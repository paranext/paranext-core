// Generated by dts-bundle-generator v9.5.1

import * as CheckboxPrimitive from '@radix-ui/react-checkbox';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import * as LabelPrimitive from '@radix-ui/react-label';
import * as PopoverPrimitive from '@radix-ui/react-popover';
import { PopoverProps } from '@radix-ui/react-popover';
import * as RadioGroupPrimitive from '@radix-ui/react-radio-group';
import * as SelectPrimitive from '@radix-ui/react-select';
import * as SeparatorPrimitive from '@radix-ui/react-separator';
import * as SliderPrimitive from '@radix-ui/react-slider';
import * as SwitchPrimitives from '@radix-ui/react-switch';
import * as TabsPrimitive from '@radix-ui/react-tabs';
import * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group';
import { ColumnDef as TSColumnDef, Row as TSRow, SortDirection as TSSortDirection, Table as TSTable } from '@tanstack/react-table';
import { ClassValue } from 'clsx';
import { LucideProps } from 'lucide-react';
import React$1 from 'react';
import { ChangeEventHandler, ComponentProps, FocusEventHandler, MouseEvent as MouseEvent$1, MouseEventHandler, MutableRefObject, PropsWithChildren, ReactNode } from 'react';
import { Toaster, toast as sonner } from 'sonner';

type Unsubscriber = () => boolean;
type UnsubscriberAsync = () => Promise<boolean>;
type PlatformEventHandler<T> = (event: T) => void;
type PlatformEvent<T> = (callback: PlatformEventHandler<T>) => Unsubscriber;
type PlatformEventAsync<T> = (callback: PlatformEventHandler<T>) => Promise<UnsubscriberAsync>;
interface ScriptureReference {
	bookNum: number;
	chapterNum: number;
	verseNum: number;
}
type ScriptureNode = ScriptureReference & {
	jsonPath: string;
};
type ScriptureTextAnchor = ScriptureNode & {
	offset: number;
};
type ScriptureSelection = {
	start: ScriptureNode | ScriptureTextAnchor;
	end?: ScriptureNode | ScriptureTextAnchor;
};
type ScrollGroupId = number;
type ReplaceType<T, A, B> = T extends A ? B : T extends object ? {
	[K in keyof T]: ReplaceType<T[K], A, B>;
} : T;
type LocalizeKey = `%${string}%`;
type ReferencedItem = `${string}.${string}`;
type OrderedItem = {
	/** Relative order of this item compared to other items in the same parent/scope (sorted ascending) */
	order: number;
};
type OrderedExtensibleContainer = OrderedItem & {
	/** Determines whether other items can be added to this after it has been defined */
	isExtensible?: boolean;
};
type MenuGroupDetailsInColumn = OrderedExtensibleContainer & {
	/** ID of column in which this group resides */
	column: ReferencedItem;
};
type MenuGroupDetailsInSubMenu = OrderedExtensibleContainer & {
	/** ID of menu item hosting the submenu in which this group resides */
	menuItem: ReferencedItem;
};
type MenuColumnWithHeader = OrderedExtensibleContainer & {
	/** Key that represents the text of the header text of the column */
	label: LocalizeKey;
};
type MenuItemBase = OrderedItem & {
	/** Menu group to which this menu item belongs */
	group: ReferencedItem;
	/** Key that represents the text of this menu item to display */
	label: LocalizeKey;
	/** Key that represents words the platform should reference when users are searching for menu items */
	searchTerms?: LocalizeKey;
	/** Key that represents the text to display if a mouse pointer hovers over the menu item */
	tooltip?: LocalizeKey;
	/** Additional information provided by developers to help people who perform localization */
	localizeNotes: string;
};
type MenuItemContainingSubmenu = MenuItemBase & {
	/** ID for this menu item that holds a submenu */
	id: ReferencedItem;
};
type MenuItemContainingCommand = MenuItemBase & {
	/** Name of the PAPI command to run when this menu item is selected. */
	command: ReferencedItem;
	/**
	 * Uri path to the icon to display after the menu text. Ex:
	 * `papi-extension://helloWorld/assets/icon.png`
	 */
	iconPathAfter?: string;
	/**
	 * Uri path to the icon to display before the menu text. Ex:
	 * `papi-extension://helloWorld/assets/icon.png`
	 */
	iconPathBefore?: string;
};
type GroupsInSingleColumnMenu = {
	/** Named menu group */
	[property: ReferencedItem]: OrderedExtensibleContainer | MenuGroupDetailsInSubMenu;
};
type GroupsInMultiColumnMenu = {
	/** Named menu group */
	[property: ReferencedItem]: MenuGroupDetailsInColumn | MenuGroupDetailsInSubMenu;
};
type ColumnsWithHeaders = {
	/** Named column of a menu */
	[property: ReferencedItem]: MenuColumnWithHeader;
	/** Defines whether columns can be added to this multi-column menu */
	isExtensible?: boolean;
};
type SingleColumnMenu = {
	/** Groups that belong in this menu */
	groups: GroupsInSingleColumnMenu;
	/** List of menu items that belong in this menu */
	items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];
};
type MultiColumnMenu = {
	/** Columns that belong in this menu */
	columns: ColumnsWithHeaders;
	/** Groups that belong in this menu */
	groups: GroupsInMultiColumnMenu;
	/** List of menu items that belong in this menu */
	items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];
};
type Localized<T> = ReplaceType<ReplaceType<T, LocalizeKey, string>, ReferencedItem, string>;
type LocalizedStringValue = string;
interface LanguageStrings {
	[k: LocalizeKey]: LocalizedStringValue;
}
export type BookChapterControlProps = {
	scrRef: ScriptureReference;
	handleSubmit: (scrRef: ScriptureReference) => void;
	getActiveBookIds?: () => string[];
};
export declare function BookChapterControl({ scrRef, handleSubmit, getActiveBookIds }: BookChapterControlProps): import("react/jsx-runtime").JSX.Element;
export type ChapterRangeSelectorProps = {
	startChapter: number;
	endChapter: number;
	handleSelectStartChapter: (chapter: number) => void;
	handleSelectEndChapter: (chapter: number) => void;
	isDisabled?: boolean;
	chapterCount: number;
};
export function ChapterRangeSelector({ startChapter, endChapter, handleSelectStartChapter, handleSelectEndChapter, isDisabled, chapterCount, }: ChapterRangeSelectorProps): import("react/jsx-runtime").JSX.Element;
export declare enum BookSelectionMode {
	CURRENT_BOOK = "current book",
	CHOOSE_BOOKS = "choose books"
}
/**
 * Object containing all keys used for localization in this component. If you're using this
 * component in an extension, you can pass it into the useLocalizedStrings hook to easily obtain the
 * localized strings and pass them into the localizedStrings prop of this component
 */
export declare const BOOK_SELECTOR_STRING_KEYS: readonly [
	"%webView_bookSelector_currentBook%",
	"%webView_bookSelector_choose%",
	"%webView_bookSelector_chooseBooks%"
];
export type BookSelectorLocalizedStrings = {
	[localizedBookSelectorKey in (typeof BOOK_SELECTOR_STRING_KEYS)[number]]?: LocalizedStringValue;
};
type BookSelectorProps = ChapterRangeSelectorProps & {
	handleBookSelectionModeChange: (newMode: BookSelectionMode) => void;
	currentBookName: string;
	onSelectBooks: () => void;
	selectedBookIds: string[];
	localizedStrings: BookSelectorLocalizedStrings;
};
export function BookSelector({ handleBookSelectionModeChange, currentBookName, onSelectBooks, selectedBookIds, chapterCount, endChapter, handleSelectEndChapter, startChapter, handleSelectStartChapter, localizedStrings, }: BookSelectorProps): import("react/jsx-runtime").JSX.Element;
export type ColumnDef<TData, TValue = unknown> = TSColumnDef<TData, TValue>;
export type RowContents<TData> = TSRow<TData>;
export type TableContents<TData> = TSTable<TData>;
export type SortDirection = TSSortDirection;
interface DataTableProps<TData, TValue> {
	columns: ColumnDef<TData, TValue>[];
	data: TData[];
	enablePagination?: boolean;
	showPaginationControls?: boolean;
	showColumnVisibilityControls?: boolean;
	stickyHeader?: boolean;
	onRowClickHandler?: (row: RowContents<TData>, table: TableContents<TData>) => void;
}
/**
 * Feature-rich table component that infuses our basic shadcn-based Table component with features
 * from TanStack's React Table library
 */
export declare function DataTable<TData, TValue>({ columns, data, enablePagination, showPaginationControls, showColumnVisibilityControls, stickyHeader, onRowClickHandler, }: DataTableProps<TData, TValue>): import("react/jsx-runtime").JSX.Element;
type Status = "approved" | "unapproved" | "unknown";
/** Occurrence of item in inventory. Primarily used by table that shows occurrences */
export type InventoryItemOccurrence = {
	/** Reference to scripture where the item appears */
	reference: ScriptureReference;
	/** Snippet of scripture that contains the occurrence */
	text: string;
};
/** Data structure that contains all information on an item that is shown in an inventory */
export type InventoryTableData = {
	/**
	 * The item (e.g. a character in the characters inventory, a marker in the marker inventory) In
	 * most cases the array will only have one element. In case of additional items (e.g. the
	 * preceding marker in the markers check), the primary item should be stored in the first index.
	 * To show additional items in the inventory, make sure to configure the `additionalItemsLabels`
	 * prop for the Inventory component
	 */
	items: string[];
	/** The number of times this item occurs in the selected scope */
	count: number;
	/** The status of this item (see documentation for `Status` type for more information) */
	status: Status;
	/** Occurrences of this item in the scripture text for the selected scope */
	occurrences: InventoryItemOccurrence[];
};
/**
 * Splits USFM string into shorter line-like segments
 *
 * @param text A single (likely very large) USFM string
 * @returns An array containing the input text, split into shorter segments
 */
export declare const getLinesFromUSFM: (text: string) => string[];
/**
 * Extracts chapter or verse number from USFM strings that start with a \c or \v marker
 *
 * @param text USFM string that is expected to start with \c or \v marker
 * @returns Chapter or verse number if one is found. Else returns 0.
 */
export declare const getNumberFromUSFM: (text: string) => number | undefined;
/**
 * Gets book ID from USFM string that starts with the \id marker, and returns book number for it
 *
 * @param text USFM string that is expected to start with \id marker
 * @returns Book number corresponding to the \id marker in the input text. Returns 0 if no marker is
 *   found or the marker is not valid
 */
export declare const getBookNumFromId: (text: string) => number;
/**
 * Gets the status for an item, typically used in the Inventory component
 *
 * @param item The item for which the status is being requested
 * @param approvedItems Array of approved items, typically as defined in `Settings.xml`
 * @param unapprovedItems Array of unapproved items, typically as defined in `Settings.xml`
 * @returns The status for the specified item
 */
export declare const getStatusForItem: (item: string, approvedItems: string[], unapprovedItems: string[]) => Status;
/**
 * Object containing all keys used for localization in this component. If you're using this
 * component in an extension, you can pass it into the useLocalizedStrings hook to easily obtain the
 * localized strings and pass them into the localizedStrings prop of this component
 */
export declare const INVENTORY_STRING_KEYS: readonly [
	"%webView_inventory_all%",
	"%webView_inventory_approved%",
	"%webView_inventory_unapproved%",
	"%webView_inventory_unknown%",
	"%webView_inventory_scope_currentBook%",
	"%webView_inventory_scope_chapter%",
	"%webView_inventory_scope_verse%",
	"%webView_inventory_filter_text%",
	"%webView_inventory_show_additional_items%",
	"%webView_inventory_occurrences_table_header_reference%",
	"%webView_inventory_occurrences_table_header_occurrence%"
];
export type InventoryLocalizedStrings = {
	[localizedInventoryKey in (typeof INVENTORY_STRING_KEYS)[number]]?: LocalizedStringValue;
};
/** Scope of scripture that the inventory can operate on */
export type Scope = "book" | "chapter" | "verse";
type AdditionalItemsLabels = {
	checkboxText?: string;
	tableHeaders?: string[];
};
type InventoryProps = {
	/** The scripture reference that the application is currently set to */
	scriptureReference: ScriptureReference;
	/** Callback function that is executed when the scripture reference is changed */
	setScriptureReference: (scriptureReference: ScriptureReference) => void;
	/**
	 * Object with all localized strings that the Inventory needs to work well across multiple
	 * languages. When using this component with Platform.Bible, you can import
	 * `INVENTORY_STRING_KEYS` from this library, pass it in to the Platform's localization hook, and
	 * pass the localized keys that are returned by the hook into this prop.
	 */
	localizedStrings: InventoryLocalizedStrings;
	/**
	 * The logic that finds the desired items in the source text. This can either be a Regular
	 * expression that captures one or multiple items (preferred), or a custom function that builds
	 * and return an InventoryDataTable[] manually. Note: In case the logic captures more than one
	 * item (i.e. InventoryTableData.items has a length greater than 1), you must provide text labels
	 * for the related columns and control elements to show by setting the `additionalItemsLabels`
	 * prop
	 */
	extractItems: RegExp | ((text: string | undefined, scriptureRef: ScriptureReference, approvedItems: string[], unapprovedItems: string[]) => InventoryTableData[]);
	/**
	 * Text labels for control elements and additional column headers in case your Inventory has more
	 * than one item to show (e.g. The 'Preceding Marker' in the Markers Inventory)
	 */
	additionalItemsLabels?: AdditionalItemsLabels;
	/** Array of approved items, typically as defined in `Settings.xml` */
	approvedItems: string[];
	/** Array of unapproved items, typically as defined in `Settings.xml` */
	unapprovedItems: string[];
	/** The source scripture text that is searched for in inventory items */
	text: string | undefined;
	/** Scope of scripture that the inventory will operate on */
	scope: Scope;
	/** Callback function that is executed when the scope is changed from the Inventory */
	onScopeChange: (scope: Scope) => void;
	/**
	 * Column definitions for the Inventory data table. The most commonly used column definitions are
	 * pre-configured for your convenience and can be imported (e.g. inventoryItemColumn,
	 * inventoryAdditionalItemColumn inventoryCountColumn, and inventoryStatusColumn). If you need any
	 * other columns you can add these yourself
	 */
	columns: ColumnDef<InventoryTableData>[];
};
/** Inventory component that is used to view and control the status of provided project settings */
export function Inventory({ scriptureReference, setScriptureReference, localizedStrings, extractItems, additionalItemsLabels, approvedItems, unapprovedItems, text, scope, onScopeChange, columns, }: InventoryProps): import("react/jsx-runtime").JSX.Element;
/**
 * Function that creates the item column for inventories
 *
 * @param itemLabel Localized label for the item column (e.g. 'Character', 'Repeated Word', etc.)
 * @returns Column that shows the inventory items. Should be used with the DataTable component
 */
export declare const inventoryItemColumn: (itemLabel: string) => ColumnDef<InventoryTableData>;
/**
 * Function that creates the count column for inventories. Should be used with the DataTable
 * component.
 *
 * @param countLabel Localized label for the count column
 * @returns Column that shows the number of occurrences of the related inventory items
 */
export declare const inventoryCountColumn: (countLabel: string) => ColumnDef<InventoryTableData>;
/**
 * Function that creates the status column for inventories. Should be used with the DataTable
 * component.
 *
 * @param statusLabel Localized label for the status column
 * @param approvedItems Array of approved items, typically as defined in `Settings.xml`
 * @param onApprovedItemsChange Callback function that stores the updated list of approved items
 * @param unapprovedItems Array of unapproved items, typically as defined in `Settings.xml`
 * @param onUnapprovedItemsChange Callback function that stores the updated list of unapproved items
 * @returns Column that shows the status buttons for the related inventory item. The button for the
 *   current status of the item is selected
 */
export declare const inventoryStatusColumn: (statusLabel: string, approvedItems: string[], onApprovedItemsChange: (items: string[]) => void, unapprovedItems: string[], onUnapprovedItemsChange: (items: string[]) => void) => ColumnDef<InventoryTableData>;
export type MultiSelectComboBoxEntry = {
	value: string;
	label: string;
	starred?: boolean;
};
interface MultiSelectComboBoxProps {
	entries: MultiSelectComboBoxEntry[];
	getEntriesCount?: (option: MultiSelectComboBoxEntry) => number;
	selected: string[];
	onChange: (values: string[]) => void;
	placeholder: string;
	commandEmptyMessage?: string;
	customSelectedText?: string;
	sortSelected?: boolean;
	icon?: React$1.ReactNode;
	className?: string;
}
export declare function MultiSelectComboBox({ entries, getEntriesCount, selected, onChange, placeholder, commandEmptyMessage, customSelectedText, sortSelected, icon, className, }: MultiSelectComboBoxProps): import("react/jsx-runtime").JSX.Element;
export type TabKeyValueContent = {
	key: string;
	value: string;
	content: React$1.ReactNode;
};
type TabNavigationContentSearchProps = {
	/** List of values and keys for each tab this component should provide */
	tabList: TabKeyValueContent[];
	/** The search query in the search bar */
	searchValue: string;
	/** Handler to run when the value of the search bar changes */
	onSearch: (searchQuery: string) => void;
	/** Optional placeholder for the search bar */
	searchPlaceholder?: string;
	/** Optional title to include in the header */
	headerTitle?: string;
	/** Optional className to modify the search input */
	searchClassName?: string;
};
declare function TabNavigationContentSearch({ tabList, searchValue, onSearch, searchPlaceholder, headerTitle, searchClassName, }: TabNavigationContentSearchProps): import("react/jsx-runtime").JSX.Element;
export type SelectedSettingsSidebarItem = {
	label: string;
	projectId?: string;
};
export type ProjectInfo = {
	projectId: string;
	projectName: string;
};
export type SettingsSidebarProps = {
	/** Optional id for testing */
	id?: string;
	/** Extension labels from contribution */
	extensionLabels: string[];
	/** Project names and ids */
	projectInfo: ProjectInfo[];
	/** Handler for selecting a sidebar item */
	handleSelectSidebarItem: (key: string, projectId?: string) => void;
	/** The current selected value in the sidebar */
	selectedSidebarItem: SelectedSettingsSidebarItem;
	/** Label for the group of extensions setting groups */
	extensionsSidebarGroupLabel: string;
	/** Label for the group of projects settings */
	projectsSidebarGroupLabel: string;
	/** Placeholder text for the button */
	buttonPlaceholderText: string;
};
export function SettingsSidebar({ id, extensionLabels, projectInfo, handleSelectSidebarItem, selectedSidebarItem, extensionsSidebarGroupLabel, projectsSidebarGroupLabel, buttonPlaceholderText, }: SettingsSidebarProps): import("react/jsx-runtime").JSX.Element;
type SettingsSidebarContentSearchProps = SettingsSidebarProps & React$1.PropsWithChildren & {
	/** Optional id for testing */
	id?: string;
	/** The search query in the search bar */
	searchValue: string;
	/** Handler to run when the value of the search bar changes */
	onSearch: (searchQuery: string) => void;
};
export function SettingsSidebarContentSearch({ id, extensionLabels, projectInfo, children, handleSelectSidebarItem, selectedSidebarItem, searchValue, onSearch, extensionsSidebarGroupLabel, projectsSidebarGroupLabel, buttonPlaceholderText, }: SettingsSidebarContentSearchProps): import("react/jsx-runtime").JSX.Element;
/**
 * Information (e.g., a checking error or some other type of "transient" annotation) about something
 * noteworthy at a specific place in an instance of the Scriptures.
 */
export type ScriptureItemDetail = ScriptureSelection & {
	/**
	 * Text of the error, note, etc. In the future, we might want to support something more than just
	 * text so that a JSX element could be provided with a link or some other controls related to the
	 * issue being reported.
	 */
	detail: string;
};
/**
 * A uniquely identifiable source of results that can be displayed in the ScriptureResultsViewer.
 * Generally, the source will be a particular Scripture check, but there may be other types of
 * sources.
 */
export type ResultsSource = {
	/**
	 * Uniquely identifies the source.
	 *
	 * @type {string}
	 */
	id: string;
	/**
	 * Name (potentially localized) of the source, suitable for display in the UI.
	 *
	 * @type {string}
	 */
	displayName: string;
};
export type ScriptureSrcItemDetail = ScriptureItemDetail & {
	/** Source/type of detail. Can be used for grouping. */
	source: ResultsSource;
};
/**
 * Represents a set of results keyed by Scripture reference. Generally, the source will be a
 * particular Scripture check, but this type also allows for other types of uniquely identifiable
 * sources.
 */
export type ResultsSet = {
	/**
	 * The backing source associated with this set of results.
	 *
	 * @type {ResultsSource}
	 */
	source: ResultsSource;
	/**
	 * Array of Scripture item details (messages keyed by Scripture reference).
	 *
	 * @type {ScriptureItemDetail[]}
	 */
	data: ScriptureItemDetail[];
};
export type ScriptureResultsViewerColumnInfo = {
	/** Optional header to display for the Reference column. Default value: 'Scripture Reference'. */
	scriptureReferenceColumnName?: string;
	/** Optional text to display to refer to the Scripture book group. Default value: 'Scripture Book'. */
	scriptureBookGroupName?: string;
	/** Optional header to display for the Type column. Default value: 'Type'. */
	typeColumnName?: string;
	/** Optional header to display for the Details column. Default value: 'Details' */
	detailsColumnName?: string;
};
export type ScriptureResultsViewerProps = ScriptureResultsViewerColumnInfo & {
	/** Groups of ScriptureItemDetail objects from particular sources (e.g., Scripture checks) */
	sources: ResultsSet[];
	/** Flag indicating whether to display column headers. Default is false. */
	showColumnHeaders?: boolean;
	/** Flag indicating whether to display source column. Default is false. */
	showSourceColumn?: boolean;
	/** Callback function to notify when a row is selected */
	onRowSelected?: (selectedRow: ScriptureSrcItemDetail | undefined) => void;
};
/**
 * Component to display a combined list of detailed items from one or more sources, where the items
 * are keyed primarily by Scripture reference. This is particularly useful for displaying a list of
 * results from Scripture checks, but more generally could be used to display any "results" from any
 * source(s). The component allows for grouping by Scripture book, source, or both. By default, it
 * displays somewhat "tree-like" which allows it to be more horizontally compact and intuitive. But
 * it also has the option of displaying as a traditional table with column headings (with or without
 * the source column showing).
 */
export function ScriptureResultsViewer({ sources, showColumnHeaders, showSourceColumn, scriptureReferenceColumnName, scriptureBookGroupName, typeColumnName, detailsColumnName, onRowSelected, }: ScriptureResultsViewerProps): import("react/jsx-runtime").JSX.Element;
export type ScrollGroupSelectorProps = {
	/**
	 * List of scroll group ids to show to the user. Either a {@link ScrollGroupId} or `undefined` for
	 * no scroll group
	 */
	availableScrollGroupIds: (ScrollGroupId | undefined)[];
	/** Currently selected scroll group id. `undefined` for no scroll group */
	scrollGroupId: ScrollGroupId | undefined;
	/** Callback function run when the user tries to change the scroll group id */
	onChangeScrollGroupId: (newScrollGroupId: ScrollGroupId | undefined) => void;
	/**
	 * Localized strings to use for displaying scroll group ids. Must be an object whose keys are
	 * `getLocalizeKeyForScrollGroupId(scrollGroupId)` for all scroll group ids (and `undefined` if
	 * included) in {@link ScrollGroupSelectorProps.availableScrollGroupIds} and whose values are the
	 * localized strings to use for those scroll group ids.
	 *
	 * Defaults to English localizations of English alphabet for scroll groups 0-25 (e.g. 0 is A) and
	 * Ø for `undefined`. Will fill in any that are not provided with these English localizations.
	 * Also, if any values match the keys, the English localization will be used. This is useful in
	 * case you want to pass in a temporary version of the localized strings while your localized
	 * strings load.
	 *
	 * @example
	 *
	 * ```typescript
	 * const myScrollGroupIdLocalizedStrings = {
	 *   [getLocalizeKeyForScrollGroupId('undefined')]: 'Ø',
	 *   [getLocalizeKeyForScrollGroupId(0)]: 'A',
	 *   [getLocalizeKeyForScrollGroupId(1)]: 'B',
	 *   [getLocalizeKeyForScrollGroupId(2)]: 'C',
	 *   [getLocalizeKeyForScrollGroupId(3)]: 'D',
	 *   [getLocalizeKeyForScrollGroupId(4)]: 'E',
	 * };
	 * ```
	 *
	 * @example
	 *
	 * ```tsx
	 * const availableScrollGroupIds = [undefined, 0, 1, 2, 3, 4];
	 *
	 * const localizeKeys = getLocalizeKeysForScrollGroupIds();
	 *
	 * const [localizedStrings] = useLocalizedStrings(localizeKeys);
	 *
	 * ...
	 *
	 * <ScrollGroupSelector localizedStrings={localizedStrings} />
	 * ```
	 */
	localizedStrings?: LanguageStrings;
};
/** Selector component for choosing a scroll group */
export function ScrollGroupSelector({ availableScrollGroupIds, scrollGroupId, onChangeScrollGroupId, localizedStrings, }: ScrollGroupSelectorProps): import("react/jsx-runtime").JSX.Element;
type SettingsListProps = React$1.PropsWithChildren;
/**
 * SettingsList component is a wrapper for list items. Rendered with a formatted div
 *
 * @param children To populate the list with
 * @returns Formatted div encompassing the children
 */
export declare function SettingsList({ children }: SettingsListProps): import("react/jsx-runtime").JSX.Element;
type SettingsListItemProps = React$1.PropsWithChildren & {
	/** Primary text of the list item */
	primary: string;
	/** Optional text of the list item */
	secondary?: string | undefined;
	/** Optional boolean to display a message if the children aren't loaded yet. Defaults to false */
	isLoading?: boolean;
	/** Optional message to display if isLoading */
	loadingMessage?: string;
};
/**
 * SettingsListItem component is a common list item. Rendered with a formatted div
 *
 * @param SettingsListItemProps
 * @returns Formatted div encompassing the list item content
 */
export declare function SettingsListItem({ primary, secondary, children, isLoading, loadingMessage, }: SettingsListItemProps): import("react/jsx-runtime").JSX.Element;
type SettingsListHeaderProps = {
	/** The primary text of the list header */
	primary: string;
	/** Optional secondary text of the list header */
	secondary?: string | undefined;
	/** Optional boolean to include a separator underneath the secondary text. Defaults to false */
	includeSeparator?: boolean;
};
/**
 * SettingsListHeader component displays text above the list
 *
 * @param SettingsListHeaderProps
 * @returns Formatted div with list header content
 */
export declare function SettingsListHeader({ primary, secondary, includeSeparator, }: SettingsListHeaderProps): import("react/jsx-runtime").JSX.Element;
export type ChecklistProps = {
	/** Optional string representing the id attribute of the Checklist */
	id?: string;
	/** Optional string representing CSS class name(s) for styling */
	className?: string;
	/** Array of strings representing the checkable items */
	listItems: string[];
	/** Array of strings representing the checked items */
	selectedListItems: string[];
	/**
	 * Function that is called when a checkbox item is selected or deselected
	 *
	 * @param item The string description for this item
	 * @param selected True if selected, false if not selected
	 */
	handleSelectListItem: (item: string, selected: boolean) => void;
	/**
	 * Optional function creates a label for a provided checkable item
	 *
	 * @param item The item for which a label is to be created
	 * @returns A string representing the label text for the checkbox associated with that item
	 */
	createLabel?: (item: string) => string;
};
/** Renders a list of checkboxes. Each checkbox corresponds to an item from the `listItems` array. */
export function Checklist({ id, className, listItems, selectedListItems, handleSelectListItem, createLabel, }: ChecklistProps): import("react/jsx-runtime").JSX.Element;
type ClassValue$1 = ClassValue;
type ClassProp = {
	class: ClassValue$1;
	className?: never;
} | {
	class?: never;
	className: ClassValue$1;
} | {
	class?: never;
	className?: never;
};
type OmitUndefined<T> = T extends undefined ? never : T;
type VariantProps<Component extends (...args: any) => any> = Omit<OmitUndefined<Parameters<Component>[0]>, "class" | "className">;
/**
 * Style variants for the Button component.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/button}
 */
export declare const buttonVariants: (props?: ({
	variant?: "link" | "default" | "outline" | "destructive" | "secondary" | "ghost" | null | undefined;
	size?: "default" | "icon" | "sm" | "lg" | null | undefined;
} & ClassProp) | undefined) => string;
/**
 * Props for Button component
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/button}
 */
export interface ButtonProps extends React$1.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}
/**
 * The Button component displays a button or a component that looks like a button. The component is
 * built and styled by Shadcn UI.
 *
 * @param ButtonProps
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/button}
 */
export declare const Button: React$1.ForwardRefExoticComponent<ButtonProps & React$1.RefAttributes<HTMLButtonElement>>;
export type ComboBoxLabelOption = {
	label: string;
};
export type ComboBoxOption = string | number | ComboBoxLabelOption;
export type ComboBoxProps<T> = {
	/** Optional unique identifier */
	id?: string;
	/** Text label title for combobox */
	/** List of available options for the dropdown menu */
	options?: readonly T[];
	/** @deprecated 3 December 2024. Renamed to {@link buttonClassName} */
	className?: string;
	/** Additional css classes to help with unique styling of the combo box button */
	buttonClassName?: string;
	/** Additional css classes to help with unique styling of the combo box popover */
	popoverContentClassName?: string;
	/**
	 * The selected value that the combo box currently holds. Must be shallow equal to one of the
	 * options entries.
	 */
	value?: T;
	/** Triggers when content of textfield is changed */
	onChange?: (newValue: T) => void;
	/** Used to determine the string value for a given option. */
	getOptionLabel?: (option: ComboBoxOption) => string;
	/** Icon to be displayed on the trigger */
	icon?: React$1.ReactNode;
	/** Text displayed on button if `value` is undefined */
	buttonPlaceholder?: string;
	/** Placeholder text for text field */
	textPlaceholder?: string;
	/** Text to display when no options match input */
	commandEmptyMessage?: string;
	/** Variant of button */
	buttonVariant?: ButtonProps["variant"];
	/** Control how the popover menu should be aligned. Defaults to start */
	alignDropDown?: "start" | "center" | "end";
	/** Optional boolean to set if trigger should be disabled */
	isDisabled?: boolean;
} & PopoverProps;
/**
 * Autocomplete input and command palette with a list of suggestions.
 *
 * Thanks to Shadcn for heavy inspiration and documentation
 * https://ui.shadcn.com/docs/components/combobox
 */
export declare function ComboBox<T extends ComboBoxOption = ComboBoxOption>({ id, options, className, buttonClassName, popoverContentClassName, value, onChange, getOptionLabel, icon, buttonPlaceholder, textPlaceholder, commandEmptyMessage, buttonVariant, alignDropDown, isDisabled, ...props }: ComboBoxProps<T>): import("react/jsx-runtime").JSX.Element;
type MenuItemInfoBase = {
	/** Text (displayable in the UI) as the name of the menu item */
	label: string;
	/** Text to display when the mouse hovers over the menu item */
	tooltip?: string;
};
export type Command = MenuItemInfoBase & {
	/** Command to execute (string.string) */
	command: string;
};
type SubMenu = MenuItemInfoBase & {
	/** Command to execute (string.string) */
	items: MenuItemInfo[];
};
export interface CommandHandler {
	(command: Command): void;
}
type MenuPropsBase = {
	menuDefinition: Localized<SingleColumnMenu>;
	commandHandler: CommandHandler;
	/**
	 * Additional action to perform when any menu item is clicked. Allows the caller to handle event
	 * (e.g., to close the menu).
	 */
	onClick?: (event: React$1.MouseEvent<HTMLElement>) => void;
};
export type MenuItemListProps = MenuPropsBase & {
	/** Optional unique (column) identifier */
	columnId?: ReferencedItem;
};
type MenuItemProps = Omit<MenuItemInfo, "command"> & React$1.PropsWithChildren<{
	/** Optional unique identifier */
	id?: string;
	onClick: (event: React$1.MouseEvent<HTMLElement>) => void;
}>;
type MenuItemInfo = (Command | SubMenu) & {
	/**
	 * If specified, menu item will be inset if it does not have a leading icon.
	 *
	 * @default true
	 */
	allowForLeadingIcons?: boolean;
	/**
	 * If specified, the path to the icon image to display on the leading side of the menu text.
	 *
	 * @default undefined (no leading icon will be shown)
	 */
	iconPathBefore?: string;
	/**
	 * If specified, the path to the icon image to display on the trailing side of the menu text.
	 *
	 * @default undefined (no trailing icon will be shown)
	 */
	iconPathAfter?: string;
	/**
	 * If true, list item is focused during the first mount
	 *
	 * @default false
	 */
	hasAutoFocus?: boolean;
	/** Additional css classes to help with unique styling of the menu item */
	className?: string;
	/**
	 * If true, the menu item will appear disabled and it will not respond to clicks or mouse hovers.
	 *
	 * @default false
	 */
	isDisabled?: boolean;
	/**
	 * If true, compact vertical padding designed for keyboard and mouse input is used.
	 *
	 * @default true
	 */
	isDense?: boolean;
	/**
	 * If true, a right-arrow icon will be displayed (iconPathAfter, if specified, will be ignored).
	 *
	 * @default false
	 */
	isSubMenuParent?: boolean;
	/**
	 * If true, the left and right padding is removed
	 *
	 * @default false
	 */
	hasDisabledGutters?: boolean;
	/**
	 * If true, a 1px light border is added to bottom of menu item
	 *
	 * @default false
	 */
	hasDivider?: boolean;
	/** Help identify which element has keyboard focus */
	focusVisibleClassName?: string;
	/** If it's a submenu, it should have the items property */
	items?: MenuItemInfo[];
};
export function MenuItem(props: MenuItemProps): import("react/jsx-runtime").JSX.Element;
export type GridMenuInfo = {
	/** The menu object containing information about the columns, groups, and items to display. */
	multiColumnMenu: Localized<MultiColumnMenu>;
};
export type GridMenuProps = GridMenuInfo & {
	/** Optional unique identifier */
	id?: string;
	commandHandler: CommandHandler;
	/** Additional css classes to help with unique styling of the grid menu */
	className?: string;
};
export function GridMenu({ commandHandler, className, multiColumnMenu, id, }: GridMenuProps): import("react/jsx-runtime").JSX.Element;
export interface MultiColumnMenuProvider {
	(isSupportAndDevelopment: boolean): Promise<Localized<MultiColumnMenu>>;
}
type HamburgerMenuButtonProps = React$1.PropsWithChildren & {
	/** The handler to use for menu commands (and eventually toolbar commands). */
	commandHandler: CommandHandler;
	/**
	 * Optional reference to the "div" container that determines the where the menu should appear. If
	 * not defined, then (1,1) used.
	 */
	containerRef?: React$1.MutableRefObject<HTMLDivElement>;
	/**
	 * The delegate to use to get the menu data. If not specified or if it returns undefined, the data
	 * in normalMenu or fullMenu property will be used.
	 */
	menuProvider?: MultiColumnMenuProvider;
	/**
	 * The menu data to show when the menu is opened if the menuProvider property is not defined.
	 * (This allows for a default or test-only static menu to be used.)
	 */
	normalMenu?: Localized<MultiColumnMenu>;
	/**
	 * The menu data to show for "full" menu (when opened with the SHIFT key pressed) if the
	 * menuProvider property is not defined. (This allows for a default or test-only static menu to be
	 * used.)
	 */
	fullMenu?: Localized<MultiColumnMenu>;
	/** Additional css class(es) to help with unique styling of the sub-components */
	className?: string;
	/** Value to use as prefix for ARIA labels on interactive sub-components */
	ariaLabelPrefix?: string;
};
export function HamburgerMenuButton({ menuProvider, normalMenu, fullMenu, commandHandler, containerRef, className, ariaLabelPrefix, children, }: HamburgerMenuButtonProps): import("react/jsx-runtime").JSX.Element;
export type IconButtonProps = React$1.PropsWithChildren<{
	/** Optional unique identifier */
	id?: string;
	/**
	 * Required. Used as both the tooltip (aka, title) and the aria-label (used for accessibility,
	 * testing, etc.), unless a distinct tooltip is supplied.
	 */
	label: string;
	/**
	 * Enabled status of button
	 *
	 * @default false
	 */
	isDisabled?: boolean;
	/** Optional tooltip to display if different from the aria-label. */
	tooltip?: string;
	/** If true, no tooltip will be displayed. */
	isTooltipSuppressed?: boolean;
	/**
	 * If given, uses a negative margin to counteract the padding on one side (this is often helpful
	 * for aligning the left or right side of the icon with content above or below, without ruining
	 * the border size and shape).
	 *
	 * @default false
	 */
	adjustMarginToAlignToEdge?: "end" | "start" | false;
	/**
	 * The size of the component. small is equivalent to the dense button styling.
	 *
	 * @default false
	 */
	size: "small" | "medium" | "large";
	/** Additional css classes to help with unique styling of the button */
	className?: string;
	/** Optional click handler */
	onClick?: React$1.MouseEventHandler<HTMLButtonElement>;
}>;
/**
 * Iconic button a user can click to do something
 *
 * Thanks to MUI for heavy inspiration and documentation
 * https://mui.com/material-ui/getting-started/overview/
 */
export declare function IconButton({ id, label, isDisabled, tooltip, isTooltipSuppressed, adjustMarginToAlignToEdge, size, className, onClick, children, }: IconButtonProps): import("react/jsx-runtime").JSX.Element;
/** Props for the SearchBar component. */
export type SearchBarProps = {
	/** Seach query for the search bar */
	value: string;
	/**
	 * Callback fired to handle the search query is updated
	 *
	 * @param searchQuery
	 */
	onSearch: (searchQuery: string) => void;
	/** Optional string that appears in the search bar without a search string */
	placeholder?: string;
	/** Optional boolean to set the input base to full width */
	isFullWidth?: boolean;
	/** Additional css classes to help with unique styling of the search bar */
	className?: string;
};
export function SearchBar({ value, onSearch, placeholder, isFullWidth, className, }: SearchBarProps): import("react/jsx-runtime").JSX.Element;
export type SpinnerProps = LucideProps;
export declare const Spinner: import("react").ForwardRefExoticComponent<Omit<LucideProps, "ref"> & import("react").RefAttributes<SVGSVGElement>>;
export type TextFieldProps = {
	/** Optional unique identifier */
	id?: string;
	/**
	 * If `true`, the component is disabled.
	 *
	 * @default false
	 */
	isDisabled?: boolean;
	/**
	 * If `true`, the label is displayed in an error state.
	 *
	 * @default false
	 */
	hasError?: boolean;
	/**
	 * If `true`, the input will take up the full width of its container.
	 *
	 * @default false
	 */
	isFullWidth?: boolean;
	/** Text that gives the user instructions on what contents the TextField expects */
	helperText?: string;
	/** The title of the TextField */
	label?: string;
	/** The short hint displayed in the `input` before the user enters a value. */
	placeholder?: string;
	/**
	 * If `true`, the label is displayed as required and the `input` element is required.
	 *
	 * @default false
	 */
	isRequired?: boolean;
	/** Additional css classes to help with unique styling of the text field */
	className?: string;
	/** Starting value for the text field if it is not controlled */
	defaultValue?: string | number;
	/** Value of the text field if controlled */
	value?: string | number;
	/** Triggers when content of textfield is changed */
	onChange?: React$1.ChangeEventHandler<HTMLInputElement>;
	/** Triggers when textfield gets focus */
	onFocus?: React$1.FocusEventHandler<HTMLInputElement>;
	/** Triggers when textfield loses focus */
	onBlur?: React$1.FocusEventHandler<HTMLInputElement>;
};
/**
 * Text input field
 *
 * Thanks to Shadcn for heavy inspiration and documentation
 * https://ui.shadcn.com/docs/components/input#with-label
 */
export declare function TextField({ id, isDisabled, hasError, isFullWidth, helperText, label, placeholder, isRequired, className, defaultValue, value, onChange, onFocus, onBlur, }: TextFieldProps): import("react/jsx-runtime").JSX.Element;
export type ToolbarProps = React$1.PropsWithChildren<{
	/** The handler to use for menu commands (and eventually toolbar commands). */
	commandHandler: CommandHandler;
	/**
	 * The optional delegate to use to get the menu data. If not specified, the "hamburger" menu will
	 * not display.
	 */
	menuProvider?: MultiColumnMenuProvider;
	/** Optional unique identifier */
	id?: string;
	/** Additional css classes to help with unique styling of the toolbar */
	className?: string;
}>;
export function Toolbar({ menuProvider, commandHandler, className, id, children, }: ToolbarProps): import("react/jsx-runtime").JSX.Element;
/**
 * The Alert displays a callout for user attention. The component is built and styled by Shadcn UI.
 *
 * @see Shadcn UI Documentation https://ui.shadcn.com/docs/components/alert
 */
export declare const Alert: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & VariantProps<(props?: ({
	variant?: "default" | "destructive" | null | undefined;
} & ClassProp) | undefined) => string> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc Alert
 * @see Shadcn UI Documentation https://ui.shadcn.com/docs/components/alert
 */
export declare const AlertTitle: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLHeadingElement> & React$1.RefAttributes<HTMLParagraphElement>>;
/**
 * @inheritdoc Alert
 * @see Shadcn UI Documentation https://ui.shadcn.com/docs/components/alert
 */
export declare const AlertDescription: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLParagraphElement> & React$1.RefAttributes<HTMLParagraphElement>>;
/**
 * Style variants for the Badge component.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/badge}
 */
export declare const badgeVariants: (props?: ({
	variant?: "default" | "outline" | "muted" | "destructive" | "secondary" | "blueIndicator" | "mutedIndicator" | null | undefined;
} & ClassProp) | undefined) => string;
/**
 * Props for the Badge component.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/badge}
 */
export interface BadgeProps extends React$1.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {
}
/**
 * The Badge component displays a badge or a component that looks like a badge. The component is
 * built and styled by Shadcn UI.
 *
 * @param BadgeProps
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/badge}
 */
export declare function Badge({ className, variant, ...props }: BadgeProps): import("react/jsx-runtime").JSX.Element;
/**
 * The Card component displays a card with header, content, and footer. This component is built and
 * styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/card}
 */
export declare const Card: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc Card
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/card}
 */
export declare const CardHeader: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc Card
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/card}
 */
export declare const CardTitle: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLHeadingElement> & React$1.RefAttributes<HTMLParagraphElement>>;
/**
 * @inheritdoc Card
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/card}
 */
export declare const CardDescription: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLParagraphElement> & React$1.RefAttributes<HTMLParagraphElement>>;
/**
 * @inheritdoc Card
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/card}
 */
export declare const CardContent: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc Card
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/card}
 */
export declare const CardFooter: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * Checkbox component provides a control that allows the user to toggle between checked and not
 * checked. This components is built on Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/checkbox}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/checkbox}
 */
export declare const Checkbox: React$1.ForwardRefExoticComponent<Omit<CheckboxPrimitive.CheckboxProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/**
 * Dropdown Menu components providing accessible dropdown menus and submenus. These components are
 * built on Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenu: React$1.FC<DropdownMenuPrimitive.DropdownMenuProps>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuTrigger: React$1.ForwardRefExoticComponent<DropdownMenuPrimitive.DropdownMenuTriggerProps & React$1.RefAttributes<HTMLButtonElement>>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuGroup: React$1.ForwardRefExoticComponent<DropdownMenuPrimitive.DropdownMenuGroupProps & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuPortal: React$1.FC<DropdownMenuPrimitive.DropdownMenuPortalProps>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuSub: React$1.FC<DropdownMenuPrimitive.DropdownMenuSubProps>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuRadioGroup: React$1.ForwardRefExoticComponent<DropdownMenuPrimitive.DropdownMenuRadioGroupProps & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export type DropdownMenuSubTriggerProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
	className?: string;
	inset?: boolean;
};
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export type DropdownMenuSubContentProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent> & {
	className?: string;
};
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export type DropdownMenuContentProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content> & {
	className?: string;
	sideOffset?: number;
};
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export type DropdownMenuItemProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
	className?: string;
	inset?: boolean;
};
/** @inheritDoc DropdownMenu @group DropdownMenu */
export type DropdownMenuCheckboxItemProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem> & {
	className?: string;
	checked?: boolean;
};
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export type DropdownMenuRadioItemProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem> & {
	className?: string;
};
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export type DropdownMenuLabelProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
	className?: string;
	inset?: boolean;
};
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export type DropdownMenuSeparatorProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator> & {
	className?: string;
};
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export type DropdownMenuShortcutProps = React$1.HTMLAttributes<HTMLSpanElement> & {
	className?: string;
};
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuSubTrigger: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuSubTriggerProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
	inset?: boolean | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuSubContent: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuSubContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuContent: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
	sideOffset?: number | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuItem: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
	inset?: boolean | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuCheckboxItem: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuCheckboxItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
	checked?: boolean | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuRadioItem: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuRadioItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuLabel: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuLabelProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
	inset?: boolean | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritDoc DropdownMenu
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare const DropdownMenuSeparator: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuSeparatorProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/dropdown-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/dropdown-menu}
 */
export declare function DropdownMenuShortcut({ className, ...props }: DropdownMenuShortcutProps): import("react/jsx-runtime").JSX.Element;
export declare namespace DropdownMenuShortcut {
	var displayName: string;
}
interface InputProps extends React$1.InputHTMLAttributes<HTMLInputElement> {
}
/**
 * Input component displays a form input field or a component that looks like an input field. This
 * components is built and styled with Shadcn UI.
 *
 * @param InputProps
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/input}
 */
export declare const Input: React$1.ForwardRefExoticComponent<InputProps & React$1.RefAttributes<HTMLInputElement>>;
/**
 * The Label component renders an accessible label associated with controls. This components is
 * built on Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/label}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/label}
 */
export declare const Label: React$1.ForwardRefExoticComponent<Omit<LabelPrimitive.LabelProps & React$1.RefAttributes<HTMLLabelElement>, "ref"> & VariantProps<(props?: ClassProp | undefined) => string> & React$1.RefAttributes<HTMLLabelElement>>;
/**
 * The Popover component displays rich content in a portal, triggered by a button. This popover is
 * built on Radix UI's Popover component and styled by Shadcn UI.
 *
 * @see Shadcn UI Documentation {@link https://ui.shadcn.com/docs/components/popover}
 * @see Radix UI Documentation {@link https://www.radix-ui.com/docs/primitives/components/popover}
 */
export declare const Popover: React$1.FC<PopoverPrimitive.PopoverProps>;
/**
 * @inheritdoc Popover
 * @see Shadcn UI Documentation {@link https://ui.shadcn.com/docs/components/popover}
 * @see Radix UI Documentation {@link https://www.radix-ui.com/docs/primitives/components/popover}
 */
export declare const PopoverTrigger: React$1.ForwardRefExoticComponent<PopoverPrimitive.PopoverTriggerProps & React$1.RefAttributes<HTMLButtonElement>>;
/**
 * @inheritdoc Popover
 * @see Shadcn UI Documentation {@link https://ui.shadcn.com/docs/components/popover}
 * @see Radix UI Documentation {@link https://www.radix-ui.com/docs/primitives/components/popover}
 */
export declare const PopoverContent: React$1.ForwardRefExoticComponent<Omit<PopoverPrimitive.PopoverContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * Radio Group components providing a set of checkable buttons—known as radio buttons—where no more
 * than one of the buttons can be checked at a time. These components are built on Radix UI
 * primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/radio-group}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/radio-group}
 */
export declare const RadioGroup: React$1.ForwardRefExoticComponent<Omit<RadioGroupPrimitive.RadioGroupProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc RadioGroup
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/radio-group}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/radio-group}
 */
export declare const RadioGroupItem: React$1.ForwardRefExoticComponent<Omit<RadioGroupPrimitive.RadioGroupItemProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/**
 * Select components display a list of options for the user to pick from—triggered by a button.
 * These components are built on Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/select}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/select}
 */
export declare const Select: React$1.FC<SelectPrimitive.SelectProps>;
/**
 * @inheritdoc Select
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/select}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/select}
 */
export declare const SelectGroup: React$1.ForwardRefExoticComponent<SelectPrimitive.SelectGroupProps & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc Select
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/select}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/select}
 */
export declare const SelectValue: React$1.ForwardRefExoticComponent<SelectPrimitive.SelectValueProps & React$1.RefAttributes<HTMLSpanElement>>;
/**
 * @inheritdoc Select
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/select}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/select}
 */
export declare const SelectTrigger: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectTriggerProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/**
 * @inheritdoc Select
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/select}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/select}
 */
export declare const SelectScrollUpButton: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectScrollUpButtonProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc Select
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/select}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/select}
 */
export declare const SelectScrollDownButton: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectScrollDownButtonProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc Select
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/select}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/select}
 */
export declare const SelectContent: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc Select
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/select}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/select}
 */
export declare const SelectLabel: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectLabelProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc Select
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/select}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/select}
 */
export declare const SelectItem: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc Select
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/select}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/select}
 */
export declare const SelectSeparator: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectSeparatorProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * The Separator component visually or semantically sepearates content. This component is built on
 * Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/separator}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/separator}
 */
export declare const Separator: React$1.ForwardRefExoticComponent<Omit<SeparatorPrimitive.SeparatorProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
type SonnerProps = React$1.ComponentProps<typeof Toaster>;
/**
 * The Sonner component is an opinionated toast component for React. It is built on Sonner and
 * styled with Shadcn UI.
 *
 * @param SonnerProps
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/sonner}
 * @see Sonner Documentation: {@link https://sonner.emilkowal.ski}
 */
export declare function Sonner({ ...props }: SonnerProps): import("react/jsx-runtime").JSX.Element;
/**
 * The Slider component is an input where the user selects a value from within a given range. This
 * component is built on Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/slider}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/slider}
 */
export declare const Slider: React$1.ForwardRefExoticComponent<Omit<SliderPrimitive.SliderProps & React$1.RefAttributes<HTMLSpanElement>, "ref"> & React$1.RefAttributes<HTMLSpanElement>>;
/**
 * The Switch component is a control that allows the user to toggle between checked and not checked.
 * This component is built on Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/switch}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/switch}
 */
export declare const Switch: React$1.ForwardRefExoticComponent<Omit<SwitchPrimitives.SwitchProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/**
 * Table components provide a responsive table. These components are built and styled with Shadcn
 * UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/table}
 */
export declare const Table: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableElement> & {
	stickyHeader?: boolean | undefined;
} & React$1.RefAttributes<HTMLTableElement>>;
/**
 * @inheritdoc Table
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/table}
 */
export declare const TableHeader: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableSectionElement> & {
	stickyHeader?: boolean | undefined;
} & React$1.RefAttributes<HTMLTableSectionElement>>;
/**
 * @inheritdoc Table
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/table}
 */
export declare const TableBody: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableSectionElement> & React$1.RefAttributes<HTMLTableSectionElement>>;
/**
 * @inheritdoc Table
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/table}
 */
export declare const TableFooter: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableSectionElement> & React$1.RefAttributes<HTMLTableSectionElement>>;
/**
 * @inheritdoc Table
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/table}
 */
export declare const TableRow: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableRowElement> & React$1.RefAttributes<HTMLTableRowElement>>;
/**
 * @inheritdoc Table
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/table}
 */
export declare const TableHead: React$1.ForwardRefExoticComponent<React$1.ThHTMLAttributes<HTMLTableCellElement> & React$1.RefAttributes<HTMLTableCellElement>>;
/**
 * @inheritdoc Table
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/table}
 */
export declare const TableCell: React$1.ForwardRefExoticComponent<React$1.TdHTMLAttributes<HTMLTableCellElement> & React$1.RefAttributes<HTMLTableCellElement>>;
/**
 * @inheritdoc Table
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/table}
 */
export declare const TableCaption: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableCaptionElement> & React$1.RefAttributes<HTMLTableCaptionElement>>;
/**
 * Tabs components provide a set of layered sections of content—known as tab panels–that are
 * displayed one at a time. These components are built on Radix UI primitives and styled with Shadcn
 * UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/tabs}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/tabs}
 */
export declare const Tabs: React$1.ForwardRefExoticComponent<TabsPrimitive.TabsProps & React$1.RefAttributes<HTMLDivElement>>;
type TabsTriggerProps = React$1.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger> & {
	className?: string;
};
/**
 * @inheritdoc Tabs
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/tabs}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/tabs}
 */
export declare const TabsList: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsListProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc Tabs
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/tabs}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/tabs}
 */
export declare const TabsTrigger: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsTriggerProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLButtonElement>>;
/**
 * @inheritdoc Tabs
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/tabs}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/tabs}
 */
export declare const TabsContent: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
type LeftTabsTriggerProps = TabsTriggerProps & {
	value: string;
	ref?: React$1.Ref<HTMLButtonElement>;
};
export declare const VerticalTabs: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare const VerticalTabsList: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsListProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
export declare const VerticalTabsTrigger: React$1.ForwardRefExoticComponent<Omit<LeftTabsTriggerProps, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
export declare const VerticalTabsContent: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string | undefined;
} & React$1.RefAttributes<HTMLDivElement>>;
/**
 * ToggleGroup components provide a set of two-state buttons that can be toggled on or off. These
 * components are built on Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/toggle-group}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/toggle-group}
 */
export declare const ToggleGroup: React$1.ForwardRefExoticComponent<((Omit<ToggleGroupPrimitive.ToggleGroupSingleProps & React$1.RefAttributes<HTMLDivElement>, "ref"> | Omit<ToggleGroupPrimitive.ToggleGroupMultipleProps & React$1.RefAttributes<HTMLDivElement>, "ref">) & VariantProps<(props?: ({
	variant?: "default" | "outline" | null | undefined;
	size?: "default" | "sm" | "lg" | null | undefined;
} & ClassProp) | undefined) => string>) & React$1.RefAttributes<HTMLDivElement>>;
/**
 * @inheritdoc ToggleGroup
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/toggle-group}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/toggle-group}
 */
export declare const ToggleGroupItem: React$1.ForwardRefExoticComponent<Omit<ToggleGroupPrimitive.ToggleGroupItemProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & VariantProps<(props?: ({
	variant?: "default" | "outline" | null | undefined;
	size?: "default" | "sm" | "lg" | null | undefined;
} & ClassProp) | undefined) => string> & React$1.RefAttributes<HTMLButtonElement>>;
type InstallButtonProps = {
	/** The installing boolean value determines the state of the button. */
	isInstalling: boolean;
	/** The handleClick function is called when the button is clicked. */
	handleClick: () => void;
	/** Optional text for the button. */
	buttonText?: string;
} & ButtonProps;
/**
 * The InstallButton component is a button designed for initiating installs. It includes visuals for
 * active installing and idle states.
 *
 * @param InstallButtonProps
 * @returns A install button.
 */
export function InstallButton({ isInstalling, handleClick, buttonText, className, ...props }: InstallButtonProps): import("react/jsx-runtime").JSX.Element;
type EnableButtonProps = {
	/** The enabling boolean value determines the state of the button. */
	isEnabling: boolean;
	/** The handleClick function is called when the button is clicked. */
	handleClick: () => void;
} & ButtonProps;
/**
 * The EnableButton component is a button designed for initiating enabling of downloads. It includes
 * visuals for active enabling and idle states.
 *
 * @param EnableButtonProps
 * @returns A button that can be used to enable.
 */
export function EnableButton({ isEnabling, handleClick, className, ...props }: EnableButtonProps): import("react/jsx-runtime").JSX.Element;
type DisableButtonProps = {
	/** The disabling boolean value determines the state of the button. */
	isDisabling: boolean;
	/** The handleClick function is called when the button is clicked. */
	handleClick: () => void;
} & ButtonProps;
/**
 * The DisableButton component is a button designed for initiating disabling of downloads. It
 * includes visuals for active disabling and idle states.
 *
 * @param DisableButtonProps
 * @returns A button that can be used to disable.
 */
export function DisableButton({ isDisabling, handleClick, className, ...props }: DisableButtonProps): import("react/jsx-runtime").JSX.Element;
type UpdateButtonProps = {
	/** The updating boolean value determines the state of the button. */
	isUpdating: boolean;
	/** The handleClick function is called when the button is clicked. */
	handleClick: () => void;
} & ButtonProps;
/**
 * The UpdateButton component is a button designed for initiating updates for downloaded extensions.
 * It includes visuals for active updating and idle states.
 *
 * @param UpdateButtonProps
 * @returns A button that can be used to update.
 */
export function UpdateButton({ isUpdating, handleClick, className, ...props }: UpdateButtonProps): import("react/jsx-runtime").JSX.Element;
interface MarkdownRendererProps {
	/** Optional unique identifier */
	id?: string;
	/** The markdown string to render */
	markdown: string;
	className?: string;
	/**
	 * The [`target` attribute for `a` html
	 * tags](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#target). Defaults to not
	 * adding a `target` to `a` tags
	 */
	anchorTarget?: string;
}
/**
 * This component renders markdown content given a markdown string. It uses typography styles from
 * the platform.
 *
 * @param MarkdownRendererProps
 * @returns A div containing the rendered markdown content.
 */
export function MarkdownRenderer({ id, markdown, className, anchorTarget, }: MarkdownRendererProps): import("react/jsx-runtime").JSX.Element;
export declare enum DropdownMenuItemType {
	Check = 0,
	Radio = 1
}
export type DropdownItem = {
	/** The label is the text that will be displayed on the dropdown item. */
	label: string;
	/** The itemType determines the DropdownMenuItemType type as either Check or Radio. */
	itemType: DropdownMenuItemType;
	/** The onClick function is called when the item is clicked. */
	onClick: () => void;
};
export type DropdownGroup = {
	/**
	 * The label is the text that will be displayed on the dropdown group. It is used to categorize
	 * the items in the group.
	 */
	label: string;
	/** The items array contains the items that will be displayed in the dropdown group */
	items: DropdownItem[];
};
type FilterDropdownProps = {
	/** Object unique identifier */
	id?: string;
	/** The groups array contains the groups that will be displayed in the dropdown */
	groups: DropdownGroup[];
};
/**
 * The FilterDropdown component is a dropdown designed for filtering content. It includes groups of
 * items that can be checkboxes or radio items.
 *
 * @param FilterDropdownProps
 * @returns A filter dropdown.
 */
export function FilterDropdown({ id, groups }: FilterDropdownProps): import("react/jsx-runtime").JSX.Element;
/**
 * The FilterButton component is a button designed for initiating filtering of data. It is designed
 * to be used with the dropdown menu. It uses forwardRef to pass the button to the dropdown trigger
 * asChild.
 *
 * @returns A button that can be used to filter.
 */
export declare const FilterButton: import("react").ForwardRefExoticComponent<import("react").RefAttributes<HTMLButtonElement>>;
interface NoExtensionsFoundProps {
	/** Optional unique identifier */
	id?: string;
	/** The message to display */
	message: string;
}
/**
 * This component displays a message to the user when no extensions are found in the marketplace.
 *
 * @param NoExtensionsFoundProps
 * @returns {JSX.Element} - Returns the message component that displays the message to the user.
 */
export function NoExtensionsFound({ id, message }: NoExtensionsFoundProps): import("react/jsx-runtime").JSX.Element;
interface MoreInfoProps {
	/** Optional unique identifier */
	id?: string;
	/** The category of the extension */
	category: string;
	/** The number of downloads for the extension */
	downloads: Record<string, number>;
	/** The languages supported by the extension */
	languages: string[];
	/** The URL to the more info page of the extension */
	moreInfoUrl: string;
}
/**
 * This component displays the more info section of the extension which includes the category,
 * number of downloads, languages, and links to the website and support
 *
 * @param MoreInfoProps
 * @returns {JSX.Element} - Returns the more info component that displays the category, number of
 *   downloads, languages, and links to the website and support
 */
export function MoreInfo({ id, category, downloads, languages, moreInfoUrl, }: MoreInfoProps): import("react/jsx-runtime").JSX.Element;
export type VersionInformation = {
	/** Date the version was published */
	date: string;
	/** Description of the changes in the version */
	description: string;
};
/** Type to store the version history information */
export type VersionHistoryType = Record<string, VersionInformation>;
interface VersionHistoryProps {
	/** Optional unique identifier */
	id?: string;
	/** Object containing the versions mapped with their information */
	versionHistory: VersionHistoryType;
}
/**
 * Component to render the version history information shown in the footer component. Lists the 5
 * most recent versions, with the options to show all versions by pressing a button.
 *
 * @param VersionHistoryProps
 * @returns Rendered version history for the Footer component
 */
export function VersionHistory({ id, versionHistory }: VersionHistoryProps): import("react/jsx-runtime").JSX.Element;
interface FooterProps {
	/** Optional unique identifier */
	id?: string;
	/** Name of the publisher */
	publisherDisplayName: string;
	/** Size of the extension file in bytes */
	fileSize: number;
	/** List of language codes supported by the extension */
	locales: string[];
	/** Object containing the version history mapped with their information */
	versionHistory: VersionHistoryType;
}
/**
 * Component to render the footer for the extension details which contains information on the
 * publisher, version history, languages, and file size.
 *
 * @param FooterProps
 * @returns The rendered Footer component
 */
export function Footer({ id, publisherDisplayName, fileSize, locales, versionHistory, }: FooterProps): import("react/jsx-runtime").JSX.Element;
interface FilterProps extends MultiSelectComboBoxProps {
	/**
	 * Placeholder text that will be displayed when no items are selected. It will appear at the
	 * location where the badges would be if any items were selected.
	 */
	badgesPlaceholder: string;
}
/**
 * This is a variant of the {@link MultiSelectComboBox}, that shows a {@link Badge} component for each
 * selected item in the combo box. Clicking the 'X' icon on the badge will clear the item from the
 * selected options. A placeholder text must be provided through 'badgesPlaceholder'. This will be
 * displayed if no items are selected,
 */
export declare function Filter({ entries, getEntriesCount, selected, onChange, placeholder, commandEmptyMessage, customSelectedText, sortSelected, icon, className, badgesPlaceholder, }: FilterProps): import("react/jsx-runtime").JSX.Element;
declare const UI_LANGUAGE_SELECTOR_STRING_KEYS: readonly [
	"%settings_uiLanguageSelector_selectFallbackLanguages%"
];
type UiLanguageSelectorLocalizedStrings = {
	[localizedUiLanguageSelectorKey in (typeof UI_LANGUAGE_SELECTOR_STRING_KEYS)[number]]?: LocalizedStringValue;
};
export type LanguageInfo = {
	/** The name of the language to be displayed (in its native script) */
	autonym: string;
	/**
	 * The name of the language in other languages, so that the language can also be displayed in the
	 * current UI language, if known.
	 */
	uiNames?: Record<string, string>;
	/**
	 * Other known names of the language (for searching). This can include pejorative names and should
	 * never be displayed unless typed by the user.
	 */
	otherNames?: string[];
};
export type UiLanguageSelectorProps = {
	/** Full set of known languages to display. The keys are valid BCP-47 tags. */
	knownUiLanguages: Record<string, LanguageInfo>;
	/** IETF BCP-47 language tag of the current primary UI language. `undefined` => 'en' */
	primaryLanguage: string;
	/**
	 * Ordered list of fallback language tags to use if the localization key can't be found in the
	 * current primary UI language. This list never contains English ('en') because it is the ultimate
	 * fallback.
	 */
	fallbackLanguages: string[] | undefined;
	/**
	 * Handler for when either the primary or the fallback languages change (or both). For this
	 * handler, the primary UI language is the first one in the array, followed by the fallback
	 * languages in order of decreasing preference.
	 */
	onLanguagesChange?: (newUiLanguages: string[]) => void;
	/** Handler for the primary language changes. */
	onPrimaryLanguageChange?: (newPrimaryUiLanguage: string) => void;
	/**
	 * Handler for when the fallback languages change. The array contains the fallback languages in
	 * order of decreasing preference.
	 */
	onFallbackLanguagesChange?: (newFallbackLanguages: string[]) => void;
	/**
	 * Map whose keys are localized string keys as contained in UI_LANGUAGE_SELECTOR_STRING_KEYS and
	 * whose values are the localized strings (in the current UI language).
	 */
	localizedStrings: UiLanguageSelectorLocalizedStrings;
	/** Additional css classes to help with unique styling of the control */
	className?: string;
};
export function UiLanguageSelector({ knownUiLanguages, primaryLanguage, fallbackLanguages, onLanguagesChange, onPrimaryLanguageChange, onFallbackLanguagesChange, localizedStrings, className, }: UiLanguageSelectorProps): import("react/jsx-runtime").JSX.Element;
/**
 * Adds an event handler to an event so the event handler runs when the event is emitted. Use
 * `papi.network.getNetworkEvent` to use a networked event with this hook.
 *
 * @param event The event to subscribe to.
 *
 *   - If event is a `PlatformEvent`, that event will be used
 *   - If event is undefined, the callback will not be subscribed. Useful if the event is not yet
 *       available for example
 *
 * @param eventHandler The callback to run when the event is emitted
 *
 *   WARNING: MUST BE STABLE - const or wrapped in useCallback. The reference must not be updated
 *   every render
 */
export declare const useEvent: <T>(event: PlatformEvent<T> | undefined, eventHandler: PlatformEventHandler<T>) => void;
/**
 * Adds an event handler to an asynchronously subscribing/unsubscribing event so the event handler
 * runs when the event is emitted. Use `papi.network.getNetworkEvent` to use a networked event with
 * this hook.
 *
 * @param event The asynchronously (un)subscribing event to subscribe to.
 *
 *   - If event is a `PlatformEvent` or `PlatformEventAsync`, that event will be used
 *   - If event is undefined, the callback will not be subscribed. Useful if the event is not yet
 *       available for example
 *
 * @param eventHandler The callback to run when the event is emitted
 *
 *   WARNING: MUST BE STABLE - const or wrapped in useCallback. The reference must not be updated
 *   every render
 */
export declare const useEventAsync: <T>(event: PlatformEvent<T> | PlatformEventAsync<T> | undefined, eventHandler: PlatformEventHandler<T>) => void;
export type UsePromiseOptions = {
	/**
	 * Whether to leave the value as the most recent resolved promise value or set it back to
	 * defaultValue while running the promise again. Defaults to true
	 */
	preserveValue?: boolean;
};
/**
 * Awaits a promise and returns a loading value while the promise is unresolved
 *
 * @param promiseFactoryCallback A function that returns the promise to await. If this callback is
 *   undefined, the current value will be returned (defaultValue unless it was previously changed
 *   and `options.preserveValue` is true), and there will be no loading.
 *
 *   WARNING: MUST BE STABLE - const or wrapped in useCallback. The reference must not be updated
 *   every render
 * @param defaultValue The initial value to return while first awaiting the promise. If
 *   `options.preserveValue` is false, this value is also shown while awaiting the promise on
 *   subsequent calls.
 *
 *   Note: this parameter is internally assigned to a `ref`, so changing it will not cause any hooks
 *   to re-run with its new value. This means that, if the `promiseFactoryCallback` changes and
 *   `options.preserveValue` is `false`, the returned value will be set to the current
 *   `defaultValue`. However, the returned value will not be updated if`defaultValue` changes.
 * @param options Various options for adjusting how this hook runs the `promiseFactoryCallback`
 *
 *   Note: this parameter is internally assigned to a `ref`, so changing it will not cause any hooks
 *   to re-run with its new value. However, the latest `options.preserveValue` will always be used
 *   appropriately to determine whether to preserve the returned value when changing the
 *   `promiseFactoryCallback`
 * @returns `[value, isLoading]`
 *
 *   - `value`: the current value for the promise, either the defaultValue or the resolved promise value
 *   - `isLoading`: whether the promise is waiting to be resolved
 */
export declare const usePromise: <T>(promiseFactoryCallback: (() => Promise<T>) | undefined, defaultValue: T, options?: UsePromiseOptions) => [
	value: T,
	isLoading: boolean
];
/**
 * Tailwind and CSS class application helper function. Uses
 * [`clsx`](https://www.npmjs.com/package/clsx) to make it easy to apply classes conditionally using
 * object syntax, and uses [`tailwind-merge`](https://www.npmjs.com/package/tailwind-merge) to make
 * it easy to merge/overwrite Tailwind classes in a programmer-logic-friendly way.
 *
 * Note: `tailwind-merge` is configured to use the prefix `tw-`, so you must use the same prefix
 * with any Tailwind classes you use with this function to successfully overwrite other Tailwind
 * classes. `platform-bible-react` is configured to use `tw-` as its Tailwind prefix, so any
 * Tailwind classes you pass into `platform-bible-react` components will be compared using the `tw-`
 * prefix.
 *
 * This function was popularized by
 * [shadcn/ui](https://ui.shadcn.com/docs/installation/manual#add-a-cn-helper). See [ByteGrad's
 * explanation video](https://www.youtube.com/watch?v=re2JFITR7TI) for more information.
 *
 * @example
 *
 * ```typescript
 * const borderShouldBeBlue = true;
 * const textShouldBeRed = true;
 * const heightShouldBe20 = false;
 * const classString = cn(
 *   'tw-bg-primary tw-h-10 tw-text-primary-foreground',
 *   'tw-bg-secondary',
 *   {
 *     'tw-border-blue-500': borderShouldBeBlue,
 *     'tw-text-red-500': textShouldBeRed,
 *     'tw-h-20': heightShouldBe20,
 *   },
 *   'some-class',
 * );
 * ```
 *
 * The resulting `classString` is `'tw-h-10 tw-bg-secondary tw-border-blue-500 tw-text-red-500
 * some-class'`
 *
 * - Notice that `'tw-bg-secondary'`, specified later, overwrote `'tw-bg-primary'`, specified earlier,
 *   because they are Tailwind classes that affect the same css property
 * - Notice that `'tw-text-red-500'`, specified later, overwrote `'tw-text-primary-foreground'`,
 *   specified earlier, because they are Tailwind classes that affect the same css property
 * - Notice that `'tw-h-20'`, specified later, did not overwrite `'tw-h-10'`, specified earlier,
 *   because `'tw-h-20'` is part of a conditional class object and its value evaluated to `false`;
 *   therefore it was not applied
 * - Notice that `'some-class'` was applied. This function is not limited only to Tailwind classes.
 *
 *
 * @param inputs Class strings or `clsx` conditional class objects to merge. Tailwind classes
 *   specified later in the arguments overwrite similar Tailwind classes specified earlier in the
 *   arguments
 * @returns Class string containing all applicable classes from the arguments based on the rules
 *   described above
 */
export declare function cn(...inputs: ClassValue[]): string;

export {
	TabNavigationContentSearch as NavigationContentSearch,
	sonner,
};

export {};
