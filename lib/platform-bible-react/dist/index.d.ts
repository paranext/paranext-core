// Generated by dts-bundle-generator v9.5.1

import { DeltaOpInsertNoteEmbed, EditorOptions } from '@eten-tech-foundation/platform-editor';
import { MarkerObject } from '@eten-tech-foundation/scripture-utilities';
import * as AvatarPrimitive from '@radix-ui/react-avatar';
import * as CheckboxPrimitive from '@radix-ui/react-checkbox';
import * as ContextMenuPrimitive from '@radix-ui/react-context-menu';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import * as LabelPrimitive from '@radix-ui/react-label';
import * as PopoverPrimitive from '@radix-ui/react-popover';
import { PopoverProps } from '@radix-ui/react-popover';
import * as ProgressPrimitive from '@radix-ui/react-progress';
import * as RadioGroupPrimitive from '@radix-ui/react-radio-group';
import * as SelectPrimitive from '@radix-ui/react-select';
import * as SeparatorPrimitive from '@radix-ui/react-separator';
import * as SliderPrimitive from '@radix-ui/react-slider';
import * as SwitchPrimitives from '@radix-ui/react-switch';
import * as TabsPrimitive from '@radix-ui/react-tabs';
import * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group';
import * as TooltipPrimitive from '@radix-ui/react-tooltip';
import { SerializedVerseRef } from '@sillsdev/scripture';
import { ColumnDef as TSColumnDef, Row as TSRow, SortDirection as TSSortDirection, Table as TSTable } from '@tanstack/react-table';
import { ClassValue } from 'clsx';
import { LucideProps } from 'lucide-react';
import React$1 from 'react';
import { ChangeEventHandler, ComponentProps, FocusEventHandler, PropsWithChildren, ReactNode } from 'react';
import * as ResizablePrimitive from 'react-resizable-panels';
import { Toaster, toast as sonner } from 'sonner';
import { Drawer as DrawerPrimitive } from 'vaul';

type Unsubscriber = () => boolean;
type UnsubscriberAsync = () => Promise<boolean>;
type PlatformEventHandler<T> = (event: T) => void;
type PlatformEvent<T> = (callback: PlatformEventHandler<T>) => Unsubscriber;
type PlatformEventAsync<T> = (callback: PlatformEventHandler<T>) => Promise<UnsubscriberAsync>;
type ScriptureNode = SerializedVerseRef & {
	jsonPath: string;
};
type ScriptureTextAnchor = ScriptureNode & {
	offset: number;
};
type ScriptureSelection = {
	start: ScriptureNode | ScriptureTextAnchor;
	end?: ScriptureNode | ScriptureTextAnchor;
};
type ScrollGroupId = number;
type ReplaceType<T, A, B> = T extends A ? B : T extends object ? {
	[K in keyof T]: ReplaceType<T[K], A, B>;
} : T;
type LocalizeKey = `%${string}%`;
type ReferencedItem = `${string}.${string}`;
type OrderedItem = {
	/** Relative order of this item compared to other items in the same parent/scope (sorted ascending) */
	order: number;
};
type OrderedExtensibleContainer = OrderedItem & {
	/** Determines whether other items can be added to this after it has been defined */
	isExtensible?: boolean;
};
type MenuGroupDetailsInColumn = OrderedExtensibleContainer & {
	/** ID of column in which this group resides */
	column: ReferencedItem;
};
type MenuGroupDetailsInSubMenu = OrderedExtensibleContainer & {
	/** ID of menu item hosting the submenu in which this group resides */
	menuItem: ReferencedItem;
};
type MenuColumnWithHeader = OrderedExtensibleContainer & {
	/** Key that represents the text of the header text of the column */
	label: LocalizeKey;
};
type MenuItemBase = OrderedItem & {
	/** Menu group to which this menu item belongs */
	group: ReferencedItem;
	/** Key that represents the text of this menu item to display */
	label: LocalizeKey;
	/** Key that represents words the platform should reference when users are searching for menu items */
	searchTerms?: LocalizeKey;
	/** Key that represents the text to display if a mouse pointer hovers over the menu item */
	tooltip?: LocalizeKey;
	/** Additional information provided by developers to help people who perform localization */
	localizeNotes: string;
};
type MenuItemContainingSubmenu = MenuItemBase & {
	/** ID for this menu item that holds a submenu */
	id: ReferencedItem;
};
type MenuItemContainingCommand = MenuItemBase & {
	/** Name of the PAPI command to run when this menu item is selected. */
	command: ReferencedItem;
	/**
	 * Uri path to the icon to display after the menu text. Ex:
	 * `papi-extension://helloWorld/assets/icon.png`
	 */
	iconPathAfter?: string;
	/**
	 * Uri path to the icon to display before the menu text. Ex:
	 * `papi-extension://helloWorld/assets/icon.png`
	 */
	iconPathBefore?: string;
};
type GroupsInMultiColumnMenu = {
	/** Named menu group */
	[property: ReferencedItem]: MenuGroupDetailsInColumn | MenuGroupDetailsInSubMenu;
};
type ColumnsWithHeaders = {
	/** Named column of a menu */
	[property: ReferencedItem]: MenuColumnWithHeader;
	/** Defines whether columns can be added to this multi-column menu */
	isExtensible?: boolean;
};
type MultiColumnMenu = {
	/** Columns that belong in this menu */
	columns: ColumnsWithHeaders;
	/** Groups that belong in this menu */
	groups: GroupsInMultiColumnMenu;
	/** List of menu items that belong in this menu */
	items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];
};
type Localized<T> = ReplaceType<ReplaceType<T, LocalizeKey, string>, ReferencedItem, string>;
type LocalizedStringValue = string;
interface LanguageStrings {
	[k: LocalizeKey]: LocalizedStringValue;
}
type CommentStatus = "Unspecified" | "Todo" | "Done" | "Resolved";
type CommentType = "Unspecified" | "Normal" | "Conflict";
type LegacyComment = {
	/** Present in a note when it has been assigned to a particular user */
	assignedUser?: string;
	/** Present when there is a Biblical Term Id associated with the note */
	biblicalTermId?: string;
	/**
	 * Type of conflict. Only applicable for conflict notes and it used to give a more specific
	 * message when displaying the note.
	 */
	conflictType?: string;
	/** Contents of the comment, represented in HTML that includes some Paratext 9 specific tags */
	contents: string;
	/**
	 * If SelectedText is not empty, some optional context of the selected text occurs immediately
	 * after the selection.
	 */
	contextAfter?: string;
	/**
	 * If SelectedText is not empty, some optional context of the selected text occurs immediately
	 * before the selection.
	 */
	contextBefore?: string;
	/** Date the comment was created (format like 2008-04-10T06:30:00.0000000-07:00) */
	date: string;
	/** True if the comment has been deleted */
	deleted: boolean;
	/** Additional information for the note header, added for Biblical Term notes. */
	extraHeadingInfo?: string;
	/** Present in a comment to hide the note when showing notes in teh Scripture text windows. */
	hideInTextWindow: boolean;
	/** Unique id of the comment, unchanged by subsequent editing */
	id: string;
	/** Whether the comment has been read (by the current user) */
	isRead: boolean;
	/** Language of note */
	language: string;
	/** Present in a note when it has been assigned to reply-to a particular user */
	replyToUser?: string;
	/** Text which was selected in comment, or "" for none */
	selectedText?: string;
	/** Present in a note when it has been marked to be shared in teh Global Consultant Notes */
	shared?: string;
	/** Approximate position where the comment begins. Zero for attached to a verse. */
	startPosition: number;
	/** Can be "todo", "done", or "deleted." Empty string falls back to previous status in thread. */
	status?: CommentStatus;
	/** Tags added in this note, joined with (',') */
	tagAdded?: string;
	/** Tags removed in this note, joined with (',') */
	tagRemoved?: string;
	/** Guid of the thread of comments */
	thread: string;
	/**
	 * Type of note. Normal notes have no type (""), but conflicts that are stored as notes have type
	 * "conflict."
	 */
	type?: string;
	/** Name of the user who created this comment */
	user: string;
	/** Original USFM content of verse */
	verse?: string;
	/** Verse reference in which comment appears */
	verseRef: string;
};
type LegacyCommentThread = {
	/** Thread identifier (from first comment) */
	id: string;
	/** All comments in this thread */
	comments: LegacyComment[];
	/** Thread status (aggregated from most recent non-Unspecified comment) */
	status: CommentStatus;
	/** Thread type (from first comment) */
	type: CommentType;
	/**
	 * User to whom the thread is assigned
	 *
	 * - `undefined` or not present if there is no assignment info
	 * - Empty string means explicitly unassigned
	 */
	assignedUser?: string;
	/** User to reply to */
	replyToUser?: string;
	/** Last modified date (ISO 8601 string) */
	modifiedDate: string;
	/** Scripture reference for this thread */
	verseRef: string;
	/** Name of the context scripture text */
	contextScrTextName?: string;
	/** Whether this is a spelling note */
	isSpellingNote: boolean;
	/** Whether this is a back translation note */
	isBTNote: boolean;
	/** Whether this is a consultant note */
	isConsultantNote: boolean;
	/** Whether the thread has been read (by the current user) */
	isRead: boolean;
	/** Biblical term ID if this is a biblical term note */
	biblicalTermId?: string;
};
/**
 * Object containing all keys used for localization in the BookChapterControl component. If you're
 * using this component in an extension, you can pass it into the useLocalizedStrings hook to easily
 * obtain the localized strings and pass them into the localizedStrings prop of this component
 */
export declare const BOOK_CHAPTER_CONTROL_STRING_KEYS: readonly [
	"%scripture_section_ot_long%",
	"%scripture_section_nt_long%",
	"%scripture_section_dc_long%",
	"%scripture_section_extra_long%",
	"%history_recent%",
	"%history_recentSearches_ariaLabel%"
];
/** Type definition for the localized strings used in the BookChapterControl component */
export type BookChapterControlLocalizedStrings = {
	[localizedKey in (typeof BOOK_CHAPTER_CONTROL_STRING_KEYS)[number]]?: string;
};
export type BookChapterControlProps = {
	/** The current scripture reference */
	scrRef: SerializedVerseRef;
	/** Callback to handle the submission of a selected reference */
	handleSubmit: (scrRef: SerializedVerseRef) => void;
	/** Optional additional class name for styling */
	className?: string;
	/** Callback to retrieve book IDs that are available in the current context */
	getActiveBookIds?: () => string[];
	/**
	 * Optional map of localized book IDs/short names and full names. The key is the standard book ID
	 * (e.g., "2CH"), the value contains a localized version of the ID and related book name (e.g. {
	 * localizedId: '2CR', localizedName: '2 Crónicas' })
	 */
	localizedBookNames?: Map<string, {
		localizedId: string;
		localizedName: string;
	}>;
	/** Optional localized strings for the component */
	localizedStrings?: LanguageStrings;
	/** Array of recent scripture references for quick access */
	recentSearches?: SerializedVerseRef[];
	/** Callback to add a new recent scripture reference */
	onAddRecentSearch?: (scrRef: SerializedVerseRef) => void;
	/** Optional ID for the popover content for accessibility */
	id?: string;
};
/**
 * `BookChapterControl` is a component that provides an interactive UI for selecting book chapters.
 * It allows users to input a search query to find specific books and chapters, navigate through
 * options with keyboard interactions, and submit selections. The component handles various
 * interactions such as opening and closing the dropdown menu, filtering book lists based on search
 * input, and managing highlighted selections. It also integrates with external handlers for
 * submitting selected references and retrieving active book IDs.
 */
export declare function BookChapterControl({ scrRef, handleSubmit, className, getActiveBookIds, localizedBookNames, localizedStrings, recentSearches, onAddRecentSearch, id, }: BookChapterControlProps): import("react/jsx-runtime").JSX.Element;
export type ChapterRangeSelectorProps = {
	/** The selected start chapter */
	startChapter: number;
	/** The selected end chapter */
	endChapter: number;
	/** Callback function to handle the selection of the start chapter */
	handleSelectStartChapter: (chapter: number) => void;
	/** Callback function to handle the selection of the end chapter */
	handleSelectEndChapter: (chapter: number) => void;
	/** Flag to disable the component */
	isDisabled?: boolean;
	/** The total number of chapters available */
	chapterCount: number;
};
/**
 * ChapterRangeSelector is a component that provides a UI for selecting a range of chapters. It
 * consists of two combo boxes for selecting the start and end chapters. The component ensures that
 * the selected start chapter is always less than or equal to the end chapter, and vice versa.
 *
 * @deprecated Jul 18 2025. This component is no longer supported or tested. Use of this component
 *   is discouraged and it may be removed in the future.
 * @param {ChapterRangeSelectorProps} props - The props for the component.
 */
export declare function ChapterRangeSelector({ startChapter, endChapter, handleSelectStartChapter, handleSelectEndChapter, isDisabled, chapterCount, }: ChapterRangeSelectorProps): import("react/jsx-runtime").JSX.Element;
/** Enumeration of possible book selection modes */
export declare enum BookSelectionMode {
	CURRENT_BOOK = "current book",
	CHOOSE_BOOKS = "choose books"
}
/**
 * Object containing all keys used for localization in this component. If you're using this
 * component in an extension, you can pass it into the useLocalizedStrings hook to easily obtain the
 * localized strings and pass them into the localizedStrings prop of this component
 */
export declare const BOOK_SELECTOR_STRING_KEYS: readonly [
	"%webView_bookSelector_currentBook%",
	"%webView_bookSelector_choose%",
	"%webView_bookSelector_chooseBooks%"
];
export type BookSelectorLocalizedStrings = {
	[localizedBookSelectorKey in (typeof BOOK_SELECTOR_STRING_KEYS)[number]]?: LocalizedStringValue;
};
type BookSelectorProps = ChapterRangeSelectorProps & {
	handleBookSelectionModeChange: (newMode: BookSelectionMode) => void;
	currentBookName: string;
	onSelectBooks: () => void;
	selectedBookIds: string[];
	localizedStrings: BookSelectorLocalizedStrings;
};
/**
 * BookSelector is a component that provides an interactive UI for selecting books. It can be set to
 * either allow the user to select a single book or to choose multiple books. In the former case, it
 * will display the range of chapters in the selected book, and in the latter case it will display a
 * list of the selected books.
 *
 * @deprecated Jul 18 2025. This component is no longer supported or tested. Use of this component
 *   is discouraged and it may be removed in the future.
 * @param {BookSelectorProps} props
 * @param {function} props.handleBookSelectionModeChange - Callback function to handle changes in
 *   book selection mode.
 * @param {string} props.currentBookName - The name of the currently selected book.
 * @param {function} props.onSelectBooks - Callback function to handle book selection.
 * @param {string[]} props.selectedBookIds - An array of book IDs that have been selected.
 * @param {BookSelectorLocalizedStrings} props.localizedStrings - Object containing localized
 *   strings for the component.
 */
export declare function BookSelector({ handleBookSelectionModeChange, currentBookName, onSelectBooks, selectedBookIds, chapterCount, endChapter, handleSelectEndChapter, startChapter, handleSelectStartChapter, localizedStrings, }: BookSelectorProps): import("react/jsx-runtime").JSX.Element;
/** Interface defining the properties for the RecentSearches component */
export interface RecentSearchesProps<T> {
	/** Array of recent search items */
	recentSearches: T[];
	/** Callback when a recent search item is selected */
	onSearchItemSelect: (item: T) => void;
	/** Function to render each search item as a string for display */
	renderItem?: (item: T) => string;
	/** Function to create a unique key for each item */
	getItemKey?: (item: T) => string;
	/** Aria label for the recent searches button */
	ariaLabel?: string;
	/** Heading text for the recent searches group */
	groupHeading?: string;
	/** Optional ID for the popover content for accessibility */
	id?: string;
	/** Class name for styling the `CommandItem` for each recent search result */
	classNameForItems?: string;
}
/**
 * Generic component that displays a button to show recent searches in a popover. Only renders if
 * there are recent searches available. Works with any data type T.
 */
export function RecentSearches<T>({ recentSearches, onSearchItemSelect, renderItem, getItemKey, ariaLabel, groupHeading, id, classNameForItems, }: RecentSearchesProps<T>): import("react/jsx-runtime").JSX.Element | undefined;
/** Generic hook for managing recent searches state and operations. */
export declare function useRecentSearches<T>(recentSearches: T[], setRecentSearches: (items: T[]) => void, areItemsEqual?: (a: T, b: T) => boolean, maxItems?: number): (item: T) => void;
/**
 * Object containing all keys used for localization in the CommentEditor component. If you're using
 * this component in an extension, you can pass it into the useLocalizedStrings hook to easily
 * obtain the localized strings and pass them into the localizedStrings prop of this component
 */
export declare const COMMENT_EDITOR_STRING_KEYS: readonly [
	"%commentEditor_placeholder%",
	"%commentEditor_saveButton_tooltip%",
	"%commentEditor_cancelButton_tooltip%",
	"%commentEditor_assignTo_label%",
	"%commentEditor_unassigned%",
	"%commentEditor_team%"
];
/** Localized strings needed for the comment editor component */
export type CommentEditorLocalizedStrings = {
	[localizedKey in (typeof COMMENT_EDITOR_STRING_KEYS)[number]]?: string;
};
/** Interface containing the types of the properties that are passed to the `CommentEditor` */
export interface CommentEditorProps {
	/** List of users that can be assigned to the new comment thread */
	assignableUsers: string[];
	/**
	 * External function to handle saving the new comment
	 *
	 * @param contents HTML content of the comment
	 * @param assignedUser Optional user to assign the comment to
	 */
	onSave: (contents: string, assignedUser?: string) => void;
	/**
	 * External function to handle closing the comment editor. Gets called when the editor is closed
	 * without saving changes
	 */
	onClose: () => void;
	/** Localized strings to be passed to the comment editor component */
	localizedStrings: CommentEditorLocalizedStrings;
}
/**
 * Component to create a new project comment from within the scripture editor
 *
 * @param CommentEditorProps - The properties for the comment editor component
 */
export function CommentEditor({ assignableUsers, onSave, onClose, localizedStrings, }: CommentEditorProps): import("react/jsx-runtime").JSX.Element;
/** Options for adding a comment to a thread */
export type AddCommentToThreadOptions = {
	/** The ID of the thread to add the comment to */
	threadId: string;
	/** The content of the comment (optional - can be omitted when only changing status or assignment) */
	contents?: string;
	/** Status to set on the thread ('Resolved' or 'Todo') */
	status?: CommentStatus;
	/** User to assign to the thread. Use "" for unassigned, "Team" for team assignment. */
	assignedUser?: string;
};
/**
 * Object containing all keys used for localization in the CommentList component. If you're using
 * this component in an extension, you can pass it into the useLocalizedStrings hook to easily
 * obtain the localized strings and pass them into the localizedStrings prop of this component
 */
export declare const COMMENT_LIST_STRING_KEYS: LocalizeKey[];
/** Props for the CommentList component */
export interface CommentListProps {
	/** Additional class name for the component */
	className?: string;
	/** Class name to apply to the display of the verse text for the first comment in the thread */
	classNameForVerseText?: string;
	/** Comment threads to render */
	threads: LegacyCommentThread[];
	/** Name of the current user, retrieved from the current user's Paratext Registry user information */
	currentUser: string;
	/** Localized strings for the component */
	localizedStrings: LanguageStrings;
	/**
	 * Externally controlled selected thread ID. When provided, this will be used as the selected
	 * thread instead of internal state. The parent component is responsible for updating this value
	 * when the selection changes.
	 */
	selectedThreadId?: string;
	/**
	 * Callback when the selected thread changes. Called when a thread is selected via click or
	 * keyboard navigation. Parent components can use this to sync their state with the internal
	 * selection.
	 */
	onSelectedThreadChange?: (threadId: string | undefined) => void;
	/**
	 * Handler for adding a comment to a thread. This unified handler supports:
	 *
	 * - Adding a comment (provide contents)
	 * - Resolving/unresolving a thread (provide status: 'Resolved' or 'Todo')
	 * - Assigning a user (provide assignedUser)
	 * - Any combination of the above
	 *
	 * If successful, returns the auto-generated comment ID (format: "threadId/userName/date").
	 * Otherwise, returns undefined.
	 */
	handleAddCommentToThread: (options: AddCommentToThreadOptions) => Promise<string | undefined>;
	/** Handler for updating a comment's content */
	handleUpdateComment: (commentId: string, contents: string) => Promise<boolean>;
	/** Handler for deleting a comment */
	handleDeleteComment: (commentId: string) => Promise<boolean>;
	/** Handler for updating a thread's read status */
	handleReadStatusChange: (threadId: string, markRead: boolean) => Promise<boolean>;
	/**
	 * Users that can be assigned to threads. Includes special values: "Team" for team assignment, ""
	 * (empty string) for unassigned.
	 */
	assignableUsers?: string[];
	/**
	 * Whether the current user can add comments to existing threads in this project. When false, UI
	 * elements for adding comments to threads should be hidden or disabled.
	 */
	canUserAddCommentToThread?: boolean;
	/**
	 * Callback to check if the current user can assign a specific thread. Returns a promise that
	 * resolves to true if the user can assign the thread, false otherwise.
	 */
	canUserAssignThreadCallback?: (threadId: string) => Promise<boolean>;
	/**
	 * Callback to check if the current user can resolve or re-open a specific thread. Returns a
	 * promise that resolves to true if the user can resolve the thread, false otherwise.
	 */
	canUserResolveThreadCallback?: (threadId: string) => Promise<boolean>;
	/**
	 * Callback to check if the current user can edit or delete a specific comment. Returns a promise
	 * that resolves to true if the user can edit or delete the comment, false otherwise.
	 */
	canUserEditOrDeleteCommentCallback?: (commentId: string) => Promise<boolean>;
}
/**
 * Component for rendering a list of comment threads
 *
 * @param CommentListProps Props for the CommentList component
 */
export function CommentList({ className, classNameForVerseText, threads, currentUser, localizedStrings, handleAddCommentToThread, handleUpdateComment, handleDeleteComment, handleReadStatusChange, assignableUsers, canUserAddCommentToThread, canUserAssignThreadCallback, canUserResolveThreadCallback, canUserEditOrDeleteCommentCallback, selectedThreadId: externalSelectedThreadId, onSelectedThreadChange, }: CommentListProps): import("react/jsx-runtime").JSX.Element;
export type ColumnDef<TData, TValue = unknown> = TSColumnDef<TData, TValue>;
export type RowContents<TData> = TSRow<TData>;
export type TableContents<TData> = TSTable<TData>;
export type SortDirection = TSSortDirection;
interface DataTableProps<TData, TValue> {
	columns: ColumnDef<TData, TValue>[];
	data: TData[] | undefined;
	enablePagination?: boolean;
	showPaginationControls?: boolean;
	showColumnVisibilityControls?: boolean;
	stickyHeader?: boolean;
	onRowClickHandler?: (row: RowContents<TData>, table: TableContents<TData>) => void;
	id?: string;
	isLoading?: boolean;
	noResultsMessage: string;
}
/**
 * Feature-rich table component that infuses our basic shadcn-based Table component with features
 * from TanStack's React Table library
 */
export declare function DataTable<TData, TValue>({ columns, data, enablePagination, showPaginationControls, showColumnVisibilityControls, stickyHeader, onRowClickHandler, id, isLoading, noResultsMessage, }: DataTableProps<TData, TValue>): import("react/jsx-runtime").JSX.Element;
interface MarkdownRendererProps {
	/** Optional unique identifier */
	id?: string;
	/** The markdown string to render */
	markdown: string;
	className?: string;
	/**
	 * The [`target` attribute for `a` html
	 * tags](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#target). Defaults to not
	 * adding a `target` to `a` tags
	 */
	anchorTarget?: string;
	/** Optional flag to truncate the content to 3 lines */
	truncate?: boolean;
}
/**
 * This component renders markdown content given a markdown string. It uses typography styles from
 * the platform.
 *
 * @param MarkdownRendererProps
 * @returns A div containing the rendered markdown content.
 */
export declare function MarkdownRenderer({ id, markdown, className, anchorTarget, truncate, }: MarkdownRendererProps): import("react/jsx-runtime").JSX.Element;
/**
 * Object containing all keys used for localization in this component. If you're using this
 * component in an extension, you can pass it into the useLocalizedStrings hook to easily obtain the
 * localized strings and pass them into the localizedStrings prop of this component
 */
export declare const ERROR_DUMP_STRING_KEYS: readonly [
	"%webView_error_dump_header%",
	"%webView_error_dump_info_message%"
];
export type ErrorDumpLocalizedStrings = {
	[localizedInventoryKey in (typeof ERROR_DUMP_STRING_KEYS)[number]]?: LocalizedStringValue;
};
interface ErrorDumpProps {
	/** String containing the error details to show */
	errorDetails: string;
	/** Handler function to notify the frontend when the error is copied */
	handleCopyNotify?: () => void;
	/**
	 * List of localized strings to localize the strings in this component. Relevant keys can be found
	 * in `ERROR_DUMP_STRING_KEYS`
	 */
	localizedStrings: ErrorDumpLocalizedStrings;
	/** Optional id for the root element */
	id?: string;
}
/** Component to render an error dump */
export declare function ErrorDump({ errorDetails, handleCopyNotify, localizedStrings, id, }: ErrorDumpProps): import("react/jsx-runtime").JSX.Element;
/**
 * Object containing all keys used for localization in the ErrorPopover component. This extends
 * ERROR_DUMP_STRING_KEYS with additional keys specific to the ErrorPopover. If you're using this
 * component in an extension, you can pass it into the useLocalizedStrings hook to easily obtain the
 * localized strings and pass them into the localizedStrings prop of this component
 */
export declare const ERROR_POPOVER_STRING_KEYS: readonly [
	"%webView_error_dump_header%",
	"%webView_error_dump_info_message%",
	"%webView_error_dump_copied_message%"
];
export type ErrorPopoverLocalizedStrings = {
	[localizedKey in (typeof ERROR_POPOVER_STRING_KEYS)[number]]?: string;
};
type ErrorPopoverProps = React$1.PropsWithChildren & Omit<ErrorDumpProps, "localizedStrings"> & {
	/**
	 * List of localized strings to localize the strings in this component. Relevant keys can be
	 * found in `ERROR_POPOVER_STRING_KEYS`
	 */
	localizedStrings: ErrorPopoverLocalizedStrings;
	/** Optional CSS classes to insert into the `PopoverContent` */
	className?: string;
	/** Optional ID for the popover content for accessibility */
	id?: string;
};
/** A popover component that displays detailed error information using the ErrorDump component. */
export declare function ErrorPopover({ errorDetails, handleCopyNotify, localizedStrings, children, className, id, }: ErrorPopoverProps): import("react/jsx-runtime").JSX.Element;
/** The DropdownMenuItemType enum is used to determine the type of the dropdown item */
export declare enum DropdownMenuItemType {
	Check = 0,
	Radio = 1
}
export type DropdownItem = {
	/** Unique identifier for this dropdown */
	id: string;
	/** The label is the text that will be displayed on the dropdown item. */
	label: string;
	/** The onUpdate function is called when the state of a dropdown item is changed. */
	onUpdate: (id: string, checked?: boolean) => void;
};
export type DropdownGroup = {
	/**
	 * The label is the text that will be displayed on the dropdown group. It is used to categorize
	 * the items in the group.
	 */
	label: string;
	/** The itemType determines the DropdownMenuItemType type as either Check or Radio. */
	itemType: DropdownMenuItemType;
	/** The items array contains the items that will be displayed in the dropdown group */
	items: DropdownItem[];
};
type FilterDropdownProps = {
	/** Object unique identifier */
	id?: string;
	/** Label for the trigger button */
	label: string;
	/** The groups array contains the groups that will be displayed in the dropdown */
	groups: DropdownGroup[];
};
/**
 * The FilterDropdown component is a dropdown designed for filtering content. It includes groups of
 * items that can be checkboxes or radio items.
 *
 * @param FilterDropdownProps
 * @returns A filter dropdown.
 */
export declare function FilterDropdown({ id, label, groups }: FilterDropdownProps): import("react/jsx-runtime").JSX.Element;
interface MoreInfoProps {
	/** Optional unique identifier */
	id?: string;
	/** The category of the extension */
	category: string;
	/** The number of downloads for the extension */
	downloads: Record<string, number>;
	/** The languages supported by the extension */
	languages: string[];
	/** The URL to the more info page of the extension */
	moreInfoUrl: string;
	/** Handler function triggered when the more info (Website) link is clicked */
	handleMoreInfoLinkClick: () => void;
	/** Optional URL to a website link to get support for the extension */
	supportUrl: string;
	/** Handler function triggered when the support link is clicked */
	handleSupportLinkClick: () => void;
}
/**
 * This component displays the more info section of the extension which includes the category,
 * number of downloads, languages, and links to the website and support
 *
 * @param MoreInfoProps
 * @returns The more info component that displays the category, number of downloads, languages, and
 *   links to the website and support
 */
export declare function MoreInfo({ id, category, downloads, languages, moreInfoUrl, handleMoreInfoLinkClick, supportUrl, handleSupportLinkClick, }: MoreInfoProps): import("react/jsx-runtime").JSX.Element;
type VersionInformation = {
	/** Date the version was published */
	date: string;
	/** Description of the changes in the version */
	description: string;
};
/** Type to store the version history information */
export type VersionHistoryType = Record<string, VersionInformation>;
interface FooterProps {
	/** Optional unique identifier */
	id?: string;
	/** Name of the publisher */
	publisherDisplayName: string;
	/** Size of the extension file in bytes */
	fileSize: number;
	/** List of language codes supported by the extension */
	locales: string[];
	/** Object containing the version history mapped with their information */
	versionHistory: VersionHistoryType;
	/** Current version of the extension */
	currentVersion: string;
}
/**
 * Component to render the footer for the extension details which contains information on the
 * publisher, version history, languages, and file size.
 *
 * @param FooterProps
 * @returns The rendered Footer component
 */
export declare function Footer({ id, publisherDisplayName, fileSize, locales, versionHistory, currentVersion, }: FooterProps): import("react/jsx-runtime").JSX.Element;
type ClassValue$1 = ClassValue;
type ClassProp = {
	class: ClassValue$1;
	className?: never;
} | {
	class?: never;
	className: ClassValue$1;
} | {
	class?: never;
	className?: never;
};
type OmitUndefined<T> = T extends undefined ? never : T;
type VariantProps<Component extends (...args: any) => any> = Omit<OmitUndefined<Parameters<Component>[0]>, "class" | "className">;
/**
 * Style variants for the Button component.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/button}
 */
export declare const buttonVariants: (props?: ({
	variant?: "link" | "default" | "outline" | "secondary" | "destructive" | "ghost" | null | undefined;
	size?: "default" | "icon" | "sm" | "lg" | null | undefined;
} & ClassProp) | undefined) => string;
/**
 * Props for Button component
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/button}
 */
export interface ButtonProps extends React$1.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}
/**
 * The Button component displays a button or a component that looks like a button. The component is
 * built and styled by Shadcn UI.
 *
 * @param ButtonProps
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/button}
 */
export declare const Button: React$1.ForwardRefExoticComponent<ButtonProps & React$1.RefAttributes<HTMLButtonElement>>;
export type MultiSelectComboBoxEntry = {
	value: string;
	label: string;
	secondaryLabel?: string;
	starred?: boolean;
};
interface MultiSelectComboBoxProps {
	/** The list of entries to select from. */
	entries: MultiSelectComboBoxEntry[];
	/** The currently selected values. */
	selected: string[];
	/** Callback function to handle changes in selection. */
	onChange: (values: string[]) => void;
	/** Placeholder text when no items are selected. */
	placeholder: string;
	/** Whether to show select all/clear all buttons. */
	hasToggleAllFeature?: boolean;
	/** Text for the select all button. */
	selectAllText?: string;
	/** Text for the clear all button. */
	clearAllText?: string;
	/** Message displayed when no entries are found. */
	commandEmptyMessage?: string;
	/** Custom text to display when items are selected. */
	customSelectedText?: string;
	/** Whether the dropdown is open (for controlled usage). */
	isOpen?: boolean;
	/** Handler that is called when the dropdown's open state changes. */
	onOpenChange?: (open: boolean) => void;
	/** Flag to disable the component. */
	isDisabled?: boolean;
	/** Flag to sort selected items. */
	sortSelected?: boolean;
	/** Optional icon to display in the button. */
	icon?: React$1.ReactNode;
	/** Additional class names for styling. */
	className?: string;
	/** Button variant to use for the trigger button. */
	variant?: VariantProps<typeof buttonVariants>["variant"];
	/** Optional ID for the component. */
	id?: string;
}
/** MultiSelectComboBox component for selecting multiple items from a list. */
export declare function MultiSelectComboBox({ entries, selected, onChange, placeholder, hasToggleAllFeature, selectAllText, clearAllText, commandEmptyMessage, customSelectedText, isOpen, onOpenChange, isDisabled, sortSelected, icon, className, variant, id, }: MultiSelectComboBoxProps): import("react/jsx-runtime").JSX.Element;
interface FilterProps extends MultiSelectComboBoxProps {
	/**
	 * Placeholder text that will be displayed when no items are selected. It will appear at the
	 * location where the badges would be if any items were selected.
	 */
	badgesPlaceholder: string;
	/** Optional id for the component */
	id?: string;
}
/**
 * This is a variant of the {@link MultiSelectComboBox}, that shows a {@link Badge} component for each
 * selected item in the combo box. Clicking the 'X' icon on the badge will clear the item from the
 * selected options. A placeholder text must be provided through 'badgesPlaceholder'. This will be
 * displayed if no items are selected,
 */
export declare function Filter({ entries, selected, onChange, placeholder, commandEmptyMessage, customSelectedText, isDisabled, sortSelected, icon, className, badgesPlaceholder, id, }: FilterProps): import("react/jsx-runtime").JSX.Element;
export type FootnoteLayout = "horizontal" | "vertical";
/** Interface defining the properties for a single footnote item component */
export interface FootnoteItemProps {
	/**
	 * The footnote to display (typically from JSX). Note: Although {@link MarkerObject.content} is an
	 * array of {@link MarkerObject}, in practice, for footnotes that array contains only one
	 * additional level of `MarkerObject` objects. The `content` of those nested objects will be plain
	 * strings, containing the text of the individual footnote data (reference, quoted text, footnote
	 * text, etc.).
	 */
	footnote: MarkerObject;
	/**
	 * Determines how footnotes are displayed:
	 *
	 * - `'horizontal'`: caller and reference appear in a leading-aligned column, with the contents in a
	 *   second column (typically used in a wide pane below the text).
	 * - `'vertical'`: caller and reference appear on the first line, with the contents displayed
	 *   beneath (typically used side-by-side with the text).
	 *
	 * @default 'horizontal'
	 */
	layout?: FootnoteLayout;
	/** Flag indicating whether to display USFM-style markers */
	showMarkers?: boolean;
	/**
	 * A function that can interpret the two special footnote caller codes defined by USFM, `+` and
	 * `-` in order to display (or suppress display of) a meaningful caller in the context where this
	 * is being used.
	 */
	formatCaller?: (caller: string | undefined) => string | undefined;
}
/** Interface defining the properties for the FootnoteList component */
export interface FootnoteListProps {
	/** Optional additional class name for styling */
	className?: string;
	/** Optional additional class name for styling the `Card` for each `FootnoteItem` in the list */
	classNameForItems?: string;
	/** The footnotes to display (typically from JSX). See {@link FootnoteItemProps.footnote} */
	footnotes: MarkerObject[];
	/**
	 * Determines how footnotes are displayed:
	 *
	 * - `'horizontal'`: caller and reference appear in a leading-aligned column, with the contents in a
	 *   second column (typically used in a wide pane below the text).
	 * - `'vertical'`: caller and reference appear on the first line, with the contents displayed
	 *   beneath (typically used side-by-side with the text).
	 *
	 * @default 'horizontal'
	 */
	layout?: FootnoteLayout;
	/**
	 * ID provided by the caller that should change whenever the list changes (due to additions,
	 * deletions or — unlikely — reordering) )
	 */
	listId: string | number;
	/** The currently selected footnote (or undefined if none) */
	selectedFootnote?: MarkerObject;
	/** Flag indicating whether to display USFM-style markers */
	showMarkers?: boolean;
	/**
	 * Flag indicating whether to suppress USFM-style formatting.
	 *
	 * @default false
	 */
	suppressFormatting?: boolean;
	/**
	 * A function that can interpret the two special footnote caller codes defined by USFM, `+` and
	 * `-` in order to display (or suppress display of) a meaningful caller in the context where this
	 * is being used.
	 */
	formatCaller?: (caller: string | undefined, index: number) => string | undefined;
	/** Callback to handle clicking/selecting a footnote in the list */
	onFootnoteSelected?: (footnote: MarkerObject, index: number, listId: string | number) => void;
}
/**
 * Object containing all keys used for localization in the FootnoteEditor component. If you're using
 * this component in an extension, you can pass it into the useLocalizedStrings hook to easily
 * obtain the localized strings and pass them into the localizedStrings prop of this component
 */
export declare const FOOTNOTE_EDITOR_STRING_KEYS: readonly [
	"%footnoteEditor_callerDropdown_label%",
	"%footnoteEditor_callerDropdown_item_generated%",
	"%footnoteEditor_callerDropdown_item_hidden%",
	"%footnoteEditor_callerDropdown_item_custom%",
	"%footnoteEditor_callerDropdown_tooltip%",
	"%footnoteEditor_cancelButton_tooltip%",
	"%footnoteEditor_copyButton_tooltip%",
	"%footnoteEditor_noteType_crossReference_label%",
	"%footnoteEditor_noteType_endNote_label%",
	"%footnoteEditor_noteType_footnote_label%",
	"%footnoteEditor_noteType_tooltip%",
	"%footnoteEditor_noteTypeDropdown_label%",
	"%footnoteEditor_saveButton_tooltip%"
];
export type FootnoteEditorLocalizedStrings = {
	[localizedKey in (typeof FOOTNOTE_EDITOR_STRING_KEYS)[number]]?: string;
};
export type FootnoteCallerType = "generated" | "hidden" | "custom";
/** Interface containing the types of the properties that are passed to the `FootnoteEditor` */
export interface FootnoteEditorProps {
	/** Class name for styling the embedded `Editor` component in this editor popover */
	classNameForEditor?: string;
	/** Delta ops for the current note being edited that are applied to the note editorial */
	noteOps: DeltaOpInsertNoteEmbed[] | undefined;
	/** External function to handle saving changes to the footnote */
	onSave: (noteOps: DeltaOpInsertNoteEmbed[]) => void;
	/**
	 * External function to handle closing the footnote editor. Gets called when the editor is closed
	 * without saving changes
	 */
	onClose: () => void;
	/** The scripture reference for the parent editor */
	scrRef: SerializedVerseRef;
	/** The unique note key to identify the note being edited used to apply changes to the note */
	noteKey: string | undefined;
	/** View options of the parent editor */
	editorOptions: EditorOptions;
	/** Localized strings to be passed to the footnote editor component */
	localizedStrings: FootnoteEditorLocalizedStrings;
}
/**
 * Component to edit footnotes from within the editor component
 *
 * @param FootnoteEditorProps - The properties for the footnote editor component
 */
export function FootnoteEditor({ classNameForEditor, noteOps, onSave, onClose, scrRef, noteKey, editorOptions, localizedStrings, }: FootnoteEditorProps): import("react/jsx-runtime").JSX.Element;
/** `FootnoteItem` is a component that provides a read-only display of a single USFM/JSX footnote. */
export declare function FootnoteItem({ footnote, layout, formatCaller, showMarkers, }: FootnoteItemProps): import("react/jsx-runtime").JSX.Element;
/** `FootnoteList` is a component that provides a read-only display of a list of USFM/JSX footnote. */
export declare function FootnoteList({ className, classNameForItems, footnotes, layout, listId, selectedFootnote, showMarkers, suppressFormatting, formatCaller, onFootnoteSelected, }: FootnoteListProps): import("react/jsx-runtime").JSX.Element;
export type Scope = "selectedText" | "verse" | "chapter" | "book" | "selectedBooks";
type Status = "approved" | "unapproved" | "unknown";
/** Occurrence of item in inventory. Primarily used by table that shows occurrences */
export type InventoryItemOccurrence = {
	/** Reference to scripture where the item appears */
	reference: SerializedVerseRef;
	/** Snippet of scripture that contains the occurrence */
	text: string;
};
/** Data structure that contains all information on an item that is shown in an inventory */
export type InventoryTableData = {
	/**
	 * The item (e.g. a character in the characters inventory, a marker in the marker inventory) In
	 * most cases the array will only have one element. In case of additional items (e.g. the
	 * preceding marker in the markers check), the primary item should be stored in the first index.
	 * To show additional items in the inventory, make sure to configure the `additionalItemsLabels`
	 * prop for the Inventory component
	 */
	items: string[];
	/** The number of times this item occurs in the selected scope */
	count: number;
	/** The status of this item (see documentation for `Status` type for more information) */
	status: Status;
	/** Occurrences of this item in the scripture text for the selected scope */
	occurrences: InventoryItemOccurrence[];
};
/**
 * Splits USFM string into shorter line-like segments
 *
 * @param text A single (likely very large) USFM string
 * @returns An array containing the input text, split into shorter segments
 */
export declare const getLinesFromUSFM: (text: string) => string[];
/**
 * Extracts chapter or verse number from USFM strings that start with a \c or \v marker
 *
 * @param text USFM string that is expected to start with \c or \v marker
 * @returns Chapter or verse number if one is found. Else returns 0.
 */
export declare const getNumberFromUSFM: (text: string) => number | undefined;
/**
 * Gets book ID from USFM string that starts with the \id marker, and returns book number for it
 *
 * @param text USFM string that is expected to start with \id marker
 * @returns Book number corresponding to the \id marker in the input text. Returns 0 if no marker is
 *   found or the marker is not valid
 */
export declare const getBookIdFromUSFM: (text: string) => string;
/**
 * Gets the status for an item, typically used in the Inventory component
 *
 * @param item The item for which the status is being requested
 * @param approvedItems Array of approved items, typically as defined in `Settings.xml`
 * @param unapprovedItems Array of unapproved items, typically as defined in `Settings.xml`
 * @returns The status for the specified item
 */
export declare const getStatusForItem: (item: string, approvedItems: string[], unapprovedItems: string[]) => Status;
/** Represents an item in the inventory with associated text and verse reference. */
export type InventoryItem = {
	/**
	 * The label by which the item is shown in the inventory (e.g. the word that is repeated in case
	 * of the Repeated Words check). It serves as a unique identifier for the item. It usually is a
	 * string, but can be a string[] when there are multiple defining attributes (e.g. when 'show
	 * preceding marker' is enabled for the Markers Inventory, the preceding marker will be stored as
	 * the second item in the array)
	 */
	inventoryText: string | string[];
	/** The snippet of scripture where this occurrence of the `inventoryItem` is found */
	verse: string;
	/** The reference to the location where the `verse` can be found in scripture */
	verseRef: SerializedVerseRef;
	/**
	 * Offset used to locate the `inventoryText` (or inventoryText[0] in case of an array) in the
	 * `verse` string
	 */
	offset: number;
};
/**
 * Object containing all keys used for localization in this component. If you're using this
 * component in an extension, you can pass it into the useLocalizedStrings hook to easily obtain the
 * localized strings and pass them into the localizedStrings prop of this component
 */
export declare const INVENTORY_STRING_KEYS: readonly [
	"%webView_inventory_all%",
	"%webView_inventory_approved%",
	"%webView_inventory_unapproved%",
	"%webView_inventory_unknown%",
	"%webView_inventory_scope_currentBook%",
	"%webView_inventory_scope_chapter%",
	"%webView_inventory_scope_verse%",
	"%webView_inventory_filter_text%",
	"%webView_inventory_show_additional_items%",
	"%webView_inventory_occurrences_table_header_reference%",
	"%webView_inventory_occurrences_table_header_occurrence%",
	"%webView_inventory_no_results%"
];
export type InventoryLocalizedStrings = {
	[localizedInventoryKey in (typeof INVENTORY_STRING_KEYS)[number]]?: LocalizedStringValue;
};
type AdditionalItemsLabels = {
	checkboxText?: string;
	tableHeaders?: string[];
};
type InventoryProps = {
	/** The inventory items that the inventory should be populated with */
	inventoryItems: InventoryItem[] | undefined;
	/** Callback function that is executed when the scripture reference is changed */
	setVerseRef: (scriptureReference: SerializedVerseRef) => void;
	/**
	 * Object with all localized strings that the Inventory needs to work well across multiple
	 * languages. When using this component with Platform.Bible, you can import
	 * `INVENTORY_STRING_KEYS` from this library, pass it in to the Platform's localization hook, and
	 * pass the localized keys that are returned by the hook into this prop.
	 */
	localizedStrings: InventoryLocalizedStrings;
	/**
	 * Text labels for control elements and additional column headers in case your Inventory has more
	 * than one item to show (e.g. The 'Preceding Marker' in the Markers Inventory)
	 */
	additionalItemsLabels?: AdditionalItemsLabels;
	/** Array of approved items, typically as defined in `Settings.xml` */
	approvedItems: string[];
	/** Array of unapproved items, typically as defined in `Settings.xml` */
	unapprovedItems: string[];
	/** Scope of scripture that the inventory will operate on */
	scope: Scope;
	/** Callback function that is executed when the scope is changed from the Inventory */
	onScopeChange: (scope: Scope) => void;
	/**
	 * Column definitions for the Inventory data table. The most commonly used column definitions are
	 * pre-configured for your convenience and can be imported (e.g. inventoryItemColumn,
	 * inventoryAdditionalItemColumn inventoryCountColumn, and inventoryStatusColumn). If you need any
	 * other columns you can add these yourself
	 */
	columns: ColumnDef<InventoryTableData>[];
	/** Unique identifier for the Inventory component */
	id?: string;
	/** Whether the inventory items are still loading */
	areInventoryItemsLoading?: boolean;
	/** Class name to apply to the provided occurrence verse text in the `OccurrencesTable` component */
	classNameForVerseText?: string;
};
/** Inventory component that is used to view and control the status of provided project settings */
export declare function Inventory({ inventoryItems, setVerseRef, localizedStrings, additionalItemsLabels, approvedItems, unapprovedItems, scope, onScopeChange, columns, id, areInventoryItemsLoading, classNameForVerseText, }: InventoryProps): import("react/jsx-runtime").JSX.Element;
/**
 * Function that creates the item column for inventories
 *
 * @param itemLabel Localized label for the item column (e.g. 'Character', 'Repeated Word', etc.)
 * @returns Column that shows the inventory items. Should be used with the DataTable component
 */
export declare const inventoryItemColumn: (itemLabel: string) => ColumnDef<InventoryTableData>;
/**
 * Function that creates the count column for inventories. Should be used with the DataTable
 * component.
 *
 * @param countLabel Localized label for the count column
 * @returns Column that shows the number of occurrences of the related inventory items
 */
export declare const inventoryCountColumn: (countLabel: string) => ColumnDef<InventoryTableData>;
/**
 * Function that creates the status column for inventories. Should be used with the DataTable
 * component.
 *
 * @param statusLabel Localized label for the status column
 * @param approvedItems Array of approved items, typically as defined in `Settings.xml`
 * @param onApprovedItemsChange Callback function that stores the updated list of approved items
 * @param unapprovedItems Array of unapproved items, typically as defined in `Settings.xml`
 * @param onUnapprovedItemsChange Callback function that stores the updated list of unapproved items
 * @returns Column that shows the status buttons for the related inventory item. The button for the
 *   current status of the item is selected
 */
export declare const inventoryStatusColumn: (statusLabel: string, approvedItems: string[], onApprovedItemsChange: (items: string[]) => void, unapprovedItems: string[], onUnapprovedItemsChange: (items: string[]) => void) => ColumnDef<InventoryTableData>;
/**
 * Object containing all keys used for localization in the FootnoteEditor component. If you're using
 * this component in an extension, you can pass it into the useLocalizedStrings hook to easily
 * obtain the localized strings and pass them into the localizedStrings prop of this component
 */
export declare const MARKER_MENU_STRING_KEYS: readonly [
	"%markerMenu_deprecated_label%",
	"%markerMenu_disallowed_label%",
	"%markerMenu_noResults%",
	"%markerMenu_searchPlaceholder%"
];
export type MarkerMenuLocalizedStrings = {
	[localizedKey in (typeof MARKER_MENU_STRING_KEYS)[number]]?: string;
};
/** Type for the markers that contain all necessary information to be displayed in the list */
export interface MarkerMenuItem {
	/** If the item is a marker, then this is the marker code */
	marker?: string;
	/** The main title for the marker or command */
	title: string;
	/** An optional subtitle for the marker */
	subtitle?: string;
	/** Optional name of icon to use instead of the marker */
	icon?: React$1.ReactNode;
	/** Whether the command/marker is deprecated */
	isDeprecated?: boolean;
	/** Whether the command/marker is disallowed for this project */
	isDisallowed?: boolean;
	/** Function to be triggered when the marker or command is selected */
	action: () => void;
}
/** Props for the marker menu component */
export interface MarkerMenuProps {
	/** Localized strings to pass through for the marker menu */
	localizedStrings: MarkerMenuLocalizedStrings;
	/**
	 * A list of the marker menu items which can either be a marker to insert or some basic command
	 * actions
	 */
	markerMenuItems: MarkerMenuItem[];
}
/** Marker menu component to render the list of markers and a few commands in the scripture editor */
export declare function MarkerMenu({ localizedStrings, markerMenuItems }: MarkerMenuProps): import("react/jsx-runtime").JSX.Element;
/**
 * Callback function that is invoked when a user selects a menu item. Receives the full
 * `MenuItemContainingCommand` object as an argument.
 */
export interface SelectMenuItemHandler {
	(selectedMenuItem: MenuItemContainingCommand): void;
}
export type SelectedSettingsSidebarItem = {
	label: string;
	projectId?: string;
};
export type ProjectInfo = {
	projectId: string;
	projectName: string;
};
export type SettingsSidebarProps = {
	/** Optional id for testing */
	id?: string;
	/** Extension labels from contribution */
	extensionLabels: Record<string, string>;
	/** Project names and ids */
	projectInfo: ProjectInfo[];
	/** Handler for selecting a sidebar item */
	handleSelectSidebarItem: (key: string, projectId?: string) => void;
	/** The current selected value in the sidebar */
	selectedSidebarItem: SelectedSettingsSidebarItem;
	/** Label for the group of extensions setting groups */
	extensionsSidebarGroupLabel: string;
	/** Label for the group of projects settings */
	projectsSidebarGroupLabel: string;
	/** Placeholder text for the button */
	buttonPlaceholderText: string;
	/** Additional css classes to help with unique styling of the sidebar */
	className?: string;
};
/**
 * The SettingsSidebar component is a sidebar that displays a list of extension settings and project
 * settings. It can be used to navigate to different settings pages. Must be wrapped in a
 * SidebarProvider component otherwise produces errors.
 *
 * @param props - {@link SettingsSidebarProps} The props for the component.
 */
export declare function SettingsSidebar({ id, extensionLabels, projectInfo, handleSelectSidebarItem, selectedSidebarItem, extensionsSidebarGroupLabel, projectsSidebarGroupLabel, buttonPlaceholderText, className, }: SettingsSidebarProps): import("react/jsx-runtime").JSX.Element;
type SettingsSidebarContentSearchProps = SettingsSidebarProps & React$1.PropsWithChildren & {
	/** The search query in the search bar */
	searchValue: string;
	/** Handler to run when the value of the search bar changes */
	onSearch: (searchQuery: string) => void;
};
/**
 * A component that wraps a search bar and a settings sidebar, providing a way to search and
 * navigate to different settings pages.
 *
 * @param {SettingsSidebarContentSearchProps} props - The props for the component.
 * @param {string} props.id - The id of the sidebar.
 */
export declare function SettingsSidebarContentSearch({ id, extensionLabels, projectInfo, children, handleSelectSidebarItem, selectedSidebarItem, searchValue, onSearch, extensionsSidebarGroupLabel, projectsSidebarGroupLabel, buttonPlaceholderText, }: SettingsSidebarContentSearchProps): import("react/jsx-runtime").JSX.Element;
/**
 * Information (e.g., a checking error or some other type of "transient" annotation) about something
 * noteworthy at a specific place in an instance of the Scriptures.
 */
export type ScriptureItemDetail = ScriptureSelection & {
	/**
	 * Text of the error, note, etc. In the future, we might want to support something more than just
	 * text so that a JSX element could be provided with a link or some other controls related to the
	 * issue being reported.
	 */
	detail: string;
};
/**
 * A uniquely identifiable source of results that can be displayed in the ScriptureResultsViewer.
 * Generally, the source will be a particular Scripture check, but there may be other types of
 * sources.
 */
export type ResultsSource = {
	/**
	 * Uniquely identifies the source.
	 *
	 * @type {string}
	 */
	id: string;
	/**
	 * Name (potentially localized) of the source, suitable for display in the UI.
	 *
	 * @type {string}
	 */
	displayName: string;
};
export type ScriptureSrcItemDetail = ScriptureItemDetail & {
	/** Source/type of detail. Can be used for grouping. */
	source: ResultsSource;
};
/**
 * Represents a set of results keyed by Scripture reference. Generally, the source will be a
 * particular Scripture check, but this type also allows for other types of uniquely identifiable
 * sources.
 */
export type ResultsSet = {
	/**
	 * The backing source associated with this set of results.
	 *
	 * @type {ResultsSource}
	 */
	source: ResultsSource;
	/**
	 * Array of Scripture item details (messages keyed by Scripture reference).
	 *
	 * @type {ScriptureItemDetail[]}
	 */
	data: ScriptureItemDetail[];
};
export type ScriptureResultsViewerColumnInfo = {
	/** Optional header to display for the Reference column. Default value: 'Scripture Reference'. */
	scriptureReferenceColumnName?: string;
	/** Optional text to display to refer to the Scripture book group. Default value: 'Scripture Book'. */
	scriptureBookGroupName?: string;
	/** Optional header to display for the Type column. Default value: 'Type'. */
	typeColumnName?: string;
	/** Optional header to display for the Details column. Default value: 'Details' */
	detailsColumnName?: string;
};
export type ScriptureResultsViewerProps = ScriptureResultsViewerColumnInfo & {
	/** Groups of ScriptureItemDetail objects from particular sources (e.g., Scripture checks) */
	sources: ResultsSet[];
	/** Flag indicating whether to display column headers. Default is false. */
	showColumnHeaders?: boolean;
	/** Flag indicating whether to display source column. Default is false. */
	showSourceColumn?: boolean;
	/** Callback function to notify when a row is selected */
	onRowSelected?: (selectedRow: ScriptureSrcItemDetail | undefined) => void;
	/** Optional id attribute for the outermost element */
	id?: string;
};
/**
 * Component to display a combined list of detailed items from one or more sources, where the items
 * are keyed primarily by Scripture reference. This is particularly useful for displaying a list of
 * results from Scripture checks, but more generally could be used to display any "results" from any
 * source(s). The component allows for grouping by Scripture book, source, or both. By default, it
 * displays somewhat "tree-like" which allows it to be more horizontally compact and intuitive. But
 * it also has the option of displaying as a traditional table with column headings (with or without
 * the source column showing).
 */
export declare function ScriptureResultsViewer({ sources, showColumnHeaders, showSourceColumn, scriptureReferenceColumnName, scriptureBookGroupName, typeColumnName, detailsColumnName, onRowSelected, id, }: ScriptureResultsViewerProps): import("react/jsx-runtime").JSX.Element;
/**
 * Object containing all keys used for localization in this component. If you're using this
 * component in an extension, you can pass it into the useLocalizedStrings hook to easily obtain the
 * localized strings and pass them into the localizedStrings prop of this component
 */
export declare const SCOPE_SELECTOR_STRING_KEYS: readonly [
	"%webView_scope_selector_selected_text%",
	"%webView_scope_selector_current_verse%",
	"%webView_scope_selector_current_chapter%",
	"%webView_scope_selector_current_book%",
	"%webView_scope_selector_choose_books%",
	"%webView_scope_selector_scope%",
	"%webView_scope_selector_select_books%",
	"%webView_book_selector_books_selected%",
	"%webView_book_selector_select_books%",
	"%webView_book_selector_search_books%",
	"%webView_book_selector_select_all%",
	"%webView_book_selector_clear_all%",
	"%webView_book_selector_no_book_found%",
	"%webView_book_selector_more%",
	"%scripture_section_ot_long%",
	"%scripture_section_ot_short%",
	"%scripture_section_nt_long%",
	"%scripture_section_nt_short%",
	"%scripture_section_dc_long%",
	"%scripture_section_dc_short%",
	"%scripture_section_extra_long%",
	"%scripture_section_extra_short%"
];
/** Type definition for the localized strings used in this component */
export type ScopeSelectorLocalizedStrings = {
	[localizedInventoryKey in (typeof SCOPE_SELECTOR_STRING_KEYS)[number]]?: LocalizedStringValue;
};
interface ScopeSelectorProps {
	/** The current scope selection */
	scope: Scope;
	/**
	 * Optional array of scopes that should be available in the selector. If not provided, all scopes
	 * will be shown as defined in the Scope type
	 */
	availableScopes?: Scope[];
	/** Callback function that is executed when the user changes the scope selection */
	onScopeChange: (scope: Scope) => void;
	/**
	 * Information about available books, formatted as a 123 character long string as defined in a
	 * projects BooksPresent setting
	 */
	availableBookInfo: string;
	/** Array of currently selected book IDs */
	selectedBookIds: string[];
	/** Callback function that is executed when the user changes the book selection */
	onSelectedBookIdsChange: (books: string[]) => void;
	/**
	 * Object with all localized strings that the component needs to work well across multiple
	 * languages. When using this component with Platform.Bible, you can import
	 * `SCOPE_SELECTOR_STRING_KEYS` from this library, pass it in to the Platform's localization hook,
	 * and pass the localized keys that are returned by the hook into this prop.
	 */
	localizedStrings: ScopeSelectorLocalizedStrings;
	/**
	 * Optional map of localized book IDs/short names and full names. Key is the (English) book ID,
	 * value contains localized versions of the ID and full book name
	 */
	localizedBookNames?: Map<string, {
		localizedId: string;
		localizedName: string;
	}>;
	/** Optional ID that is applied to the root element of this component */
	id?: string;
}
/**
 * A component that allows users to select the scope of their search or operation. Available scopes
 * are defined in the Scope type. When 'selectedBooks' is chosen as the scope, a BookSelector
 * component is displayed to allow users to choose specific books.
 */
export declare function ScopeSelector({ scope, availableScopes, onScopeChange, availableBookInfo, selectedBookIds, onSelectedBookIdsChange, localizedStrings, localizedBookNames, id, }: ScopeSelectorProps): import("react/jsx-runtime").JSX.Element;
export type ScrollGroupSelectorProps = {
	/**
	 * List of scroll group ids to show to the user. Either a `ScrollGroupId` or `undefined` for no
	 * scroll group
	 */
	availableScrollGroupIds: (ScrollGroupId | undefined)[];
	/** Currently selected scroll group id. `undefined` for no scroll group */
	scrollGroupId: ScrollGroupId | undefined;
	/** Callback function run when the user tries to change the scroll group id */
	onChangeScrollGroupId: (newScrollGroupId: ScrollGroupId | undefined) => void;
	/**
	 * Localized strings to use for displaying scroll group ids. Must be an object whose keys are
	 * `getLocalizeKeyForScrollGroupId(scrollGroupId)` for all scroll group ids (and `undefined` if
	 * included) in {@link ScrollGroupSelectorProps.availableScrollGroupIds} and whose values are the
	 * localized strings to use for those scroll group ids.
	 *
	 * Defaults to English localizations of English alphabet for scroll groups 0-25 (e.g. 0 is A) and
	 * Ø for `undefined`. Will fill in any that are not provided with these English localizations.
	 * Also, if any values match the keys, the English localization will be used. This is useful in
	 * case you want to pass in a temporary version of the localized strings while your localized
	 * strings load.
	 *
	 * @example
	 *
	 * ```typescript
	 * const myScrollGroupIdLocalizedStrings = {
	 *   [getLocalizeKeyForScrollGroupId('undefined')]: 'Ø',
	 *   [getLocalizeKeyForScrollGroupId(0)]: 'A',
	 *   [getLocalizeKeyForScrollGroupId(1)]: 'B',
	 *   [getLocalizeKeyForScrollGroupId(2)]: 'C',
	 *   [getLocalizeKeyForScrollGroupId(3)]: 'D',
	 *   [getLocalizeKeyForScrollGroupId(4)]: 'E',
	 * };
	 * ```
	 *
	 * @example
	 *
	 * ```tsx
	 * const availableScrollGroupIds = [undefined, 0, 1, 2, 3, 4];
	 *
	 * const localizeKeys = getLocalizeKeysForScrollGroupIds();
	 *
	 * const [localizedStrings] = useLocalizedStrings(localizeKeys);
	 *
	 * ...
	 *
	 * <ScrollGroupSelector localizedStrings={localizedStrings} />
	 * ```
	 */
	localizedStrings?: LanguageStrings;
	/** Size of the scroll group dropdown button. Defaults to 'sm' */
	size?: "default" | "sm" | "lg" | "icon";
	/** Additional css classes to help with unique styling */
	className?: string;
	/** Optional id for the select element */
	id?: string;
};
/** Selector component for choosing a scroll group */
export declare function ScrollGroupSelector({ availableScrollGroupIds, scrollGroupId, onChangeScrollGroupId, localizedStrings, size, className, id, }: ScrollGroupSelectorProps): import("react/jsx-runtime").JSX.Element;
type SettingsListProps = React$1.PropsWithChildren;
/**
 * SettingsList component is a wrapper for list items. Rendered with a formatted div
 *
 * @deprecated Jul 18 2025. This component is no longer supported or tested. Use of this component
 *   is discouraged and it may be removed in the future.
 * @param children To populate the list with
 * @returns Formatted div encompassing the children
 */
export declare function SettingsList({ children }: SettingsListProps): import("react/jsx-runtime").JSX.Element;
type SettingsListItemProps = React$1.PropsWithChildren & {
	/** Primary text of the list item */
	primary: string;
	/** Optional text of the list item */
	secondary?: string | undefined;
	/** Optional boolean to display a message if the children aren't loaded yet. Defaults to false */
	isLoading?: boolean;
	/** Optional message to display if isLoading */
	loadingMessage?: string;
};
/**
 * SettingsListItem component is a common list item. Rendered with a formatted div
 *
 * @deprecated Jul 18 2025. This component is no longer supported or tested. Use of this component
 *   is discouraged and it may be removed in the future.
 * @param SettingsListItemProps
 * @returns Formatted div encompassing the list item content
 */
export declare function SettingsListItem({ primary, secondary, children, isLoading, loadingMessage, }: SettingsListItemProps): import("react/jsx-runtime").JSX.Element;
type SettingsListHeaderProps = {
	/** The primary text of the list header */
	primary: string;
	/** Optional secondary text of the list header */
	secondary?: string | undefined;
	/** Optional boolean to include a separator underneath the secondary text. Defaults to false */
	includeSeparator?: boolean;
};
/**
 * SettingsListHeader component displays text above the list
 *
 * @deprecated Jul 18 2025. This component is no longer supported or tested. Use of this component
 *   is discouraged and it may be removed in the future.
 * @param SettingsListHeaderProps
 * @returns Formatted div with list header content
 */
export declare function SettingsListHeader({ primary, secondary, includeSeparator, }: SettingsListHeaderProps): import("react/jsx-runtime").JSX.Element;
type TabDropdownMenuProps = {
	/** The handler to use for menu commands */
	onSelectMenuItem: SelectMenuItemHandler;
	/** The menu data to show on the dropdown menu */
	menuData: Localized<MultiColumnMenu>;
	/** Defines a string value that labels the current element */
	tabLabel: string;
	/** Optional icon for the dropdown menu trigger. Defaults to hamburger icon. */
	icon?: React$1.ReactNode;
	/** Additional css class(es) to help with unique styling of the tab dropdown menu */
	className?: string;
	/** Style variant for the app menubar component. */
	variant?: "default" | "muted";
	buttonVariant?: "default" | "ghost" | "outline" | "secondary";
	/** Optional unique identifier */
	id?: string;
};
/**
 * Dropdown menu designed to be used with Platform.Bible menu data. Column headers are ignored.
 * Column data is separated by a horizontal divider, so groups are not distinguishable. Tooltips are
 * displayed on hovering over menu items, if a tooltip is defined for them.
 *
 * A child component can be passed in to show as an icon on the menu trigger button.
 */
export function TabDropdownMenu({ onSelectMenuItem, menuData, tabLabel, icon, className, variant, buttonVariant, id, }: TabDropdownMenuProps): import("react/jsx-runtime").JSX.Element;
type TabToolbarCommonProps = {
	/**
	 * The handler to use for toolbar item commands related to the project menu. Here is a basic
	 * example of how to create this:
	 *
	 * @example
	 *
	 * ```tsx
	 * const projectMenuCommandHandler: SelectMenuItemHandler = async (selectedMenuItem) => {
	 *   const commandName = selectedMenuItem.command;
	 *   try {
	 *     // Assert the more specific type. Assert the more specific type. The menu data should
	 *     // specify a valid command name here. If not, the error will be caught.
	 *     // eslint-disable-next-line no-type-assertion/no-type-assertion
	 *     await papi.commands.sendCommand(commandName as CommandNames);
	 *   } catch (e) {
	 *     throw new Error(
	 *       `handleMenuCommand error: command: ${commandName}. ${JSON.stringify(e)}`,
	 *     );
	 *   }
	 * };
	 * ```
	 */
	onSelectProjectMenuItem: SelectMenuItemHandler;
	/**
	 * Menu data that is used to populate the Menubar component for the project menu. In an extension,
	 * the menu data comes from menus.json in the contributions folder. To access that info, use
	 * useMemo to get the WebViewMenu.
	 */
	projectMenuData?: Localized<MultiColumnMenu>;
	/** Optional unique identifier */
	id?: string;
	/** Additional css classes to help with unique styling of the extensible toolbar */
	className?: string;
	/** Icon that will be displayed on the Menu Button. Defaults to the hamburger menu icon. */
	menuButtonIcon?: React$1.ReactNode;
};
export type TabToolbarProps = TabToolbarCommonProps & {
	/**
	 * The handler to use for toolbar item commands related to the tab view menu. Here is a basic
	 * example of how to create this from the hello-rock3 extension:
	 *
	 * @example
	 *
	 * ```tsx
	 * const projectMenuCommandHandler: SelectMenuItemHandler = async (selectedMenuItem) => {
	 *   const commandName = selectedMenuItem.command;
	 *   try {
	 *     // Assert the more specific type. Assert the more specific type. The menu data should
	 *     // specify a valid command name here. If not, the error will be caught.
	 *     // eslint-disable-next-line no-type-assertion/no-type-assertion
	 *     await papi.commands.sendCommand(commandName as CommandNames);
	 *   } catch (e) {
	 *     throw new Error(
	 *       `handleMenuCommand error: command: ${commandName}. ${JSON.stringify(e)}`,
	 *     );
	 *   }
	 * };
	 * ```
	 */
	onSelectViewInfoMenuItem: SelectMenuItemHandler;
	/** Menu data that is used to populate the Menubar component for the view info menu */
	tabViewMenuData?: Localized<MultiColumnMenu>;
	/**
	 * Toolbar children to be put at the start of the the toolbar after the project menu icon (left
	 * side in ltr, right side in rtl). Recommended for inner navigation.
	 */
	startAreaChildren?: React$1.ReactNode;
	/** Toolbar children to be put in the center area of the the toolbar. Recommended for tools. */
	centerAreaChildren?: React$1.ReactNode;
	/**
	 * Toolbar children to be put at the end of the the toolbar before the tab view menu icon (right
	 * side in ltr, left side in rtl). Recommended for secondary tools and view options.
	 */
	endAreaChildren?: React$1.ReactNode;
};
/**
 * Toolbar that holds the project menu icon on one side followed by three different areas/categories
 * for toolbar icons followed by an optional view info menu icon. See the Tab Floating Menu Button
 * component for a menu component that takes up less screen real estate yet is always visible.
 */
export declare function TabToolbar({ onSelectProjectMenuItem, onSelectViewInfoMenuItem, projectMenuData, tabViewMenuData, id, className, startAreaChildren, centerAreaChildren, endAreaChildren, menuButtonIcon, }: TabToolbarProps): import("react/jsx-runtime").JSX.Element;
/**
 * Renders a TabDropdownMenu with a trigger button that looks like the menuButtonIcon or like the
 * default of three stacked horizontal lines (aka the hamburger). The menu "floats" over the content
 * so it is always visible. When clicked, it displays a dropdown menu with the projectMenuData.
 */
export declare function TabFloatingMenu({ onSelectProjectMenuItem, projectMenuData, id, className, menuButtonIcon, }: TabToolbarCommonProps): import("react/jsx-runtime").JSX.Element;
export type TabKeyValueContent = {
	key: string;
	value: string;
	content: React$1.ReactNode;
};
type TabNavigationContentSearchProps = {
	/** List of values and keys for each tab this component should provide */
	tabList: TabKeyValueContent[];
	/** The search query in the search bar */
	searchValue: string;
	/** Handler to run when the value of the search bar changes */
	onSearch: (searchQuery: string) => void;
	/** Optional placeholder for the search bar */
	searchPlaceholder?: string;
	/** Optional title to include in the header */
	headerTitle?: string;
	/** Optional className to modify the search input */
	searchClassName?: string;
	/** Optional id for the root element */
	id?: string;
};
/**
 * TabNavigationContentSearch component provides a vertical tab navigation interface with a search
 * bar at the top. This component allows users to filter content within tabs based on a search
 * query.
 *
 * @param {TabNavigationContentSearchProps} props
 * @param {TabKeyValueContent[]} props.tabList - List of objects containing keys, values, and
 *   content for each tab to be displayed.
 * @param {string} props.searchValue - The current value of the search input.
 * @param {function} props.onSearch - Callback function called when the search input changes;
 *   receives the new search query as an argument.
 * @param {string} [props.searchPlaceholder] - Optional placeholder text for the search input.
 * @param {string} [props.headerTitle] - Optional title to display above the search input.
 * @param {string} [props.searchClassName] - Optional CSS class name to apply custom styles to the
 *   search input.
 * @param {string} [props.id] - Optional id for the root element.
 */
declare function TabNavigationContentSearch({ tabList, searchValue, onSearch, searchPlaceholder, headerTitle, searchClassName, id, }: TabNavigationContentSearchProps): import("react/jsx-runtime").JSX.Element;
export type ToolbarProps = React$1.PropsWithChildren<{
	/** The handler to use for menu commands (and eventually toolbar commands). */
	onSelectMenuItem: SelectMenuItemHandler;
	/**
	 * Menu data that is used to populate the Menubar component. If empty object, no menus will be
	 * shown on the App Menubar
	 */
	menuData?: Localized<MultiColumnMenu>;
	/**
	 * Optional callback function that is executed whenever a menu on the App Menubar is opened or
	 * closed. Helpful for handling updates to the menu, as changing menu data when the menu is opened
	 * is not desirable.
	 */
	onOpenChange?: (isOpen: boolean) => void;
	/** Optional unique identifier */
	id?: string;
	/** Additional css classes to help with unique styling of the toolbar */
	className?: string;
	/**
	 * Whether the toolbar should be used as a draggable area for moving the application. This will
	 * add an electron specific style `WebkitAppRegion: 'drag'` to the toolbar in order to make it
	 * draggable. See:
	 * https://www.electronjs.org/docs/latest/tutorial/custom-title-bar#create-a-custom-title-bar
	 */
	shouldUseAsAppDragArea?: boolean;
	/** Toolbar children to be put at the start of the toolbar (left side in ltr, right side in rtl) */
	appMenuAreaChildren?: React$1.ReactNode;
	/** Toolbar children to be put at the end of the toolbar (right side in ltr, left side in rtl) */
	configAreaChildren?: React$1.ReactNode;
	/** Variant of the menubar */
	menubarVariant?: "default" | "muted";
}>;
/**
 * Get tailwind class for reserved space for the window controls / macos "traffic lights". Passing
 * 'darwin' will reserve the necessary space for macos traffic lights at the start, otherwise a
 * different amount of space at the end for the window controls.
 *
 * Apply to the toolbar like: `<Toolbar className={cn('tw-h-8 tw-bg-background',
 * getToolbarOSReservedSpaceClassName('darwin'))}>` or `<Toolbar
 * className={getToolbarOSReservedSpaceClassName('linux')}>`
 *
 * @param operatingSystem The os platform: 'darwin' (macos) | anything else
 * @returns The class name to apply to the toolbar if os specific space should be reserved
 */
export declare function getToolbarOSReservedSpaceClassName(operatingSystem: string | undefined): string | undefined;
/**
 * A customizable toolbar component with a menubar, content area, and configure area.
 *
 * This component is designed to be used in the window title bar of an electron application.
 *
 * @param {ToolbarProps} props - The props for the component.
 */
export declare function Toolbar({ menuData, onOpenChange, onSelectMenuItem, className, id, children, appMenuAreaChildren, configAreaChildren, shouldUseAsAppDragArea, menubarVariant, }: ToolbarProps): import("react/jsx-runtime").JSX.Element;
declare const UI_LANGUAGE_SELECTOR_STRING_KEYS: readonly [
	"%settings_uiLanguageSelector_fallbackLanguages%"
];
type UiLanguageSelectorLocalizedStrings = {
	[localizedUiLanguageSelectorKey in (typeof UI_LANGUAGE_SELECTOR_STRING_KEYS)[number]]?: LocalizedStringValue;
};
export type LanguageInfo = {
	/** The name of the language to be displayed (in its native script) */
	autonym: string;
	/**
	 * The name of the language in other languages, so that the language can also be displayed in the
	 * current UI language, if known.
	 */
	uiNames?: Record<string, string>;
	/**
	 * Other known names of the language (for searching). This can include pejorative names and should
	 * never be displayed unless typed by the user.
	 */
	otherNames?: string[];
};
export type UiLanguageSelectorProps = {
	/** Full set of known languages to display. The keys are valid BCP-47 tags. */
	knownUiLanguages: Record<string, LanguageInfo>;
	/** IETF BCP-47 language tag of the current primary UI language. `undefined` => 'en' */
	primaryLanguage: string;
	/**
	 * Ordered list of fallback language tags to use if the localization key can't be found in the
	 * current primary UI language. This list never contains English ('en') because it is the ultimate
	 * fallback.
	 */
	fallbackLanguages: string[] | undefined;
	/**
	 * Handler for when either the primary or the fallback languages change (or both). For this
	 * handler, the primary UI language is the first one in the array, followed by the fallback
	 * languages in order of decreasing preference.
	 */
	onLanguagesChange?: (newUiLanguages: string[]) => void;
	/** Handler for the primary language changes. */
	onPrimaryLanguageChange?: (newPrimaryUiLanguage: string) => void;
	/**
	 * Handler for when the fallback languages change. The array contains the fallback languages in
	 * order of decreasing preference.
	 */
	onFallbackLanguagesChange?: (newFallbackLanguages: string[]) => void;
	/**
	 * Map whose keys are localized string keys as contained in UI_LANGUAGE_SELECTOR_STRING_KEYS and
	 * whose values are the localized strings (in the current UI language).
	 */
	localizedStrings: UiLanguageSelectorLocalizedStrings;
	/** Additional css classes to help with unique styling of the control */
	className?: string;
	/** Optional id for the root element */
	id?: string;
};
/**
 * A component for selecting the user interface language and managing fallback languages. Allows
 * users to choose a primary UI language and optionally select fallback languages.
 *
 * @param {UiLanguageSelectorProps} props - The props for the component.
 */
export declare function UiLanguageSelector({ knownUiLanguages, primaryLanguage, fallbackLanguages, onLanguagesChange, onPrimaryLanguageChange, onFallbackLanguagesChange, localizedStrings, className, id, }: UiLanguageSelectorProps): import("react/jsx-runtime").JSX.Element;
export type ChecklistProps = {
	/** Optional string representing the id attribute of the Checklist */
	id?: string;
	/** Optional string representing CSS class name(s) for styling */
	className?: string;
	/** Array of strings representing the checkable items */
	listItems: string[];
	/** Array of strings representing the checked items */
	selectedListItems: string[];
	/**
	 * Function that is called when a checkbox item is selected or deselected
	 *
	 * @param item The string description for this item
	 * @param selected True if selected, false if not selected
	 */
	handleSelectListItem: (item: string, selected: boolean) => void;
	/**
	 * Optional function creates a label for a provided checkable item
	 *
	 * @param item The item for which a label is to be created
	 * @returns A string representing the label text for the checkbox associated with that item
	 */
	createLabel?: (item: string) => string;
	/**
	 * Optional function creates a label for a provided checkable item
	 *
	 * @param item The item for which a label is to be created, including text and any additional
	 *   elements (e.g. links)
	 * @returns A react node representing the label text and any additional elements (e.g. links) for
	 *   the checkbox associated with that item
	 */
	createComplexLabel?: (item: string) => React$1.ReactNode;
};
/** Renders a list of checkboxes. Each checkbox corresponds to an item from the `listItems` array. */
export declare function Checklist({ id, className, listItems, selectedListItems, handleSelectListItem, createLabel, createComplexLabel, }: ChecklistProps): import("react/jsx-runtime").JSX.Element;
export type ComboBoxLabelOption = {
	label: string;
	secondaryLabel?: string;
};
export type ComboBoxOption = string | number | ComboBoxLabelOption;
/** Represents a group of options with an optional heading */
export type ComboBoxGroup<T> = {
	/** The heading text for this group of options */
	groupHeading: string;
	/** The options within this group */
	options: readonly T[];
};
export type ComboBoxProps<T> = {
	/** Optional unique identifier */
	id?: string;
	/**
	 * List of available options for the dropdown menu. Can be either:
	 *
	 * - A flat array of options (single group, no heading)
	 * - An array of group objects. Each group has a heading and an array of options
	 */
	options?: readonly T[] | readonly ComboBoxGroup<T>[];
	/** @deprecated 3 December 2024. Renamed to `buttonClassName` */
	className?: string;
	/** Additional css classes to help with unique styling of the combo box button */
	buttonClassName?: string;
	/** Additional css classes to help with unique styling of the combo box popover */
	popoverContentClassName?: string;
	/**
	 * The selected value that the combo box currently holds. Must be shallow equal to one of the
	 * options entries.
	 */
	value?: T;
	/** Triggers when content of textfield is changed */
	onChange?: (newValue: T) => void;
	/** Used to determine the string value for a given option. */
	getOptionLabel?: (option: T) => string;
	/**
	 * Used to determine the string value to display on the button for the selected value. If not
	 * provided, falls back to `getOptionLabel`.
	 */
	getButtonLabel?: (option: T) => string;
	/** Icon to be displayed on the trigger */
	icon?: React$1.ReactNode;
	/** Text displayed on button if `value` is undefined */
	buttonPlaceholder?: string;
	/** Placeholder text for text field */
	textPlaceholder?: string;
	/** Text to display when no options match input */
	commandEmptyMessage?: string;
	/** Variant of button */
	buttonVariant?: ButtonProps["variant"];
	/** Control how the popover menu should be aligned. Defaults to start */
	alignDropDown?: "start" | "center" | "end";
	/** Optional boolean to set if trigger should be disabled */
	isDisabled?: boolean;
	/** Optional aria-label for the trigger button for accessibility */
	ariaLabel?: string;
} & PopoverProps;
/**
 * Autocomplete input and command palette with a list of suggestions.
 *
 * Thanks to Shadcn for heavy inspiration and documentation
 * https://ui.shadcn.com/docs/components/combobox
 */
export declare function ComboBox<T extends ComboBoxOption = ComboBoxOption>({ id, options, className, buttonClassName, popoverContentClassName, value, onChange, getOptionLabel, getButtonLabel, icon, buttonPlaceholder, textPlaceholder, commandEmptyMessage, buttonVariant, alignDropDown, isDisabled, ariaLabel, ...props }: ComboBoxProps<T>): import("react/jsx-runtime").JSX.Element;
interface ResultsCardProps {
	/** Unique key for the card */
	cardKey: string;
	/** Whether this card is currently selected/focused */
	isSelected: boolean;
	/** Callback function called when the card is clicked */
	onSelect: () => void;
	/** Whether the content of this card are in a denied state */
	isDenied?: boolean;
	/** Whether the card should be hidden */
	isHidden?: boolean;
	/** Additional CSS classes to apply to the card */
	className?: string;
	/** Main content to display on the card */
	children: React$1.ReactNode;
	/** Content to show in the dropdown menu when selected */
	dropdownContent?: React$1.ReactNode;
	/** Additional content to show below the main content when selected */
	additionalSelectedContent?: React$1.ReactNode;
	/** Color to use for the card's accent border */
	accentColor?: string;
}
/**
 * ResultsCard is a base component for displaying scripture-related results in a card format, even
 * though it is not based on the Card component. It provides common functionality like selection
 * state, dropdown menus, and expandable content.
 */
export declare function ResultsCard({ cardKey, isSelected, onSelect, isDenied, isHidden, className, children, dropdownContent, additionalSelectedContent, accentColor, }: ResultsCardProps): import("react/jsx-runtime").JSX.Element;
/** Props for the SearchBar component. */
export type SearchBarProps = {
	/** Search query for the search bar */
	value: string;
	/**
	 * Callback fired to handle the search query is updated
	 *
	 * @param searchQuery
	 */
	onSearch: (searchQuery: string) => void;
	/** Optional string that appears in the search bar without a search string */
	placeholder?: string;
	/** Optional boolean to set the input base to full width */
	isFullWidth?: boolean;
	/** Additional css classes to help with unique styling of the search bar */
	className?: string;
	/** Optional boolean to disable the search bar */
	isDisabled?: boolean;
	/** Optional id for the root element */
	id?: string;
};
/**
 * A search bar component with a search icon and a clear button when the search query is not empty.
 *
 * @param {SearchBarProps} props - The props for the component.
 * @param {string} props.value - The search query for the search bar
 * @param {(searchQuery: string) => void} props.onSearch - Callback fired to handle the search query
 *   is updated
 * @param {string} [props.placeholder] - Optional string that appears in the search bar without a
 *   search string
 * @param {boolean} [props.isFullWidth] - Optional boolean to set the input base to full width
 * @param {string} [props.className] - Additional css classes to help with unique styling of the
 *   search bar
 * @param {boolean} [props.isDisabled] - Optional boolean to disable the search bar
 * @param {string} [props.id] - Optional id for the root element
 */
export declare const SearchBar: import("react").ForwardRefExoticComponent<SearchBarProps & import("react").RefAttributes<HTMLInputElement>>;
export type SpinnerProps = LucideProps;
/**
 * A spinner component that uses the LoaderCircle icon from lucide-react to indicate loading states.
 * The spinner rotates to indicate that a process is ongoing.
 */
export declare const Spinner: import("react").ForwardRefExoticComponent<Omit<LucideProps, "ref"> & import("react").RefAttributes<SVGSVGElement>>;
export type TextFieldProps = {
	/** Optional unique identifier */
	id?: string;
	/**
	 * If `true`, the component is disabled.
	 *
	 * @default false
	 */
	isDisabled?: boolean;
	/**
	 * If `true`, the label is displayed in an error state.
	 *
	 * @default false
	 */
	hasError?: boolean;
	/**
	 * If `true`, the input will take up the full width of its container.
	 *
	 * @default false
	 */
	isFullWidth?: boolean;
	/** Text that gives the user instructions on what contents the TextField expects */
	helperText?: string;
	/** The title of the TextField */
	label?: string;
	/** The short hint displayed in the `input` before the user enters a value. */
	placeholder?: string;
	/**
	 * If `true`, the label is displayed as required and the `input` element is required.
	 *
	 * @default false
	 */
	isRequired?: boolean;
	/** Additional css classes to help with unique styling of the text field */
	className?: string;
	/** Starting value for the text field if it is not controlled */
	defaultValue?: string | number;
	/** Value of the text field if controlled */
	value?: string | number;
	/** Triggers when content of textfield is changed */
	onChange?: React$1.ChangeEventHandler<HTMLInputElement>;
	/** Triggers when textfield gets focus */
	onFocus?: React$1.FocusEventHandler<HTMLInputElement>;
	/** Triggers when textfield loses focus */
	onBlur?: React$1.FocusEventHandler<HTMLInputElement>;
};
/**
 * Text input field
 *
 * Thanks to Shadcn for heavy inspiration and documentation
 * https://ui.shadcn.com/docs/components/input#with-label
 */
export declare function TextField({ id, isDisabled, hasError, isFullWidth, helperText, label, placeholder, isRequired, className, defaultValue, value, onChange, onFocus, onBlur, }: TextFieldProps): import("react/jsx-runtime").JSX.Element;
/**
 * The Alert displays a callout for user attention. The component is built and styled by Shadcn UI.
 * See Shadcn UI Documentation https://ui.shadcn.com/docs/components/alert
 */
export declare const Alert: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & VariantProps<(props?: ({
	variant?: "default" | "destructive" | null | undefined;
} & ClassProp) | undefined) => string> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Alert */
export declare const AlertTitle: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLHeadingElement> & React$1.RefAttributes<HTMLParagraphElement>>;
/** @inheritdoc Alert */
export declare const AlertDescription: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLParagraphElement> & React$1.RefAttributes<HTMLParagraphElement>>;
/**
 * The Avatar component displays a user's profile picture or initials. The component is built and
 * styled by Shadcn UI. See Shadcn UI Documentation https://ui.shadcn.com/docs/components/avatar
 */
export declare const Avatar: React$1.ForwardRefExoticComponent<Omit<AvatarPrimitive.AvatarProps & React$1.RefAttributes<HTMLSpanElement>, "ref"> & React$1.RefAttributes<HTMLSpanElement>>;
/** @inheritdoc Avatar */
export declare const AvatarImage: React$1.ForwardRefExoticComponent<Omit<AvatarPrimitive.AvatarImageProps & React$1.RefAttributes<HTMLImageElement>, "ref"> & React$1.RefAttributes<HTMLImageElement>>;
/** @inheritdoc Avatar */
export declare const AvatarFallback: React$1.ForwardRefExoticComponent<Omit<AvatarPrimitive.AvatarFallbackProps & React$1.RefAttributes<HTMLSpanElement>, "ref"> & React$1.RefAttributes<HTMLSpanElement>>;
/**
 * Style variants for the Badge component.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/badge}
 */
export declare const badgeVariants: (props?: ({
	variant?: "default" | "outline" | "muted" | "secondary" | "destructive" | "ghost" | "blueIndicator" | "mutedIndicator" | null | undefined;
} & ClassProp) | undefined) => string;
/**
 * Props for the Badge component.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/badge}
 */
export interface BadgeProps extends React$1.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {
}
/**
 * The Badge component displays a badge or a component that looks like a badge. The component is
 * built and styled by Shadcn UI.
 *
 * @param BadgeProps
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/badge}
 */
export declare const Badge: React$1.ForwardRefExoticComponent<BadgeProps & React$1.RefAttributes<HTMLDivElement>>;
/**
 * The Card component displays a card with header, content, and footer. This component is built and
 * styled with Shadcn UI. See Shadcn UI Documentation: https://ui.shadcn.com/docs/components/card
 */
export declare const Card: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Card */
export declare const CardHeader: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Card */
export declare const CardTitle: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLHeadingElement> & React$1.RefAttributes<HTMLParagraphElement>>;
/** @inheritdoc Card */
export declare const CardDescription: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLParagraphElement> & React$1.RefAttributes<HTMLParagraphElement>>;
/** @inheritdoc Card */
export declare const CardContent: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Card */
export declare const CardFooter: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * Checkbox component provides a control that allows the user to toggle between checked and not
 * checked. This components is built on Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/checkbox}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/checkbox}
 */
export declare const Checkbox: React$1.ForwardRefExoticComponent<Omit<CheckboxPrimitive.CheckboxProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/**
 * Command menu for React. These components are built on cmdk and styled with Shadcn UI. See Shadcn
 * UI documentation: https://ui.shadcn.com/docs/components/command See cmdk documentation:
 * https://cmdk.paco.me/
 */
export declare const Command: React$1.ForwardRefExoticComponent<Omit<{
	children?: React$1.ReactNode;
} & Pick<Pick<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof React$1.HTMLAttributes<HTMLDivElement>> & {
	ref?: React$1.Ref<HTMLDivElement>;
} & {
	asChild?: boolean;
}, "key" | keyof React$1.HTMLAttributes<HTMLDivElement> | "asChild"> & {
	label?: string;
	shouldFilter?: boolean;
	filter?: (value: string, search: string, keywords?: string[]) => number;
	defaultValue?: string;
	value?: string;
	onValueChange?: (value: string) => void;
	loop?: boolean;
	disablePointerSelection?: boolean;
	vimBindings?: boolean;
} & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Command */
export declare const CommandInput: React$1.ForwardRefExoticComponent<Omit<Omit<Pick<Pick<React$1.DetailedHTMLProps<React$1.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, "key" | keyof React$1.InputHTMLAttributes<HTMLInputElement>> & {
	ref?: React$1.Ref<HTMLInputElement>;
} & {
	asChild?: boolean;
}, "key" | keyof React$1.InputHTMLAttributes<HTMLInputElement> | "asChild">, "type" | "value" | "onChange"> & {
	value?: string;
	onValueChange?: (search: string) => void;
} & React$1.RefAttributes<HTMLInputElement>, "ref"> & React$1.RefAttributes<HTMLInputElement>>;
/** @inheritdoc Command */
export declare const CommandList: React$1.ForwardRefExoticComponent<Omit<{
	children?: React$1.ReactNode;
} & Pick<Pick<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof React$1.HTMLAttributes<HTMLDivElement>> & {
	ref?: React$1.Ref<HTMLDivElement>;
} & {
	asChild?: boolean;
}, "key" | keyof React$1.HTMLAttributes<HTMLDivElement> | "asChild"> & {
	label?: string;
} & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Command */
export declare const CommandEmpty: React$1.ForwardRefExoticComponent<Omit<{
	children?: React$1.ReactNode;
} & Pick<Pick<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof React$1.HTMLAttributes<HTMLDivElement>> & {
	ref?: React$1.Ref<HTMLDivElement>;
} & {
	asChild?: boolean;
}, "key" | keyof React$1.HTMLAttributes<HTMLDivElement> | "asChild"> & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Command */
export declare const CommandGroup: React$1.ForwardRefExoticComponent<Omit<{
	children?: React$1.ReactNode;
} & Omit<Pick<Pick<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof React$1.HTMLAttributes<HTMLDivElement>> & {
	ref?: React$1.Ref<HTMLDivElement>;
} & {
	asChild?: boolean;
}, "key" | keyof React$1.HTMLAttributes<HTMLDivElement> | "asChild">, "value" | "heading"> & {
	heading?: React$1.ReactNode;
	value?: string;
	forceMount?: boolean;
} & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Command */
export declare const CommandItem: React$1.ForwardRefExoticComponent<Omit<{
	children?: React$1.ReactNode;
} & Omit<Pick<Pick<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof React$1.HTMLAttributes<HTMLDivElement>> & {
	ref?: React$1.Ref<HTMLDivElement>;
} & {
	asChild?: boolean;
}, "key" | keyof React$1.HTMLAttributes<HTMLDivElement> | "asChild">, "value" | "disabled" | "onSelect"> & {
	disabled?: boolean;
	onSelect?: (value: string) => void;
	value?: string;
	keywords?: string[];
	forceMount?: boolean;
} & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * Context Menu component displays a menu to the user — such as a set of actions or functions,
 * triggered by a button.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/context-menu}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/context-menu}
 */
export declare const ContextMenu: React$1.FC<ContextMenuPrimitive.ContextMenuProps>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuTrigger: React$1.ForwardRefExoticComponent<ContextMenuPrimitive.ContextMenuTriggerProps & React$1.RefAttributes<HTMLSpanElement>>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuGroup: React$1.ForwardRefExoticComponent<ContextMenuPrimitive.ContextMenuGroupProps & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuPortal: React$1.FC<ContextMenuPrimitive.ContextMenuPortalProps>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuSub: React$1.FC<ContextMenuPrimitive.ContextMenuSubProps>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuRadioGroup: React$1.ForwardRefExoticComponent<ContextMenuPrimitive.ContextMenuRadioGroupProps & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuSubTrigger: React$1.ForwardRefExoticComponent<Omit<ContextMenuPrimitive.ContextMenuSubTriggerProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	inset?: boolean;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuSubContent: React$1.ForwardRefExoticComponent<Omit<ContextMenuPrimitive.ContextMenuSubContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuContent: React$1.ForwardRefExoticComponent<Omit<ContextMenuPrimitive.ContextMenuContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuItem: React$1.ForwardRefExoticComponent<Omit<ContextMenuPrimitive.ContextMenuItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	inset?: boolean;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuCheckboxItem: React$1.ForwardRefExoticComponent<Omit<ContextMenuPrimitive.ContextMenuCheckboxItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuRadioItem: React$1.ForwardRefExoticComponent<Omit<ContextMenuPrimitive.ContextMenuRadioItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuLabel: React$1.ForwardRefExoticComponent<Omit<ContextMenuPrimitive.ContextMenuLabelProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	inset?: boolean;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc ContextMenu */
export declare const ContextMenuSeparator: React$1.ForwardRefExoticComponent<Omit<ContextMenuPrimitive.ContextMenuSeparatorProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc ContextMenu */
export declare function ContextMenuShortcut({ className, ...props }: React$1.HTMLAttributes<HTMLSpanElement>): import("react/jsx-runtime").JSX.Element;
export declare namespace ContextMenuShortcut {
	var displayName: string;
}
/**
 * A drawer component for React. These components are built on Vaul and styled with Shadcn UI. See
 * Shadcn UI Documentation: https://ui.shadcn.com/docs/components/drawer See Vaul Documentation:
 * https://vaul.emilkowal.ski/getting-started
 */
export declare function Drawer({ shouldScaleBackground, direction, ...props }: React$1.ComponentProps<typeof DrawerPrimitive.Root>): import("react/jsx-runtime").JSX.Element;
export declare namespace Drawer {
	var displayName: string;
}
/** @inheritdoc Drawer */
export declare const DrawerTrigger: React$1.ForwardRefExoticComponent<import("@radix-ui/react-dialog").DialogTriggerProps & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc Drawer */
export declare const DrawerPortal: typeof import("vaul").Portal;
/** @inheritdoc Drawer */
export declare const DrawerClose: React$1.ForwardRefExoticComponent<import("@radix-ui/react-dialog").DialogCloseProps & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc Drawer */
export declare const DrawerOverlay: React$1.ForwardRefExoticComponent<Omit<Omit<import("@radix-ui/react-dialog").DialogOverlayProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
interface DrawerContentProps extends React$1.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content> {
	/** Optionally hide the drawer handle */
	hideDrawerHandle?: boolean;
}
/** @inheritdoc Drawer */
export declare const DrawerContent: React$1.ForwardRefExoticComponent<DrawerContentProps & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Drawer */
export declare function DrawerHeader({ className, ...props }: React$1.HTMLAttributes<HTMLDivElement>): import("react/jsx-runtime").JSX.Element;
export declare namespace DrawerHeader {
	var displayName: string;
}
/** @inheritdoc Drawer */
export declare function DrawerFooter({ className, ...props }: React$1.HTMLAttributes<HTMLDivElement>): import("react/jsx-runtime").JSX.Element;
export declare namespace DrawerFooter {
	var displayName: string;
}
/** @inheritdoc Drawer */
export declare const DrawerTitle: React$1.ForwardRefExoticComponent<Omit<import("@radix-ui/react-dialog").DialogTitleProps & React$1.RefAttributes<HTMLHeadingElement>, "ref"> & React$1.RefAttributes<HTMLHeadingElement>>;
/** @inheritdoc Drawer */
export declare const DrawerDescription: React$1.ForwardRefExoticComponent<Omit<import("@radix-ui/react-dialog").DialogDescriptionProps & React$1.RefAttributes<HTMLParagraphElement>, "ref"> & React$1.RefAttributes<HTMLParagraphElement>>;
type MenuContextProps = {
	variant?: "default" | "muted";
};
/**
 * Dropdown Menu components providing accessible dropdown menus and submenus. These components are
 * built on Radix UI primitives and styled with Shadcn UI. See Shadcn UI Documentation:
 * https://ui.shadcn.com/docs/components/dropdown-menu See Radix UI Documentation:
 * https://www.radix-ui.com/primitives/docs/components/dropdown-menu
 */
export type DropdownMenuProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Root> & {
	variant?: MenuContextProps["variant"];
};
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuTrigger: React$1.ForwardRefExoticComponent<DropdownMenuPrimitive.DropdownMenuTriggerProps & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuGroup: React$1.ForwardRefExoticComponent<DropdownMenuPrimitive.DropdownMenuGroupProps & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuPortal: React$1.FC<DropdownMenuPrimitive.DropdownMenuPortalProps>;
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuSub: React$1.FC<DropdownMenuPrimitive.DropdownMenuSubProps>;
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuRadioGroup: React$1.ForwardRefExoticComponent<DropdownMenuPrimitive.DropdownMenuRadioGroupProps & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc DropdownMenuProps */
export type DropdownMenuSubTriggerProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
	className?: string;
	inset?: boolean;
};
/** @inheritdoc DropdownMenuProps */
export type DropdownMenuSubContentProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent> & {
	className?: string;
};
/** @inheritdoc DropdownMenuProps */
export type DropdownMenuContentProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content> & {
	className?: string;
	sideOffset?: number;
};
/** @inheritdoc DropdownMenuProps */
export type DropdownMenuItemProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
	className?: string;
	inset?: boolean;
};
/** @inheritdoc DropdownMenuProps */
export type DropdownMenuCheckboxItemProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem> & {
	className?: string;
	checked?: boolean;
};
/** @inheritdoc DropdownMenuProps */
export type DropdownMenuRadioItemProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem> & {
	className?: string;
};
/** @inheritdoc DropdownMenuProps */
export type DropdownMenuLabelProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
	className?: string;
	inset?: boolean;
};
/** @inheritdoc DropdownMenuProps */
export type DropdownMenuSeparatorProps = React$1.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator> & {
	className?: string;
};
/** @inheritdoc DropdownMenuProps */
export type DropdownMenuShortcutProps = React$1.HTMLAttributes<HTMLSpanElement> & {
	className?: string;
};
/** @inheritdoc DropdownMenuProps */
export declare function DropdownMenu({ variant, ...props }: DropdownMenuProps): import("react/jsx-runtime").JSX.Element;
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuSubTrigger: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuSubTriggerProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
	inset?: boolean;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuSubContent: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuSubContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuContent: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
	sideOffset?: number;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuItem: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
	inset?: boolean;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuCheckboxItem: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuCheckboxItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
	checked?: boolean;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuRadioItem: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuRadioItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuLabel: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuLabelProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
	inset?: boolean;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc DropdownMenuProps */
export declare const DropdownMenuSeparator: React$1.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuSeparatorProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc DropdownMenuProps */
export declare function DropdownMenuShortcut({ className, ...props }: DropdownMenuShortcutProps): import("react/jsx-runtime").JSX.Element;
export declare namespace DropdownMenuShortcut {
	var displayName: string;
}
interface InputProps extends React$1.InputHTMLAttributes<HTMLInputElement> {
}
/**
 * Input component displays a form input field or a component that looks like an input field. This
 * components is built and styled with Shadcn UI.
 *
 * @param InputProps
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/input}
 */
export declare const Input: React$1.ForwardRefExoticComponent<InputProps & React$1.RefAttributes<HTMLInputElement>>;
/**
 * The Label component renders an accessible label associated with controls. This components is
 * built on Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/label}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/label}
 */
export declare const Label: React$1.ForwardRefExoticComponent<Omit<LabelPrimitive.LabelProps & React$1.RefAttributes<HTMLLabelElement>, "ref"> & VariantProps<(props?: ClassProp | undefined) => string> & React$1.RefAttributes<HTMLLabelElement>>;
/**
 * The Popover component displays rich content in a portal, triggered by a button. This popover is
 * built on Radix UI's Popover component and styled by Shadcn UI.
 *
 * See Shadcn UI Documentation https://ui.shadcn.com/docs/components/popover See Radix UI
 * Documentation https://www.radix-ui.com/docs/primitives/components/popover
 */
export declare const Popover: React$1.FC<PopoverPrimitive.PopoverProps>;
/** @inheritdoc Popover */
export declare const PopoverTrigger: React$1.ForwardRefExoticComponent<PopoverPrimitive.PopoverTriggerProps & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc Popover */
export declare const PopoverAnchor: React$1.ForwardRefExoticComponent<PopoverPrimitive.PopoverAnchorProps & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Popover */
export declare const PopoverContent: React$1.ForwardRefExoticComponent<Omit<PopoverPrimitive.PopoverContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * Displays an indicator showing the completion progress of a task, typically displayed as a
 * progress bar. This component is built on Radix UI primitives and styled with Shadcn UI. See
 * Shadcn UI documentation: https://ui.shadcn.com/docs/components/progress See Radix UI
 * documentation: https://www.radix-ui.com/primitives/docs/components/progress#api-reference
 */
export declare const Progress: React$1.ForwardRefExoticComponent<Omit<ProgressPrimitive.ProgressProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * Radio Group components providing a set of checkable buttons—known as radio buttons—where no more
 * than one of the buttons can be checked at a time. These components are built on Radix UI
 * primitives and styled with Shadcn UI.
 *
 * See Shadcn UI Documentation: https://ui.shadcn.com/docs/components/radio-group See Radix UI
 * Documentation: https://www.radix-ui.com/primitives/docs/components/radio-group
 */
export declare const RadioGroup: React$1.ForwardRefExoticComponent<Omit<RadioGroupPrimitive.RadioGroupProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc RadioGroup */
export declare const RadioGroupItem: React$1.ForwardRefExoticComponent<Omit<RadioGroupPrimitive.RadioGroupItemProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/**
 * Props for Select component
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/select}
 */
export interface SelectTriggerProps extends React$1.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>, VariantProps<typeof selectTriggerVariants> {
	asChild?: boolean;
}
/**
 * Select components display a list of options for the user to pick from—triggered by a button.
 * These components are built on Radix UI primitives and styled with Shadcn UI.
 *
 * See Shadcn UI Documentation: https://ui.shadcn.com/docs/components/select See Radix UI
 * Documentation: https://www.radix-ui.com/primitives/docs/components/select
 */
export declare const Select: React$1.FC<SelectPrimitive.SelectProps>;
/** @inheritdoc Select */
export declare const SelectGroup: React$1.ForwardRefExoticComponent<SelectPrimitive.SelectGroupProps & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Select */
export declare const SelectValue: React$1.ForwardRefExoticComponent<SelectPrimitive.SelectValueProps & React$1.RefAttributes<HTMLSpanElement>>;
/**
 * Style variants for the Select Trigger component.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/button}
 */
export declare const selectTriggerVariants: (props?: ({
	size?: "default" | "icon" | "sm" | "lg" | null | undefined;
} & ClassProp) | undefined) => string;
/** @inheritdoc Select */
export declare const SelectTrigger: React$1.ForwardRefExoticComponent<SelectTriggerProps & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc Select */
export declare const SelectScrollUpButton: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectScrollUpButtonProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Select */
export declare const SelectScrollDownButton: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectScrollDownButtonProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Select */
export declare const SelectContent: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Select */
export declare const SelectLabel: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectLabelProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Select */
export declare const SelectItem: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectItemProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Select */
export declare const SelectSeparator: React$1.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectSeparatorProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/**
 * Accessible resizable panel groups and layouts with keyboard support. This component is built on
 * react-resizable-panels and styled with Shadcn UI. See Shadcn UI documentation:
 * https://ui.shadcn.com/docs/components/resizable See react-resizable-panels documentation:
 * https://github.com/bvaughn/react-resizable-panels/tree/main/packages/react-resizable-panels
 */
export declare function ResizablePanelGroup({ className, ...props }: React$1.ComponentProps<typeof ResizablePrimitive.PanelGroup>): import("react/jsx-runtime").JSX.Element;
/** @inheritdoc ResizablePanelGroup */
export declare const ResizablePanel: React$1.ForwardRefExoticComponent<Omit<React$1.HTMLAttributes<HTMLElement | HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | HTMLAnchorElement | HTMLScriptElement | HTMLEmbedElement | HTMLFormElement | HTMLHeadElement | HTMLAreaElement | HTMLObjectElement | HTMLLinkElement | HTMLMapElement | HTMLInputElement | HTMLBaseElement | HTMLTimeElement | HTMLDataElement | HTMLProgressElement | HTMLTrackElement | HTMLSourceElement | HTMLButtonElement | HTMLAudioElement | HTMLQuoteElement | HTMLBodyElement | HTMLBRElement | HTMLTableCaptionElement | HTMLTableColElement | HTMLDataListElement | HTMLModElement | HTMLDetailsElement | HTMLDialogElement | HTMLDivElement | HTMLDListElement | HTMLFieldSetElement | HTMLHeadingElement | HTMLHRElement | HTMLHtmlElement | HTMLIFrameElement | HTMLLabelElement | HTMLLegendElement | HTMLLIElement | HTMLMenuElement | HTMLMetaElement | HTMLMeterElement | HTMLOListElement | HTMLOptGroupElement | HTMLOptionElement | HTMLOutputElement | HTMLParagraphElement | HTMLPictureElement | HTMLPreElement | HTMLSelectElement | HTMLSlotElement | HTMLSpanElement | HTMLStyleElement | HTMLTableElement | HTMLTableSectionElement | HTMLTableCellElement | HTMLTemplateElement | HTMLTextAreaElement | HTMLTitleElement | HTMLTableRowElement | HTMLUListElement>, "id" | "onResize"> & {
	className?: string;
	collapsedSize?: number | undefined;
	collapsible?: boolean | undefined;
	defaultSize?: number | undefined;
	id?: string;
	maxSize?: number | undefined;
	minSize?: number | undefined;
	onCollapse?: ResizablePrimitive.PanelOnCollapse;
	onExpand?: ResizablePrimitive.PanelOnExpand;
	onResize?: ResizablePrimitive.PanelOnResize;
	order?: number;
	style?: object;
	tagName?: keyof HTMLElementTagNameMap | undefined;
} & {
	children?: import("react").ReactNode | undefined;
} & React$1.RefAttributes<ResizablePrimitive.ImperativePanelHandle>>;
/** @inheritdoc ResizablePanelGroup */
export declare function ResizableHandle({ withHandle, className, ...props }: React$1.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
	withHandle?: boolean;
}): import("react/jsx-runtime").JSX.Element;
/**
 * The Separator component visually or semantically separates content. This component is built on
 * Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/separator}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/separator}
 */
export declare const Separator: React$1.ForwardRefExoticComponent<Omit<SeparatorPrimitive.SeparatorProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Tooltip */
export declare const TooltipProvider: React$1.FC<TooltipPrimitive.TooltipProviderProps>;
/**
 * Tooltip components provide a popover that displays information related to an element when hovered
 * or focused. These components are built on Radix UI primitives and styled with Shadcn UI. See
 * Shadcn UI Documentation: https://ui.shadcn.com/docs/components/tooltip See Radix UI
 * Documentation: https://www.radix-ui.com/primitives/docs/components/tooltip
 */
export declare const Tooltip: React$1.FC<TooltipPrimitive.TooltipProps>;
/** @inheritdoc Tooltip */
export declare const TooltipTrigger: React$1.ForwardRefExoticComponent<TooltipPrimitive.TooltipTriggerProps & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc Tooltip */
export declare const TooltipContent: React$1.ForwardRefExoticComponent<Omit<TooltipPrimitive.TooltipContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
type Side = "primary" | "secondary";
type SidebarContextProps = {
	state: "expanded" | "collapsed";
	open: boolean;
	setOpen: (open: boolean) => void;
	toggleSidebar: () => void;
	side: Side;
};
/** @inheritdoc SidebarProvider */
export declare function useSidebar(): SidebarContextProps;
/**
 * Sidebar components providing an accessible sidebar along with all the sub components that can be
 * used to populate and style it. These components are adapted from Shadcn UI. See Shadcn UI
 * Documentation: https://ui.shadcn.com/docs/components/sidebar
 */
export declare const SidebarProvider: React$1.ForwardRefExoticComponent<Omit<React$1.ClassAttributes<HTMLDivElement> & React$1.HTMLAttributes<HTMLDivElement> & {
	/** Whether the sidebar is initially open. */
	defaultOpen?: boolean;
	/** Whether the sidebar is open. */
	open?: boolean;
	/** Callback fired when the open state changes. */
	onOpenChange?: (open: boolean) => void;
	/** The side of the sidebar. */
	side?: Side;
}, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc SidebarProvider */
export declare const Sidebar: React$1.ForwardRefExoticComponent<Omit<React$1.ClassAttributes<HTMLDivElement> & React$1.HTMLAttributes<HTMLDivElement> & {
	variant?: "sidebar" | "floating" | "inset";
	collapsible?: "offcanvas" | "icon" | "none";
}, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarTrigger: React$1.ForwardRefExoticComponent<Omit<ButtonProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarRail: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarInset: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLElement>, HTMLElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarInput: React$1.ForwardRefExoticComponent<Omit<InputProps & React$1.RefAttributes<HTMLInputElement>, "ref"> & React$1.RefAttributes<HTMLInputElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarHeader: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarFooter: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarSeparator: React$1.ForwardRefExoticComponent<Omit<Omit<import("@radix-ui/react-separator").SeparatorProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarContent: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarGroup: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarGroupLabel: React$1.ForwardRefExoticComponent<Omit<React$1.ClassAttributes<HTMLDivElement> & React$1.HTMLAttributes<HTMLDivElement> & {
	asChild?: boolean;
}, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarGroupAction: React$1.ForwardRefExoticComponent<Omit<React$1.ClassAttributes<HTMLButtonElement> & React$1.ButtonHTMLAttributes<HTMLButtonElement> & {
	asChild?: boolean;
}, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarGroupContent: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarMenu: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLUListElement>, HTMLUListElement>, "ref"> & React$1.RefAttributes<HTMLUListElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarMenuItem: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.LiHTMLAttributes<HTMLLIElement>, HTMLLIElement>, "ref"> & React$1.RefAttributes<HTMLLIElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarMenuButton: React$1.ForwardRefExoticComponent<Omit<React$1.ClassAttributes<HTMLButtonElement> & React$1.ButtonHTMLAttributes<HTMLButtonElement> & {
	asChild?: boolean;
	isActive?: boolean;
	tooltip?: string | React$1.ComponentProps<typeof TooltipContent>;
} & VariantProps<(props?: ({
	variant?: "default" | "outline" | null | undefined;
	size?: "default" | "sm" | "lg" | null | undefined;
} & ClassProp) | undefined) => string>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarMenuAction: React$1.ForwardRefExoticComponent<Omit<React$1.ClassAttributes<HTMLButtonElement> & React$1.ButtonHTMLAttributes<HTMLButtonElement> & {
	asChild?: boolean;
	showOnHover?: boolean;
}, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarMenuBadge: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarMenuSkeleton: React$1.ForwardRefExoticComponent<Omit<React$1.ClassAttributes<HTMLDivElement> & React$1.HTMLAttributes<HTMLDivElement> & {
	showIcon?: boolean;
}, "ref"> & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarMenuSub: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLUListElement>, HTMLUListElement>, "ref"> & React$1.RefAttributes<HTMLUListElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarMenuSubItem: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.LiHTMLAttributes<HTMLLIElement>, HTMLLIElement>, "ref"> & React$1.RefAttributes<HTMLLIElement>>;
/** @inheritdoc SidebarProvider */
export declare const SidebarMenuSubButton: React$1.ForwardRefExoticComponent<Omit<React$1.ClassAttributes<HTMLAnchorElement> & React$1.AnchorHTMLAttributes<HTMLAnchorElement> & {
	asChild?: boolean;
	size?: "sm" | "md";
	isActive?: boolean;
}, "ref"> & React$1.RefAttributes<HTMLAnchorElement>>;
type SonnerProps = React$1.ComponentProps<typeof Toaster>;
/**
 * The Sonner component is an opinionated toast component for React. It is built on Sonner and
 * styled with Shadcn UI.
 *
 * @param SonnerProps
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/sonner}
 * @see Sonner Documentation: {@link https://sonner.emilkowal.ski}
 */
export declare function Sonner({ ...props }: SonnerProps): import("react/jsx-runtime").JSX.Element;
/**
 * Use to show a placeholder while content is loading. This component is from Shadcn UI. See Shadcn
 * UI documentation: https://ui.shadcn.com/docs/components/skeleton
 */
export declare function Skeleton({ className, ...props }: React$1.HTMLAttributes<HTMLDivElement>): import("react/jsx-runtime").JSX.Element;
/**
 * The Slider component is an input where the user selects a value from within a given range. This
 * component is built on Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/slider}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/slider}
 */
export declare const Slider: React$1.ForwardRefExoticComponent<Omit<SliderPrimitive.SliderProps & React$1.RefAttributes<HTMLSpanElement>, "ref"> & React$1.RefAttributes<HTMLSpanElement>>;
/**
 * The Switch component is a control that allows the user to toggle between checked and not checked.
 * This component is built on Radix UI primitives and styled with Shadcn UI.
 *
 * @see Shadcn UI Documentation: {@link https://ui.shadcn.com/docs/components/switch}
 * @see Radix UI Documentation: {@link https://www.radix-ui.com/primitives/docs/components/switch}
 */
export declare const Switch: React$1.ForwardRefExoticComponent<Omit<SwitchPrimitives.SwitchProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/**
 * Table components provide a responsive table. These components are built and styled with Shadcn
 * UI. See Shadcn UI Documentation: https://ui.shadcn.com/docs/components/table
 */
export declare const Table: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableElement> & {
	stickyHeader?: boolean;
} & React$1.RefAttributes<HTMLTableElement>>;
/** @inheritdoc Table */
export declare const TableHeader: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableSectionElement> & {
	stickyHeader?: boolean;
} & React$1.RefAttributes<HTMLTableSectionElement>>;
/** @inheritdoc Table */
export declare const TableBody: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableSectionElement> & React$1.RefAttributes<HTMLTableSectionElement>>;
/** @inheritdoc Table */
export declare const TableFooter: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableSectionElement> & React$1.RefAttributes<HTMLTableSectionElement>>;
/** @inheritdoc Table */
export declare const TableRow: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableRowElement> & {
	setFocusAlsoRunsSelect?: boolean;
} & React$1.RefAttributes<HTMLTableRowElement>>;
/** @inheritdoc Table */
export declare const TableHead: React$1.ForwardRefExoticComponent<React$1.ThHTMLAttributes<HTMLTableCellElement> & React$1.RefAttributes<HTMLTableCellElement>>;
/** @inheritdoc Table */
export declare const TableCell: React$1.ForwardRefExoticComponent<React$1.TdHTMLAttributes<HTMLTableCellElement> & React$1.RefAttributes<HTMLTableCellElement>>;
/** @inheritdoc Table */
export declare const TableCaption: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLTableCaptionElement> & React$1.RefAttributes<HTMLTableCaptionElement>>;
/**
 * Tabs components provide a set of layered sections of content—known as tab panels–that are
 * displayed one at a time. These components are built on Radix UI primitives and styled with Shadcn
 * UI. See Shadcn UI Documentation: https://ui.shadcn.com/docs/components/tabs See Radix UI
 * Documentation: https://www.radix-ui.com/primitives/docs/components/tabs
 */
export declare const Tabs: React$1.ForwardRefExoticComponent<TabsPrimitive.TabsProps & React$1.RefAttributes<HTMLDivElement>>;
type TabsTriggerProps = React$1.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger> & {
	className?: string;
};
/** @inheritdoc Tabs */
export declare const TabsList: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsListProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc Tabs */
export declare const TabsTrigger: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsTriggerProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & {
	className?: string;
} & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc Tabs */
export declare const TabsContent: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
} & React$1.RefAttributes<HTMLDivElement>>;
type LeftTabsTriggerProps = TabsTriggerProps & {
	value: string;
	ref?: React$1.Ref<HTMLButtonElement>;
};
/**
 * Tabs components provide a set of layered sections of content—known as tab panels–that are
 * displayed one at a time. These components are built on Radix UI primitives and styled with Shadcn
 * UI. See Shadcn UI Documentation: https://ui.shadcn.com/docs/components/tabs See Radix UI
 * Documentation: https://www.radix-ui.com/primitives/docs/components/tabs
 */
export declare const VerticalTabs: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc VerticalTabs */
export declare const VerticalTabsList: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsListProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
} & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc VerticalTabs */
export declare const VerticalTabsTrigger: React$1.ForwardRefExoticComponent<Omit<LeftTabsTriggerProps, "ref"> & React$1.RefAttributes<HTMLButtonElement>>;
/** @inheritdoc VerticalTabs */
export declare const VerticalTabsContent: React$1.ForwardRefExoticComponent<Omit<TabsPrimitive.TabsContentProps & React$1.RefAttributes<HTMLDivElement>, "ref"> & {
	className?: string;
} & React$1.RefAttributes<HTMLDivElement>>;
/**
 * Displays a form textarea or a component that looks like a textarea. This component is from Shadcn
 * UI. See Shadcn UI documentation: https://ui.shadcn.com/docs/components/textarea
 */
export declare const Textarea: React$1.ForwardRefExoticComponent<Omit<React$1.DetailedHTMLProps<React$1.TextareaHTMLAttributes<HTMLTextAreaElement>, HTMLTextAreaElement>, "ref"> & React$1.RefAttributes<HTMLTextAreaElement>>;
/**
 * ToggleGroup components provide a set of two-state buttons that can be toggled on or off. These
 * components are built on Radix UI primitives and styled with Shadcn UI. See Shadcn UI
 * Documentation: https://ui.shadcn.com/docs/components/toggle-group See Radix UI Documentation:
 * https://www.radix-ui.com/primitives/docs/components/toggle-group
 */
export declare const ToggleGroup: React$1.ForwardRefExoticComponent<((Omit<ToggleGroupPrimitive.ToggleGroupSingleProps & React$1.RefAttributes<HTMLDivElement>, "ref"> | Omit<ToggleGroupPrimitive.ToggleGroupMultipleProps & React$1.RefAttributes<HTMLDivElement>, "ref">) & VariantProps<(props?: ({
	variant?: "default" | "outline" | null | undefined;
	size?: "default" | "sm" | "lg" | null | undefined;
} & ClassProp) | undefined) => string>) & React$1.RefAttributes<HTMLDivElement>>;
/** @inheritdoc ToggleGroup */
export declare const ToggleGroupItem: React$1.ForwardRefExoticComponent<Omit<ToggleGroupPrimitive.ToggleGroupItemProps & React$1.RefAttributes<HTMLButtonElement>, "ref"> & VariantProps<(props?: ({
	variant?: "default" | "outline" | null | undefined;
	size?: "default" | "sm" | "lg" | null | undefined;
} & ClassProp) | undefined) => string> & React$1.RefAttributes<HTMLButtonElement>>;
/**
 * Adds an event handler to an event so the event handler runs when the event is emitted. Use
 * `papi.network.getNetworkEvent` to use a networked event with this hook.
 *
 * @param event The event to subscribe to.
 *
 *   - If event is a `PlatformEvent`, that event will be used
 *   - If event is undefined, the callback will not be subscribed. Useful if the event is not yet
 *       available for example
 *
 * @param eventHandler The callback to run when the event is emitted
 *
 *   WARNING: MUST BE STABLE - const or wrapped in useCallback. The reference must not be updated
 *   every render
 */
export declare const useEvent: <T>(event: PlatformEvent<T> | undefined, eventHandler: PlatformEventHandler<T>) => void;
/**
 * Adds an event handler to an asynchronously subscribing/unsubscribing event so the event handler
 * runs when the event is emitted. Use `papi.network.getNetworkEvent` to use a networked event with
 * this hook.
 *
 * @param event The asynchronously (un)subscribing event to subscribe to.
 *
 *   - If event is a `PlatformEvent` or `PlatformEventAsync`, that event will be used
 *   - If event is undefined, the callback will not be subscribed. Useful if the event is not yet
 *       available for example
 *
 * @param eventHandler The callback to run when the event is emitted
 *
 *   WARNING: MUST BE STABLE - const or wrapped in useCallback. The reference must not be updated
 *   every render
 */
export declare const useEventAsync: <T>(event: PlatformEvent<T> | PlatformEventAsync<T> | undefined, eventHandler: PlatformEventHandler<T>) => void;
export type UsePromiseOptions = {
	/**
	 * Whether to leave the value as the most recent resolved promise value or set it back to
	 * defaultValue while running the promise again. Defaults to true
	 */
	preserveValue?: boolean;
};
/**
 * Awaits a promise and returns a loading value while the promise is unresolved
 *
 * @param promiseFactoryCallback A function that returns the promise to await. If this callback is
 *   undefined, the current value will be returned (defaultValue unless it was previously changed
 *   and `options.preserveValue` is true), and there will be no loading.
 *
 *   WARNING: MUST BE STABLE - const or wrapped in useCallback. The reference must not be updated
 *   every render
 * @param defaultValue The initial value to return while first awaiting the promise. If
 *   `options.preserveValue` is false, this value is also shown while awaiting the promise on
 *   subsequent calls.
 *
 *   Note: this parameter is internally assigned to a `ref`, so changing it will not cause any hooks
 *   to re-run with its new value. This means that, if the `promiseFactoryCallback` changes and
 *   `options.preserveValue` is `false`, the returned value will be set to the current
 *   `defaultValue`. However, the returned value will not be updated if`defaultValue` changes.
 * @param options Various options for adjusting how this hook runs the `promiseFactoryCallback`
 *
 *   Note: this parameter is internally assigned to a `ref`, so changing it will not cause any hooks
 *   to re-run with its new value. However, the latest `options.preserveValue` will always be used
 *   appropriately to determine whether to preserve the returned value when changing the
 *   `promiseFactoryCallback`
 * @returns `[value, isLoading]`
 *
 *   - `value`: the current value for the promise, either the defaultValue or the resolved promise value
 *   - `isLoading`: whether the promise is waiting to be resolved
 */
export declare const usePromise: <T>(promiseFactoryCallback: (() => Promise<T>) | undefined, defaultValue: T, options?: UsePromiseOptions) => [
	value: T,
	isLoading: boolean
];
/**
 * Adds a CSS stylesheet to the current document in a
 * [`style`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/style) element
 *
 * @param stylesheet The CSS stylesheet to apply to the current document. If `undefined`, this hook
 *   does nothing.
 */
export declare function useStylesheet(stylesheet: string | undefined): void;
/** Properties of one option contained in a listbox */
export interface ListboxOption {
	/** Unique identifier for the option */
	id: string;
}
/** Props for the useListbox hook */
export interface UseListboxProps {
	/** Array of options for the listbox */
	options: ListboxOption[];
	/** Callback when the focus changes to a different option */
	onFocusChange?: (option: ListboxOption) => void;
	/** Callback to toggle the selection of an option */
	onOptionSelect?: (option: ListboxOption) => void;
	/** Callback when a character key is pressed */
	onCharacterPress?: (char: string) => void;
}
/**
 * Hook for handling keyboard navigation of a listbox.
 *
 * @param UseListboxProps - The properties for configuring the listbox behavior.
 * @returns An object containing:
 *
 *   - `listboxRef`: A ref to be attached to the listbox container element (e.g., `<ul>`), used for
 *       focus management.
 *   - `activeId`: The id of the currently focused (active) option, or `undefined` if none is focused.
 *   - `selectedId`: The id of the currently selected option, or `undefined` if none is selected.
 *   - `handleKeyDown`: A keyboard event handler to be attached to the listbox container for handling
 *       navigation and selection.
 *   - `focusOption`: A function to programmatically focus a specific option by id.
 */
export declare const useListbox: ({ options, onFocusChange, onOptionSelect, onCharacterPress, }: UseListboxProps) => {
	listboxRef: React$1.RefObject<HTMLElement>;
	activeId: string | undefined;
	selectedId: string | undefined;
	/** Keyboard event handler for listbox navigation and selection */
	handleKeyDown: (event: React$1.KeyboardEvent<HTMLElement>) => void;
	/** Focus an option by its ID */
	focusOption: (id: string) => void;
};
/**
 * Tailwind and CSS class application helper function. Uses
 * [`clsx`](https://www.npmjs.com/package/clsx) to make it easy to apply classes conditionally using
 * object syntax, and uses [`tailwind-merge`](https://www.npmjs.com/package/tailwind-merge) to make
 * it easy to merge/overwrite Tailwind classes in a programmer-logic-friendly way.
 *
 * Note: `tailwind-merge` is configured to use the prefix `tw-`, so you must use the same prefix
 * with any Tailwind classes you use with this function to successfully overwrite other Tailwind
 * classes. `platform-bible-react` is configured to use `tw-` as its Tailwind prefix, so any
 * Tailwind classes you pass into `platform-bible-react` components will be compared using the `tw-`
 * prefix.
 *
 * This function was popularized by
 * [shadcn/ui](https://ui.shadcn.com/docs/installation/manual#add-a-cn-helper). See [ByteGrad's
 * explanation video](https://www.youtube.com/watch?v=re2JFITR7TI) for more information.
 *
 * @example
 *
 * ```typescript
 * const borderShouldBeBlue = true;
 * const textShouldBeRed = true;
 * const heightShouldBe20 = false;
 * const classString = cn(
 *   'tw-bg-primary tw-h-10 tw-text-primary-foreground',
 *   'tw-bg-secondary',
 *   {
 *     'tw-border-blue-500': borderShouldBeBlue,
 *     'tw-text-red-500': textShouldBeRed,
 *     'tw-h-20': heightShouldBe20,
 *   },
 *   'some-class',
 * );
 * ```
 *
 * The resulting `classString` is `'tw-h-10 tw-bg-secondary tw-border-blue-500 tw-text-red-500
 * some-class'`
 *
 * - Notice that `'tw-bg-secondary'`, specified later, overwrote `'tw-bg-primary'`, specified earlier,
 *   because they are Tailwind classes that affect the same css property
 * - Notice that `'tw-text-red-500'`, specified later, overwrote `'tw-text-primary-foreground'`,
 *   specified earlier, because they are Tailwind classes that affect the same css property
 * - Notice that `'tw-h-20'`, specified later, did not overwrite `'tw-h-10'`, specified earlier,
 *   because `'tw-h-20'` is part of a conditional class object and its value evaluated to `false`;
 *   therefore it was not applied
 * - Notice that `'some-class'` was applied. This function is not limited only to Tailwind classes.
 *
 *
 * @param inputs Class strings or `clsx` conditional class objects to merge. Tailwind classes
 *   specified later in the arguments overwrite similar Tailwind classes specified earlier in the
 *   arguments
 * @returns Class string containing all applicable classes from the arguments based on the rules
 *   described above
 */
export declare function cn(...inputs: ClassValue[]): string;

export {
	TabNavigationContentSearch as NavigationContentSearch,
	sonner,
};

export {};
