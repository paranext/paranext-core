var B0 = Object.defineProperty;
var q0 = (t, e, n) => e in t ? B0(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var nn = (t, e, n) => q0(t, typeof e != "symbol" ? e + "" : e, n);
import { jsx as d, jsxs as M, Fragment as ft } from "react/jsx-runtime";
import * as si from "react";
import X, { forwardRef as an, useRef as he, useMemo as ue, useState as oe, useCallback as ce, useLayoutEffect as xt, createContext as Zr, useContext as jo, useEffect as ie, Component as j0, createElement as Ep, Suspense as Yu, memo as U0, useImperativeHandle as Qu, Children as V0, cloneElement as H0, isValidElement as z0, createRef as G0, Fragment as uw } from "react";
import { Command as wn } from "cmdk";
import { X as wl, Search as dw, Check as br, Clock as kp, ChevronsLeft as Np, ChevronsRight as Tp, ChevronLeft as Xc, ChevronRight as pi, ArrowLeft as K0, ArrowRight as W0, Circle as gl, ChevronsUpDown as Zu, BoldIcon as J0, ItalicIcon as X0, UnderlineIcon as Y0, StrikethroughIcon as Q0, ChevronUp as Yc, ChevronDown as fi, AtSign as Z0, ArrowUp as ev, FilterIcon as tv, ArrowLeftIcon as nv, ChevronLeftIcon as rv, ChevronRightIcon as ov, ArrowRightIcon as iv, Copy as pw, Filter as sv, User as av, Link as lv, CircleHelp as cv, Star as uv, AlertCircle as Qc, CircleCheckIcon as dv, CircleXIcon as pv, CircleHelpIcon as fv, ArrowUpIcon as hv, ArrowDownIcon as wv, ArrowUpDownIcon as gv, PanelLeft as mv, PanelRight as bv, ScrollText as vv, MenuIcon as yv, Menu as xv, EllipsisVertical as _v, MoreHorizontal as Cv, LoaderCircle as Ev, GripVertical as kv } from "lucide-react";
import { clsx as Nv } from "clsx";
import { extendTailwindMerge as Tv } from "tailwind-merge";
import * as Kn from "@radix-ui/react-dialog";
import { includes as ga, Section as $e, getChaptersForBook as Av, formatScrRef as ai, getSectionForBook as ds, formatRelativeDate as Sv, formatReplacementString as ps, NumberFormat as Dv, formatBytes as Mv, getCurrentLocale as Ov, getFormatCallerFunction as Rv, deepEqual as ed, isString as wc, compareScrRefs as Zc, scrRefToBBBCCCVVV as gc, getLocalizeKeyForScrollGroupId as Ke } from "platform-bible-utils";
import { Slot as Si } from "@radix-ui/react-slot";
import { cva as eo } from "class-variance-authority";
import * as hi from "@radix-ui/react-popover";
import * as fw from "@radix-ui/react-label";
import * as ms from "@radix-ui/react-radio-group";
import * as hw from "@radix-ui/react-separator";
import { createEditor as qs, $getRoot as tt, $createParagraphNode as js, $getSelection as ve, HISTORY_MERGE_TAG as Uo, ParagraphNode as Us, TextNode as Hn, $findMatchingParent as Iv, $isElementNode as Ae, shallowMergeConfig as Lv, defineExtension as Or, safeCast as Vs, RootNode as Pv, LineBreakNode as td, TabNode as $v, $isEditorState as Fv, createCommand as Di, CLICK_COMMAND as Bv, isDOMNode as ww, $getNodeFromDOMNode as qv, $isNodeSelection as eu, $createNodeSelection as jv, $setSelection as ml, COMMAND_PRIORITY_LOW as to, $isRangeSelection as me, DecoratorNode as Vo, $create as Uv, $getNodeByKey as it, CLEAR_EDITOR_COMMAND as bl, COMMAND_PRIORITY_EDITOR as Qe, INDENT_CONTENT_COMMAND as Ap, COMMAND_PRIORITY_CRITICAL as Gr, KEY_TAB_COMMAND as gw, $createRangeSelection as vl, $normalizeSelection__EXPERIMENTAL as Vv, OUTDENT_CONTENT_COMMAND as Hv, INSERT_TAB_COMMAND as zv, $isBlockElementNode as Gv, $isDecoratorNode as nd, $isParagraphNode as rd, $isTextNode as xe, SELECTION_CHANGE_COMMAND as no, FORMAT_TEXT_COMMAND as Kv, $isTokenOrSegmented as mw, $getCharacterOffsets as bw, $cloneWithPropertiesEphemeral as Wv, getRegisteredNode as vw, isHTMLElement as vr, isDocumentFragment as Ga, INTERNAL_$isBlock as ma, $caretFromPoint as Jv, $isExtendableTextPointCaret as Xv, $extendCaretToRange as Yv, $isChildCaret as yw, $isRootNode as od, $getEditor as Qv, $getChildCaret as Zv, $getSiblingCaret as tu, makeStepwiseIterator as ey, $getAdjacentChildCaret as Sp, $rewindSiblingCaret as ty, $cloneWithProperties as ny, ElementNode as ro, isHTMLAnchorElement as xw, $applyNodeReplacement as Mt, CAN_REDO_COMMAND as os, CAN_UNDO_COMMAND as is, CLEAR_HISTORY_COMMAND as _w, REDO_COMMAND as id, HISTORIC_TAG as nu, UNDO_COMMAND as sd, HISTORY_PUSH_TAG as ry, KEY_ENTER_COMMAND as Cw, KEY_ESCAPE_COMMAND as Ew, KEY_ARROW_UP_COMMAND as oy, KEY_ARROW_DOWN_COMMAND as iy, DRAGSTART_COMMAND as sy, DROP_COMMAND as kw, PASTE_COMMAND as yl, PASTE_TAG as ay, CUT_COMMAND as xl, COPY_COMMAND as _l, SELECT_ALL_COMMAND as ly, $selectAll as cy, INSERT_LINE_BREAK_COMMAND as Dp, KEY_DELETE_COMMAND as uy, DELETE_CHARACTER_COMMAND as mc, KEY_BACKSPACE_COMMAND as dy, KEY_ARROW_RIGHT_COMMAND as py, KEY_ARROW_LEFT_COMMAND as fy, INSERT_PARAGRAPH_COMMAND as hy, REMOVE_TEXT_COMMAND as wy, CONTROLLED_TEXT_INSERTION_COMMAND as gy, DELETE_LINE_COMMAND as my, DELETE_WORD_COMMAND as by, createState as Nw, $addUpdateTag as vy, $createPoint as Mp, $createTextNode as pt, COMMAND_PRIORITY_NORMAL as Pa, KEY_DOWN_COMMAND as Hs, $isRootOrShadowRoot as yy, $parseSerializedNode as xy, COMMAND_PRIORITY_HIGH as Cl, $getCommonAncestor as _y, $hasUpdateTag as Cy, $getState as bs, $setState as Nr } from "lexical";
import * as zs from "@radix-ui/react-tooltip";
import { HeadingNode as Ey, QuoteNode as ky, registerRichText as Tw } from "@lexical/rich-text";
import * as Ny from "react-dom";
import { flushSync as ad, createPortal as ur } from "react-dom";
import { $isTableSelection as Aw } from "@lexical/table";
import * as El from "@radix-ui/react-toggle-group";
import * as Sw from "@radix-ui/react-toggle";
import Ty from "markdown-to-jsx";
import * as Mi from "@radix-ui/react-avatar";
import { useReactTable as Dw, getFilteredRowModel as Ay, getSortedRowModel as Mw, getPaginationRowModel as Sy, getCoreRowModel as Ow, flexRender as fs, getGroupedRowModel as Dy, getExpandedRowModel as My } from "@tanstack/react-table";
import * as st from "@radix-ui/react-dropdown-menu";
import { DropdownMenuTrigger as Oy } from "@radix-ui/react-dropdown-menu";
import * as vt from "@radix-ui/react-select";
import * as ru from "@radix-ui/react-checkbox";
import * as gn from "@radix-ui/react-tabs";
import * as at from "@radix-ui/react-menubar";
import { useHotkeys as Ry } from "react-hotkeys-hook";
import * as lt from "@radix-ui/react-context-menu";
import { Drawer as Yn } from "vaul";
import * as ou from "@radix-ui/react-progress";
import * as ld from "react-resizable-panels";
import { Toaster as Iy } from "sonner";
import { toast as $O } from "sonner";
import * as ss from "@radix-ui/react-slider";
import * as iu from "@radix-ui/react-switch";
const Ly = Tv({ prefix: "tw-" });
function z(...t) {
  return Ly(Nv(t));
}
const Py = "layoutDirection";
function Bt() {
  const t = localStorage.getItem(Py);
  return t === "rtl" ? t : "ltr";
}
const $y = Kn.Root, Fy = Kn.Portal, Rw = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  Kn.Overlay,
  {
    ref: n,
    className: z(
      "tw-fixed tw-inset-0 tw-z-50 tw-bg-black/80 data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0",
      t
    ),
    ...e
  }
));
Rw.displayName = Kn.Overlay.displayName;
const Iw = X.forwardRef(({ className: t, children: e, ...n }, r) => {
  const o = Bt();
  return /* @__PURE__ */ M(Fy, { children: [
    /* @__PURE__ */ d(Rw, {}),
    /* @__PURE__ */ M(
      Kn.Content,
      {
        ref: r,
        className: z(
          "pr-twp tw-fixed tw-left-[50%] tw-top-[50%] tw-z-50 tw-grid tw-w-full tw-max-w-lg tw-translate-x-[-50%] tw-translate-y-[-50%] tw-gap-4 tw-border tw-bg-background tw-p-6 tw-shadow-lg tw-duration-200 data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[state=closed]:tw-slide-out-to-left-1/2 data-[state=closed]:tw-slide-out-to-top-[48%] data-[state=open]:tw-slide-in-from-left-1/2 data-[state=open]:tw-slide-in-from-top-[48%] sm:tw-rounded-lg",
          t
        ),
        ...n,
        dir: o,
        children: [
          e,
          /* @__PURE__ */ M(
            Kn.Close,
            {
              className: z(
                "tw-absolute tw-top-4 tw-rounded-sm tw-opacity-70 tw-ring-offset-background tw-transition-opacity hover:tw-opacity-100 focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-ring focus:tw-ring-offset-2 disabled:tw-pointer-events-none data-[state=open]:tw-bg-accent data-[state=open]:tw-text-muted-foreground",
                { "tw-right-4": o === "ltr" },
                { "tw-left-4": o === "rtl" }
              ),
              children: [
                /* @__PURE__ */ d(wl, { className: "tw-h-4 tw-w-4" }),
                /* @__PURE__ */ d("span", { className: "tw-sr-only", children: "Close" })
              ]
            }
          )
        ]
      }
    )
  ] });
});
Iw.displayName = Kn.Content.displayName;
function Lw({ className: t, ...e }) {
  return /* @__PURE__ */ d(
    "div",
    {
      className: z(
        "tw-flex tw-flex-col tw-space-y-1.5 tw-text-center sm:tw-text-start",
        t
      ),
      ...e
    }
  );
}
Lw.displayName = "DialogHeader";
const Pw = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  Kn.Title,
  {
    ref: n,
    className: z("tw-text-lg tw-font-semibold tw-leading-none tw-tracking-tight", t),
    ...e
  }
));
Pw.displayName = Kn.Title.displayName;
const By = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  Kn.Description,
  {
    ref: n,
    className: z("tw-text-sm tw-text-muted-foreground", t),
    ...e
  }
));
By.displayName = Kn.Description.displayName;
const Oi = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  wn,
  {
    ref: n,
    className: z(
      "tw-flex tw-h-full tw-w-full tw-flex-col tw-overflow-hidden tw-rounded-md tw-bg-popover tw-text-popover-foreground",
      t
    ),
    ...e
  }
));
Oi.displayName = wn.displayName;
const Gs = X.forwardRef(({ className: t, ...e }, n) => {
  const r = Bt();
  return /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center tw-border-b tw-px-3", dir: r, children: [
    /* @__PURE__ */ d(dw, { className: "tw-me-2 tw-h-4 tw-w-4 tw-shrink-0 tw-opacity-50" }),
    /* @__PURE__ */ d(
      wn.Input,
      {
        ref: n,
        className: z(
          "tw-flex tw-h-11 tw-w-full tw-rounded-md tw-bg-transparent tw-py-3 tw-text-sm tw-outline-none placeholder:tw-text-muted-foreground disabled:tw-cursor-not-allowed disabled:tw-opacity-50",
          t
        ),
        ...e
      }
    )
  ] });
});
Gs.displayName = wn.Input.displayName;
const Ri = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  wn.List,
  {
    ref: n,
    className: z("tw-max-h-[300px] tw-overflow-y-auto tw-overflow-x-hidden", t),
    ...e
  }
));
Ri.displayName = wn.List.displayName;
const kl = X.forwardRef((t, e) => /* @__PURE__ */ d(wn.Empty, { ref: e, className: "tw-py-6 tw-text-center tw-text-sm", ...t }));
kl.displayName = wn.Empty.displayName;
const No = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  wn.Group,
  {
    ref: n,
    className: z(
      "tw-overflow-hidden tw-p-1 tw-text-foreground [&_[cmdk-group-heading]]:tw-px-2 [&_[cmdk-group-heading]]:tw-py-1.5 [&_[cmdk-group-heading]]:tw-text-xs [&_[cmdk-group-heading]]:tw-font-medium [&_[cmdk-group-heading]]:tw-text-muted-foreground",
      t
    ),
    ...e
  }
));
No.displayName = wn.Group.displayName;
const $w = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  wn.Separator,
  {
    ref: n,
    className: z("tw--mx-1 tw-h-px tw-bg-border", t),
    ...e
  }
));
$w.displayName = wn.Separator.displayName;
const Ho = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  wn.Item,
  {
    ref: n,
    className: z(
      "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none data-[disabled=true]:tw-pointer-events-none data-[selected=true]:tw-bg-accent data-[selected=true]:tw-text-accent-foreground data-[disabled=true]:tw-opacity-50",
      t
    ),
    ...e
  }
));
Ho.displayName = wn.Item.displayName;
var qy = Object.defineProperty, jy = (t, e, n) => e in t ? qy(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Ie = (t, e, n) => jy(t, typeof e != "symbol" ? e + "" : e, n);
const To = [
  "GEN",
  "EXO",
  "LEV",
  "NUM",
  "DEU",
  "JOS",
  "JDG",
  "RUT",
  "1SA",
  "2SA",
  // 10
  "1KI",
  "2KI",
  "1CH",
  "2CH",
  "EZR",
  "NEH",
  "EST",
  "JOB",
  "PSA",
  "PRO",
  // 20
  "ECC",
  "SNG",
  "ISA",
  "JER",
  "LAM",
  "EZK",
  "DAN",
  "HOS",
  "JOL",
  "AMO",
  // 30
  "OBA",
  "JON",
  "MIC",
  "NAM",
  "HAB",
  "ZEP",
  "HAG",
  "ZEC",
  "MAL",
  "MAT",
  // 40
  "MRK",
  "LUK",
  "JHN",
  "ACT",
  "ROM",
  "1CO",
  "2CO",
  "GAL",
  "EPH",
  "PHP",
  // 50
  "COL",
  "1TH",
  "2TH",
  "1TI",
  "2TI",
  "TIT",
  "PHM",
  "HEB",
  "JAS",
  "1PE",
  // 60
  "2PE",
  "1JN",
  "2JN",
  "3JN",
  "JUD",
  "REV",
  "TOB",
  "JDT",
  "ESG",
  "WIS",
  // 70
  "SIR",
  "BAR",
  "LJE",
  "S3Y",
  "SUS",
  "BEL",
  "1MA",
  "2MA",
  "3MA",
  "4MA",
  // 80
  "1ES",
  "2ES",
  "MAN",
  "PS2",
  "ODA",
  "PSS",
  "JSA",
  // actual variant text for JOS, now in LXA text
  "JDB",
  // actual variant text for JDG, now in LXA text
  "TBS",
  // actual variant text for TOB, now in LXA text
  "SST",
  // actual variant text for SUS, now in LXA text // 90
  "DNT",
  // actual variant text for DAN, now in LXA text
  "BLT",
  // actual variant text for BEL, now in LXA text
  "XXA",
  "XXB",
  "XXC",
  "XXD",
  "XXE",
  "XXF",
  "XXG",
  "FRT",
  // 100
  "BAK",
  "OTH",
  "3ES",
  // Used previously but really should be 2ES
  "EZA",
  // Used to be called 4ES, but not actually in any known project
  "5EZ",
  // Used to be called 5ES, but not actually in any known project
  "6EZ",
  // Used to be called 6ES, but not actually in any known project
  "INT",
  "CNC",
  "GLO",
  "TDX",
  // 110
  "NDX",
  "DAG",
  "PS3",
  "2BA",
  "LBA",
  "JUB",
  "ENO",
  "1MQ",
  "2MQ",
  "3MQ",
  // 120
  "REP",
  "4BA",
  "LAO"
], cd = [
  "XXA",
  "XXB",
  "XXC",
  "XXD",
  "XXE",
  "XXF",
  "XXG",
  "FRT",
  "BAK",
  "OTH",
  "INT",
  "CNC",
  "GLO",
  "TDX",
  "NDX"
], Fw = [
  "Genesis",
  "Exodus",
  "Leviticus",
  "Numbers",
  "Deuteronomy",
  "Joshua",
  "Judges",
  "Ruth",
  "1 Samuel",
  "2 Samuel",
  "1 Kings",
  "2 Kings",
  "1 Chronicles",
  "2 Chronicles",
  "Ezra",
  "Nehemiah",
  "Esther (Hebrew)",
  "Job",
  "Psalms",
  "Proverbs",
  "Ecclesiastes",
  "Song of Songs",
  "Isaiah",
  "Jeremiah",
  "Lamentations",
  "Ezekiel",
  "Daniel (Hebrew)",
  "Hosea",
  "Joel",
  "Amos",
  "Obadiah",
  "Jonah",
  "Micah",
  "Nahum",
  "Habakkuk",
  "Zephaniah",
  "Haggai",
  "Zechariah",
  "Malachi",
  "Matthew",
  "Mark",
  "Luke",
  "John",
  "Acts",
  "Romans",
  "1 Corinthians",
  "2 Corinthians",
  "Galatians",
  "Ephesians",
  "Philippians",
  "Colossians",
  "1 Thessalonians",
  "2 Thessalonians",
  "1 Timothy",
  "2 Timothy",
  "Titus",
  "Philemon",
  "Hebrews",
  "James",
  "1 Peter",
  "2 Peter",
  "1 John",
  "2 John",
  "3 John",
  "Jude",
  "Revelation",
  "Tobit",
  "Judith",
  "Esther Greek",
  "Wisdom of Solomon",
  "Sirach (Ecclesiasticus)",
  "Baruch",
  "Letter of Jeremiah",
  "Song of 3 Young Men",
  "Susanna",
  "Bel and the Dragon",
  "1 Maccabees",
  "2 Maccabees",
  "3 Maccabees",
  "4 Maccabees",
  "1 Esdras (Greek)",
  "2 Esdras (Latin)",
  "Prayer of Manasseh",
  "Psalm 151",
  "Odes",
  "Psalms of Solomon",
  // WARNING, if you change the spelling of the *obsolete* tag be sure to update
  // IsObsolete routine
  "Joshua A. *obsolete*",
  "Judges B. *obsolete*",
  "Tobit S. *obsolete*",
  "Susanna Th. *obsolete*",
  "Daniel Th. *obsolete*",
  "Bel Th. *obsolete*",
  "Extra A",
  "Extra B",
  "Extra C",
  "Extra D",
  "Extra E",
  "Extra F",
  "Extra G",
  "Front Matter",
  "Back Matter",
  "Other Matter",
  "3 Ezra *obsolete*",
  "Apocalypse of Ezra",
  "5 Ezra (Latin Prologue)",
  "6 Ezra (Latin Epilogue)",
  "Introduction",
  "Concordance ",
  "Glossary ",
  "Topical Index",
  "Names Index",
  "Daniel Greek",
  "Psalms 152-155",
  "2 Baruch (Apocalypse)",
  "Letter of Baruch",
  "Jubilees",
  "Enoch",
  "1 Meqabyan",
  "2 Meqabyan",
  "3 Meqabyan",
  "Reproof (Proverbs 25-31)",
  "4 Baruch (Rest of Baruch)",
  "Laodiceans"
], Op = Yy();
function Ii(t, e = !0) {
  return e && (t = t.toUpperCase()), t in Op ? Op[t] : 0;
}
function ud(t) {
  return Ii(t) > 0;
}
function Uy(t) {
  const e = typeof t == "string" ? Ii(t) : t;
  return e >= 40 && e <= 66;
}
function Vy(t) {
  return (typeof t == "string" ? Ii(t) : t) <= 39;
}
function Bw(t) {
  return t <= 66;
}
function Hy(t) {
  const e = typeof t == "string" ? Ii(t) : t;
  return Uw(e) && !Bw(e);
}
function* zy() {
  for (let t = 1; t <= To.length; t++) yield t;
}
const Gy = 1, qw = To.length;
function Ky() {
  return ["XXA", "XXB", "XXC", "XXD", "XXE", "XXF", "XXG"];
}
function dd(t, e = "***") {
  const n = t - 1;
  return n < 0 || n >= To.length ? e : To[n];
}
function jw(t) {
  return t <= 0 || t > qw ? "******" : Fw[t - 1];
}
function Wy(t) {
  return jw(Ii(t));
}
function Uw(t) {
  const e = typeof t == "number" ? dd(t) : t;
  return ud(e) && !cd.includes(e);
}
function Jy(t) {
  const e = typeof t == "number" ? dd(t) : t;
  return ud(e) && cd.includes(e);
}
function Xy(t) {
  return Fw[t - 1].includes("*obsolete*");
}
function Yy() {
  const t = {};
  for (let e = 0; e < To.length; e++)
    t[To[e]] = e + 1;
  return t;
}
const We = {
  allBookIds: To,
  nonCanonicalIds: cd,
  bookIdToNumber: Ii,
  isBookIdValid: ud,
  isBookNT: Uy,
  isBookOT: Vy,
  isBookOTNT: Bw,
  isBookDC: Hy,
  allBookNumbers: zy,
  firstBook: Gy,
  lastBook: qw,
  extraBooks: Ky,
  bookNumberToId: dd,
  bookNumberToEnglishName: jw,
  bookIdToEnglishName: Wy,
  isCanonical: Uw,
  isExtraMaterial: Jy,
  isObsolete: Xy
};
var ar = /* @__PURE__ */ ((t) => (t[t.Unknown = 0] = "Unknown", t[t.Original = 1] = "Original", t[t.Septuagint = 2] = "Septuagint", t[t.Vulgate = 3] = "Vulgate", t[t.English = 4] = "English", t[t.RussianProtestant = 5] = "RussianProtestant", t[t.RussianOrthodox = 6] = "RussianOrthodox", t))(ar || {});
const Nn = class {
  // private versInfo: Versification;
  constructor(e) {
    if (Ie(this, "name"), Ie(this, "fullPath"), Ie(this, "isPresent"), Ie(this, "hasVerseSegments"), Ie(this, "isCustomized"), Ie(this, "baseVersification"), Ie(this, "scriptureBooks"), Ie(this, "_type"), e == null)
      throw new Error("Argument undefined");
    typeof e == "string" ? (this.name = e, this._type = ar[e]) : (this._type = e, this.name = ar[e]);
  }
  get type() {
    return this._type;
  }
  equals(e) {
    return !e.type || !this.type ? !1 : e.type === this.type;
  }
};
Ie(Nn, "Original", new Nn(ar.Original)), Ie(Nn, "Septuagint", new Nn(ar.Septuagint)), Ie(Nn, "Vulgate", new Nn(ar.Vulgate)), Ie(Nn, "English", new Nn(ar.English)), Ie(Nn, "RussianProtestant", new Nn(ar.RussianProtestant)), Ie(Nn, "RussianOrthodox", new Nn(ar.RussianOrthodox));
let bo = Nn;
function Rp(t, e) {
  const n = e[0];
  for (let r = 1; r < e.length; r++)
    t = t.split(e[r]).join(n);
  return t.split(n);
}
var Vw = /* @__PURE__ */ ((t) => (t[t.Valid = 0] = "Valid", t[t.UnknownVersification = 1] = "UnknownVersification", t[t.OutOfRange = 2] = "OutOfRange", t[t.VerseOutOfOrder = 3] = "VerseOutOfOrder", t[t.VerseRepeated = 4] = "VerseRepeated", t))(Vw || {});
const pn = class qe {
  constructor(e, n, r, o) {
    if (Ie(this, "firstChapter"), Ie(this, "lastChapter"), Ie(this, "lastVerse"), Ie(this, "hasSegmentsDefined"), Ie(this, "text"), Ie(this, "BBBCCCVVVS"), Ie(this, "longHashCode"), Ie(this, "versification"), Ie(this, "rtlMark", "â€"), Ie(this, "_bookNum", 0), Ie(this, "_chapterNum", 0), Ie(this, "_verseNum", 0), Ie(this, "_verse"), r == null && o == null)
      if (e != null && typeof e == "string") {
        const i = e, s = n != null && n instanceof bo ? n : void 0;
        this.setEmpty(s), this.parse(i);
      } else if (e != null && typeof e == "number") {
        const i = n != null && n instanceof bo ? n : void 0;
        this.setEmpty(i), this._verseNum = e % qe.chapterDigitShifter, this._chapterNum = Math.floor(
          e % qe.bookDigitShifter / qe.chapterDigitShifter
        ), this._bookNum = Math.floor(e / qe.bookDigitShifter);
      } else if (n == null)
        if (e != null && e instanceof qe) {
          const i = e;
          this._bookNum = i.bookNum, this._chapterNum = i.chapterNum, this._verseNum = i.verseNum, this._verse = i.verse, this.versification = i.versification;
        } else {
          if (e == null) return;
          const i = e instanceof bo ? e : qe.defaultVersification;
          this.setEmpty(i);
        }
      else
        throw new Error("VerseRef constructor not supported.");
    else if (e != null && n != null && r != null)
      if (typeof e == "string" && typeof n == "string" && typeof r == "string")
        this.setEmpty(o), this.updateInternal(e, n, r);
      else if (typeof e == "number" && typeof n == "number" && typeof r == "number")
        this._bookNum = e, this._chapterNum = n, this._verseNum = r, this.versification = o ?? qe.defaultVersification;
      else
        throw new Error("VerseRef constructor not supported.");
    else
      throw new Error("VerseRef constructor not supported.");
  }
  /**
   * Determines if the verse string is in a valid format (does not consider versification).
   */
  static isVerseParseable(e) {
    return e.length > 0 && "0123456789".includes(e[0]) && !e.endsWith(this.verseRangeSeparator) && !e.endsWith(this.verseSequenceIndicator);
  }
  /**
   * Tries to parse the specified string into a verse reference.
   * @param str - The string to attempt to parse.
   * @returns success: `true` if the specified string was successfully parsed, `false` otherwise.
   * @returns verseRef: The result of the parse if successful, or empty VerseRef if it failed
   */
  static tryParse(e) {
    let n;
    try {
      return n = new qe(e), { success: !0, verseRef: n };
    } catch (r) {
      if (r instanceof Yi)
        return n = new qe(), { success: !1, verseRef: n };
      throw r;
    }
  }
  /**
   * Gets the reference as a comparable integer where the book, chapter, and verse each occupy 3
   * digits.
   * @param bookNum - Book number (this is 1-based, not an index).
   * @param chapterNum - Chapter number.
   * @param verseNum - Verse number.
   * @returns The reference as a comparable integer where the book, chapter, and verse each occupy 3
   * digits.
   */
  static getBBBCCCVVV(e, n, r) {
    return e % qe.bcvMaxValue * qe.bookDigitShifter + (n >= 0 ? n % qe.bcvMaxValue * qe.chapterDigitShifter : 0) + (r >= 0 ? r % qe.bcvMaxValue : 0);
  }
  /**
   * Deserializes a serialized VerseRef.
   * @param serializedVerseRef - Serialized VerseRef to create from.
   * @returns the deserialized VerseRef.
   */
  static fromJSON(e) {
    const { book: n, chapterNum: r, verseNum: o, verse: i, versificationStr: s } = e, a = i || o.toString();
    let l;
    return s && (l = new bo(s)), n ? new qe(n, r.toString(), a, l) : new qe();
  }
  /**
   * Parses a verse string and gets the leading numeric portion as a number.
   * @param verseStr - verse string to parse
   * @returns true if the entire string could be parsed as a single, simple verse number (1-999);
   *    false if the verse string represented a verse bridge, contained segment letters, or was invalid
   */
  static tryGetVerseNum(e) {
    let n;
    if (!e)
      return n = -1, { success: !0, vNum: n };
    n = 0;
    let r;
    for (let o = 0; o < e.length; o++) {
      if (r = e[o], r < "0" || r > "9")
        return o === 0 && (n = -1), { success: !1, vNum: n };
      if (n = n * 10 + +r - 0, n > qe.bcvMaxValue)
        return n = -1, { success: !1, vNum: n };
    }
    return { success: !0, vNum: n };
  }
  /**
   * Checks to see if a VerseRef hasn't been set - all values are the default.
   */
  get isDefault() {
    return this.bookNum === 0 && this.chapterNum === 0 && this.verseNum === 0 && this.versification == null;
  }
  /**
   * Gets whether the verse contains multiple verses.
   */
  get hasMultiple() {
    return this._verse != null && (this._verse.includes(qe.verseRangeSeparator) || this._verse.includes(qe.verseSequenceIndicator));
  }
  /**
   * Gets or sets the book of the reference. Book is the 3-letter abbreviation in capital letters,
   * e.g. `'MAT'`.
   */
  get book() {
    return We.bookNumberToId(this.bookNum, "");
  }
  set book(e) {
    this.bookNum = We.bookIdToNumber(e);
  }
  /**
   * Gets or sets the chapter of the reference,. e.g. `'3'`.
   */
  get chapter() {
    return this.isDefault || this._chapterNum < 0 ? "" : this._chapterNum.toString();
  }
  set chapter(e) {
    const n = +e;
    this._chapterNum = Number.isInteger(n) ? n : -1;
  }
  /**
   * Gets or sets the verse of the reference, including range, segments, and sequences, e.g. `'4'`,
   * or `'4b-5a, 7'`.
   */
  get verse() {
    return this._verse != null ? this._verse : this.isDefault || this._verseNum < 0 ? "" : this._verseNum.toString();
  }
  set verse(e) {
    const { success: n, vNum: r } = qe.tryGetVerseNum(e);
    this._verse = n ? void 0 : e.replace(this.rtlMark, ""), this._verseNum = r, !(this._verseNum >= 0) && ({ vNum: this._verseNum } = qe.tryGetVerseNum(this._verse));
  }
  /**
   * Get or set Book based on book number, e.g. `42`.
   */
  get bookNum() {
    return this._bookNum;
  }
  set bookNum(e) {
    if (e <= 0 || e > We.lastBook)
      throw new Yi(
        "BookNum must be greater than zero and less than or equal to last book"
      );
    this._bookNum = e;
  }
  /**
   * Gets or sets the chapter number, e.g. `3`. `-1` if not valid.
   */
  get chapterNum() {
    return this._chapterNum;
  }
  set chapterNum(e) {
    this.chapterNum = e;
  }
  /**
   * Gets or sets verse start number, e.g. `4`. `-1` if not valid.
   */
  get verseNum() {
    return this._verseNum;
  }
  set verseNum(e) {
    this._verseNum = e;
  }
  /**
   * String representing the versification (should ONLY be used for serialization/deserialization).
   *
   * @remarks This is for backwards compatibility when ScrVers was an enumeration.
   */
  get versificationStr() {
    var e;
    return (e = this.versification) == null ? void 0 : e.name;
  }
  set versificationStr(e) {
    this.versification = this.versification != null ? new bo(e) : void 0;
  }
  /**
   * Determines if the reference is valid.
   */
  get valid() {
    return this.validStatus === 0;
  }
  /**
   * Get the valid status for this reference.
   */
  get validStatus() {
    return this.validateVerse(qe.verseRangeSeparators, qe.verseSequenceIndicators);
  }
  /**
   * Gets the reference as a comparable integer where the book,
   * chapter, and verse each occupy three digits and the verse is 0.
   */
  get BBBCCC() {
    return qe.getBBBCCCVVV(this._bookNum, this._chapterNum, 0);
  }
  /**
   * Gets the reference as a comparable integer where the book,
   * chapter, and verse each occupy three digits. If verse is not null
   * (i.e., this reference represents a complex reference with verse
   * segments or bridge) this cannot be used for an exact comparison.
   */
  get BBBCCCVVV() {
    return qe.getBBBCCCVVV(this._bookNum, this._chapterNum, this._verseNum);
  }
  /**
   * Gets whether the verse is defined as an excluded verse in the versification.
   * Does not handle verse ranges.
   */
  // eslint-disable-next-line @typescript-eslint/class-literal-property-style
  get isExcluded() {
    return !1;
  }
  /**
   * Parses the reference in the specified string.
   * Optionally versification can follow reference as in GEN 3:11/4
   * Throw an exception if
   * - invalid book name
   * - chapter number is missing or not a number
   * - verse number is missing or does not start with a number
   * - versification is invalid
   * @param verseStr - string to parse e.g. 'MAT 3:11'
   */
  parse(e) {
    if (e = e.replace(this.rtlMark, ""), e.includes("/")) {
      const i = e.split("/");
      if (e = i[0], i.length > 1)
        try {
          const s = +i[1].trim();
          this.versification = new bo(ar[s]);
        } catch {
          throw new Yi("Invalid reference : " + e);
        }
    }
    const n = e.trim().split(" ");
    if (n.length !== 2)
      throw new Yi("Invalid reference : " + e);
    const r = n[1].split(":"), o = +r[0];
    if (r.length !== 2 || We.bookIdToNumber(n[0]) === 0 || !Number.isInteger(o) || o < 0 || !qe.isVerseParseable(r[1]))
      throw new Yi("Invalid reference : " + e);
    this.updateInternal(n[0], r[0], r[1]);
  }
  /**
   * Simplifies this verse ref so that it has no bridging of verses or
   * verse segments like `'1a'`.
   */
  simplify() {
    this._verse = void 0;
  }
  /**
   * Makes a clone of the reference.
   *
   * @returns The cloned VerseRef.
   */
  clone() {
    return new qe(this);
  }
  toString() {
    const e = this.book;
    return e === "" ? "" : `${e} ${this.chapter}:${this.verse}`;
  }
  toJSON() {
    let e = this.verse;
    (e === "" || e === this.verseNum.toString()) && (e = void 0);
    const n = {
      book: this.book,
      chapterNum: this.chapterNum,
      verseNum: this.verseNum,
      verse: e,
      versificationStr: this.versificationStr
    };
    return e || delete n.verse, n;
  }
  /**
   * Compares this `VerseRef` with supplied one.
   * @param verseRef - object to compare this one to.
   * @returns `true` if this `VerseRef` is equal to the supplied one, `false` otherwise.
   */
  equals(e) {
    return e instanceof qe ? e._bookNum === this._bookNum && e._chapterNum === this._chapterNum && e._verseNum === this._verseNum && e.verse === this.verse && (e.versification == null && this.versification == null || e.versification != null && this.versification != null && e.versification.equals(this.versification)) : !1;
  }
  /**
   * Enumerate all individual verses contained in a VerseRef.
   * Verse ranges are indicated by "-" and consecutive verses by ","s.
   * Examples:
   * GEN 1:2 returns GEN 1:2
   * GEN 1:1a-3b,5 returns GEN 1:1a, GEN 1:2, GEN 1:3b, GEN 1:5
   * GEN 1:2a-2c returns //! ??????
   *
   * @param specifiedVersesOnly - if set to <c>true</c> return only verses that are
   * explicitly specified only, not verses within a range. Defaults to `false`.
   * @param verseRangeSeparators - Verse range separators.
   * Defaults to `VerseRef.verseRangeSeparators`.
   * @param verseSequenceSeparators - Verse sequence separators.
   * Defaults to `VerseRef.verseSequenceIndicators`.
   * @returns An array of all single verse references in this VerseRef.
   */
  allVerses(e = !1, n = qe.verseRangeSeparators, r = qe.verseSequenceIndicators) {
    if (this._verse == null || this.chapterNum <= 0)
      return [this.clone()];
    const o = [], i = Rp(this._verse, r);
    for (const s of i.map((a) => Rp(a, n))) {
      const a = this.clone();
      a.verse = s[0];
      const l = a.verseNum;
      if (o.push(a), s.length > 1) {
        const c = this.clone();
        if (c.verse = s[1], !e)
          for (let u = l + 1; u < c.verseNum; u++) {
            const p = new qe(
              this._bookNum,
              this._chapterNum,
              u,
              this.versification
            );
            this.isExcluded || o.push(p);
          }
        o.push(c);
      }
    }
    return o;
  }
  /**
   * Validates a verse number using the supplied separators rather than the defaults.
   */
  validateVerse(e, n) {
    if (!this.verse)
      return this.internalValid;
    let r = 0;
    for (const o of this.allVerses(!0, e, n)) {
      const i = o.internalValid;
      if (i !== 0)
        return i;
      const s = o.BBBCCCVVV;
      if (r > s)
        return 3;
      if (r === s)
        return 4;
      r = s;
    }
    return 0;
  }
  /**
   * Gets whether a single verse reference is valid.
   */
  get internalValid() {
    return this.versification == null ? 1 : this._bookNum <= 0 || this._bookNum > We.lastBook ? 2 : (We.isCanonical(this._bookNum), 0);
  }
  setEmpty(e = qe.defaultVersification) {
    this._bookNum = 0, this._chapterNum = -1, this._verse = void 0, this.versification = e;
  }
  updateInternal(e, n, r) {
    this.bookNum = We.bookIdToNumber(e), this.chapter = n, this.verse = r;
  }
};
Ie(pn, "defaultVersification", bo.English), Ie(pn, "verseRangeSeparator", "-"), Ie(pn, "verseSequenceIndicator", ","), Ie(pn, "verseRangeSeparators", [pn.verseRangeSeparator]), Ie(pn, "verseSequenceIndicators", [pn.verseSequenceIndicator]), Ie(pn, "chapterDigitShifter", 1e3), Ie(pn, "bookDigitShifter", pn.chapterDigitShifter * pn.chapterDigitShifter), Ie(pn, "bcvMaxValue", pn.chapterDigitShifter - 1), /**
* The valid status of the VerseRef.
*/
Ie(pn, "ValidStatusType", Vw);
let Yi = class extends Error {
};
const Hw = (t, e, n, r, o) => {
  switch (t) {
    case $e.OT:
      return e ?? "Old Testament";
    case $e.NT:
      return n ?? "New Testament";
    case $e.DC:
      return r ?? "Deuterocanon";
    case $e.Extra:
      return o ?? "Extra Materials";
    default:
      throw new Error(`Unknown section: ${t}`);
  }
}, Qy = (t, e, n, r, o) => {
  switch (t) {
    case $e.OT:
      return e ?? "OT";
    case $e.NT:
      return n ?? "NT";
    case $e.DC:
      return r ?? "DC";
    case $e.Extra:
      return o ?? "Extra";
    default:
      throw new Error(`Unknown section: ${t}`);
  }
};
function li(t, e) {
  var r;
  return ((r = e == null ? void 0 : e.get(t)) == null ? void 0 : r.localizedName) ?? We.bookIdToEnglishName(t);
}
function pd(t, e) {
  var r;
  return ((r = e == null ? void 0 : e.get(t)) == null ? void 0 : r.localizedId) ?? t.toUpperCase();
}
const zw = We.allBookIds.filter(
  (t) => !We.isObsolete(We.bookIdToNumber(t))
), _o = Object.fromEntries(
  zw.map((t) => [t, We.bookIdToEnglishName(t)])
);
function fd(t, e, n) {
  const r = e.trim().toLowerCase();
  if (!r) return !1;
  const o = We.bookIdToEnglishName(t), i = n == null ? void 0 : n.get(t);
  return !!(ga(o.toLowerCase(), r) || ga(t.toLowerCase(), r) || (i ? ga(i.localizedName.toLowerCase(), r) || ga(i.localizedId.toLowerCase(), r) : !1));
}
const Gw = an(
  ({
    bookId: t,
    isSelected: e,
    onSelect: n,
    onMouseDown: r,
    section: o,
    className: i,
    showCheck: s = !1,
    localizedBookNames: a,
    commandValue: l
  }, c) => {
    const u = he(!1), p = () => {
      u.current || n == null || n(t), setTimeout(() => {
        u.current = !1;
      }, 100);
    }, f = (b) => {
      u.current = !0, r ? r(b) : n == null || n(t);
    }, h = ue(
      () => li(t, a),
      [t, a]
    ), g = ue(
      () => pd(t, a),
      [t, a]
    );
    return /* @__PURE__ */ d(
      "div",
      {
        className: z(
          "tw-mx-1 tw-my-1 tw-border-b-0 tw-border-e-0 tw-border-s-2 tw-border-t-0 tw-border-solid",
          {
            "tw-border-s-red-200": o === $e.OT,
            "tw-border-s-purple-200": o === $e.NT,
            "tw-border-s-indigo-200": o === $e.DC,
            "tw-border-s-amber-200": o === $e.Extra
          }
        ),
        children: /* @__PURE__ */ M(
          Ho,
          {
            ref: c,
            value: l || `${t} ${We.bookIdToEnglishName(t)}`,
            onSelect: p,
            onMouseDown: f,
            role: "option",
            "aria-selected": e,
            "aria-label": `${We.bookIdToEnglishName(t)} (${t.toLocaleUpperCase()})`,
            className: i,
            children: [
              s && /* @__PURE__ */ d(
                br,
                {
                  className: z(
                    "tw-me-2 tw-h-4 tw-w-4 tw-flex-shrink-0",
                    e ? "tw-opacity-100" : "tw-opacity-0"
                  )
                }
              ),
              /* @__PURE__ */ d("span", { className: "tw-min-w-0 tw-flex-1", children: h }),
              /* @__PURE__ */ d("span", { className: "tw-ms-2 tw-flex-shrink-0 tw-text-xs tw-text-muted-foreground", children: g })
            ]
          }
        )
      }
    );
  }
), Zy = eo(
  "pr-twp tw-inline-flex tw-items-center tw-justify-center tw-gap-2 tw-whitespace-nowrap tw-rounded-md tw-text-sm tw-font-medium tw-ring-offset-background tw-transition-colors focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-pointer-events-none disabled:tw-opacity-50 [&_svg]:tw-pointer-events-none [&_svg]:tw-size-4 [&_svg]:tw-shrink-0",
  {
    variants: {
      variant: {
        default: "tw-bg-primary tw-text-primary-foreground hover:tw-bg-primary/90",
        destructive: "tw-bg-destructive tw-text-destructive-foreground hover:tw-bg-destructive/90",
        outline: "tw-border tw-border-input tw-bg-background hover:tw-bg-accent hover:tw-text-accent-foreground",
        secondary: "tw-bg-secondary tw-text-secondary-foreground hover:tw-bg-secondary/80",
        ghost: "hover:tw-bg-accent hover:tw-text-accent-foreground",
        link: "tw-text-primary tw-underline-offset-4 hover:tw-underline"
      },
      size: {
        default: "tw-h-10 tw-px-4 tw-py-2",
        sm: "tw-h-9 tw-rounded-md tw-px-3",
        lg: "tw-h-11 tw-rounded-md tw-px-8",
        icon: "tw-h-10 tw-w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Ne = X.forwardRef(
  ({ className: t, variant: e, size: n, asChild: r = !1, ...o }, i) => /* @__PURE__ */ d(r ? Si : "button", { className: z(Zy({ variant: e, size: n, className: t })), ref: i, ...o })
);
Ne.displayName = "Button";
const Li = hi.Root, Pi = hi.Trigger, M5 = hi.Anchor, zo = X.forwardRef(({ className: t, align: e = "center", sideOffset: n = 4, ...r }, o) => {
  const i = Bt();
  return /* @__PURE__ */ d(hi.Portal, { children: /* @__PURE__ */ d(
    hi.Content,
    {
      ref: o,
      align: e,
      sideOffset: n,
      className: z(
        // CUSTOM Changed z-order from 50 to 250 to make them appear on floating tabs (200)
        "tw-z-[250]",
        "pr-twp tw-w-72 tw-rounded-md tw-border tw-bg-popover tw-p-4 tw-text-popover-foreground tw-shadow-md tw-outline-none data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
        t
      ),
      ...r,
      dir: i
    }
  ) });
});
zo.displayName = hi.Content.displayName;
function su(t, e, n) {
  return `${t} ${_o[t]}${e ? ` ${pd(t, e)} ${li(t, e)}` : ""}${n ? ` ${n}` : ""}`;
}
function e2({
  recentSearches: t,
  onSearchItemSelect: e,
  renderItem: n = (a) => String(a),
  getItemKey: r = (a) => String(a),
  ariaLabel: o = "Show recent searches",
  groupHeading: i = "Recent",
  id: s
}) {
  const [a, l] = oe(!1);
  if (t.length === 0)
    return;
  const c = (u) => {
    e(u), l(!1);
  };
  return /* @__PURE__ */ M(Li, { open: a, onOpenChange: l, children: [
    /* @__PURE__ */ d(Pi, { asChild: !0, children: /* @__PURE__ */ d(
      Ne,
      {
        variant: "ghost",
        size: "icon",
        className: "tw-absolute tw-right-0 tw-top-0 tw-h-full tw-px-3 tw-py-2",
        "aria-label": o,
        children: /* @__PURE__ */ d(kp, { className: "tw-h-4 tw-w-4" })
      }
    ) }),
    /* @__PURE__ */ d(zo, { id: s, className: "tw-w-[300px] tw-p-0", align: "start", children: /* @__PURE__ */ d(Oi, { children: /* @__PURE__ */ d(Ri, { children: /* @__PURE__ */ d(No, { heading: i, children: t.map((u) => /* @__PURE__ */ M(
      Ho,
      {
        onSelect: () => c(u),
        className: "tw-flex tw-items-center",
        children: [
          /* @__PURE__ */ d(kp, { className: "tw-mr-2 tw-h-4 tw-w-4 tw-opacity-50" }),
          /* @__PURE__ */ d("span", { children: n(u) })
        ]
      },
      r(u)
    )) }) }) }) })
  ] });
}
function O5(t, e, n = (o, i) => o === i, r = 15) {
  return (o) => {
    const i = t.filter(
      (a) => !n(a, o)
    ), s = [o, ...i.slice(0, r - 1)];
    e(s);
  };
}
const bc = {
  // Matches start of string (`^`), one or more non-colon/space words, optionally followed by space and more words (`([^:\s]+(?:\s+[^:\s]+)*)`), end of string (`$`), case-insensitive (`i`)
  BOOK_ONLY: /^([^:\s]+(?:\s+[^:\s]+)*)$/i,
  // Same as above, but followed by a space and a chapter number (`\s+(\d+)`)
  BOOK_CHAPTER: /^([^:\s]+(?:\s+[^:\s]+)*)\s+(\d+)$/i,
  // Same as above, but followed by a colon and optionally a verse number (`:(\d*)`)
  BOOK_CHAPTER_VERSE: /^([^:\s]+(?:\s+[^:\s]+)*)\s+(\d+):(\d*)$/i
}, t2 = [
  bc.BOOK_ONLY,
  bc.BOOK_CHAPTER,
  bc.BOOK_CHAPTER_VERSE
];
function Ip(t) {
  const e = /^[a-zA-Z]$/.test(t), n = /^[0-9]$/.test(t);
  return { isLetter: e, isDigit: n };
}
function dr(t) {
  return Av(We.bookIdToNumber(t));
}
function n2(t, e, n) {
  if (!t.trim() || e.length === 0) return;
  const r = t2.reduce(
    (o, i) => {
      if (o) return o;
      const s = i.exec(t.trim());
      if (s) {
        const [a, l = void 0, c = void 0] = s.slice(1);
        let u;
        const p = e.filter((f) => fd(f, a, n));
        if (p.length === 1 && ([u] = p), !u && l) {
          if (We.isBookIdValid(a)) {
            const f = a.toUpperCase();
            e.includes(f) && (u = f);
          }
          if (!u && n) {
            const f = Array.from(n.entries()).find(
              ([, h]) => h.localizedId.toLowerCase() === a.toLowerCase()
            );
            f && e.includes(f[0]) && ([u] = f);
          }
        }
        if (!u && l) {
          const h = ((g) => Object.keys(_o).find(
            (b) => _o[b].toLowerCase() === g.toLowerCase()
          ))(a);
          if (h && e.includes(h) && (u = h), !u && n) {
            const g = Array.from(n.entries()).find(
              ([, b]) => b.localizedName.toLowerCase() === a.toLowerCase()
            );
            g && e.includes(g[0]) && ([u] = g);
          }
        }
        if (u) {
          let f = l ? parseInt(l, 10) : void 0;
          f && f > dr(u) && (f = Math.max(dr(u), 1));
          const h = c ? parseInt(c, 10) : void 0;
          return {
            book: u,
            chapterNum: f,
            verseNum: h
          };
        }
      }
    },
    void 0
  );
  if (r) return r;
}
function r2(t, e, n, r) {
  const o = ce(() => {
    if (t.chapterNum > 1)
      r({
        book: t.book,
        chapterNum: t.chapterNum - 1,
        verseNum: 1
      });
    else {
      const l = e.indexOf(t.book);
      if (l > 0) {
        const c = e[l - 1], u = Math.max(dr(c), 1);
        r({
          book: c,
          chapterNum: u,
          verseNum: 1
        });
      }
    }
  }, [t, e, r]), i = ce(() => {
    const l = dr(t.book);
    if (t.chapterNum < l)
      r({
        book: t.book,
        chapterNum: t.chapterNum + 1,
        verseNum: 1
      });
    else {
      const c = e.indexOf(t.book);
      if (c < e.length - 1) {
        const u = e[c + 1];
        r({
          book: u,
          chapterNum: 1,
          verseNum: 1
        });
      }
    }
  }, [t, e, r]), s = ce(() => {
    r({
      book: t.book,
      chapterNum: t.chapterNum,
      verseNum: t.verseNum > 1 ? t.verseNum - 1 : 0
    });
  }, [t, r]), a = ce(() => {
    r({
      book: t.book,
      chapterNum: t.chapterNum,
      verseNum: t.verseNum + 1
    });
  }, [t, r]);
  return ue(() => [
    {
      onClick: o,
      disabled: e.length === 0 || t.chapterNum === 1 && e.indexOf(t.book) === 0,
      title: "Previous chapter",
      icon: n === "ltr" ? Np : Tp
    },
    {
      onClick: s,
      disabled: e.length === 0 || t.verseNum === 0,
      title: "Previous verse",
      icon: n === "ltr" ? Xc : pi
    },
    {
      onClick: a,
      disabled: e.length === 0,
      title: "Next verse",
      icon: n === "ltr" ? pi : Xc
    },
    {
      onClick: i,
      disabled: e.length === 0 || (t.chapterNum === dr(t.book) || dr(t.book) === -1) && e.indexOf(t.book) === e.length - 1,
      title: "Next chapter",
      icon: n === "ltr" ? Tp : Np
    }
  ], [
    t,
    e,
    n,
    o,
    s,
    a,
    i
  ]);
}
function Lp({
  bookId: t,
  scrRef: e,
  onChapterSelect: n,
  setChapterRef: r,
  isChapterDimmed: o,
  className: i
}) {
  if (t)
    return /* @__PURE__ */ d(No, { children: /* @__PURE__ */ d("div", { className: z("tw-grid tw-grid-cols-6 tw-gap-1", i), children: Array.from({ length: dr(t) }, (s, a) => a + 1).map((s) => /* @__PURE__ */ d(
      Ho,
      {
        value: `${t} ${_o[t] || ""} ${s}`,
        onSelect: () => n(s),
        ref: r(s),
        className: z(
          "tw-h-8 tw-w-8 tw-cursor-pointer tw-justify-center tw-rounded-md tw-text-center tw-text-sm",
          {
            "tw-bg-primary tw-text-primary-foreground": t === e.book && s === e.chapterNum
          },
          {
            "tw-bg-muted/50 tw-text-muted-foreground/50": (o == null ? void 0 : o(s)) ?? !1
          }
        ),
        children: s
      },
      s
    )) }) });
}
function R5({
  scrRef: t,
  handleSubmit: e,
  className: n,
  getActiveBookIds: r,
  localizedBookNames: o,
  localizedStrings: i,
  recentSearches: s,
  onAddRecentSearch: a,
  id: l
}) {
  const c = Bt(), [u, p] = oe(!1), [f, h] = oe(""), [g, b] = oe(""), [_, x] = oe("books"), [y, A] = oe(void 0), [P, V] = oe(!1), O = he(void 0), U = he(void 0), B = he(void 0), F = he(void 0), K = he({}), E = ce(
    (re) => {
      e(re), a && a(re);
    },
    [e, a]
  ), S = ue(() => r ? r() : zw, [r]), k = ue(() => ({
    [$e.OT]: S.filter((Ce) => We.isBookOT(Ce)),
    [$e.NT]: S.filter((Ce) => We.isBookNT(Ce)),
    [$e.DC]: S.filter((Ce) => We.isBookDC(Ce)),
    [$e.Extra]: S.filter((Ce) => We.extraBooks().includes(Ce))
  }), [S]), I = ue(() => Object.values(k).flat(), [k]), N = ue(() => {
    if (!g.trim()) return k;
    const re = {
      [$e.OT]: [],
      [$e.NT]: [],
      [$e.DC]: [],
      [$e.Extra]: []
    };
    return [$e.OT, $e.NT, $e.DC, $e.Extra].forEach((Re) => {
      re[Re] = k[Re].filter((je) => fd(je, g, o));
    }), re;
  }, [k, g, o]), T = ue(
    () => n2(g, I, o),
    [g, I, o]
  ), $ = ce(() => {
    T && (E({
      book: T.book,
      chapterNum: T.chapterNum ?? 1,
      verseNum: T.verseNum ?? 1
    }), p(!1), b(""), h(""));
  }, [E, T]), L = ce(
    (re) => {
      if (dr(re) <= 1) {
        E({
          book: re,
          chapterNum: 1,
          verseNum: 1
        }), p(!1), b("");
        return;
      }
      A(re), x("chapters");
    },
    [E]
  ), J = ce(
    (re) => {
      const Ce = _ === "chapters" ? y : T == null ? void 0 : T.book;
      Ce && (E({
        book: Ce,
        chapterNum: re,
        verseNum: 1
      }), p(!1), x("books"), A(void 0), b(""));
    },
    [E, _, y, T]
  ), G = ce(
    (re) => {
      E(re), p(!1), b("");
    },
    [E]
  ), W = r2(t, I, c, e), ee = ce(() => {
    x("books"), A(void 0), setTimeout(() => {
      U.current && U.current.focus();
    }, 0);
  }, []), te = ce(
    (re) => {
      if (!re && _ === "chapters") {
        ee();
        return;
      }
      p(re), re && (x("books"), A(void 0), b(""));
    },
    [_, ee]
  ), { otLong: Z, ntLong: Y, dcLong: le, extraLong: de } = {
    otLong: i == null ? void 0 : i["%scripture_section_ot_long%"],
    ntLong: i == null ? void 0 : i["%scripture_section_nt_long%"],
    dcLong: i == null ? void 0 : i["%scripture_section_dc_long%"],
    extraLong: i == null ? void 0 : i["%scripture_section_extra_long%"]
  }, pe = ce(
    (re) => Hw(re, Z, Y, le, de),
    [Z, Y, le, de]
  ), _e = ce(
    (re) => T ? !!T.chapterNum && !re.toString().includes(T.chapterNum.toString()) : !1,
    [T]
  ), be = ue(
    () => ai(
      t,
      o ? li(t.book, o) : "English"
    ),
    [t, o]
  ), ye = ce((re) => (Ce) => {
    K.current[re] = Ce;
  }, []), se = ce((re) => {
    (re.key === "Home" || re.key === "End") && re.stopPropagation();
  }, []), Se = ce(
    (re) => {
      if (re.ctrlKey) return;
      const { isLetter: Ce, isDigit: Re } = Ip(re.key);
      if (_ === "chapters") {
        if (re.key === "Backspace") {
          re.preventDefault(), re.stopPropagation(), ee();
          return;
        }
        if (Ce || Re) {
          if (re.preventDefault(), re.stopPropagation(), x("books"), A(void 0), Re && y) {
            const je = _o[y];
            b(`${je} ${re.key}`);
          } else
            b(re.key);
          setTimeout(() => {
            U.current && U.current.focus();
          }, 0);
          return;
        }
      }
      if ((_ === "chapters" || _ === "books" && T) && ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(re.key)) {
        const je = _ === "chapters" ? y : T == null ? void 0 : T.book;
        if (!je) return;
        const Je = (() => {
          if (!f) return 1;
          const Me = f.match(/(\d+)$/);
          return Me ? parseInt(Me[1], 10) : 0;
        })(), wt = dr(je);
        if (!wt) return;
        let ut = Je;
        const yt = 6;
        switch (re.key) {
          case "ArrowLeft":
            Je !== 0 && (ut = Je > 1 ? Je - 1 : wt);
            break;
          case "ArrowRight":
            Je !== 0 && (ut = Je < wt ? Je + 1 : 1);
            break;
          case "ArrowUp":
            ut = Je === 0 ? wt : Math.max(1, Je - yt);
            break;
          case "ArrowDown":
            ut = Je === 0 ? 1 : Math.min(wt, Je + yt);
            break;
          default:
            return;
        }
        ut !== Je && (re.preventDefault(), re.stopPropagation(), h(su(je, o, ut)), setTimeout(() => {
          const Me = K.current[ut];
          Me && Me.scrollIntoView({ block: "nearest", behavior: "smooth" });
        }, 0));
      }
    },
    [
      _,
      T,
      ee,
      y,
      f,
      o
    ]
  ), Fe = ce((re) => {
    if (re.shiftKey || re.key === "Tab" || re.key === " ") return;
    const { isLetter: Ce, isDigit: Re } = Ip(re.key);
    (Ce || Re) && (re.preventDefault(), b((je) => je + re.key), U.current.focus(), V(!1));
  }, []);
  return xt(() => {
    const re = setTimeout(() => {
      if (u && _ === "books" && B.current && F.current) {
        const Ce = B.current, Re = F.current, je = Re.offsetTop, Je = Ce.clientHeight, wt = Re.clientHeight, ut = je - Je / 2 + wt / 2;
        Ce.scrollTo({
          top: Math.max(0, ut),
          behavior: "smooth"
        }), h(su(t.book));
      }
    }, 0);
    return () => {
      clearTimeout(re);
    };
  }, [u, _, g, T, t.book]), xt(() => {
    if (_ === "chapters" && y) {
      const re = y === t.book;
      setTimeout(() => {
        if (B.current)
          if (re) {
            const Ce = K.current[t.chapterNum];
            Ce && Ce.scrollIntoView({ block: "center", behavior: "smooth" });
          } else
            B.current.scrollTo({ top: 0 });
        O.current && O.current.focus();
      }, 0);
    }
  }, [_, y, T, t.book, t.chapterNum]), /* @__PURE__ */ M(Li, { open: u, onOpenChange: te, children: [
    /* @__PURE__ */ d(Pi, { asChild: !0, children: /* @__PURE__ */ d(
      Ne,
      {
        "aria-label": "book-chapter-trigger",
        variant: "outline",
        role: "combobox",
        "aria-expanded": u,
        className: z(
          "tw-h-8 tw-w-full tw-min-w-16 tw-max-w-48 tw-overflow-hidden tw-px-1",
          n
        ),
        children: /* @__PURE__ */ d("span", { className: "tw-truncate", children: be })
      }
    ) }),
    /* @__PURE__ */ d(zo, { id: l, forceMount: !0, className: "tw-w-[280px] tw-p-0", align: "center", children: /* @__PURE__ */ M(
      Oi,
      {
        ref: O,
        onKeyDown: Se,
        loop: !0,
        value: f,
        onValueChange: h,
        shouldFilter: !1,
        children: [
          _ === "books" ? /* @__PURE__ */ M("div", { className: "tw-flex tw-items-end", children: [
            /* @__PURE__ */ M("div", { className: "tw-relative tw-flex-1", children: [
              /* @__PURE__ */ d(
                Gs,
                {
                  ref: U,
                  value: g,
                  onValueChange: b,
                  onKeyDown: se,
                  onFocus: () => V(!1),
                  className: s && s.length > 0 ? "!tw-pr-10" : ""
                }
              ),
              s && s.length > 0 && /* @__PURE__ */ d(
                e2,
                {
                  recentSearches: s,
                  onSearchItemSelect: G,
                  renderItem: (re) => ai(re, "English"),
                  getItemKey: (re) => `${re.book}-${re.chapterNum}-${re.verseNum}`,
                  ariaLabel: i == null ? void 0 : i["%history_recentSearches_ariaLabel%"],
                  groupHeading: i == null ? void 0 : i["%history_recent%"]
                }
              )
            ] }),
            /* @__PURE__ */ d("div", { className: "tw-flex tw-items-center tw-gap-1 tw-border-b tw-pe-2", children: W.map(({ onClick: re, disabled: Ce, title: Re, icon: je }) => /* @__PURE__ */ d(
              Ne,
              {
                variant: "ghost",
                size: "sm",
                onClick: () => {
                  V(!0), re();
                },
                disabled: Ce,
                className: "tw-h-10 tw-w-4 tw-p-0",
                title: Re,
                onKeyDown: Fe,
                children: /* @__PURE__ */ d(je, {})
              },
              Re
            )) })
          ] }) : /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center tw-border-b tw-px-3 tw-py-2", children: [
            /* @__PURE__ */ d(
              Ne,
              {
                variant: "ghost",
                size: "sm",
                onClick: ee,
                className: "tw-mr-2 tw-h-6 tw-w-6 tw-p-0",
                tabIndex: -1,
                children: c === "ltr" ? /* @__PURE__ */ d(K0, { className: "tw-h-4 tw-w-4" }) : /* @__PURE__ */ d(W0, { className: "tw-h-4 tw-w-4" })
              }
            ),
            y && /* @__PURE__ */ d("span", { tabIndex: -1, className: "tw-text-sm tw-font-medium", children: li(y, o) })
          ] }),
          !P && /* @__PURE__ */ M(Ri, { ref: B, children: [
            _ === "books" && /* @__PURE__ */ M(ft, { children: [
              !T && Object.entries(N).map(([re, Ce]) => {
                if (Ce.length !== 0)
                  return (
                    // We are mapping over filteredBooksByType, which uses Section as key type
                    // eslint-disable-next-line no-type-assertion/no-type-assertion
                    /* @__PURE__ */ d(No, { heading: pe(re), children: Ce.map((Re) => /* @__PURE__ */ d(
                      Gw,
                      {
                        bookId: Re,
                        onSelect: (je) => L(je),
                        section: ds(Re),
                        commandValue: `${Re} ${_o[Re]}`,
                        ref: Re === t.book ? F : void 0,
                        localizedBookNames: o
                      },
                      Re
                    )) }, re)
                  );
              }),
              T && /* @__PURE__ */ d(No, { children: /* @__PURE__ */ d(
                Ho,
                {
                  value: `${T.book} ${_o[T.book]} ${T.chapterNum || ""}:${T.verseNum || ""})}`,
                  onSelect: $,
                  className: "tw-font-semibold tw-text-primary",
                  children: ai(
                    {
                      book: T.book,
                      chapterNum: T.chapterNum ?? 1,
                      verseNum: T.verseNum ?? 1
                    },
                    o ? pd(T.book, o) : void 0
                  )
                },
                "top-match"
              ) }),
              T && dr(T.book) > 1 && /* @__PURE__ */ M(ft, { children: [
                /* @__PURE__ */ d("div", { className: "tw-mb-2 tw-px-3 tw-text-sm tw-font-medium tw-text-muted-foreground", children: li(T.book, o) }),
                /* @__PURE__ */ d(
                  Lp,
                  {
                    bookId: T.book,
                    scrRef: t,
                    onChapterSelect: J,
                    setChapterRef: ye,
                    isChapterDimmed: _e,
                    className: "tw-px-4 tw-pb-4"
                  }
                )
              ] })
            ] }),
            _ === "chapters" && y && /* @__PURE__ */ d(
              Lp,
              {
                bookId: y,
                scrRef: t,
                onChapterSelect: J,
                setChapterRef: ye,
                className: "tw-p-4"
              }
            )
          ] })
        ]
      }
    ) })
  ] });
}
const I5 = Object.freeze([
  "%scripture_section_ot_long%",
  "%scripture_section_nt_long%",
  "%scripture_section_dc_long%",
  "%scripture_section_extra_long%",
  "%history_recent%",
  "%history_recentSearches_ariaLabel%"
]), o2 = eo(
  "tw-text-sm tw-font-medium tw-leading-none peer-disabled:tw-cursor-not-allowed peer-disabled:tw-opacity-70"
), Lt = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(fw.Root, { ref: n, className: z("pr-twp", o2(), t), ...e }));
Lt.displayName = fw.Root.displayName;
const hd = X.forwardRef(({ className: t, ...e }, n) => {
  const r = Bt();
  return /* @__PURE__ */ d(
    ms.Root,
    {
      className: z("pr-twp tw-grid tw-gap-2", t),
      ...e,
      ref: n,
      dir: r
    }
  );
});
hd.displayName = ms.Root.displayName;
const Ka = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  ms.Item,
  {
    ref: n,
    className: z(
      "pr-twp tw-aspect-square tw-h-4 tw-w-4 tw-rounded-full tw-border tw-border-primary tw-text-primary tw-ring-offset-background focus:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-cursor-not-allowed disabled:tw-opacity-50",
      t
    ),
    ...e,
    children: /* @__PURE__ */ d(ms.Indicator, { className: "tw-flex tw-items-center tw-justify-center", children: /* @__PURE__ */ d(gl, { className: "tw-h-2.5 tw-w-2.5 tw-fill-current tw-text-current" }) })
  }
));
Ka.displayName = ms.Item.displayName;
function i2(t) {
  return typeof t == "string" ? t : typeof t == "number" ? t.toString() : t.label;
}
function au({
  id: t,
  options: e = [],
  className: n,
  buttonClassName: r,
  popoverContentClassName: o,
  value: i,
  onChange: s = () => {
  },
  getOptionLabel: a = i2,
  icon: l = void 0,
  buttonPlaceholder: c = "",
  textPlaceholder: u = "",
  commandEmptyMessage: p = "No option found",
  buttonVariant: f = "outline",
  alignDropDown: h = "start",
  isDisabled: g = !1,
  ...b
}) {
  const [_, x] = oe(!1);
  return /* @__PURE__ */ M(Li, { open: _, onOpenChange: x, ...b, children: [
    /* @__PURE__ */ d(Pi, { asChild: !0, children: /* @__PURE__ */ M(
      Ne,
      {
        variant: f,
        role: "combobox",
        "aria-expanded": _,
        id: t,
        className: z(
          "tw-flex tw-w-[200px] tw-items-center tw-justify-between tw-overflow-hidden",
          r ?? n
        ),
        disabled: g,
        children: [
          /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-1 tw-items-center tw-overflow-hidden", children: [
            l && /* @__PURE__ */ d("div", { className: "tw-pe-2", children: l }),
            /* @__PURE__ */ d("span", { className: z("tw-overflow-hidden tw-text-ellipsis tw-whitespace-nowrap"), children: i ? a(i) : c })
          ] }),
          /* @__PURE__ */ d(Zu, { className: "tw-ms-2 tw-h-4 tw-w-4 tw-shrink-0 tw-opacity-50" })
        ]
      }
    ) }),
    /* @__PURE__ */ d(
      zo,
      {
        align: h,
        className: z("tw-w-[200px] tw-p-0", o),
        children: /* @__PURE__ */ M(Oi, { children: [
          /* @__PURE__ */ d(Gs, { placeholder: u, className: "tw-text-inherit" }),
          /* @__PURE__ */ d(kl, { children: p }),
          /* @__PURE__ */ d(Ri, { children: e.map((y) => /* @__PURE__ */ M(
            Ho,
            {
              value: a(y),
              onSelect: () => {
                s(y), x(!1);
              },
              children: [
                /* @__PURE__ */ d(
                  br,
                  {
                    className: z("tw-me-2 tw-h-4 tw-w-4", {
                      "tw-opacity-0": !i || a(i) !== a(y)
                    })
                  }
                ),
                a(y)
              ]
            },
            a(y)
          )) })
        ] })
      }
    )
  ] });
}
function s2({
  startChapter: t,
  endChapter: e,
  handleSelectStartChapter: n,
  handleSelectEndChapter: r,
  isDisabled: o = !1,
  chapterCount: i
}) {
  const s = ue(
    () => Array.from({ length: i }, (c, u) => u + 1),
    [i]
  );
  return /* @__PURE__ */ M(ft, { children: [
    /* @__PURE__ */ d(Lt, { htmlFor: "start-chapters-combobox", children: "Chapters" }),
    /* @__PURE__ */ d(
      au,
      {
        isDisabled: o,
        onChange: (c) => {
          n(c), c > e && r(c);
        },
        buttonClassName: "tw-me-2 tw-ms-2 tw-w-20",
        options: s,
        getOptionLabel: (c) => c.toString(),
        value: t
      },
      "start chapter"
    ),
    /* @__PURE__ */ d(Lt, { htmlFor: "end-chapters-combobox", children: "to" }),
    /* @__PURE__ */ d(
      au,
      {
        isDisabled: o,
        onChange: (c) => {
          r(c), c < t && n(c);
        },
        buttonClassName: "tw-ms-2 tw-w-20",
        options: s,
        getOptionLabel: (c) => c.toString(),
        value: e
      },
      "end chapter"
    )
  ] });
}
var a2 = /* @__PURE__ */ ((t) => (t.CURRENT_BOOK = "current book", t.CHOOSE_BOOKS = "choose books", t))(a2 || {});
const L5 = Object.freeze([
  "%webView_bookSelector_currentBook%",
  "%webView_bookSelector_choose%",
  "%webView_bookSelector_chooseBooks%"
]), vc = (t, e) => t[e] ?? e;
function P5({
  handleBookSelectionModeChange: t,
  currentBookName: e,
  onSelectBooks: n,
  selectedBookIds: r,
  chapterCount: o,
  endChapter: i,
  handleSelectEndChapter: s,
  startChapter: a,
  handleSelectStartChapter: l,
  localizedStrings: c
}) {
  const u = vc(c, "%webView_bookSelector_currentBook%"), p = vc(c, "%webView_bookSelector_choose%"), f = vc(c, "%webView_bookSelector_chooseBooks%"), [h, g] = oe(
    "current book"
    /* CURRENT_BOOK */
  ), b = (_) => {
    g(_), t(_);
  };
  return /* @__PURE__ */ d(
    hd,
    {
      className: "pr-twp tw-flex",
      value: h,
      onValueChange: (_) => b(_),
      children: /* @__PURE__ */ M("div", { className: "tw-flex tw-w-full tw-flex-col tw-gap-4", children: [
        /* @__PURE__ */ M("div", { className: "tw-grid tw-grid-cols-[25%,25%,50%]", children: [
          /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center", children: [
            /* @__PURE__ */ d(Ka, {
              value: "current book"
              /* CURRENT_BOOK */
            }),
            /* @__PURE__ */ d(Lt, { className: "tw-ms-1", children: u })
          ] }),
          /* @__PURE__ */ d(Lt, { className: "tw-flex tw-items-center", children: e }),
          /* @__PURE__ */ d("div", { className: "tw-flex tw-items-center tw-justify-end", children: /* @__PURE__ */ d(
            s2,
            {
              isDisabled: h === "choose books",
              handleSelectStartChapter: l,
              handleSelectEndChapter: s,
              chapterCount: o,
              startChapter: a,
              endChapter: i
            }
          ) })
        ] }),
        /* @__PURE__ */ M("div", { className: "tw-grid tw-grid-cols-[25%,50%,25%]", children: [
          /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center", children: [
            /* @__PURE__ */ d(Ka, {
              value: "choose books"
              /* CHOOSE_BOOKS */
            }),
            /* @__PURE__ */ d(Lt, { className: "tw-ms-1", children: f })
          ] }),
          /* @__PURE__ */ d(Lt, { className: "tw-flex tw-items-center", children: r.map((_) => We.bookIdToEnglishName(_)).join(", ") }),
          /* @__PURE__ */ d(
            Ne,
            {
              disabled: h === "current book",
              onClick: () => n(),
              children: p
            }
          )
        ] })
      ] })
    }
  );
}
const l2 = ["input", "select", "textarea", "button"], c2 = ["button", "textbox"], u2 = ({
  options: t,
  onFocusChange: e,
  onOptionSelect: n,
  onCharacterPress: r
}) => {
  const o = he(null), [i, s] = oe(void 0), [a, l] = oe(void 0), c = ce(
    (h) => {
      s(h);
      const g = t.find((_) => _.id === h);
      g && (e == null || e(g));
      const b = document.getElementById(h);
      b && (b.scrollIntoView({ block: "center" }), b.focus()), o.current && o.current.setAttribute("aria-activedescendant", h);
    },
    [e, t]
  ), u = ce(
    (h) => {
      const g = t.find((b) => b.id === h);
      g && (l((b) => b === h ? void 0 : h), n == null || n(g));
    },
    [n, t]
  ), p = (h) => {
    if (!h) return !1;
    const g = h.tagName.toLowerCase();
    if (h.isContentEditable || l2.includes(g)) return !0;
    const b = h.getAttribute("role");
    if (b && c2.includes(b)) return !0;
    const _ = h.getAttribute("tabindex");
    return _ !== void 0 && _ !== "-1";
  }, f = ce(
    (h) => {
      var U;
      const g = h.target, b = (B) => B ? document.getElementById(B) : void 0, _ = b(a), x = b(i);
      if (!!(_ && g && _.contains(g) && g !== _) && p(g)) {
        if (h.key === "Escape" || h.key === "ArrowLeft" && !g.isContentEditable) {
          if (a) {
            h.preventDefault(), h.stopPropagation();
            const B = t.find((F) => F.id === a);
            B && c(B.id);
          }
          return;
        }
        if (h.key === "ArrowDown" || h.key === "ArrowUp") {
          if (!_) return;
          const B = Array.from(
            _.querySelectorAll(
              'button:not([disabled]), input:not([disabled]):not([type="hidden"]), textarea:not([disabled]), select:not([disabled]), [href], [tabindex]:not([tabindex="-1"])'
            )
          );
          if (B.length === 0) return;
          const F = B.findIndex((E) => E === g);
          if (F === -1) return;
          let K;
          h.key === "ArrowDown" ? K = Math.min(F + 1, B.length - 1) : K = Math.max(F - 1, 0), K !== F && (h.preventDefault(), h.stopPropagation(), (U = B[K]) == null || U.focus());
          return;
        }
        return;
      }
      const P = t.findIndex((B) => B.id === i);
      let V = P;
      switch (h.key) {
        case "ArrowDown":
          V = Math.min(P + 1, t.length - 1), h.preventDefault();
          break;
        case "ArrowUp":
          V = Math.max(P - 1, 0), h.preventDefault();
          break;
        case "Home":
          V = 0, h.preventDefault();
          break;
        case "End":
          V = t.length - 1, h.preventDefault();
          break;
        case " ":
        case "Enter":
          i && u(i), h.preventDefault(), h.stopPropagation();
          return;
        case "ArrowRight": {
          const B = x;
          if (B) {
            const F = B.querySelector(
              'input:not([disabled]):not([type="hidden"]), textarea:not([disabled]), select:not([disabled])'
            ), K = B.querySelector(
              'button:not([disabled]), [href], [tabindex]:not([tabindex="-1"]), [contenteditable="true"]'
            ), E = F ?? K;
            if (E) {
              h.preventDefault(), E.focus();
              return;
            }
          }
          break;
        }
        default:
          h.key.length === 1 && !h.metaKey && !h.ctrlKey && !h.altKey && (p(g) || (r == null || r(h.key), h.preventDefault()));
          return;
      }
      const O = t[V];
      O && c(O.id);
    },
    [t, c, i, a, u, r]
  );
  return {
    listboxRef: o,
    activeId: i,
    selectedId: a,
    handleKeyDown: f,
    focusOption: c
  };
}, wd = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "div",
    {
      ref: n,
      className: z(
        "pr-twp tw-rounded-lg tw-border tw-bg-card tw-text-card-foreground tw-shadow-sm",
        t
      ),
      ...e
    }
  )
);
wd.displayName = "Card";
const d2 = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "div",
    {
      ref: n,
      className: z("pr-twp tw-flex tw-flex-col tw-space-y-1.5 tw-p-6", t),
      ...e
    }
  )
);
d2.displayName = "CardHeader";
const p2 = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "h3",
    {
      ref: n,
      className: z(
        "pr-twp tw-text-2xl tw-font-semibold tw-leading-none tw-tracking-tight",
        t
      ),
      ...e,
      children: e.children
    }
  )
);
p2.displayName = "CardTitle";
const f2 = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d("p", { ref: n, className: z("pr-twp tw-text-sm tw-text-muted-foreground", t), ...e }));
f2.displayName = "CardDescription";
const Kw = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d("div", { ref: n, className: z("pr-twp tw-p-6 tw-pt-0", t), ...e })
);
Kw.displayName = "CardContent";
const h2 = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "div",
    {
      ref: n,
      className: z("pr-twp tw-flex tw-items-center tw-p-6 tw-pt-0", t),
      ...e
    }
  )
);
h2.displayName = "CardFooter";
const vs = X.forwardRef(({ className: t, orientation: e = "horizontal", decorative: n = !0, ...r }, o) => /* @__PURE__ */ d(
  hw.Root,
  {
    ref: o,
    decorative: n,
    orientation: e,
    className: z(
      "pr-twp tw-shrink-0 tw-bg-border",
      e === "horizontal" ? "tw-h-[1px] tw-w-full" : "tw-h-full tw-w-[1px]",
      t
    ),
    ...r
  }
));
vs.displayName = hw.Root.displayName;
const w2 = eo(
  "pr-twp tw-inline-flex tw-items-center tw-rounded-full tw-px-2.5 tw-py-0.5 tw-text-xs tw-font-semibold tw-transition-colors focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-ring focus:tw-ring-offset-2",
  {
    variants: {
      variant: {
        default: "tw-border tw-border-transparent tw-bg-primary tw-text-primary-foreground hover:tw-bg-primary/80",
        secondary: "tw-border tw-border-transparent tw-bg-secondary tw-text-secondary-foreground hover:tw-bg-secondary/80",
        muted: "tw-border tw-border-transparent tw-bg-muted tw-text-muted-foreground hover:tw-bg-muted/80",
        destructive: "tw-border tw-border-transparent tw-bg-destructive tw-text-destructive-foreground hover:tw-bg-destructive/80",
        outline: "tw-border tw-text-foreground",
        blueIndicator: "tw-w-[5px] tw-h-[5px] tw-bg-blue-400 tw-px-0",
        mutedIndicator: "tw-w-[5px] tw-h-[5px] tw-bg-zinc-400 tw-px-0",
        ghost: "hover:tw-bg-accent hover:tw-text-accent-foreground tw-text-mu"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), ys = X.forwardRef(
  ({ className: t, variant: e, ...n }, r) => /* @__PURE__ */ d("div", { ref: r, className: z("pr-twp", w2({ variant: e }), t), ...n })
);
ys.displayName = "Badge";
const Ww = Zr(null);
function g2(t, e) {
  return { getTheme: function() {
    return e ?? null;
  } };
}
function oo() {
  const t = jo(Ww);
  return t == null && function(e, ...n) {
    const r = new URL("https://lexical.dev/docs/error"), o = new URLSearchParams();
    o.append("code", e);
    for (const i of n) o.append("v", i);
    throw r.search = o.toString(), Error(`Minified Lexical error #${e}; visit ${r.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }(8), t;
}
const Jw = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, m2 = Jw ? xt : ie, ba = { tag: Uo };
function b2({ initialConfig: t, children: e }) {
  const n = ue(() => {
    const { theme: r, namespace: o, nodes: i, onError: s, editorState: a, html: l } = t, c = g2(null, r), u = qs({ editable: t.editable, html: l, namespace: o, nodes: i, onError: (p) => s(p, u), theme: r });
    return function(p, f) {
      if (f !== null) {
        if (f === void 0) p.update(() => {
          const h = tt();
          if (h.isEmpty()) {
            const g = js();
            h.append(g);
            const b = Jw ? document.activeElement : null;
            (ve() !== null || b !== null && b === p.getRootElement()) && g.select();
          }
        }, ba);
        else if (f !== null) switch (typeof f) {
          case "string": {
            const h = p.parseEditorState(f);
            p.setEditorState(h, ba);
            break;
          }
          case "object":
            p.setEditorState(f, ba);
            break;
          case "function":
            p.update(() => {
              tt().isEmpty() && f(p);
            }, ba);
        }
      }
    }(u, a), [u, c];
  }, []);
  return m2(() => {
    const r = t.editable, [o] = n;
    o.setEditable(r === void 0 || r);
  }, []), d(Ww.Provider, { value: n, children: e });
}
const v2 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? xt : ie;
function y2({ ignoreHistoryMergeTagChange: t = !0, ignoreSelectionChange: e = !1, onChange: n }) {
  const [r] = oo();
  return v2(() => {
    if (n) return r.registerUpdateListener(({ editorState: o, dirtyElements: i, dirtyLeaves: s, prevEditorState: a, tags: l }) => {
      e && i.size === 0 && s.size === 0 || t && l.has(Uo) || a.isEmpty() || n(o, r, l);
    });
  }, [r, t, e, n]), null;
}
const gd = {
  ltr: "tw-text-left",
  rtl: "tw-text-right",
  heading: {
    h1: "tw-scroll-m-20 tw-text-4xl tw-font-extrabold tw-tracking-tight lg:tw-text-5xl",
    h2: "tw-scroll-m-20 tw-border-b tw-pb-2 tw-text-3xl tw-font-semibold tw-tracking-tight first:tw-mt-0",
    h3: "tw-scroll-m-20 tw-text-2xl tw-font-semibold tw-tracking-tight",
    h4: "tw-scroll-m-20 tw-text-xl tw-font-semibold tw-tracking-tight",
    h5: "tw-scroll-m-20 tw-text-lg tw-font-semibold tw-tracking-tight",
    h6: "tw-scroll-m-20 tw-text-base tw-font-semibold tw-tracking-tight"
  },
  paragraph: "tw-outline-none",
  quote: "tw-mt-6 tw-border-l-2 tw-pl-6 tw-italic",
  link: "tw-text-blue-600 hover:tw-underline hover:tw-cursor-pointer",
  list: {
    checklist: "tw-relative",
    listitem: "tw-mx-8",
    listitemChecked: 'tw-relative tw-mx-2 tw-px-6 tw-list-none tw-outline-none tw-line-through before:tw-content-[""] before:tw-w-4 before:tw-h-4 before:tw-top-0.5 before:tw-left-0 before:tw-cursor-pointer before:tw-block before:tw-bg-cover before:tw-absolute before:tw-border before:tw-border-primary before:tw-rounded before:tw-bg-primary before:tw-bg-no-repeat after:tw-content-[""] after:tw-cursor-pointer after:tw-border-white after:tw-border-solid after:tw-absolute after:tw-block after:tw-top-[6px] after:tw-w-[3px] after:tw-left-[7px] after:tw-right-[7px] after:tw-h-[6px] after:tw-rotate-45 after:tw-border-r-2 after:tw-border-b-2 after:tw-border-l-0 after:tw-border-t-0',
    listitemUnchecked: 'tw-relative tw-mx-2 tw-px-6 tw-list-none tw-outline-none before:tw-content-[""] before:tw-w-4 before:tw-h-4 before:tw-top-0.5 before:tw-left-0 before:tw-cursor-pointer before:tw-block before:tw-bg-cover before:tw-absolute before:tw-border before:tw-border-primary before:tw-rounded',
    nested: {
      listitem: "tw-list-none before:tw-hidden after:tw-hidden"
    },
    ol: "tw-m-0 tw-p-0 tw-list-decimal [&>li]:tw-mt-2",
    olDepth: [
      "tw-list-outside !tw-list-decimal",
      "tw-list-outside !tw-list-[upper-roman]",
      "tw-list-outside !tw-list-[lower-roman]",
      "tw-list-outside !tw-list-[upper-alpha]",
      "tw-list-outside !tw-list-[lower-alpha]"
    ],
    ul: "tw-m-0 tw-p-0 tw-list-outside [&>li]:tw-mt-2",
    ulDepth: [
      "tw-list-outside !tw-list-disc",
      "tw-list-outside !tw-list-disc",
      "tw-list-outside !tw-list-disc",
      "tw-list-outside !tw-list-disc",
      "tw-list-outside !tw-list-disc"
    ]
  },
  hashtag: "tw-text-blue-600 tw-bg-blue-100 tw-rounded-md tw-px-1",
  text: {
    bold: "tw-font-bold",
    code: "tw-bg-gray-100 tw-p-1 tw-rounded-md",
    italic: "tw-italic",
    strikethrough: "tw-line-through",
    subscript: "tw-sub",
    superscript: "tw-sup",
    underline: "tw-underline",
    underlineStrikethrough: "tw-underline tw-line-through"
  },
  image: "tw-relative tw-inline-block tw-user-select-none tw-cursor-default editor-image",
  inlineImage: "tw-relative tw-inline-block tw-user-select-none tw-cursor-default inline-editor-image",
  keyword: "tw-text-purple-900 tw-font-bold",
  code: "EditorTheme__code",
  codeHighlight: {
    atrule: "EditorTheme__tokenAttr",
    attr: "EditorTheme__tokenAttr",
    boolean: "EditorTheme__tokenProperty",
    builtin: "EditorTheme__tokenSelector",
    cdata: "EditorTheme__tokenComment",
    char: "EditorTheme__tokenSelector",
    class: "EditorTheme__tokenFunction",
    "class-name": "EditorTheme__tokenFunction",
    comment: "EditorTheme__tokenComment",
    constant: "EditorTheme__tokenProperty",
    deleted: "EditorTheme__tokenProperty",
    doctype: "EditorTheme__tokenComment",
    entity: "EditorTheme__tokenOperator",
    function: "EditorTheme__tokenFunction",
    important: "EditorTheme__tokenVariable",
    inserted: "EditorTheme__tokenSelector",
    keyword: "EditorTheme__tokenAttr",
    namespace: "EditorTheme__tokenVariable",
    number: "EditorTheme__tokenProperty",
    operator: "EditorTheme__tokenOperator",
    prolog: "EditorTheme__tokenComment",
    property: "EditorTheme__tokenProperty",
    punctuation: "EditorTheme__tokenPunctuation",
    regex: "EditorTheme__tokenVariable",
    selector: "EditorTheme__tokenSelector",
    string: "EditorTheme__tokenSelector",
    symbol: "EditorTheme__tokenProperty",
    tag: "EditorTheme__tokenProperty",
    url: "EditorTheme__tokenOperator",
    variable: "EditorTheme__tokenVariable"
  },
  characterLimit: "!tw-bg-destructive/50",
  table: "EditorTheme__table tw-w-fit tw-overflow-scroll tw-border-collapse",
  tableCell: 'EditorTheme__tableCell tw-w-24 tw-relative tw-border tw-px-4 tw-py-2 tw-text-left [&[align=center]]:tw-text-center [&[align=right]]:tw-text-right"',
  tableCellActionButton: "EditorTheme__tableCellActionButton tw-bg-background tw-block tw-border-0 tw-rounded-2xl tw-w-5 tw-h-5 tw-text-foreground tw-cursor-pointer",
  tableCellActionButtonContainer: "EditorTheme__tableCellActionButtonContainer tw-block tw-right-1 tw-top-1.5 tw-absolute tw-z-10 tw-w-5 tw-h-5",
  tableCellEditing: "EditorTheme__tableCellEditing tw-rounded-sm tw-shadow-sm",
  tableCellHeader: "EditorTheme__tableCellHeader tw-bg-muted tw-border tw-px-4 tw-py-2 tw-text-left tw-font-bold [&[align=center]]:tw-text-center [&[align=right]]:tw-text-right",
  tableCellPrimarySelected: "EditorTheme__tableCellPrimarySelected tw-border tw-border-primary tw-border-solid tw-block tw-h-[calc(100%-2px)] tw-w-[calc(100%-2px)] tw-absolute tw--left-[1px] tw--top-[1px] tw-z-10 ",
  tableCellResizer: "EditorTheme__tableCellResizer tw-absolute tw--right-1 tw-h-full tw-w-2 tw-cursor-ew-resize tw-z-10 tw-top-0",
  tableCellSelected: "EditorTheme__tableCellSelected tw-bg-muted",
  tableCellSortedIndicator: "EditorTheme__tableCellSortedIndicator tw-block tw-opacity-50 tw-bsolute tw-bottom-0 tw-left-0 tw-w-full tw-h-1 tw-bg-muted",
  tableResizeRuler: "EditorTheme__tableCellResizeRuler tw-block tw-absolute tw-w-[1px] tw-h-full tw-bg-primary tw-top-0",
  tableRowStriping: "EditorTheme__tableRowStriping tw-m-0 tw-border-t tw-p-0 even:tw-bg-muted",
  tableSelected: "EditorTheme__tableSelected tw-ring-2 tw-ring-primary tw-ring-offset-2",
  tableSelection: "EditorTheme__tableSelection tw-bg-transparent",
  layoutItem: "tw-border tw-border-dashed tw-px-4 tw-py-2",
  layoutContainer: "tw-grid tw-gap-2.5 tw-my-2.5 tw-mx-0",
  autocomplete: "tw-text-muted-foreground",
  blockCursor: "",
  embedBlock: {
    base: "tw-user-select-none",
    focus: "tw-ring-2 tw-ring-primary tw-ring-offset-2"
  },
  hr: 'tw-p-0.5 tw-border-none tw-my-1 tw-mx-0 tw-cursor-pointer after:tw-content-[""] after:tw-block after:tw-h-0.5 after:tw-bg-muted selected:tw-ring-2 selected:tw-ring-primary selected:tw-ring-offset-2 selected:tw-user-select-none',
  indent: "[--lexical-indent-base-value:40px]",
  mark: "",
  markOverlap: ""
}, Nl = zs.Provider, md = zs.Root, bd = zs.Trigger, Tl = X.forwardRef(({ className: t, sideOffset: e = 4, ...n }, r) => /* @__PURE__ */ d(
  zs.Content,
  {
    ref: r,
    sideOffset: e,
    className: z(
      "pr-twp tw-z-50 tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-px-3 tw-py-1.5 tw-text-sm tw-text-popover-foreground tw-shadow-md tw-animate-in tw-fade-in-0 tw-zoom-in-95 data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=closed]:tw-zoom-out-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
      t
    ),
    ...n
  }
));
Tl.displayName = zs.Content.displayName;
const vd = [
  Ey,
  Us,
  Hn,
  ky
], x2 = Zr(null), yc = {
  didCatch: !1,
  error: null
};
class _2 extends j0 {
  constructor(e) {
    super(e), this.resetErrorBoundary = this.resetErrorBoundary.bind(this), this.state = yc;
  }
  static getDerivedStateFromError(e) {
    return {
      didCatch: !0,
      error: e
    };
  }
  resetErrorBoundary() {
    const {
      error: e
    } = this.state;
    if (e !== null) {
      for (var n, r, o = arguments.length, i = new Array(o), s = 0; s < o; s++)
        i[s] = arguments[s];
      (n = (r = this.props).onReset) === null || n === void 0 || n.call(r, {
        args: i,
        reason: "imperative-api"
      }), this.setState(yc);
    }
  }
  componentDidCatch(e, n) {
    var r, o;
    (r = (o = this.props).onError) === null || r === void 0 || r.call(o, e, n);
  }
  componentDidUpdate(e, n) {
    const {
      didCatch: r
    } = this.state, {
      resetKeys: o
    } = this.props;
    if (r && n.error !== null && C2(e.resetKeys, o)) {
      var i, s;
      (i = (s = this.props).onReset) === null || i === void 0 || i.call(s, {
        next: o,
        prev: e.resetKeys,
        reason: "keys"
      }), this.setState(yc);
    }
  }
  render() {
    const {
      children: e,
      fallbackRender: n,
      FallbackComponent: r,
      fallback: o
    } = this.props, {
      didCatch: i,
      error: s
    } = this.state;
    let a = e;
    if (i) {
      const l = {
        error: s,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof n == "function")
        a = n(l);
      else if (r)
        a = Ep(r, l);
      else if (o !== void 0)
        a = o;
      else
        throw s;
    }
    return Ep(x2.Provider, {
      value: {
        didCatch: i,
        error: s,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, a);
  }
}
function C2() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return t.length !== e.length || t.some((n, r) => !Object.is(n, e[r]));
}
function E2({ children: t, onError: e }) {
  return d(_2, { fallback: d("div", { style: { border: "1px solid #f00", color: "#f00", padding: "8px" }, children: "An error was thrown." }), onError: e, children: t });
}
const k2 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? xt : ie;
function N2(t) {
  return { initialValueFn: () => t.isEditable(), subscribe: (e) => t.registerEditableListener(e) };
}
function T2() {
  return function(t) {
    const [e] = oo(), n = ue(() => t(e), [e, t]), [r, o] = oe(() => n.initialValueFn()), i = he(r);
    return k2(() => {
      const { initialValueFn: s, subscribe: a } = n, l = s();
      return i.current !== l && (i.current = l, o(l)), a((c) => {
        i.current = c, o(c);
      });
    }, [n, t]), r;
  }(N2);
}
function A2(t, ...e) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", t);
  for (const o of e) r.append("v", o);
  throw n.search = r.toString(), Error(`Minified Lexical error #${t}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
const Xw = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, S2 = Xw && "documentMode" in document ? document.documentMode : null;
!(!Xw || !("InputEvent" in window) || S2) && "getTargetRanges" in new window.InputEvent("input");
function Yw(...t) {
  const e = [];
  for (const n of t) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) e.push(r);
  return e;
}
function xs(...t) {
  return () => {
    for (let e = t.length - 1; e >= 0; e--) t[e]();
    t.length = 0;
  };
}
function Qw(t, ...e) {
  const n = Yw(...e);
  n.length > 0 && t.classList.add(...n);
}
function D2(t, ...e) {
  const n = Yw(...e);
  n.length > 0 && t.classList.remove(...n);
}
function Pp(t) {
  const e = Iv(t, (n) => Ae(n) && !n.isInline());
  return Ae(e) || A2(4, t.__key), e;
}
function M2(t, e) {
  const n = [];
  for (let r = 0; r < t.length; r++) {
    const o = e(t[r]);
    o !== null && n.push(o);
  }
  return n;
}
const O2 = Symbol.for("preact-signals");
function Al() {
  if (Kr > 1) return void Kr--;
  let t, e = !1;
  for (; hs !== void 0; ) {
    let n = hs;
    for (hs = void 0, lu++; n !== void 0; ) {
      const r = n.o;
      if (n.o = void 0, n.f &= -3, !(8 & n.f) && Zw(n)) try {
        n.c();
      } catch (o) {
        e || (t = o, e = !0);
      }
      n = r;
    }
  }
  if (lu = 0, Kr--, e) throw t;
}
function R2(t) {
  if (Kr > 0) return t();
  Kr++;
  try {
    return t();
  } finally {
    Al();
  }
}
let He, hs;
function $p(t) {
  const e = He;
  He = void 0;
  try {
    return t();
  } finally {
    He = e;
  }
}
let Kr = 0, lu = 0, $a = 0;
function Fp(t) {
  if (He === void 0) return;
  let e = t.n;
  return e === void 0 || e.t !== He ? (e = { i: 0, S: t, p: He.s, n: void 0, t: He, e: void 0, x: void 0, r: e }, He.s !== void 0 && (He.s.n = e), He.s = e, t.n = e, 32 & He.f && t.S(e), e) : e.i === -1 ? (e.i = 0, e.n !== void 0 && (e.n.p = e.p, e.p !== void 0 && (e.p.n = e.n), e.p = He.s, e.n = void 0, He.s.n = e, He.s = e), e) : void 0;
}
function rn(t, e) {
  this.v = t, this.i = 0, this.n = void 0, this.t = void 0, this.W = e == null ? void 0 : e.watched, this.Z = e == null ? void 0 : e.unwatched, this.name = e == null ? void 0 : e.name;
}
function _s(t, e) {
  return new rn(t, e);
}
function Zw(t) {
  for (let e = t.s; e !== void 0; e = e.n) if (e.S.i !== e.i || !e.S.h() || e.S.i !== e.i) return !0;
  return !1;
}
function Bp(t) {
  for (let e = t.s; e !== void 0; e = e.n) {
    const n = e.S.n;
    if (n !== void 0 && (e.r = n), e.S.n = e, e.i = -1, e.n === void 0) {
      t.s = e;
      break;
    }
  }
}
function eg(t) {
  let e, n = t.s;
  for (; n !== void 0; ) {
    const r = n.p;
    n.i === -1 ? (n.S.U(n), r !== void 0 && (r.n = n.n), n.n !== void 0 && (n.n.p = r)) : e = n, n.S.n = n.r, n.r !== void 0 && (n.r = void 0), n = r;
  }
  t.s = e;
}
function vo(t, e) {
  rn.call(this, void 0), this.x = t, this.s = void 0, this.g = $a - 1, this.f = 4, this.W = e == null ? void 0 : e.watched, this.Z = e == null ? void 0 : e.unwatched, this.name = e == null ? void 0 : e.name;
}
function I2(t, e) {
  return new vo(t, e);
}
function tg(t) {
  const e = t.u;
  if (t.u = void 0, typeof e == "function") {
    Kr++;
    const n = He;
    He = void 0;
    try {
      e();
    } catch (r) {
      throw t.f &= -2, t.f |= 8, yd(t), r;
    } finally {
      He = n, Al();
    }
  }
}
function yd(t) {
  for (let e = t.s; e !== void 0; e = e.n) e.S.U(e);
  t.x = void 0, t.s = void 0, tg(t);
}
function L2(t) {
  if (He !== this) throw new Error("Out-of-order effect");
  eg(this), He = t, this.f &= -2, 8 & this.f && yd(this), Al();
}
function ri(t, e) {
  this.x = t, this.u = void 0, this.s = void 0, this.o = void 0, this.f = 32, this.name = e == null ? void 0 : e.name;
}
function Wr(t, e) {
  const n = new ri(t, e);
  try {
    n.c();
  } catch (o) {
    throw n.d(), o;
  }
  const r = n.d.bind(n);
  return r[Symbol.dispose] = r, r;
}
function Sl(t, e = {}) {
  const n = {};
  for (const r in t) {
    const o = e[r], i = _s(o === void 0 ? t[r] : o);
    n[r] = i;
  }
  return n;
}
rn.prototype.brand = O2, rn.prototype.h = function() {
  return !0;
}, rn.prototype.S = function(t) {
  const e = this.t;
  e !== t && t.e === void 0 && (t.x = e, this.t = t, e !== void 0 ? e.e = t : $p(() => {
    var n;
    (n = this.W) == null || n.call(this);
  }));
}, rn.prototype.U = function(t) {
  if (this.t !== void 0) {
    const e = t.e, n = t.x;
    e !== void 0 && (e.x = n, t.e = void 0), n !== void 0 && (n.e = e, t.x = void 0), t === this.t && (this.t = n, n === void 0 && $p(() => {
      var r;
      (r = this.Z) == null || r.call(this);
    }));
  }
}, rn.prototype.subscribe = function(t) {
  return Wr(() => {
    const e = this.value, n = He;
    He = void 0;
    try {
      t(e);
    } finally {
      He = n;
    }
  }, { name: "sub" });
}, rn.prototype.valueOf = function() {
  return this.value;
}, rn.prototype.toString = function() {
  return this.value + "";
}, rn.prototype.toJSON = function() {
  return this.value;
}, rn.prototype.peek = function() {
  const t = He;
  He = void 0;
  try {
    return this.value;
  } finally {
    He = t;
  }
}, Object.defineProperty(rn.prototype, "value", { get() {
  const t = Fp(this);
  return t !== void 0 && (t.i = this.i), this.v;
}, set(t) {
  if (t !== this.v) {
    if (lu > 100) throw new Error("Cycle detected");
    this.v = t, this.i++, $a++, Kr++;
    try {
      for (let e = this.t; e !== void 0; e = e.x) e.t.N();
    } finally {
      Al();
    }
  }
} }), vo.prototype = new rn(), vo.prototype.h = function() {
  if (this.f &= -3, 1 & this.f) return !1;
  if ((36 & this.f) == 32 || (this.f &= -5, this.g === $a)) return !0;
  if (this.g = $a, this.f |= 1, this.i > 0 && !Zw(this)) return this.f &= -2, !0;
  const t = He;
  try {
    Bp(this), He = this;
    const e = this.x();
    (16 & this.f || this.v !== e || this.i === 0) && (this.v = e, this.f &= -17, this.i++);
  } catch (e) {
    this.v = e, this.f |= 16, this.i++;
  }
  return He = t, eg(this), this.f &= -2, !0;
}, vo.prototype.S = function(t) {
  if (this.t === void 0) {
    this.f |= 36;
    for (let e = this.s; e !== void 0; e = e.n) e.S.S(e);
  }
  rn.prototype.S.call(this, t);
}, vo.prototype.U = function(t) {
  if (this.t !== void 0 && (rn.prototype.U.call(this, t), this.t === void 0)) {
    this.f &= -33;
    for (let e = this.s; e !== void 0; e = e.n) e.S.U(e);
  }
}, vo.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (let t = this.t; t !== void 0; t = t.x) t.t.N();
  }
}, Object.defineProperty(vo.prototype, "value", { get() {
  if (1 & this.f) throw new Error("Cycle detected");
  const t = Fp(this);
  if (this.h(), t !== void 0 && (t.i = this.i), 16 & this.f) throw this.v;
  return this.v;
} }), ri.prototype.c = function() {
  const t = this.S();
  try {
    if (8 & this.f || this.x === void 0) return;
    const e = this.x();
    typeof e == "function" && (this.u = e);
  } finally {
    t();
  }
}, ri.prototype.S = function() {
  if (1 & this.f) throw new Error("Cycle detected");
  this.f |= 1, this.f &= -9, tg(this), Bp(this), Kr++;
  const t = He;
  return He = this, L2.bind(this, t);
}, ri.prototype.N = function() {
  2 & this.f || (this.f |= 2, this.o = hs, hs = this);
}, ri.prototype.d = function() {
  this.f |= 8, 1 & this.f || yd(this);
}, ri.prototype.dispose = function() {
  this.d();
};
Or({ build: (t, e, n) => Sl(e), config: Vs({ defaultSelection: "rootEnd", disabled: !1 }), name: "@lexical/extension/AutoFocus", register(t, e, n) {
  const r = n.getOutput();
  return Wr(() => r.disabled.value ? void 0 : t.registerRootListener((o) => {
    t.focus(() => {
      const i = document.activeElement;
      o === null || i !== null && o.contains(i) || o.focus({ preventScroll: !0 });
    }, { defaultSelection: r.defaultSelection.peek() });
  }));
} });
function ng() {
  const t = tt(), e = ve(), n = js();
  t.clear(), t.append(n), e !== null && n.select(), me(e) && (e.format = 0);
}
function P2(t, e = ng) {
  return t.registerCommand(bl, (n) => (t.update(e), !0), Qe);
}
Or({ build: (t, e, n) => Sl(e), config: Vs({ $onClear: ng }), name: "@lexical/extension/ClearEditor", register(t, e, n) {
  const { $onClear: r } = n.getOutput();
  return Wr(() => P2(t, r.value));
} });
function $2(t) {
  return (typeof t.nodes == "function" ? t.nodes() : t.nodes) || [];
}
function rg(t, e) {
  let n;
  return _s(t(), { unwatched() {
    n && (n(), n = void 0);
  }, watched() {
    this.value = t(), n = e(this);
  } });
}
const cu = Or({ build: (t) => rg(() => t.getEditorState(), (e) => t.registerUpdateListener((n) => {
  e.value = n.editorState;
})), name: "@lexical/extension/EditorState" });
function Xe(t, ...e) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", t);
  for (const o of e) r.append("v", o);
  throw n.search = r.toString(), Error(`Minified Lexical error #${t}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function og(t, e) {
  if (t && e && !Array.isArray(e) && typeof t == "object" && typeof e == "object") {
    const n = t, r = e;
    for (const o in r) n[o] = og(n[o], r[o]);
    return t;
  }
  return e;
}
const xd = 0, uu = 1, ig = 2, xc = 3, va = 4, ti = 5, _c = 6, Qi = 7;
function Cc(t) {
  return t.id === xd;
}
function sg(t) {
  return t.id === ig;
}
function F2(t) {
  return function(e) {
    return e.id === uu;
  }(t) || Xe(305, String(t.id), String(uu)), Object.assign(t, { id: ig });
}
const B2 = /* @__PURE__ */ new Set();
let q2 = class {
  constructor(e, n) {
    nn(this, "builder");
    nn(this, "configs");
    nn(this, "_dependency");
    nn(this, "_peerNameSet");
    nn(this, "extension");
    nn(this, "state");
    nn(this, "_signal");
    this.builder = e, this.extension = n, this.configs = /* @__PURE__ */ new Set(), this.state = { id: xd };
  }
  mergeConfigs() {
    let e = this.extension.config || {};
    const n = this.extension.mergeConfig ? this.extension.mergeConfig.bind(this.extension) : Lv;
    for (const r of this.configs) e = n(e, r);
    return e;
  }
  init(e) {
    const n = this.state;
    sg(n) || Xe(306, String(n.id));
    const r = { getDependency: this.getInitDependency.bind(this), getDirectDependentNames: this.getDirectDependentNames.bind(this), getPeer: this.getInitPeer.bind(this), getPeerNameSet: this.getPeerNameSet.bind(this) }, o = { ...r, getDependency: this.getDependency.bind(this), getInitResult: this.getInitResult.bind(this), getPeer: this.getPeer.bind(this) }, i = function(a, l, c) {
      return Object.assign(a, { config: l, id: xc, registerState: c });
    }(n, this.mergeConfigs(), r);
    let s;
    this.state = i, this.extension.init && (s = this.extension.init(e, i.config, r)), this.state = function(a, l, c) {
      return Object.assign(a, { id: va, initResult: l, registerState: c });
    }(i, s, o);
  }
  build(e) {
    const n = this.state;
    let r;
    n.id !== va && Xe(307, String(n.id), String(ti)), this.extension.build && (r = this.extension.build(e, n.config, n.registerState));
    const o = { ...n.registerState, getOutput: () => r, getSignal: this.getSignal.bind(this) };
    this.state = function(i, s, a) {
      return Object.assign(i, { id: ti, output: s, registerState: a });
    }(n, r, o);
  }
  register(e, n) {
    this._signal = n;
    const r = this.state;
    r.id !== ti && Xe(308, String(r.id), String(ti));
    const o = this.extension.register && this.extension.register(e, r.config, r.registerState);
    return this.state = function(i) {
      return Object.assign(i, { id: _c });
    }(r), () => {
      const i = this.state;
      i.id !== Qi && Xe(309, String(r.id), String(Qi)), this.state = function(s) {
        return Object.assign(s, { id: ti });
      }(i), o && o();
    };
  }
  afterRegistration(e) {
    const n = this.state;
    let r;
    return n.id !== _c && Xe(310, String(n.id), String(_c)), this.extension.afterRegistration && (r = this.extension.afterRegistration(e, n.config, n.registerState)), this.state = function(o) {
      return Object.assign(o, { id: Qi });
    }(n), r;
  }
  getSignal() {
    return this._signal === void 0 && Xe(311), this._signal;
  }
  getInitResult() {
    this.extension.init === void 0 && Xe(312, this.extension.name);
    const e = this.state;
    return function(n) {
      return n.id >= va;
    }(e) || Xe(313, String(e.id), String(va)), e.initResult;
  }
  getInitPeer(e) {
    const n = this.builder.extensionNameMap.get(e);
    return n ? n.getExtensionInitDependency() : void 0;
  }
  getExtensionInitDependency() {
    const e = this.state;
    return function(n) {
      return n.id >= xc;
    }(e) || Xe(314, String(e.id), String(xc)), { config: e.config };
  }
  getPeer(e) {
    const n = this.builder.extensionNameMap.get(e);
    return n ? n.getExtensionDependency() : void 0;
  }
  getInitDependency(e) {
    const n = this.builder.getExtensionRep(e);
    return n === void 0 && Xe(315, this.extension.name, e.name), n.getExtensionInitDependency();
  }
  getDependency(e) {
    const n = this.builder.getExtensionRep(e);
    return n === void 0 && Xe(315, this.extension.name, e.name), n.getExtensionDependency();
  }
  getState() {
    const e = this.state;
    return function(n) {
      return n.id >= Qi;
    }(e) || Xe(316, String(e.id), String(Qi)), e;
  }
  getDirectDependentNames() {
    return this.builder.incomingEdges.get(this.extension.name) || B2;
  }
  getPeerNameSet() {
    let e = this._peerNameSet;
    return e || (e = new Set((this.extension.peerDependencies || []).map(([n]) => n)), this._peerNameSet = e), e;
  }
  getExtensionDependency() {
    if (!this._dependency) {
      const e = this.state;
      (function(n) {
        return n.id >= ti;
      })(e) || Xe(317, this.extension.name), this._dependency = { config: e.config, init: e.initResult, output: e.output };
    }
    return this._dependency;
  }
};
const qp = { tag: Uo };
function j2() {
  const t = tt();
  t.isEmpty() && t.append(js());
}
const U2 = Or({ config: Vs({ setOptions: qp, updateOptions: qp }), init: ({ $initialEditorState: t = j2 }) => ({ $initialEditorState: t, initialized: !1 }), afterRegistration(t, { updateOptions: e, setOptions: n }, r) {
  const o = r.getInitResult();
  if (!o.initialized) {
    o.initialized = !0;
    const { $initialEditorState: i } = o;
    if (Fv(i)) t.setEditorState(i, n);
    else if (typeof i == "function") t.update(() => {
      i(t);
    }, e);
    else if (i && (typeof i == "string" || typeof i == "object")) {
      const s = t.parseEditorState(i);
      t.setEditorState(s, n);
    }
  }
  return () => {
  };
}, name: "@lexical/extension/InitialState", nodes: [Pv, Hn, td, $v, Us] }), jp = Symbol.for("@lexical/extension/LexicalBuilder");
function Up() {
}
function V2(t) {
  throw t;
}
function ya(t) {
  return Array.isArray(t) ? t : [t];
}
const Ec = "0.38.2+prod.esm";
let H2 = class Fa {
  constructor(e) {
    nn(this, "roots");
    nn(this, "extensionNameMap");
    nn(this, "outgoingConfigEdges");
    nn(this, "incomingEdges");
    nn(this, "conflicts");
    nn(this, "_sortedExtensionReps");
    nn(this, "PACKAGE_VERSION");
    this.outgoingConfigEdges = /* @__PURE__ */ new Map(), this.incomingEdges = /* @__PURE__ */ new Map(), this.extensionNameMap = /* @__PURE__ */ new Map(), this.conflicts = /* @__PURE__ */ new Map(), this.PACKAGE_VERSION = Ec, this.roots = e;
    for (const n of e) this.addExtension(n);
  }
  static fromExtensions(e) {
    const n = [ya(U2)];
    for (const r of e) n.push(ya(r));
    return new Fa(n);
  }
  static maybeFromEditor(e) {
    const n = e[jp];
    return n && (n.PACKAGE_VERSION !== Ec && Xe(292, n.PACKAGE_VERSION, Ec), n instanceof Fa || Xe(293)), n;
  }
  static fromEditor(e) {
    const n = Fa.maybeFromEditor(e);
    return n === void 0 && Xe(294), n;
  }
  constructEditor() {
    const { $initialEditorState: e, onError: n, ...r } = this.buildCreateEditorArgs(), o = Object.assign(qs({ ...r, ...n ? { onError: (i) => {
      n(i, o);
    } } : {} }), { [jp]: this });
    for (const i of this.sortedExtensionReps()) i.build(o);
    return o;
  }
  buildEditor() {
    let e = Up;
    function n() {
      try {
        e();
      } finally {
        e = Up;
      }
    }
    const r = Object.assign(this.constructEditor(), { dispose: n, [Symbol.dispose]: n });
    return e = xs(this.registerEditor(r), () => r.setRootElement(null)), r;
  }
  hasExtensionByName(e) {
    return this.extensionNameMap.has(e);
  }
  getExtensionRep(e) {
    const n = this.extensionNameMap.get(e.name);
    if (n) return n.extension !== e && Xe(295, e.name), n;
  }
  addEdge(e, n, r) {
    const o = this.outgoingConfigEdges.get(e);
    o ? o.set(n, r) : this.outgoingConfigEdges.set(e, /* @__PURE__ */ new Map([[n, r]]));
    const i = this.incomingEdges.get(n);
    i ? i.add(e) : this.incomingEdges.set(n, /* @__PURE__ */ new Set([e]));
  }
  addExtension(e) {
    this._sortedExtensionReps !== void 0 && Xe(296);
    const n = ya(e), [r] = n;
    typeof r.name != "string" && Xe(297, typeof r.name);
    let o = this.extensionNameMap.get(r.name);
    if (o !== void 0 && o.extension !== r && Xe(298, r.name), !o) {
      o = new q2(this, r), this.extensionNameMap.set(r.name, o);
      const i = this.conflicts.get(r.name);
      typeof i == "string" && Xe(299, r.name, i);
      for (const s of r.conflictsWith || []) this.extensionNameMap.has(s) && Xe(299, r.name, s), this.conflicts.set(s, r.name);
      for (const s of r.dependencies || []) {
        const a = ya(s);
        this.addEdge(r.name, a[0].name, a.slice(1)), this.addExtension(a);
      }
      for (const [s, a] of r.peerDependencies || []) this.addEdge(r.name, s, a ? [a] : []);
    }
  }
  sortedExtensionReps() {
    if (this._sortedExtensionReps) return this._sortedExtensionReps;
    const e = [], n = (r, o) => {
      let i = r.state;
      if (sg(i)) return;
      const s = r.extension.name;
      var a;
      Cc(i) || Xe(300, s, o || "[unknown]"), Cc(a = i) || Xe(304, String(a.id), String(xd)), i = Object.assign(a, { id: uu }), r.state = i;
      const l = this.outgoingConfigEdges.get(s);
      if (l) for (const c of l.keys()) {
        const u = this.extensionNameMap.get(c);
        u && n(u, s);
      }
      i = F2(i), r.state = i, e.push(r);
    };
    for (const r of this.extensionNameMap.values()) Cc(r.state) && n(r);
    for (const r of e) for (const [o, i] of this.outgoingConfigEdges.get(r.extension.name) || []) if (i.length > 0) {
      const s = this.extensionNameMap.get(o);
      if (s) for (const a of i) s.configs.add(a);
    }
    for (const [r, ...o] of this.roots) if (o.length > 0) {
      const i = this.extensionNameMap.get(r.name);
      i === void 0 && Xe(301, r.name);
      for (const s of o) i.configs.add(s);
    }
    return this._sortedExtensionReps = e, this._sortedExtensionReps;
  }
  registerEditor(e) {
    const n = this.sortedExtensionReps(), r = new AbortController(), o = [() => r.abort()], i = r.signal;
    for (const s of n) {
      const a = s.register(e, i);
      a && o.push(a);
    }
    for (const s of n) {
      const a = s.afterRegistration(e);
      a && o.push(a);
    }
    return xs(...o);
  }
  buildCreateEditorArgs() {
    const e = {}, n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), i = {}, s = {}, a = this.sortedExtensionReps();
    for (const u of a) {
      const { extension: p } = u;
      if (p.onError !== void 0 && (e.onError = p.onError), p.disableEvents !== void 0 && (e.disableEvents = p.disableEvents), p.parentEditor !== void 0 && (e.parentEditor = p.parentEditor), p.editable !== void 0 && (e.editable = p.editable), p.namespace !== void 0 && (e.namespace = p.namespace), p.$initialEditorState !== void 0 && (e.$initialEditorState = p.$initialEditorState), p.nodes) for (const f of $2(p)) {
        if (typeof f != "function") {
          const h = r.get(f.replace);
          h && Xe(302, p.name, f.replace.name, h.extension.name), r.set(f.replace, u);
        }
        n.add(f);
      }
      if (p.html) {
        if (p.html.export) for (const [f, h] of p.html.export.entries()) o.set(f, h);
        p.html.import && Object.assign(i, p.html.import);
      }
      p.theme && og(s, p.theme);
    }
    Object.keys(s).length > 0 && (e.theme = s), n.size && (e.nodes = [...n]);
    const l = Object.keys(i).length > 0, c = o.size > 0;
    (l || c) && (e.html = {}, l && (e.html.import = i), c && (e.html.export = o));
    for (const u of a) u.init(e);
    return e.onError || (e.onError = V2), e;
  }
};
const z2 = /* @__PURE__ */ new Set(), Vp = Or({ build(t, e, n) {
  const r = n.getDependency(cu).output, o = _s({ watchedNodeKeys: /* @__PURE__ */ new Map() }), i = rg(() => {
  }, () => Wr(() => {
    const s = i.peek(), { watchedNodeKeys: a } = o.value;
    let l, c = !1;
    r.value.read(() => {
      if (ve()) for (const [u, p] of a.entries()) {
        if (p.size === 0) {
          a.delete(u);
          continue;
        }
        const f = it(u), h = f && f.isSelected() || !1;
        c = c || h !== (!!s && s.has(u)), h && (l = l || /* @__PURE__ */ new Set(), l.add(u));
      }
    }), !c && l && s && l.size === s.size || (i.value = l);
  }));
  return { watchNodeKey: function(s) {
    const a = I2(() => (i.value || z2).has(s)), { watchedNodeKeys: l } = o.peek();
    let c = l.get(s);
    const u = c !== void 0;
    return c = c || /* @__PURE__ */ new Set(), c.add(a), u || (l.set(s, c), o.value = { watchedNodeKeys: l }), a;
  } };
}, dependencies: [cu], name: "@lexical/extension/NodeSelection" });
Di("INSERT_HORIZONTAL_RULE_COMMAND");
let Wa = class ag extends Vo {
  static getType() {
    return "horizontalrule";
  }
  static clone(e) {
    return new ag(e.__key);
  }
  static importJSON(e) {
    return lg().updateFromJSON(e);
  }
  static importDOM() {
    return { hr: () => ({ conversion: G2, priority: 0 }) };
  }
  exportDOM() {
    return { element: document.createElement("hr") };
  }
  createDOM(e) {
    const n = document.createElement("hr");
    return Qw(n, e.theme.hr), n;
  }
  getTextContent() {
    return `
`;
  }
  isInline() {
    return !1;
  }
  updateDOM() {
    return !1;
  }
};
function G2() {
  return { node: lg() };
}
function lg() {
  return Uv(Wa);
}
function K2(t) {
  return t instanceof Wa;
}
Or({ dependencies: [cu, Vp], name: "@lexical/extension/HorizontalRule", nodes: [Wa], register(t, e, n) {
  const { watchNodeKey: r } = n.getDependency(Vp).output, o = _s({ nodeSelections: /* @__PURE__ */ new Map() }), i = t._config.theme.hrSelected ?? "selected";
  return xs(t.registerCommand(Bv, (s) => {
    if (ww(s.target)) {
      const a = qv(s.target);
      if (K2(a)) return function(l, c = !1) {
        const u = ve(), p = l.isSelected(), f = l.getKey();
        let h;
        c && eu(u) ? h = u : (h = jv(), ml(h)), p ? h.delete(f) : h.add(f);
      }(a, s.shiftKey), !0;
    }
    return !1;
  }, to), t.registerMutationListener(Wa, (s, a) => {
    R2(() => {
      let l = !1;
      const { nodeSelections: c } = o.peek();
      for (const [u, p] of s.entries()) if (p === "destroyed") c.delete(u), l = !0;
      else {
        const f = c.get(u), h = t.getElementByKey(u);
        f ? f.domNode.value = h : (l = !0, c.set(u, { domNode: _s(h), selectedSignal: r(u) }));
      }
      l && (o.value = { nodeSelections: c });
    });
  }), Wr(() => {
    const s = [];
    for (const { domNode: a, selectedSignal: l } of o.value.nodeSelections.values()) s.push(Wr(() => {
      const c = a.value;
      c && (l.value ? Qw(c, i) : D2(c, i));
    }));
    return xs(...s);
  }));
} });
function W2(t, e) {
  return xs(t.registerCommand(gw, (n) => {
    const r = ve();
    if (!me(r)) return !1;
    n.preventDefault();
    const o = function(i) {
      const s = i.getNodes();
      if (M2(s, (f) => Gv(f) && f.canIndent() ? f : null).length > 0) return !0;
      const a = i.anchor, l = i.focus, c = l.isBefore(a) ? l : a, u = c.getNode(), p = Pp(u);
      if (p.canIndent()) {
        const f = p.getKey();
        let h = vl();
        if (h.anchor.set(f, 0, "element"), h.focus.set(f, 0, "element"), h = Vv(h), h.anchor.is(c)) return !0;
      }
      return !1;
    }(r) ? n.shiftKey ? Hv : Ap : zv;
    return t.dispatchCommand(o, void 0);
  }, Qe), t.registerCommand(Ap, () => {
    const n = typeof e == "number" ? e : e ? e.peek() : null;
    if (n == null) return !1;
    const r = ve();
    if (!me(r)) return !1;
    const o = r.getNodes().map((i) => Pp(i).getIndent());
    return Math.max(...o) + 1 >= n;
  }, Gr));
}
Or({ build: (t, e, n) => Sl(e), config: Vs({ disabled: !1, maxIndent: null }), name: "@lexical/extension/TabIndentation", register(t, e, n) {
  const { disabled: r, maxIndent: o } = n.getOutput();
  return Wr(() => {
    if (!r.value) return W2(t, o);
  });
} });
const J2 = Or({ name: "@lexical/react/ReactProvider" });
function X2() {
  return tt().getTextContent();
}
function Y2(t, e = !0) {
  if (t) return !1;
  let n = X2();
  return e && (n = n.trim()), n === "";
}
function Q2(t) {
  if (!Y2(t, !1)) return !1;
  const e = tt().getChildren(), n = e.length;
  if (n > 1) return !1;
  for (let r = 0; r < n; r++) {
    const o = e[r];
    if (nd(o)) return !1;
    if (Ae(o)) {
      if (!rd(o) || o.__indent !== 0) return !1;
      const i = o.getChildren(), s = i.length;
      for (let a = 0; a < s; a++) {
        const l = i[r];
        if (!xe(l)) return !1;
      }
    }
  }
  return !0;
}
function cg(t) {
  return () => Q2(t);
}
const ug = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, Z2 = ug && "documentMode" in document ? document.documentMode : null;
!(!ug || !("InputEvent" in window) || Z2) && "getTargetRanges" in new window.InputEvent("input");
function _d(...t) {
  return () => {
    for (let e = t.length - 1; e >= 0; e--) t[e]();
    t.length = 0;
  };
}
function dg(t) {
  const e = window.location.origin, n = (r) => {
    if (r.origin !== e) return;
    const o = t.getRootElement();
    if (document.activeElement !== o) return;
    const i = r.data;
    if (typeof i == "string") {
      let s;
      try {
        s = JSON.parse(i);
      } catch {
        return;
      }
      if (s && s.protocol === "nuanria_messaging" && s.type === "request") {
        const a = s.payload;
        if (a && a.functionId === "makeChanges") {
          const l = a.args;
          if (l) {
            const [c, u, p, f, h] = l;
            t.update(() => {
              const g = ve();
              if (me(g)) {
                const b = g.anchor;
                let _ = b.getNode(), x = 0, y = 0;
                if (xe(_) && c >= 0 && u >= 0 && (x = c, y = c + u, g.setTextNodeRange(_, x, _, y)), x === y && p === "" || (g.insertRawText(p), _ = b.getNode()), xe(_)) {
                  x = f, y = f + h;
                  const A = _.getTextContentSize();
                  x = x > A ? A : x, y = y > A ? A : y, g.setTextNodeRange(_, x, _, y);
                }
                r.stopImmediatePropagation();
              }
            });
          }
        }
      }
    }
  };
  return window.addEventListener("message", n, !0), () => {
    window.removeEventListener("message", n, !0);
  };
}
Or({ build: (t, e, n) => Sl(e), config: Vs({ disabled: typeof window > "u" }), name: "@lexical/dragon", register: (t, e, n) => Wr(() => n.getOutput().disabled.value ? void 0 : dg(t)) });
function ex(t, ...e) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", t);
  for (const o of e) r.append("v", o);
  throw n.search = r.toString(), Error(`Minified Lexical error #${t}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
const Cd = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? xt : ie;
function tx({ editor: t, ErrorBoundary: e }) {
  return function(n, r) {
    const [o, i] = oe(() => n.getDecorators());
    return Cd(() => n.registerDecoratorListener((s) => {
      ad(() => {
        i(s);
      });
    }), [n]), ie(() => {
      i(n.getDecorators());
    }, [n]), ue(() => {
      const s = [], a = Object.keys(o);
      for (let l = 0; l < a.length; l++) {
        const c = a[l], u = d(r, { onError: (f) => n._onError(f), children: d(Yu, { fallback: null, children: o[c] }) }), p = n.getElementByKey(c);
        p !== null && s.push(ur(u, p, c));
      }
      return s;
    }, [r, o, n]);
  }(t, e);
}
function nx({ editor: t, ErrorBoundary: e }) {
  return function(n) {
    const r = H2.maybeFromEditor(n);
    if (r && r.hasExtensionByName(J2.name)) {
      for (const o of ["@lexical/plain-text", "@lexical/rich-text"]) r.hasExtensionByName(o) && ex(320, o);
      return !0;
    }
    return !1;
  }(t) ? null : d(tx, { editor: t, ErrorBoundary: e });
}
function Hp(t) {
  return t.getEditorState().read(cg(t.isComposing()));
}
function rx({ contentEditable: t, placeholder: e = null, ErrorBoundary: n }) {
  const [r] = oo();
  return function(o) {
    Cd(() => _d(Tw(o), dg(o)), [o]);
  }(r), M(ft, { children: [t, d(ox, { content: e }), d(nx, { editor: r, ErrorBoundary: n })] });
}
function ox({ content: t }) {
  const [e] = oo(), n = function(o) {
    const [i, s] = oe(() => Hp(o));
    return Cd(() => {
      function a() {
        const l = Hp(o);
        s(l);
      }
      return a(), _d(o.registerUpdateListener(() => {
        a();
      }), o.registerEditableListener(() => {
        a();
      }));
    }, [o]), i;
  }(e), r = T2();
  return n ? typeof t == "function" ? t(r) : t : null;
}
function ix({ defaultSelection: t }) {
  const [e] = oo();
  return ie(() => {
    e.focus(() => {
      const n = document.activeElement, r = e.getRootElement();
      r === null || n !== null && r.contains(n) || r.focus({ preventScroll: !0 });
    }, { defaultSelection: t });
  }, [t, e]), null;
}
const pg = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? xt : ie;
function sx({ editor: t, ariaActiveDescendant: e, ariaAutoComplete: n, ariaControls: r, ariaDescribedBy: o, ariaErrorMessage: i, ariaExpanded: s, ariaInvalid: a, ariaLabel: l, ariaLabelledBy: c, ariaMultiline: u, ariaOwns: p, ariaRequired: f, autoCapitalize: h, className: g, id: b, role: _ = "textbox", spellCheck: x = !0, style: y, tabIndex: A, "data-testid": P, ...V }, O) {
  const [U, B] = oe(t.isEditable()), F = ce((E) => {
    E && E.ownerDocument && E.ownerDocument.defaultView ? t.setRootElement(E) : t.setRootElement(null);
  }, [t]), K = ue(() => /* @__PURE__ */ function(...E) {
    return (S) => {
      for (const k of E) typeof k == "function" ? k(S) : k != null && (k.current = S);
    };
  }(O, F), [F, O]);
  return pg(() => (B(t.isEditable()), t.registerEditableListener((E) => {
    B(E);
  })), [t]), d("div", { "aria-activedescendant": U ? e : void 0, "aria-autocomplete": U ? n : "none", "aria-controls": U ? r : void 0, "aria-describedby": o, ...i != null ? { "aria-errormessage": i } : {}, "aria-expanded": U && _ === "combobox" ? !!s : void 0, ...a != null ? { "aria-invalid": a } : {}, "aria-label": l, "aria-labelledby": c, "aria-multiline": u, "aria-owns": U ? p : void 0, "aria-readonly": !U || void 0, "aria-required": f, autoCapitalize: h, className: g, contentEditable: U, "data-testid": P, id: b, ref: K, role: _, spellCheck: x, style: y, tabIndex: A, ...V });
}
const ax = an(sx);
function zp(t) {
  return t.getEditorState().read(cg(t.isComposing()));
}
const lx = an(cx);
function cx(t, e) {
  const { placeholder: n, ...r } = t, [o] = oo();
  return M(ft, { children: [d(ax, { editor: o, ...r, ref: e }), n != null && d(ux, { editor: o, content: n })] });
}
function ux({ content: t, editor: e }) {
  const n = function(s) {
    const [a, l] = oe(() => zp(s));
    return pg(() => {
      function c() {
        const u = zp(s);
        l(u);
      }
      return c(), _d(s.registerUpdateListener(() => {
        c();
      }), s.registerEditableListener(() => {
        c();
      }));
    }, [s]), a;
  }(e), [r, o] = oe(e.isEditable());
  if (xt(() => (o(e.isEditable()), e.registerEditableListener((s) => {
    o(s);
  })), [e]), !n) return null;
  let i = null;
  return typeof t == "function" ? i = t(r) : t !== null && (i = t), i === null ? null : d("div", { "aria-hidden": !0, children: i });
}
function dx({
  placeholder: t,
  className: e,
  placeholderClassName: n
}) {
  return /* @__PURE__ */ d(
    lx,
    {
      className: e ?? "ContentEditable__root tw-relative tw-block tw-min-h-11 tw-overflow-auto tw-px-3 tw-py-3 tw-text-sm tw-outline-none",
      "aria-placeholder": t,
      placeholder: /* @__PURE__ */ d(
        "div",
        {
          className: n ?? "tw-pointer-events-none tw-absolute tw-left-0 tw-top-0 tw-select-none tw-overflow-hidden tw-text-ellipsis tw-px-3 tw-py-3 tw-text-sm tw-text-muted-foreground",
          children: t
        }
      )
    }
  );
}
function px() {
  throw new Error("ToolbarContext not initialized");
}
const fg = Zr({
  activeEditor: px(),
  $updateToolbar: () => {
  },
  blockType: "paragraph",
  setBlockType: () => {
  },
  showModal: () => {
  }
});
function fx({
  activeEditor: t,
  $updateToolbar: e,
  blockType: n,
  setBlockType: r,
  showModal: o,
  children: i
}) {
  const s = ue(
    () => ({
      activeEditor: t,
      $updateToolbar: e,
      blockType: n,
      setBlockType: r,
      showModal: o
    }),
    [t, e, n, r, o]
  );
  return /* @__PURE__ */ d(fg.Provider, { value: s, children: i });
}
function hg() {
  return jo(fg);
}
function hx() {
  const [t, e] = oe(void 0), n = ce(() => {
    e(void 0);
  }, []), r = ue(() => {
    if (t === void 0)
      return;
    const { title: i, content: s } = t;
    return /* @__PURE__ */ d($y, { open: !0, onOpenChange: n, children: /* @__PURE__ */ M(Iw, { children: [
      /* @__PURE__ */ d(Lw, { children: /* @__PURE__ */ d(Pw, { children: i }) }),
      s
    ] }) });
  }, [t, n]), o = ce(
    (i, s, a = !1) => {
      e({
        closeOnClickOutside: a,
        content: s(n),
        title: i
      });
    },
    [n]
  );
  return [r, o];
}
function wx({
  children: t
}) {
  const [e] = oo(), [n, r] = oe(e), [o, i] = oe("paragraph"), [s, a] = hx(), l = () => {
  };
  return ie(() => n.registerCommand(
    no,
    (c, u) => (r(u), !1),
    Gr
  ), [n]), /* @__PURE__ */ M(
    fx,
    {
      activeEditor: n,
      $updateToolbar: l,
      blockType: o,
      setBlockType: i,
      showModal: a,
      children: [
        s,
        t({ blockType: o })
      ]
    }
  );
}
function gx(t) {
  const [e] = oo(), { activeEditor: n } = hg();
  ie(() => n.registerCommand(
    no,
    () => {
      const r = ve();
      return r && t(r), !1;
    },
    Gr
  ), [e, t]), ie(() => {
    n.getEditorState().read(() => {
      const r = ve();
      r && t(r);
    });
  }, [n, t]);
}
const wg = eo(
  "pr-twp tw-inline-flex tw-items-center tw-justify-center tw-rounded-md tw-text-sm tw-font-medium tw-ring-offset-background tw-transition-colors hover:tw-bg-muted hover:tw-text-muted-foreground focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-pointer-events-none disabled:tw-opacity-50 data-[state=on]:tw-bg-accent data-[state=on]:tw-text-accent-foreground",
  {
    variants: {
      variant: {
        default: "tw-bg-transparent",
        outline: "tw-border tw-border-input tw-bg-transparent hover:tw-bg-accent hover:tw-text-accent-foreground"
      },
      size: {
        default: "tw-h-10 tw-px-3",
        sm: "tw-h-9 tw-px-2.5",
        lg: "tw-h-11 tw-px-5"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), mx = X.forwardRef(({ className: t, variant: e, size: n, ...r }, o) => /* @__PURE__ */ d(
  Sw.Root,
  {
    ref: o,
    className: z(wg({ variant: e, size: n, className: t })),
    ...r
  }
));
mx.displayName = Sw.Root.displayName;
const gg = X.createContext({
  size: "default",
  variant: "default"
}), Ed = X.forwardRef(({ className: t, variant: e, size: n, children: r, ...o }, i) => {
  const s = Bt();
  return /* @__PURE__ */ d(
    El.Root,
    {
      ref: i,
      className: z("pr-twp tw-flex tw-items-center tw-justify-center tw-gap-1", t),
      ...o,
      dir: s,
      children: /* @__PURE__ */ d(
        gg.Provider,
        {
          value: { variant: e, size: n },
          children: r
        }
      )
    }
  );
});
Ed.displayName = El.Root.displayName;
const ws = X.forwardRef(({ className: t, children: e, variant: n, size: r, ...o }, i) => {
  const s = X.useContext(gg);
  return /* @__PURE__ */ d(
    El.Item,
    {
      ref: i,
      className: z(
        wg({
          variant: s.variant || n,
          size: s.size || r
        }),
        t
      ),
      ...o,
      children: e
    }
  );
});
ws.displayName = El.Item.displayName;
const Gp = [
  { format: "bold", icon: J0, label: "Bold" },
  { format: "italic", icon: X0, label: "Italic" },
  { format: "underline", icon: Y0, label: "Underline" },
  { format: "strikethrough", icon: Q0, label: "Strikethrough" }
];
function bx() {
  const { activeEditor: t } = hg(), [e, n] = oe([]), r = ce((o) => {
    if (me(o) || Aw(o)) {
      const i = [];
      Gp.forEach(({ format: s }) => {
        o.hasFormat(s) && i.push(s);
      }), n((s) => s.length !== i.length || !i.every((a) => s.includes(a)) ? i : s);
    }
  }, []);
  return gx(r), /* @__PURE__ */ d(
    Ed,
    {
      type: "multiple",
      value: e,
      onValueChange: n,
      variant: "outline",
      size: "sm",
      children: Gp.map(({ format: o, icon: i, label: s }) => /* @__PURE__ */ d(
        ws,
        {
          value: o,
          "aria-label": s,
          onClick: () => {
            t.dispatchCommand(Kv, o);
          },
          children: /* @__PURE__ */ d(i, { className: "tw-h-4 tw-w-4" })
        },
        o
      ))
    }
  );
}
function vx({
  placeholder: t = "Start typing ...",
  autoFocus: e = !1
}) {
  const [, n] = oe(void 0);
  return /* @__PURE__ */ M("div", { className: "tw-relative", children: [
    /* @__PURE__ */ d(wx, { children: () => /* @__PURE__ */ d("div", { className: "tw-sticky tw-top-0 tw-z-10 tw-flex tw-gap-2 tw-overflow-auto tw-border-b tw-p-1", children: /* @__PURE__ */ d(bx, {}) }) }),
    /* @__PURE__ */ M("div", { className: "tw-relative", children: [
      /* @__PURE__ */ d(
        rx,
        {
          contentEditable: /* @__PURE__ */ d("div", { ref: (o) => {
            o !== void 0 && n(o);
          }, children: /* @__PURE__ */ d(dx, { placeholder: t }) }),
          ErrorBoundary: E2
        }
      ),
      e && /* @__PURE__ */ d(ix, { defaultSelection: "rootStart" })
    ] })
  ] });
}
const yx = {
  namespace: "Editor",
  theme: gd,
  nodes: vd,
  onError: (t) => {
    console.error(t);
  }
};
function Kp({
  editorState: t,
  editorSerializedState: e,
  onChange: n,
  onSerializedChange: r,
  placeholder: o = "Start typing ...",
  autoFocus: i = !1
}) {
  return /* @__PURE__ */ d("div", { className: "pr-twp tw-overflow-hidden tw-rounded-lg tw-border tw-bg-background tw-shadow", children: /* @__PURE__ */ d(
    b2,
    {
      initialConfig: {
        ...yx,
        ...t ? { editorState: t } : {},
        ...e ? { editorState: JSON.stringify(e) } : {}
      },
      children: /* @__PURE__ */ M(Nl, { children: [
        /* @__PURE__ */ d(vx, { placeholder: o, autoFocus: i }),
        /* @__PURE__ */ d(
          y2,
          {
            ignoreSelectionChange: !0,
            onChange: (s) => {
              n == null || n(s), r == null || r(s.toJSON());
            }
          }
        )
      ] })
    }
  ) });
}
function xx(t, e, n = "self") {
  const r = t.getStartEndPoints();
  if (e.isSelected(t) && !mw(e) && r !== null) {
    const [o, i] = r, s = t.isBackward(), a = o.getNode(), l = i.getNode(), c = e.is(a), u = e.is(l);
    if (c || u) {
      const [p, f] = bw(t), h = a.is(l), g = e.is(s ? l : a), b = e.is(s ? a : l);
      let _, x = 0;
      h ? (x = p > f ? f : p, _ = p > f ? p : f) : g ? (x = s ? f : p, _ = void 0) : b && (x = 0, _ = s ? p : f);
      const y = e.__text.slice(x, _);
      y !== e.__text && (n === "clone" && (e = Wv(e)), e.__text = y);
    }
  }
  return e;
}
function _x(t, e) {
  if (typeof document > "u" || typeof window > "u" && global.window === void 0) throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  const n = document.createElement("div"), r = tt().getChildren();
  for (let o = 0; o < r.length; o++)
    mg(t, r[o], n, e);
  return n.innerHTML;
}
function mg(t, e, n, r = null) {
  let o = r === null || e.isSelected(r);
  const i = Ae(e) && e.excludeFromCopy("html");
  let s = e;
  r !== null && xe(e) && (s = xx(r, e, "clone"));
  const a = Ae(s) ? s.getChildren() : [], l = vw(t, s.getType());
  let c;
  c = l && l.exportDOM !== void 0 ? l.exportDOM(t, s) : s.exportDOM(t);
  const { element: u, after: p } = c;
  if (!u) return !1;
  const f = document.createDocumentFragment();
  for (let h = 0; h < a.length; h++) {
    const g = a[h], b = mg(t, g, f, r);
    !o && Ae(e) && b && e.extractWithChild(g, r, "html") && (o = !0);
  }
  if (o && !i) {
    if ((vr(u) || Ga(u)) && u.append(f), n.append(u), p) {
      const h = p.call(s, u);
      h && (Ga(u) ? u.replaceChildren(h) : u.replaceWith(h));
    }
  } else n.append(f);
  return o;
}
function xa(t) {
  if (!t) return !1;
  const e = qs({
    namespace: "EditorUtils",
    theme: gd,
    nodes: vd,
    onError: (o) => {
      console.error(o);
    }
  }), n = e.parseEditorState(JSON.stringify(t));
  e.setEditorState(n);
  let r = !1;
  return e.getEditorState().read(() => {
    r = tt().getTextContent().trim().length > 0;
  }), r;
}
function Cx(t) {
  const e = qs({
    namespace: "EditorUtils",
    theme: gd,
    nodes: vd,
    onError: (o) => {
      console.error(o);
    }
  }), n = e.parseEditorState(JSON.stringify(t));
  e.setEditorState(n);
  let r = "";
  return e.getEditorState().read(() => {
    r = _x(e);
  }), r = r.replace(/\s+class="[^"]*"/g, "").replace(/\s+style="[^"]*"/g, "").replace(/<span>(.*?)<\/span>/g, "$1").replace(/<b><strong>(.*?)<\/strong><\/b>/g, "<b>$1</b>").replace(/<i><em>(.*?)<\/em><\/i>/g, "<i>$1</i>").replace(/<u><span>(.*?)<\/span><\/u>/g, "<u>$1</u>").replace(/<s><span>(.*?)<\/span><\/s>/g, "<s>$1</s>"), r;
}
function Ex(t) {
  return t.replace(/<strikethrough>([\s\S]*?)<\/strikethrough>/gi, "<s>$1</s>").replace(
    /<color[^>]*name="([^"]+)"[^>]*>([\s\S]*?)<\/color>/gi,
    (e, n, r) => `<span style="color: ${{
      red: "#ef4444",
      green: "#22c55e",
      blue: "#3b82f6"
    }[n.toLowerCase()] || n}">${r}</span>`
  ).replace(/<language[^>]*>([\s\S]*?)<\/language>/gi, "$1");
}
function kx(t) {
  const e = t.replace(/[#*_~`[\]()]/g, "").replace(/<[^>]*>/g, "").trim(), n = 150;
  if (e.length <= n)
    return t;
  let r = n;
  return [". ", "! ", "? ", `
`, " "].find((s) => {
    const a = e.lastIndexOf(s, n);
    return a > n * 0.7 ? (r = a + s.length, !0) : !1;
  }) || (r = n), `${t.slice(0, r).trim()}...`;
}
function Nx({
  id: t,
  markdown: e,
  className: n,
  anchorTarget: r,
  truncate: o
}) {
  const i = ue(() => Ex(e), [e]), s = ue(
    () => o ? kx(i) : i,
    [i, o]
  ), a = ue(
    () => ({
      overrides: {
        a: {
          props: {
            target: r
          }
        }
      }
    }),
    [r]
  );
  return /* @__PURE__ */ d("div", { id: t, className: z("pr-twp", n), children: /* @__PURE__ */ d(Ty, { options: a, children: s }) });
}
const bg = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  Mi.Root,
  {
    ref: n,
    className: z(
      "pr-twp tw-relative tw-flex tw-h-10 tw-w-10 tw-shrink-0 tw-overflow-hidden tw-rounded-full",
      t
    ),
    ...e
  }
));
bg.displayName = Mi.Root.displayName;
const Tx = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  Mi.Image,
  {
    ref: n,
    className: z("pr-twp tw-aspect-square tw-h-full tw-w-full", t),
    ...e
  }
));
Tx.displayName = Mi.Image.displayName;
const vg = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  Mi.Fallback,
  {
    ref: n,
    className: z(
      "pr-twp tw-flex tw-h-full tw-w-full tw-items-center tw-justify-center tw-rounded-full tw-bg-muted",
      t
    ),
    ...e
  }
));
vg.displayName = Mi.Fallback.displayName;
function Wp({
  comment: t,
  isReply: e = !1,
  localizedStrings: n,
  isThreadExpanded: r = !1,
  handleClickCommentText: o,
  handleMouseDownCommentText: i
}) {
  const s = ue(() => {
    const c = new Date(t.date), u = Sv(
      c,
      n["%comment_date_today%"],
      n["%comment_date_yesterday%"]
    ), p = c.toLocaleTimeString(void 0, {
      hour: "numeric",
      minute: "2-digit"
    });
    return `${u} at ${p}`;
  }, [t.date, n]), a = ue(
    () => !e && t.assignedUser ? ps(n["%comment_assigned_to%"], {
      assignedUser: t.assignedUser
    }) : t.user,
    [e, t.assignedUser, t.user, n]
  ), l = ue(
    () => t.user.split(" ").map((c) => c[0]).join("").toUpperCase().slice(0, 2),
    [t.user]
  );
  return /* @__PURE__ */ d("div", { className: z("tw-space-y-3", e && "tw-text-sm"), children: /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-row tw-gap-3", children: [
    /* @__PURE__ */ d(bg, { className: z("tw-h-8 tw-w-8"), children: /* @__PURE__ */ d(vg, { className: "tw-text-xs tw-font-medium", children: l }) }),
    /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-1 tw-flex-col tw-gap-2", children: [
      /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-row tw-flex-wrap tw-items-baseline tw-gap-x-2", children: [
        /* @__PURE__ */ d(
          "p",
          {
            className: "tw-text-sm tw-font-medium",
            onClick: o,
            onMouseDown: i,
            children: a
          }
        ),
        /* @__PURE__ */ d(
          "p",
          {
            className: "tw-text-xs tw-font-normal tw-text-muted-foreground",
            onClick: o,
            onMouseDown: i,
            children: s
          }
        )
      ] }),
      /* @__PURE__ */ d(
        "div",
        {
          className: "tw-flex tw-flex-row tw-items-start tw-gap-2 tw-break-words tw-text-sm tw-font-normal tw-text-foreground",
          onClick: o,
          onMouseDown: i,
          children: /* @__PURE__ */ d(
            Nx,
            {
              className: "tw-text-sm tw-font-normal tw-text-primary",
              markdown: t.contents,
              truncate: !r
            }
          )
        }
      )
    ] })
  ] }) });
}
const Jp = {
  root: {
    children: [
      {
        children: [
          {
            detail: 0,
            format: 0,
            mode: "normal",
            style: "",
            text: "",
            type: "text",
            version: 1
          }
        ],
        direction: "ltr",
        format: "",
        indent: 0,
        type: "paragraph",
        version: 1
      }
    ],
    direction: "ltr",
    format: "",
    indent: 0,
    type: "root",
    version: 1
  }
};
function Ax({
  comments: t,
  localizedStrings: e,
  isSelected: n = !1,
  verseRef: r,
  assignedUser: o,
  handleSelectThread: i,
  threadId: s,
  threadStatus: a,
  handleResolveCommentThread: l,
  handleAddComment: c
}) {
  const [u, p] = oe(Jp), [f, h] = oe(!1), [g, b] = oe(!1), [_, x] = oe(!1), [y, A] = oe(0), P = ue(() => t[0], [t]), V = he(null);
  ie(() => {
    const L = V.current;
    if (!L) return;
    const J = () => {
      b(L.scrollWidth > L.clientWidth);
    };
    return J(), window.addEventListener("resize", J), () => window.removeEventListener("resize", J);
  }, [P.verse]), ie(() => {
    x(!1);
  }, [n]);
  const O = ue(
    () => ({
      singleReply: e["%comment_thread_single_reply%"],
      multipleReplies: e["%comment_thread_multiple_replies%"]
    }),
    [e]
  ), U = ue(
    () => o ? ps(e["%comment_assigned_to%"], { assignedUser: o }) : void 0,
    [o, e]
  ), B = ue(() => t.slice(1), [t]), F = ue(() => B.length ?? 0, [B.length]), K = ue(() => F > 0, [F]), E = ue(() => !n || _ || F <= 2 ? B : B.slice(-2), [B, F, n, _]), S = ue(() => !n || _ || F <= 2 ? 0 : F - 2, [F, n, _]), k = ue(
    () => F === 1 ? O.singleReply : ps(O.multipleReplies, { count: F }),
    [F, O.singleReply, O.multipleReplies]
  ), I = ue(
    () => S === 1 ? O.singleReply : ps(O.multipleReplies, { count: S }),
    [S, O.singleReply, O.multipleReplies]
  ), N = ce(
    (L) => {
      if (n) {
        const J = window.getSelection();
        J && J.toString().length > 0 && L.stopPropagation();
      }
    },
    [n]
  ), T = ce(
    (L) => {
      n && L.stopPropagation();
    },
    [n]
  ), $ = ce(() => {
    c(s, Cx(u)) && (p(Jp), A((J) => J + 1));
  }, [u, c, s]);
  return /* @__PURE__ */ d(
    wd,
    {
      role: "option",
      "aria-selected": n,
      id: s,
      className: z(
        "tw-w-full tw-rounded-none tw-border-none tw-p-4 tw-outline-none tw-transition-all tw-duration-200 focus:tw-ring-2 focus:tw-ring-ring focus:tw-ring-offset-1 focus:tw-ring-offset-background",
        {
          "tw-cursor-pointer tw-bg-slate-50 hover:tw-shadow-md": !n
        },
        { "tw-bg-background": n }
      ),
      onClick: () => {
        i(s);
      },
      tabIndex: -1,
      children: /* @__PURE__ */ M(Kw, { className: "tw-flex tw-flex-col tw-gap-2 tw-p-0", children: [
        /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-col tw-content-center tw-items-start tw-gap-4", children: [
          U && /* @__PURE__ */ d(
            ys,
            {
              onClick: N,
              onMouseDown: T,
              className: "tw-rounded-sm tw-bg-input tw-text-sm tw-font-normal tw-text-primary hover:tw-bg-input",
              children: U
            }
          ),
          /* @__PURE__ */ M("div", { className: "tw-flex tw-max-w-full tw-flex-wrap tw-items-baseline tw-gap-2", children: [
            /* @__PURE__ */ M(
              "p",
              {
                ref: V,
                className: z(
                  "tw-flex-1 tw-overflow-hidden tw-text-ellipsis tw-text-sm tw-font-normal tw-text-muted-foreground",
                  {
                    "tw-overflow-visible tw-text-clip tw-whitespace-normal tw-break-words": f
                  },
                  { "tw-whitespace-nowrap": !f }
                ),
                onClick: N,
                onMouseDown: T,
                children: [
                  r,
                  " ",
                  P.verse
                ]
              }
            ),
            g && /* @__PURE__ */ d(
              Ne,
              {
                variant: "ghost",
                size: "icon",
                onClick: (L) => {
                  L.stopPropagation(), h(!f);
                },
                className: "tw-text-muted-foreground tw-transition hover:tw-text-foreground",
                "aria-label": f ? "Collapse text" : "Expand text",
                children: f ? /* @__PURE__ */ d(Yc, {}) : /* @__PURE__ */ d(fi, {})
              }
            )
          ] }),
          /* @__PURE__ */ M("div", { className: "tw-flex tw-w-full tw-flex-row tw-items-baseline tw-gap-3", children: [
            /* @__PURE__ */ d("div", { className: "tw-flex-1", children: /* @__PURE__ */ d(
              Wp,
              {
                comment: P,
                localizedStrings: e,
                isThreadExpanded: n,
                handleClickCommentText: N,
                handleMouseDownCommentText: T
              }
            ) }),
            n && a !== "Resolved" && /* @__PURE__ */ d(
              Ne,
              {
                variant: "ghost",
                size: "icon",
                className: "tw-shrink-0",
                onClick: (L) => {
                  L.stopPropagation(), l(s);
                },
                children: /* @__PURE__ */ d(br, {})
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ M(ft, { children: [
          K && !n && /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center tw-gap-5", children: [
            /* @__PURE__ */ d("div", { className: "tw-w-8", children: /* @__PURE__ */ d(vs, {}) }),
            /* @__PURE__ */ d("p", { className: "tw-text-sm tw-text-muted-foreground", children: k })
          ] }),
          !n && xa(u) && /* @__PURE__ */ d(
            Kp,
            {
              editorSerializedState: u,
              onSerializedChange: (L) => p(L),
              placeholder: e["%comment_replyOrAssign%"]
            }
          ),
          n && /* @__PURE__ */ M(ft, { children: [
            S > 0 && /* @__PURE__ */ M(
              "div",
              {
                className: "tw-flex tw-cursor-pointer tw-items-center tw-gap-5 tw-py-2",
                onClick: (L) => {
                  L.stopPropagation(), x(!0);
                },
                role: "button",
                tabIndex: 0,
                onKeyDown: (L) => {
                  (L.key === "Enter" || L.key === " ") && (L.preventDefault(), L.stopPropagation(), x(!0));
                },
                children: [
                  /* @__PURE__ */ d("div", { className: "tw-w-8", children: /* @__PURE__ */ d(vs, {}) }),
                  /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center tw-gap-2", children: [
                    /* @__PURE__ */ d("p", { className: "tw-text-sm tw-text-muted-foreground", children: I }),
                    _ ? /* @__PURE__ */ d(Yc, {}) : /* @__PURE__ */ d(fi, {})
                  ] })
                ]
              }
            ),
            E.map((L) => /* @__PURE__ */ d("div", { children: /* @__PURE__ */ d(
              Wp,
              {
                comment: L,
                localizedStrings: e,
                isReply: !0,
                isThreadExpanded: n,
                handleClickCommentText: N,
                handleMouseDownCommentText: T
              }
            ) }, L.id)),
            /* @__PURE__ */ M(
              "div",
              {
                role: "textbox",
                tabIndex: -1,
                className: "tw-w-full tw-space-y-2",
                onClick: (L) => L.stopPropagation(),
                onKeyDownCapture: (L) => {
                  L.key === "Enter" && L.shiftKey && (L.preventDefault(), L.stopPropagation(), xa(u) && $());
                },
                onKeyDown: (L) => {
                  (L.key === "Enter" || L.key === " ") && L.stopPropagation();
                },
                children: [
                  /* @__PURE__ */ d(
                    Kp,
                    {
                      editorSerializedState: u,
                      onSerializedChange: (L) => p(L),
                      placeholder: e["%comment_replyOrAssign%"],
                      autoFocus: !0
                    },
                    y
                  ),
                  /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-row tw-items-start tw-justify-end tw-gap-2", children: [
                    /* @__PURE__ */ d(
                      Ne,
                      {
                        size: "icon",
                        variant: "outline",
                        className: "tw-flex tw-items-center tw-justify-center tw-rounded-md",
                        disabled: !xa(u),
                        children: /* @__PURE__ */ d(Z0, {})
                      }
                    ),
                    /* @__PURE__ */ d(
                      Ne,
                      {
                        size: "icon",
                        onClick: $,
                        className: "tw-flex tw-items-center tw-justify-center tw-rounded-md",
                        disabled: !xa(u),
                        children: /* @__PURE__ */ d(ev, {})
                      }
                    )
                  ] })
                ]
              }
            )
          ] })
        ] })
      ] })
    }
  );
}
function F5({
  className: t = "",
  threads: e,
  localizedStrings: n,
  handleAddComment: r,
  handleResolveCommentThread: o
}) {
  const [i, s] = oe(), a = e.map((g) => ({
    id: `thread-${g.id}`
  })), l = ce((g) => {
    s(g.id);
  }, []), c = ce((g) => {
    s(g);
  }, []), { listboxRef: u, activeId: p, handleKeyDown: f } = u2({
    options: a,
    onOptionSelect: l
  }), h = ce(
    (g) => {
      g.key === "Escape" ? (s(void 0), g.preventDefault(), g.stopPropagation()) : f(g);
    },
    [f]
  );
  return ie(() => {
    if (!i) return;
    const g = document.getElementById(i);
    if (!g) return;
    const b = requestAnimationFrame(() => {
      const _ = requestAnimationFrame(() => {
        const x = g.querySelector(
          '[contenteditable="true"]'
        ), y = g.querySelector(
          "textarea:not([disabled]), select:not([disabled]), button:not([disabled])"
        ), A = x ?? y;
        if (A && (A.focus(), x && A === x)) {
          const P = window.getSelection(), V = document.createRange();
          V.selectNodeContents(x), V.collapse(!1), P == null || P.removeAllRanges(), P == null || P.addRange(V);
        }
      });
      return () => cancelAnimationFrame(_);
    });
    return () => cancelAnimationFrame(b);
  }, [i]), /* @__PURE__ */ d(
    "div",
    {
      id: "comment-thread-list",
      role: "listbox",
      tabIndex: 0,
      ref: u,
      "aria-activedescendant": p ?? void 0,
      "aria-label": "Comments",
      className: z(
        "tw-flex tw-w-full tw-max-w-screen-md tw-flex-col tw-space-y-3 tw-outline-none focus:tw-ring-2 focus:tw-ring-ring focus:tw-ring-offset-1 focus:tw-ring-offset-background",
        t
      ),
      onKeyDown: h,
      children: e.map((g) => /* @__PURE__ */ d("div", { children: /* @__PURE__ */ d(
        Ax,
        {
          comments: g.comments,
          localizedStrings: n,
          verseRef: g.verseRef,
          handleSelectThread: c,
          threadId: `thread-${g.id}`,
          isSelected: i === `thread-${g.id}`,
          assignedUser: g.assignedUser,
          threadStatus: g.status,
          handleAddComment: r,
          handleResolveCommentThread: o
        }
      ) }, `thread-${g.id}`))
    }
  );
}
const kd = Zr(void 0);
function Qn() {
  const t = jo(kd);
  if (!t)
    throw new Error("useMenuContext must be used within a MenuContext.Provider.");
  return t;
}
const Rr = eo("", {
  variants: {
    variant: {
      default: "",
      muted: "hover:tw-bg-muted hover:tw-text-foreground focus:tw-bg-muted focus:tw-text-foreground data-[state=open]:tw-bg-muted data-[state=open]:tw-text-foreground"
    }
  },
  defaultVariants: {
    variant: "default"
  }
}), Nd = st.Trigger, yg = st.Group, Sx = st.Portal, Dx = st.Sub, Mx = st.RadioGroup;
function Dl({ variant: t = "default", ...e }) {
  const n = X.useMemo(
    () => ({
      variant: t
    }),
    [t]
  );
  return /* @__PURE__ */ d(kd.Provider, { value: n, children: /* @__PURE__ */ d(st.Root, { ...e }) });
}
const xg = X.forwardRef(({ className: t, inset: e, children: n, ...r }, o) => {
  const i = Qn();
  return /* @__PURE__ */ M(
    st.SubTrigger,
    {
      ref: o,
      className: z(
        "tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none focus:tw-bg-accent data-[state=open]:tw-bg-accent",
        e && "tw-pl-8",
        t,
        Rr({ variant: i.variant })
        // CUSTOM use context to add variants
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ d(pi, { className: "tw-ml-auto tw-h-4 tw-w-4" })
      ]
    }
  );
});
xg.displayName = st.SubTrigger.displayName;
const _g = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  st.SubContent,
  {
    ref: n,
    className: z(
      "pr-twp tw-z-50 tw-min-w-[8rem] tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-p-1 tw-text-popover-foreground tw-shadow-lg data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
      t
    ),
    ...e
  }
));
_g.displayName = st.SubContent.displayName;
const Ks = X.forwardRef(({ className: t, sideOffset: e = 4, children: n, ...r }, o) => {
  const i = Bt();
  return /* @__PURE__ */ d(st.Portal, { children: /* @__PURE__ */ d(
    st.Content,
    {
      ref: o,
      sideOffset: e,
      className: z(
        /* adding pr-twp because the dropdown content is added to the dom as a sibling to the app root */
        "pr-twp tw-z-50 tw-min-w-[8rem] tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-p-1 tw-text-popover-foreground tw-shadow-md data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
        t
      ),
      ...r,
      children: /* @__PURE__ */ d("div", { dir: i, children: n })
    }
  ) });
});
Ks.displayName = st.Content.displayName;
const Cg = X.forwardRef(({ className: t, inset: e, ...n }, r) => {
  const o = Bt(), i = Qn();
  return /* @__PURE__ */ d(
    st.Item,
    {
      ref: r,
      className: z(
        // removed: tw-relative focus:tw-text-accent-foreground
        "tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none tw-transition-colors focus:tw-bg-accent data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
        e && "tw-pl-8",
        t,
        Rr({ variant: i.variant })
        // CUSTOM use context to add variants
      ),
      ...n,
      dir: o
    }
  );
});
Cg.displayName = st.Item.displayName;
const Td = X.forwardRef(({ className: t, children: e, checked: n, ...r }, o) => {
  const i = Qn();
  return /* @__PURE__ */ M(
    st.CheckboxItem,
    {
      ref: o,
      className: z(
        "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pe-2 tw-ps-8 tw-text-sm tw-outline-none tw-transition-colors focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
        t,
        Rr({ variant: i.variant })
        // CUSTOM use context to add variants
      ),
      checked: n,
      ...r,
      children: [
        /* @__PURE__ */ d("span", { className: "tw-absolute tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center ltr:tw-left-2 rtl:tw-right-2", children: /* @__PURE__ */ d(st.ItemIndicator, { children: /* @__PURE__ */ d(br, { className: "tw-h-4 tw-w-4" }) }) }),
        e
      ]
    }
  );
});
Td.displayName = st.CheckboxItem.displayName;
const Eg = X.forwardRef(({ className: t, children: e, ...n }, r) => {
  const o = Qn();
  return /* @__PURE__ */ M(
    st.RadioItem,
    {
      ref: r,
      className: z(
        "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pe-2 tw-ps-8 tw-text-sm tw-outline-none tw-transition-colors focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
        t,
        Rr({ variant: o.variant })
        // CUSTOM use context to add variants
      ),
      ...n,
      children: [
        /* @__PURE__ */ d("span", { className: "tw-absolute tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center ltr:tw-left-2 rtl:tw-right-2", children: /* @__PURE__ */ d(st.ItemIndicator, { children: /* @__PURE__ */ d(gl, { className: "tw-h-2 tw-w-2 tw-fill-current" }) }) }),
        e
      ]
    }
  );
});
Eg.displayName = st.RadioItem.displayName;
const Ad = X.forwardRef(({ className: t, inset: e, ...n }, r) => /* @__PURE__ */ d(
  st.Label,
  {
    ref: r,
    className: z("tw-px-2 tw-py-1.5 tw-text-sm tw-font-semibold", e && "tw-pl-8", t),
    ...n
  }
));
Ad.displayName = st.Label.displayName;
const Ml = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  st.Separator,
  {
    ref: n,
    className: z("tw--mx-1 tw-my-1 tw-h-px tw-bg-muted", t),
    ...e
  }
));
Ml.displayName = st.Separator.displayName;
function Ox({ className: t, ...e }) {
  return /* @__PURE__ */ d(
    "span",
    {
      className: z("tw-ms-auto tw-text-xs tw-tracking-widest tw-opacity-60", t),
      ...e
    }
  );
}
Ox.displayName = "DropdownMenuShortcut";
function Rx({ table: t }) {
  return /* @__PURE__ */ M(Dl, { children: [
    /* @__PURE__ */ d(Oy, { asChild: !0, children: /* @__PURE__ */ M(Ne, { variant: "outline", size: "sm", className: "tw-ml-auto tw-hidden tw-h-8 lg:tw-flex", children: [
      /* @__PURE__ */ d(tv, { className: "tw-mr-2 tw-h-4 tw-w-4" }),
      "View"
    ] }) }),
    /* @__PURE__ */ M(Ks, { align: "end", className: "tw-w-[150px]", children: [
      /* @__PURE__ */ d(Ad, { children: "Toggle columns" }),
      /* @__PURE__ */ d(Ml, {}),
      t.getAllColumns().filter((e) => e.getCanHide()).map((e) => /* @__PURE__ */ d(
        Td,
        {
          className: "tw-capitalize",
          checked: e.getIsVisible(),
          onCheckedChange: (n) => e.toggleVisibility(!!n),
          children: e.id
        },
        e.id
      ))
    ] })
  ] });
}
const wi = vt.Root, Ix = vt.Group, gi = vt.Value, Lx = eo(
  "tw-flex tw-h-10 tw-w-full tw-items-center tw-justify-between tw-rounded-md tw-border tw-border-input tw-bg-background tw-px-3 tw-py-2 tw-text-sm tw-ring-offset-background placeholder:tw-text-muted-foreground focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-ring focus:tw-ring-offset-2 disabled:tw-cursor-not-allowed disabled:tw-opacity-50 [&>span]:tw-line-clamp-1",
  {
    variants: {
      size: {
        default: "tw-h-10 tw-px-4 tw-py-2",
        sm: "tw-h-8 tw-rounded-md tw-px-3",
        lg: "tw-h-11 tw-rounded-md tw-px-8",
        icon: "tw-h-10 tw-w-10"
      }
    },
    defaultVariants: {
      size: "default"
    }
  }
), Ao = X.forwardRef(({ className: t, children: e, size: n, ...r }, o) => {
  const i = Bt();
  return /* @__PURE__ */ M(
    vt.Trigger,
    {
      className: z(Lx({ size: n, className: t })),
      ref: o,
      ...r,
      dir: i,
      children: [
        e,
        /* @__PURE__ */ d(vt.Icon, { asChild: !0, children: /* @__PURE__ */ d(fi, { className: "tw-h-4 tw-w-4 tw-opacity-50" }) })
      ]
    }
  );
});
Ao.displayName = vt.Trigger.displayName;
const kg = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  vt.ScrollUpButton,
  {
    ref: n,
    className: z("tw-flex tw-cursor-default tw-items-center tw-justify-center tw-py-1", t),
    ...e,
    children: /* @__PURE__ */ d(Yc, { className: "tw-h-4 tw-w-4" })
  }
));
kg.displayName = vt.ScrollUpButton.displayName;
const Ng = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  vt.ScrollDownButton,
  {
    ref: n,
    className: z("tw-flex tw-cursor-default tw-items-center tw-justify-center tw-py-1", t),
    ...e,
    children: /* @__PURE__ */ d(fi, { className: "tw-h-4 tw-w-4" })
  }
));
Ng.displayName = vt.ScrollDownButton.displayName;
const So = X.forwardRef(({ className: t, children: e, position: n = "popper", ...r }, o) => {
  const i = Bt();
  return /* @__PURE__ */ d(vt.Portal, { children: /* @__PURE__ */ M(
    vt.Content,
    {
      ref: o,
      className: z(
        "pr-twp tw-relative tw-z-50 tw-max-h-96 tw-min-w-[8rem] tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-text-popover-foreground tw-shadow-md data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
        n === "popper" && "data-[side=bottom]:tw-translate-y-1 data-[side=left]:tw--translate-x-1 data-[side=right]:tw-translate-x-1 data-[side=top]:tw--translate-y-1",
        t
      ),
      position: n,
      ...r,
      children: [
        /* @__PURE__ */ d(kg, {}),
        /* @__PURE__ */ d(
          vt.Viewport,
          {
            className: z(
              "tw-p-1",
              n === "popper" && "tw-h-[var(--radix-select-trigger-height)] tw-w-full tw-min-w-[var(--radix-select-trigger-width)]"
            ),
            children: /* @__PURE__ */ d("div", { dir: i, children: e })
          }
        ),
        /* @__PURE__ */ d(Ng, {})
      ]
    }
  ) });
});
So.displayName = vt.Content.displayName;
const Px = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  vt.Label,
  {
    ref: n,
    className: z("tw-py-1.5 tw-pl-8 tw-pr-2 tw-text-sm tw-font-semibold", t),
    ...e
  }
));
Px.displayName = vt.Label.displayName;
const Dn = X.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ M(
  vt.Item,
  {
    ref: r,
    className: z(
      "tw-relative tw-flex tw-w-full tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pe-2 tw-ps-8 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
      t
    ),
    ...n,
    children: [
      /* @__PURE__ */ d("span", { className: "tw-absolute tw-start-2 tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center", children: /* @__PURE__ */ d(vt.ItemIndicator, { children: /* @__PURE__ */ d(br, { className: "tw-h-4 tw-w-4" }) }) }),
      /* @__PURE__ */ d(vt.ItemText, { children: e })
    ]
  }
));
Dn.displayName = vt.Item.displayName;
const $x = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  vt.Separator,
  {
    ref: n,
    className: z("tw--mx-1 tw-my-1 tw-h-px tw-bg-muted", t),
    ...e
  }
));
$x.displayName = vt.Separator.displayName;
function Fx({ table: t }) {
  return /* @__PURE__ */ d("div", { className: "tw-flex tw-items-center tw-justify-between tw-px-2 tw-pb-3 tw-pt-3", children: /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center tw-space-x-6 lg:tw-space-x-8", children: [
    /* @__PURE__ */ M("div", { className: "tw-flex-1 tw-text-sm tw-text-muted-foreground", children: [
      t.getFilteredSelectedRowModel().rows.length,
      " of",
      " ",
      t.getFilteredRowModel().rows.length,
      " row(s) selected"
    ] }),
    /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center tw-space-x-2", children: [
      /* @__PURE__ */ d("p", { className: "tw-text-nowrap tw-text-sm tw-font-medium", children: "Rows per page" }),
      /* @__PURE__ */ M(
        wi,
        {
          value: `${t.getState().pagination.pageSize}`,
          onValueChange: (e) => {
            t.setPageSize(Number(e));
          },
          children: [
            /* @__PURE__ */ d(Ao, { className: "tw-h-8 tw-w-[70px]", children: /* @__PURE__ */ d(gi, { placeholder: t.getState().pagination.pageSize }) }),
            /* @__PURE__ */ d(So, { side: "top", children: [10, 20, 30, 40, 50].map((e) => /* @__PURE__ */ d(Dn, { value: `${e}`, children: e }, e)) })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ M("div", { className: "tw-flex tw-w-[100px] tw-items-center tw-justify-center tw-text-sm tw-font-medium", children: [
      "Page ",
      t.getState().pagination.pageIndex + 1,
      " of ",
      t.getPageCount()
    ] }),
    /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center tw-space-x-2", children: [
      /* @__PURE__ */ M(
        Ne,
        {
          variant: "outline",
          size: "icon",
          className: "tw-hidden tw-h-8 tw-w-8 tw-p-0 lg:tw-flex",
          onClick: () => t.setPageIndex(0),
          disabled: !t.getCanPreviousPage(),
          children: [
            /* @__PURE__ */ d("span", { className: "tw-sr-only", children: "Go to first page" }),
            /* @__PURE__ */ d(nv, { className: "tw-h-4 tw-w-4" })
          ]
        }
      ),
      /* @__PURE__ */ M(
        Ne,
        {
          variant: "outline",
          size: "icon",
          className: "tw-h-8 tw-w-8 tw-p-0",
          onClick: () => t.previousPage(),
          disabled: !t.getCanPreviousPage(),
          children: [
            /* @__PURE__ */ d("span", { className: "tw-sr-only", children: "Go to previous page" }),
            /* @__PURE__ */ d(rv, { className: "tw-h-4 tw-w-4" })
          ]
        }
      ),
      /* @__PURE__ */ M(
        Ne,
        {
          variant: "outline",
          size: "icon",
          className: "tw-h-8 tw-w-8 tw-p-0",
          onClick: () => t.nextPage(),
          disabled: !t.getCanNextPage(),
          children: [
            /* @__PURE__ */ d("span", { className: "tw-sr-only", children: "Go to next page" }),
            /* @__PURE__ */ d(ov, { className: "tw-h-4 tw-w-4" })
          ]
        }
      ),
      /* @__PURE__ */ M(
        Ne,
        {
          variant: "outline",
          size: "icon",
          className: "tw-hidden tw-h-8 tw-w-8 tw-p-0 lg:tw-flex",
          onClick: () => t.setPageIndex(t.getPageCount() - 1),
          disabled: !t.getCanNextPage(),
          children: [
            /* @__PURE__ */ d("span", { className: "tw-sr-only", children: "Go to last page" }),
            /* @__PURE__ */ d(iv, { className: "tw-h-4 tw-w-4" })
          ]
        }
      )
    ] })
  ] }) });
}
const Xp = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [contenteditable],
  tr:not([disabled])
`;
function Bx(t) {
  return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length);
}
function Cs(t, e) {
  const n = e ? `${Xp}, ${e}` : Xp;
  return Array.from(t.querySelectorAll(n)).filter(
    (r) => !r.hasAttribute("disabled") && !r.getAttribute("aria-hidden") && Bx(r)
  );
}
const Ol = X.forwardRef(({ className: t, stickyHeader: e, ...n }, r) => {
  const o = X.useRef(null);
  X.useEffect(() => {
    typeof r == "function" ? r(o.current) : r && "current" in r && (r.current = o.current);
  }, [r]), X.useEffect(() => {
    const s = o.current;
    if (!s) return;
    const a = () => {
      requestAnimationFrame(() => {
        Cs(s, '[tabindex]:not([tabindex="-1"])').forEach((u) => {
          u.setAttribute("tabindex", "-1");
        });
      });
    };
    a();
    const l = new MutationObserver(() => {
      a();
    });
    return l.observe(s, {
      childList: !0,
      // Watch for added/removed elements
      subtree: !0,
      // Include descendants
      attributes: !0,
      attributeFilter: ["tabindex"]
      // Watch for tabindex changes
    }), () => {
      l.disconnect();
    };
  }, []);
  const i = (s) => {
    const { current: a } = o;
    if (a) {
      if (s.key === "ArrowDown") {
        s.preventDefault(), Cs(a)[0].focus();
        return;
      }
      s.key === " " && document.activeElement === a && s.preventDefault();
    }
  };
  return /* @__PURE__ */ d("div", { className: z("pr-twp tw-relative tw-w-full", { "tw-p-1": e }), children: /* @__PURE__ */ d(
    "table",
    {
      tabIndex: 0,
      onKeyDown: i,
      ref: o,
      className: z(
        "tw-w-full tw-caption-bottom tw-text-sm tw-outline-none",
        // CUSTOM: Add outline-none to remove duplicate outline
        "focus:tw-relative focus:tw-z-10 focus:tw-ring-2 focus:tw-ring-ring focus:tw-ring-offset-1 focus:tw-ring-offset-background",
        // CUSTOM: Add focus styles
        t
      ),
      "aria-label": "Table",
      "aria-labelledby": "table-label",
      ...n
    }
  ) });
});
Ol.displayName = "Table";
const Rl = X.forwardRef(({ className: t, stickyHeader: e, ...n }, r) => /* @__PURE__ */ d(
  "thead",
  {
    ref: r,
    className: z(
      {
        "tw-sticky tw-top-[-1px] tw-z-20 tw-bg-background tw-drop-shadow-sm": e
      },
      "[&_tr]:tw-border-b",
      t
    ),
    ...n
  }
));
Rl.displayName = "TableHeader";
const Il = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d("tbody", { ref: n, className: z("[&_tr:last-child]:tw-border-0", t), ...e }));
Il.displayName = "TableBody";
const qx = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  "tfoot",
  {
    ref: n,
    className: z("tw-border-t tw-bg-muted/50 tw-font-medium [&>tr]:last:tw-border-b-0", t),
    ...e
  }
));
qx.displayName = "TableFooter";
function jx(t) {
  X.useEffect(() => {
    const e = t.current;
    if (!e) return;
    const n = (r) => {
      if (e.contains(document.activeElement)) {
        if (r.key === "ArrowRight" || r.key === "ArrowLeft") {
          r.preventDefault(), r.stopPropagation();
          const o = t.current ? Cs(t.current) : [], i = o.indexOf(document.activeElement), s = r.key === "ArrowRight" ? i + 1 : i - 1;
          s >= 0 && s < o.length && o[s].focus();
        }
        r.key === "Escape" && (r.preventDefault(), e.focus()), (r.key === "ArrowDown" || r.key === "ArrowUp") && r.preventDefault();
      }
    };
    return e.addEventListener("keydown", n), () => {
      e.removeEventListener("keydown", n);
    };
  }, [t]);
}
function Ux(t, e, n) {
  let r;
  return n === "ArrowLeft" && e > 0 ? r = t[e - 1] : n === "ArrowRight" && e < t.length - 1 && (r = t[e + 1]), r ? (requestAnimationFrame(() => r.focus()), !0) : !1;
}
function Vx(t, e, n) {
  let r;
  return n === "ArrowDown" && e < t.length - 1 ? r = t[e + 1] : n === "ArrowUp" && e > 0 && (r = t[e - 1]), r ? (requestAnimationFrame(() => r.focus()), !0) : !1;
}
const Tr = X.forwardRef(({ className: t, onKeyDown: e, onSelect: n, setFocusAlsoRunsSelect: r = !1, ...o }, i) => {
  const s = X.useRef(null);
  X.useEffect(() => {
    typeof i == "function" ? i(s.current) : i && "current" in i && (i.current = s.current);
  }, [i]), jx(s);
  const a = X.useMemo(
    () => s.current ? Cs(s.current) : [],
    [s]
  ), l = X.useCallback(
    (u) => {
      const { current: p } = s;
      if (!p || !p.parentElement) return;
      const f = p.closest("table"), h = f ? (
        // getFocusableElements returns an HTMLElement[] but we are filtering for HTMLTableRowElements
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        Cs(f).filter(
          (_) => _.tagName === "TR"
        )
      ) : [], g = h.indexOf(p), b = a.indexOf(
        // activeElement is generic Element, so we need to cast it to HTMLElement
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        document.activeElement
      );
      if (u.key === "ArrowDown" || u.key === "ArrowUp")
        u.preventDefault(), Vx(h, g, u.key);
      else if (u.key === "ArrowLeft" || u.key === "ArrowRight")
        u.preventDefault(), Ux(a, b, u.key);
      else if (u.key === "Escape") {
        u.preventDefault();
        const _ = p.closest("table");
        _ && _.focus();
      }
      e == null || e(u);
    },
    [s, a, e]
  ), c = X.useCallback(
    (u) => {
      r && (n == null || n(u));
    },
    [r, n]
  );
  return /* @__PURE__ */ d(
    "tr",
    {
      ref: s,
      tabIndex: -1,
      onKeyDown: l,
      onFocus: c,
      className: z(
        // CUSTOM: Add focus styles and add tw-outline-none so there isn't a duplicate outline
        "tw-border-b tw-outline-none tw-transition-colors hover:tw-bg-muted/50",
        "focus:tw-relative focus:tw-z-10 focus:tw-ring-2 focus:tw-ring-ring focus:tw-ring-offset-1 focus:tw-ring-offset-background",
        "data-[state=selected]:tw-bg-muted",
        t
      ),
      ...o
    }
  );
});
Tr.displayName = "TableRow";
const Es = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  "th",
  {
    ref: n,
    className: z(
      "tw-h-12 tw-px-4 tw-text-start tw-align-middle tw-font-medium tw-text-muted-foreground [&:has([role=checkbox])]:tw-pe-0",
      t
    ),
    ...e
  }
));
Es.displayName = "TableHead";
const Co = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  "td",
  {
    ref: n,
    className: z("tw-p-4 tw-align-middle [&:has([role=checkbox])]:tw-pe-0", t),
    ...e
  }
));
Co.displayName = "TableCell";
const Hx = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  "caption",
  {
    ref: n,
    className: z("tw-mt-4 tw-text-sm tw-text-muted-foreground", t),
    ...e
  }
));
Hx.displayName = "TableCaption";
function du({ className: t, ...e }) {
  return /* @__PURE__ */ d(
    "div",
    {
      className: z("pr-twp tw-animate-pulse tw-rounded-md tw-bg-muted", t),
      ...e
    }
  );
}
function zx({
  columns: t,
  data: e,
  enablePagination: n = !1,
  showPaginationControls: r = !1,
  showColumnVisibilityControls: o = !1,
  stickyHeader: i = !1,
  onRowClickHandler: s = () => {
  },
  id: a,
  isLoading: l = !1,
  noResultsMessage: c
}) {
  var O;
  const [u, p] = oe([]), [f, h] = oe([]), [g, b] = oe({}), [_, x] = oe({}), y = ue(() => e ?? [], [e]), A = Dw({
    data: y,
    columns: t,
    getCoreRowModel: Ow(),
    ...n && { getPaginationRowModel: Sy() },
    onSortingChange: p,
    getSortedRowModel: Mw(),
    onColumnFiltersChange: h,
    getFilteredRowModel: Ay(),
    onColumnVisibilityChange: b,
    onRowSelectionChange: x,
    state: {
      sorting: u,
      columnFilters: f,
      columnVisibility: g,
      rowSelection: _
    }
  }), P = A.getVisibleFlatColumns();
  let V;
  return l ? V = Array.from({ length: 10 }).map((F, K) => `skeleton-row-${K}`).map((F) => /* @__PURE__ */ d(Tr, { children: /* @__PURE__ */ d(Co, { colSpan: P.length ?? t.length, className: "tw-border-0 tw-p-0", children: /* @__PURE__ */ d("div", { className: "tw-w-full tw-py-2", children: /* @__PURE__ */ d(du, { className: "tw-h-14 tw-w-full tw-rounded-md" }) }) }) }, F)) : ((O = A.getRowModel().rows) == null ? void 0 : O.length) > 0 ? V = A.getRowModel().rows.map((U) => /* @__PURE__ */ d(
    Tr,
    {
      onClick: () => s(U, A),
      "data-state": U.getIsSelected() && "selected",
      children: U.getVisibleCells().map((B) => /* @__PURE__ */ d(Co, { children: fs(B.column.columnDef.cell, B.getContext()) }, B.id))
    },
    U.id
  )) : V = /* @__PURE__ */ d(Tr, { children: /* @__PURE__ */ d(Co, { colSpan: t.length, className: "tw-h-24 tw-text-center", children: c }) }), /* @__PURE__ */ M("div", { className: "pr-twp", id: a, children: [
    o && /* @__PURE__ */ d(Rx, { table: A }),
    /* @__PURE__ */ M(Ol, { stickyHeader: i, children: [
      /* @__PURE__ */ d(Rl, { stickyHeader: i, children: A.getHeaderGroups().map((U) => /* @__PURE__ */ d(Tr, { children: U.headers.map((B) => /* @__PURE__ */ d(Es, { children: B.isPlaceholder ? void 0 : fs(B.column.columnDef.header, B.getContext()) }, B.id)) }, U.id)) }),
      /* @__PURE__ */ d(Il, { children: V })
    ] }),
    n && /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center tw-justify-end tw-space-x-2 tw-py-4", children: [
      /* @__PURE__ */ d(
        Ne,
        {
          variant: "outline",
          size: "sm",
          onClick: () => A.previousPage(),
          disabled: !A.getCanPreviousPage(),
          children: "Previous"
        }
      ),
      /* @__PURE__ */ d(
        Ne,
        {
          variant: "outline",
          size: "sm",
          onClick: () => A.nextPage(),
          disabled: !A.getCanNextPage(),
          children: "Next"
        }
      )
    ] }),
    n && r && /* @__PURE__ */ d(Fx, { table: A })
  ] });
}
const Gx = Object.freeze([
  "%webView_error_dump_header%",
  "%webView_error_dump_info_message%"
]), Yp = (t, e) => t[e] ?? e;
function Kx({
  errorDetails: t,
  handleCopyNotify: e,
  localizedStrings: n,
  id: r
}) {
  const o = Yp(n, "%webView_error_dump_header%"), i = Yp(n, "%webView_error_dump_info_message%");
  function s() {
    navigator.clipboard.writeText(t), e && e();
  }
  return /* @__PURE__ */ M(
    "div",
    {
      id: r,
      className: "tw-inline-flex tw-w-full tw-flex-col tw-items-start tw-justify-start tw-gap-4",
      children: [
        /* @__PURE__ */ M("div", { className: "tw-inline-flex tw-items-start tw-justify-start tw-gap-4 tw-self-stretch", children: [
          /* @__PURE__ */ M("div", { className: "tw-inline-flex tw-flex-1 tw-flex-col tw-items-start tw-justify-start", children: [
            /* @__PURE__ */ d("div", { className: "tw-text-color-text tw-justify-center tw-text-center tw-text-lg tw-font-semibold tw-leading-loose", children: o }),
            /* @__PURE__ */ d("div", { className: "tw-justify-center tw-self-stretch tw-text-sm tw-font-normal tw-leading-tight tw-text-muted-foreground", children: i })
          ] }),
          /* @__PURE__ */ d(Ne, { variant: "secondary", size: "icon", className: "size-8", onClick: () => s(), children: /* @__PURE__ */ d(pw, {}) })
        ] }),
        /* @__PURE__ */ d("div", { className: "tw-prose tw-w-full", children: /* @__PURE__ */ d("pre", { className: "tw-text-xs", children: t }) })
      ]
    }
  );
}
const B5 = Object.freeze([
  ...Gx,
  "%webView_error_dump_copied_message%"
]);
function q5({
  errorDetails: t,
  handleCopyNotify: e,
  localizedStrings: n,
  children: r,
  className: o,
  id: i
}) {
  const [s, a] = oe(!1), l = () => {
    a(!0), e && e();
  };
  return /* @__PURE__ */ M(Li, { onOpenChange: (u) => {
    u || a(!1);
  }, children: [
    /* @__PURE__ */ d(Pi, { asChild: !0, children: r }),
    /* @__PURE__ */ M(zo, { id: i, className: z("tw-min-w-80 tw-max-w-96", o), children: [
      s && n["%webView_error_dump_copied_message%"] && /* @__PURE__ */ d(Lt, { children: n["%webView_error_dump_copied_message%"] }),
      /* @__PURE__ */ d(
        Kx,
        {
          errorDetails: t,
          handleCopyNotify: l,
          localizedStrings: n
        }
      )
    ] })
  ] });
}
var Wx = /* @__PURE__ */ ((t) => (t[t.Check = 0] = "Check", t[t.Radio = 1] = "Radio", t))(Wx || {});
function j5({ id: t, label: e, groups: n }) {
  const [r, o] = oe(
    Object.fromEntries(
      n.map(
        (c, u) => c.itemType === 0 ? [u, []] : void 0
      ).filter((c) => !!c)
    )
  ), [i, s] = oe({}), a = (c, u) => {
    const p = !r[c][u];
    o((h) => (h[c][u] = p, { ...h }));
    const f = n[c].items[u];
    f.onUpdate(f.id, p);
  }, l = (c, u) => {
    s((f) => (f[c] = u, { ...f }));
    const p = n[c].items.find((f) => f.id === u);
    p ? p.onUpdate(u) : console.error(`Could not find dropdown radio item with id '${u}'!`);
  };
  return /* @__PURE__ */ d("div", { id: t, children: /* @__PURE__ */ M(Dl, { children: [
    /* @__PURE__ */ d(Nd, { asChild: !0, children: /* @__PURE__ */ M(Ne, { variant: "default", children: [
      /* @__PURE__ */ d(sv, { size: 16, className: "tw-mr-2 tw-h-4 tw-w-4" }),
      e,
      /* @__PURE__ */ d(fi, { size: 16, className: "tw-ml-2 tw-h-4 tw-w-4" })
    ] }) }),
    /* @__PURE__ */ d(Ks, { children: n.map((c, u) => /* @__PURE__ */ M("div", { children: [
      /* @__PURE__ */ d(Ad, { children: c.label }),
      /* @__PURE__ */ d(yg, { children: c.itemType === 0 ? /* @__PURE__ */ d(ft, { children: c.items.map((p, f) => /* @__PURE__ */ d("div", { children: /* @__PURE__ */ d(
        Td,
        {
          checked: r[u][f],
          onCheckedChange: () => a(u, f),
          children: p.label
        }
      ) }, p.id)) }) : /* @__PURE__ */ d(
        Mx,
        {
          value: i[u],
          onValueChange: (p) => l(u, p),
          children: c.items.map((p) => /* @__PURE__ */ d("div", { children: /* @__PURE__ */ d(Eg, { value: p.id, children: p.label }) }, p.id))
        }
      ) }),
      /* @__PURE__ */ d(Ml, {})
    ] }, c.label)) })
  ] }) });
}
function U5({
  id: t,
  category: e,
  downloads: n,
  languages: r,
  moreInfoUrl: o,
  handleMoreInfoLinkClick: i,
  supportUrl: s,
  handleSupportLinkClick: a
}) {
  const l = new Dv("en", {
    notation: "compact",
    compactDisplay: "short"
  }).format(Object.values(n).reduce((u, p) => u + p, 0)), c = () => {
    window.scrollTo(0, document.body.scrollHeight);
  };
  return /* @__PURE__ */ M(
    "div",
    {
      id: t,
      className: "pr-twp tw-flex tw-items-center tw-justify-center tw-gap-4 tw-divide-x tw-border-b tw-border-t tw-py-2 tw-text-center",
      children: [
        e && /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-col tw-items-center tw-gap-1", children: [
          /* @__PURE__ */ d("div", { className: "tw-flex", children: /* @__PURE__ */ d("span", { className: "tw-text-xs tw-font-semibold tw-text-foreground", children: e }) }),
          /* @__PURE__ */ d("span", { className: "tw-text-xs tw-text-foreground", children: "CATEGORY" })
        ] }),
        /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-col tw-items-center tw-gap-1 tw-ps-4", children: [
          /* @__PURE__ */ M("div", { className: "tw-flex tw-gap-1", children: [
            /* @__PURE__ */ d(av, { className: "tw-h-4 tw-w-4" }),
            /* @__PURE__ */ d("span", { className: "tw-text-xs tw-font-semibold tw-text-foreground", children: l })
          ] }),
          /* @__PURE__ */ d("span", { className: "tw-text-xs tw-text-foreground", children: "USERS" })
        ] }),
        /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-col tw-items-center tw-gap-1 tw-ps-4", children: [
          /* @__PURE__ */ d("div", { className: "tw-flex tw-gap-2", children: r.slice(0, 3).map((u) => /* @__PURE__ */ d("span", { className: "tw-text-xs tw-font-semibold tw-text-foreground", children: u.toUpperCase() }, u)) }),
          r.length > 3 && /* @__PURE__ */ M(
            "button",
            {
              type: "button",
              onClick: () => c(),
              className: "tw-text-xs tw-text-foreground tw-underline",
              children: [
                "+",
                r.length - 3,
                " more languages"
              ]
            }
          )
        ] }),
        (o || s) && /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-col tw-gap-1 tw-ps-4", children: [
          o && /* @__PURE__ */ d("div", { className: "tw-flex tw-gap-1", children: /* @__PURE__ */ M(
            Ne,
            {
              onClick: () => i(),
              variant: "link",
              className: "tw-flex tw-h-auto tw-gap-1 tw-py-0 tw-text-xs tw-font-semibold tw-text-foreground",
              children: [
                "Website",
                /* @__PURE__ */ d(lv, { className: "tw-h-4 tw-w-4" })
              ]
            }
          ) }),
          s && /* @__PURE__ */ d("div", { className: "tw-flex tw-gap-1", children: /* @__PURE__ */ M(
            Ne,
            {
              onClick: () => a(),
              variant: "link",
              className: "tw-flex tw-h-auto tw-gap-1 tw-py-0 tw-text-xs tw-font-semibold tw-text-foreground",
              children: [
                "Support",
                /* @__PURE__ */ d(cv, { className: "tw-h-4 tw-w-4" })
              ]
            }
          ) })
        ] })
      ]
    }
  );
}
function Jx({ id: t, versionHistory: e }) {
  const [n, r] = oe(!1), o = /* @__PURE__ */ new Date();
  function i(a) {
    const l = new Date(a), c = new Date(o.getTime() - l.getTime()), u = c.getUTCFullYear() - 1970, p = c.getUTCMonth(), f = c.getUTCDate() - 1;
    let h = "";
    return u > 0 ? h = `${u.toString()} year${u === 1 ? "" : "s"} ago` : p > 0 ? h = `${p.toString()} month${p === 1 ? "" : "s"} ago` : f === 0 ? h = "today" : h = `${f.toString()} day${f === 1 ? "" : "s"} ago`, h;
  }
  const s = Object.entries(e).sort((a, l) => l[0].localeCompare(a[0]));
  return /* @__PURE__ */ M("div", { className: "pr-twp", id: t, children: [
    /* @__PURE__ */ d("h3", { className: "tw-text-md tw-font-semibold", children: "What`s New" }),
    /* @__PURE__ */ d("ul", { className: "tw-list-disc tw-pl-5 tw-pr-4 tw-text-xs tw-text-foreground", children: (n ? s : s.slice(0, 5)).map((a) => /* @__PURE__ */ M("div", { className: "tw-mt-3 tw-flex tw-justify-between", children: [
      /* @__PURE__ */ d("div", { className: "tw-text-foreground", children: /* @__PURE__ */ d("li", { className: "tw-prose tw-text-xs", children: /* @__PURE__ */ d("span", { children: a[1].description }) }) }),
      /* @__PURE__ */ M("div", { className: "tw-justify-end tw-text-right", children: [
        /* @__PURE__ */ M("div", { children: [
          "Version ",
          a[0]
        ] }),
        /* @__PURE__ */ d("div", { children: i(a[1].date) })
      ] })
    ] }, a[0])) }),
    s.length > 5 && /* @__PURE__ */ d(
      "button",
      {
        type: "button",
        onClick: () => r(!n),
        className: "tw-text-xs tw-text-foreground tw-underline",
        children: n ? "Show Less Version History" : "Show All Version History"
      }
    )
  ] });
}
function V5({
  id: t,
  publisherDisplayName: e,
  fileSize: n,
  locales: r,
  versionHistory: o,
  currentVersion: i
}) {
  const s = ue(() => Mv(n), [n]), l = ((c) => {
    const u = new Intl.DisplayNames(Ov(), { type: "language" });
    return c.map((p) => u.of(p));
  })(r);
  return /* @__PURE__ */ d("div", { id: t, className: "pr-twp tw-border-t tw-py-2", children: /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-col tw-gap-2 tw-divide-y", children: [
    Object.entries(o).length > 0 && /* @__PURE__ */ d(Jx, { versionHistory: o }),
    /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-col tw-gap-2 tw-py-2", children: [
      /* @__PURE__ */ d("h2", { className: "tw-text-md tw-font-semibold", children: "Information" }),
      /* @__PURE__ */ M("div", { className: "tw-flex tw-items-start tw-justify-between tw-text-xs tw-text-foreground", children: [
        /* @__PURE__ */ M("p", { className: "tw-flex tw-flex-col tw-justify-start tw-gap-1", children: [
          /* @__PURE__ */ d("span", { children: "Publisher" }),
          /* @__PURE__ */ d("span", { className: "tw-font-semibold", children: e }),
          /* @__PURE__ */ d("span", { children: "Size" }),
          /* @__PURE__ */ d("span", { className: "tw-font-semibold", children: s })
        ] }),
        /* @__PURE__ */ d("div", { className: "tw-flex tw-w-3/4 tw-items-center tw-justify-between tw-text-xs tw-text-foreground", children: /* @__PURE__ */ M("p", { className: "tw-flex tw-flex-col tw-justify-start tw-gap-1", children: [
          /* @__PURE__ */ d("span", { children: "Version" }),
          /* @__PURE__ */ d("span", { className: "tw-font-semibold", children: i }),
          /* @__PURE__ */ d("span", { children: "Languages" }),
          /* @__PURE__ */ d("span", { className: "tw-font-semibold", children: l.join(", ") })
        ] }) })
      ] })
    ] })
  ] }) });
}
function Xx({
  entries: t,
  selected: e,
  onChange: n,
  placeholder: r,
  hasToggleAllFeature: o = !1,
  selectAllText: i = "Select All",
  clearAllText: s = "Clear All",
  commandEmptyMessage: a = "No entries found",
  customSelectedText: l,
  isOpen: c = void 0,
  onOpenChange: u = void 0,
  isDisabled: p = !1,
  sortSelected: f = !1,
  icon: h = void 0,
  className: g = void 0,
  variant: b = "ghost",
  id: _
}) {
  const [x, y] = oe(!1), A = ce(
    (K) => {
      var S;
      const E = (S = t.find((k) => k.label === K)) == null ? void 0 : S.value;
      E && n(
        e.includes(E) ? e.filter((k) => k !== E) : [...e, E]
      );
    },
    [t, e, n]
  ), P = () => l || r, V = ue(() => {
    if (!f) return t;
    const K = t.filter((S) => S.starred).sort((S, k) => S.label.localeCompare(k.label)), E = t.filter((S) => !S.starred).sort((S, k) => {
      const I = e.includes(S.value), N = e.includes(k.value);
      return I && !N ? -1 : !I && N ? 1 : S.label.localeCompare(k.label);
    });
    return [...K, ...E];
  }, [t, e, f]), O = () => {
    n(t.map((K) => K.value));
  }, U = () => {
    n([]);
  }, B = c ?? x;
  return /* @__PURE__ */ d("div", { id: _, className: g, children: /* @__PURE__ */ M(Li, { open: B, onOpenChange: u ?? y, children: [
    /* @__PURE__ */ d(Pi, { asChild: !0, children: /* @__PURE__ */ M(
      Ne,
      {
        variant: b,
        role: "combobox",
        "aria-expanded": B,
        className: "tw-group tw-w-full tw-justify-between",
        disabled: p,
        children: [
          /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center tw-gap-2", children: [
            h && /* @__PURE__ */ d("div", { className: "tw-ml-2 tw-h-4 tw-w-4 tw-shrink-0 tw-opacity-50", children: /* @__PURE__ */ d("span", { className: "tw-flex tw-h-full tw-w-full tw-items-center tw-justify-center", children: h }) }),
            /* @__PURE__ */ d("div", { className: "tw-font-normal", children: P() })
          ] }),
          /* @__PURE__ */ d(Zu, { className: "tw-ml-2 tw-h-4 tw-w-4 tw-shrink-0 tw-opacity-50" })
        ]
      }
    ) }),
    /* @__PURE__ */ d(zo, { align: "start", className: "tw-w-full tw-p-0", children: /* @__PURE__ */ M(Oi, { children: [
      /* @__PURE__ */ d(Gs, { placeholder: `Search ${r.toLowerCase()}...` }),
      o && /* @__PURE__ */ M("div", { className: "tw-flex tw-justify-between tw-border-b tw-p-2", children: [
        /* @__PURE__ */ d(Ne, { variant: "ghost", size: "sm", onClick: O, children: i }),
        /* @__PURE__ */ d(Ne, { variant: "ghost", size: "sm", onClick: U, children: s })
      ] }),
      /* @__PURE__ */ M(Ri, { children: [
        /* @__PURE__ */ d(kl, { children: a }),
        /* @__PURE__ */ d(No, { children: V.map((K) => /* @__PURE__ */ M(
          Ho,
          {
            value: K.label,
            onSelect: A,
            className: "tw-flex tw-items-center tw-gap-2",
            children: [
              /* @__PURE__ */ d("div", { className: "w-4", children: /* @__PURE__ */ d(
                br,
                {
                  className: z(
                    "tw-h-4 tw-w-4",
                    e.includes(K.value) ? "tw-opacity-100" : "tw-opacity-0"
                  )
                }
              ) }),
              K.starred && /* @__PURE__ */ d(uv, { className: "tw-h-4 tw-w-4" }),
              /* @__PURE__ */ d("div", { className: "tw-flex-grow", children: K.label }),
              K.secondaryLabel && /* @__PURE__ */ d("div", { className: "tw-text-end tw-text-muted-foreground", children: K.secondaryLabel })
            ]
          },
          K.label
        )) })
      ] })
    ] }) })
  ] }) });
}
function H5({
  entries: t,
  selected: e,
  onChange: n,
  placeholder: r,
  commandEmptyMessage: o,
  customSelectedText: i,
  isDisabled: s,
  sortSelected: a,
  icon: l,
  className: c,
  badgesPlaceholder: u,
  id: p
}) {
  return /* @__PURE__ */ M("div", { id: p, className: "tw-flex tw-items-center tw-gap-2", children: [
    /* @__PURE__ */ d(
      Xx,
      {
        entries: t,
        selected: e,
        onChange: n,
        placeholder: r,
        commandEmptyMessage: o,
        customSelectedText: i,
        isDisabled: s,
        sortSelected: a,
        icon: l,
        className: c
      }
    ),
    e.length > 0 ? /* @__PURE__ */ d("div", { className: "tw-flex tw-flex-wrap tw-items-center tw-gap-2", children: e.map((f) => {
      var h;
      return /* @__PURE__ */ M(ys, { variant: "muted", className: "tw-flex tw-items-center tw-gap-1", children: [
        /* @__PURE__ */ d(
          Ne,
          {
            variant: "ghost",
            size: "icon",
            className: "tw-h-4 tw-w-4 tw-p-0 hover:tw-bg-transparent",
            onClick: () => n(e.filter((g) => g !== f)),
            children: /* @__PURE__ */ d(wl, { className: "tw-h-3 tw-w-3" })
          }
        ),
        (h = t.find((g) => g.value === f)) == null ? void 0 : h.label
      ] }, f);
    }) }) : /* @__PURE__ */ d(Lt, { children: u })
  ] });
}
var Ur = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Yx(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Pe = {}, Rt = {}, Qp;
function $i() {
  if (Qp) return Rt;
  Qp = 1;
  function t(x, y, A) {
    if (A === void 0 && (A = Array.prototype), x && typeof A.find == "function")
      return A.find.call(x, y);
    for (var P = 0; P < x.length; P++)
      if (n(x, P)) {
        var V = x[P];
        if (y.call(void 0, V, P, x))
          return V;
      }
  }
  function e(x, y) {
    return y === void 0 && (y = Object), y && typeof y.getOwnPropertyDescriptors == "function" && (x = y.create(null, y.getOwnPropertyDescriptors(x))), y && typeof y.freeze == "function" ? y.freeze(x) : x;
  }
  function n(x, y) {
    return Object.prototype.hasOwnProperty.call(x, y);
  }
  function r(x, y) {
    if (x === null || typeof x != "object")
      throw new TypeError("target is not an object");
    for (var A in y)
      n(y, A) && (x[A] = y[A]);
    return x;
  }
  var o = e({
    allowfullscreen: !0,
    async: !0,
    autofocus: !0,
    autoplay: !0,
    checked: !0,
    controls: !0,
    default: !0,
    defer: !0,
    disabled: !0,
    formnovalidate: !0,
    hidden: !0,
    ismap: !0,
    itemscope: !0,
    loop: !0,
    multiple: !0,
    muted: !0,
    nomodule: !0,
    novalidate: !0,
    open: !0,
    playsinline: !0,
    readonly: !0,
    required: !0,
    reversed: !0,
    selected: !0
  });
  function i(x) {
    return n(o, x.toLowerCase());
  }
  var s = e({
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
  });
  function a(x) {
    return n(s, x.toLowerCase());
  }
  var l = e({
    script: !1,
    style: !1,
    textarea: !0,
    title: !0
  });
  function c(x) {
    var y = x.toLowerCase();
    return n(l, y) && !l[y];
  }
  function u(x) {
    var y = x.toLowerCase();
    return n(l, y) && l[y];
  }
  function p(x) {
    return x === h.HTML;
  }
  function f(x) {
    return p(x) || x === h.XML_XHTML_APPLICATION;
  }
  var h = e({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring
     *      WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType
     *      registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/xml`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType
     *      registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  }), g = Object.keys(h).map(function(x) {
    return h[x];
  });
  function b(x) {
    return g.indexOf(x) > -1;
  }
  var _ = e({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace.
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });
  return Rt.assign = r, Rt.find = t, Rt.freeze = e, Rt.HTML_BOOLEAN_ATTRIBUTES = o, Rt.HTML_RAW_TEXT_ELEMENTS = l, Rt.HTML_VOID_ELEMENTS = s, Rt.hasDefaultHTMLNamespace = f, Rt.hasOwn = n, Rt.isHTMLBooleanAttribute = i, Rt.isHTMLRawTextElement = c, Rt.isHTMLEscapableRawTextElement = u, Rt.isHTMLMimeType = p, Rt.isHTMLVoidElement = a, Rt.isValidMimeType = b, Rt.MIME_TYPE = h, Rt.NAMESPACE = _, Rt;
}
var ni = {}, Zp;
function Ll() {
  if (Zp) return ni;
  Zp = 1;
  var t = $i();
  function e(f, h) {
    f.prototype = Object.create(Error.prototype, {
      constructor: { value: f },
      name: { value: f.name, enumerable: !0, writable: h }
    });
  }
  var n = t.freeze({
    /**
     * the default value as defined by the spec
     */
    Error: "Error",
    /**
     * @deprecated
     * Use RangeError instead.
     */
    IndexSizeError: "IndexSizeError",
    /**
     * @deprecated
     * Just to match the related static code, not part of the spec.
     */
    DomstringSizeError: "DomstringSizeError",
    HierarchyRequestError: "HierarchyRequestError",
    WrongDocumentError: "WrongDocumentError",
    InvalidCharacterError: "InvalidCharacterError",
    /**
     * @deprecated
     * Just to match the related static code, not part of the spec.
     */
    NoDataAllowedError: "NoDataAllowedError",
    NoModificationAllowedError: "NoModificationAllowedError",
    NotFoundError: "NotFoundError",
    NotSupportedError: "NotSupportedError",
    InUseAttributeError: "InUseAttributeError",
    InvalidStateError: "InvalidStateError",
    SyntaxError: "SyntaxError",
    InvalidModificationError: "InvalidModificationError",
    NamespaceError: "NamespaceError",
    /**
     * @deprecated
     * Use TypeError for invalid arguments,
     * "NotSupportedError" DOMException for unsupported operations,
     * and "NotAllowedError" DOMException for denied requests instead.
     */
    InvalidAccessError: "InvalidAccessError",
    /**
     * @deprecated
     * Just to match the related static code, not part of the spec.
     */
    ValidationError: "ValidationError",
    /**
     * @deprecated
     * Use TypeError instead.
     */
    TypeMismatchError: "TypeMismatchError",
    SecurityError: "SecurityError",
    NetworkError: "NetworkError",
    AbortError: "AbortError",
    /**
     * @deprecated
     * Just to match the related static code, not part of the spec.
     */
    URLMismatchError: "URLMismatchError",
    QuotaExceededError: "QuotaExceededError",
    TimeoutError: "TimeoutError",
    InvalidNodeTypeError: "InvalidNodeTypeError",
    DataCloneError: "DataCloneError",
    EncodingError: "EncodingError",
    NotReadableError: "NotReadableError",
    UnknownError: "UnknownError",
    ConstraintError: "ConstraintError",
    DataError: "DataError",
    TransactionInactiveError: "TransactionInactiveError",
    ReadOnlyError: "ReadOnlyError",
    VersionError: "VersionError",
    OperationError: "OperationError",
    NotAllowedError: "NotAllowedError",
    OptOutError: "OptOutError"
  }), r = Object.keys(n);
  function o(f) {
    return typeof f == "number" && f >= 1 && f <= 25;
  }
  function i(f) {
    return typeof f == "string" && f.substring(f.length - n.Error.length) === n.Error;
  }
  function s(f, h) {
    o(f) ? (this.name = r[f], this.message = h || "") : (this.message = f, this.name = i(h) ? h : n.Error), Error.captureStackTrace && Error.captureStackTrace(this, s);
  }
  e(s, !0), Object.defineProperties(s.prototype, {
    code: {
      enumerable: !0,
      get: function() {
        var f = r.indexOf(this.name);
        return o(f) ? f : 0;
      }
    }
  });
  for (var a = {
    INDEX_SIZE_ERR: 1,
    DOMSTRING_SIZE_ERR: 2,
    HIERARCHY_REQUEST_ERR: 3,
    WRONG_DOCUMENT_ERR: 4,
    INVALID_CHARACTER_ERR: 5,
    NO_DATA_ALLOWED_ERR: 6,
    NO_MODIFICATION_ALLOWED_ERR: 7,
    NOT_FOUND_ERR: 8,
    NOT_SUPPORTED_ERR: 9,
    INUSE_ATTRIBUTE_ERR: 10,
    INVALID_STATE_ERR: 11,
    SYNTAX_ERR: 12,
    INVALID_MODIFICATION_ERR: 13,
    NAMESPACE_ERR: 14,
    INVALID_ACCESS_ERR: 15,
    VALIDATION_ERR: 16,
    TYPE_MISMATCH_ERR: 17,
    SECURITY_ERR: 18,
    NETWORK_ERR: 19,
    ABORT_ERR: 20,
    URL_MISMATCH_ERR: 21,
    QUOTA_EXCEEDED_ERR: 22,
    TIMEOUT_ERR: 23,
    INVALID_NODE_TYPE_ERR: 24,
    DATA_CLONE_ERR: 25
  }, l = Object.entries(a), c = 0; c < l.length; c++) {
    var u = l[c][0];
    s[u] = l[c][1];
  }
  function p(f, h) {
    this.message = f, this.locator = h, Error.captureStackTrace && Error.captureStackTrace(this, p);
  }
  return e(p), ni.DOMException = s, ni.DOMExceptionName = n, ni.ExceptionCode = a, ni.ParseError = p, ni;
}
var mt = {}, Te = {}, ef;
function Tg() {
  if (ef) return Te;
  ef = 1;
  function t(Ge) {
    try {
      typeof Ge != "function" && (Ge = RegExp);
      var dt = new Ge("ðŒ†", "u").exec("ðŒ†");
      return !!dt && dt[0].length === 2;
    } catch {
    }
    return !1;
  }
  var e = t();
  function n(Ge) {
    if (Ge.source[0] !== "[")
      throw new Error(Ge + " can not be used with chars");
    return Ge.source.slice(1, Ge.source.lastIndexOf("]"));
  }
  function r(Ge, dt) {
    if (Ge.source[0] !== "[")
      throw new Error("/" + Ge.source + "/ can not be used with chars_without");
    if (!dt || typeof dt != "string")
      throw new Error(JSON.stringify(dt) + " is not a valid search");
    if (Ge.source.indexOf(dt) === -1)
      throw new Error('"' + dt + '" is not is /' + Ge.source + "/");
    if (dt === "-" && Ge.source.indexOf(dt) !== 1)
      throw new Error('"' + dt + '" is not at the first postion of /' + Ge.source + "/");
    return new RegExp(Ge.source.replace(dt, ""), e ? "u" : "");
  }
  function o(Ge) {
    var dt = this;
    return new RegExp(
      Array.prototype.slice.call(arguments).map(function(Zt) {
        var en = typeof Zt == "string";
        if (en && dt === void 0 && Zt === "|")
          throw new Error("use regg instead of reg to wrap expressions with `|`!");
        return en ? Zt : Zt.source;
      }).join(""),
      e ? "mu" : "m"
    );
  }
  function i(Ge) {
    if (arguments.length === 0)
      throw new Error("no parameters provided");
    return o.apply(i, ["(?:"].concat(Array.prototype.slice.call(arguments), [")"]));
  }
  var s = "ï¿½", a = /[-\x09\x0A\x0D\x20-\x2C\x2E-\uD7FF\uE000-\uFFFD]/;
  e && (a = o("[", n(a), "\\u{10000}-\\u{10FFFF}", "]"));
  var l = /[\x20\x09\x0D\x0A]/, c = n(l), u = o(l, "+"), p = o(l, "*"), f = /[:_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  e && (f = o("[", n(f), "\\u{10000}-\\u{10FFFF}", "]"));
  var h = n(f), g = o("[", h, n(/[-.0-9\xB7]/), n(/[\u0300-\u036F\u203F-\u2040]/), "]"), b = o(f, g, "*"), _ = o(g, "+"), x = o("&", b, ";"), y = i(/&#[0-9]+;|&#x[0-9a-fA-F]+;/), A = i(x, "|", y), P = o("%", b, ";"), V = i(
    o('"', i(/[^%&"]/, "|", P, "|", A), "*", '"'),
    "|",
    o("'", i(/[^%&']/, "|", P, "|", A), "*", "'")
  ), O = i('"', i(/[^<&"]/, "|", A), "*", '"', "|", "'", i(/[^<&']/, "|", A), "*", "'"), U = r(f, ":"), B = r(g, ":"), F = o(U, B, "*"), K = o(F, i(":", F), "?"), E = o("^", K, "$"), S = o("(", K, ")"), k = i(/"[^"]*"|'[^']*'/), I = o(/^<\?/, "(", b, ")", i(u, "(", a, "*?)"), "?", /\?>/), N = /[\x20\x0D\x0Aa-zA-Z0-9-'()+,./:=?;!*#@$_%]/, T = i('"', N, '*"', "|", "'", r(N, "'"), "*'"), $ = "<!--", L = "-->", J = o($, i(r(a, "-"), "|", o("-", r(a, "-"))), "*", L), G = "#PCDATA", W = i(
    o(/\(/, p, G, i(p, /\|/, p, K), "*", p, /\)\*/),
    "|",
    o(/\(/, p, G, p, /\)/)
  ), ee = /[?*+]?/, te = o(
    /\([^>]+\)/,
    ee
    /*regg(choice, '|', seq), _children_quantity*/
  ), Z = i("EMPTY", "|", "ANY", "|", W, "|", te), Y = "<!ELEMENT", le = o(Y, u, i(K, "|", P), u, i(Z, "|", P), p, ">"), de = o("NOTATION", u, /\(/, p, b, i(p, /\|/, p, b), "*", p, /\)/), pe = o(/\(/, p, _, i(p, /\|/, p, _), "*", p, /\)/), _e = i(de, "|", pe), be = i(/CDATA|ID|IDREF|IDREFS|ENTITY|ENTITIES|NMTOKEN|NMTOKENS/, "|", _e), ye = i(/#REQUIRED|#IMPLIED/, "|", i(i("#FIXED", u), "?", O)), se = i(u, b, u, be, u, ye), Se = "<!ATTLIST", Fe = o(Se, u, b, se, "*", p, ">"), re = "about:legacy-compat", Ce = i('"' + re + '"', "|", "'" + re + "'"), Re = "SYSTEM", je = "PUBLIC", Je = i(i(Re, u, k), "|", i(je, u, T, u, k)), wt = o(
    "^",
    i(
      i(Re, u, "(?<SystemLiteralOnly>", k, ")"),
      "|",
      i(je, u, "(?<PubidLiteral>", T, ")", u, "(?<SystemLiteral>", k, ")")
    )
  ), ut = i(u, "NDATA", u, b), yt = i(V, "|", i(Je, ut, "?")), Me = "<!ENTITY", Nt = o(Me, u, b, u, yt, p, ">"), nt = i(V, "|", Je), Pn = o(Me, u, "%", u, b, u, nt, p, ">"), mn = i(Nt, "|", Pn), ln = o(je, u, T), bn = o("<!NOTATION", u, b, u, i(Je, "|", ln), p, ">"), ge = o(p, "=", p), ze = /1[.]\d+/, Tt = o(u, "version", ge, i("'", ze, "'", "|", '"', ze, '"')), Ot = /[A-Za-z][-A-Za-z0-9._]*/, vn = i(u, "encoding", ge, i('"', Ot, '"', "|", "'", Ot, "'")), yn = i(u, "standalone", ge, i("'", i("yes", "|", "no"), "'", "|", '"', i("yes", "|", "no"), '"')), $n = o(/^<\?xml/, Tt, vn, "?", yn, "?", p, /\?>/), xn = "<!DOCTYPE", _n = "<![CDATA[", qt = "]]>", Cn = /<!\[CDATA\[/, En = /\]\]>/, cn = o(a, "*?", En), er = o(Cn, cn);
  return Te.chars = n, Te.chars_without = r, Te.detectUnicodeSupport = t, Te.reg = o, Te.regg = i, Te.ABOUT_LEGACY_COMPAT = re, Te.ABOUT_LEGACY_COMPAT_SystemLiteral = Ce, Te.AttlistDecl = Fe, Te.CDATA_START = _n, Te.CDATA_END = qt, Te.CDSect = er, Te.Char = a, Te.Comment = J, Te.COMMENT_START = $, Te.COMMENT_END = L, Te.DOCTYPE_DECL_START = xn, Te.elementdecl = le, Te.EntityDecl = mn, Te.EntityValue = V, Te.ExternalID = Je, Te.ExternalID_match = wt, Te.Name = b, Te.NotationDecl = bn, Te.Reference = A, Te.PEReference = P, Te.PI = I, Te.PUBLIC = je, Te.PubidLiteral = T, Te.QName = K, Te.QName_exact = E, Te.QName_group = S, Te.S = u, Te.SChar_s = c, Te.S_OPT = p, Te.SYSTEM = Re, Te.SystemLiteral = k, Te.UNICODE_REPLACEMENT_CHARACTER = s, Te.UNICODE_SUPPORT = e, Te.XMLDecl = $n, Te;
}
var tf;
function Ag() {
  if (tf) return mt;
  tf = 1;
  var t = $i(), e = t.find, n = t.hasDefaultHTMLNamespace, r = t.hasOwn, o = t.isHTMLMimeType, i = t.isHTMLRawTextElement, s = t.isHTMLVoidElement, a = t.MIME_TYPE, l = t.NAMESPACE, c = Symbol(), u = Ll(), p = u.DOMException, f = u.DOMExceptionName, h = Tg();
  function g(m) {
    if (m !== c)
      throw new TypeError("Illegal constructor");
  }
  function b(m) {
    return m !== "";
  }
  function _(m) {
    return m ? m.split(/[\t\n\f\r ]+/).filter(b) : [];
  }
  function x(m, v) {
    return r(m, v) || (m[v] = !0), m;
  }
  function y(m) {
    if (!m) return [];
    var v = _(m);
    return Object.keys(v.reduce(x, {}));
  }
  function A(m) {
    return function(v) {
      return m && m.indexOf(v) !== -1;
    };
  }
  function P(m) {
    if (!h.QName_exact.test(m))
      throw new p(p.INVALID_CHARACTER_ERR, 'invalid character in qualified name "' + m + '"');
  }
  function V(m, v) {
    P(v), m = m || null;
    var D = null, H = v;
    if (v.indexOf(":") >= 0) {
      var ne = v.split(":");
      D = ne[0], H = ne[1];
    }
    if (D !== null && m === null)
      throw new p(p.NAMESPACE_ERR, "prefix is non-null and namespace is null");
    if (D === "xml" && m !== t.NAMESPACE.XML)
      throw new p(p.NAMESPACE_ERR, 'prefix is "xml" and namespace is not the XML namespace');
    if ((D === "xmlns" || v === "xmlns") && m !== t.NAMESPACE.XMLNS)
      throw new p(
        p.NAMESPACE_ERR,
        'either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace'
      );
    if (m === t.NAMESPACE.XMLNS && D !== "xmlns" && v !== "xmlns")
      throw new p(
        p.NAMESPACE_ERR,
        'namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns"'
      );
    return [m, D, H];
  }
  function O(m, v) {
    for (var D in m)
      r(m, D) && (v[D] = m[D]);
  }
  function U(m, v) {
    var D = m.prototype;
    if (!(D instanceof v)) {
      let H = function() {
      };
      H.prototype = v.prototype, H = new H(), O(D, H), m.prototype = D = H;
    }
    D.constructor != m && (typeof m != "function" && console.error("unknown Class:" + m), D.constructor = m);
  }
  var B = {}, F = B.ELEMENT_NODE = 1, K = B.ATTRIBUTE_NODE = 2, E = B.TEXT_NODE = 3, S = B.CDATA_SECTION_NODE = 4, k = B.ENTITY_REFERENCE_NODE = 5, I = B.ENTITY_NODE = 6, N = B.PROCESSING_INSTRUCTION_NODE = 7, T = B.COMMENT_NODE = 8, $ = B.DOCUMENT_NODE = 9, L = B.DOCUMENT_TYPE_NODE = 10, J = B.DOCUMENT_FRAGMENT_NODE = 11, G = B.NOTATION_NODE = 12, W = t.freeze({
    DOCUMENT_POSITION_DISCONNECTED: 1,
    DOCUMENT_POSITION_PRECEDING: 2,
    DOCUMENT_POSITION_FOLLOWING: 4,
    DOCUMENT_POSITION_CONTAINS: 8,
    DOCUMENT_POSITION_CONTAINED_BY: 16,
    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32
  });
  function ee(m, v) {
    if (v.length < m.length) return ee(v, m);
    var D = null;
    for (var H in m) {
      if (m[H] !== v[H]) return D;
      D = m[H];
    }
    return D;
  }
  function te(m) {
    return m.guid || (m.guid = Math.random()), m.guid;
  }
  function Z() {
  }
  Z.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1
     * inclusive.
     *
     * @type {number}
     */
    length: 0,
    /**
     * Returns the item at `index`. If index is greater than or equal to the number of nodes in
     * the list, this returns null.
     *
     * @param index
     * Unsigned long Index into the collection.
     * @returns {Node | null}
     * The node at position `index` in the NodeList,
     * or null if that is not a valid index.
     */
    item: function(m) {
      return m >= 0 && m < this.length ? this[m] : null;
    },
    /**
     * Returns a string representation of the NodeList.
     *
     * @param {unknown} nodeFilter
     * __A filter function? Not implemented according to the spec?__.
     * @returns {string}
     * A string representation of the NodeList.
     */
    toString: function(m) {
      for (var v = [], D = 0; D < this.length; D++)
        en(this[D], v, m);
      return v.join("");
    },
    /**
     * Filters the NodeList based on a predicate.
     *
     * @param {function(Node): boolean} predicate
     * - A predicate function to filter the NodeList.
     * @returns {Node[]}
     * An array of nodes that satisfy the predicate.
     * @private
     */
    filter: function(m) {
      return Array.prototype.filter.call(this, m);
    },
    /**
     * Returns the first index at which a given node can be found in the NodeList, or -1 if it is
     * not present.
     *
     * @param {Node} item
     * - The Node item to locate in the NodeList.
     * @returns {number}
     * The first index of the node in the NodeList; -1 if not found.
     * @private
     */
    indexOf: function(m) {
      return Array.prototype.indexOf.call(this, m);
    }
  }, Z.prototype[Symbol.iterator] = function() {
    var m = this, v = 0;
    return {
      next: function() {
        return v < m.length ? {
          value: m[v++],
          done: !1
        } : {
          done: !0
        };
      },
      return: function() {
        return {
          done: !0
        };
      }
    };
  };
  function Y(m, v) {
    this._node = m, this._refresh = v, le(this);
  }
  function le(m) {
    var v = m._node._inc || m._node.ownerDocument._inc;
    if (m._inc !== v) {
      var D = m._refresh(m._node);
      if (Sn(m, "length", D.length), !m.$$length || D.length < m.$$length)
        for (var H = D.length; H in m; H++)
          r(m, H) && delete m[H];
      O(D, m), m._inc = v;
    }
  }
  Y.prototype.item = function(m) {
    return le(this), this[m] || null;
  }, U(Y, Z);
  function de() {
  }
  function pe(m, v) {
    for (var D = 0; D < m.length; ) {
      if (m[D] === v)
        return D;
      D++;
    }
  }
  function _e(m, v, D, H) {
    if (H ? v[pe(v, H)] = D : (v[v.length] = D, v.length++), m) {
      D.ownerElement = m;
      var ne = m.ownerDocument;
      ne && (H && Re(ne, m, H), Ce(ne, m, D));
    }
  }
  function be(m, v, D) {
    var H = pe(v, D);
    if (H >= 0) {
      for (var ne = v.length - 1; H <= ne; )
        v[H] = v[++H];
      if (v.length = ne, m) {
        var ae = m.ownerDocument;
        ae && Re(ae, m, D), D.ownerElement = null;
      }
    }
  }
  de.prototype = {
    length: 0,
    item: Z.prototype.item,
    /**
     * Get an attribute by name. Note: Name is in lower case in case of HTML namespace and
     * document.
     *
     * @param {string} localName
     * The local name of the attribute.
     * @returns {Attr | null}
     * The attribute with the given local name, or null if no such attribute exists.
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name
     */
    getNamedItem: function(m) {
      this._ownerElement && this._ownerElement._isInHTMLDocumentAndNamespace() && (m = m.toLowerCase());
      for (var v = 0; v < this.length; ) {
        var D = this[v];
        if (D.nodeName === m)
          return D;
        v++;
      }
      return null;
    },
    /**
     * Set an attribute.
     *
     * @param {Attr} attr
     * The attribute to set.
     * @returns {Attr | null}
     * The old attribute with the same local name and namespace URI as the new one, or null if no
     * such attribute exists.
     * @throws {DOMException}
     * With code:
     * - {@link INUSE_ATTRIBUTE_ERR} - If the attribute is already an attribute of another
     * element.
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
     */
    setNamedItem: function(m) {
      var v = m.ownerElement;
      if (v && v !== this._ownerElement)
        throw new p(p.INUSE_ATTRIBUTE_ERR);
      var D = this.getNamedItemNS(m.namespaceURI, m.localName);
      return D === m ? m : (_e(this._ownerElement, this, m, D), D);
    },
    /**
     * Set an attribute, replacing an existing attribute with the same local name and namespace
     * URI if one exists.
     *
     * @param {Attr} attr
     * The attribute to set.
     * @returns {Attr | null}
     * The old attribute with the same local name and namespace URI as the new one, or null if no
     * such attribute exists.
     * @throws {DOMException}
     * Throws a DOMException with the name "InUseAttributeError" if the attribute is already an
     * attribute of another element.
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
     */
    setNamedItemNS: function(m) {
      return this.setNamedItem(m);
    },
    /**
     * Removes an attribute specified by the local name.
     *
     * @param {string} localName
     * The local name of the attribute to be removed.
     * @returns {Attr}
     * The attribute node that was removed.
     * @throws {DOMException}
     * With code:
     * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given name is found.
     * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditem
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name
     */
    removeNamedItem: function(m) {
      var v = this.getNamedItem(m);
      if (!v)
        throw new p(p.NOT_FOUND_ERR, m);
      return be(this._ownerElement, this, v), v;
    },
    /**
     * Removes an attribute specified by the namespace and local name.
     *
     * @param {string | null} namespaceURI
     * The namespace URI of the attribute to be removed.
     * @param {string} localName
     * The local name of the attribute to be removed.
     * @returns {Attr}
     * The attribute node that was removed.
     * @throws {DOMException}
     * With code:
     * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given namespace URI and local
     * name is found.
     * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditemns
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace
     */
    removeNamedItemNS: function(m, v) {
      var D = this.getNamedItemNS(m, v);
      if (!D)
        throw new p(p.NOT_FOUND_ERR, m ? m + " : " + v : v);
      return be(this._ownerElement, this, D), D;
    },
    /**
     * Get an attribute by namespace and local name.
     *
     * @param {string | null} namespaceURI
     * The namespace URI of the attribute.
     * @param {string} localName
     * The local name of the attribute.
     * @returns {Attr | null}
     * The attribute with the given namespace URI and local name, or null if no such attribute
     * exists.
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace
     */
    getNamedItemNS: function(m, v) {
      m || (m = null);
      for (var D = 0; D < this.length; ) {
        var H = this[D];
        if (H.localName === v && H.namespaceURI === m)
          return H;
        D++;
      }
      return null;
    }
  }, de.prototype[Symbol.iterator] = function() {
    var m = this, v = 0;
    return {
      next: function() {
        return v < m.length ? {
          value: m[v++],
          done: !1
        } : {
          done: !0
        };
      },
      return: function() {
        return {
          done: !0
        };
      }
    };
  };
  function ye() {
  }
  ye.prototype = {
    /**
     * Test if the DOM implementation implements a specific feature and version, as specified in
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMFeatures DOM Features}.
     *
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given
     * feature is supported. The different implementations fairly diverged in what kind of
     * features were reported. The latest version of the spec settled to force this method to
     * always return true, where the functionality was accurate and in use.
     *
     * @deprecated
     * It is deprecated and modern browsers return true in all cases.
     * @function DOMImplementation#hasFeature
     * @param {string} feature
     * The name of the feature to test.
     * @param {string} [version]
     * This is the version number of the feature to test.
     * @returns {boolean}
     * Always returns true.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-5CED94D7 DOM Level 3 Core
     */
    hasFeature: function(m, v) {
      return !0;
    },
    /**
     * Creates a DOM Document object of the specified type with its document element. Note that
     * based on the {@link DocumentType}
     * given to create the document, the implementation may instantiate specialized
     * {@link Document} objects that support additional features than the "Core", such as "HTML"
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML}.
     * On the other hand, setting the {@link DocumentType} after the document was created makes
     * this very unlikely to happen. Alternatively, specialized {@link Document} creation methods,
     * such as createHTMLDocument
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML},
     * can be used to obtain specific types of {@link Document} objects.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document`
     * instance (with it's `type` set to `'xml'`).
     * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     *
     * @function DOMImplementation.createDocument
     * @param {string | null} namespaceURI
     * The
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-namespaceURI namespace URI}
     * of the document element to create or null.
     * @param {string | null} qualifiedName
     * The
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified name}
     * of the document element to be created or null.
     * @param {DocumentType | null} [doctype=null]
     * The type of document to be created or null. When doctype is not null, its
     * {@link Node#ownerDocument} attribute is set to the document being created. Default is
     * `null`
     * @returns {Document}
     * A new {@link Document} object with its document element. If the NamespaceURI,
     * qualifiedName, and doctype are null, the returned {@link Document} is empty with no
     * document element.
     * @throws {DOMException}
     * With code:
     *
     * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
     * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
     * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed, if the qualifiedName has a
     * prefix and the namespaceURI is null, or if the qualifiedName is null and the namespaceURI
     * is different from null, or if the qualifiedName has a prefix that is "xml" and the
     * namespaceURI is different from "{@link http://www.w3.org/XML/1998/namespace}"
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#Namespaces XML Namespaces},
     * or if the DOM implementation does not support the "XML" feature but a non-null namespace
     * URI was provided, since namespaces were defined by XML.
     * - `WRONG_DOCUMENT_ERR`: Raised if doctype has already been used with a different document
     * or was created from a different implementation.
     * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
     * "XML" and the language exposed through the Document does not support XML Namespaces (such
     * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
     * @since DOM Level 2.
     * @see {@link #createHTMLDocument}
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument DOM Living Standard
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-2-Core-DOM-createDocument DOM
     *      Level 3 Core
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM
     *      Level 2 Core (initial)
     */
    createDocument: function(m, v, D) {
      var H = a.XML_APPLICATION;
      m === l.HTML ? H = a.XML_XHTML_APPLICATION : m === l.SVG && (H = a.XML_SVG_IMAGE);
      var ne = new re(c, { contentType: H });
      if (ne.implementation = this, ne.childNodes = new Z(), ne.doctype = D || null, D && ne.appendChild(D), v) {
        var ae = ne.createElementNS(m, v);
        ne.appendChild(ae);
      }
      return ne;
    },
    /**
     * Creates an empty DocumentType node. Entity declarations and notations are not made
     * available. Entity reference expansions and default attribute additions do not occur.
     *
     * **This behavior is slightly different from the one in the specs**:
     * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - `publicId` and `systemId` contain the raw data including any possible quotes,
     *   so they can always be serialized back to the original value
     * - `internalSubset` contains the raw string between `[` and `]` if present,
     *   but is not parsed or validated in any form.
     *
     * @function DOMImplementation#createDocumentType
     * @param {string} qualifiedName
     * The {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified
     * name} of the document type to be created.
     * @param {string} [publicId]
     * The external subset public identifier.
     * @param {string} [systemId]
     * The external subset system identifier.
     * @param {string} [internalSubset]
     * the internal subset or an empty string if it is not present
     * @returns {DocumentType}
     * A new {@link DocumentType} node with {@link Node#ownerDocument} set to null.
     * @throws {DOMException}
     * With code:
     *
     * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
     * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
     * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed.
     * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
     * "XML" and the language exposed through the Document does not support XML Namespaces (such
     * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
     * @since DOM Level 2.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType
     *      MDN
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living
     *      Standard
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-3-Core-DOM-createDocType DOM
     *      Level 3 Core
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM
     *      Level 2 Core
     * @see https://github.com/xmldom/xmldom/blob/master/CHANGELOG.md#050
     * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-Core-DocType-internalSubset
     * @prettierignore
     */
    createDocumentType: function(m, v, D, H) {
      P(m);
      var ne = new xn(c);
      return ne.name = m, ne.nodeName = m, ne.publicId = v || "", ne.systemId = D || "", ne.internalSubset = H || "", ne.childNodes = new Z(), ne;
    },
    /**
     * Returns an HTML document, that might already have a basic DOM structure.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - If the first argument is `false` no initial nodes are added (steps 3-7 in the specs are
     * omitted)
     * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     *
     * @param {string | false} [title]
     * A string containing the title to give the new HTML document.
     * @returns {Document}
     * The HTML document.
     * @since WHATWG Living Standard.
     * @see {@link #createDocument}
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument
     * @see https://dom.spec.whatwg.org/#html-document
     */
    createHTMLDocument: function(m) {
      var v = new re(c, { contentType: a.HTML });
      if (v.implementation = this, v.childNodes = new Z(), m !== !1) {
        v.doctype = this.createDocumentType("html"), v.doctype.ownerDocument = v, v.appendChild(v.doctype);
        var D = v.createElement("html");
        v.appendChild(D);
        var H = v.createElement("head");
        if (D.appendChild(H), typeof m == "string") {
          var ne = v.createElement("title");
          ne.appendChild(v.createTextNode(m)), H.appendChild(ne);
        }
        D.appendChild(v.createElement("body"));
      }
      return v;
    }
  };
  function se(m) {
    g(m);
  }
  se.prototype = {
    /**
     * The first child of this node.
     *
     * @type {Node | null}
     */
    firstChild: null,
    /**
     * The last child of this node.
     *
     * @type {Node | null}
     */
    lastChild: null,
    /**
     * The previous sibling of this node.
     *
     * @type {Node | null}
     */
    previousSibling: null,
    /**
     * The next sibling of this node.
     *
     * @type {Node | null}
     */
    nextSibling: null,
    /**
     * The parent node of this node.
     *
     * @type {Node | null}
     */
    parentNode: null,
    /**
     * The parent element of this node.
     *
     * @type {Element | null}
     */
    get parentElement() {
      return this.parentNode && this.parentNode.nodeType === this.ELEMENT_NODE ? this.parentNode : null;
    },
    /**
     * The child nodes of this node.
     *
     * @type {NodeList}
     */
    childNodes: null,
    /**
     * The document object associated with this node.
     *
     * @type {Document | null}
     */
    ownerDocument: null,
    /**
     * The value of this node.
     *
     * @type {string | null}
     */
    nodeValue: null,
    /**
     * The namespace URI of this node.
     *
     * @type {string | null}
     */
    namespaceURI: null,
    /**
     * The prefix of the namespace for this node.
     *
     * @type {string | null}
     */
    prefix: null,
    /**
     * The local part of the qualified name of this node.
     *
     * @type {string | null}
     */
    localName: null,
    /**
     * The baseURI is currently always `about:blank`,
     * since that's what happens when you create a document from scratch.
     *
     * @type {'about:blank'}
     */
    baseURI: "about:blank",
    /**
     * Is true if this node is part of a document.
     *
     * @type {boolean}
     */
    get isConnected() {
      var m = this.getRootNode();
      return m && m.nodeType === m.DOCUMENT_NODE;
    },
    /**
     * Checks whether `other` is an inclusive descendant of this node.
     *
     * @param {Node | null | undefined} other
     * The node to check.
     * @returns {boolean}
     * True if `other` is an inclusive descendant of this node; false otherwise.
     * @see https://dom.spec.whatwg.org/#dom-node-contains
     */
    contains: function(m) {
      if (!m) return !1;
      var v = m;
      do {
        if (this === v) return !0;
        v = m.parentNode;
      } while (v);
      return !1;
    },
    /**
     * @typedef GetRootNodeOptions
     * @property {boolean} [composed=false]
     */
    /**
     * Searches for the root node of this node.
     *
     * **This behavior is slightly different from the in the specs**:
     * - ignores `options.composed`, since `ShadowRoot`s are unsupported, always returns root.
     *
     * @param {GetRootNodeOptions} [options]
     * @returns {Node}
     * Root node.
     * @see https://dom.spec.whatwg.org/#dom-node-getrootnode
     * @see https://dom.spec.whatwg.org/#concept-shadow-including-root
     */
    getRootNode: function(m) {
      var v = this;
      do {
        if (!v.parentNode)
          return v;
        v = v.parentNode;
      } while (v);
    },
    /**
     * Checks whether the given node is equal to this node.
     *
     * @param {Node} [otherNode]
     * @see https://dom.spec.whatwg.org/#concept-node-equals
     */
    isEqualNode: function(m) {
      if (!m || this.nodeType !== m.nodeType) return !1;
      switch (this.nodeType) {
        case this.DOCUMENT_TYPE_NODE:
          if (this.name !== m.name || this.publicId !== m.publicId || this.systemId !== m.systemId) return !1;
          break;
        case this.ELEMENT_NODE:
          if (this.namespaceURI !== m.namespaceURI || this.prefix !== m.prefix || this.localName !== m.localName || this.attributes.length !== m.attributes.length) return !1;
          for (var v = 0; v < this.attributes.length; v++) {
            var D = this.attributes.item(v);
            if (!D.isEqualNode(m.getAttributeNodeNS(D.namespaceURI, D.localName)))
              return !1;
          }
          break;
        case this.ATTRIBUTE_NODE:
          if (this.namespaceURI !== m.namespaceURI || this.localName !== m.localName || this.value !== m.value) return !1;
          break;
        case this.PROCESSING_INSTRUCTION_NODE:
          if (this.target !== m.target || this.data !== m.data)
            return !1;
          break;
        case this.TEXT_NODE:
        case this.COMMENT_NODE:
          if (this.data !== m.data) return !1;
          break;
      }
      if (this.childNodes.length !== m.childNodes.length)
        return !1;
      for (var v = 0; v < this.childNodes.length; v++)
        if (!this.childNodes[v].isEqualNode(m.childNodes[v]))
          return !1;
      return !0;
    },
    /**
     * Checks whether or not the given node is this node.
     *
     * @param {Node} [otherNode]
     */
    isSameNode: function(m) {
      return this === m;
    },
    /**
     * Inserts a node before a reference node as a child of this node.
     *
     * @param {Node} newChild
     * The new child node to be inserted.
     * @param {Node | null} refChild
     * The reference node before which newChild will be inserted.
     * @returns {Node}
     * The new child node successfully inserted.
     * @throws {DOMException}
     * Throws a DOMException if inserting the node would result in a DOM tree that is not
     * well-formed, or if `child` is provided but is not a child of `parent`.
     * See {@link _insertBefore} for more details.
     * @since Modified in DOM L2
     */
    insertBefore: function(m, v) {
      return ge(this, m, v);
    },
    /**
     * Replaces an old child node with a new child node within this node.
     *
     * @param {Node} newChild
     * The new node that is to replace the old node.
     * If it already exists in the DOM, it is removed from its original position.
     * @param {Node} oldChild
     * The existing child node to be replaced.
     * @returns {Node}
     * Returns the replaced child node.
     * @throws {DOMException}
     * Throws a DOMException if replacing the node would result in a DOM tree that is not
     * well-formed, or if `oldChild` is not a child of `this`.
     * This can also occur if the pre-replacement validity assertion fails.
     * See {@link _insertBefore}, {@link Node.removeChild}, and
     * {@link assertPreReplacementValidityInDocument} for more details.
     * @see https://dom.spec.whatwg.org/#concept-node-replace
     */
    replaceChild: function(m, v) {
      ge(this, m, v, bn), v && this.removeChild(v);
    },
    /**
     * Removes an existing child node from this node.
     *
     * @param {Node} oldChild
     * The child node to be removed.
     * @returns {Node}
     * Returns the removed child node.
     * @throws {DOMException}
     * Throws a DOMException if `oldChild` is not a child of `this`.
     * See {@link _removeChild} for more details.
     */
    removeChild: function(m) {
      return Je(this, m);
    },
    /**
     * Appends a child node to this node.
     *
     * @param {Node} newChild
     * The child node to be appended to this node.
     * If it already exists in the DOM, it is removed from its original position.
     * @returns {Node}
     * Returns the appended child node.
     * @throws {DOMException}
     * Throws a DOMException if appending the node would result in a DOM tree that is not
     * well-formed, or if `newChild` is not a valid Node.
     * See {@link insertBefore} for more details.
     */
    appendChild: function(m) {
      return this.insertBefore(m, null);
    },
    /**
     * Determines whether this node has any child nodes.
     *
     * @returns {boolean}
     * Returns true if this node has any child nodes, and false otherwise.
     */
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    /**
     * Creates a copy of the calling node.
     *
     * @param {boolean} deep
     * If true, the contents of the node are recursively copied.
     * If false, only the node itself (and its attributes, if it is an element) are copied.
     * @returns {Node}
     * Returns the newly created copy of the node.
     * @throws {DOMException}
     * May throw a DOMException if operations within {@link Element#setAttributeNode} or
     * {@link Node#appendChild} (which are potentially invoked in this method) do not meet their
     * specific constraints.
     * @see {@link cloneNode}
     */
    cloneNode: function(m) {
      return $r(this.ownerDocument || this, this, m);
    },
    /**
     * Puts the specified node and all of its subtree into a "normalized" form. In a normalized
     * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.
     *
     * Specifically, this method merges any adjacent text nodes (i.e., nodes for which `nodeType`
     * is `TEXT_NODE`) into a single node with the combined data. It also removes any empty text
     * nodes.
     *
     * This method operates recursively, so it also normalizes any and all descendent nodes within
     * the subtree.
     *
     * @throws {DOMException}
     * May throw a DOMException if operations within removeChild or appendData (which are
     * potentially invoked in this method) do not meet their specific constraints.
     * @since Modified in DOM Level 2
     * @see {@link Node.removeChild}
     * @see {@link CharacterData.appendData}
     */
    normalize: function() {
      for (var m = this.firstChild; m; ) {
        var v = m.nextSibling;
        v && v.nodeType == E && m.nodeType == E ? (this.removeChild(v), m.appendData(v.data)) : (m.normalize(), m = v);
      }
    },
    /**
     * Checks whether the DOM implementation implements a specific feature and its version.
     *
     * @deprecated
     * Since `DOMImplementation.hasFeature` is deprecated and always returns true.
     * @param {string} feature
     * The package name of the feature to test. This is the same name that can be passed to the
     * method `hasFeature` on `DOMImplementation`.
     * @param {string} version
     * This is the version number of the package name to test.
     * @returns {boolean}
     * Returns true in all cases in the current implementation.
     * @since Introduced in DOM Level 2
     * @see {@link DOMImplementation.hasFeature}
     */
    isSupported: function(m, v) {
      return this.ownerDocument.implementation.hasFeature(m, v);
    },
    /**
     * Look up the prefix associated to the given namespace URI, starting from this node.
     * **The default namespace declarations are ignored by this method.**
     * See Namespace Prefix Lookup for details on the algorithm used by this method.
     *
     * **This behavior is different from the in the specs**:
     * - no node type specific handling
     * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
     *
     * @param {string | null} namespaceURI
     * The namespace URI for which to find the associated prefix.
     * @returns {string | null}
     * The associated prefix, if found; otherwise, null.
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
     * @see https://github.com/xmldom/xmldom/issues/322
     * @prettierignore
     */
    lookupPrefix: function(m) {
      for (var v = this; v; ) {
        var D = v._nsMap;
        if (D) {
          for (var H in D)
            if (r(D, H) && D[H] === m)
              return H;
        }
        v = v.nodeType == K ? v.ownerDocument : v.parentNode;
      }
      return null;
    },
    /**
     * This function is used to look up the namespace URI associated with the given prefix,
     * starting from this node.
     *
     * **This behavior is different from the in the specs**:
     * - no node type specific handling
     * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
     *
     * @param {string | null} prefix
     * The prefix for which to find the associated namespace URI.
     * @returns {string | null}
     * The associated namespace URI, if found; otherwise, null.
     * @since DOM Level 3
     * @see https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI
     * @prettierignore
     */
    lookupNamespaceURI: function(m) {
      for (var v = this; v; ) {
        var D = v._nsMap;
        if (D && r(D, m))
          return D[m];
        v = v.nodeType == K ? v.ownerDocument : v.parentNode;
      }
      return null;
    },
    /**
     * Determines whether the given namespace URI is the default namespace.
     *
     * The function works by looking up the prefix associated with the given namespace URI. If no
     * prefix is found (i.e., the namespace URI is not registered in the namespace map of this
     * node or any of its ancestors), it returns `true`, implying the namespace URI is considered
     * the default.
     *
     * **This behavior is different from the in the specs**:
     * - no node type specific handling
     * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
     *
     * @param {string | null} namespaceURI
     * The namespace URI to be checked.
     * @returns {boolean}
     * Returns true if the given namespace URI is the default namespace, false otherwise.
     * @since DOM Level 3
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isDefaultNamespace
     * @see https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
     * @prettierignore
     */
    isDefaultNamespace: function(m) {
      var v = this.lookupPrefix(m);
      return v == null;
    },
    /**
     * Compares the reference node with a node with regard to their position in the document and
     * according to the document order.
     *
     * @param {Node} other
     * The node to compare the reference node to.
     * @returns {number}
     * Returns how the node is positioned relatively to the reference node according to the
     * bitmask. 0 if reference node and given node are the same.
     * @since DOM Level 3
     * @see https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-compare
     * @see https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
     */
    compareDocumentPosition: function(m) {
      if (this === m) return 0;
      var v = m, D = this, H = null, ne = null;
      if (v instanceof Tt && (H = v, v = H.ownerElement), D instanceof Tt && (ne = D, D = ne.ownerElement, H && v && D === v))
        for (var ae = 0, Oe; Oe = D.attributes[ae]; ae++) {
          if (Oe === H)
            return W.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + W.DOCUMENT_POSITION_PRECEDING;
          if (Oe === ne)
            return W.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + W.DOCUMENT_POSITION_FOLLOWING;
        }
      if (!v || !D || D.ownerDocument !== v.ownerDocument)
        return W.DOCUMENT_POSITION_DISCONNECTED + W.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + (te(D.ownerDocument) > te(v.ownerDocument) ? W.DOCUMENT_POSITION_FOLLOWING : W.DOCUMENT_POSITION_PRECEDING);
      if (ne && v === D)
        return W.DOCUMENT_POSITION_CONTAINS + W.DOCUMENT_POSITION_PRECEDING;
      if (H && v === D)
        return W.DOCUMENT_POSITION_CONTAINED_BY + W.DOCUMENT_POSITION_FOLLOWING;
      for (var gt = [], _t = v.parentNode; _t; ) {
        if (!ne && _t === D)
          return W.DOCUMENT_POSITION_CONTAINED_BY + W.DOCUMENT_POSITION_FOLLOWING;
        gt.push(_t), _t = _t.parentNode;
      }
      gt.reverse();
      for (var jt = [], At = D.parentNode; At; ) {
        if (!H && At === v)
          return W.DOCUMENT_POSITION_CONTAINS + W.DOCUMENT_POSITION_PRECEDING;
        jt.push(At), At = At.parentNode;
      }
      jt.reverse();
      var ct = ee(gt, jt);
      for (var kn in ct.childNodes) {
        var Kt = ct.childNodes[kn];
        if (Kt === D) return W.DOCUMENT_POSITION_FOLLOWING;
        if (Kt === v) return W.DOCUMENT_POSITION_PRECEDING;
        if (jt.indexOf(Kt) >= 0) return W.DOCUMENT_POSITION_FOLLOWING;
        if (gt.indexOf(Kt) >= 0) return W.DOCUMENT_POSITION_PRECEDING;
      }
      return 0;
    }
  };
  function Se(m) {
    return m == "<" && "&lt;" || m == ">" && "&gt;" || m == "&" && "&amp;" || m == '"' && "&quot;" || "&#" + m.charCodeAt() + ";";
  }
  O(B, se), O(B, se.prototype), O(W, se), O(W, se.prototype);
  function Fe(m, v) {
    if (v(m))
      return !0;
    if (m = m.firstChild)
      do
        if (Fe(m, v))
          return !0;
      while (m = m.nextSibling);
  }
  function re(m, v) {
    g(m);
    var D = v || {};
    this.ownerDocument = this, this.contentType = D.contentType || a.XML_APPLICATION, this.type = o(this.contentType) ? "html" : "xml";
  }
  function Ce(m, v, D) {
    m && m._inc++;
    var H = D.namespaceURI;
    H === l.XMLNS && (v._nsMap[D.prefix ? D.localName : ""] = D.value);
  }
  function Re(m, v, D, H) {
    m && m._inc++;
    var ne = D.namespaceURI;
    ne === l.XMLNS && delete v._nsMap[D.prefix ? D.localName : ""];
  }
  function je(m, v, D) {
    if (m && m._inc) {
      m._inc++;
      var H = v.childNodes;
      if (D && !D.nextSibling)
        H[H.length++] = D;
      else {
        for (var ne = v.firstChild, ae = 0; ne; )
          H[ae++] = ne, ne = ne.nextSibling;
        H.length = ae, delete H[H.length];
      }
    }
  }
  function Je(m, v) {
    if (m !== v.parentNode)
      throw new p(p.NOT_FOUND_ERR, "child's parent is not parent");
    var D = v.previousSibling, H = v.nextSibling;
    return D ? D.nextSibling = H : m.firstChild = H, H ? H.previousSibling = D : m.lastChild = D, je(m.ownerDocument, m), v.parentNode = null, v.previousSibling = null, v.nextSibling = null, v;
  }
  function wt(m) {
    return m && (m.nodeType === se.DOCUMENT_NODE || m.nodeType === se.DOCUMENT_FRAGMENT_NODE || m.nodeType === se.ELEMENT_NODE);
  }
  function ut(m) {
    return m && (m.nodeType === se.CDATA_SECTION_NODE || m.nodeType === se.COMMENT_NODE || m.nodeType === se.DOCUMENT_FRAGMENT_NODE || m.nodeType === se.DOCUMENT_TYPE_NODE || m.nodeType === se.ELEMENT_NODE || m.nodeType === se.PROCESSING_INSTRUCTION_NODE || m.nodeType === se.TEXT_NODE);
  }
  function yt(m) {
    return m && m.nodeType === se.DOCUMENT_TYPE_NODE;
  }
  function Me(m) {
    return m && m.nodeType === se.ELEMENT_NODE;
  }
  function Nt(m) {
    return m && m.nodeType === se.TEXT_NODE;
  }
  function nt(m, v) {
    var D = m.childNodes || [];
    if (e(D, Me) || yt(v))
      return !1;
    var H = e(D, yt);
    return !(v && H && D.indexOf(H) > D.indexOf(v));
  }
  function Pn(m, v) {
    var D = m.childNodes || [];
    function H(ae) {
      return Me(ae) && ae !== v;
    }
    if (e(D, H))
      return !1;
    var ne = e(D, yt);
    return !(v && ne && D.indexOf(ne) > D.indexOf(v));
  }
  function mn(m, v, D) {
    if (!wt(m))
      throw new p(p.HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + m.nodeType);
    if (D && D.parentNode !== m)
      throw new p(p.NOT_FOUND_ERR, "child not in parent");
    if (
      // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
      !ut(v) || // 5. If either `node` is a Text node and `parent` is a document,
      // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
      // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
      // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
      yt(v) && m.nodeType !== se.DOCUMENT_NODE
    )
      throw new p(
        p.HIERARCHY_REQUEST_ERR,
        "Unexpected node type " + v.nodeType + " for parent node type " + m.nodeType
      );
  }
  function ln(m, v, D) {
    var H = m.childNodes || [], ne = v.childNodes || [];
    if (v.nodeType === se.DOCUMENT_FRAGMENT_NODE) {
      var ae = ne.filter(Me);
      if (ae.length > 1 || e(ne, Nt))
        throw new p(p.HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      if (ae.length === 1 && !nt(m, D))
        throw new p(p.HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
    }
    if (Me(v) && !nt(m, D))
      throw new p(p.HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
    if (yt(v)) {
      if (e(H, yt))
        throw new p(p.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      var Oe = e(H, Me);
      if (D && H.indexOf(Oe) < H.indexOf(D))
        throw new p(p.HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      if (!D && Oe)
        throw new p(p.HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
    }
  }
  function bn(m, v, D) {
    var H = m.childNodes || [], ne = v.childNodes || [];
    if (v.nodeType === se.DOCUMENT_FRAGMENT_NODE) {
      var ae = ne.filter(Me);
      if (ae.length > 1 || e(ne, Nt))
        throw new p(p.HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      if (ae.length === 1 && !Pn(m, D))
        throw new p(p.HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
    }
    if (Me(v) && !Pn(m, D))
      throw new p(p.HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
    if (yt(v)) {
      if (e(H, function(_t) {
        return yt(_t) && _t !== D;
      }))
        throw new p(p.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      var Oe = e(H, Me);
      if (D && H.indexOf(Oe) < H.indexOf(D))
        throw new p(p.HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
    }
  }
  function ge(m, v, D, H) {
    mn(m, v, D), m.nodeType === se.DOCUMENT_NODE && (H || ln)(m, v, D);
    var ne = v.parentNode;
    if (ne && ne.removeChild(v), v.nodeType === J) {
      var ae = v.firstChild;
      if (ae == null)
        return v;
      var Oe = v.lastChild;
    } else
      ae = Oe = v;
    var gt = D ? D.previousSibling : m.lastChild;
    ae.previousSibling = gt, Oe.nextSibling = D, gt ? gt.nextSibling = ae : m.firstChild = ae, D == null ? m.lastChild = Oe : D.previousSibling = Oe;
    do
      ae.parentNode = m;
    while (ae !== Oe && (ae = ae.nextSibling));
    return je(m.ownerDocument || m, m, v), v.nodeType == J && (v.firstChild = v.lastChild = null), v;
  }
  re.prototype = {
    /**
     * The implementation that created this document.
     *
     * @type DOMImplementation
     * @readonly
     */
    implementation: null,
    nodeName: "#document",
    nodeType: $,
    /**
     * The DocumentType node of the document.
     *
     * @type DocumentType
     * @readonly
     */
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(m, v) {
      if (m.nodeType === J) {
        for (var D = m.firstChild; D; ) {
          var H = D.nextSibling;
          this.insertBefore(D, v), D = H;
        }
        return m;
      }
      return ge(this, m, v), m.ownerDocument = this, this.documentElement === null && m.nodeType === F && (this.documentElement = m), m;
    },
    removeChild: function(m) {
      var v = Je(this, m);
      return v === this.documentElement && (this.documentElement = null), v;
    },
    replaceChild: function(m, v) {
      ge(this, m, v, bn), m.ownerDocument = this, v && this.removeChild(v), Me(m) && (this.documentElement = m);
    },
    // Introduced in DOM Level 2:
    importNode: function(m, v) {
      return Fn(this, m, v);
    },
    // Introduced in DOM Level 2:
    getElementById: function(m) {
      var v = null;
      return Fe(this.documentElement, function(D) {
        if (D.nodeType == F && D.getAttribute("id") == m)
          return v = D, !0;
      }), v;
    },
    /**
     * Creates a new `Element` that is owned by this `Document`.
     * In HTML Documents `localName` is the lower cased `tagName`,
     * otherwise no transformation is being applied.
     * When `contentType` implies the HTML namespace, it will be set as `namespaceURI`.
     *
     * __This implementation differs from the specification:__ - The provided name is not checked
     * against the `Name` production,
     * so no related error will be thrown.
     * - There is no interface `HTMLElement`, it is always an `Element`.
     * - There is no support for a second argument to indicate using custom elements.
     *
     * @param {string} tagName
     * @returns {Element}
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
     * @see https://dom.spec.whatwg.org/#dom-document-createelement
     * @see https://dom.spec.whatwg.org/#concept-create-element
     */
    createElement: function(m) {
      var v = new ze(c);
      v.ownerDocument = this, this.type === "html" && (m = m.toLowerCase()), n(this.contentType) && (v.namespaceURI = l.HTML), v.nodeName = m, v.tagName = m, v.localName = m, v.childNodes = new Z();
      var D = v.attributes = new de();
      return D._ownerElement = v, v;
    },
    /**
     * @returns {DocumentFragment}
     */
    createDocumentFragment: function() {
      var m = new En(c);
      return m.ownerDocument = this, m.childNodes = new Z(), m;
    },
    /**
     * @param {string} data
     * @returns {Text}
     */
    createTextNode: function(m) {
      var v = new vn(c);
      return v.ownerDocument = this, v.childNodes = new Z(), v.appendData(m), v;
    },
    /**
     * @param {string} data
     * @returns {Comment}
     */
    createComment: function(m) {
      var v = new yn(c);
      return v.ownerDocument = this, v.childNodes = new Z(), v.appendData(m), v;
    },
    /**
     * @param {string} data
     * @returns {CDATASection}
     */
    createCDATASection: function(m) {
      var v = new $n(c);
      return v.ownerDocument = this, v.childNodes = new Z(), v.appendData(m), v;
    },
    /**
     * @param {string} target
     * @param {string} data
     * @returns {ProcessingInstruction}
     */
    createProcessingInstruction: function(m, v) {
      var D = new cn(c);
      return D.ownerDocument = this, D.childNodes = new Z(), D.nodeName = D.target = m, D.nodeValue = D.data = v, D;
    },
    /**
     * Creates an `Attr` node that is owned by this document.
     * In HTML Documents `localName` is the lower cased `name`,
     * otherwise no transformation is being applied.
     *
     * __This implementation differs from the specification:__ - The provided name is not checked
     * against the `Name` production,
     * so no related error will be thrown.
     *
     * @param {string} name
     * @returns {Attr}
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createAttribute
     * @see https://dom.spec.whatwg.org/#dom-document-createattribute
     */
    createAttribute: function(m) {
      if (!h.QName_exact.test(m))
        throw new p(p.INVALID_CHARACTER_ERR, 'invalid character in name "' + m + '"');
      return this.type === "html" && (m = m.toLowerCase()), this._createAttribute(m);
    },
    _createAttribute: function(m) {
      var v = new Tt(c);
      return v.ownerDocument = this, v.childNodes = new Z(), v.name = m, v.nodeName = m, v.localName = m, v.specified = !0, v;
    },
    /**
     * Creates an EntityReference object.
     * The current implementation does not fill the `childNodes` with those of the corresponding
     * `Entity`
     *
     * @deprecated
     * In DOM Level 4.
     * @param {string} name
     * The name of the entity to reference. No namespace well-formedness checks are performed.
     * @returns {EntityReference}
     * @throws {DOMException}
     * With code `INVALID_CHARACTER_ERR` when `name` is not valid.
     * @throws {DOMException}
     * with code `NOT_SUPPORTED_ERR` when the document is of type `html`
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-392B75AE
     */
    createEntityReference: function(m) {
      if (!h.Name.test(m))
        throw new p(p.INVALID_CHARACTER_ERR, 'not a valid xml name "' + m + '"');
      if (this.type === "html")
        throw new p("document is an html document", f.NotSupportedError);
      var v = new Cn(c);
      return v.ownerDocument = this, v.childNodes = new Z(), v.nodeName = m, v;
    },
    // Introduced in DOM Level 2:
    /**
     * @param {string} namespaceURI
     * @param {string} qualifiedName
     * @returns {Element}
     */
    createElementNS: function(m, v) {
      var D = V(m, v), H = new ze(c), ne = H.attributes = new de();
      return H.childNodes = new Z(), H.ownerDocument = this, H.nodeName = v, H.tagName = v, H.namespaceURI = D[0], H.prefix = D[1], H.localName = D[2], ne._ownerElement = H, H;
    },
    // Introduced in DOM Level 2:
    /**
     * @param {string} namespaceURI
     * @param {string} qualifiedName
     * @returns {Attr}
     */
    createAttributeNS: function(m, v) {
      var D = V(m, v), H = new Tt(c);
      return H.ownerDocument = this, H.childNodes = new Z(), H.nodeName = v, H.name = v, H.specified = !0, H.namespaceURI = D[0], H.prefix = D[1], H.localName = D[2], H;
    }
  }, U(re, se);
  function ze(m) {
    g(m), this._nsMap = /* @__PURE__ */ Object.create(null);
  }
  ze.prototype = {
    nodeType: F,
    /**
     * The attributes of this element.
     *
     * @type {NamedNodeMap | null}
     */
    attributes: null,
    getQualifiedName: function() {
      return this.prefix ? this.prefix + ":" + this.localName : this.localName;
    },
    _isInHTMLDocumentAndNamespace: function() {
      return this.ownerDocument.type === "html" && this.namespaceURI === l.HTML;
    },
    /**
     * Implementaton of Level2 Core function hasAttributes.
     *
     * @returns {boolean}
     * True if attribute list is not empty.
     * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-NodeHasAttrs
     */
    hasAttributes: function() {
      return !!(this.attributes && this.attributes.length);
    },
    hasAttribute: function(m) {
      return !!this.getAttributeNode(m);
    },
    /**
     * Returns elementâ€™s first attribute whose qualified name is `name`, and `null`
     * if there is no such attribute.
     *
     * @param {string} name
     * @returns {string | null}
     */
    getAttribute: function(m) {
      var v = this.getAttributeNode(m);
      return v ? v.value : null;
    },
    getAttributeNode: function(m) {
      return this._isInHTMLDocumentAndNamespace() && (m = m.toLowerCase()), this.attributes.getNamedItem(m);
    },
    /**
     * Sets the value of elementâ€™s first attribute whose qualified name is qualifiedName to value.
     *
     * @param {string} name
     * @param {string} value
     */
    setAttribute: function(m, v) {
      this._isInHTMLDocumentAndNamespace() && (m = m.toLowerCase());
      var D = this.getAttributeNode(m);
      D ? D.value = D.nodeValue = "" + v : (D = this.ownerDocument._createAttribute(m), D.value = D.nodeValue = "" + v, this.setAttributeNode(D));
    },
    removeAttribute: function(m) {
      var v = this.getAttributeNode(m);
      v && this.removeAttributeNode(v);
    },
    setAttributeNode: function(m) {
      return this.attributes.setNamedItem(m);
    },
    setAttributeNodeNS: function(m) {
      return this.attributes.setNamedItemNS(m);
    },
    removeAttributeNode: function(m) {
      return this.attributes.removeNamedItem(m.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(m, v) {
      var D = this.getAttributeNodeNS(m, v);
      D && this.removeAttributeNode(D);
    },
    hasAttributeNS: function(m, v) {
      return this.getAttributeNodeNS(m, v) != null;
    },
    /**
     * Returns elementâ€™s attribute whose namespace is `namespaceURI` and local name is
     * `localName`,
     * or `null` if there is no such attribute.
     *
     * @param {string} namespaceURI
     * @param {string} localName
     * @returns {string | null}
     */
    getAttributeNS: function(m, v) {
      var D = this.getAttributeNodeNS(m, v);
      return D ? D.value : null;
    },
    /**
     * Sets the value of elementâ€™s attribute whose namespace is `namespaceURI` and local name is
     * `localName` to value.
     *
     * @param {string} namespaceURI
     * @param {string} qualifiedName
     * @param {string} value
     * @see https://dom.spec.whatwg.org/#dom-element-setattributens
     */
    setAttributeNS: function(m, v, D) {
      var H = V(m, v), ne = H[2], ae = this.getAttributeNodeNS(m, ne);
      ae ? ae.value = ae.nodeValue = "" + D : (ae = this.ownerDocument.createAttributeNS(m, v), ae.value = ae.nodeValue = "" + D, this.setAttributeNode(ae));
    },
    getAttributeNodeNS: function(m, v) {
      return this.attributes.getNamedItemNS(m, v);
    },
    /**
     * Returns a LiveNodeList of all child elements which have **all** of the given class name(s).
     *
     * Returns an empty list if `classNames` is an empty string or only contains HTML white space
     * characters.
     *
     * Warning: This returns a live LiveNodeList.
     * Changes in the DOM will reflect in the array as the changes occur.
     * If an element selected by this array no longer qualifies for the selector,
     * it will automatically be removed. Be aware of this for iteration purposes.
     *
     * @param {string} classNames
     * Is a string representing the class name(s) to match; multiple class names are separated by
     * (ASCII-)whitespace.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
     */
    getElementsByClassName: function(m) {
      var v = y(m);
      return new Y(this, function(D) {
        var H = [];
        return v.length > 0 && Fe(D, function(ne) {
          if (ne !== D && ne.nodeType === F) {
            var ae = ne.getAttribute("class");
            if (ae) {
              var Oe = m === ae;
              if (!Oe) {
                var gt = y(ae);
                Oe = v.every(A(gt));
              }
              Oe && H.push(ne);
            }
          }
        }), H;
      });
    },
    /**
     * Returns a LiveNodeList of elements with the given qualifiedName.
     * Searching for all descendants can be done by passing `*` as `qualifiedName`.
     *
     * All descendants of the specified element are searched, but not the element itself.
     * The returned list is live, which means it updates itself with the DOM tree automatically.
     * Therefore, there is no need to call `Element.getElementsByTagName()`
     * with the same element and arguments repeatedly if the DOM changes in between calls.
     *
     * When called on an HTML element in an HTML document,
     * `getElementsByTagName` lower-cases the argument before searching for it.
     * This is undesirable when trying to match camel-cased SVG elements (such as
     * `<linearGradient>`) in an HTML document.
     * Instead, use `Element.getElementsByTagNameNS()`,
     * which preserves the capitalization of the tag name.
     *
     * `Element.getElementsByTagName` is similar to `Document.getElementsByTagName()`,
     * except that it only searches for elements that are descendants of the specified element.
     *
     * @param {string} qualifiedName
     * @returns {LiveNodeList}
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbytagname
     */
    getElementsByTagName: function(m) {
      var v = (this.nodeType === $ ? this : this.ownerDocument).type === "html", D = m.toLowerCase();
      return new Y(this, function(H) {
        var ne = [];
        return Fe(H, function(ae) {
          if (!(ae === H || ae.nodeType !== F))
            if (m === "*")
              ne.push(ae);
            else {
              var Oe = ae.getQualifiedName(), gt = v && ae.namespaceURI === l.HTML ? D : m;
              Oe === gt && ne.push(ae);
            }
        }), ne;
      });
    },
    getElementsByTagNameNS: function(m, v) {
      return new Y(this, function(D) {
        var H = [];
        return Fe(D, function(ne) {
          ne !== D && ne.nodeType === F && (m === "*" || ne.namespaceURI === m) && (v === "*" || ne.localName == v) && H.push(ne);
        }), H;
      });
    }
  }, re.prototype.getElementsByClassName = ze.prototype.getElementsByClassName, re.prototype.getElementsByTagName = ze.prototype.getElementsByTagName, re.prototype.getElementsByTagNameNS = ze.prototype.getElementsByTagNameNS, U(ze, se);
  function Tt(m) {
    g(m), this.namespaceURI = null, this.prefix = null, this.ownerElement = null;
  }
  Tt.prototype.nodeType = K, U(Tt, se);
  function Ot(m) {
    g(m);
  }
  Ot.prototype = {
    data: "",
    substringData: function(m, v) {
      return this.data.substring(m, m + v);
    },
    appendData: function(m) {
      m = this.data + m, this.nodeValue = this.data = m, this.length = m.length;
    },
    insertData: function(m, v) {
      this.replaceData(m, 0, v);
    },
    deleteData: function(m, v) {
      this.replaceData(m, v, "");
    },
    replaceData: function(m, v, D) {
      var H = this.data.substring(0, m), ne = this.data.substring(m + v);
      D = H + D + ne, this.nodeValue = this.data = D, this.length = D.length;
    }
  }, U(Ot, se);
  function vn(m) {
    g(m);
  }
  vn.prototype = {
    nodeName: "#text",
    nodeType: E,
    splitText: function(m) {
      var v = this.data, D = v.substring(m);
      v = v.substring(0, m), this.data = this.nodeValue = v, this.length = v.length;
      var H = this.ownerDocument.createTextNode(D);
      return this.parentNode && this.parentNode.insertBefore(H, this.nextSibling), H;
    }
  }, U(vn, Ot);
  function yn(m) {
    g(m);
  }
  yn.prototype = {
    nodeName: "#comment",
    nodeType: T
  }, U(yn, Ot);
  function $n(m) {
    g(m);
  }
  $n.prototype = {
    nodeName: "#cdata-section",
    nodeType: S
  }, U($n, vn);
  function xn(m) {
    g(m);
  }
  xn.prototype.nodeType = L, U(xn, se);
  function _n(m) {
    g(m);
  }
  _n.prototype.nodeType = G, U(_n, se);
  function qt(m) {
    g(m);
  }
  qt.prototype.nodeType = I, U(qt, se);
  function Cn(m) {
    g(m);
  }
  Cn.prototype.nodeType = k, U(Cn, se);
  function En(m) {
    g(m);
  }
  En.prototype.nodeName = "#document-fragment", En.prototype.nodeType = J, U(En, se);
  function cn(m) {
    g(m);
  }
  cn.prototype.nodeType = N, U(cn, Ot);
  function er() {
  }
  er.prototype.serializeToString = function(m, v) {
    return Ge.call(m, v);
  }, se.prototype.toString = Ge;
  function Ge(m) {
    var v = [], D = this.nodeType === $ && this.documentElement || this, H = D.prefix, ne = D.namespaceURI;
    if (ne && H == null) {
      var H = D.lookupPrefix(ne);
      if (H == null)
        var ae = [
          { namespace: ne, prefix: null }
          //{namespace:uri,prefix:''}
        ];
    }
    return en(this, v, m, ae), v.join("");
  }
  function dt(m, v, D) {
    var H = m.prefix || "", ne = m.namespaceURI;
    if (!ne || H === "xml" && ne === l.XML || ne === l.XMLNS)
      return !1;
    for (var ae = D.length; ae--; ) {
      var Oe = D[ae];
      if (Oe.prefix === H)
        return Oe.namespace !== ne;
    }
    return !0;
  }
  function Zt(m, v, D) {
    m.push(" ", v, '="', D.replace(/[<>&"\t\n\r]/g, Se), '"');
  }
  function en(m, v, D, H) {
    H || (H = []);
    var ne = m.nodeType === $ ? m : m.ownerDocument, ae = ne.type === "html";
    if (D)
      if (m = D(m), m) {
        if (typeof m == "string") {
          v.push(m);
          return;
        }
      } else
        return;
    switch (m.nodeType) {
      case F:
        var Oe = m.attributes, gt = Oe.length, Et = m.firstChild, _t = m.tagName, jt = _t;
        if (!ae && !m.prefix && m.namespaceURI) {
          for (var At, ct = 0; ct < Oe.length; ct++)
            if (Oe.item(ct).name === "xmlns") {
              At = Oe.item(ct).value;
              break;
            }
          if (!At)
            for (var kn = H.length - 1; kn >= 0; kn--) {
              var Kt = H[kn];
              if (Kt.prefix === "" && Kt.namespace === m.namespaceURI) {
                At = Kt.namespace;
                break;
              }
            }
          if (At !== m.namespaceURI)
            for (var kn = H.length - 1; kn >= 0; kn--) {
              var Kt = H[kn];
              if (Kt.namespace === m.namespaceURI) {
                Kt.prefix && (jt = Kt.prefix + ":" + _t);
                break;
              }
            }
        }
        v.push("<", jt);
        for (var Bn = 0; Bn < gt; Bn++) {
          var un = Oe.item(Bn);
          un.prefix == "xmlns" ? H.push({
            prefix: un.localName,
            namespace: un.value
          }) : un.nodeName == "xmlns" && H.push({ prefix: "", namespace: un.value });
        }
        for (var Bn = 0; Bn < gt; Bn++) {
          var un = Oe.item(Bn);
          if (dt(un, ae, H)) {
            var qn = un.prefix || "", Ct = un.namespaceURI;
            Zt(v, qn ? "xmlns:" + qn : "xmlns", Ct), H.push({ prefix: qn, namespace: Ct });
          }
          en(un, v, D, H);
        }
        if (_t === jt && dt(m, ae, H)) {
          var qn = m.prefix || "", Ct = m.namespaceURI;
          Zt(v, qn ? "xmlns:" + qn : "xmlns", Ct), H.push({ prefix: qn, namespace: Ct });
        }
        var uo = !Et;
        if (uo && (ae || m.namespaceURI === l.HTML) && (uo = s(_t)), uo)
          v.push("/>");
        else {
          if (v.push(">"), ae && i(_t))
            for (; Et; )
              Et.data ? v.push(Et.data) : en(Et, v, D, H.slice()), Et = Et.nextSibling;
          else
            for (; Et; )
              en(Et, v, D, H.slice()), Et = Et.nextSibling;
          v.push("</", jt, ">");
        }
        return;
      case $:
      case J:
        for (var Et = m.firstChild; Et; )
          en(Et, v, D, H.slice()), Et = Et.nextSibling;
        return;
      case K:
        return Zt(v, m.name, m.value);
      case E:
        return v.push(m.data.replace(/[<&>]/g, Se));
      case S:
        return v.push(h.CDATA_START, m.data, h.CDATA_END);
      case T:
        return v.push(h.COMMENT_START, m.data, h.COMMENT_END);
      case L:
        var Jo = m.publicId, tr = m.systemId;
        v.push(h.DOCTYPE_DECL_START, " ", m.name), Jo ? (v.push(" ", h.PUBLIC, " ", Jo), tr && tr !== "." && v.push(" ", tr)) : tr && tr !== "." && v.push(" ", h.SYSTEM, " ", tr), m.internalSubset && v.push(" [", m.internalSubset, "]"), v.push(">");
        return;
      case N:
        return v.push("<?", m.target, " ", m.data, "?>");
      case k:
        return v.push("&", m.nodeName, ";");
      //case ENTITY_NODE:
      //case NOTATION_NODE:
      default:
        v.push("??", m.nodeName);
    }
  }
  function Fn(m, v, D) {
    var H;
    switch (v.nodeType) {
      case F:
        H = v.cloneNode(!1), H.ownerDocument = m;
      //var attrs = node2.attributes;
      //var len = attrs.length;
      //for(var i=0;i<len;i++){
      //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
      //}
      case J:
        break;
      case K:
        D = !0;
        break;
    }
    if (H || (H = v.cloneNode(!1)), H.ownerDocument = m, H.parentNode = null, D)
      for (var ne = v.firstChild; ne; )
        H.appendChild(Fn(m, ne, D)), ne = ne.nextSibling;
    return H;
  }
  function $r(m, v, D) {
    var H = new v.constructor(c);
    for (var ne in v)
      if (r(v, ne)) {
        var ae = v[ne];
        typeof ae != "object" && ae != H[ne] && (H[ne] = ae);
      }
    switch (v.childNodes && (H.childNodes = new Z()), H.ownerDocument = m, H.nodeType) {
      case F:
        var Oe = v.attributes, gt = H.attributes = new de(), _t = Oe.length;
        gt._ownerElement = H;
        for (var jt = 0; jt < _t; jt++)
          H.setAttributeNode($r(m, Oe.item(jt), !0));
        break;
      case K:
        D = !0;
    }
    if (D)
      for (var At = v.firstChild; At; )
        H.appendChild($r(m, At, D)), At = At.nextSibling;
    return H;
  }
  function Sn(m, v, D) {
    m[v] = D;
  }
  try {
    if (Object.defineProperty) {
      let m = function(v) {
        switch (v.nodeType) {
          case F:
          case J:
            var D = [];
            for (v = v.firstChild; v; )
              v.nodeType !== 7 && v.nodeType !== 8 && D.push(m(v)), v = v.nextSibling;
            return D.join("");
          default:
            return v.nodeValue;
        }
      };
      Object.defineProperty(Y.prototype, "length", {
        get: function() {
          return le(this), this.$$length;
        }
      }), Object.defineProperty(se.prototype, "textContent", {
        get: function() {
          return m(this);
        },
        set: function(v) {
          switch (this.nodeType) {
            case F:
            case J:
              for (; this.firstChild; )
                this.removeChild(this.firstChild);
              (v || String(v)) && this.appendChild(this.ownerDocument.createTextNode(v));
              break;
            default:
              this.data = v, this.value = v, this.nodeValue = v;
          }
        }
      }), Sn = function(v, D, H) {
        v["$$" + D] = H;
      };
    }
  } catch {
  }
  return mt._updateLiveList = le, mt.Attr = Tt, mt.CDATASection = $n, mt.CharacterData = Ot, mt.Comment = yn, mt.Document = re, mt.DocumentFragment = En, mt.DocumentType = xn, mt.DOMImplementation = ye, mt.Element = ze, mt.Entity = qt, mt.EntityReference = Cn, mt.LiveNodeList = Y, mt.NamedNodeMap = de, mt.Node = se, mt.NodeList = Z, mt.Notation = _n, mt.Text = vn, mt.ProcessingInstruction = cn, mt.XMLSerializer = er, mt;
}
var wo = {}, kc = {}, nf;
function Qx() {
  return nf || (nf = 1, function(t) {
    var e = $i().freeze;
    t.XML_ENTITIES = e({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    }), t.HTML_ENTITIES = e({
      Aacute: "Ã",
      aacute: "Ã¡",
      Abreve: "Ä‚",
      abreve: "Äƒ",
      ac: "âˆ¾",
      acd: "âˆ¿",
      acE: "âˆ¾Ì³",
      Acirc: "Ã‚",
      acirc: "Ã¢",
      acute: "Â´",
      Acy: "Ð",
      acy: "Ð°",
      AElig: "Ã†",
      aelig: "Ã¦",
      af: "â¡",
      Afr: "ð”„",
      afr: "ð”ž",
      Agrave: "Ã€",
      agrave: "Ã ",
      alefsym: "â„µ",
      aleph: "â„µ",
      Alpha: "Î‘",
      alpha: "Î±",
      Amacr: "Ä€",
      amacr: "Ä",
      amalg: "â¨¿",
      AMP: "&",
      amp: "&",
      And: "â©“",
      and: "âˆ§",
      andand: "â©•",
      andd: "â©œ",
      andslope: "â©˜",
      andv: "â©š",
      ang: "âˆ ",
      ange: "â¦¤",
      angle: "âˆ ",
      angmsd: "âˆ¡",
      angmsdaa: "â¦¨",
      angmsdab: "â¦©",
      angmsdac: "â¦ª",
      angmsdad: "â¦«",
      angmsdae: "â¦¬",
      angmsdaf: "â¦­",
      angmsdag: "â¦®",
      angmsdah: "â¦¯",
      angrt: "âˆŸ",
      angrtvb: "âŠ¾",
      angrtvbd: "â¦",
      angsph: "âˆ¢",
      angst: "Ã…",
      angzarr: "â¼",
      Aogon: "Ä„",
      aogon: "Ä…",
      Aopf: "ð”¸",
      aopf: "ð•’",
      ap: "â‰ˆ",
      apacir: "â©¯",
      apE: "â©°",
      ape: "â‰Š",
      apid: "â‰‹",
      apos: "'",
      ApplyFunction: "â¡",
      approx: "â‰ˆ",
      approxeq: "â‰Š",
      Aring: "Ã…",
      aring: "Ã¥",
      Ascr: "ð’œ",
      ascr: "ð’¶",
      Assign: "â‰”",
      ast: "*",
      asymp: "â‰ˆ",
      asympeq: "â‰",
      Atilde: "Ãƒ",
      atilde: "Ã£",
      Auml: "Ã„",
      auml: "Ã¤",
      awconint: "âˆ³",
      awint: "â¨‘",
      backcong: "â‰Œ",
      backepsilon: "Ï¶",
      backprime: "â€µ",
      backsim: "âˆ½",
      backsimeq: "â‹",
      Backslash: "âˆ–",
      Barv: "â«§",
      barvee: "âŠ½",
      Barwed: "âŒ†",
      barwed: "âŒ…",
      barwedge: "âŒ…",
      bbrk: "âŽµ",
      bbrktbrk: "âŽ¶",
      bcong: "â‰Œ",
      Bcy: "Ð‘",
      bcy: "Ð±",
      bdquo: "â€ž",
      becaus: "âˆµ",
      Because: "âˆµ",
      because: "âˆµ",
      bemptyv: "â¦°",
      bepsi: "Ï¶",
      bernou: "â„¬",
      Bernoullis: "â„¬",
      Beta: "Î’",
      beta: "Î²",
      beth: "â„¶",
      between: "â‰¬",
      Bfr: "ð”…",
      bfr: "ð”Ÿ",
      bigcap: "â‹‚",
      bigcirc: "â—¯",
      bigcup: "â‹ƒ",
      bigodot: "â¨€",
      bigoplus: "â¨",
      bigotimes: "â¨‚",
      bigsqcup: "â¨†",
      bigstar: "â˜…",
      bigtriangledown: "â–½",
      bigtriangleup: "â–³",
      biguplus: "â¨„",
      bigvee: "â‹",
      bigwedge: "â‹€",
      bkarow: "â¤",
      blacklozenge: "â§«",
      blacksquare: "â–ª",
      blacktriangle: "â–´",
      blacktriangledown: "â–¾",
      blacktriangleleft: "â—‚",
      blacktriangleright: "â–¸",
      blank: "â£",
      blk12: "â–’",
      blk14: "â–‘",
      blk34: "â–“",
      block: "â–ˆ",
      bne: "=âƒ¥",
      bnequiv: "â‰¡âƒ¥",
      bNot: "â«­",
      bnot: "âŒ",
      Bopf: "ð”¹",
      bopf: "ð•“",
      bot: "âŠ¥",
      bottom: "âŠ¥",
      bowtie: "â‹ˆ",
      boxbox: "â§‰",
      boxDL: "â•—",
      boxDl: "â•–",
      boxdL: "â••",
      boxdl: "â”",
      boxDR: "â•”",
      boxDr: "â•“",
      boxdR: "â•’",
      boxdr: "â”Œ",
      boxH: "â•",
      boxh: "â”€",
      boxHD: "â•¦",
      boxHd: "â•¤",
      boxhD: "â•¥",
      boxhd: "â”¬",
      boxHU: "â•©",
      boxHu: "â•§",
      boxhU: "â•¨",
      boxhu: "â”´",
      boxminus: "âŠŸ",
      boxplus: "âŠž",
      boxtimes: "âŠ ",
      boxUL: "â•",
      boxUl: "â•œ",
      boxuL: "â•›",
      boxul: "â”˜",
      boxUR: "â•š",
      boxUr: "â•™",
      boxuR: "â•˜",
      boxur: "â””",
      boxV: "â•‘",
      boxv: "â”‚",
      boxVH: "â•¬",
      boxVh: "â•«",
      boxvH: "â•ª",
      boxvh: "â”¼",
      boxVL: "â•£",
      boxVl: "â•¢",
      boxvL: "â•¡",
      boxvl: "â”¤",
      boxVR: "â• ",
      boxVr: "â•Ÿ",
      boxvR: "â•ž",
      boxvr: "â”œ",
      bprime: "â€µ",
      Breve: "Ë˜",
      breve: "Ë˜",
      brvbar: "Â¦",
      Bscr: "â„¬",
      bscr: "ð’·",
      bsemi: "â",
      bsim: "âˆ½",
      bsime: "â‹",
      bsol: "\\",
      bsolb: "â§…",
      bsolhsub: "âŸˆ",
      bull: "â€¢",
      bullet: "â€¢",
      bump: "â‰Ž",
      bumpE: "âª®",
      bumpe: "â‰",
      Bumpeq: "â‰Ž",
      bumpeq: "â‰",
      Cacute: "Ä†",
      cacute: "Ä‡",
      Cap: "â‹’",
      cap: "âˆ©",
      capand: "â©„",
      capbrcup: "â©‰",
      capcap: "â©‹",
      capcup: "â©‡",
      capdot: "â©€",
      CapitalDifferentialD: "â……",
      caps: "âˆ©ï¸€",
      caret: "â",
      caron: "Ë‡",
      Cayleys: "â„­",
      ccaps: "â©",
      Ccaron: "ÄŒ",
      ccaron: "Ä",
      Ccedil: "Ã‡",
      ccedil: "Ã§",
      Ccirc: "Äˆ",
      ccirc: "Ä‰",
      Cconint: "âˆ°",
      ccups: "â©Œ",
      ccupssm: "â©",
      Cdot: "ÄŠ",
      cdot: "Ä‹",
      cedil: "Â¸",
      Cedilla: "Â¸",
      cemptyv: "â¦²",
      cent: "Â¢",
      CenterDot: "Â·",
      centerdot: "Â·",
      Cfr: "â„­",
      cfr: "ð” ",
      CHcy: "Ð§",
      chcy: "Ñ‡",
      check: "âœ“",
      checkmark: "âœ“",
      Chi: "Î§",
      chi: "Ï‡",
      cir: "â—‹",
      circ: "Ë†",
      circeq: "â‰—",
      circlearrowleft: "â†º",
      circlearrowright: "â†»",
      circledast: "âŠ›",
      circledcirc: "âŠš",
      circleddash: "âŠ",
      CircleDot: "âŠ™",
      circledR: "Â®",
      circledS: "â“ˆ",
      CircleMinus: "âŠ–",
      CirclePlus: "âŠ•",
      CircleTimes: "âŠ—",
      cirE: "â§ƒ",
      cire: "â‰—",
      cirfnint: "â¨",
      cirmid: "â«¯",
      cirscir: "â§‚",
      ClockwiseContourIntegral: "âˆ²",
      CloseCurlyDoubleQuote: "â€",
      CloseCurlyQuote: "â€™",
      clubs: "â™£",
      clubsuit: "â™£",
      Colon: "âˆ·",
      colon: ":",
      Colone: "â©´",
      colone: "â‰”",
      coloneq: "â‰”",
      comma: ",",
      commat: "@",
      comp: "âˆ",
      compfn: "âˆ˜",
      complement: "âˆ",
      complexes: "â„‚",
      cong: "â‰…",
      congdot: "â©­",
      Congruent: "â‰¡",
      Conint: "âˆ¯",
      conint: "âˆ®",
      ContourIntegral: "âˆ®",
      Copf: "â„‚",
      copf: "ð•”",
      coprod: "âˆ",
      Coproduct: "âˆ",
      COPY: "Â©",
      copy: "Â©",
      copysr: "â„—",
      CounterClockwiseContourIntegral: "âˆ³",
      crarr: "â†µ",
      Cross: "â¨¯",
      cross: "âœ—",
      Cscr: "ð’ž",
      cscr: "ð’¸",
      csub: "â«",
      csube: "â«‘",
      csup: "â«",
      csupe: "â«’",
      ctdot: "â‹¯",
      cudarrl: "â¤¸",
      cudarrr: "â¤µ",
      cuepr: "â‹ž",
      cuesc: "â‹Ÿ",
      cularr: "â†¶",
      cularrp: "â¤½",
      Cup: "â‹“",
      cup: "âˆª",
      cupbrcap: "â©ˆ",
      CupCap: "â‰",
      cupcap: "â©†",
      cupcup: "â©Š",
      cupdot: "âŠ",
      cupor: "â©…",
      cups: "âˆªï¸€",
      curarr: "â†·",
      curarrm: "â¤¼",
      curlyeqprec: "â‹ž",
      curlyeqsucc: "â‹Ÿ",
      curlyvee: "â‹Ž",
      curlywedge: "â‹",
      curren: "Â¤",
      curvearrowleft: "â†¶",
      curvearrowright: "â†·",
      cuvee: "â‹Ž",
      cuwed: "â‹",
      cwconint: "âˆ²",
      cwint: "âˆ±",
      cylcty: "âŒ­",
      Dagger: "â€¡",
      dagger: "â€ ",
      daleth: "â„¸",
      Darr: "â†¡",
      dArr: "â‡“",
      darr: "â†“",
      dash: "â€",
      Dashv: "â«¤",
      dashv: "âŠ£",
      dbkarow: "â¤",
      dblac: "Ë",
      Dcaron: "ÄŽ",
      dcaron: "Ä",
      Dcy: "Ð”",
      dcy: "Ð´",
      DD: "â……",
      dd: "â…†",
      ddagger: "â€¡",
      ddarr: "â‡Š",
      DDotrahd: "â¤‘",
      ddotseq: "â©·",
      deg: "Â°",
      Del: "âˆ‡",
      Delta: "Î”",
      delta: "Î´",
      demptyv: "â¦±",
      dfisht: "â¥¿",
      Dfr: "ð”‡",
      dfr: "ð”¡",
      dHar: "â¥¥",
      dharl: "â‡ƒ",
      dharr: "â‡‚",
      DiacriticalAcute: "Â´",
      DiacriticalDot: "Ë™",
      DiacriticalDoubleAcute: "Ë",
      DiacriticalGrave: "`",
      DiacriticalTilde: "Ëœ",
      diam: "â‹„",
      Diamond: "â‹„",
      diamond: "â‹„",
      diamondsuit: "â™¦",
      diams: "â™¦",
      die: "Â¨",
      DifferentialD: "â…†",
      digamma: "Ï",
      disin: "â‹²",
      div: "Ã·",
      divide: "Ã·",
      divideontimes: "â‹‡",
      divonx: "â‹‡",
      DJcy: "Ð‚",
      djcy: "Ñ’",
      dlcorn: "âŒž",
      dlcrop: "âŒ",
      dollar: "$",
      Dopf: "ð”»",
      dopf: "ð••",
      Dot: "Â¨",
      dot: "Ë™",
      DotDot: "âƒœ",
      doteq: "â‰",
      doteqdot: "â‰‘",
      DotEqual: "â‰",
      dotminus: "âˆ¸",
      dotplus: "âˆ”",
      dotsquare: "âŠ¡",
      doublebarwedge: "âŒ†",
      DoubleContourIntegral: "âˆ¯",
      DoubleDot: "Â¨",
      DoubleDownArrow: "â‡“",
      DoubleLeftArrow: "â‡",
      DoubleLeftRightArrow: "â‡”",
      DoubleLeftTee: "â«¤",
      DoubleLongLeftArrow: "âŸ¸",
      DoubleLongLeftRightArrow: "âŸº",
      DoubleLongRightArrow: "âŸ¹",
      DoubleRightArrow: "â‡’",
      DoubleRightTee: "âŠ¨",
      DoubleUpArrow: "â‡‘",
      DoubleUpDownArrow: "â‡•",
      DoubleVerticalBar: "âˆ¥",
      DownArrow: "â†“",
      Downarrow: "â‡“",
      downarrow: "â†“",
      DownArrowBar: "â¤“",
      DownArrowUpArrow: "â‡µ",
      DownBreve: "Ì‘",
      downdownarrows: "â‡Š",
      downharpoonleft: "â‡ƒ",
      downharpoonright: "â‡‚",
      DownLeftRightVector: "â¥",
      DownLeftTeeVector: "â¥ž",
      DownLeftVector: "â†½",
      DownLeftVectorBar: "â¥–",
      DownRightTeeVector: "â¥Ÿ",
      DownRightVector: "â‡",
      DownRightVectorBar: "â¥—",
      DownTee: "âŠ¤",
      DownTeeArrow: "â†§",
      drbkarow: "â¤",
      drcorn: "âŒŸ",
      drcrop: "âŒŒ",
      Dscr: "ð’Ÿ",
      dscr: "ð’¹",
      DScy: "Ð…",
      dscy: "Ñ•",
      dsol: "â§¶",
      Dstrok: "Ä",
      dstrok: "Ä‘",
      dtdot: "â‹±",
      dtri: "â–¿",
      dtrif: "â–¾",
      duarr: "â‡µ",
      duhar: "â¥¯",
      dwangle: "â¦¦",
      DZcy: "Ð",
      dzcy: "ÑŸ",
      dzigrarr: "âŸ¿",
      Eacute: "Ã‰",
      eacute: "Ã©",
      easter: "â©®",
      Ecaron: "Äš",
      ecaron: "Ä›",
      ecir: "â‰–",
      Ecirc: "ÃŠ",
      ecirc: "Ãª",
      ecolon: "â‰•",
      Ecy: "Ð­",
      ecy: "Ñ",
      eDDot: "â©·",
      Edot: "Ä–",
      eDot: "â‰‘",
      edot: "Ä—",
      ee: "â…‡",
      efDot: "â‰’",
      Efr: "ð”ˆ",
      efr: "ð”¢",
      eg: "âªš",
      Egrave: "Ãˆ",
      egrave: "Ã¨",
      egs: "âª–",
      egsdot: "âª˜",
      el: "âª™",
      Element: "âˆˆ",
      elinters: "â§",
      ell: "â„“",
      els: "âª•",
      elsdot: "âª—",
      Emacr: "Ä’",
      emacr: "Ä“",
      empty: "âˆ…",
      emptyset: "âˆ…",
      EmptySmallSquare: "â—»",
      emptyv: "âˆ…",
      EmptyVerySmallSquare: "â–«",
      emsp: "â€ƒ",
      emsp13: "â€„",
      emsp14: "â€…",
      ENG: "ÅŠ",
      eng: "Å‹",
      ensp: "â€‚",
      Eogon: "Ä˜",
      eogon: "Ä™",
      Eopf: "ð”¼",
      eopf: "ð•–",
      epar: "â‹•",
      eparsl: "â§£",
      eplus: "â©±",
      epsi: "Îµ",
      Epsilon: "Î•",
      epsilon: "Îµ",
      epsiv: "Ïµ",
      eqcirc: "â‰–",
      eqcolon: "â‰•",
      eqsim: "â‰‚",
      eqslantgtr: "âª–",
      eqslantless: "âª•",
      Equal: "â©µ",
      equals: "=",
      EqualTilde: "â‰‚",
      equest: "â‰Ÿ",
      Equilibrium: "â‡Œ",
      equiv: "â‰¡",
      equivDD: "â©¸",
      eqvparsl: "â§¥",
      erarr: "â¥±",
      erDot: "â‰“",
      Escr: "â„°",
      escr: "â„¯",
      esdot: "â‰",
      Esim: "â©³",
      esim: "â‰‚",
      Eta: "Î—",
      eta: "Î·",
      ETH: "Ã",
      eth: "Ã°",
      Euml: "Ã‹",
      euml: "Ã«",
      euro: "â‚¬",
      excl: "!",
      exist: "âˆƒ",
      Exists: "âˆƒ",
      expectation: "â„°",
      ExponentialE: "â…‡",
      exponentiale: "â…‡",
      fallingdotseq: "â‰’",
      Fcy: "Ð¤",
      fcy: "Ñ„",
      female: "â™€",
      ffilig: "ï¬ƒ",
      fflig: "ï¬€",
      ffllig: "ï¬„",
      Ffr: "ð”‰",
      ffr: "ð”£",
      filig: "ï¬",
      FilledSmallSquare: "â—¼",
      FilledVerySmallSquare: "â–ª",
      fjlig: "fj",
      flat: "â™­",
      fllig: "ï¬‚",
      fltns: "â–±",
      fnof: "Æ’",
      Fopf: "ð”½",
      fopf: "ð•—",
      ForAll: "âˆ€",
      forall: "âˆ€",
      fork: "â‹”",
      forkv: "â«™",
      Fouriertrf: "â„±",
      fpartint: "â¨",
      frac12: "Â½",
      frac13: "â…“",
      frac14: "Â¼",
      frac15: "â…•",
      frac16: "â…™",
      frac18: "â…›",
      frac23: "â…”",
      frac25: "â…–",
      frac34: "Â¾",
      frac35: "â…—",
      frac38: "â…œ",
      frac45: "â…˜",
      frac56: "â…š",
      frac58: "â…",
      frac78: "â…ž",
      frasl: "â„",
      frown: "âŒ¢",
      Fscr: "â„±",
      fscr: "ð’»",
      gacute: "Çµ",
      Gamma: "Î“",
      gamma: "Î³",
      Gammad: "Ïœ",
      gammad: "Ï",
      gap: "âª†",
      Gbreve: "Äž",
      gbreve: "ÄŸ",
      Gcedil: "Ä¢",
      Gcirc: "Äœ",
      gcirc: "Ä",
      Gcy: "Ð“",
      gcy: "Ð³",
      Gdot: "Ä ",
      gdot: "Ä¡",
      gE: "â‰§",
      ge: "â‰¥",
      gEl: "âªŒ",
      gel: "â‹›",
      geq: "â‰¥",
      geqq: "â‰§",
      geqslant: "â©¾",
      ges: "â©¾",
      gescc: "âª©",
      gesdot: "âª€",
      gesdoto: "âª‚",
      gesdotol: "âª„",
      gesl: "â‹›ï¸€",
      gesles: "âª”",
      Gfr: "ð”Š",
      gfr: "ð”¤",
      Gg: "â‹™",
      gg: "â‰«",
      ggg: "â‹™",
      gimel: "â„·",
      GJcy: "Ðƒ",
      gjcy: "Ñ“",
      gl: "â‰·",
      gla: "âª¥",
      glE: "âª’",
      glj: "âª¤",
      gnap: "âªŠ",
      gnapprox: "âªŠ",
      gnE: "â‰©",
      gne: "âªˆ",
      gneq: "âªˆ",
      gneqq: "â‰©",
      gnsim: "â‹§",
      Gopf: "ð”¾",
      gopf: "ð•˜",
      grave: "`",
      GreaterEqual: "â‰¥",
      GreaterEqualLess: "â‹›",
      GreaterFullEqual: "â‰§",
      GreaterGreater: "âª¢",
      GreaterLess: "â‰·",
      GreaterSlantEqual: "â©¾",
      GreaterTilde: "â‰³",
      Gscr: "ð’¢",
      gscr: "â„Š",
      gsim: "â‰³",
      gsime: "âªŽ",
      gsiml: "âª",
      Gt: "â‰«",
      GT: ">",
      gt: ">",
      gtcc: "âª§",
      gtcir: "â©º",
      gtdot: "â‹—",
      gtlPar: "â¦•",
      gtquest: "â©¼",
      gtrapprox: "âª†",
      gtrarr: "â¥¸",
      gtrdot: "â‹—",
      gtreqless: "â‹›",
      gtreqqless: "âªŒ",
      gtrless: "â‰·",
      gtrsim: "â‰³",
      gvertneqq: "â‰©ï¸€",
      gvnE: "â‰©ï¸€",
      Hacek: "Ë‡",
      hairsp: "â€Š",
      half: "Â½",
      hamilt: "â„‹",
      HARDcy: "Ðª",
      hardcy: "ÑŠ",
      hArr: "â‡”",
      harr: "â†”",
      harrcir: "â¥ˆ",
      harrw: "â†­",
      Hat: "^",
      hbar: "â„",
      Hcirc: "Ä¤",
      hcirc: "Ä¥",
      hearts: "â™¥",
      heartsuit: "â™¥",
      hellip: "â€¦",
      hercon: "âŠ¹",
      Hfr: "â„Œ",
      hfr: "ð”¥",
      HilbertSpace: "â„‹",
      hksearow: "â¤¥",
      hkswarow: "â¤¦",
      hoarr: "â‡¿",
      homtht: "âˆ»",
      hookleftarrow: "â†©",
      hookrightarrow: "â†ª",
      Hopf: "â„",
      hopf: "ð•™",
      horbar: "â€•",
      HorizontalLine: "â”€",
      Hscr: "â„‹",
      hscr: "ð’½",
      hslash: "â„",
      Hstrok: "Ä¦",
      hstrok: "Ä§",
      HumpDownHump: "â‰Ž",
      HumpEqual: "â‰",
      hybull: "âƒ",
      hyphen: "â€",
      Iacute: "Ã",
      iacute: "Ã­",
      ic: "â£",
      Icirc: "ÃŽ",
      icirc: "Ã®",
      Icy: "Ð˜",
      icy: "Ð¸",
      Idot: "Ä°",
      IEcy: "Ð•",
      iecy: "Ðµ",
      iexcl: "Â¡",
      iff: "â‡”",
      Ifr: "â„‘",
      ifr: "ð”¦",
      Igrave: "ÃŒ",
      igrave: "Ã¬",
      ii: "â…ˆ",
      iiiint: "â¨Œ",
      iiint: "âˆ­",
      iinfin: "â§œ",
      iiota: "â„©",
      IJlig: "Ä²",
      ijlig: "Ä³",
      Im: "â„‘",
      Imacr: "Äª",
      imacr: "Ä«",
      image: "â„‘",
      ImaginaryI: "â…ˆ",
      imagline: "â„",
      imagpart: "â„‘",
      imath: "Ä±",
      imof: "âŠ·",
      imped: "Æµ",
      Implies: "â‡’",
      in: "âˆˆ",
      incare: "â„…",
      infin: "âˆž",
      infintie: "â§",
      inodot: "Ä±",
      Int: "âˆ¬",
      int: "âˆ«",
      intcal: "âŠº",
      integers: "â„¤",
      Integral: "âˆ«",
      intercal: "âŠº",
      Intersection: "â‹‚",
      intlarhk: "â¨—",
      intprod: "â¨¼",
      InvisibleComma: "â£",
      InvisibleTimes: "â¢",
      IOcy: "Ð",
      iocy: "Ñ‘",
      Iogon: "Ä®",
      iogon: "Ä¯",
      Iopf: "ð•€",
      iopf: "ð•š",
      Iota: "Î™",
      iota: "Î¹",
      iprod: "â¨¼",
      iquest: "Â¿",
      Iscr: "â„",
      iscr: "ð’¾",
      isin: "âˆˆ",
      isindot: "â‹µ",
      isinE: "â‹¹",
      isins: "â‹´",
      isinsv: "â‹³",
      isinv: "âˆˆ",
      it: "â¢",
      Itilde: "Ä¨",
      itilde: "Ä©",
      Iukcy: "Ð†",
      iukcy: "Ñ–",
      Iuml: "Ã",
      iuml: "Ã¯",
      Jcirc: "Ä´",
      jcirc: "Äµ",
      Jcy: "Ð™",
      jcy: "Ð¹",
      Jfr: "ð”",
      jfr: "ð”§",
      jmath: "È·",
      Jopf: "ð•",
      jopf: "ð•›",
      Jscr: "ð’¥",
      jscr: "ð’¿",
      Jsercy: "Ðˆ",
      jsercy: "Ñ˜",
      Jukcy: "Ð„",
      jukcy: "Ñ”",
      Kappa: "Îš",
      kappa: "Îº",
      kappav: "Ï°",
      Kcedil: "Ä¶",
      kcedil: "Ä·",
      Kcy: "Ðš",
      kcy: "Ðº",
      Kfr: "ð”Ž",
      kfr: "ð”¨",
      kgreen: "Ä¸",
      KHcy: "Ð¥",
      khcy: "Ñ…",
      KJcy: "ÐŒ",
      kjcy: "Ñœ",
      Kopf: "ð•‚",
      kopf: "ð•œ",
      Kscr: "ð’¦",
      kscr: "ð“€",
      lAarr: "â‡š",
      Lacute: "Ä¹",
      lacute: "Äº",
      laemptyv: "â¦´",
      lagran: "â„’",
      Lambda: "Î›",
      lambda: "Î»",
      Lang: "âŸª",
      lang: "âŸ¨",
      langd: "â¦‘",
      langle: "âŸ¨",
      lap: "âª…",
      Laplacetrf: "â„’",
      laquo: "Â«",
      Larr: "â†ž",
      lArr: "â‡",
      larr: "â†",
      larrb: "â‡¤",
      larrbfs: "â¤Ÿ",
      larrfs: "â¤",
      larrhk: "â†©",
      larrlp: "â†«",
      larrpl: "â¤¹",
      larrsim: "â¥³",
      larrtl: "â†¢",
      lat: "âª«",
      lAtail: "â¤›",
      latail: "â¤™",
      late: "âª­",
      lates: "âª­ï¸€",
      lBarr: "â¤Ž",
      lbarr: "â¤Œ",
      lbbrk: "â²",
      lbrace: "{",
      lbrack: "[",
      lbrke: "â¦‹",
      lbrksld: "â¦",
      lbrkslu: "â¦",
      Lcaron: "Ä½",
      lcaron: "Ä¾",
      Lcedil: "Ä»",
      lcedil: "Ä¼",
      lceil: "âŒˆ",
      lcub: "{",
      Lcy: "Ð›",
      lcy: "Ð»",
      ldca: "â¤¶",
      ldquo: "â€œ",
      ldquor: "â€ž",
      ldrdhar: "â¥§",
      ldrushar: "â¥‹",
      ldsh: "â†²",
      lE: "â‰¦",
      le: "â‰¤",
      LeftAngleBracket: "âŸ¨",
      LeftArrow: "â†",
      Leftarrow: "â‡",
      leftarrow: "â†",
      LeftArrowBar: "â‡¤",
      LeftArrowRightArrow: "â‡†",
      leftarrowtail: "â†¢",
      LeftCeiling: "âŒˆ",
      LeftDoubleBracket: "âŸ¦",
      LeftDownTeeVector: "â¥¡",
      LeftDownVector: "â‡ƒ",
      LeftDownVectorBar: "â¥™",
      LeftFloor: "âŒŠ",
      leftharpoondown: "â†½",
      leftharpoonup: "â†¼",
      leftleftarrows: "â‡‡",
      LeftRightArrow: "â†”",
      Leftrightarrow: "â‡”",
      leftrightarrow: "â†”",
      leftrightarrows: "â‡†",
      leftrightharpoons: "â‡‹",
      leftrightsquigarrow: "â†­",
      LeftRightVector: "â¥Ž",
      LeftTee: "âŠ£",
      LeftTeeArrow: "â†¤",
      LeftTeeVector: "â¥š",
      leftthreetimes: "â‹‹",
      LeftTriangle: "âŠ²",
      LeftTriangleBar: "â§",
      LeftTriangleEqual: "âŠ´",
      LeftUpDownVector: "â¥‘",
      LeftUpTeeVector: "â¥ ",
      LeftUpVector: "â†¿",
      LeftUpVectorBar: "â¥˜",
      LeftVector: "â†¼",
      LeftVectorBar: "â¥’",
      lEg: "âª‹",
      leg: "â‹š",
      leq: "â‰¤",
      leqq: "â‰¦",
      leqslant: "â©½",
      les: "â©½",
      lescc: "âª¨",
      lesdot: "â©¿",
      lesdoto: "âª",
      lesdotor: "âªƒ",
      lesg: "â‹šï¸€",
      lesges: "âª“",
      lessapprox: "âª…",
      lessdot: "â‹–",
      lesseqgtr: "â‹š",
      lesseqqgtr: "âª‹",
      LessEqualGreater: "â‹š",
      LessFullEqual: "â‰¦",
      LessGreater: "â‰¶",
      lessgtr: "â‰¶",
      LessLess: "âª¡",
      lesssim: "â‰²",
      LessSlantEqual: "â©½",
      LessTilde: "â‰²",
      lfisht: "â¥¼",
      lfloor: "âŒŠ",
      Lfr: "ð”",
      lfr: "ð”©",
      lg: "â‰¶",
      lgE: "âª‘",
      lHar: "â¥¢",
      lhard: "â†½",
      lharu: "â†¼",
      lharul: "â¥ª",
      lhblk: "â–„",
      LJcy: "Ð‰",
      ljcy: "Ñ™",
      Ll: "â‹˜",
      ll: "â‰ª",
      llarr: "â‡‡",
      llcorner: "âŒž",
      Lleftarrow: "â‡š",
      llhard: "â¥«",
      lltri: "â—º",
      Lmidot: "Ä¿",
      lmidot: "Å€",
      lmoust: "âŽ°",
      lmoustache: "âŽ°",
      lnap: "âª‰",
      lnapprox: "âª‰",
      lnE: "â‰¨",
      lne: "âª‡",
      lneq: "âª‡",
      lneqq: "â‰¨",
      lnsim: "â‹¦",
      loang: "âŸ¬",
      loarr: "â‡½",
      lobrk: "âŸ¦",
      LongLeftArrow: "âŸµ",
      Longleftarrow: "âŸ¸",
      longleftarrow: "âŸµ",
      LongLeftRightArrow: "âŸ·",
      Longleftrightarrow: "âŸº",
      longleftrightarrow: "âŸ·",
      longmapsto: "âŸ¼",
      LongRightArrow: "âŸ¶",
      Longrightarrow: "âŸ¹",
      longrightarrow: "âŸ¶",
      looparrowleft: "â†«",
      looparrowright: "â†¬",
      lopar: "â¦…",
      Lopf: "ð•ƒ",
      lopf: "ð•",
      loplus: "â¨­",
      lotimes: "â¨´",
      lowast: "âˆ—",
      lowbar: "_",
      LowerLeftArrow: "â†™",
      LowerRightArrow: "â†˜",
      loz: "â—Š",
      lozenge: "â—Š",
      lozf: "â§«",
      lpar: "(",
      lparlt: "â¦“",
      lrarr: "â‡†",
      lrcorner: "âŒŸ",
      lrhar: "â‡‹",
      lrhard: "â¥­",
      lrm: "â€Ž",
      lrtri: "âŠ¿",
      lsaquo: "â€¹",
      Lscr: "â„’",
      lscr: "ð“",
      Lsh: "â†°",
      lsh: "â†°",
      lsim: "â‰²",
      lsime: "âª",
      lsimg: "âª",
      lsqb: "[",
      lsquo: "â€˜",
      lsquor: "â€š",
      Lstrok: "Å",
      lstrok: "Å‚",
      Lt: "â‰ª",
      LT: "<",
      lt: "<",
      ltcc: "âª¦",
      ltcir: "â©¹",
      ltdot: "â‹–",
      lthree: "â‹‹",
      ltimes: "â‹‰",
      ltlarr: "â¥¶",
      ltquest: "â©»",
      ltri: "â—ƒ",
      ltrie: "âŠ´",
      ltrif: "â—‚",
      ltrPar: "â¦–",
      lurdshar: "â¥Š",
      luruhar: "â¥¦",
      lvertneqq: "â‰¨ï¸€",
      lvnE: "â‰¨ï¸€",
      macr: "Â¯",
      male: "â™‚",
      malt: "âœ ",
      maltese: "âœ ",
      Map: "â¤…",
      map: "â†¦",
      mapsto: "â†¦",
      mapstodown: "â†§",
      mapstoleft: "â†¤",
      mapstoup: "â†¥",
      marker: "â–®",
      mcomma: "â¨©",
      Mcy: "Ðœ",
      mcy: "Ð¼",
      mdash: "â€”",
      mDDot: "âˆº",
      measuredangle: "âˆ¡",
      MediumSpace: "âŸ",
      Mellintrf: "â„³",
      Mfr: "ð”",
      mfr: "ð”ª",
      mho: "â„§",
      micro: "Âµ",
      mid: "âˆ£",
      midast: "*",
      midcir: "â«°",
      middot: "Â·",
      minus: "âˆ’",
      minusb: "âŠŸ",
      minusd: "âˆ¸",
      minusdu: "â¨ª",
      MinusPlus: "âˆ“",
      mlcp: "â«›",
      mldr: "â€¦",
      mnplus: "âˆ“",
      models: "âŠ§",
      Mopf: "ð•„",
      mopf: "ð•ž",
      mp: "âˆ“",
      Mscr: "â„³",
      mscr: "ð“‚",
      mstpos: "âˆ¾",
      Mu: "Îœ",
      mu: "Î¼",
      multimap: "âŠ¸",
      mumap: "âŠ¸",
      nabla: "âˆ‡",
      Nacute: "Åƒ",
      nacute: "Å„",
      nang: "âˆ âƒ’",
      nap: "â‰‰",
      napE: "â©°Ì¸",
      napid: "â‰‹Ì¸",
      napos: "Å‰",
      napprox: "â‰‰",
      natur: "â™®",
      natural: "â™®",
      naturals: "â„•",
      nbsp: "Â ",
      nbump: "â‰ŽÌ¸",
      nbumpe: "â‰Ì¸",
      ncap: "â©ƒ",
      Ncaron: "Å‡",
      ncaron: "Åˆ",
      Ncedil: "Å…",
      ncedil: "Å†",
      ncong: "â‰‡",
      ncongdot: "â©­Ì¸",
      ncup: "â©‚",
      Ncy: "Ð",
      ncy: "Ð½",
      ndash: "â€“",
      ne: "â‰ ",
      nearhk: "â¤¤",
      neArr: "â‡—",
      nearr: "â†—",
      nearrow: "â†—",
      nedot: "â‰Ì¸",
      NegativeMediumSpace: "â€‹",
      NegativeThickSpace: "â€‹",
      NegativeThinSpace: "â€‹",
      NegativeVeryThinSpace: "â€‹",
      nequiv: "â‰¢",
      nesear: "â¤¨",
      nesim: "â‰‚Ì¸",
      NestedGreaterGreater: "â‰«",
      NestedLessLess: "â‰ª",
      NewLine: `
`,
      nexist: "âˆ„",
      nexists: "âˆ„",
      Nfr: "ð”‘",
      nfr: "ð”«",
      ngE: "â‰§Ì¸",
      nge: "â‰±",
      ngeq: "â‰±",
      ngeqq: "â‰§Ì¸",
      ngeqslant: "â©¾Ì¸",
      nges: "â©¾Ì¸",
      nGg: "â‹™Ì¸",
      ngsim: "â‰µ",
      nGt: "â‰«âƒ’",
      ngt: "â‰¯",
      ngtr: "â‰¯",
      nGtv: "â‰«Ì¸",
      nhArr: "â‡Ž",
      nharr: "â†®",
      nhpar: "â«²",
      ni: "âˆ‹",
      nis: "â‹¼",
      nisd: "â‹º",
      niv: "âˆ‹",
      NJcy: "ÐŠ",
      njcy: "Ñš",
      nlArr: "â‡",
      nlarr: "â†š",
      nldr: "â€¥",
      nlE: "â‰¦Ì¸",
      nle: "â‰°",
      nLeftarrow: "â‡",
      nleftarrow: "â†š",
      nLeftrightarrow: "â‡Ž",
      nleftrightarrow: "â†®",
      nleq: "â‰°",
      nleqq: "â‰¦Ì¸",
      nleqslant: "â©½Ì¸",
      nles: "â©½Ì¸",
      nless: "â‰®",
      nLl: "â‹˜Ì¸",
      nlsim: "â‰´",
      nLt: "â‰ªâƒ’",
      nlt: "â‰®",
      nltri: "â‹ª",
      nltrie: "â‹¬",
      nLtv: "â‰ªÌ¸",
      nmid: "âˆ¤",
      NoBreak: "â ",
      NonBreakingSpace: "Â ",
      Nopf: "â„•",
      nopf: "ð•Ÿ",
      Not: "â«¬",
      not: "Â¬",
      NotCongruent: "â‰¢",
      NotCupCap: "â‰­",
      NotDoubleVerticalBar: "âˆ¦",
      NotElement: "âˆ‰",
      NotEqual: "â‰ ",
      NotEqualTilde: "â‰‚Ì¸",
      NotExists: "âˆ„",
      NotGreater: "â‰¯",
      NotGreaterEqual: "â‰±",
      NotGreaterFullEqual: "â‰§Ì¸",
      NotGreaterGreater: "â‰«Ì¸",
      NotGreaterLess: "â‰¹",
      NotGreaterSlantEqual: "â©¾Ì¸",
      NotGreaterTilde: "â‰µ",
      NotHumpDownHump: "â‰ŽÌ¸",
      NotHumpEqual: "â‰Ì¸",
      notin: "âˆ‰",
      notindot: "â‹µÌ¸",
      notinE: "â‹¹Ì¸",
      notinva: "âˆ‰",
      notinvb: "â‹·",
      notinvc: "â‹¶",
      NotLeftTriangle: "â‹ª",
      NotLeftTriangleBar: "â§Ì¸",
      NotLeftTriangleEqual: "â‹¬",
      NotLess: "â‰®",
      NotLessEqual: "â‰°",
      NotLessGreater: "â‰¸",
      NotLessLess: "â‰ªÌ¸",
      NotLessSlantEqual: "â©½Ì¸",
      NotLessTilde: "â‰´",
      NotNestedGreaterGreater: "âª¢Ì¸",
      NotNestedLessLess: "âª¡Ì¸",
      notni: "âˆŒ",
      notniva: "âˆŒ",
      notnivb: "â‹¾",
      notnivc: "â‹½",
      NotPrecedes: "âŠ€",
      NotPrecedesEqual: "âª¯Ì¸",
      NotPrecedesSlantEqual: "â‹ ",
      NotReverseElement: "âˆŒ",
      NotRightTriangle: "â‹«",
      NotRightTriangleBar: "â§Ì¸",
      NotRightTriangleEqual: "â‹­",
      NotSquareSubset: "âŠÌ¸",
      NotSquareSubsetEqual: "â‹¢",
      NotSquareSuperset: "âŠÌ¸",
      NotSquareSupersetEqual: "â‹£",
      NotSubset: "âŠ‚âƒ’",
      NotSubsetEqual: "âŠˆ",
      NotSucceeds: "âŠ",
      NotSucceedsEqual: "âª°Ì¸",
      NotSucceedsSlantEqual: "â‹¡",
      NotSucceedsTilde: "â‰¿Ì¸",
      NotSuperset: "âŠƒâƒ’",
      NotSupersetEqual: "âŠ‰",
      NotTilde: "â‰",
      NotTildeEqual: "â‰„",
      NotTildeFullEqual: "â‰‡",
      NotTildeTilde: "â‰‰",
      NotVerticalBar: "âˆ¤",
      npar: "âˆ¦",
      nparallel: "âˆ¦",
      nparsl: "â«½âƒ¥",
      npart: "âˆ‚Ì¸",
      npolint: "â¨”",
      npr: "âŠ€",
      nprcue: "â‹ ",
      npre: "âª¯Ì¸",
      nprec: "âŠ€",
      npreceq: "âª¯Ì¸",
      nrArr: "â‡",
      nrarr: "â†›",
      nrarrc: "â¤³Ì¸",
      nrarrw: "â†Ì¸",
      nRightarrow: "â‡",
      nrightarrow: "â†›",
      nrtri: "â‹«",
      nrtrie: "â‹­",
      nsc: "âŠ",
      nsccue: "â‹¡",
      nsce: "âª°Ì¸",
      Nscr: "ð’©",
      nscr: "ð“ƒ",
      nshortmid: "âˆ¤",
      nshortparallel: "âˆ¦",
      nsim: "â‰",
      nsime: "â‰„",
      nsimeq: "â‰„",
      nsmid: "âˆ¤",
      nspar: "âˆ¦",
      nsqsube: "â‹¢",
      nsqsupe: "â‹£",
      nsub: "âŠ„",
      nsubE: "â«…Ì¸",
      nsube: "âŠˆ",
      nsubset: "âŠ‚âƒ’",
      nsubseteq: "âŠˆ",
      nsubseteqq: "â«…Ì¸",
      nsucc: "âŠ",
      nsucceq: "âª°Ì¸",
      nsup: "âŠ…",
      nsupE: "â«†Ì¸",
      nsupe: "âŠ‰",
      nsupset: "âŠƒâƒ’",
      nsupseteq: "âŠ‰",
      nsupseteqq: "â«†Ì¸",
      ntgl: "â‰¹",
      Ntilde: "Ã‘",
      ntilde: "Ã±",
      ntlg: "â‰¸",
      ntriangleleft: "â‹ª",
      ntrianglelefteq: "â‹¬",
      ntriangleright: "â‹«",
      ntrianglerighteq: "â‹­",
      Nu: "Î",
      nu: "Î½",
      num: "#",
      numero: "â„–",
      numsp: "â€‡",
      nvap: "â‰âƒ’",
      nVDash: "âŠ¯",
      nVdash: "âŠ®",
      nvDash: "âŠ­",
      nvdash: "âŠ¬",
      nvge: "â‰¥âƒ’",
      nvgt: ">âƒ’",
      nvHarr: "â¤„",
      nvinfin: "â§ž",
      nvlArr: "â¤‚",
      nvle: "â‰¤âƒ’",
      nvlt: "<âƒ’",
      nvltrie: "âŠ´âƒ’",
      nvrArr: "â¤ƒ",
      nvrtrie: "âŠµâƒ’",
      nvsim: "âˆ¼âƒ’",
      nwarhk: "â¤£",
      nwArr: "â‡–",
      nwarr: "â†–",
      nwarrow: "â†–",
      nwnear: "â¤§",
      Oacute: "Ã“",
      oacute: "Ã³",
      oast: "âŠ›",
      ocir: "âŠš",
      Ocirc: "Ã”",
      ocirc: "Ã´",
      Ocy: "Ðž",
      ocy: "Ð¾",
      odash: "âŠ",
      Odblac: "Å",
      odblac: "Å‘",
      odiv: "â¨¸",
      odot: "âŠ™",
      odsold: "â¦¼",
      OElig: "Å’",
      oelig: "Å“",
      ofcir: "â¦¿",
      Ofr: "ð”’",
      ofr: "ð”¬",
      ogon: "Ë›",
      Ograve: "Ã’",
      ograve: "Ã²",
      ogt: "â§",
      ohbar: "â¦µ",
      ohm: "Î©",
      oint: "âˆ®",
      olarr: "â†º",
      olcir: "â¦¾",
      olcross: "â¦»",
      oline: "â€¾",
      olt: "â§€",
      Omacr: "ÅŒ",
      omacr: "Å",
      Omega: "Î©",
      omega: "Ï‰",
      Omicron: "ÎŸ",
      omicron: "Î¿",
      omid: "â¦¶",
      ominus: "âŠ–",
      Oopf: "ð•†",
      oopf: "ð• ",
      opar: "â¦·",
      OpenCurlyDoubleQuote: "â€œ",
      OpenCurlyQuote: "â€˜",
      operp: "â¦¹",
      oplus: "âŠ•",
      Or: "â©”",
      or: "âˆ¨",
      orarr: "â†»",
      ord: "â©",
      order: "â„´",
      orderof: "â„´",
      ordf: "Âª",
      ordm: "Âº",
      origof: "âŠ¶",
      oror: "â©–",
      orslope: "â©—",
      orv: "â©›",
      oS: "â“ˆ",
      Oscr: "ð’ª",
      oscr: "â„´",
      Oslash: "Ã˜",
      oslash: "Ã¸",
      osol: "âŠ˜",
      Otilde: "Ã•",
      otilde: "Ãµ",
      Otimes: "â¨·",
      otimes: "âŠ—",
      otimesas: "â¨¶",
      Ouml: "Ã–",
      ouml: "Ã¶",
      ovbar: "âŒ½",
      OverBar: "â€¾",
      OverBrace: "âž",
      OverBracket: "âŽ´",
      OverParenthesis: "âœ",
      par: "âˆ¥",
      para: "Â¶",
      parallel: "âˆ¥",
      parsim: "â«³",
      parsl: "â«½",
      part: "âˆ‚",
      PartialD: "âˆ‚",
      Pcy: "ÐŸ",
      pcy: "Ð¿",
      percnt: "%",
      period: ".",
      permil: "â€°",
      perp: "âŠ¥",
      pertenk: "â€±",
      Pfr: "ð”“",
      pfr: "ð”­",
      Phi: "Î¦",
      phi: "Ï†",
      phiv: "Ï•",
      phmmat: "â„³",
      phone: "â˜Ž",
      Pi: "Î ",
      pi: "Ï€",
      pitchfork: "â‹”",
      piv: "Ï–",
      planck: "â„",
      planckh: "â„Ž",
      plankv: "â„",
      plus: "+",
      plusacir: "â¨£",
      plusb: "âŠž",
      pluscir: "â¨¢",
      plusdo: "âˆ”",
      plusdu: "â¨¥",
      pluse: "â©²",
      PlusMinus: "Â±",
      plusmn: "Â±",
      plussim: "â¨¦",
      plustwo: "â¨§",
      pm: "Â±",
      Poincareplane: "â„Œ",
      pointint: "â¨•",
      Popf: "â„™",
      popf: "ð•¡",
      pound: "Â£",
      Pr: "âª»",
      pr: "â‰º",
      prap: "âª·",
      prcue: "â‰¼",
      prE: "âª³",
      pre: "âª¯",
      prec: "â‰º",
      precapprox: "âª·",
      preccurlyeq: "â‰¼",
      Precedes: "â‰º",
      PrecedesEqual: "âª¯",
      PrecedesSlantEqual: "â‰¼",
      PrecedesTilde: "â‰¾",
      preceq: "âª¯",
      precnapprox: "âª¹",
      precneqq: "âªµ",
      precnsim: "â‹¨",
      precsim: "â‰¾",
      Prime: "â€³",
      prime: "â€²",
      primes: "â„™",
      prnap: "âª¹",
      prnE: "âªµ",
      prnsim: "â‹¨",
      prod: "âˆ",
      Product: "âˆ",
      profalar: "âŒ®",
      profline: "âŒ’",
      profsurf: "âŒ“",
      prop: "âˆ",
      Proportion: "âˆ·",
      Proportional: "âˆ",
      propto: "âˆ",
      prsim: "â‰¾",
      prurel: "âŠ°",
      Pscr: "ð’«",
      pscr: "ð“…",
      Psi: "Î¨",
      psi: "Ïˆ",
      puncsp: "â€ˆ",
      Qfr: "ð””",
      qfr: "ð”®",
      qint: "â¨Œ",
      Qopf: "â„š",
      qopf: "ð•¢",
      qprime: "â—",
      Qscr: "ð’¬",
      qscr: "ð“†",
      quaternions: "â„",
      quatint: "â¨–",
      quest: "?",
      questeq: "â‰Ÿ",
      QUOT: '"',
      quot: '"',
      rAarr: "â‡›",
      race: "âˆ½Ì±",
      Racute: "Å”",
      racute: "Å•",
      radic: "âˆš",
      raemptyv: "â¦³",
      Rang: "âŸ«",
      rang: "âŸ©",
      rangd: "â¦’",
      range: "â¦¥",
      rangle: "âŸ©",
      raquo: "Â»",
      Rarr: "â† ",
      rArr: "â‡’",
      rarr: "â†’",
      rarrap: "â¥µ",
      rarrb: "â‡¥",
      rarrbfs: "â¤ ",
      rarrc: "â¤³",
      rarrfs: "â¤ž",
      rarrhk: "â†ª",
      rarrlp: "â†¬",
      rarrpl: "â¥…",
      rarrsim: "â¥´",
      Rarrtl: "â¤–",
      rarrtl: "â†£",
      rarrw: "â†",
      rAtail: "â¤œ",
      ratail: "â¤š",
      ratio: "âˆ¶",
      rationals: "â„š",
      RBarr: "â¤",
      rBarr: "â¤",
      rbarr: "â¤",
      rbbrk: "â³",
      rbrace: "}",
      rbrack: "]",
      rbrke: "â¦Œ",
      rbrksld: "â¦Ž",
      rbrkslu: "â¦",
      Rcaron: "Å˜",
      rcaron: "Å™",
      Rcedil: "Å–",
      rcedil: "Å—",
      rceil: "âŒ‰",
      rcub: "}",
      Rcy: "Ð ",
      rcy: "Ñ€",
      rdca: "â¤·",
      rdldhar: "â¥©",
      rdquo: "â€",
      rdquor: "â€",
      rdsh: "â†³",
      Re: "â„œ",
      real: "â„œ",
      realine: "â„›",
      realpart: "â„œ",
      reals: "â„",
      rect: "â–­",
      REG: "Â®",
      reg: "Â®",
      ReverseElement: "âˆ‹",
      ReverseEquilibrium: "â‡‹",
      ReverseUpEquilibrium: "â¥¯",
      rfisht: "â¥½",
      rfloor: "âŒ‹",
      Rfr: "â„œ",
      rfr: "ð”¯",
      rHar: "â¥¤",
      rhard: "â‡",
      rharu: "â‡€",
      rharul: "â¥¬",
      Rho: "Î¡",
      rho: "Ï",
      rhov: "Ï±",
      RightAngleBracket: "âŸ©",
      RightArrow: "â†’",
      Rightarrow: "â‡’",
      rightarrow: "â†’",
      RightArrowBar: "â‡¥",
      RightArrowLeftArrow: "â‡„",
      rightarrowtail: "â†£",
      RightCeiling: "âŒ‰",
      RightDoubleBracket: "âŸ§",
      RightDownTeeVector: "â¥",
      RightDownVector: "â‡‚",
      RightDownVectorBar: "â¥•",
      RightFloor: "âŒ‹",
      rightharpoondown: "â‡",
      rightharpoonup: "â‡€",
      rightleftarrows: "â‡„",
      rightleftharpoons: "â‡Œ",
      rightrightarrows: "â‡‰",
      rightsquigarrow: "â†",
      RightTee: "âŠ¢",
      RightTeeArrow: "â†¦",
      RightTeeVector: "â¥›",
      rightthreetimes: "â‹Œ",
      RightTriangle: "âŠ³",
      RightTriangleBar: "â§",
      RightTriangleEqual: "âŠµ",
      RightUpDownVector: "â¥",
      RightUpTeeVector: "â¥œ",
      RightUpVector: "â†¾",
      RightUpVectorBar: "â¥”",
      RightVector: "â‡€",
      RightVectorBar: "â¥“",
      ring: "Ëš",
      risingdotseq: "â‰“",
      rlarr: "â‡„",
      rlhar: "â‡Œ",
      rlm: "â€",
      rmoust: "âŽ±",
      rmoustache: "âŽ±",
      rnmid: "â«®",
      roang: "âŸ­",
      roarr: "â‡¾",
      robrk: "âŸ§",
      ropar: "â¦†",
      Ropf: "â„",
      ropf: "ð•£",
      roplus: "â¨®",
      rotimes: "â¨µ",
      RoundImplies: "â¥°",
      rpar: ")",
      rpargt: "â¦”",
      rppolint: "â¨’",
      rrarr: "â‡‰",
      Rrightarrow: "â‡›",
      rsaquo: "â€º",
      Rscr: "â„›",
      rscr: "ð“‡",
      Rsh: "â†±",
      rsh: "â†±",
      rsqb: "]",
      rsquo: "â€™",
      rsquor: "â€™",
      rthree: "â‹Œ",
      rtimes: "â‹Š",
      rtri: "â–¹",
      rtrie: "âŠµ",
      rtrif: "â–¸",
      rtriltri: "â§Ž",
      RuleDelayed: "â§´",
      ruluhar: "â¥¨",
      rx: "â„ž",
      Sacute: "Åš",
      sacute: "Å›",
      sbquo: "â€š",
      Sc: "âª¼",
      sc: "â‰»",
      scap: "âª¸",
      Scaron: "Å ",
      scaron: "Å¡",
      sccue: "â‰½",
      scE: "âª´",
      sce: "âª°",
      Scedil: "Åž",
      scedil: "ÅŸ",
      Scirc: "Åœ",
      scirc: "Å",
      scnap: "âªº",
      scnE: "âª¶",
      scnsim: "â‹©",
      scpolint: "â¨“",
      scsim: "â‰¿",
      Scy: "Ð¡",
      scy: "Ñ",
      sdot: "â‹…",
      sdotb: "âŠ¡",
      sdote: "â©¦",
      searhk: "â¤¥",
      seArr: "â‡˜",
      searr: "â†˜",
      searrow: "â†˜",
      sect: "Â§",
      semi: ";",
      seswar: "â¤©",
      setminus: "âˆ–",
      setmn: "âˆ–",
      sext: "âœ¶",
      Sfr: "ð”–",
      sfr: "ð”°",
      sfrown: "âŒ¢",
      sharp: "â™¯",
      SHCHcy: "Ð©",
      shchcy: "Ñ‰",
      SHcy: "Ð¨",
      shcy: "Ñˆ",
      ShortDownArrow: "â†“",
      ShortLeftArrow: "â†",
      shortmid: "âˆ£",
      shortparallel: "âˆ¥",
      ShortRightArrow: "â†’",
      ShortUpArrow: "â†‘",
      shy: "Â­",
      Sigma: "Î£",
      sigma: "Ïƒ",
      sigmaf: "Ï‚",
      sigmav: "Ï‚",
      sim: "âˆ¼",
      simdot: "â©ª",
      sime: "â‰ƒ",
      simeq: "â‰ƒ",
      simg: "âªž",
      simgE: "âª ",
      siml: "âª",
      simlE: "âªŸ",
      simne: "â‰†",
      simplus: "â¨¤",
      simrarr: "â¥²",
      slarr: "â†",
      SmallCircle: "âˆ˜",
      smallsetminus: "âˆ–",
      smashp: "â¨³",
      smeparsl: "â§¤",
      smid: "âˆ£",
      smile: "âŒ£",
      smt: "âªª",
      smte: "âª¬",
      smtes: "âª¬ï¸€",
      SOFTcy: "Ð¬",
      softcy: "ÑŒ",
      sol: "/",
      solb: "â§„",
      solbar: "âŒ¿",
      Sopf: "ð•Š",
      sopf: "ð•¤",
      spades: "â™ ",
      spadesuit: "â™ ",
      spar: "âˆ¥",
      sqcap: "âŠ“",
      sqcaps: "âŠ“ï¸€",
      sqcup: "âŠ”",
      sqcups: "âŠ”ï¸€",
      Sqrt: "âˆš",
      sqsub: "âŠ",
      sqsube: "âŠ‘",
      sqsubset: "âŠ",
      sqsubseteq: "âŠ‘",
      sqsup: "âŠ",
      sqsupe: "âŠ’",
      sqsupset: "âŠ",
      sqsupseteq: "âŠ’",
      squ: "â–¡",
      Square: "â–¡",
      square: "â–¡",
      SquareIntersection: "âŠ“",
      SquareSubset: "âŠ",
      SquareSubsetEqual: "âŠ‘",
      SquareSuperset: "âŠ",
      SquareSupersetEqual: "âŠ’",
      SquareUnion: "âŠ”",
      squarf: "â–ª",
      squf: "â–ª",
      srarr: "â†’",
      Sscr: "ð’®",
      sscr: "ð“ˆ",
      ssetmn: "âˆ–",
      ssmile: "âŒ£",
      sstarf: "â‹†",
      Star: "â‹†",
      star: "â˜†",
      starf: "â˜…",
      straightepsilon: "Ïµ",
      straightphi: "Ï•",
      strns: "Â¯",
      Sub: "â‹",
      sub: "âŠ‚",
      subdot: "âª½",
      subE: "â«…",
      sube: "âŠ†",
      subedot: "â«ƒ",
      submult: "â«",
      subnE: "â«‹",
      subne: "âŠŠ",
      subplus: "âª¿",
      subrarr: "â¥¹",
      Subset: "â‹",
      subset: "âŠ‚",
      subseteq: "âŠ†",
      subseteqq: "â«…",
      SubsetEqual: "âŠ†",
      subsetneq: "âŠŠ",
      subsetneqq: "â«‹",
      subsim: "â«‡",
      subsub: "â«•",
      subsup: "â«“",
      succ: "â‰»",
      succapprox: "âª¸",
      succcurlyeq: "â‰½",
      Succeeds: "â‰»",
      SucceedsEqual: "âª°",
      SucceedsSlantEqual: "â‰½",
      SucceedsTilde: "â‰¿",
      succeq: "âª°",
      succnapprox: "âªº",
      succneqq: "âª¶",
      succnsim: "â‹©",
      succsim: "â‰¿",
      SuchThat: "âˆ‹",
      Sum: "âˆ‘",
      sum: "âˆ‘",
      sung: "â™ª",
      Sup: "â‹‘",
      sup: "âŠƒ",
      sup1: "Â¹",
      sup2: "Â²",
      sup3: "Â³",
      supdot: "âª¾",
      supdsub: "â«˜",
      supE: "â«†",
      supe: "âŠ‡",
      supedot: "â«„",
      Superset: "âŠƒ",
      SupersetEqual: "âŠ‡",
      suphsol: "âŸ‰",
      suphsub: "â«—",
      suplarr: "â¥»",
      supmult: "â«‚",
      supnE: "â«Œ",
      supne: "âŠ‹",
      supplus: "â«€",
      Supset: "â‹‘",
      supset: "âŠƒ",
      supseteq: "âŠ‡",
      supseteqq: "â«†",
      supsetneq: "âŠ‹",
      supsetneqq: "â«Œ",
      supsim: "â«ˆ",
      supsub: "â«”",
      supsup: "â«–",
      swarhk: "â¤¦",
      swArr: "â‡™",
      swarr: "â†™",
      swarrow: "â†™",
      swnwar: "â¤ª",
      szlig: "ÃŸ",
      Tab: "	",
      target: "âŒ–",
      Tau: "Î¤",
      tau: "Ï„",
      tbrk: "âŽ´",
      Tcaron: "Å¤",
      tcaron: "Å¥",
      Tcedil: "Å¢",
      tcedil: "Å£",
      Tcy: "Ð¢",
      tcy: "Ñ‚",
      tdot: "âƒ›",
      telrec: "âŒ•",
      Tfr: "ð”—",
      tfr: "ð”±",
      there4: "âˆ´",
      Therefore: "âˆ´",
      therefore: "âˆ´",
      Theta: "Î˜",
      theta: "Î¸",
      thetasym: "Ï‘",
      thetav: "Ï‘",
      thickapprox: "â‰ˆ",
      thicksim: "âˆ¼",
      ThickSpace: "âŸâ€Š",
      thinsp: "â€‰",
      ThinSpace: "â€‰",
      thkap: "â‰ˆ",
      thksim: "âˆ¼",
      THORN: "Ãž",
      thorn: "Ã¾",
      Tilde: "âˆ¼",
      tilde: "Ëœ",
      TildeEqual: "â‰ƒ",
      TildeFullEqual: "â‰…",
      TildeTilde: "â‰ˆ",
      times: "Ã—",
      timesb: "âŠ ",
      timesbar: "â¨±",
      timesd: "â¨°",
      tint: "âˆ­",
      toea: "â¤¨",
      top: "âŠ¤",
      topbot: "âŒ¶",
      topcir: "â«±",
      Topf: "ð•‹",
      topf: "ð•¥",
      topfork: "â«š",
      tosa: "â¤©",
      tprime: "â€´",
      TRADE: "â„¢",
      trade: "â„¢",
      triangle: "â–µ",
      triangledown: "â–¿",
      triangleleft: "â—ƒ",
      trianglelefteq: "âŠ´",
      triangleq: "â‰œ",
      triangleright: "â–¹",
      trianglerighteq: "âŠµ",
      tridot: "â—¬",
      trie: "â‰œ",
      triminus: "â¨º",
      TripleDot: "âƒ›",
      triplus: "â¨¹",
      trisb: "â§",
      tritime: "â¨»",
      trpezium: "â¢",
      Tscr: "ð’¯",
      tscr: "ð“‰",
      TScy: "Ð¦",
      tscy: "Ñ†",
      TSHcy: "Ð‹",
      tshcy: "Ñ›",
      Tstrok: "Å¦",
      tstrok: "Å§",
      twixt: "â‰¬",
      twoheadleftarrow: "â†ž",
      twoheadrightarrow: "â† ",
      Uacute: "Ãš",
      uacute: "Ãº",
      Uarr: "â†Ÿ",
      uArr: "â‡‘",
      uarr: "â†‘",
      Uarrocir: "â¥‰",
      Ubrcy: "ÐŽ",
      ubrcy: "Ñž",
      Ubreve: "Å¬",
      ubreve: "Å­",
      Ucirc: "Ã›",
      ucirc: "Ã»",
      Ucy: "Ð£",
      ucy: "Ñƒ",
      udarr: "â‡…",
      Udblac: "Å°",
      udblac: "Å±",
      udhar: "â¥®",
      ufisht: "â¥¾",
      Ufr: "ð”˜",
      ufr: "ð”²",
      Ugrave: "Ã™",
      ugrave: "Ã¹",
      uHar: "â¥£",
      uharl: "â†¿",
      uharr: "â†¾",
      uhblk: "â–€",
      ulcorn: "âŒœ",
      ulcorner: "âŒœ",
      ulcrop: "âŒ",
      ultri: "â—¸",
      Umacr: "Åª",
      umacr: "Å«",
      uml: "Â¨",
      UnderBar: "_",
      UnderBrace: "âŸ",
      UnderBracket: "âŽµ",
      UnderParenthesis: "â",
      Union: "â‹ƒ",
      UnionPlus: "âŠŽ",
      Uogon: "Å²",
      uogon: "Å³",
      Uopf: "ð•Œ",
      uopf: "ð•¦",
      UpArrow: "â†‘",
      Uparrow: "â‡‘",
      uparrow: "â†‘",
      UpArrowBar: "â¤’",
      UpArrowDownArrow: "â‡…",
      UpDownArrow: "â†•",
      Updownarrow: "â‡•",
      updownarrow: "â†•",
      UpEquilibrium: "â¥®",
      upharpoonleft: "â†¿",
      upharpoonright: "â†¾",
      uplus: "âŠŽ",
      UpperLeftArrow: "â†–",
      UpperRightArrow: "â†—",
      Upsi: "Ï’",
      upsi: "Ï…",
      upsih: "Ï’",
      Upsilon: "Î¥",
      upsilon: "Ï…",
      UpTee: "âŠ¥",
      UpTeeArrow: "â†¥",
      upuparrows: "â‡ˆ",
      urcorn: "âŒ",
      urcorner: "âŒ",
      urcrop: "âŒŽ",
      Uring: "Å®",
      uring: "Å¯",
      urtri: "â—¹",
      Uscr: "ð’°",
      uscr: "ð“Š",
      utdot: "â‹°",
      Utilde: "Å¨",
      utilde: "Å©",
      utri: "â–µ",
      utrif: "â–´",
      uuarr: "â‡ˆ",
      Uuml: "Ãœ",
      uuml: "Ã¼",
      uwangle: "â¦§",
      vangrt: "â¦œ",
      varepsilon: "Ïµ",
      varkappa: "Ï°",
      varnothing: "âˆ…",
      varphi: "Ï•",
      varpi: "Ï–",
      varpropto: "âˆ",
      vArr: "â‡•",
      varr: "â†•",
      varrho: "Ï±",
      varsigma: "Ï‚",
      varsubsetneq: "âŠŠï¸€",
      varsubsetneqq: "â«‹ï¸€",
      varsupsetneq: "âŠ‹ï¸€",
      varsupsetneqq: "â«Œï¸€",
      vartheta: "Ï‘",
      vartriangleleft: "âŠ²",
      vartriangleright: "âŠ³",
      Vbar: "â««",
      vBar: "â«¨",
      vBarv: "â«©",
      Vcy: "Ð’",
      vcy: "Ð²",
      VDash: "âŠ«",
      Vdash: "âŠ©",
      vDash: "âŠ¨",
      vdash: "âŠ¢",
      Vdashl: "â«¦",
      Vee: "â‹",
      vee: "âˆ¨",
      veebar: "âŠ»",
      veeeq: "â‰š",
      vellip: "â‹®",
      Verbar: "â€–",
      verbar: "|",
      Vert: "â€–",
      vert: "|",
      VerticalBar: "âˆ£",
      VerticalLine: "|",
      VerticalSeparator: "â˜",
      VerticalTilde: "â‰€",
      VeryThinSpace: "â€Š",
      Vfr: "ð”™",
      vfr: "ð”³",
      vltri: "âŠ²",
      vnsub: "âŠ‚âƒ’",
      vnsup: "âŠƒâƒ’",
      Vopf: "ð•",
      vopf: "ð•§",
      vprop: "âˆ",
      vrtri: "âŠ³",
      Vscr: "ð’±",
      vscr: "ð“‹",
      vsubnE: "â«‹ï¸€",
      vsubne: "âŠŠï¸€",
      vsupnE: "â«Œï¸€",
      vsupne: "âŠ‹ï¸€",
      Vvdash: "âŠª",
      vzigzag: "â¦š",
      Wcirc: "Å´",
      wcirc: "Åµ",
      wedbar: "â©Ÿ",
      Wedge: "â‹€",
      wedge: "âˆ§",
      wedgeq: "â‰™",
      weierp: "â„˜",
      Wfr: "ð”š",
      wfr: "ð”´",
      Wopf: "ð•Ž",
      wopf: "ð•¨",
      wp: "â„˜",
      wr: "â‰€",
      wreath: "â‰€",
      Wscr: "ð’²",
      wscr: "ð“Œ",
      xcap: "â‹‚",
      xcirc: "â—¯",
      xcup: "â‹ƒ",
      xdtri: "â–½",
      Xfr: "ð”›",
      xfr: "ð”µ",
      xhArr: "âŸº",
      xharr: "âŸ·",
      Xi: "Îž",
      xi: "Î¾",
      xlArr: "âŸ¸",
      xlarr: "âŸµ",
      xmap: "âŸ¼",
      xnis: "â‹»",
      xodot: "â¨€",
      Xopf: "ð•",
      xopf: "ð•©",
      xoplus: "â¨",
      xotime: "â¨‚",
      xrArr: "âŸ¹",
      xrarr: "âŸ¶",
      Xscr: "ð’³",
      xscr: "ð“",
      xsqcup: "â¨†",
      xuplus: "â¨„",
      xutri: "â–³",
      xvee: "â‹",
      xwedge: "â‹€",
      Yacute: "Ã",
      yacute: "Ã½",
      YAcy: "Ð¯",
      yacy: "Ñ",
      Ycirc: "Å¶",
      ycirc: "Å·",
      Ycy: "Ð«",
      ycy: "Ñ‹",
      yen: "Â¥",
      Yfr: "ð”œ",
      yfr: "ð”¶",
      YIcy: "Ð‡",
      yicy: "Ñ—",
      Yopf: "ð•",
      yopf: "ð•ª",
      Yscr: "ð’´",
      yscr: "ð“Ž",
      YUcy: "Ð®",
      yucy: "ÑŽ",
      Yuml: "Å¸",
      yuml: "Ã¿",
      Zacute: "Å¹",
      zacute: "Åº",
      Zcaron: "Å½",
      zcaron: "Å¾",
      Zcy: "Ð—",
      zcy: "Ð·",
      Zdot: "Å»",
      zdot: "Å¼",
      zeetrf: "â„¨",
      ZeroWidthSpace: "â€‹",
      Zeta: "Î–",
      zeta: "Î¶",
      Zfr: "â„¨",
      zfr: "ð”·",
      ZHcy: "Ð–",
      zhcy: "Ð¶",
      zigrarr: "â‡",
      Zopf: "â„¤",
      zopf: "ð•«",
      Zscr: "ð’µ",
      zscr: "ð“",
      zwj: "â€",
      zwnj: "â€Œ"
    }), t.entityMap = t.HTML_ENTITIES;
  }(kc)), kc;
}
var Zi = {}, rf;
function Zx() {
  if (rf) return Zi;
  rf = 1;
  var t = $i(), e = Tg(), n = Ll(), r = t.isHTMLEscapableRawTextElement, o = t.isHTMLMimeType, i = t.isHTMLRawTextElement, s = t.hasOwn, a = t.NAMESPACE, l = n.ParseError, c = n.DOMException, u = 0, p = 1, f = 2, h = 3, g = 4, b = 5, _ = 6, x = 7;
  function y() {
  }
  y.prototype = {
    parse: function(N, T, $) {
      var L = this.domBuilder;
      L.startDocument(), F(T, T = /* @__PURE__ */ Object.create(null)), P(N, T, $, L, this.errorHandler), L.endDocument();
    }
  };
  var A = /&#?\w+;?/g;
  function P(N, T, $, L, J) {
    var G = o(L.mimeType);
    N.indexOf(e.UNICODE_REPLACEMENT_CHARACTER) >= 0 && J.warning("Unicode replacement character detected, source encoding issues?");
    function W(ge) {
      if (ge > 65535) {
        ge -= 65536;
        var ze = 55296 + (ge >> 10), Tt = 56320 + (ge & 1023);
        return String.fromCharCode(ze, Tt);
      } else
        return String.fromCharCode(ge);
    }
    function ee(ge) {
      var ze = ge[ge.length - 1] === ";" ? ge : ge + ";";
      if (!G && ze !== ge)
        return J.error("EntityRef: expecting ;"), ge;
      var Tt = e.Reference.exec(ze);
      if (!Tt || Tt[0].length !== ze.length)
        return J.error("entity not matching Reference production: " + ge), ge;
      var Ot = ze.slice(1, -1);
      return s($, Ot) ? $[Ot] : Ot.charAt(0) === "#" ? W(parseInt(Ot.substring(1).replace("x", "0x"))) : (J.error("entity not found:" + ge), ge);
    }
    function te(ge) {
      if (ge > ye) {
        var ze = N.substring(ye, ge).replace(A, ee);
        de && pe(ye), L.characters(ze, 0, ge - ye), ye = ge;
      }
    }
    var Z = 0, Y = 0, le = /\r\n?|\n|$/g, de = L.locator;
    function pe(ge, ze) {
      for (; ge >= Y && (ze = le.exec(N)); )
        Z = Y, Y = ze.index + ze[0].length, de.lineNumber++;
      de.columnNumber = ge - Z + 1;
    }
    for (var _e = [{ currentNSMap: T }], be = [], ye = 0; ; ) {
      try {
        var se = N.indexOf("<", ye);
        if (se < 0) {
          if (!G && be.length > 0)
            return J.fatalError("unclosed xml tag(s): " + be.join(", "));
          if (!N.substring(ye).match(/^\s*$/)) {
            var Se = L.doc, Fe = Se.createTextNode(N.substring(ye));
            if (Se.documentElement)
              return J.error("Extra content at the end of the document");
            Se.appendChild(Fe), L.currentElement = Fe;
          }
          return;
        }
        if (se > ye) {
          var re = N.substring(ye, se);
          !G && be.length === 0 && (re = re.replace(new RegExp(e.S_OPT.source, "g"), ""), re && J.error("Unexpected content outside root element: '" + re + "'")), te(se);
        }
        switch (N.charAt(se + 1)) {
          case "/":
            var nt = N.indexOf(">", se + 2), Ce = N.substring(se + 2, nt > 0 ? nt : void 0);
            if (!Ce)
              return J.fatalError("end tag name missing");
            var Re = nt > 0 && e.reg("^", e.QName_group, e.S_OPT, "$").exec(Ce);
            if (!Re)
              return J.fatalError('end tag name contains invalid characters: "' + Ce + '"');
            if (!L.currentElement && !L.doc.documentElement)
              return;
            var je = be[be.length - 1] || L.currentElement.tagName || L.doc.documentElement.tagName || "";
            if (je !== Re[1]) {
              var Je = Re[1].toLowerCase();
              if (!G || je.toLowerCase() !== Je)
                return J.fatalError('Opening and ending tag mismatch: "' + je + '" != "' + Ce + '"');
            }
            var wt = _e.pop();
            be.pop();
            var ut = wt.localNSMap;
            if (L.endElement(wt.uri, wt.localName, je), ut)
              for (var yt in ut)
                s(ut, yt) && L.endPrefixMapping(yt);
            nt++;
            break;
          // end element
          case "?":
            de && pe(se), nt = k(N, se, L, J);
            break;
          case "!":
            de && pe(se), nt = S(N, se, L, J, G);
            break;
          default:
            de && pe(se);
            var Me = new I(), Nt = _e[_e.length - 1].currentNSMap, nt = O(N, se, Me, Nt, ee, J, G), Pn = Me.length;
            if (Me.closed || (G && t.isHTMLVoidElement(Me.tagName) ? Me.closed = !0 : be.push(Me.tagName)), de && Pn) {
              for (var mn = V(de, {}), ln = 0; ln < Pn; ln++) {
                var bn = Me[ln];
                pe(bn.offset), bn.locator = V(de, {});
              }
              L.locator = mn, U(Me, L, Nt) && _e.push(Me), L.locator = de;
            } else
              U(Me, L, Nt) && _e.push(Me);
            G && !Me.closed ? nt = B(N, nt, Me.tagName, ee, L) : nt++;
        }
      } catch (ge) {
        if (ge instanceof l)
          throw ge;
        if (ge instanceof c)
          throw new l(ge.name + ": " + ge.message, L.locator, ge);
        J.error("element parse error: " + ge), nt = -1;
      }
      nt > ye ? ye = nt : te(Math.max(se, ye) + 1);
    }
  }
  function V(N, T) {
    return T.lineNumber = N.lineNumber, T.columnNumber = N.columnNumber, T;
  }
  function O(N, T, $, L, J, G, W) {
    function ee(pe, _e, be) {
      if (s($.attributeNames, pe))
        return G.fatalError("Attribute " + pe + " redefined");
      if (!W && _e.indexOf("<") >= 0)
        return G.fatalError("Unescaped '<' not allowed in attributes values");
      $.addValue(
        pe,
        // @see https://www.w3.org/TR/xml/#AVNormalize
        // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
        // - recursive replacement of (DTD) entity references
        // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
        _e.replace(/[\t\n\r]/g, " ").replace(A, J),
        be
      );
    }
    for (var te, Z, Y = ++T, le = u; ; ) {
      var de = N.charAt(Y);
      switch (de) {
        case "=":
          if (le === p)
            te = N.slice(T, Y), le = h;
          else if (le === f)
            le = h;
          else
            throw new Error("attribute equal must after attrName");
          break;
        case "'":
        case '"':
          if (le === h || le === p)
            if (le === p && (G.warning('attribute value must after "="'), te = N.slice(T, Y)), T = Y + 1, Y = N.indexOf(de, T), Y > 0)
              Z = N.slice(T, Y), ee(te, Z, T - 1), le = b;
            else
              throw new Error("attribute value no end '" + de + "' match");
          else if (le == g)
            Z = N.slice(T, Y), ee(te, Z, T), G.warning('attribute "' + te + '" missed start quot(' + de + ")!!"), T = Y + 1, le = b;
          else
            throw new Error('attribute value must after "="');
          break;
        case "/":
          switch (le) {
            case u:
              $.setTagName(N.slice(T, Y));
            case b:
            case _:
            case x:
              le = x, $.closed = !0;
            case g:
            case p:
              break;
            case f:
              $.closed = !0;
              break;
            //case S_EQ:
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          return G.error("unexpected end of input"), le == u && $.setTagName(N.slice(T, Y)), Y;
        case ">":
          switch (le) {
            case u:
              $.setTagName(N.slice(T, Y));
            case b:
            case _:
            case x:
              break;
            //normal
            case g:
            //Compatible state
            case p:
              Z = N.slice(T, Y), Z.slice(-1) === "/" && ($.closed = !0, Z = Z.slice(0, -1));
            case f:
              le === f && (Z = te), le == g ? (G.warning('attribute "' + Z + '" missed quot(")!'), ee(te, Z, T)) : (W || G.warning('attribute "' + Z + '" missed value!! "' + Z + '" instead!!'), ee(Z, Z, T));
              break;
            case h:
              if (!W)
                return G.fatalError(`AttValue: ' or " expected`);
          }
          return Y;
        /*xml space '\x20' | #x9 | #xD | #xA; */
        case "Â€":
          de = " ";
        default:
          if (de <= " ")
            switch (le) {
              case u:
                $.setTagName(N.slice(T, Y)), le = _;
                break;
              case p:
                te = N.slice(T, Y), le = f;
                break;
              case g:
                var Z = N.slice(T, Y);
                G.warning('attribute "' + Z + '" missed quot(")!!'), ee(te, Z, T);
              case b:
                le = _;
                break;
            }
          else
            switch (le) {
              //case S_TAG:void();break;
              //case S_ATTR:void();break;
              //case S_ATTR_NOQUOT_VALUE:void();break;
              case f:
                W || G.warning('attribute "' + te + '" missed value!! "' + te + '" instead2!!'), ee(te, te, T), T = Y, le = p;
                break;
              case b:
                G.warning('attribute space is required"' + te + '"!!');
              case _:
                le = p, T = Y;
                break;
              case h:
                le = g, T = Y;
                break;
              case x:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
      }
      Y++;
    }
  }
  function U(N, T, $) {
    for (var L = N.tagName, J = null, le = N.length; le--; ) {
      var G = N[le], W = G.qName, ee = G.value, de = W.indexOf(":");
      if (de > 0)
        var te = G.prefix = W.slice(0, de), Z = W.slice(de + 1), Y = te === "xmlns" && Z;
      else
        Z = W, te = null, Y = W === "xmlns" && "";
      G.localName = Z, Y !== !1 && (J == null && (J = /* @__PURE__ */ Object.create(null), F($, $ = /* @__PURE__ */ Object.create(null))), $[Y] = J[Y] = ee, G.uri = a.XMLNS, T.startPrefixMapping(Y, ee));
    }
    for (var le = N.length; le--; )
      G = N[le], G.prefix && (G.prefix === "xml" && (G.uri = a.XML), G.prefix !== "xmlns" && (G.uri = $[G.prefix]));
    var de = L.indexOf(":");
    de > 0 ? (te = N.prefix = L.slice(0, de), Z = N.localName = L.slice(de + 1)) : (te = null, Z = N.localName = L);
    var pe = N.uri = $[te || ""];
    if (T.startElement(pe, Z, L, N), N.closed) {
      if (T.endElement(pe, Z, L), J)
        for (te in J)
          s(J, te) && T.endPrefixMapping(te);
    } else
      return N.currentNSMap = $, N.localNSMap = J, !0;
  }
  function B(N, T, $, L, J) {
    var G = r($);
    if (G || i($)) {
      var W = N.indexOf("</" + $ + ">", T), ee = N.substring(T + 1, W);
      return G && (ee = ee.replace(A, L)), J.characters(ee, 0, ee.length), W;
    }
    return T + 1;
  }
  function F(N, T) {
    for (var $ in N)
      s(N, $) && (T[$] = N[$]);
  }
  function K(N, T) {
    var $ = T;
    function L(Y) {
      return Y = Y || 0, N.charAt($ + Y);
    }
    function J(Y) {
      Y = Y || 1, $ += Y;
    }
    function G() {
      for (var Y = 0; $ < N.length; ) {
        var le = L();
        if (le !== " " && le !== `
` && le !== "	" && le !== "\r")
          return Y;
        Y++, J();
      }
      return -1;
    }
    function W() {
      return N.substring($);
    }
    function ee(Y) {
      return N.substring($, $ + Y.length) === Y;
    }
    function te(Y) {
      return N.substring($, $ + Y.length).toUpperCase() === Y.toUpperCase();
    }
    function Z(Y) {
      var le = e.reg("^", Y), de = le.exec(W());
      return de ? (J(de[0].length), de[0]) : null;
    }
    return {
      char: L,
      getIndex: function() {
        return $;
      },
      getMatch: Z,
      getSource: function() {
        return N;
      },
      skip: J,
      skipBlanks: G,
      substringFromIndex: W,
      substringStartsWith: ee,
      substringStartsWithCaseInsensitive: te
    };
  }
  function E(N, T) {
    function $(ee, te) {
      var Z = e.PI.exec(ee.substringFromIndex());
      return Z ? Z[1].toLowerCase() === "xml" ? te.fatalError(
        "xml declaration is only allowed at the start of the document, but found at position " + ee.getIndex()
      ) : (ee.skip(Z[0].length), Z[0]) : te.fatalError("processing instruction is not well-formed at position " + ee.getIndex());
    }
    var L = N.getSource();
    if (N.char() === "[") {
      N.skip(1);
      for (var J = N.getIndex(); N.getIndex() < L.length; ) {
        if (N.skipBlanks(), N.char() === "]") {
          var G = L.substring(J, N.getIndex());
          return N.skip(1), G;
        }
        var W = null;
        if (N.char() === "<" && N.char(1) === "!")
          switch (N.char(2)) {
            case "E":
              N.char(3) === "L" ? W = N.getMatch(e.elementdecl) : N.char(3) === "N" && (W = N.getMatch(e.EntityDecl));
              break;
            case "A":
              W = N.getMatch(e.AttlistDecl);
              break;
            case "N":
              W = N.getMatch(e.NotationDecl);
              break;
            case "-":
              W = N.getMatch(e.Comment);
              break;
          }
        else if (N.char() === "<" && N.char(1) === "?")
          W = $(N, T);
        else if (N.char() === "%")
          W = N.getMatch(e.PEReference);
        else
          return T.fatalError("Error detected in Markup declaration");
        if (!W)
          return T.fatalError("Error in internal subset at position " + N.getIndex());
      }
      return T.fatalError("doctype internal subset is not well-formed, missing ]");
    }
  }
  function S(N, T, $, L, J) {
    var G = K(N, T);
    switch (J ? G.char(2).toUpperCase() : G.char(2)) {
      case "-":
        var W = G.getMatch(e.Comment);
        return W ? ($.comment(W, e.COMMENT_START.length, W.length - e.COMMENT_START.length - e.COMMENT_END.length), G.getIndex()) : L.fatalError("comment is not well-formed at position " + G.getIndex());
      case "[":
        var ee = G.getMatch(e.CDSect);
        return ee ? !J && !$.currentElement ? L.fatalError("CDATA outside of element") : ($.startCDATA(), $.characters(ee, e.CDATA_START.length, ee.length - e.CDATA_START.length - e.CDATA_END.length), $.endCDATA(), G.getIndex()) : L.fatalError("Invalid CDATA starting at position " + T);
      case "D": {
        if ($.doc && $.doc.documentElement)
          return L.fatalError("Doctype not allowed inside or after documentElement at position " + G.getIndex());
        if (J ? !G.substringStartsWithCaseInsensitive(e.DOCTYPE_DECL_START) : !G.substringStartsWith(e.DOCTYPE_DECL_START))
          return L.fatalError("Expected " + e.DOCTYPE_DECL_START + " at position " + G.getIndex());
        if (G.skip(e.DOCTYPE_DECL_START.length), G.skipBlanks() < 1)
          return L.fatalError("Expected whitespace after " + e.DOCTYPE_DECL_START + " at position " + G.getIndex());
        var te = {
          name: void 0,
          publicId: void 0,
          systemId: void 0,
          internalSubset: void 0
        };
        if (te.name = G.getMatch(e.Name), !te.name)
          return L.fatalError("doctype name missing or contains unexpected characters at position " + G.getIndex());
        if (J && te.name.toLowerCase() !== "html" && L.warning("Unexpected DOCTYPE in HTML document at position " + G.getIndex()), G.skipBlanks(), G.substringStartsWith(e.PUBLIC) || G.substringStartsWith(e.SYSTEM)) {
          var Z = e.ExternalID_match.exec(G.substringFromIndex());
          if (!Z)
            return L.fatalError("doctype external id is not well-formed at position " + G.getIndex());
          Z.groups.SystemLiteralOnly !== void 0 ? te.systemId = Z.groups.SystemLiteralOnly : (te.systemId = Z.groups.SystemLiteral, te.publicId = Z.groups.PubidLiteral), G.skip(Z[0].length);
        } else if (J && G.substringStartsWithCaseInsensitive(e.SYSTEM)) {
          if (G.skip(e.SYSTEM.length), G.skipBlanks() < 1)
            return L.fatalError("Expected whitespace after " + e.SYSTEM + " at position " + G.getIndex());
          if (te.systemId = G.getMatch(e.ABOUT_LEGACY_COMPAT_SystemLiteral), !te.systemId)
            return L.fatalError(
              "Expected " + e.ABOUT_LEGACY_COMPAT + " in single or double quotes after " + e.SYSTEM + " at position " + G.getIndex()
            );
        }
        return J && te.systemId && !e.ABOUT_LEGACY_COMPAT_SystemLiteral.test(te.systemId) && L.warning("Unexpected doctype.systemId in HTML document at position " + G.getIndex()), J || (G.skipBlanks(), te.internalSubset = E(G, L)), G.skipBlanks(), G.char() !== ">" ? L.fatalError("doctype not terminated with > at position " + G.getIndex()) : (G.skip(1), $.startDTD(te.name, te.publicId, te.systemId, te.internalSubset), $.endDTD(), G.getIndex());
      }
      default:
        return L.fatalError('Not well-formed XML starting with "<!" at position ' + T);
    }
  }
  function k(N, T, $, L) {
    var J = N.substring(T).match(e.PI);
    if (!J)
      return L.fatalError("Invalid processing instruction starting at position " + T);
    if (J[1].toLowerCase() === "xml") {
      if (T > 0)
        return L.fatalError(
          "processing instruction at position " + T + " is an xml declaration which is only at the start of the document"
        );
      if (!e.XMLDecl.test(N.substring(T)))
        return L.fatalError("xml declaration is not well-formed");
    }
    return $.processingInstruction(J[1], J[2]), T + J[0].length;
  }
  function I() {
    this.attributeNames = /* @__PURE__ */ Object.create(null);
  }
  return I.prototype = {
    setTagName: function(N) {
      if (!e.QName_exact.test(N))
        throw new Error("invalid tagName:" + N);
      this.tagName = N;
    },
    addValue: function(N, T, $) {
      if (!e.QName_exact.test(N))
        throw new Error("invalid attribute:" + N);
      this.attributeNames[N] = this.length, this[this.length++] = { qName: N, value: T, offset: $ };
    },
    length: 0,
    getLocalName: function(N) {
      return this[N].localName;
    },
    getLocator: function(N) {
      return this[N].locator;
    },
    getQName: function(N) {
      return this[N].qName;
    },
    getURI: function(N) {
      return this[N].uri;
    },
    getValue: function(N) {
      return this[N].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  }, Zi.XMLReader = y, Zi.parseUtils = K, Zi.parseDoctypeCommentOrCData = S, Zi;
}
var of;
function e1() {
  if (of) return wo;
  of = 1;
  var t = $i(), e = Ag(), n = Ll(), r = Qx(), o = Zx(), i = e.DOMImplementation, s = t.hasDefaultHTMLNamespace, a = t.isHTMLMimeType, l = t.isValidMimeType, c = t.MIME_TYPE, u = t.NAMESPACE, p = n.ParseError, f = o.XMLReader;
  function h(O) {
    return O.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028\u2029]/g, `
`);
  }
  function g(O) {
    if (O = O || {}, O.locator === void 0 && (O.locator = !0), this.assign = O.assign || t.assign, this.domHandler = O.domHandler || b, this.onError = O.onError || O.errorHandler, O.errorHandler && typeof O.errorHandler != "function")
      throw new TypeError("errorHandler object is no longer supported, switch to onError!");
    O.errorHandler && O.errorHandler("warning", "The `errorHandler` option has been deprecated, use `onError` instead!", this), this.normalizeLineEndings = O.normalizeLineEndings || h, this.locator = !!O.locator, this.xmlns = this.assign(/* @__PURE__ */ Object.create(null), O.xmlns);
  }
  g.prototype.parseFromString = function(O, U) {
    if (!l(U))
      throw new TypeError('DOMParser.parseFromString: the provided mimeType "' + U + '" is not valid.');
    var B = this.assign(/* @__PURE__ */ Object.create(null), this.xmlns), F = r.XML_ENTITIES, K = B[""] || null;
    s(U) ? (F = r.HTML_ENTITIES, K = u.HTML) : U === c.XML_SVG_IMAGE && (K = u.SVG), B[""] = K, B.xml = B.xml || u.XML;
    var E = new this.domHandler({
      mimeType: U,
      defaultNamespace: K,
      onError: this.onError
    }), S = this.locator ? {} : void 0;
    this.locator && E.setDocumentLocator(S);
    var k = new f();
    k.errorHandler = E, k.domBuilder = E;
    var I = !t.isHTMLMimeType(U);
    return I && typeof O != "string" && k.errorHandler.fatalError("source is not a string"), k.parse(this.normalizeLineEndings(String(O)), B, F), E.doc.documentElement || k.errorHandler.fatalError("missing root element"), E.doc;
  };
  function b(O) {
    var U = O || {};
    this.mimeType = U.mimeType || c.XML_APPLICATION, this.defaultNamespace = U.defaultNamespace || null, this.cdata = !1, this.currentElement = void 0, this.doc = void 0, this.locator = void 0, this.onError = U.onError;
  }
  function _(O, U) {
    U.lineNumber = O.lineNumber, U.columnNumber = O.columnNumber;
  }
  b.prototype = {
    /**
     * Either creates an XML or an HTML document and stores it under `this.doc`.
     * If it is an XML document, `this.defaultNamespace` is used to create it,
     * and it will not contain any `childNodes`.
     * If it is an HTML document, it will be created without any `childNodes`.
     *
     * @see http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
     */
    startDocument: function() {
      var O = new i();
      this.doc = a(this.mimeType) ? O.createHTMLDocument(!1) : O.createDocument(this.defaultNamespace, "");
    },
    startElement: function(O, U, B, F) {
      var K = this.doc, E = K.createElementNS(O, B || U), S = F.length;
      A(this, E), this.currentElement = E, this.locator && _(this.locator, E);
      for (var k = 0; k < S; k++) {
        var O = F.getURI(k), I = F.getValue(k), B = F.getQName(k), N = K.createAttributeNS(O, B);
        this.locator && _(F.getLocator(k), N), N.value = N.nodeValue = I, E.setAttributeNode(N);
      }
    },
    endElement: function(O, U, B) {
      this.currentElement = this.currentElement.parentNode;
    },
    startPrefixMapping: function(O, U) {
    },
    endPrefixMapping: function(O) {
    },
    processingInstruction: function(O, U) {
      var B = this.doc.createProcessingInstruction(O, U);
      this.locator && _(this.locator, B), A(this, B);
    },
    ignorableWhitespace: function(O, U, B) {
    },
    characters: function(O, U, B) {
      if (O = y.apply(this, arguments), O) {
        if (this.cdata)
          var F = this.doc.createCDATASection(O);
        else
          var F = this.doc.createTextNode(O);
        this.currentElement ? this.currentElement.appendChild(F) : /^\s*$/.test(O) && this.doc.appendChild(F), this.locator && _(this.locator, F);
      }
    },
    skippedEntity: function(O) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    /**
     * Stores the locator to be able to set the `columnNumber` and `lineNumber`
     * on the created DOM nodes.
     *
     * @param {Locator} locator
     */
    setDocumentLocator: function(O) {
      O && (O.lineNumber = 0), this.locator = O;
    },
    //LexicalHandler
    comment: function(O, U, B) {
      O = y.apply(this, arguments);
      var F = this.doc.createComment(O);
      this.locator && _(this.locator, F), A(this, F);
    },
    startCDATA: function() {
      this.cdata = !0;
    },
    endCDATA: function() {
      this.cdata = !1;
    },
    startDTD: function(O, U, B, F) {
      var K = this.doc.implementation;
      if (K && K.createDocumentType) {
        var E = K.createDocumentType(O, U, B, F);
        this.locator && _(this.locator, E), A(this, E), this.doc.doctype = E;
      }
    },
    reportError: function(O, U) {
      if (typeof this.onError == "function")
        try {
          this.onError(O, U, this);
        } catch (B) {
          throw new p("Reporting " + O + ' "' + U + '" caused ' + B, this.locator);
        }
      else
        console.error("[xmldom " + O + "]	" + U, x(this.locator));
    },
    /**
     * @see http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(O) {
      this.reportError("warning", O);
    },
    error: function(O) {
      this.reportError("error", O);
    },
    /**
     * This function reports a fatal error and throws a ParseError.
     *
     * @param {string} message
     * - The message to be used for reporting and throwing the error.
     * @returns {never}
     * This function always throws an error and never returns a value.
     * @throws {ParseError}
     * Always throws a ParseError with the provided message.
     */
    fatalError: function(O) {
      throw this.reportError("fatalError", O), new p(O, this.locator);
    }
  };
  function x(O) {
    if (O)
      return `
@#[line:` + O.lineNumber + ",col:" + O.columnNumber + "]";
  }
  function y(O, U, B) {
    return typeof O == "string" ? O.substr(U, B) : O.length >= U + B || U ? new java.lang.String(O, U, B) + "" : O;
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(
    /\w+/g,
    function(O) {
      b.prototype[O] = function() {
        return null;
      };
    }
  );
  function A(O, U) {
    O.currentElement ? O.currentElement.appendChild(U) : O.doc.appendChild(U);
  }
  function P(O) {
    if (O === "error") throw "onErrorStopParsing";
  }
  function V() {
    throw "onWarningStopParsing";
  }
  return wo.__DOMHandler = b, wo.DOMParser = g, wo.normalizeLineEndings = h, wo.onErrorStopParsing = P, wo.onWarningStopParsing = V, wo;
}
var sf;
function t1() {
  if (sf) return Pe;
  sf = 1;
  var t = $i();
  Pe.assign = t.assign, Pe.hasDefaultHTMLNamespace = t.hasDefaultHTMLNamespace, Pe.isHTMLMimeType = t.isHTMLMimeType, Pe.isValidMimeType = t.isValidMimeType, Pe.MIME_TYPE = t.MIME_TYPE, Pe.NAMESPACE = t.NAMESPACE;
  var e = Ll();
  Pe.DOMException = e.DOMException, Pe.DOMExceptionName = e.DOMExceptionName, Pe.ExceptionCode = e.ExceptionCode, Pe.ParseError = e.ParseError;
  var n = Ag();
  Pe.Attr = n.Attr, Pe.CDATASection = n.CDATASection, Pe.CharacterData = n.CharacterData, Pe.Comment = n.Comment, Pe.Document = n.Document, Pe.DocumentFragment = n.DocumentFragment, Pe.DocumentType = n.DocumentType, Pe.DOMImplementation = n.DOMImplementation, Pe.Element = n.Element, Pe.Entity = n.Entity, Pe.EntityReference = n.EntityReference, Pe.LiveNodeList = n.LiveNodeList, Pe.NamedNodeMap = n.NamedNodeMap, Pe.Node = n.Node, Pe.NodeList = n.NodeList, Pe.Notation = n.Notation, Pe.ProcessingInstruction = n.ProcessingInstruction, Pe.Text = n.Text, Pe.XMLSerializer = n.XMLSerializer;
  var r = e1();
  return Pe.DOMParser = r.DOMParser, Pe.normalizeLineEndings = r.normalizeLineEndings, Pe.onErrorStopParsing = r.onErrorStopParsing, Pe.onWarningStopParsing = r.onWarningStopParsing, Pe;
}
t1();
const ks = "USJ", Ns = "3.1", Sd = Object.freeze({ type: ks, version: Ns, content: [] }), n1 = [
  "type",
  "marker",
  "content",
  "sid",
  "eid",
  "number",
  "code",
  "altnumber",
  "pubnumber",
  "caller",
  "align",
  "category"
];
function r1(t) {
  return o1.includes(t);
}
const o1 = [
  // Old Testament
  "GEN",
  "EXO",
  "LEV",
  "NUM",
  "DEU",
  "JOS",
  "JDG",
  "RUT",
  "1SA",
  "2SA",
  "1KI",
  "2KI",
  "1CH",
  "2CH",
  "EZR",
  "NEH",
  "EST",
  "JOB",
  "PSA",
  "PRO",
  "ECC",
  "SNG",
  "ISA",
  "JER",
  "LAM",
  "EZK",
  "DAN",
  "HOS",
  "JOL",
  "AMO",
  "OBA",
  "JON",
  "MIC",
  "NAM",
  "HAB",
  "ZEP",
  "HAG",
  "ZEC",
  "MAL",
  // New Testament
  "MAT",
  "MRK",
  "LUK",
  "JHN",
  "ACT",
  "ROM",
  "1CO",
  "2CO",
  "GAL",
  "EPH",
  "PHP",
  "COL",
  "1TH",
  "2TH",
  "1TI",
  "2TI",
  "TIT",
  "PHM",
  "HEB",
  "JAS",
  "1PE",
  "2PE",
  "1JN",
  "2JN",
  "3JN",
  "JUD",
  "REV",
  // Deuterocanon
  "TOB",
  "JDT",
  "ESG",
  "WIS",
  "SIR",
  "BAR",
  "LJE",
  "S3Y",
  "SUS",
  "BEL",
  "1MA",
  "2MA",
  "3MA",
  "4MA",
  "1ES",
  "2ES",
  "MAN",
  "PS2",
  "ODA",
  "PSS",
  "EZA",
  "5EZ",
  "6EZ",
  "DAG",
  "PS3",
  "2BA",
  "LBA",
  "JUB",
  "ENO",
  "1MQ",
  "2MQ",
  "3MQ",
  "REP",
  "4BA",
  "LAO",
  // Non scripture
  "FRT",
  "BAK",
  "OTH",
  "INT",
  "CNC",
  "GLO",
  "TDX",
  "NDX",
  "XXA",
  "XXB",
  "XXC",
  "XXD",
  "XXE",
  "XXF",
  "XXG"
], pu = "$", Sg = ".content[";
function i1(t) {
  const e = t.split(Sg);
  if (e.shift() !== pu)
    throw new Error(`indexesFromJsonPath: jsonPath didn't start with '${pu}'`);
  return e.map((n) => parseInt(n, 10));
}
function s1(t) {
  return t.reduce((e, n) => `${e}${Sg}${n}]`, pu);
}
function af(t) {
  let e = t;
  for (; e != null; ) {
    if (e.nodeType === Node.TEXT_NODE) return e;
    e = e.firstChild;
  }
  return null;
}
function lf(t) {
  const e = t.parentNode;
  if (e == null) throw new Error("Should never happen");
  return [e, Array.from(e.childNodes).indexOf(t)];
}
function a1(t, e, n, r, o) {
  const i = e.getKey(), s = r.getKey(), a = document.createRange();
  let l = t.getElementByKey(i), c = t.getElementByKey(s), u = n, p = o;
  if (xe(e) && (l = af(l)), xe(r) && (c = af(c)), e === void 0 || r === void 0 || l === null || c === null) return null;
  l.nodeName === "BR" && ([l, u] = lf(l)), c.nodeName === "BR" && ([c, p] = lf(c));
  const f = l.firstChild;
  l === c && f != null && f.nodeName === "BR" && u === 0 && p === 0 && (p = 1);
  try {
    a.setStart(l, u), a.setEnd(c, p);
  } catch {
    return null;
  }
  return !a.collapsed || u === p && i === s || (a.setStart(c, p), a.setEnd(l, u)), a;
}
function l1(t, e) {
  const n = t.getRootElement();
  if (n === null) return [];
  const r = n.getBoundingClientRect(), o = getComputedStyle(n), i = parseFloat(o.paddingLeft) + parseFloat(o.paddingRight), s = Array.from(e.getClientRects());
  let a, l = s.length;
  s.sort((c, u) => {
    const p = c.top - u.top;
    return Math.abs(p) <= 3 ? c.left - u.left : p;
  });
  for (let c = 0; c < l; c++) {
    const u = s[c], p = a && a.top <= u.top && a.top + a.height > u.top && a.left + a.width > u.left, f = u.width + i === r.width;
    p || f ? (s.splice(c--, 1), l--) : a = u;
  }
  return s;
}
function c1(t, e) {
  const n = t.getStartEndPoints();
  if (e.isSelected(t) && !mw(e) && n !== null) {
    const [r, o] = n, i = t.isBackward(), s = r.getNode(), a = o.getNode(), l = e.is(s), c = e.is(a);
    if (l || c) {
      const [u, p] = bw(t), f = s.is(a), h = e.is(i ? a : s), g = e.is(i ? s : a);
      let b, _ = 0;
      f ? (_ = u > p ? p : u, b = u > p ? u : p) : h ? (_ = i ? p : u, b = void 0) : g && (_ = 0, b = i ? u : p), e.__text = e.__text.slice(_, b);
    }
  }
  return e;
}
function u1(t, e) {
  const n = t.getFormatType(), r = t.getIndent();
  n !== e.getFormatType() && e.setFormat(n), r !== e.getIndent() && e.setIndent(r);
}
function d1(t, e, n = u1) {
  if (t === null) return;
  const r = t.getStartEndPoints(), o = /* @__PURE__ */ new Map();
  let i = null;
  if (r) {
    const [s, a] = r;
    i = vl(), i.anchor.set(s.key, s.offset, s.type), i.focus.set(a.key, a.offset, a.type);
    const l = Nc(s.getNode(), ma), c = Nc(a.getNode(), ma);
    Ae(l) && o.set(l.getKey(), l), Ae(c) && o.set(c.getKey(), c);
  }
  for (const s of t.getNodes()) if (Ae(s) && ma(s)) o.set(s.getKey(), s);
  else if (r === null) {
    const a = Nc(s, ma);
    Ae(a) && o.set(a.getKey(), a);
  }
  for (const [s, a] of o) {
    const l = e();
    n(a, l), a.replace(l, !0), i && (s === i.anchor.key && i.anchor.set(l.getKey(), i.anchor.offset, i.anchor.type), s === i.focus.key && i.focus.set(l.getKey(), i.focus.offset, i.focus.type));
  }
  i && t.is(ve()) && ml(i);
}
function Dg(t) {
  const e = t.anchor.getNode(), n = od(e) ? e : e.getParentOrThrow(), r = Qv().getElementByKey(n.getKey());
  if (r === null) return !1;
  const o = r.ownerDocument.defaultView;
  return o === null ? !1 : o.getComputedStyle(r).writingMode === "vertical-rl";
}
function cf(t, e) {
  let n = Dg(t) ? !e : e;
  Mg(t) && (n = !n);
  const r = Jv(t.focus, n ? "previous" : "next");
  if (Xv(r)) return !1;
  for (const o of Yv(r)) {
    if (yw(o)) return !o.origin.isInline();
    if (!Ae(o.origin)) {
      if (nd(o.origin)) return !0;
      break;
    }
  }
  return !1;
}
function p1(t, e, n, r) {
  t.modify(e ? "extend" : "move", n, r);
}
function Mg(t) {
  const e = t.anchor.getNode();
  return (od(e) ? e : e.getParentOrThrow()).getDirection() === "rtl";
}
function uf(t, e, n) {
  const r = Mg(t);
  let o;
  o = Dg(t) || r ? !n : n, p1(t, e, o, "character");
}
function Nc(t, e) {
  let n = t;
  for (; n !== null && n.getParent() !== null && !e(n); ) n = n.getParentOrThrow();
  return e(n) ? n : null;
}
const Ws = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, f1 = Ws && "documentMode" in document ? document.documentMode : null, h1 = Ws && /Mac|iPod|iPhone|iPad/.test(navigator.platform), w1 = Ws && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
!(!Ws || !("InputEvent" in window) || f1) && "getTargetRanges" in new window.InputEvent("input");
function Og(...t) {
  const e = [];
  for (const n of t) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) e.push(r);
  return e;
}
function Gt(...t) {
  return () => {
    for (let e = t.length - 1; e >= 0; e--) t[e]();
    t.length = 0;
  };
}
const g1 = Ws, fu = h1, m1 = w1;
function Vr(t, ...e) {
  const n = Og(...e);
  n.length > 0 && t.classList.add(...n);
}
function hu(t, ...e) {
  const n = Og(...e);
  n.length > 0 && t.classList.remove(...n);
}
function Js(t, e) {
  return Array.from(b1(t));
}
function b1(t, e) {
  return v1("next", t);
}
function v1(t, e, n) {
  const r = tt(), o = e || r, i = Ae(o) ? Zv(o, t) : tu(o, t), s = y1(o), a = function(c, u) {
    const p = pf(tu(c, u));
    return p && p[0];
  }(o, t);
  let l = s;
  return ey({ hasNext: (c) => c !== null, initial: i, map: (c) => ({ depth: l, node: c.origin }), step: (c) => {
    if (c.isSameNodeCaret(a)) return null;
    yw(c) && l++;
    const u = pf(c);
    return !u || u[0].isSameNodeCaret(a) ? null : (l += u[1], u[0]);
  } });
}
function y1(t) {
  let e = -1;
  for (let n = t; n !== null; n = n.getParent()) e++;
  return e;
}
const Ts = (t, e) => {
  let n = t;
  for (; n !== tt() && n != null; ) {
    if (e(n)) return n;
    n = n.getParent();
  }
  return null;
};
function Rg(t, e, n, r) {
  const o = (i) => i instanceof e;
  return t.registerNodeTransform(e, (i) => {
    const s = ((a) => {
      const l = a.getChildren();
      for (let p = 0; p < l.length; p++) {
        const f = l[p];
        if (o(f)) return null;
      }
      let c = a, u = a;
      for (; c !== null; ) if (u = c, c = c.getParent(), o(c)) return { child: u, parent: c };
      return null;
    })(i);
    if (s !== null) {
      const { child: a, parent: l } = s;
      if (a.is(i)) {
        r(l, i);
        const c = a.getNextSiblings(), u = c.length;
        if (l.insertAfter(a), u !== 0) {
          const p = n(l);
          a.insertAfter(p);
          for (let f = 0; f < u; f++) p.append(c[f]);
        }
        l.canBeEmpty() || l.getChildrenSize() !== 0 || l.remove();
      }
    }
  });
}
function Ig(t, e) {
  return t !== null && Object.getPrototypeOf(t).constructor.name === e.name;
}
let Tc = !(m1 || !g1) && void 0;
function x1(t) {
  let e = 1;
  if (function() {
    if (Tc === void 0) {
      const n = document.createElement("div");
      n.style.cssText = "position: absolute; opacity: 0; width: 100px; left: -1000px;", document.body.appendChild(n);
      const r = n.getBoundingClientRect();
      n.style.setProperty("zoom", "2"), Tc = n.getBoundingClientRect().width === r.width, document.body.removeChild(n);
    }
    return Tc;
  }()) for (; t; ) e *= Number(window.getComputedStyle(t).getPropertyValue("zoom")), t = t.parentElement;
  return e;
}
function df(t) {
  ty(tu(t, "next")).splice(1, t.getChildren());
}
function pf(t, e = "root") {
  let n = 0, r = t, o = Sp(r);
  for (; o === null; ) {
    if (n--, o = r.getParentCaret(e), !o) return null;
    r = o, o = Sp(r);
  }
  return o && [o, n];
}
var _a = { exports: {} }, Ac, ff;
function _1() {
  if (ff) return Ac;
  ff = 1;
  var t = -1, e = 1, n = 0;
  function r(E, S, k, I, N) {
    if (E === S)
      return E ? [[n, E]] : [];
    if (k != null) {
      var T = F(E, S, k);
      if (T)
        return T;
    }
    var $ = a(E, S), L = E.substring(0, $);
    E = E.substring($), S = S.substring($), $ = c(E, S);
    var J = E.substring(E.length - $);
    E = E.substring(0, E.length - $), S = S.substring(0, S.length - $);
    var G = o(E, S);
    return L && G.unshift([n, L]), J && G.push([n, J]), y(G, N), I && p(G), G;
  }
  function o(E, S) {
    var k;
    if (!E)
      return [[e, S]];
    if (!S)
      return [[t, E]];
    var I = E.length > S.length ? E : S, N = E.length > S.length ? S : E, T = I.indexOf(N);
    if (T !== -1)
      return k = [
        [e, I.substring(0, T)],
        [n, N],
        [e, I.substring(T + N.length)]
      ], E.length > S.length && (k[0][0] = k[2][0] = t), k;
    if (N.length === 1)
      return [
        [t, E],
        [e, S]
      ];
    var $ = u(E, S);
    if ($) {
      var L = $[0], J = $[1], G = $[2], W = $[3], ee = $[4], te = r(L, G), Z = r(J, W);
      return te.concat([[n, ee]], Z);
    }
    return i(E, S);
  }
  function i(E, S) {
    for (var k = E.length, I = S.length, N = Math.ceil((k + I) / 2), T = N, $ = 2 * N, L = new Array($), J = new Array($), G = 0; G < $; G++)
      L[G] = -1, J[G] = -1;
    L[T + 1] = 0, J[T + 1] = 0;
    for (var W = k - I, ee = W % 2 !== 0, te = 0, Z = 0, Y = 0, le = 0, de = 0; de < N; de++) {
      for (var pe = -de + te; pe <= de - Z; pe += 2) {
        var _e = T + pe, be;
        pe === -de || pe !== de && L[_e - 1] < L[_e + 1] ? be = L[_e + 1] : be = L[_e - 1] + 1;
        for (var ye = be - pe; be < k && ye < I && E.charAt(be) === S.charAt(ye); )
          be++, ye++;
        if (L[_e] = be, be > k)
          Z += 2;
        else if (ye > I)
          te += 2;
        else if (ee) {
          var se = T + W - pe;
          if (se >= 0 && se < $ && J[se] !== -1) {
            var Se = k - J[se];
            if (be >= Se)
              return s(E, S, be, ye);
          }
        }
      }
      for (var Fe = -de + Y; Fe <= de - le; Fe += 2) {
        var se = T + Fe, Se;
        Fe === -de || Fe !== de && J[se - 1] < J[se + 1] ? Se = J[se + 1] : Se = J[se - 1] + 1;
        for (var re = Se - Fe; Se < k && re < I && E.charAt(k - Se - 1) === S.charAt(I - re - 1); )
          Se++, re++;
        if (J[se] = Se, Se > k)
          le += 2;
        else if (re > I)
          Y += 2;
        else if (!ee) {
          var _e = T + W - Fe;
          if (_e >= 0 && _e < $ && L[_e] !== -1) {
            var be = L[_e], ye = T + be - _e;
            if (Se = k - Se, be >= Se)
              return s(E, S, be, ye);
          }
        }
      }
    }
    return [
      [t, E],
      [e, S]
    ];
  }
  function s(E, S, k, I) {
    var N = E.substring(0, k), T = S.substring(0, I), $ = E.substring(k), L = S.substring(I), J = r(N, T), G = r($, L);
    return J.concat(G);
  }
  function a(E, S) {
    if (!E || !S || E.charAt(0) !== S.charAt(0))
      return 0;
    for (var k = 0, I = Math.min(E.length, S.length), N = I, T = 0; k < N; )
      E.substring(T, N) == S.substring(T, N) ? (k = N, T = k) : I = N, N = Math.floor((I - k) / 2 + k);
    return A(E.charCodeAt(N - 1)) && N--, N;
  }
  function l(E, S) {
    var k = E.length, I = S.length;
    if (k == 0 || I == 0)
      return 0;
    k > I ? E = E.substring(k - I) : k < I && (S = S.substring(0, k));
    var N = Math.min(k, I);
    if (E == S)
      return N;
    for (var T = 0, $ = 1; ; ) {
      var L = E.substring(N - $), J = S.indexOf(L);
      if (J == -1)
        return T;
      $ += J, (J == 0 || E.substring(N - $) == S.substring(0, $)) && (T = $, $++);
    }
  }
  function c(E, S) {
    if (!E || !S || E.slice(-1) !== S.slice(-1))
      return 0;
    for (var k = 0, I = Math.min(E.length, S.length), N = I, T = 0; k < N; )
      E.substring(E.length - N, E.length - T) == S.substring(S.length - N, S.length - T) ? (k = N, T = k) : I = N, N = Math.floor((I - k) / 2 + k);
    return P(E.charCodeAt(E.length - N)) && N--, N;
  }
  function u(E, S) {
    var k = E.length > S.length ? E : S, I = E.length > S.length ? S : E;
    if (k.length < 4 || I.length * 2 < k.length)
      return null;
    function N(Z, Y, le) {
      for (var de = Z.substring(le, le + Math.floor(Z.length / 4)), pe = -1, _e = "", be, ye, se, Se; (pe = Y.indexOf(de, pe + 1)) !== -1; ) {
        var Fe = a(
          Z.substring(le),
          Y.substring(pe)
        ), re = c(
          Z.substring(0, le),
          Y.substring(0, pe)
        );
        _e.length < re + Fe && (_e = Y.substring(pe - re, pe) + Y.substring(pe, pe + Fe), be = Z.substring(0, le - re), ye = Z.substring(le + Fe), se = Y.substring(0, pe - re), Se = Y.substring(pe + Fe));
      }
      return _e.length * 2 >= Z.length ? [
        be,
        ye,
        se,
        Se,
        _e
      ] : null;
    }
    var T = N(
      k,
      I,
      Math.ceil(k.length / 4)
    ), $ = N(
      k,
      I,
      Math.ceil(k.length / 2)
    ), L;
    if (!T && !$)
      return null;
    $ ? T ? L = T[4].length > $[4].length ? T : $ : L = $ : L = T;
    var J, G, W, ee;
    E.length > S.length ? (J = L[0], G = L[1], W = L[2], ee = L[3]) : (W = L[0], ee = L[1], J = L[2], G = L[3]);
    var te = L[4];
    return [J, G, W, ee, te];
  }
  function p(E) {
    for (var S = !1, k = [], I = 0, N = null, T = 0, $ = 0, L = 0, J = 0, G = 0; T < E.length; )
      E[T][0] == n ? (k[I++] = T, $ = J, L = G, J = 0, G = 0, N = E[T][1]) : (E[T][0] == e ? J += E[T][1].length : G += E[T][1].length, N && N.length <= Math.max($, L) && N.length <= Math.max(J, G) && (E.splice(k[I - 1], 0, [
        t,
        N
      ]), E[k[I - 1] + 1][0] = e, I--, I--, T = I > 0 ? k[I - 1] : -1, $ = 0, L = 0, J = 0, G = 0, N = null, S = !0)), T++;
    for (S && y(E), x(E), T = 1; T < E.length; ) {
      if (E[T - 1][0] == t && E[T][0] == e) {
        var W = E[T - 1][1], ee = E[T][1], te = l(W, ee), Z = l(ee, W);
        te >= Z ? (te >= W.length / 2 || te >= ee.length / 2) && (E.splice(T, 0, [
          n,
          ee.substring(0, te)
        ]), E[T - 1][1] = W.substring(
          0,
          W.length - te
        ), E[T + 1][1] = ee.substring(te), T++) : (Z >= W.length / 2 || Z >= ee.length / 2) && (E.splice(T, 0, [
          n,
          W.substring(0, Z)
        ]), E[T - 1][0] = e, E[T - 1][1] = ee.substring(
          0,
          ee.length - Z
        ), E[T + 1][0] = t, E[T + 1][1] = W.substring(Z), T++), T++;
      }
      T++;
    }
  }
  var f = /[^a-zA-Z0-9]/, h = /\s/, g = /[\r\n]/, b = /\n\r?\n$/, _ = /^\r?\n\r?\n/;
  function x(E) {
    function S(Z, Y) {
      if (!Z || !Y)
        return 6;
      var le = Z.charAt(Z.length - 1), de = Y.charAt(0), pe = le.match(f), _e = de.match(f), be = pe && le.match(h), ye = _e && de.match(h), se = be && le.match(g), Se = ye && de.match(g), Fe = se && Z.match(b), re = Se && Y.match(_);
      return Fe || re ? 5 : se || Se ? 4 : pe && !be && ye ? 3 : be || ye ? 2 : pe || _e ? 1 : 0;
    }
    for (var k = 1; k < E.length - 1; ) {
      if (E[k - 1][0] == n && E[k + 1][0] == n) {
        var I = E[k - 1][1], N = E[k][1], T = E[k + 1][1], $ = c(I, N);
        if ($) {
          var L = N.substring(N.length - $);
          I = I.substring(0, I.length - $), N = L + N.substring(0, N.length - $), T = L + T;
        }
        for (var J = I, G = N, W = T, ee = S(I, N) + S(N, T); N.charAt(0) === T.charAt(0); ) {
          I += N.charAt(0), N = N.substring(1) + T.charAt(0), T = T.substring(1);
          var te = S(I, N) + S(N, T);
          te >= ee && (ee = te, J = I, G = N, W = T);
        }
        E[k - 1][1] != J && (J ? E[k - 1][1] = J : (E.splice(k - 1, 1), k--), E[k][1] = G, W ? E[k + 1][1] = W : (E.splice(k + 1, 1), k--));
      }
      k++;
    }
  }
  function y(E, S) {
    E.push([n, ""]);
    for (var k = 0, I = 0, N = 0, T = "", $ = "", L; k < E.length; ) {
      if (k < E.length - 1 && !E[k][1]) {
        E.splice(k, 1);
        continue;
      }
      switch (E[k][0]) {
        case e:
          N++, $ += E[k][1], k++;
          break;
        case t:
          I++, T += E[k][1], k++;
          break;
        case n:
          var J = k - N - I - 1;
          if (S) {
            if (J >= 0 && O(E[J][1])) {
              var G = E[J][1].slice(-1);
              if (E[J][1] = E[J][1].slice(
                0,
                -1
              ), T = G + T, $ = G + $, !E[J][1]) {
                E.splice(J, 1), k--;
                var W = J - 1;
                E[W] && E[W][0] === e && (N++, $ = E[W][1] + $, W--), E[W] && E[W][0] === t && (I++, T = E[W][1] + T, W--), J = W;
              }
            }
            if (V(E[k][1])) {
              var G = E[k][1].charAt(0);
              E[k][1] = E[k][1].slice(1), T += G, $ += G;
            }
          }
          if (k < E.length - 1 && !E[k][1]) {
            E.splice(k, 1);
            break;
          }
          if (T.length > 0 || $.length > 0) {
            T.length > 0 && $.length > 0 && (L = a($, T), L !== 0 && (J >= 0 ? E[J][1] += $.substring(
              0,
              L
            ) : (E.splice(0, 0, [
              n,
              $.substring(0, L)
            ]), k++), $ = $.substring(L), T = T.substring(L)), L = c($, T), L !== 0 && (E[k][1] = $.substring($.length - L) + E[k][1], $ = $.substring(
              0,
              $.length - L
            ), T = T.substring(
              0,
              T.length - L
            )));
            var ee = N + I;
            T.length === 0 && $.length === 0 ? (E.splice(k - ee, ee), k = k - ee) : T.length === 0 ? (E.splice(k - ee, ee, [e, $]), k = k - ee + 1) : $.length === 0 ? (E.splice(k - ee, ee, [t, T]), k = k - ee + 1) : (E.splice(
              k - ee,
              ee,
              [t, T],
              [e, $]
            ), k = k - ee + 2);
          }
          k !== 0 && E[k - 1][0] === n ? (E[k - 1][1] += E[k][1], E.splice(k, 1)) : k++, N = 0, I = 0, T = "", $ = "";
          break;
      }
    }
    E[E.length - 1][1] === "" && E.pop();
    var te = !1;
    for (k = 1; k < E.length - 1; )
      E[k - 1][0] === n && E[k + 1][0] === n && (E[k][1].substring(
        E[k][1].length - E[k - 1][1].length
      ) === E[k - 1][1] ? (E[k][1] = E[k - 1][1] + E[k][1].substring(
        0,
        E[k][1].length - E[k - 1][1].length
      ), E[k + 1][1] = E[k - 1][1] + E[k + 1][1], E.splice(k - 1, 1), te = !0) : E[k][1].substring(0, E[k + 1][1].length) == E[k + 1][1] && (E[k - 1][1] += E[k + 1][1], E[k][1] = E[k][1].substring(E[k + 1][1].length) + E[k + 1][1], E.splice(k + 1, 1), te = !0)), k++;
    te && y(E, S);
  }
  function A(E) {
    return E >= 55296 && E <= 56319;
  }
  function P(E) {
    return E >= 56320 && E <= 57343;
  }
  function V(E) {
    return P(E.charCodeAt(0));
  }
  function O(E) {
    return A(E.charCodeAt(E.length - 1));
  }
  function U(E) {
    for (var S = [], k = 0; k < E.length; k++)
      E[k][1].length > 0 && S.push(E[k]);
    return S;
  }
  function B(E, S, k, I) {
    return O(E) || V(I) ? null : U([
      [n, E],
      [t, S],
      [e, k],
      [n, I]
    ]);
  }
  function F(E, S, k) {
    var I = typeof k == "number" ? { index: k, length: 0 } : k.oldRange, N = typeof k == "number" ? null : k.newRange, T = E.length, $ = S.length;
    if (I.length === 0 && (N === null || N.length === 0)) {
      var L = I.index, J = E.slice(0, L), G = E.slice(L), W = N ? N.index : null;
      e: {
        var ee = L + $ - T;
        if (W !== null && W !== ee || ee < 0 || ee > $)
          break e;
        var te = S.slice(0, ee), Z = S.slice(ee);
        if (Z !== G)
          break e;
        var Y = Math.min(L, ee), le = J.slice(0, Y), de = te.slice(0, Y);
        if (le !== de)
          break e;
        var pe = J.slice(Y), _e = te.slice(Y);
        return B(le, pe, _e, G);
      }
      e: {
        if (W !== null && W !== L)
          break e;
        var be = L, te = S.slice(0, be), Z = S.slice(be);
        if (te !== J)
          break e;
        var ye = Math.min(T - be, $ - be), se = G.slice(G.length - ye), Se = Z.slice(Z.length - ye);
        if (se !== Se)
          break e;
        var pe = G.slice(0, G.length - ye), _e = Z.slice(0, Z.length - ye);
        return B(J, pe, _e, se);
      }
    }
    if (I.length > 0 && N && N.length === 0)
      e: {
        var le = E.slice(0, I.index), se = E.slice(I.index + I.length), Y = le.length, ye = se.length;
        if ($ < Y + ye)
          break e;
        var de = S.slice(0, Y), Se = S.slice($ - ye);
        if (le !== de || se !== Se)
          break e;
        var pe = E.slice(Y, T - ye), _e = S.slice(Y, $ - ye);
        return B(le, pe, _e, se);
      }
    return null;
  }
  function K(E, S, k, I) {
    return r(E, S, k, I, !0);
  }
  return K.INSERT = e, K.DELETE = t, K.EQUAL = n, Ac = K, Ac;
}
var as = { exports: {} };
as.exports;
var hf;
function Lg() {
  return hf || (hf = 1, function(t, e) {
    var n = 200, r = "__lodash_hash_undefined__", o = 9007199254740991, i = "[object Arguments]", s = "[object Array]", a = "[object Boolean]", l = "[object Date]", c = "[object Error]", u = "[object Function]", p = "[object GeneratorFunction]", f = "[object Map]", h = "[object Number]", g = "[object Object]", b = "[object Promise]", _ = "[object RegExp]", x = "[object Set]", y = "[object String]", A = "[object Symbol]", P = "[object WeakMap]", V = "[object ArrayBuffer]", O = "[object DataView]", U = "[object Float32Array]", B = "[object Float64Array]", F = "[object Int8Array]", K = "[object Int16Array]", E = "[object Int32Array]", S = "[object Uint8Array]", k = "[object Uint8ClampedArray]", I = "[object Uint16Array]", N = "[object Uint32Array]", T = /[\\^$.*+?()[\]{}|]/g, $ = /\w*$/, L = /^\[object .+?Constructor\]$/, J = /^(?:0|[1-9]\d*)$/, G = {};
    G[i] = G[s] = G[V] = G[O] = G[a] = G[l] = G[U] = G[B] = G[F] = G[K] = G[E] = G[f] = G[h] = G[g] = G[_] = G[x] = G[y] = G[A] = G[S] = G[k] = G[I] = G[N] = !0, G[c] = G[u] = G[P] = !1;
    var W = typeof Ur == "object" && Ur && Ur.Object === Object && Ur, ee = typeof self == "object" && self && self.Object === Object && self, te = W || ee || Function("return this")(), Z = e && !e.nodeType && e, Y = Z && !0 && t && !t.nodeType && t, le = Y && Y.exports === Z;
    function de(w, C) {
      return w.set(C[0], C[1]), w;
    }
    function pe(w, C) {
      return w.add(C), w;
    }
    function _e(w, C) {
      for (var R = -1, Q = w ? w.length : 0; ++R < Q && C(w[R], R, w) !== !1; )
        ;
      return w;
    }
    function be(w, C) {
      for (var R = -1, Q = C.length, ke = w.length; ++R < Q; )
        w[ke + R] = C[R];
      return w;
    }
    function ye(w, C, R, Q) {
      for (var ke = -1, we = w ? w.length : 0; ++ke < we; )
        R = C(R, w[ke], ke, w);
      return R;
    }
    function se(w, C) {
      for (var R = -1, Q = Array(w); ++R < w; )
        Q[R] = C(R);
      return Q;
    }
    function Se(w, C) {
      return w == null ? void 0 : w[C];
    }
    function Fe(w) {
      var C = !1;
      if (w != null && typeof w.toString != "function")
        try {
          C = !!(w + "");
        } catch {
        }
      return C;
    }
    function re(w) {
      var C = -1, R = Array(w.size);
      return w.forEach(function(Q, ke) {
        R[++C] = [ke, Q];
      }), R;
    }
    function Ce(w, C) {
      return function(R) {
        return w(C(R));
      };
    }
    function Re(w) {
      var C = -1, R = Array(w.size);
      return w.forEach(function(Q) {
        R[++C] = Q;
      }), R;
    }
    var je = Array.prototype, Je = Function.prototype, wt = Object.prototype, ut = te["__core-js_shared__"], yt = function() {
      var w = /[^.]+$/.exec(ut && ut.keys && ut.keys.IE_PROTO || "");
      return w ? "Symbol(src)_1." + w : "";
    }(), Me = Je.toString, Nt = wt.hasOwnProperty, nt = wt.toString, Pn = RegExp(
      "^" + Me.call(Nt).replace(T, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), mn = le ? te.Buffer : void 0, ln = te.Symbol, bn = te.Uint8Array, ge = Ce(Object.getPrototypeOf, Object), ze = Object.create, Tt = wt.propertyIsEnumerable, Ot = je.splice, vn = Object.getOwnPropertySymbols, yn = mn ? mn.isBuffer : void 0, $n = Ce(Object.keys, Object), xn = jn(te, "DataView"), _n = jn(te, "Map"), qt = jn(te, "Promise"), Cn = jn(te, "Set"), En = jn(te, "WeakMap"), cn = jn(Object, "create"), er = tn(xn), Ge = tn(_n), dt = tn(qt), Zt = tn(Cn), en = tn(En), Fn = ln ? ln.prototype : void 0, $r = Fn ? Fn.valueOf : void 0;
    function Sn(w) {
      var C = -1, R = w ? w.length : 0;
      for (this.clear(); ++C < R; ) {
        var Q = w[C];
        this.set(Q[0], Q[1]);
      }
    }
    function m() {
      this.__data__ = cn ? cn(null) : {};
    }
    function v(w) {
      return this.has(w) && delete this.__data__[w];
    }
    function D(w) {
      var C = this.__data__;
      if (cn) {
        var R = C[w];
        return R === r ? void 0 : R;
      }
      return Nt.call(C, w) ? C[w] : void 0;
    }
    function H(w) {
      var C = this.__data__;
      return cn ? C[w] !== void 0 : Nt.call(C, w);
    }
    function ne(w, C) {
      var R = this.__data__;
      return R[w] = cn && C === void 0 ? r : C, this;
    }
    Sn.prototype.clear = m, Sn.prototype.delete = v, Sn.prototype.get = D, Sn.prototype.has = H, Sn.prototype.set = ne;
    function ae(w) {
      var C = -1, R = w ? w.length : 0;
      for (this.clear(); ++C < R; ) {
        var Q = w[C];
        this.set(Q[0], Q[1]);
      }
    }
    function Oe() {
      this.__data__ = [];
    }
    function gt(w) {
      var C = this.__data__, R = Yo(C, w);
      if (R < 0)
        return !1;
      var Q = C.length - 1;
      return R == Q ? C.pop() : Ot.call(C, R, 1), !0;
    }
    function _t(w) {
      var C = this.__data__, R = Yo(C, w);
      return R < 0 ? void 0 : C[R][1];
    }
    function jt(w) {
      return Yo(this.__data__, w) > -1;
    }
    function At(w, C) {
      var R = this.__data__, Q = Yo(R, w);
      return Q < 0 ? R.push([w, C]) : R[Q][1] = C, this;
    }
    ae.prototype.clear = Oe, ae.prototype.delete = gt, ae.prototype.get = _t, ae.prototype.has = jt, ae.prototype.set = At;
    function ct(w) {
      var C = -1, R = w ? w.length : 0;
      for (this.clear(); ++C < R; ) {
        var Q = w[C];
        this.set(Q[0], Q[1]);
      }
    }
    function kn() {
      this.__data__ = {
        hash: new Sn(),
        map: new (_n || ae)(),
        string: new Sn()
      };
    }
    function Kt(w) {
      return fo(this, w).delete(w);
    }
    function Bn(w) {
      return fo(this, w).get(w);
    }
    function un(w) {
      return fo(this, w).has(w);
    }
    function qn(w, C) {
      return fo(this, w).set(w, C), this;
    }
    ct.prototype.clear = kn, ct.prototype.delete = Kt, ct.prototype.get = Bn, ct.prototype.has = un, ct.prototype.set = qn;
    function Ct(w) {
      this.__data__ = new ae(w);
    }
    function uo() {
      this.__data__ = new ae();
    }
    function Et(w) {
      return this.__data__.delete(w);
    }
    function Jo(w) {
      return this.__data__.get(w);
    }
    function tr(w) {
      return this.__data__.has(w);
    }
    function Jl(w, C) {
      var R = this.__data__;
      if (R instanceof ae) {
        var Q = R.__data__;
        if (!_n || Q.length < n - 1)
          return Q.push([w, C]), this;
        R = this.__data__ = new ct(Q);
      }
      return R.set(w, C), this;
    }
    Ct.prototype.clear = uo, Ct.prototype.delete = Et, Ct.prototype.get = Jo, Ct.prototype.has = tr, Ct.prototype.set = Jl;
    function Xo(w, C) {
      var R = Wi(w) || Zo(w) ? se(w.length, String) : [], Q = R.length, ke = !!Q;
      for (var we in w)
        Nt.call(w, we) && !(ke && (we == "length" || cc(we, Q))) && R.push(we);
      return R;
    }
    function ia(w, C, R) {
      var Q = w[C];
      (!(Nt.call(w, C) && ua(Q, R)) || R === void 0 && !(C in w)) && (w[C] = R);
    }
    function Yo(w, C) {
      for (var R = w.length; R--; )
        if (ua(w[R][0], C))
          return R;
      return -1;
    }
    function nr(w, C) {
      return w && Ki(C, Xi(C), w);
    }
    function zi(w, C, R, Q, ke, we, Ue) {
      var Be;
      if (Q && (Be = we ? Q(w, ke, we, Ue) : Q(w)), Be !== void 0)
        return Be;
      if (!or(w))
        return w;
      var kt = Wi(w);
      if (kt) {
        if (Be = ac(w), !C)
          return oc(w, Be);
      } else {
        var Ve = _r(w), Wt = Ve == u || Ve == p;
        if (da(w))
          return Qo(w, C);
        if (Ve == g || Ve == i || Wt && !we) {
          if (Fe(w))
            return we ? w : {};
          if (Be = rr(Wt ? {} : w), !C)
            return ic(w, nr(Be, w));
        } else {
          if (!G[Ve])
            return we ? w : {};
          Be = lc(w, Ve, zi, C);
        }
      }
      Ue || (Ue = new Ct());
      var dn = Ue.get(w);
      if (dn)
        return dn;
      if (Ue.set(w, Be), !kt)
        var St = R ? sc(w) : Xi(w);
      return _e(St || w, function(Jt, Ut) {
        St && (Ut = Jt, Jt = w[Ut]), ia(Be, Ut, zi(Jt, C, R, Q, Ut, w, Ue));
      }), Be;
    }
    function Xl(w) {
      return or(w) ? ze(w) : {};
    }
    function Yl(w, C, R) {
      var Q = C(w);
      return Wi(w) ? Q : be(Q, R(w));
    }
    function Ql(w) {
      return nt.call(w);
    }
    function Zl(w) {
      if (!or(w) || dc(w))
        return !1;
      var C = Ji(w) || Fe(w) ? Pn : L;
      return C.test(tn(w));
    }
    function ec(w) {
      if (!la(w))
        return $n(w);
      var C = [];
      for (var R in Object(w))
        Nt.call(w, R) && R != "constructor" && C.push(R);
      return C;
    }
    function Qo(w, C) {
      if (C)
        return w.slice();
      var R = new w.constructor(w.length);
      return w.copy(R), R;
    }
    function Gi(w) {
      var C = new w.constructor(w.byteLength);
      return new bn(C).set(new bn(w)), C;
    }
    function po(w, C) {
      var R = C ? Gi(w.buffer) : w.buffer;
      return new w.constructor(R, w.byteOffset, w.byteLength);
    }
    function sa(w, C, R) {
      var Q = C ? R(re(w), !0) : re(w);
      return ye(Q, de, new w.constructor());
    }
    function aa(w) {
      var C = new w.constructor(w.source, $.exec(w));
      return C.lastIndex = w.lastIndex, C;
    }
    function tc(w, C, R) {
      var Q = C ? R(Re(w), !0) : Re(w);
      return ye(Q, pe, new w.constructor());
    }
    function nc(w) {
      return $r ? Object($r.call(w)) : {};
    }
    function rc(w, C) {
      var R = C ? Gi(w.buffer) : w.buffer;
      return new w.constructor(R, w.byteOffset, w.length);
    }
    function oc(w, C) {
      var R = -1, Q = w.length;
      for (C || (C = Array(Q)); ++R < Q; )
        C[R] = w[R];
      return C;
    }
    function Ki(w, C, R, Q) {
      R || (R = {});
      for (var ke = -1, we = C.length; ++ke < we; ) {
        var Ue = C[ke], Be = void 0;
        ia(R, Ue, Be === void 0 ? w[Ue] : Be);
      }
      return R;
    }
    function ic(w, C) {
      return Ki(w, xr(w), C);
    }
    function sc(w) {
      return Yl(w, Xi, xr);
    }
    function fo(w, C) {
      var R = w.__data__;
      return uc(C) ? R[typeof C == "string" ? "string" : "hash"] : R.map;
    }
    function jn(w, C) {
      var R = Se(w, C);
      return Zl(R) ? R : void 0;
    }
    var xr = vn ? Ce(vn, Object) : fc, _r = Ql;
    (xn && _r(new xn(new ArrayBuffer(1))) != O || _n && _r(new _n()) != f || qt && _r(qt.resolve()) != b || Cn && _r(new Cn()) != x || En && _r(new En()) != P) && (_r = function(w) {
      var C = nt.call(w), R = C == g ? w.constructor : void 0, Q = R ? tn(R) : void 0;
      if (Q)
        switch (Q) {
          case er:
            return O;
          case Ge:
            return f;
          case dt:
            return b;
          case Zt:
            return x;
          case en:
            return P;
        }
      return C;
    });
    function ac(w) {
      var C = w.length, R = w.constructor(C);
      return C && typeof w[0] == "string" && Nt.call(w, "index") && (R.index = w.index, R.input = w.input), R;
    }
    function rr(w) {
      return typeof w.constructor == "function" && !la(w) ? Xl(ge(w)) : {};
    }
    function lc(w, C, R, Q) {
      var ke = w.constructor;
      switch (C) {
        case V:
          return Gi(w);
        case a:
        case l:
          return new ke(+w);
        case O:
          return po(w, Q);
        case U:
        case B:
        case F:
        case K:
        case E:
        case S:
        case k:
        case I:
        case N:
          return rc(w, Q);
        case f:
          return sa(w, Q, R);
        case h:
        case y:
          return new ke(w);
        case _:
          return aa(w);
        case x:
          return tc(w, Q, R);
        case A:
          return nc(w);
      }
    }
    function cc(w, C) {
      return C = C ?? o, !!C && (typeof w == "number" || J.test(w)) && w > -1 && w % 1 == 0 && w < C;
    }
    function uc(w) {
      var C = typeof w;
      return C == "string" || C == "number" || C == "symbol" || C == "boolean" ? w !== "__proto__" : w === null;
    }
    function dc(w) {
      return !!yt && yt in w;
    }
    function la(w) {
      var C = w && w.constructor, R = typeof C == "function" && C.prototype || wt;
      return w === R;
    }
    function tn(w) {
      if (w != null) {
        try {
          return Me.call(w);
        } catch {
        }
        try {
          return w + "";
        } catch {
        }
      }
      return "";
    }
    function ca(w) {
      return zi(w, !0, !0);
    }
    function ua(w, C) {
      return w === C || w !== w && C !== C;
    }
    function Zo(w) {
      return pc(w) && Nt.call(w, "callee") && (!Tt.call(w, "callee") || nt.call(w) == i);
    }
    var Wi = Array.isArray;
    function ei(w) {
      return w != null && pa(w.length) && !Ji(w);
    }
    function pc(w) {
      return fa(w) && ei(w);
    }
    var da = yn || hc;
    function Ji(w) {
      var C = or(w) ? nt.call(w) : "";
      return C == u || C == p;
    }
    function pa(w) {
      return typeof w == "number" && w > -1 && w % 1 == 0 && w <= o;
    }
    function or(w) {
      var C = typeof w;
      return !!w && (C == "object" || C == "function");
    }
    function fa(w) {
      return !!w && typeof w == "object";
    }
    function Xi(w) {
      return ei(w) ? Xo(w) : ec(w);
    }
    function fc() {
      return [];
    }
    function hc() {
      return !1;
    }
    t.exports = ca;
  }(as, as.exports)), as.exports;
}
var ls = { exports: {} };
ls.exports;
var wf;
function Pg() {
  return wf || (wf = 1, function(t, e) {
    var n = 200, r = "__lodash_hash_undefined__", o = 1, i = 2, s = 9007199254740991, a = "[object Arguments]", l = "[object Array]", c = "[object AsyncFunction]", u = "[object Boolean]", p = "[object Date]", f = "[object Error]", h = "[object Function]", g = "[object GeneratorFunction]", b = "[object Map]", _ = "[object Number]", x = "[object Null]", y = "[object Object]", A = "[object Promise]", P = "[object Proxy]", V = "[object RegExp]", O = "[object Set]", U = "[object String]", B = "[object Symbol]", F = "[object Undefined]", K = "[object WeakMap]", E = "[object ArrayBuffer]", S = "[object DataView]", k = "[object Float32Array]", I = "[object Float64Array]", N = "[object Int8Array]", T = "[object Int16Array]", $ = "[object Int32Array]", L = "[object Uint8Array]", J = "[object Uint8ClampedArray]", G = "[object Uint16Array]", W = "[object Uint32Array]", ee = /[\\^$.*+?()[\]{}|]/g, te = /^\[object .+?Constructor\]$/, Z = /^(?:0|[1-9]\d*)$/, Y = {};
    Y[k] = Y[I] = Y[N] = Y[T] = Y[$] = Y[L] = Y[J] = Y[G] = Y[W] = !0, Y[a] = Y[l] = Y[E] = Y[u] = Y[S] = Y[p] = Y[f] = Y[h] = Y[b] = Y[_] = Y[y] = Y[V] = Y[O] = Y[U] = Y[K] = !1;
    var le = typeof Ur == "object" && Ur && Ur.Object === Object && Ur, de = typeof self == "object" && self && self.Object === Object && self, pe = le || de || Function("return this")(), _e = e && !e.nodeType && e, be = _e && !0 && t && !t.nodeType && t, ye = be && be.exports === _e, se = ye && le.process, Se = function() {
      try {
        return se && se.binding && se.binding("util");
      } catch {
      }
    }(), Fe = Se && Se.isTypedArray;
    function re(w, C) {
      for (var R = -1, Q = w == null ? 0 : w.length, ke = 0, we = []; ++R < Q; ) {
        var Ue = w[R];
        C(Ue, R, w) && (we[ke++] = Ue);
      }
      return we;
    }
    function Ce(w, C) {
      for (var R = -1, Q = C.length, ke = w.length; ++R < Q; )
        w[ke + R] = C[R];
      return w;
    }
    function Re(w, C) {
      for (var R = -1, Q = w == null ? 0 : w.length; ++R < Q; )
        if (C(w[R], R, w))
          return !0;
      return !1;
    }
    function je(w, C) {
      for (var R = -1, Q = Array(w); ++R < w; )
        Q[R] = C(R);
      return Q;
    }
    function Je(w) {
      return function(C) {
        return w(C);
      };
    }
    function wt(w, C) {
      return w.has(C);
    }
    function ut(w, C) {
      return w == null ? void 0 : w[C];
    }
    function yt(w) {
      var C = -1, R = Array(w.size);
      return w.forEach(function(Q, ke) {
        R[++C] = [ke, Q];
      }), R;
    }
    function Me(w, C) {
      return function(R) {
        return w(C(R));
      };
    }
    function Nt(w) {
      var C = -1, R = Array(w.size);
      return w.forEach(function(Q) {
        R[++C] = Q;
      }), R;
    }
    var nt = Array.prototype, Pn = Function.prototype, mn = Object.prototype, ln = pe["__core-js_shared__"], bn = Pn.toString, ge = mn.hasOwnProperty, ze = function() {
      var w = /[^.]+$/.exec(ln && ln.keys && ln.keys.IE_PROTO || "");
      return w ? "Symbol(src)_1." + w : "";
    }(), Tt = mn.toString, Ot = RegExp(
      "^" + bn.call(ge).replace(ee, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), vn = ye ? pe.Buffer : void 0, yn = pe.Symbol, $n = pe.Uint8Array, xn = mn.propertyIsEnumerable, _n = nt.splice, qt = yn ? yn.toStringTag : void 0, Cn = Object.getOwnPropertySymbols, En = vn ? vn.isBuffer : void 0, cn = Me(Object.keys, Object), er = xr(pe, "DataView"), Ge = xr(pe, "Map"), dt = xr(pe, "Promise"), Zt = xr(pe, "Set"), en = xr(pe, "WeakMap"), Fn = xr(Object, "create"), $r = tn(er), Sn = tn(Ge), m = tn(dt), v = tn(Zt), D = tn(en), H = yn ? yn.prototype : void 0, ne = H ? H.valueOf : void 0;
    function ae(w) {
      var C = -1, R = w == null ? 0 : w.length;
      for (this.clear(); ++C < R; ) {
        var Q = w[C];
        this.set(Q[0], Q[1]);
      }
    }
    function Oe() {
      this.__data__ = Fn ? Fn(null) : {}, this.size = 0;
    }
    function gt(w) {
      var C = this.has(w) && delete this.__data__[w];
      return this.size -= C ? 1 : 0, C;
    }
    function _t(w) {
      var C = this.__data__;
      if (Fn) {
        var R = C[w];
        return R === r ? void 0 : R;
      }
      return ge.call(C, w) ? C[w] : void 0;
    }
    function jt(w) {
      var C = this.__data__;
      return Fn ? C[w] !== void 0 : ge.call(C, w);
    }
    function At(w, C) {
      var R = this.__data__;
      return this.size += this.has(w) ? 0 : 1, R[w] = Fn && C === void 0 ? r : C, this;
    }
    ae.prototype.clear = Oe, ae.prototype.delete = gt, ae.prototype.get = _t, ae.prototype.has = jt, ae.prototype.set = At;
    function ct(w) {
      var C = -1, R = w == null ? 0 : w.length;
      for (this.clear(); ++C < R; ) {
        var Q = w[C];
        this.set(Q[0], Q[1]);
      }
    }
    function kn() {
      this.__data__ = [], this.size = 0;
    }
    function Kt(w) {
      var C = this.__data__, R = Qo(C, w);
      if (R < 0)
        return !1;
      var Q = C.length - 1;
      return R == Q ? C.pop() : _n.call(C, R, 1), --this.size, !0;
    }
    function Bn(w) {
      var C = this.__data__, R = Qo(C, w);
      return R < 0 ? void 0 : C[R][1];
    }
    function un(w) {
      return Qo(this.__data__, w) > -1;
    }
    function qn(w, C) {
      var R = this.__data__, Q = Qo(R, w);
      return Q < 0 ? (++this.size, R.push([w, C])) : R[Q][1] = C, this;
    }
    ct.prototype.clear = kn, ct.prototype.delete = Kt, ct.prototype.get = Bn, ct.prototype.has = un, ct.prototype.set = qn;
    function Ct(w) {
      var C = -1, R = w == null ? 0 : w.length;
      for (this.clear(); ++C < R; ) {
        var Q = w[C];
        this.set(Q[0], Q[1]);
      }
    }
    function uo() {
      this.size = 0, this.__data__ = {
        hash: new ae(),
        map: new (Ge || ct)(),
        string: new ae()
      };
    }
    function Et(w) {
      var C = jn(this, w).delete(w);
      return this.size -= C ? 1 : 0, C;
    }
    function Jo(w) {
      return jn(this, w).get(w);
    }
    function tr(w) {
      return jn(this, w).has(w);
    }
    function Jl(w, C) {
      var R = jn(this, w), Q = R.size;
      return R.set(w, C), this.size += R.size == Q ? 0 : 1, this;
    }
    Ct.prototype.clear = uo, Ct.prototype.delete = Et, Ct.prototype.get = Jo, Ct.prototype.has = tr, Ct.prototype.set = Jl;
    function Xo(w) {
      var C = -1, R = w == null ? 0 : w.length;
      for (this.__data__ = new Ct(); ++C < R; )
        this.add(w[C]);
    }
    function ia(w) {
      return this.__data__.set(w, r), this;
    }
    function Yo(w) {
      return this.__data__.has(w);
    }
    Xo.prototype.add = Xo.prototype.push = ia, Xo.prototype.has = Yo;
    function nr(w) {
      var C = this.__data__ = new ct(w);
      this.size = C.size;
    }
    function zi() {
      this.__data__ = new ct(), this.size = 0;
    }
    function Xl(w) {
      var C = this.__data__, R = C.delete(w);
      return this.size = C.size, R;
    }
    function Yl(w) {
      return this.__data__.get(w);
    }
    function Ql(w) {
      return this.__data__.has(w);
    }
    function Zl(w, C) {
      var R = this.__data__;
      if (R instanceof ct) {
        var Q = R.__data__;
        if (!Ge || Q.length < n - 1)
          return Q.push([w, C]), this.size = ++R.size, this;
        R = this.__data__ = new Ct(Q);
      }
      return R.set(w, C), this.size = R.size, this;
    }
    nr.prototype.clear = zi, nr.prototype.delete = Xl, nr.prototype.get = Yl, nr.prototype.has = Ql, nr.prototype.set = Zl;
    function ec(w, C) {
      var R = Zo(w), Q = !R && ua(w), ke = !R && !Q && ei(w), we = !R && !Q && !ke && fa(w), Ue = R || Q || ke || we, Be = Ue ? je(w.length, String) : [], kt = Be.length;
      for (var Ve in w)
        ge.call(w, Ve) && !(Ue && // Safari 9 has enumerable `arguments.length` in strict mode.
        (Ve == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        ke && (Ve == "offset" || Ve == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        we && (Ve == "buffer" || Ve == "byteLength" || Ve == "byteOffset") || // Skip index properties.
        lc(Ve, kt))) && Be.push(Ve);
      return Be;
    }
    function Qo(w, C) {
      for (var R = w.length; R--; )
        if (ca(w[R][0], C))
          return R;
      return -1;
    }
    function Gi(w, C, R) {
      var Q = C(w);
      return Zo(w) ? Q : Ce(Q, R(w));
    }
    function po(w) {
      return w == null ? w === void 0 ? F : x : qt && qt in Object(w) ? _r(w) : la(w);
    }
    function sa(w) {
      return or(w) && po(w) == a;
    }
    function aa(w, C, R, Q, ke) {
      return w === C ? !0 : w == null || C == null || !or(w) && !or(C) ? w !== w && C !== C : tc(w, C, R, Q, aa, ke);
    }
    function tc(w, C, R, Q, ke, we) {
      var Ue = Zo(w), Be = Zo(C), kt = Ue ? l : rr(w), Ve = Be ? l : rr(C);
      kt = kt == a ? y : kt, Ve = Ve == a ? y : Ve;
      var Wt = kt == y, dn = Ve == y, St = kt == Ve;
      if (St && ei(w)) {
        if (!ei(C))
          return !1;
        Ue = !0, Wt = !1;
      }
      if (St && !Wt)
        return we || (we = new nr()), Ue || fa(w) ? Ki(w, C, R, Q, ke, we) : ic(w, C, kt, R, Q, ke, we);
      if (!(R & o)) {
        var Jt = Wt && ge.call(w, "__wrapped__"), Ut = dn && ge.call(C, "__wrapped__");
        if (Jt || Ut) {
          var Fr = Jt ? w.value() : w, Cr = Ut ? C.value() : C;
          return we || (we = new nr()), ke(Fr, Cr, R, Q, we);
        }
      }
      return St ? (we || (we = new nr()), sc(w, C, R, Q, ke, we)) : !1;
    }
    function nc(w) {
      if (!pa(w) || uc(w))
        return !1;
      var C = da(w) ? Ot : te;
      return C.test(tn(w));
    }
    function rc(w) {
      return or(w) && Ji(w.length) && !!Y[po(w)];
    }
    function oc(w) {
      if (!dc(w))
        return cn(w);
      var C = [];
      for (var R in Object(w))
        ge.call(w, R) && R != "constructor" && C.push(R);
      return C;
    }
    function Ki(w, C, R, Q, ke, we) {
      var Ue = R & o, Be = w.length, kt = C.length;
      if (Be != kt && !(Ue && kt > Be))
        return !1;
      var Ve = we.get(w);
      if (Ve && we.get(C))
        return Ve == C;
      var Wt = -1, dn = !0, St = R & i ? new Xo() : void 0;
      for (we.set(w, C), we.set(C, w); ++Wt < Be; ) {
        var Jt = w[Wt], Ut = C[Wt];
        if (Q)
          var Fr = Ue ? Q(Ut, Jt, Wt, C, w, we) : Q(Jt, Ut, Wt, w, C, we);
        if (Fr !== void 0) {
          if (Fr)
            continue;
          dn = !1;
          break;
        }
        if (St) {
          if (!Re(C, function(Cr, ho) {
            if (!wt(St, ho) && (Jt === Cr || ke(Jt, Cr, R, Q, we)))
              return St.push(ho);
          })) {
            dn = !1;
            break;
          }
        } else if (!(Jt === Ut || ke(Jt, Ut, R, Q, we))) {
          dn = !1;
          break;
        }
      }
      return we.delete(w), we.delete(C), dn;
    }
    function ic(w, C, R, Q, ke, we, Ue) {
      switch (R) {
        case S:
          if (w.byteLength != C.byteLength || w.byteOffset != C.byteOffset)
            return !1;
          w = w.buffer, C = C.buffer;
        case E:
          return !(w.byteLength != C.byteLength || !we(new $n(w), new $n(C)));
        case u:
        case p:
        case _:
          return ca(+w, +C);
        case f:
          return w.name == C.name && w.message == C.message;
        case V:
        case U:
          return w == C + "";
        case b:
          var Be = yt;
        case O:
          var kt = Q & o;
          if (Be || (Be = Nt), w.size != C.size && !kt)
            return !1;
          var Ve = Ue.get(w);
          if (Ve)
            return Ve == C;
          Q |= i, Ue.set(w, C);
          var Wt = Ki(Be(w), Be(C), Q, ke, we, Ue);
          return Ue.delete(w), Wt;
        case B:
          if (ne)
            return ne.call(w) == ne.call(C);
      }
      return !1;
    }
    function sc(w, C, R, Q, ke, we) {
      var Ue = R & o, Be = fo(w), kt = Be.length, Ve = fo(C), Wt = Ve.length;
      if (kt != Wt && !Ue)
        return !1;
      for (var dn = kt; dn--; ) {
        var St = Be[dn];
        if (!(Ue ? St in C : ge.call(C, St)))
          return !1;
      }
      var Jt = we.get(w);
      if (Jt && we.get(C))
        return Jt == C;
      var Ut = !0;
      we.set(w, C), we.set(C, w);
      for (var Fr = Ue; ++dn < kt; ) {
        St = Be[dn];
        var Cr = w[St], ho = C[St];
        if (Q)
          var Cp = Ue ? Q(ho, Cr, St, C, w, we) : Q(Cr, ho, St, w, C, we);
        if (!(Cp === void 0 ? Cr === ho || ke(Cr, ho, R, Q, we) : Cp)) {
          Ut = !1;
          break;
        }
        Fr || (Fr = St == "constructor");
      }
      if (Ut && !Fr) {
        var ha = w.constructor, wa = C.constructor;
        ha != wa && "constructor" in w && "constructor" in C && !(typeof ha == "function" && ha instanceof ha && typeof wa == "function" && wa instanceof wa) && (Ut = !1);
      }
      return we.delete(w), we.delete(C), Ut;
    }
    function fo(w) {
      return Gi(w, Xi, ac);
    }
    function jn(w, C) {
      var R = w.__data__;
      return cc(C) ? R[typeof C == "string" ? "string" : "hash"] : R.map;
    }
    function xr(w, C) {
      var R = ut(w, C);
      return nc(R) ? R : void 0;
    }
    function _r(w) {
      var C = ge.call(w, qt), R = w[qt];
      try {
        w[qt] = void 0;
        var Q = !0;
      } catch {
      }
      var ke = Tt.call(w);
      return Q && (C ? w[qt] = R : delete w[qt]), ke;
    }
    var ac = Cn ? function(w) {
      return w == null ? [] : (w = Object(w), re(Cn(w), function(C) {
        return xn.call(w, C);
      }));
    } : fc, rr = po;
    (er && rr(new er(new ArrayBuffer(1))) != S || Ge && rr(new Ge()) != b || dt && rr(dt.resolve()) != A || Zt && rr(new Zt()) != O || en && rr(new en()) != K) && (rr = function(w) {
      var C = po(w), R = C == y ? w.constructor : void 0, Q = R ? tn(R) : "";
      if (Q)
        switch (Q) {
          case $r:
            return S;
          case Sn:
            return b;
          case m:
            return A;
          case v:
            return O;
          case D:
            return K;
        }
      return C;
    });
    function lc(w, C) {
      return C = C ?? s, !!C && (typeof w == "number" || Z.test(w)) && w > -1 && w % 1 == 0 && w < C;
    }
    function cc(w) {
      var C = typeof w;
      return C == "string" || C == "number" || C == "symbol" || C == "boolean" ? w !== "__proto__" : w === null;
    }
    function uc(w) {
      return !!ze && ze in w;
    }
    function dc(w) {
      var C = w && w.constructor, R = typeof C == "function" && C.prototype || mn;
      return w === R;
    }
    function la(w) {
      return Tt.call(w);
    }
    function tn(w) {
      if (w != null) {
        try {
          return bn.call(w);
        } catch {
        }
        try {
          return w + "";
        } catch {
        }
      }
      return "";
    }
    function ca(w, C) {
      return w === C || w !== w && C !== C;
    }
    var ua = sa(/* @__PURE__ */ function() {
      return arguments;
    }()) ? sa : function(w) {
      return or(w) && ge.call(w, "callee") && !xn.call(w, "callee");
    }, Zo = Array.isArray;
    function Wi(w) {
      return w != null && Ji(w.length) && !da(w);
    }
    var ei = En || hc;
    function pc(w, C) {
      return aa(w, C);
    }
    function da(w) {
      if (!pa(w))
        return !1;
      var C = po(w);
      return C == h || C == g || C == c || C == P;
    }
    function Ji(w) {
      return typeof w == "number" && w > -1 && w % 1 == 0 && w <= s;
    }
    function pa(w) {
      var C = typeof w;
      return w != null && (C == "object" || C == "function");
    }
    function or(w) {
      return w != null && typeof w == "object";
    }
    var fa = Fe ? Je(Fe) : rc;
    function Xi(w) {
      return Wi(w) ? ec(w) : oc(w);
    }
    function fc() {
      return [];
    }
    function hc() {
      return !1;
    }
    t.exports = pc;
  }(ls, ls.exports)), ls.exports;
}
var Ca = {}, gf;
function C1() {
  if (gf) return Ca;
  gf = 1, Object.defineProperty(Ca, "__esModule", { value: !0 });
  const t = Lg(), e = Pg();
  var n;
  return function(r) {
    function o(l = {}, c = {}, u = !1) {
      typeof l != "object" && (l = {}), typeof c != "object" && (c = {});
      let p = t(c);
      u || (p = Object.keys(p).reduce((f, h) => (p[h] != null && (f[h] = p[h]), f), {}));
      for (const f in l)
        l[f] !== void 0 && c[f] === void 0 && (p[f] = l[f]);
      return Object.keys(p).length > 0 ? p : void 0;
    }
    r.compose = o;
    function i(l = {}, c = {}) {
      typeof l != "object" && (l = {}), typeof c != "object" && (c = {});
      const u = Object.keys(l).concat(Object.keys(c)).reduce((p, f) => (e(l[f], c[f]) || (p[f] = c[f] === void 0 ? null : c[f]), p), {});
      return Object.keys(u).length > 0 ? u : void 0;
    }
    r.diff = i;
    function s(l = {}, c = {}) {
      l = l || {};
      const u = Object.keys(c).reduce((p, f) => (c[f] !== l[f] && l[f] !== void 0 && (p[f] = c[f]), p), {});
      return Object.keys(l).reduce((p, f) => (l[f] !== c[f] && c[f] === void 0 && (p[f] = null), p), u);
    }
    r.invert = s;
    function a(l, c, u = !1) {
      if (typeof l != "object")
        return c;
      if (typeof c != "object")
        return;
      if (!u)
        return c;
      const p = Object.keys(c).reduce((f, h) => (l[h] === void 0 && (f[h] = c[h]), f), {});
      return Object.keys(p).length > 0 ? p : void 0;
    }
    r.transform = a;
  }(n || (n = {})), Ca.default = n, Ca;
}
var Ea = {}, mf;
function $g() {
  if (mf) return Ea;
  mf = 1, Object.defineProperty(Ea, "__esModule", { value: !0 });
  var t;
  return function(e) {
    function n(r) {
      return typeof r.delete == "number" ? r.delete : typeof r.retain == "number" ? r.retain : typeof r.retain == "object" && r.retain !== null ? 1 : typeof r.insert == "string" ? r.insert.length : 1;
    }
    e.length = n;
  }(t || (t = {})), Ea.default = t, Ea;
}
var ka = {}, bf;
function E1() {
  if (bf) return ka;
  bf = 1, Object.defineProperty(ka, "__esModule", { value: !0 });
  const t = $g();
  class e {
    constructor(r) {
      this.ops = r, this.index = 0, this.offset = 0;
    }
    hasNext() {
      return this.peekLength() < 1 / 0;
    }
    next(r) {
      r || (r = 1 / 0);
      const o = this.ops[this.index];
      if (o) {
        const i = this.offset, s = t.default.length(o);
        if (r >= s - i ? (r = s - i, this.index += 1, this.offset = 0) : this.offset += r, typeof o.delete == "number")
          return { delete: r };
        {
          const a = {};
          return o.attributes && (a.attributes = o.attributes), typeof o.retain == "number" ? a.retain = r : typeof o.retain == "object" && o.retain !== null ? a.retain = o.retain : typeof o.insert == "string" ? a.insert = o.insert.substr(i, r) : a.insert = o.insert, a;
        }
      } else
        return { retain: 1 / 0 };
    }
    peek() {
      return this.ops[this.index];
    }
    peekLength() {
      return this.ops[this.index] ? t.default.length(this.ops[this.index]) - this.offset : 1 / 0;
    }
    peekType() {
      const r = this.ops[this.index];
      return r ? typeof r.delete == "number" ? "delete" : typeof r.retain == "number" || typeof r.retain == "object" && r.retain !== null ? "retain" : "insert" : "retain";
    }
    rest() {
      if (this.hasNext()) {
        if (this.offset === 0)
          return this.ops.slice(this.index);
        {
          const r = this.offset, o = this.index, i = this.next(), s = this.ops.slice(this.index);
          return this.offset = r, this.index = o, [i].concat(s);
        }
      } else return [];
    }
  }
  return ka.default = e, ka;
}
var vf;
function k1() {
  return vf || (vf = 1, function(t, e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AttributeMap = e.OpIterator = e.Op = void 0;
    const n = _1(), r = Lg(), o = Pg(), i = C1();
    e.AttributeMap = i.default;
    const s = $g();
    e.Op = s.default;
    const a = E1();
    e.OpIterator = a.default;
    const l = "\0", c = (p, f) => {
      if (typeof p != "object" || p === null)
        throw new Error(`cannot retain a ${typeof p}`);
      if (typeof f != "object" || f === null)
        throw new Error(`cannot retain a ${typeof f}`);
      const h = Object.keys(p)[0];
      if (!h || h !== Object.keys(f)[0])
        throw new Error(`embed types not matched: ${h} != ${Object.keys(f)[0]}`);
      return [h, p[h], f[h]];
    };
    class u {
      constructor(f) {
        Array.isArray(f) ? this.ops = f : f != null && Array.isArray(f.ops) ? this.ops = f.ops : this.ops = [];
      }
      static registerEmbed(f, h) {
        this.handlers[f] = h;
      }
      static unregisterEmbed(f) {
        delete this.handlers[f];
      }
      static getHandler(f) {
        const h = this.handlers[f];
        if (!h)
          throw new Error(`no handlers for embed type "${f}"`);
        return h;
      }
      insert(f, h) {
        const g = {};
        return typeof f == "string" && f.length === 0 ? this : (g.insert = f, h != null && typeof h == "object" && Object.keys(h).length > 0 && (g.attributes = h), this.push(g));
      }
      delete(f) {
        return f <= 0 ? this : this.push({ delete: f });
      }
      retain(f, h) {
        if (typeof f == "number" && f <= 0)
          return this;
        const g = { retain: f };
        return h != null && typeof h == "object" && Object.keys(h).length > 0 && (g.attributes = h), this.push(g);
      }
      push(f) {
        let h = this.ops.length, g = this.ops[h - 1];
        if (f = r(f), typeof g == "object") {
          if (typeof f.delete == "number" && typeof g.delete == "number")
            return this.ops[h - 1] = { delete: g.delete + f.delete }, this;
          if (typeof g.delete == "number" && f.insert != null && (h -= 1, g = this.ops[h - 1], typeof g != "object"))
            return this.ops.unshift(f), this;
          if (o(f.attributes, g.attributes)) {
            if (typeof f.insert == "string" && typeof g.insert == "string")
              return this.ops[h - 1] = { insert: g.insert + f.insert }, typeof f.attributes == "object" && (this.ops[h - 1].attributes = f.attributes), this;
            if (typeof f.retain == "number" && typeof g.retain == "number")
              return this.ops[h - 1] = { retain: g.retain + f.retain }, typeof f.attributes == "object" && (this.ops[h - 1].attributes = f.attributes), this;
          }
        }
        return h === this.ops.length ? this.ops.push(f) : this.ops.splice(h, 0, f), this;
      }
      chop() {
        const f = this.ops[this.ops.length - 1];
        return f && typeof f.retain == "number" && !f.attributes && this.ops.pop(), this;
      }
      filter(f) {
        return this.ops.filter(f);
      }
      forEach(f) {
        this.ops.forEach(f);
      }
      map(f) {
        return this.ops.map(f);
      }
      partition(f) {
        const h = [], g = [];
        return this.forEach((b) => {
          (f(b) ? h : g).push(b);
        }), [h, g];
      }
      reduce(f, h) {
        return this.ops.reduce(f, h);
      }
      changeLength() {
        return this.reduce((f, h) => h.insert ? f + s.default.length(h) : h.delete ? f - h.delete : f, 0);
      }
      length() {
        return this.reduce((f, h) => f + s.default.length(h), 0);
      }
      slice(f = 0, h = 1 / 0) {
        const g = [], b = new a.default(this.ops);
        let _ = 0;
        for (; _ < h && b.hasNext(); ) {
          let x;
          _ < f ? x = b.next(f - _) : (x = b.next(h - _), g.push(x)), _ += s.default.length(x);
        }
        return new u(g);
      }
      compose(f) {
        const h = new a.default(this.ops), g = new a.default(f.ops), b = [], _ = g.peek();
        if (_ != null && typeof _.retain == "number" && _.attributes == null) {
          let y = _.retain;
          for (; h.peekType() === "insert" && h.peekLength() <= y; )
            y -= h.peekLength(), b.push(h.next());
          _.retain - y > 0 && g.next(_.retain - y);
        }
        const x = new u(b);
        for (; h.hasNext() || g.hasNext(); )
          if (g.peekType() === "insert")
            x.push(g.next());
          else if (h.peekType() === "delete")
            x.push(h.next());
          else {
            const y = Math.min(h.peekLength(), g.peekLength()), A = h.next(y), P = g.next(y);
            if (P.retain) {
              const V = {};
              if (typeof A.retain == "number")
                V.retain = typeof P.retain == "number" ? y : P.retain;
              else if (typeof P.retain == "number")
                A.retain == null ? V.insert = A.insert : V.retain = A.retain;
              else {
                const U = A.retain == null ? "insert" : "retain", [B, F, K] = c(A[U], P.retain), E = u.getHandler(B);
                V[U] = {
                  [B]: E.compose(F, K, U === "retain")
                };
              }
              const O = i.default.compose(A.attributes, P.attributes, typeof A.retain == "number");
              if (O && (V.attributes = O), x.push(V), !g.hasNext() && o(x.ops[x.ops.length - 1], V)) {
                const U = new u(h.rest());
                return x.concat(U).chop();
              }
            } else typeof P.delete == "number" && (typeof A.retain == "number" || typeof A.retain == "object" && A.retain !== null) && x.push(P);
          }
        return x.chop();
      }
      concat(f) {
        const h = new u(this.ops.slice());
        return f.ops.length > 0 && (h.push(f.ops[0]), h.ops = h.ops.concat(f.ops.slice(1))), h;
      }
      diff(f, h) {
        if (this.ops === f.ops)
          return new u();
        const g = [this, f].map((A) => A.map((P) => {
          if (P.insert != null)
            return typeof P.insert == "string" ? P.insert : l;
          const V = A === f ? "on" : "with";
          throw new Error("diff() called " + V + " non-document");
        }).join("")), b = new u(), _ = n(g[0], g[1], h, !0), x = new a.default(this.ops), y = new a.default(f.ops);
        return _.forEach((A) => {
          let P = A[1].length;
          for (; P > 0; ) {
            let V = 0;
            switch (A[0]) {
              case n.INSERT:
                V = Math.min(y.peekLength(), P), b.push(y.next(V));
                break;
              case n.DELETE:
                V = Math.min(P, x.peekLength()), x.next(V), b.delete(V);
                break;
              case n.EQUAL:
                V = Math.min(x.peekLength(), y.peekLength(), P);
                const O = x.next(V), U = y.next(V);
                o(O.insert, U.insert) ? b.retain(V, i.default.diff(O.attributes, U.attributes)) : b.push(U).delete(V);
                break;
            }
            P -= V;
          }
        }), b.chop();
      }
      eachLine(f, h = `
`) {
        const g = new a.default(this.ops);
        let b = new u(), _ = 0;
        for (; g.hasNext(); ) {
          if (g.peekType() !== "insert")
            return;
          const x = g.peek(), y = s.default.length(x) - g.peekLength(), A = typeof x.insert == "string" ? x.insert.indexOf(h, y) - y : -1;
          if (A < 0)
            b.push(g.next());
          else if (A > 0)
            b.push(g.next(A));
          else {
            if (f(b, g.next(1).attributes || {}, _) === !1)
              return;
            _ += 1, b = new u();
          }
        }
        b.length() > 0 && f(b, {}, _);
      }
      invert(f) {
        const h = new u();
        return this.reduce((g, b) => {
          if (b.insert)
            h.delete(s.default.length(b));
          else {
            if (typeof b.retain == "number" && b.attributes == null)
              return h.retain(b.retain), g + b.retain;
            if (b.delete || typeof b.retain == "number") {
              const _ = b.delete || b.retain;
              return f.slice(g, g + _).forEach((y) => {
                b.delete ? h.push(y) : b.retain && b.attributes && h.retain(s.default.length(y), i.default.invert(b.attributes, y.attributes));
              }), g + _;
            } else if (typeof b.retain == "object" && b.retain !== null) {
              const _ = f.slice(g, g + 1), x = new a.default(_.ops).next(), [y, A, P] = c(b.retain, x.insert), V = u.getHandler(y);
              return h.retain({ [y]: V.invert(A, P) }, i.default.invert(b.attributes, x.attributes)), g + 1;
            }
          }
          return g;
        }, 0), h.chop();
      }
      transform(f, h = !1) {
        if (h = !!h, typeof f == "number")
          return this.transformPosition(f, h);
        const g = f, b = new a.default(this.ops), _ = new a.default(g.ops), x = new u();
        for (; b.hasNext() || _.hasNext(); )
          if (b.peekType() === "insert" && (h || _.peekType() !== "insert"))
            x.retain(s.default.length(b.next()));
          else if (_.peekType() === "insert")
            x.push(_.next());
          else {
            const y = Math.min(b.peekLength(), _.peekLength()), A = b.next(y), P = _.next(y);
            if (A.delete)
              continue;
            if (P.delete)
              x.push(P);
            else {
              const V = A.retain, O = P.retain;
              let U = typeof O == "object" && O !== null ? O : y;
              if (typeof V == "object" && V !== null && typeof O == "object" && O !== null) {
                const B = Object.keys(V)[0];
                if (B === Object.keys(O)[0]) {
                  const F = u.getHandler(B);
                  F && (U = {
                    [B]: F.transform(V[B], O[B], h)
                  });
                }
              }
              x.retain(U, i.default.transform(A.attributes, P.attributes, h));
            }
          }
        return x.chop();
      }
      transformPosition(f, h = !1) {
        h = !!h;
        const g = new a.default(this.ops);
        let b = 0;
        for (; g.hasNext() && b <= f; ) {
          const _ = g.peekLength(), x = g.peekType();
          if (g.next(), x === "delete") {
            f -= Math.min(_, f - b);
            continue;
          } else x === "insert" && (b < f || !h) && (f += _);
          b += _;
        }
        return f;
      }
    }
    u.Op = s.default, u.OpIterator = a.default, u.AttributeMap = i.default, u.handlers = {}, e.default = u, t.exports = u, t.exports.default = u;
  }(_a, _a.exports)), _a.exports;
}
var N1 = k1();
const cs = /* @__PURE__ */ Yx(N1);
var T1 = Object.getOwnPropertyNames, A1 = Object.getOwnPropertySymbols, S1 = Object.prototype.hasOwnProperty;
function yf(t, e) {
  return function(r, o, i) {
    return t(r, o, i) && e(r, o, i);
  };
}
function Na(t) {
  return function(n, r, o) {
    if (!n || !r || typeof n != "object" || typeof r != "object")
      return t(n, r, o);
    var i = o.cache, s = i.get(n), a = i.get(r);
    if (s && a)
      return s === r && a === n;
    i.set(n, r), i.set(r, n);
    var l = t(n, r, o);
    return i.delete(n), i.delete(r), l;
  };
}
function xf(t) {
  return T1(t).concat(A1(t));
}
var D1 = Object.hasOwn || function(t, e) {
  return S1.call(t, e);
};
function Go(t, e) {
  return t === e || !t && !e && t !== t && e !== e;
}
var M1 = "__v", O1 = "__o", R1 = "_owner", _f = Object.getOwnPropertyDescriptor, Cf = Object.keys;
function I1(t, e, n) {
  var r = t.length;
  if (e.length !== r)
    return !1;
  for (; r-- > 0; )
    if (!n.equals(t[r], e[r], r, r, t, e, n))
      return !1;
  return !0;
}
function L1(t, e) {
  return Go(t.getTime(), e.getTime());
}
function P1(t, e) {
  return t.name === e.name && t.message === e.message && t.cause === e.cause && t.stack === e.stack;
}
function $1(t, e) {
  return t === e;
}
function Ef(t, e, n) {
  var r = t.size;
  if (r !== e.size)
    return !1;
  if (!r)
    return !0;
  for (var o = new Array(r), i = t.entries(), s, a, l = 0; (s = i.next()) && !s.done; ) {
    for (var c = e.entries(), u = !1, p = 0; (a = c.next()) && !a.done; ) {
      if (o[p]) {
        p++;
        continue;
      }
      var f = s.value, h = a.value;
      if (n.equals(f[0], h[0], l, p, t, e, n) && n.equals(f[1], h[1], f[0], h[0], t, e, n)) {
        u = o[p] = !0;
        break;
      }
      p++;
    }
    if (!u)
      return !1;
    l++;
  }
  return !0;
}
var F1 = Go;
function B1(t, e, n) {
  var r = Cf(t), o = r.length;
  if (Cf(e).length !== o)
    return !1;
  for (; o-- > 0; )
    if (!Fg(t, e, n, r[o]))
      return !1;
  return !0;
}
function es(t, e, n) {
  var r = xf(t), o = r.length;
  if (xf(e).length !== o)
    return !1;
  for (var i, s, a; o-- > 0; )
    if (i = r[o], !Fg(t, e, n, i) || (s = _f(t, i), a = _f(e, i), (s || a) && (!s || !a || s.configurable !== a.configurable || s.enumerable !== a.enumerable || s.writable !== a.writable)))
      return !1;
  return !0;
}
function q1(t, e) {
  return Go(t.valueOf(), e.valueOf());
}
function j1(t, e) {
  return t.source === e.source && t.flags === e.flags;
}
function kf(t, e, n) {
  var r = t.size;
  if (r !== e.size)
    return !1;
  if (!r)
    return !0;
  for (var o = new Array(r), i = t.values(), s, a; (s = i.next()) && !s.done; ) {
    for (var l = e.values(), c = !1, u = 0; (a = l.next()) && !a.done; ) {
      if (!o[u] && n.equals(s.value, a.value, s.value, a.value, t, e, n)) {
        c = o[u] = !0;
        break;
      }
      u++;
    }
    if (!c)
      return !1;
  }
  return !0;
}
function U1(t, e) {
  var n = t.length;
  if (e.length !== n)
    return !1;
  for (; n-- > 0; )
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function V1(t, e) {
  return t.hostname === e.hostname && t.pathname === e.pathname && t.protocol === e.protocol && t.port === e.port && t.hash === e.hash && t.username === e.username && t.password === e.password;
}
function Fg(t, e, n, r) {
  return (r === R1 || r === O1 || r === M1) && (t.$$typeof || e.$$typeof) ? !0 : D1(e, r) && n.equals(t[r], e[r], r, r, t, e, n);
}
var H1 = "[object Arguments]", z1 = "[object Boolean]", G1 = "[object Date]", K1 = "[object Error]", W1 = "[object Map]", J1 = "[object Number]", X1 = "[object Object]", Y1 = "[object RegExp]", Q1 = "[object Set]", Z1 = "[object String]", e_ = "[object URL]", t_ = Array.isArray, Nf = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, Tf = Object.assign, n_ = Object.prototype.toString.call.bind(Object.prototype.toString);
function r_(t) {
  var e = t.areArraysEqual, n = t.areDatesEqual, r = t.areErrorsEqual, o = t.areFunctionsEqual, i = t.areMapsEqual, s = t.areNumbersEqual, a = t.areObjectsEqual, l = t.arePrimitiveWrappersEqual, c = t.areRegExpsEqual, u = t.areSetsEqual, p = t.areTypedArraysEqual, f = t.areUrlsEqual;
  return function(g, b, _) {
    if (g === b)
      return !0;
    if (g == null || b == null)
      return !1;
    var x = typeof g;
    if (x !== typeof b)
      return !1;
    if (x !== "object")
      return x === "number" ? s(g, b, _) : x === "function" ? o(g, b, _) : !1;
    var y = g.constructor;
    if (y !== b.constructor)
      return !1;
    if (y === Object)
      return a(g, b, _);
    if (t_(g))
      return e(g, b, _);
    if (Nf != null && Nf(g))
      return p(g, b, _);
    if (y === Date)
      return n(g, b, _);
    if (y === RegExp)
      return c(g, b, _);
    if (y === Map)
      return i(g, b, _);
    if (y === Set)
      return u(g, b, _);
    var A = n_(g);
    return A === G1 ? n(g, b, _) : A === Y1 ? c(g, b, _) : A === W1 ? i(g, b, _) : A === Q1 ? u(g, b, _) : A === X1 ? typeof g.then != "function" && typeof b.then != "function" && a(g, b, _) : A === e_ ? f(g, b, _) : A === K1 ? r(g, b, _) : A === H1 ? a(g, b, _) : A === z1 || A === J1 || A === Z1 ? l(g, b, _) : !1;
  };
}
function o_(t) {
  var e = t.circular, n = t.createCustomConfig, r = t.strict, o = {
    areArraysEqual: r ? es : I1,
    areDatesEqual: L1,
    areErrorsEqual: P1,
    areFunctionsEqual: $1,
    areMapsEqual: r ? yf(Ef, es) : Ef,
    areNumbersEqual: F1,
    areObjectsEqual: r ? es : B1,
    arePrimitiveWrappersEqual: q1,
    areRegExpsEqual: j1,
    areSetsEqual: r ? yf(kf, es) : kf,
    areTypedArraysEqual: r ? es : U1,
    areUrlsEqual: V1
  };
  if (n && (o = Tf({}, o, n(o))), e) {
    var i = Na(o.areArraysEqual), s = Na(o.areMapsEqual), a = Na(o.areObjectsEqual), l = Na(o.areSetsEqual);
    o = Tf({}, o, {
      areArraysEqual: i,
      areMapsEqual: s,
      areObjectsEqual: a,
      areSetsEqual: l
    });
  }
  return o;
}
function i_(t) {
  return function(e, n, r, o, i, s, a) {
    return t(e, n, a);
  };
}
function s_(t) {
  var e = t.circular, n = t.comparator, r = t.createState, o = t.equals, i = t.strict;
  if (r)
    return function(l, c) {
      var u = r(), p = u.cache, f = p === void 0 ? e ? /* @__PURE__ */ new WeakMap() : void 0 : p, h = u.meta;
      return n(l, c, {
        cache: f,
        equals: o,
        meta: h,
        strict: i
      });
    };
  if (e)
    return function(l, c) {
      return n(l, c, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: o,
        meta: void 0,
        strict: i
      });
    };
  var s = {
    cache: void 0,
    equals: o,
    meta: void 0,
    strict: i
  };
  return function(l, c) {
    return n(l, c, s);
  };
}
var kr = io();
io({ strict: !0 });
io({ circular: !0 });
io({
  circular: !0,
  strict: !0
});
io({
  createInternalComparator: function() {
    return Go;
  }
});
io({
  strict: !0,
  createInternalComparator: function() {
    return Go;
  }
});
io({
  circular: !0,
  createInternalComparator: function() {
    return Go;
  }
});
io({
  circular: !0,
  createInternalComparator: function() {
    return Go;
  },
  strict: !0
});
function io(t) {
  t === void 0 && (t = {});
  var e = t.circular, n = e === void 0 ? !1 : e, r = t.createInternalComparator, o = t.createState, i = t.strict, s = i === void 0 ? !1 : i, a = o_(t), l = r_(a), c = r ? r(l) : i_(l);
  return s_({ circular: n, comparator: l, createState: o, equals: c, strict: s });
}
const Bg = Zr(null);
function a_(t, e) {
  return { getTheme: function() {
    return e ?? null;
  } };
}
function De() {
  const t = jo(Bg);
  return t == null && function(e, ...n) {
    const r = new URL("https://lexical.dev/docs/error"), o = new URLSearchParams();
    o.append("code", e);
    for (const i of n) o.append("v", i);
    throw r.search = o.toString(), Error(`Minified Lexical error #${e}; visit ${r.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }(8), t;
}
function qg(t, e) {
  if (typeof document > "u" || typeof window > "u" && global.window === void 0) throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  const n = document.createElement("div"), r = tt().getChildren();
  for (let o = 0; o < r.length; o++)
    jg(t, r[o], n, e);
  return n.innerHTML;
}
function jg(t, e, n, r = null) {
  let o = r === null || e.isSelected(r);
  const i = Ae(e) && e.excludeFromCopy("html");
  let s = e;
  if (r !== null) {
    let h = ny(e);
    h = xe(h) && r !== null ? c1(r, h) : h, s = h;
  }
  const a = Ae(s) ? s.getChildren() : [], l = vw(t, s.getType());
  let c;
  c = l && l.exportDOM !== void 0 ? l.exportDOM(t, s) : s.exportDOM(t);
  const { element: u, after: p } = c;
  if (!u) return !1;
  const f = document.createDocumentFragment();
  for (let h = 0; h < a.length; h++) {
    const g = a[h], b = jg(t, g, f, r);
    !o && Ae(e) && b && e.extractWithChild(g, r, "html") && (o = !0);
  }
  if (o && !i) {
    if ((vr(u) || Ga(u)) && u.append(f), n.append(u), p) {
      const h = p.call(s, u);
      h && (Ga(u) ? u.replaceChildren(h) : u.replaceWith(h));
    }
  } else n.append(f);
  return o;
}
const l_ = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
let Ug = class Vg extends ro {
  static getType() {
    return "link";
  }
  static clone(e) {
    return new Vg(e.__url, { rel: e.__rel, target: e.__target, title: e.__title }, e.__key);
  }
  constructor(e = "", n = {}, r) {
    super(r);
    const { target: o = null, rel: i = null, title: s = null } = n;
    this.__url = e, this.__target = o, this.__rel = i, this.__title = s;
  }
  createDOM(e) {
    const n = document.createElement("a");
    return this.updateLinkDOM(null, n, e), Vr(n, e.theme.link), n;
  }
  updateLinkDOM(e, n, r) {
    if (xw(n)) {
      e && e.__url === this.__url || (n.href = this.sanitizeUrl(this.__url));
      for (const o of ["target", "rel", "title"]) {
        const i = `__${o}`, s = this[i];
        e && e[i] === s || (s ? n[o] = s : n.removeAttribute(o));
      }
    }
  }
  updateDOM(e, n, r) {
    return this.updateLinkDOM(e, n, r), !1;
  }
  static importDOM() {
    return { a: (e) => ({ conversion: c_, priority: 1 }) };
  }
  static importJSON(e) {
    return wu().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setURL(e.url).setRel(e.rel || null).setTarget(e.target || null).setTitle(e.title || null);
  }
  sanitizeUrl(e) {
    e = Af(e);
    try {
      const n = new URL(Af(e));
      if (!l_.has(n.protocol)) return "about:blank";
    } catch {
      return e;
    }
    return e;
  }
  exportJSON() {
    return { ...super.exportJSON(), rel: this.getRel(), target: this.getTarget(), title: this.getTitle(), url: this.getURL() };
  }
  getURL() {
    return this.getLatest().__url;
  }
  setURL(e) {
    const n = this.getWritable();
    return n.__url = e, n;
  }
  getTarget() {
    return this.getLatest().__target;
  }
  setTarget(e) {
    const n = this.getWritable();
    return n.__target = e, n;
  }
  getRel() {
    return this.getLatest().__rel;
  }
  setRel(e) {
    const n = this.getWritable();
    return n.__rel = e, n;
  }
  getTitle() {
    return this.getLatest().__title;
  }
  setTitle(e) {
    const n = this.getWritable();
    return n.__title = e, n;
  }
  insertNewAfter(e, n = !0) {
    const r = wu(this.__url, { rel: this.__rel, target: this.__target, title: this.__title });
    return this.insertAfter(r, n), r;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
  extractWithChild(e, n, r) {
    if (!me(n)) return !1;
    const o = n.anchor.getNode(), i = n.focus.getNode();
    return this.isParentOf(o) && this.isParentOf(i) && n.getTextContent().length > 0;
  }
  isEmailURI() {
    return this.__url.startsWith("mailto:");
  }
  isWebSiteURI() {
    return this.__url.startsWith("https://") || this.__url.startsWith("http://");
  }
};
function c_(t) {
  let e = null;
  if (xw(t)) {
    const n = t.textContent;
    (n !== null && n !== "" || t.children.length > 0) && (e = wu(t.getAttribute("href") || "", { rel: t.getAttribute("rel"), target: t.getAttribute("target"), title: t.getAttribute("title") }));
  }
  return { node: e };
}
function wu(t = "", e) {
  return Mt(new Ug(t, e));
}
function u_(t) {
  return t instanceof Ug;
}
Di("TOGGLE_LINK_COMMAND");
const d_ = /^\+?[0-9\s()-]{5,}$/;
function Af(t) {
  return t.match(/^[a-z][a-z0-9+.-]*:/i) || t.match(/^[/#.]/) ? t : t.includes("@") ? `mailto:${t}` : d_.test(t) ? `tel:${t}` : `https://${t}`;
}
const Hg = [];
let zg = class Gg extends ro {
  static getType() {
    return "mark";
  }
  static clone(e) {
    return new Gg(e.__ids, e.__key);
  }
  static importDOM() {
    return null;
  }
  static importJSON(e) {
    return Sf().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setIDs(e.ids);
  }
  exportJSON() {
    return { ...super.exportJSON(), ids: this.getIDs() };
  }
  constructor(e = Hg, n) {
    super(n), this.__ids = e;
  }
  createDOM(e) {
    const n = document.createElement("mark");
    return Vr(n, e.theme.mark), this.__ids.length > 1 && Vr(n, e.theme.markOverlap), n;
  }
  updateDOM(e, n, r) {
    const o = e.__ids, i = this.__ids, s = o.length, a = i.length, l = r.theme.markOverlap;
    return s !== a && (s === 1 ? a === 2 && Vr(n, l) : a === 1 && hu(n, l)), !1;
  }
  hasID(e) {
    return this.getIDs().includes(e);
  }
  getIDs() {
    return Array.from(this.getLatest().__ids);
  }
  setIDs(e) {
    const n = this.getWritable();
    return n.__ids = e, n;
  }
  addID(e) {
    const n = this.getWritable();
    return n.__ids.includes(e) ? n : n.setIDs([...n.__ids, e]);
  }
  deleteID(e) {
    const n = this.getWritable(), r = n.__ids.indexOf(e);
    if (r === -1) return n;
    const o = Array.from(n.__ids);
    return o.splice(r, 1), n.setIDs(o);
  }
  insertNewAfter(e, n = !0) {
    const r = Sf(this.__ids);
    return this.insertAfter(r, n), r;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
  extractWithChild(e, n, r) {
    if (!me(n) || r === "html") return !1;
    const o = n.anchor, i = n.focus, s = o.getNode(), a = i.getNode(), l = n.isBackward() ? o.offset - i.offset : i.offset - o.offset;
    return this.isParentOf(s) && this.isParentOf(a) && this.getTextContent().length === l;
  }
  excludeFromCopy(e) {
    return e !== "clone";
  }
};
function Sf(t = Hg) {
  return Mt(new zg(t));
}
function p_(t) {
  return t instanceof zg;
}
const Kg = Object.freeze({ "	": "\\t", "\n": "\\n" }), Df = new RegExp(Object.keys(Kg).join("|"), "g"), lr = Object.freeze({ ancestorHasNextSibling: "|", ancestorIsLastChild: " ", hasNextSibling: "â”œ", isLastChild: "â””", selectedChar: "^", selectedLine: ">" }), f_ = [(t) => t.hasFormat("bold") && "Bold", (t) => t.hasFormat("code") && "Code", (t) => t.hasFormat("italic") && "Italic", (t) => t.hasFormat("strikethrough") && "Strikethrough", (t) => t.hasFormat("subscript") && "Subscript", (t) => t.hasFormat("superscript") && "Superscript", (t) => t.hasFormat("underline") && "Underline", (t) => t.hasFormat("highlight") && "Highlight"], h_ = [(t) => t.hasTextFormat("bold") && "Bold", (t) => t.hasTextFormat("code") && "Code", (t) => t.hasTextFormat("italic") && "Italic", (t) => t.hasTextFormat("strikethrough") && "Strikethrough", (t) => t.hasTextFormat("subscript") && "Subscript", (t) => t.hasTextFormat("superscript") && "Superscript", (t) => t.hasTextFormat("underline") && "Underline", (t) => t.hasTextFormat("highlight") && "Highlight"], w_ = [(t) => t.isDirectionless() && "Directionless", (t) => t.isUnmergeable() && "Unmergeable"], g_ = [(t) => t.isToken() && "Token", (t) => t.isSegmented() && "Segmented"];
function m_(t, e, n, r, o = !1) {
  const i = t.getEditorState(), s = t._config, a = t._compositionKey, l = t._editable;
  if (n) {
    let f = "";
    return i.read(() => {
      f = function(h) {
        const g = document.createElement("div");
        return g.innerHTML = h.trim(), Jg(g, 0).innerHTML;
      }(qg(t));
    }), f;
  }
  let c = ` root
`;
  const u = i.read(() => {
    const f = ve();
    return Wg(tt(), (h, g) => {
      const b = `(${h.getKey()})`, _ = h.getType() || "", x = h.isSelected();
      c += `${x ? lr.selectedLine : " "} ${g.join(" ")} ${b} ${_} ${function(y, A, P = !1) {
        const V = A ? A(y, P) : void 0;
        if (V !== void 0 && V.length > 0) return V;
        if (xe(y)) {
          const O = y.getTextContent(), U = O.length === 0 ? "(empty)" : `"${Mf(O, P)}"`, B = function(F) {
            return [Of(F), b_(F), v_(F), Rf(F)].filter(Boolean).join(", ");
          }(y);
          return [U, B.length !== 0 ? `{ ${B} }` : null].filter(Boolean).join(" ").trim();
        }
        if (u_(y)) {
          const O = y.getURL(), U = O.length === 0 ? "(empty)" : `"${Mf(O, P)}"`, B = function(F) {
            return [y_(F), x_(F), __(F), Rf(F)].filter(Boolean).join(", ");
          }(y);
          return [U, B.length !== 0 ? `{ ${B} }` : null].filter(Boolean).join(" ").trim();
        }
        if (p_(y)) return `ids: [ ${y.getIDs().join(", ")} ]`;
        if (rd(y)) {
          const O = function(B) {
            let F = h_.map((K) => K(B)).filter(Boolean).join(", ").toLocaleLowerCase();
            return F !== "" && (F = "format: " + F), F;
          }(y);
          let U = O !== "" ? `{ ${O} }` : "";
          return U += y.__style ? `(${y.__style})` : "", U;
        }
        return "";
      }(h, r, o)}
`, c += function({ indent: y, isSelected: A, node: P, nodeKeyDisplay: V, selection: O, typeDisplay: U }) {
        if (!xe(P) || !me(O) || !A || Ae(P)) return "";
        const B = O.anchor, F = O.focus;
        if (P.getTextContent() === "" || B.getNode() === O.focus.getNode() && B.offset === F.offset) return "";
        const [K, E] = function(L, J) {
          const G = J.getStartEndPoints();
          if (eu(J) || G === null) return [-1, -1];
          const [W, ee] = G, te = L.getTextContent(), Z = te.length;
          let Y = -1, le = -1;
          if (W.type === "text" && ee.type === "text") {
            const _e = W.getNode(), be = ee.getNode();
            _e === be && L === _e && W.offset !== ee.offset ? [Y, le] = W.offset < ee.offset ? [W.offset, ee.offset] : [ee.offset, W.offset] : [Y, le] = L === _e ? _e.isBefore(be) ? [W.offset, Z] : [0, W.offset] : L === be ? be.isBefore(_e) ? [ee.offset, Z] : [0, ee.offset] : [0, Z];
          }
          const de = (te.slice(0, Y).match(Df) || []).length, pe = (te.slice(Y, le).match(Df) || []).length;
          return [Y + de, le + de + pe];
        }(P, O);
        if (K === E) return "";
        const S = y[y.length - 1] === lr.hasNextSibling ? lr.ancestorHasNextSibling : lr.ancestorIsLastChild, k = [...y.slice(0, y.length - 1), S], I = Array(K + 1).fill(" "), N = Array(E - K).fill(lr.selectedChar), T = U.length + 2, $ = Array(V.length + T).fill(" ");
        return [lr.selectedLine, k.join(" "), [...$, ...I, ...N].join("")].join(" ") + `
`;
      }({ indent: g, isSelected: x, node: h, nodeKeyDisplay: b, selection: f, typeDisplay: _ });
    }), f === null ? ": null" : me(f) ? function(h) {
      let g = "";
      const b = Of(h);
      g += `: range ${b !== "" ? `{ ${b} }` : ""} ${h.style !== "" ? `{ style: ${h.style} } ` : ""}`;
      const _ = h.anchor, x = h.focus, y = _.offset, A = x.offset;
      return g += `
  â”œ anchor { key: ${_.key}, offset: ${y === null ? "null" : y}, type: ${_.type} }`, g += `
  â”” focus { key: ${x.key}, offset: ${A === null ? "null" : A}, type: ${x.type} }`, g;
    }(f) : Aw(f) ? function(h) {
      return `: table
  â”” { table: ${h.tableKey}, anchorCell: ${h.anchor.key}, focusCell: ${h.focus.key} }`;
    }(f) : function(h) {
      return eu(h) ? `: node
  â”” [${Array.from(h._nodes).join(", ")}]` : "";
    }(f);
  });
  if (c += `
 selection` + u, c += `

 commands:`, e.length) for (const { index: f, type: h, payload: g } of e) c += `
  â”” ${f}. { type: ${h}, payload: ${g instanceof Event ? g.constructor.name : g} }`;
  else c += `
  â”” None dispatched.`;
  const { version: p } = t.constructor;
  return c += `

 editor${p ? ` (v${p})` : ""}:`, c += `
  â”” namespace ${s.namespace}`, a !== null && (c += `
  â”” compositionKey ${a}`), c += `
  â”” editable ${String(l)}`, c;
}
function Wg(t, e, n = []) {
  const r = t.getChildren(), o = r.length;
  r.forEach((i, s) => {
    e(i, n.concat(s === o - 1 ? lr.isLastChild : lr.hasNextSibling)), Ae(i) && Wg(i, e, n.concat(s === o - 1 ? lr.ancestorIsLastChild : lr.ancestorHasNextSibling));
  });
}
function Mf(t, e = !1) {
  const n = Object.entries(Kg).reduce((r, [o, i]) => r.replace(new RegExp(o, "g"), String(i)), t);
  return e ? n.replace(/[^\s]/g, "*") : n;
}
function b_(t) {
  let e = w_.map((n) => n(t)).filter(Boolean).join(", ").toLocaleLowerCase();
  return e !== "" && (e = "detail: " + e), e;
}
function v_(t) {
  let e = g_.map((n) => n(t)).filter(Boolean).join(", ").toLocaleLowerCase();
  return e !== "" && (e = "mode: " + e), e;
}
function Of(t) {
  let e = f_.map((n) => n(t)).filter(Boolean).join(", ").toLocaleLowerCase();
  return e !== "" && (e = "format: " + e), e;
}
function y_(t) {
  let e = t.getTarget();
  return e != null && (e = "target: " + e), e;
}
function x_(t) {
  let e = t.getRel();
  return e != null && (e = "rel: " + e), e;
}
function __(t) {
  let e = t.getTitle();
  return e != null && (e = "title: " + e), e;
}
function Rf(t) {
  if (!t.__state) return !1;
  const e = [];
  for (const [r, o] of t.__state.knownState.entries()) {
    if (r.isEqual(o, r.defaultValue)) continue;
    const i = JSON.stringify(r.unparse(o));
    e.push(`[${r.key}: ${i}]`);
  }
  let n = e.join(",");
  return n !== "" && (n = "state: " + n), n;
}
function Jg(t, e) {
  const n = new Array(1 + e++).join("  "), r = new Array(e - 1).join("  ");
  let o;
  for (let i = 0; i < t.children.length; i++) o = document.createTextNode(`
` + n), t.insertBefore(o, t.children[i]), Jg(t.children[i], e), t.lastElementChild === t.children[i] && (o = document.createTextNode(`
` + r), t.appendChild(o));
  return t;
}
const C_ = an(function({ treeTypeButtonClassName: t, timeTravelButtonClassName: e, timeTravelPanelSliderClassName: n, timeTravelPanelButtonClassName: r, viewClassName: o, timeTravelPanelClassName: i, editorState: s, setEditorState: a, setEditorReadOnly: l, generateContent: c, commandsLog: u = [] }, p) {
  const [f, h] = oe([]), [g, b] = oe(""), [_, x] = oe(!1), [y, A] = oe(!1), P = he(0), V = he(null), [O, U] = oe(!1), [B, F] = oe(!1), [K, E] = oe(!1), S = he(), k = he([]), I = he(0), N = ce(($) => {
    const L = ++I.current;
    c($).then((J) => {
      L === I.current && b(J);
    }).catch((J) => {
      L === I.current && b(`Error rendering tree: ${J.message}

Stack:
${J.stack}`);
    });
  }, [c]);
  ie(() => {
    if (!(!K && s._nodeMap.size > 1e3 && (F(!0), !K)) && (S.current !== s || k.current !== u)) {
      const $ = S.current !== s;
      S.current = s, k.current = u, N(y), !_ && $ && h((L) => [...L, [Date.now(), s]]);
    }
  }, [s, N, y, K, _, u]);
  const T = f.length;
  return ie(() => {
    if (O) {
      let $;
      const L = () => {
        const J = P.current;
        if (J === T - 1) return void U(!1);
        const G = f[J][0], W = f[J + 1][0];
        $ = setTimeout(() => {
          P.current++;
          const ee = P.current, te = V.current;
          te !== null && (te.value = String(ee)), a(f[ee][1]), L();
        }, W - G);
      };
      return L(), () => {
        clearTimeout($);
      };
    }
  }, [f, O, T, a]), M("div", { className: o, children: [!K && B ? M("div", { style: { padding: 20 }, children: [d("span", { style: { marginRight: 20 }, children: "Detected large EditorState, this can impact debugging performance." }), d("button", { onClick: () => {
    E(!0);
  }, style: { background: "transparent", border: "1px solid white", color: "white", cursor: "pointer", padding: 5 }, children: "Show full tree" })] }) : null, K ? null : d("button", { onClick: () => (N(!y), void A(!y)), className: t, type: "button", children: y ? "Tree" : "Export DOM" }), !_ && (K || !B) && T > 2 && d("button", { onClick: () => {
    l(!0), P.current = T - 1, x(!0);
  }, className: e, type: "button", children: "Time Travel" }), (K || !B) && d("pre", { ref: p, children: g }), _ && (K || !B) && M("div", { className: i, children: [d("button", { className: r, onClick: () => {
    P.current === T - 1 && (P.current = 1), U(!O);
  }, type: "button", children: O ? "Pause" : "Play" }), d("input", { className: n, ref: V, onChange: ($) => {
    const L = Number($.target.value), J = f[L];
    J && (P.current = L, a(J[1]));
  }, type: "range", min: "1", max: T - 1 }), d("button", { className: r, onClick: () => {
    l(!1);
    const $ = f.length - 1, L = f[$];
    a(L[1]);
    const J = V.current;
    J !== null && (J.value = String($)), x(!1), U(!1);
  }, type: "button", children: "Exit" })] })] });
});
function E_(t, e) {
  const n = /* @__PURE__ */ new Set();
  let r = 0;
  for (const [o] of t._commands) n.add(t.registerCommand(o, (i) => (e((s) => {
    r += 1;
    const a = [...s];
    return a.push({ index: r, payload: i, type: o.type ? o.type : "UNKNOWN" }), a.length > 10 && a.shift(), a;
  }), !1), Gr));
  return () => n.forEach((o) => o());
}
function k_(t) {
  const [e, n] = oe([]);
  return ie(() => E_(t, n), [t]), ue(() => e, [e]);
}
function N_({ treeTypeButtonClassName: t, timeTravelButtonClassName: e, timeTravelPanelSliderClassName: n, timeTravelPanelButtonClassName: r, timeTravelPanelClassName: o, viewClassName: i, editor: s, customPrintNode: a }) {
  const l = si.createRef(), [c, u] = oe(s.getEditorState()), p = k_(s);
  return ie(() => Gt(s.registerUpdateListener(({ editorState: f }) => {
    u(f);
  }), s.registerEditableListener(() => {
    u(s.getEditorState());
  })), [s]), ie(() => {
    const f = l.current;
    if (f !== null) return f.__lexicalEditor = s, () => {
      f.__lexicalEditor = null;
    };
  }, [s, l]), d(C_, { treeTypeButtonClassName: t, timeTravelButtonClassName: e, timeTravelPanelSliderClassName: n, timeTravelPanelButtonClassName: r, viewClassName: i, timeTravelPanelClassName: o, setEditorReadOnly: (f) => {
    const h = s.getRootElement();
    h != null && (h.contentEditable = f ? "false" : "true");
  }, editorState: c, setEditorState: (f) => s.setEditorState(f), generateContent: async function(f) {
    return m_(s, p, f, a);
  }, ref: l, commandsLog: p });
}
const Xg = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, T_ = Xg ? xt : ie, Ta = { tag: Uo };
function Yg({ initialConfig: t, children: e }) {
  const n = ue(() => {
    const { theme: r, namespace: o, nodes: i, onError: s, editorState: a, html: l } = t, c = a_(null, r), u = qs({ editable: t.editable, html: l, namespace: o, nodes: i, onError: (p) => s(p, u), theme: r });
    return function(p, f) {
      if (f !== null) {
        if (f === void 0) p.update(() => {
          const h = tt();
          if (h.isEmpty()) {
            const g = js();
            h.append(g);
            const b = Xg ? document.activeElement : null;
            (ve() !== null || b !== null && b === p.getRootElement()) && g.select();
          }
        }, Ta);
        else if (f !== null) switch (typeof f) {
          case "string": {
            const h = p.parseEditorState(f);
            p.setEditorState(h, Ta);
            break;
          }
          case "object":
            p.setEditorState(f, Ta);
            break;
          case "function":
            p.update(() => {
              tt().isEmpty() && f(p);
            }, Ta);
        }
      }
    }(u, a), [u, c];
  }, []);
  return T_(() => {
    const r = t.editable, [o] = n;
    o.setEditable(r === void 0 || r);
  }, []), d(Bg.Provider, { value: n, children: e });
}
function Qg() {
  return tt().getTextContent();
}
function Zg(t, e = !0) {
  if (t) return !1;
  let n = Qg();
  return e && (n = n.trim()), n === "";
}
function A_(t) {
  if (!Zg(t, !1)) return !1;
  const e = tt().getChildren(), n = e.length;
  if (n > 1) return !1;
  for (let r = 0; r < n; r++) {
    const o = e[r];
    if (nd(o)) return !1;
    if (Ae(o)) {
      if (!rd(o) || o.__indent !== 0) return !1;
      const i = o.getChildren(), s = i.length;
      for (let a = 0; a < s; a++) {
        const l = i[r];
        if (!xe(l)) return !1;
      }
    }
  }
  return !0;
}
function Dd(t) {
  return () => A_(t);
}
const em = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? xt : ie;
function S_({ editor: t, ariaActiveDescendant: e, ariaAutoComplete: n, ariaControls: r, ariaDescribedBy: o, ariaErrorMessage: i, ariaExpanded: s, ariaInvalid: a, ariaLabel: l, ariaLabelledBy: c, ariaMultiline: u, ariaOwns: p, ariaRequired: f, autoCapitalize: h, className: g, id: b, role: _ = "textbox", spellCheck: x = !0, style: y, tabIndex: A, "data-testid": P, ...V }, O) {
  const [U, B] = oe(t.isEditable()), F = ce((E) => {
    E && E.ownerDocument && E.ownerDocument.defaultView ? t.setRootElement(E) : t.setRootElement(null);
  }, [t]), K = ue(() => /* @__PURE__ */ function(...E) {
    return (S) => {
      E.forEach((k) => {
        typeof k == "function" ? k(S) : k != null && (k.current = S);
      });
    };
  }(O, F), [F, O]);
  return em(() => (B(t.isEditable()), t.registerEditableListener((E) => {
    B(E);
  })), [t]), d("div", { "aria-activedescendant": U ? e : void 0, "aria-autocomplete": U ? n : "none", "aria-controls": U ? r : void 0, "aria-describedby": o, ...i != null ? { "aria-errormessage": i } : {}, "aria-expanded": U && _ === "combobox" ? !!s : void 0, ...a != null ? { "aria-invalid": a } : {}, "aria-label": l, "aria-labelledby": c, "aria-multiline": u, "aria-owns": U ? p : void 0, "aria-readonly": !U || void 0, "aria-required": f, autoCapitalize: h, className: g, contentEditable: U, "data-testid": P, id: b, ref: K, role: _, spellCheck: x, style: y, tabIndex: A, ...V });
}
const D_ = an(S_);
function If(t) {
  return t.getEditorState().read(Dd(t.isComposing()));
}
const tm = an(M_);
function M_(t, e) {
  const { placeholder: n, ...r } = t, [o] = De();
  return M(ft, { children: [d(D_, { editor: o, ...r, ref: e }), n != null && d(O_, { editor: o, content: n })] });
}
function O_({ content: t, editor: e }) {
  const n = function(s) {
    const [a, l] = oe(() => If(s));
    return em(() => {
      function c() {
        const u = If(s);
        l(u);
      }
      return c(), Gt(s.registerUpdateListener(() => {
        c();
      }), s.registerEditableListener(() => {
        c();
      }));
    }, [s]), a;
  }(e), [r, o] = oe(e.isEditable());
  if (xt(() => (o(e.isEditable()), e.registerEditableListener((s) => {
    o(s);
  })), [e]), !n) return null;
  let i = null;
  return typeof t == "function" ? i = t(r) : t !== null && (i = t), i === null ? null : d("div", { "aria-hidden": !0, children: i });
}
function nm({ editorRef: t }) {
  const [e] = De();
  return si.useEffect(() => {
    typeof t == "function" ? t(e) : typeof t == "object" && (t.current = e);
  }, [e]), null;
}
function gu(t, e) {
  return gu = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, gu(t, e);
}
var Lf = { error: null }, R_ = function(t) {
  var e, n;
  function r() {
    for (var i, s = arguments.length, a = new Array(s), l = 0; l < s; l++) a[l] = arguments[l];
    return (i = t.call.apply(t, [this].concat(a)) || this).state = Lf, i.resetErrorBoundary = function() {
      for (var c, u = arguments.length, p = new Array(u), f = 0; f < u; f++) p[f] = arguments[f];
      i.props.onReset == null || (c = i.props).onReset.apply(c, p), i.reset();
    }, i;
  }
  n = t, (e = r).prototype = Object.create(n.prototype), e.prototype.constructor = e, gu(e, n), r.getDerivedStateFromError = function(i) {
    return { error: i };
  };
  var o = r.prototype;
  return o.reset = function() {
    this.setState(Lf);
  }, o.componentDidCatch = function(i, s) {
    var a, l;
    (a = (l = this.props).onError) == null || a.call(l, i, s);
  }, o.componentDidUpdate = function(i, s) {
    var a, l, c, u, p = this.state.error, f = this.props.resetKeys;
    p !== null && s.error !== null && ((c = i.resetKeys) === void 0 && (c = []), (u = f) === void 0 && (u = []), c.length !== u.length || c.some(function(h, g) {
      return !Object.is(h, u[g]);
    })) && ((a = (l = this.props).onResetKeysChange) == null || a.call(l, i.resetKeys, f), this.reset());
  }, o.render = function() {
    var i = this.state.error, s = this.props, a = s.fallbackRender, l = s.FallbackComponent, c = s.fallback;
    if (i !== null) {
      var u = { error: i, resetErrorBoundary: this.resetErrorBoundary };
      if (si.isValidElement(c)) return c;
      if (typeof a == "function") return a(u);
      if (l) return si.createElement(l, u);
      throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
    }
    return this.props.children;
  }, r;
}(si.Component);
function rm({ children: t, onError: e }) {
  return d(R_, { fallback: d("div", { style: { border: "1px solid #f00", color: "#f00", padding: "8px" }, children: "An error was thrown." }), onError: e, children: t });
}
const Aa = 0, mu = 1, bu = 2, Un = 0, I_ = 1, Pf = 2, L_ = 3, P_ = 4;
function $_(t, e, n, r, o) {
  if (t === null || n.size === 0 && r.size === 0 && !o) return Un;
  const i = e._selection, s = t._selection;
  if (o) return I_;
  if (!(me(i) && me(s) && s.isCollapsed() && i.isCollapsed())) return Un;
  const a = function(x, y, A) {
    const P = x._nodeMap, V = [];
    for (const O of y) {
      const U = P.get(O);
      U !== void 0 && V.push(U);
    }
    for (const [O, U] of A) {
      if (!U) continue;
      const B = P.get(O);
      B === void 0 || od(B) || V.push(B);
    }
    return V;
  }(e, n, r);
  if (a.length === 0) return Un;
  if (a.length > 1) {
    const x = e._nodeMap, y = x.get(i.anchor.key), A = x.get(s.anchor.key);
    return y && A && !t._nodeMap.has(y.__key) && xe(y) && y.__text.length === 1 && i.anchor.offset === 1 ? Pf : Un;
  }
  const l = a[0], c = t._nodeMap.get(l.__key);
  if (!xe(c) || !xe(l) || c.__mode !== l.__mode) return Un;
  const u = c.__text, p = l.__text;
  if (u === p) return Un;
  const f = i.anchor, h = s.anchor;
  if (f.key !== h.key || f.type !== "text") return Un;
  const g = f.offset, b = h.offset, _ = p.length - u.length;
  return _ === 1 && b === g - 1 ? Pf : _ === -1 && b === g + 1 ? L_ : _ === -1 && b === g ? P_ : Un;
}
function F_(t, e) {
  let n = Date.now(), r = Un;
  return (o, i, s, a, l, c) => {
    const u = Date.now();
    if (c.has(nu)) return r = Un, n = u, bu;
    const p = $_(o, i, a, l, t.isComposing()), f = (() => {
      const h = s === null || s.editor === t, g = c.has(ry);
      if (!g && h && c.has(Uo)) return Aa;
      if (o === null) return mu;
      const b = i._selection;
      return a.size > 0 || l.size > 0 ? g === !1 && p !== Un && p === r && u < n + e && h || a.size === 1 && function(_, x, y) {
        const A = x._nodeMap.get(_), P = y._nodeMap.get(_), V = x._selection, O = y._selection;
        return !(me(V) && me(O) && V.anchor.type === "element" && V.focus.type === "element" && O.anchor.type === "text" && O.focus.type === "text" || !xe(A) || !xe(P) || A.__parent !== P.__parent) && JSON.stringify(x.read(() => A.exportJSON())) === JSON.stringify(y.read(() => P.exportJSON()));
      }(Array.from(a)[0], o, i) ? Aa : mu : b !== null ? Aa : bu;
    })();
    return n = u, r = p, f;
  };
}
function $f(t) {
  t.undoStack = [], t.redoStack = [], t.current = null;
}
function B_(t, e, n) {
  const r = F_(t, n);
  return Gt(t.registerCommand(sd, () => (function(i, s) {
    const a = s.redoStack, l = s.undoStack;
    if (l.length !== 0) {
      const c = s.current, u = l.pop();
      c !== null && (a.push(c), i.dispatchCommand(os, !0)), l.length === 0 && i.dispatchCommand(is, !1), s.current = u || null, u && u.editor.setEditorState(u.editorState, { tag: nu });
    }
  }(t, e), !0), Qe), t.registerCommand(id, () => (function(i, s) {
    const a = s.redoStack, l = s.undoStack;
    if (a.length !== 0) {
      const c = s.current;
      c !== null && (l.push(c), i.dispatchCommand(is, !0));
      const u = a.pop();
      a.length === 0 && i.dispatchCommand(os, !1), s.current = u || null, u && u.editor.setEditorState(u.editorState, { tag: nu });
    }
  }(t, e), !0), Qe), t.registerCommand(bl, () => ($f(e), !1), Qe), t.registerCommand(_w, () => ($f(e), t.dispatchCommand(os, !1), t.dispatchCommand(is, !1), !0), Qe), t.registerUpdateListener(({ editorState: i, prevEditorState: s, dirtyLeaves: a, dirtyElements: l, tags: c }) => {
    const u = e.current, p = e.redoStack, f = e.undoStack, h = u === null ? null : u.editorState;
    if (u !== null && i === h) return;
    const g = r(s, i, u, a, l, c);
    if (g === mu) p.length !== 0 && (e.redoStack = [], t.dispatchCommand(os, !1)), u !== null && (f.push({ ...u }), t.dispatchCommand(is, !0));
    else if (g === bu) return;
    e.current = { editor: t, editorState: i };
  }));
}
function q_() {
  return { current: null, redoStack: [], undoStack: [] };
}
function om({ delay: t, externalHistoryState: e }) {
  const [n] = De();
  return function(r, o, i = 1e3) {
    const s = ue(() => o || q_(), [o]);
    ie(() => B_(r, s, i), [i, r, s]);
  }(n, e, t), null;
}
const j_ = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? xt : ie;
function U_(t) {
  return { initialValueFn: () => t.isEditable(), subscribe: (e) => t.registerEditableListener(e) };
}
function im() {
  return function(t) {
    const [e] = De(), n = ue(() => t(e), [e, t]), [r, o] = oe(() => n.initialValueFn()), i = he(r);
    return j_(() => {
      const { initialValueFn: s, subscribe: a } = n, l = s();
      return i.current !== l && (i.current = l, o(l)), a((c) => {
        i.current = c, o(c);
      });
    }, [n, t]), r;
  }(U_);
}
function sm(t) {
  const e = window.location.origin, n = (r) => {
    if (r.origin !== e) return;
    const o = t.getRootElement();
    if (document.activeElement !== o) return;
    const i = r.data;
    if (typeof i == "string") {
      let s;
      try {
        s = JSON.parse(i);
      } catch {
        return;
      }
      if (s && s.protocol === "nuanria_messaging" && s.type === "request") {
        const a = s.payload;
        if (a && a.functionId === "makeChanges") {
          const l = a.args;
          if (l) {
            const [c, u, p, f, h, g] = l;
            t.update(() => {
              const b = ve();
              if (me(b)) {
                const _ = b.anchor;
                let x = _.getNode(), y = 0, A = 0;
                if (xe(x) && c >= 0 && u >= 0 && (y = c, A = c + u, b.setTextNodeRange(x, y, x, A)), y === A && p === "" || (b.insertRawText(p), x = _.getNode()), xe(x)) {
                  y = f, A = f + h;
                  const P = x.getTextContentSize();
                  y = y > P ? P : y, A = A > P ? P : A, b.setTextNodeRange(x, y, x, A);
                }
                r.stopImmediatePropagation();
              }
            });
          }
        }
      }
    }
  };
  return window.addEventListener("message", n, !0), () => {
    window.removeEventListener("message", n, !0);
  };
}
const vu = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? xt : ie;
function Ff(t) {
  return t.getEditorState().read(Dd(t.isComposing()));
}
function V_({ contentEditable: t, placeholder: e = null, ErrorBoundary: n }) {
  const [r] = De(), o = function(i, s) {
    const [a, l] = oe(() => i.getDecorators());
    return vu(() => i.registerDecoratorListener((c) => {
      ad(() => {
        l(c);
      });
    }), [i]), ie(() => {
      l(i.getDecorators());
    }, [i]), ue(() => {
      const c = [], u = Object.keys(a);
      for (let p = 0; p < u.length; p++) {
        const f = u[p], h = d(s, { onError: (b) => i._onError(b), children: d(Yu, { fallback: null, children: a[f] }) }), g = i.getElementByKey(f);
        g !== null && c.push(ur(h, g, f));
      }
      return c;
    }, [s, a, i]);
  }(r, n);
  return function(i) {
    vu(() => Gt(Tw(i), sm(i)), [i]);
  }(r), M(ft, { children: [t, d(H_, { content: e }), o] });
}
function H_({ content: t }) {
  const [e] = De(), n = function(o) {
    const [i, s] = oe(() => Ff(o));
    return vu(() => {
      function a() {
        const l = Ff(o);
        s(l);
      }
      return a(), Gt(o.registerUpdateListener(() => {
        a();
      }), o.registerEditableListener(() => {
        a();
      }));
    }, [o]), i;
  }(e), r = im();
  return n ? typeof t == "function" ? t(r) : t : null;
}
const Ja = Math.min, Eo = Math.max, Xa = Math.round, Sa = Math.floor, pr = (t) => ({
  x: t,
  y: t
}), z_ = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, G_ = {
  start: "end",
  end: "start"
};
function Bf(t, e, n) {
  return Eo(t, Ja(e, n));
}
function Md(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function mi(t) {
  return t.split("-")[0];
}
function Od(t) {
  return t.split("-")[1];
}
function am(t) {
  return t === "x" ? "y" : "x";
}
function lm(t) {
  return t === "y" ? "height" : "width";
}
const K_ = /* @__PURE__ */ new Set(["top", "bottom"]);
function xo(t) {
  return K_.has(mi(t)) ? "y" : "x";
}
function cm(t) {
  return am(xo(t));
}
function W_(t, e, n) {
  n === void 0 && (n = !1);
  const r = Od(t), o = cm(t), i = lm(o);
  let s = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[i] > e.floating[i] && (s = Ya(s)), [s, Ya(s)];
}
function J_(t) {
  const e = Ya(t);
  return [yu(t), e, yu(e)];
}
function yu(t) {
  return t.replace(/start|end/g, (e) => G_[e]);
}
const qf = ["left", "right"], jf = ["right", "left"], X_ = ["top", "bottom"], Y_ = ["bottom", "top"];
function Q_(t, e, n) {
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? jf : qf : e ? qf : jf;
    case "left":
    case "right":
      return e ? X_ : Y_;
    default:
      return [];
  }
}
function Z_(t, e, n, r) {
  const o = Od(t);
  let i = Q_(mi(t), n === "start", r);
  return o && (i = i.map((s) => s + "-" + o), e && (i = i.concat(i.map(yu)))), i;
}
function Ya(t) {
  return t.replace(/left|right|bottom|top/g, (e) => z_[e]);
}
function eC(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function tC(t) {
  return typeof t != "number" ? eC(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function Qa(t) {
  const {
    x: e,
    y: n,
    width: r,
    height: o
  } = t;
  return {
    width: r,
    height: o,
    top: n,
    left: e,
    right: e + r,
    bottom: n + o,
    x: e,
    y: n
  };
}
function Uf(t, e, n) {
  let {
    reference: r,
    floating: o
  } = t;
  const i = xo(e), s = cm(e), a = lm(s), l = mi(e), c = i === "y", u = r.x + r.width / 2 - o.width / 2, p = r.y + r.height / 2 - o.height / 2, f = r[a] / 2 - o[a] / 2;
  let h;
  switch (l) {
    case "top":
      h = {
        x: u,
        y: r.y - o.height
      };
      break;
    case "bottom":
      h = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: p
      };
      break;
    case "left":
      h = {
        x: r.x - o.width,
        y: p
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (Od(e)) {
    case "start":
      h[s] -= f * (n && c ? -1 : 1);
      break;
    case "end":
      h[s] += f * (n && c ? -1 : 1);
      break;
  }
  return h;
}
const nC = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: i = [],
    platform: s
  } = n, a = i.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let c = await s.getElementRects({
    reference: t,
    floating: e,
    strategy: o
  }), {
    x: u,
    y: p
  } = Uf(c, r, l), f = r, h = {}, g = 0;
  for (let b = 0; b < a.length; b++) {
    const {
      name: _,
      fn: x
    } = a[b], {
      x: y,
      y: A,
      data: P,
      reset: V
    } = await x({
      x: u,
      y: p,
      initialPlacement: r,
      placement: f,
      strategy: o,
      middlewareData: h,
      rects: c,
      platform: s,
      elements: {
        reference: t,
        floating: e
      }
    });
    u = y ?? u, p = A ?? p, h = {
      ...h,
      [_]: {
        ...h[_],
        ...P
      }
    }, V && g <= 50 && (g++, typeof V == "object" && (V.placement && (f = V.placement), V.rects && (c = V.rects === !0 ? await s.getElementRects({
      reference: t,
      floating: e,
      strategy: o
    }) : V.rects), {
      x: u,
      y: p
    } = Uf(c, f, l)), b = -1);
  }
  return {
    x: u,
    y: p,
    placement: f,
    strategy: o,
    middlewareData: h
  };
};
async function um(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: o,
    platform: i,
    rects: s,
    elements: a,
    strategy: l
  } = t, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: p = "floating",
    altBoundary: f = !1,
    padding: h = 0
  } = Md(e, t), g = tC(h), _ = a[f ? p === "floating" ? "reference" : "floating" : p], x = Qa(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(_))) == null || n ? _ : _.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), y = p === "floating" ? {
    x: r,
    y: o,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, A = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), P = await (i.isElement == null ? void 0 : i.isElement(A)) ? await (i.getScale == null ? void 0 : i.getScale(A)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, V = Qa(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: y,
    offsetParent: A,
    strategy: l
  }) : y);
  return {
    top: (x.top - V.top + g.top) / P.y,
    bottom: (V.bottom - x.bottom + g.bottom) / P.y,
    left: (x.left - V.left + g.left) / P.x,
    right: (V.right - x.right + g.right) / P.x
  };
}
const rC = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: o,
        middlewareData: i,
        rects: s,
        initialPlacement: a,
        platform: l,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: p = !0,
        fallbackPlacements: f,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: b = !0,
        ..._
      } = Md(t, e);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const x = mi(o), y = xo(a), A = mi(a) === a, P = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), V = f || (A || !b ? [Ya(a)] : J_(a)), O = g !== "none";
      !f && O && V.push(...Z_(a, b, g, P));
      const U = [a, ...V], B = await um(e, _), F = [];
      let K = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (u && F.push(B[x]), p) {
        const I = W_(o, s, P);
        F.push(B[I[0]], B[I[1]]);
      }
      if (K = [...K, {
        placement: o,
        overflows: F
      }], !F.every((I) => I <= 0)) {
        var E, S;
        const I = (((E = i.flip) == null ? void 0 : E.index) || 0) + 1, N = U[I];
        if (N && (!(p === "alignment" ? y !== xo(N) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        K.every((L) => xo(L.placement) === y ? L.overflows[0] > 0 : !0)))
          return {
            data: {
              index: I,
              overflows: K
            },
            reset: {
              placement: N
            }
          };
        let T = (S = K.filter(($) => $.overflows[0] <= 0).sort(($, L) => $.overflows[1] - L.overflows[1])[0]) == null ? void 0 : S.placement;
        if (!T)
          switch (h) {
            case "bestFit": {
              var k;
              const $ = (k = K.filter((L) => {
                if (O) {
                  const J = xo(L.placement);
                  return J === y || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  J === "y";
                }
                return !0;
              }).map((L) => [L.placement, L.overflows.filter((J) => J > 0).reduce((J, G) => J + G, 0)]).sort((L, J) => L[1] - J[1])[0]) == null ? void 0 : k[0];
              $ && (T = $);
              break;
            }
            case "initialPlacement":
              T = a;
              break;
          }
        if (o !== T)
          return {
            reset: {
              placement: T
            }
          };
      }
      return {};
    }
  };
}, oC = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: o
      } = e, {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: a = {
          fn: (_) => {
            let {
              x,
              y
            } = _;
            return {
              x,
              y
            };
          }
        },
        ...l
      } = Md(t, e), c = {
        x: n,
        y: r
      }, u = await um(e, l), p = xo(mi(o)), f = am(p);
      let h = c[f], g = c[p];
      if (i) {
        const _ = f === "y" ? "top" : "left", x = f === "y" ? "bottom" : "right", y = h + u[_], A = h - u[x];
        h = Bf(y, h, A);
      }
      if (s) {
        const _ = p === "y" ? "top" : "left", x = p === "y" ? "bottom" : "right", y = g + u[_], A = g - u[x];
        g = Bf(y, g, A);
      }
      const b = a.fn({
        ...e,
        [f]: h,
        [p]: g
      });
      return {
        ...b,
        data: {
          x: b.x - n,
          y: b.y - r,
          enabled: {
            [f]: i,
            [p]: s
          }
        }
      };
    }
  };
};
function Pl() {
  return typeof window < "u";
}
function Fi(t) {
  return dm(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function An(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function yr(t) {
  var e;
  return (e = (dm(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function dm(t) {
  return Pl() ? t instanceof Node || t instanceof An(t).Node : !1;
}
function Wn(t) {
  return Pl() ? t instanceof Element || t instanceof An(t).Element : !1;
}
function gr(t) {
  return Pl() ? t instanceof HTMLElement || t instanceof An(t).HTMLElement : !1;
}
function Vf(t) {
  return !Pl() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof An(t).ShadowRoot;
}
const iC = /* @__PURE__ */ new Set(["inline", "contents"]);
function Xs(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: o
  } = Jn(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !iC.has(o);
}
const sC = /* @__PURE__ */ new Set(["table", "td", "th"]);
function aC(t) {
  return sC.has(Fi(t));
}
const lC = [":popover-open", ":modal"];
function $l(t) {
  return lC.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const cC = ["transform", "translate", "scale", "rotate", "perspective"], uC = ["transform", "translate", "scale", "rotate", "perspective", "filter"], dC = ["paint", "layout", "strict", "content"];
function Rd(t) {
  const e = Id(), n = Wn(t) ? Jn(t) : t;
  return cC.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || uC.some((r) => (n.willChange || "").includes(r)) || dC.some((r) => (n.contain || "").includes(r));
}
function pC(t) {
  let e = Jr(t);
  for (; gr(e) && !bi(e); ) {
    if (Rd(e))
      return e;
    if ($l(e))
      return null;
    e = Jr(e);
  }
  return null;
}
function Id() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const fC = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function bi(t) {
  return fC.has(Fi(t));
}
function Jn(t) {
  return An(t).getComputedStyle(t);
}
function Fl(t) {
  return Wn(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function Jr(t) {
  if (Fi(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Vf(t) && t.host || // Fallback.
    yr(t)
  );
  return Vf(e) ? e.host : e;
}
function pm(t) {
  const e = Jr(t);
  return bi(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : gr(e) && Xs(e) ? e : pm(e);
}
function As(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const o = pm(t), i = o === ((r = t.ownerDocument) == null ? void 0 : r.body), s = An(o);
  if (i) {
    const a = xu(s);
    return e.concat(s, s.visualViewport || [], Xs(o) ? o : [], a && n ? As(a) : []);
  }
  return e.concat(o, As(o, [], n));
}
function xu(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function fm(t) {
  const e = Jn(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const o = gr(t), i = o ? t.offsetWidth : n, s = o ? t.offsetHeight : r, a = Xa(n) !== i || Xa(r) !== s;
  return a && (n = i, r = s), {
    width: n,
    height: r,
    $: a
  };
}
function Ld(t) {
  return Wn(t) ? t : t.contextElement;
}
function ci(t) {
  const e = Ld(t);
  if (!gr(e))
    return pr(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i
  } = fm(e);
  let s = (i ? Xa(n.width) : n.width) / r, a = (i ? Xa(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const hC = /* @__PURE__ */ pr(0);
function hm(t) {
  const e = An(t);
  return !Id() || !e.visualViewport ? hC : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function wC(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== An(t) ? !1 : e;
}
function Do(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const o = t.getBoundingClientRect(), i = Ld(t);
  let s = pr(1);
  e && (r ? Wn(r) && (s = ci(r)) : s = ci(t));
  const a = wC(i, n, r) ? hm(i) : pr(0);
  let l = (o.left + a.x) / s.x, c = (o.top + a.y) / s.y, u = o.width / s.x, p = o.height / s.y;
  if (i) {
    const f = An(i), h = r && Wn(r) ? An(r) : r;
    let g = f, b = xu(g);
    for (; b && r && h !== g; ) {
      const _ = ci(b), x = b.getBoundingClientRect(), y = Jn(b), A = x.left + (b.clientLeft + parseFloat(y.paddingLeft)) * _.x, P = x.top + (b.clientTop + parseFloat(y.paddingTop)) * _.y;
      l *= _.x, c *= _.y, u *= _.x, p *= _.y, l += A, c += P, g = An(b), b = xu(g);
    }
  }
  return Qa({
    width: u,
    height: p,
    x: l,
    y: c
  });
}
function Bl(t, e) {
  const n = Fl(t).scrollLeft;
  return e ? e.left + n : Do(yr(t)).left + n;
}
function wm(t, e) {
  const n = t.getBoundingClientRect(), r = n.left + e.scrollLeft - Bl(t, n), o = n.top + e.scrollTop;
  return {
    x: r,
    y: o
  };
}
function gC(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: r,
    strategy: o
  } = t;
  const i = o === "fixed", s = yr(r), a = e ? $l(e.floating) : !1;
  if (r === s || a && i)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = pr(1);
  const u = pr(0), p = gr(r);
  if ((p || !p && !i) && ((Fi(r) !== "body" || Xs(s)) && (l = Fl(r)), gr(r))) {
    const h = Do(r);
    c = ci(r), u.x = h.x + r.clientLeft, u.y = h.y + r.clientTop;
  }
  const f = s && !p && !i ? wm(s, l) : pr(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x + f.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y + f.y
  };
}
function mC(t) {
  return Array.from(t.getClientRects());
}
function bC(t) {
  const e = yr(t), n = Fl(t), r = t.ownerDocument.body, o = Eo(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), i = Eo(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + Bl(t);
  const a = -n.scrollTop;
  return Jn(r).direction === "rtl" && (s += Eo(e.clientWidth, r.clientWidth) - o), {
    width: o,
    height: i,
    x: s,
    y: a
  };
}
const Hf = 25;
function vC(t, e) {
  const n = An(t), r = yr(t), o = n.visualViewport;
  let i = r.clientWidth, s = r.clientHeight, a = 0, l = 0;
  if (o) {
    i = o.width, s = o.height;
    const u = Id();
    (!u || u && e === "fixed") && (a = o.offsetLeft, l = o.offsetTop);
  }
  const c = Bl(r);
  if (c <= 0) {
    const u = r.ownerDocument, p = u.body, f = getComputedStyle(p), h = u.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, g = Math.abs(r.clientWidth - p.clientWidth - h);
    g <= Hf && (i -= g);
  } else c <= Hf && (i += c);
  return {
    width: i,
    height: s,
    x: a,
    y: l
  };
}
const yC = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function xC(t, e) {
  const n = Do(t, !0, e === "fixed"), r = n.top + t.clientTop, o = n.left + t.clientLeft, i = gr(t) ? ci(t) : pr(1), s = t.clientWidth * i.x, a = t.clientHeight * i.y, l = o * i.x, c = r * i.y;
  return {
    width: s,
    height: a,
    x: l,
    y: c
  };
}
function zf(t, e, n) {
  let r;
  if (e === "viewport")
    r = vC(t, n);
  else if (e === "document")
    r = bC(yr(t));
  else if (Wn(e))
    r = xC(e, n);
  else {
    const o = hm(t);
    r = {
      x: e.x - o.x,
      y: e.y - o.y,
      width: e.width,
      height: e.height
    };
  }
  return Qa(r);
}
function gm(t, e) {
  const n = Jr(t);
  return n === e || !Wn(n) || bi(n) ? !1 : Jn(n).position === "fixed" || gm(n, e);
}
function _C(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let r = As(t, [], !1).filter((a) => Wn(a) && Fi(a) !== "body"), o = null;
  const i = Jn(t).position === "fixed";
  let s = i ? Jr(t) : t;
  for (; Wn(s) && !bi(s); ) {
    const a = Jn(s), l = Rd(s);
    !l && a.position === "fixed" && (o = null), (i ? !l && !o : !l && a.position === "static" && !!o && yC.has(o.position) || Xs(s) && !l && gm(t, s)) ? r = r.filter((u) => u !== s) : o = a, s = Jr(s);
  }
  return e.set(t, r), r;
}
function CC(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = t;
  const s = [...n === "clippingAncestors" ? $l(e) ? [] : _C(e, this._c) : [].concat(n), r], a = s[0], l = s.reduce((c, u) => {
    const p = zf(e, u, o);
    return c.top = Eo(p.top, c.top), c.right = Ja(p.right, c.right), c.bottom = Ja(p.bottom, c.bottom), c.left = Eo(p.left, c.left), c;
  }, zf(e, a, o));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function EC(t) {
  const {
    width: e,
    height: n
  } = fm(t);
  return {
    width: e,
    height: n
  };
}
function kC(t, e, n) {
  const r = gr(e), o = yr(e), i = n === "fixed", s = Do(t, !0, i, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = pr(0);
  function c() {
    l.x = Bl(o);
  }
  if (r || !r && !i)
    if ((Fi(e) !== "body" || Xs(o)) && (a = Fl(e)), r) {
      const h = Do(e, !0, i, e);
      l.x = h.x + e.clientLeft, l.y = h.y + e.clientTop;
    } else o && c();
  i && !r && o && c();
  const u = o && !r && !i ? wm(o, a) : pr(0), p = s.left + a.scrollLeft - l.x - u.x, f = s.top + a.scrollTop - l.y - u.y;
  return {
    x: p,
    y: f,
    width: s.width,
    height: s.height
  };
}
function Sc(t) {
  return Jn(t).position === "static";
}
function Gf(t, e) {
  if (!gr(t) || Jn(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return yr(t) === n && (n = n.ownerDocument.body), n;
}
function mm(t, e) {
  const n = An(t);
  if ($l(t))
    return n;
  if (!gr(t)) {
    let o = Jr(t);
    for (; o && !bi(o); ) {
      if (Wn(o) && !Sc(o))
        return o;
      o = Jr(o);
    }
    return n;
  }
  let r = Gf(t, e);
  for (; r && aC(r) && Sc(r); )
    r = Gf(r, e);
  return r && bi(r) && Sc(r) && !Rd(r) ? n : r || pC(t) || n;
}
const NC = async function(t) {
  const e = this.getOffsetParent || mm, n = this.getDimensions, r = await n(t.floating);
  return {
    reference: kC(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function TC(t) {
  return Jn(t).direction === "rtl";
}
const AC = {
  convertOffsetParentRelativeRectToViewportRelativeRect: gC,
  getDocumentElement: yr,
  getClippingRect: CC,
  getOffsetParent: mm,
  getElementRects: NC,
  getClientRects: mC,
  getDimensions: EC,
  getScale: ci,
  isElement: Wn,
  isRTL: TC
};
function bm(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function SC(t, e) {
  let n = null, r;
  const o = yr(t);
  function i() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
  }
  function s(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), i();
    const c = t.getBoundingClientRect(), {
      left: u,
      top: p,
      width: f,
      height: h
    } = c;
    if (a || e(), !f || !h)
      return;
    const g = Sa(p), b = Sa(o.clientWidth - (u + f)), _ = Sa(o.clientHeight - (p + h)), x = Sa(u), A = {
      rootMargin: -g + "px " + -b + "px " + -_ + "px " + -x + "px",
      threshold: Eo(0, Ja(1, l)) || 1
    };
    let P = !0;
    function V(O) {
      const U = O[0].intersectionRatio;
      if (U !== l) {
        if (!P)
          return s();
        U ? s(!1, U) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      U === 1 && !bm(c, t.getBoundingClientRect()) && s(), P = !1;
    }
    try {
      n = new IntersectionObserver(V, {
        ...A,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(V, A);
    }
    n.observe(t);
  }
  return s(!0), i;
}
function DC(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, c = Ld(t), u = o || i ? [...c ? As(c) : [], ...As(e)] : [];
  u.forEach((x) => {
    o && x.addEventListener("scroll", n, {
      passive: !0
    }), i && x.addEventListener("resize", n);
  });
  const p = c && a ? SC(c, n) : null;
  let f = -1, h = null;
  s && (h = new ResizeObserver((x) => {
    let [y] = x;
    y && y.target === c && h && (h.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var A;
      (A = h) == null || A.observe(e);
    })), n();
  }), c && !l && h.observe(c), h.observe(e));
  let g, b = l ? Do(t) : null;
  l && _();
  function _() {
    const x = Do(t);
    b && !bm(b, x) && n(), b = x, g = requestAnimationFrame(_);
  }
  return n(), () => {
    var x;
    u.forEach((y) => {
      o && y.removeEventListener("scroll", n), i && y.removeEventListener("resize", n);
    }), p == null || p(), (x = h) == null || x.disconnect(), h = null, l && cancelAnimationFrame(g);
  };
}
const MC = oC, OC = rC, RC = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: AC,
    ...n
  }, i = {
    ...o.platform,
    _c: r
  };
  return nC(t, e, {
    ...o,
    platform: i
  });
}, _u = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, IC = _u ? xt : ie;
let LC = class {
  constructor(e) {
    this.key = e, this.ref = { current: null }, this.setRefElement = this.setRefElement.bind(this);
  }
  setRefElement(e) {
    this.ref = { current: e };
  }
};
const Kf = (t) => {
  const e = document.getElementById("typeahead-menu");
  if (!e) return;
  const n = e.getBoundingClientRect();
  n.top + n.height > window.innerHeight && e.scrollIntoView({ block: "center" }), n.top < 0 && e.scrollIntoView({ block: "center" }), t.scrollIntoView({ block: "nearest" });
};
function Wf(t, e) {
  const n = t.getBoundingClientRect(), r = e.getBoundingClientRect();
  return n.top > r.top && n.top < r.bottom;
}
function PC(t, e, n, r) {
  const [o] = De();
  ie(() => {
    if (e != null && t != null) {
      const i = o.getRootElement(), s = i != null ? function(p, f) {
        let h = getComputedStyle(p);
        const g = h.position === "absolute", b = /(auto|scroll)/;
        if (h.position === "fixed") return document.body;
        for (let _ = p; _ = _.parentElement; ) if (h = getComputedStyle(_), (!g || h.position !== "static") && b.test(h.overflow + h.overflowY + h.overflowX)) return _;
        return document.body;
      }(i) : document.body;
      let a = !1, l = Wf(e, s);
      const c = function() {
        a || (window.requestAnimationFrame(function() {
          n(), a = !1;
        }), a = !0);
        const p = Wf(e, s);
        p !== l && (l = p, r != null && r(p));
      }, u = new ResizeObserver(n);
      return window.addEventListener("resize", n), document.addEventListener("scroll", c, { capture: !0, passive: !0 }), u.observe(e), () => {
        u.unobserve(e), window.removeEventListener("resize", n), document.removeEventListener("scroll", c, !0);
      };
    }
  }, [e, o, r, n, t]);
}
const Jf = Di("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
function $C({ close: t, editor: e, anchorElementRef: n, resolution: r, options: o, menuRenderFn: i, onSelectOption: s, shouldSplitNodeWithQuery: a = !1, commandPriority: l = to, preselectFirstItem: c = !0 }) {
  const [u, p] = oe(null), f = r.match && r.match.matchingString;
  ie(() => {
    c && p(0);
  }, [f, c]);
  const h = ce((b) => {
    e.update(() => {
      const _ = r.match != null && a ? function(x) {
        const y = ve();
        if (!me(y) || !y.isCollapsed()) return null;
        const A = y.anchor;
        if (A.type !== "text") return null;
        const P = A.getNode();
        if (!P.isSimpleText()) return null;
        const V = A.offset, O = P.getTextContent().slice(0, V), U = x.replaceableString.length, B = V - function(K, E, S) {
          let k = S;
          for (let I = k; I <= E.length; I++) K.slice(-I) === E.substring(0, I) && (k = I);
          return k;
        }(O, x.matchingString, U);
        if (B < 0) return null;
        let F;
        return B === 0 ? [F] = P.splitText(V) : [, F] = P.splitText(B, V), F;
      }(r.match) : null;
      s(b, _, t, r.match ? r.match.matchingString : "");
    });
  }, [e, a, r.match, s, t]), g = ce((b) => {
    const _ = e.getRootElement();
    _ !== null && (_.setAttribute("aria-activedescendant", "typeahead-item-" + b), p(b));
  }, [e]);
  return ie(() => () => {
    const b = e.getRootElement();
    b !== null && b.removeAttribute("aria-activedescendant");
  }, [e]), IC(() => {
    o === null ? p(null) : u === null && c && g(0);
  }, [o, u, g, c]), ie(() => Gt(e.registerCommand(Jf, ({ option: b }) => !(!b.ref || b.ref.current == null) && (Kf(b.ref.current), !0), l)), [e, g, l]), ie(() => Gt(e.registerCommand(iy, (b) => {
    const _ = b;
    if (o !== null && o.length) {
      const x = u === null ? 0 : u !== o.length - 1 ? u + 1 : 0;
      g(x);
      const y = o[x];
      y.ref != null && y.ref.current && e.dispatchCommand(Jf, { index: x, option: y }), _.preventDefault(), _.stopImmediatePropagation();
    }
    return !0;
  }, l), e.registerCommand(oy, (b) => {
    const _ = b;
    if (o !== null && o.length) {
      const x = u === null ? o.length - 1 : u !== 0 ? u - 1 : o.length - 1;
      g(x);
      const y = o[x];
      y.ref != null && y.ref.current && Kf(y.ref.current), _.preventDefault(), _.stopImmediatePropagation();
    }
    return !0;
  }, l), e.registerCommand(Ew, (b) => {
    const _ = b;
    return _.preventDefault(), _.stopImmediatePropagation(), t(), !0;
  }, l), e.registerCommand(gw, (b) => {
    const _ = b;
    return o !== null && u !== null && o[u] != null && (_.preventDefault(), _.stopImmediatePropagation(), h(o[u]), !0);
  }, l), e.registerCommand(Cw, (b) => o !== null && u !== null && o[u] != null && (b !== null && (b.preventDefault(), b.stopImmediatePropagation()), h(o[u]), !0), l)), [h, t, e, o, u, g, l]), i(n, ue(() => ({ options: o, selectOptionAndCleanUp: h, selectedIndex: u, setHighlightedIndex: p }), [h, u, o]), r.match ? r.match.matchingString : "");
}
function Xf(t, e) {
  e != null && (t.className = e), t.setAttribute("aria-label", "Typeahead menu"), t.setAttribute("role", "listbox"), t.style.display = "block", t.style.position = "absolute";
}
function FC({ options: t, onWillOpen: e, onClose: n, onOpen: r, onSelectOption: o, menuRenderFn: i, anchorClassName: s, commandPriority: a = to, parent: l }) {
  const [c] = De(), [u, p] = oe(null), f = si.useRef(null), h = function(y, A, P, V = _u ? document.body : void 0, O = !0) {
    const [U] = De(), B = _u ? document.createElement("div") : null, F = he(B), K = ce(() => {
      if (F.current === null || V === void 0) return;
      F.current.style.top = F.current.style.bottom;
      const S = U.getRootElement(), k = F.current, I = k.firstChild;
      if (S !== null && y !== null) {
        const { left: N, top: T, width: $, height: L } = y.getRect(), J = F.current.offsetHeight;
        if (k.style.top = `${T + J + 3 + (O ? window.pageYOffset : 0)}px`, k.style.left = `${N + window.pageXOffset}px`, k.style.height = `${L}px`, k.style.width = `${$}px`, I !== null) {
          I.style.top = `${T}`;
          const G = I.getBoundingClientRect(), W = G.height, ee = G.width, te = S.getBoundingClientRect();
          N + ee > te.right && (k.style.left = `${te.right - ee + window.pageXOffset}px`), (T + W > window.innerHeight || T + W > te.bottom) && T - te.top > W + L && (k.style.top = `${T - W - L + (O ? window.pageYOffset : 0)}px`);
        }
        k.isConnected || (Xf(k, P), V.append(k)), k.setAttribute("id", "typeahead-menu"), S.setAttribute("aria-controls", "typeahead-menu");
      }
    }, [U, y, O, P, V]);
    ie(() => {
      const S = U.getRootElement();
      return y !== null && K(), () => {
        S !== null && S.removeAttribute("aria-controls");
        const k = F.current;
        k !== null && k.isConnected && (k.remove(), k.removeAttribute("id"));
      };
    }, [U, K, y]);
    const E = ce((S) => {
      y !== null && (S || A(null));
    }, [y, A]);
    return PC(y, F.current, K, E), B != null && B === F.current && (Xf(B, P), V != null && V.append(B)), F;
  }(u, p, s, l), g = ce(() => {
    p(null), n != null && u !== null && n();
  }, [n, u]), b = ce((y) => {
    p(y), r != null && u === null && r(y);
  }, [r, u]), _ = ce((y) => {
    y.preventDefault(), e != null && e(y);
    const A = x1(y.target);
    b({ getRect: () => new DOMRect(y.clientX / A, y.clientY / A, 1, 1) });
  }, [b, e]), x = ce((y) => {
    u !== null && f.current != null && y.target != null && ww(y.target) && !f.current.contains(y.target) && g();
  }, [g, u]);
  return ie(() => {
    const y = c.getRootElement();
    if (y) return y.addEventListener("contextmenu", _), () => y.removeEventListener("contextmenu", _);
  }, [c, _]), ie(() => (document.addEventListener("click", x), () => document.removeEventListener("click", x)), [c, x]), h.current === null || u === null || c === null ? null : d($C, { close: g, resolution: u, editor: c, anchorElementRef: h, options: t, menuRenderFn: (y, A) => i(y, A, { setMenuRef: (P) => {
    f.current = P;
  } }), onSelectOption: o, commandPriority: a });
}
function BC({ defaultSelection: t }) {
  const [e] = De();
  return ie(() => {
    e.focus(() => {
      const n = document.activeElement, r = e.getRootElement();
      r === null || n !== null && r.contains(n) || r.focus({ preventScroll: !0 });
    }, { defaultSelection: t });
  }, [t, e]), null;
}
const qC = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? xt : ie;
function jC({ onClear: t }) {
  const [e] = De();
  return qC(() => e.registerCommand(bl, (n) => (e.update(() => {
    if (t == null) {
      const r = tt(), o = ve(), i = js();
      r.clear(), r.append(i), o !== null && i.select(), me(o) && (o.format = 0);
    } else t();
  }), !0), Qe), [e, t]), null;
}
const Yf = [["Cat", "rgb(125, 50, 0)"], ["Dog", "rgb(100, 0, 0)"], ["Rabbit", "rgb(150, 0, 0)"], ["Frog", "rgb(200, 0, 0)"], ["Fox", "rgb(200, 75, 0)"], ["Hedgehog", "rgb(0, 75, 0)"], ["Pigeon", "rgb(0, 125, 0)"], ["Squirrel", "rgb(75, 100, 0)"], ["Bear", "rgb(125, 100, 0)"], ["Tiger", "rgb(0, 0, 150)"], ["Leopard", "rgb(0, 0, 200)"], ["Zebra", "rgb(0, 0, 250)"], ["Wolf", "rgb(0, 100, 150)"], ["Owl", "rgb(0, 100, 100)"], ["Gull", "rgb(100, 0, 100)"], ["Squid", "rgb(150, 0, 150)"]], Qf = Yf[Math.floor(Math.random() * Yf.length)], UC = Zr({ clientID: 0, color: Qf[1], isCollabActive: !1, name: Qf[0], yjsDocMap: /* @__PURE__ */ new Map() });
function vm(t, e) {
  return jo(UC);
}
const VC = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? xt : ie;
function HC({ ignoreHistoryMergeTagChange: t = !0, ignoreSelectionChange: e = !1, onChange: n }) {
  const [r] = De();
  return VC(() => {
    if (n) return r.registerUpdateListener(({ editorState: o, dirtyElements: i, dirtyLeaves: s, prevEditorState: a, tags: l }) => {
      e && i.size === 0 && s.size === 0 || t && l.has(Uo) || a.isEmpty() || n(o, r, l);
    });
  }, [r, t, e, n]), null;
}
function zC(t, ...e) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", t);
  for (const o of e) r.append("v", o);
  throw n.search = r.toString(), Error(`Minified Lexical error #${t}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function GC(t, e = ve()) {
  return e == null && zC(166), me(e) && e.isCollapsed() || e.getNodes().length === 0 ? "" : qg(t, e);
}
function Zf(t, e) {
  const n = t.getData("text/plain") || t.getData("text/uri-list");
  n != null && e.insertRawText(n);
}
const Bi = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, KC = Bi && "documentMode" in document ? document.documentMode : null, WC = !(!Bi || !("InputEvent" in window) || KC) && "getTargetRanges" in new window.InputEvent("input"), JC = Bi && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), eh = Bi && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, XC = Bi && /^(?=.*Chrome).*/i.test(navigator.userAgent), YC = Bi && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !XC;
function th(t, e) {
  e.update(() => {
    if (t !== null) {
      const n = Ig(t, KeyboardEvent) ? null : t.clipboardData, r = ve();
      if (r !== null && n != null) {
        t.preventDefault();
        const o = GC(e);
        o !== null && n.setData("text/html", o), n.setData("text/plain", r.getTextContent());
      }
    }
  });
}
function QC(t) {
  return Gt(t.registerCommand(mc, (e) => {
    const n = ve();
    return !!me(n) && (n.deleteCharacter(e), !0);
  }, Qe), t.registerCommand(by, (e) => {
    const n = ve();
    return !!me(n) && (n.deleteWord(e), !0);
  }, Qe), t.registerCommand(my, (e) => {
    const n = ve();
    return !!me(n) && (n.deleteLine(e), !0);
  }, Qe), t.registerCommand(gy, (e) => {
    const n = ve();
    if (!me(n)) return !1;
    if (typeof e == "string") n.insertText(e);
    else {
      const r = e.dataTransfer;
      if (r != null) Zf(r, n);
      else {
        const o = e.data;
        o && n.insertText(o);
      }
    }
    return !0;
  }, Qe), t.registerCommand(wy, () => {
    const e = ve();
    return !!me(e) && (e.removeText(), !0);
  }, Qe), t.registerCommand(Dp, (e) => {
    const n = ve();
    return !!me(n) && (n.insertLineBreak(e), !0);
  }, Qe), t.registerCommand(hy, () => {
    const e = ve();
    return !!me(e) && (e.insertLineBreak(), !0);
  }, Qe), t.registerCommand(fy, (e) => {
    const n = ve();
    if (!me(n)) return !1;
    const r = e, o = r.shiftKey;
    return !!cf(n, !0) && (r.preventDefault(), uf(n, o, !0), !0);
  }, Qe), t.registerCommand(py, (e) => {
    const n = ve();
    if (!me(n)) return !1;
    const r = e, o = r.shiftKey;
    return !!cf(n, !1) && (r.preventDefault(), uf(n, o, !1), !0);
  }, Qe), t.registerCommand(dy, (e) => {
    const n = ve();
    return !!me(n) && (!eh || navigator.language !== "ko-KR") && (e.preventDefault(), t.dispatchCommand(mc, !0));
  }, Qe), t.registerCommand(uy, (e) => {
    const n = ve();
    return !!me(n) && (e.preventDefault(), t.dispatchCommand(mc, !1));
  }, Qe), t.registerCommand(Cw, (e) => {
    const n = ve();
    if (!me(n)) return !1;
    if (e !== null) {
      if ((eh || JC || YC) && WC) return !1;
      e.preventDefault();
    }
    return t.dispatchCommand(Dp, !1);
  }, Qe), t.registerCommand(ly, () => (cy(), !0), Qe), t.registerCommand(_l, (e) => {
    const n = ve();
    return !!me(n) && (th(e, t), !0);
  }, Qe), t.registerCommand(xl, (e) => {
    const n = ve();
    return !!me(n) && (function(r, o) {
      th(r, o), o.update(() => {
        const i = ve();
        me(i) && i.removeText();
      });
    }(e, t), !0);
  }, Qe), t.registerCommand(yl, (e) => {
    const n = ve();
    return !!me(n) && (function(r, o) {
      r.preventDefault(), o.update(() => {
        const i = ve(), s = Ig(r, ClipboardEvent) ? r.clipboardData : null;
        s != null && me(i) && Zf(s, i);
      }, { tag: ay });
    }(e, t), !0);
  }, Qe), t.registerCommand(kw, (e) => {
    const n = ve();
    return !!me(n) && (e.preventDefault(), !0);
  }, Qe), t.registerCommand(sy, (e) => {
    const n = ve();
    return !!me(n) && (e.preventDefault(), !0);
  }, Qe));
}
const Cu = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? xt : ie;
function nh(t) {
  return t.getEditorState().read(Dd(t.isComposing()));
}
function ZC({ contentEditable: t, placeholder: e = null, ErrorBoundary: n }) {
  const [r] = De(), o = function(i, s) {
    const [a, l] = oe(() => i.getDecorators());
    return Cu(() => i.registerDecoratorListener((c) => {
      ad(() => {
        l(c);
      });
    }), [i]), ie(() => {
      l(i.getDecorators());
    }, [i]), ue(() => {
      const c = [], u = Object.keys(a);
      for (let p = 0; p < u.length; p++) {
        const f = u[p], h = d(s, { onError: (b) => i._onError(b), children: d(Yu, { fallback: null, children: a[f] }) }), g = i.getElementByKey(f);
        g !== null && c.push(ur(h, g, f));
      }
      return c;
    }, [s, a, i]);
  }(r, n);
  return function(i) {
    Cu(() => Gt(QC(i), sm(i)), [i]);
  }(r), M(ft, { children: [t, d(eE, { content: e }), o] });
}
function eE({ content: t }) {
  const [e] = De(), n = function(o) {
    const [i, s] = oe(() => nh(o));
    return Cu(() => {
      function a() {
        const l = nh(o);
        s(l);
      }
      return a(), Gt(o.registerUpdateListener(() => {
        a();
      }), o.registerEditableListener(() => {
        a();
      }));
    }, [o]), i;
  }(e), r = im();
  return n ? typeof t == "function" ? t(r) : t : null;
}
const fr = () => /* @__PURE__ */ new Map(), Eu = (t) => {
  const e = fr();
  return t.forEach((n, r) => {
    e.set(r, n);
  }), e;
}, qi = (t, e, n) => {
  let r = t.get(e);
  return r === void 0 && t.set(e, r = n()), r;
}, tE = (t, e) => {
  const n = [];
  for (const [r, o] of t)
    n.push(e(o, r));
  return n;
}, nE = (t, e) => {
  for (const [n, r] of t)
    if (e(r, n))
      return !0;
  return !1;
}, vi = () => /* @__PURE__ */ new Set(), Dc = (t) => t[t.length - 1], yi = Array.from, rE = Array.isArray;
class oE {
  constructor() {
    this._observers = fr();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(e, n) {
    return qi(
      this._observers,
      /** @type {string} */
      e,
      vi
    ).add(n), n;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(e, n) {
    const r = (...o) => {
      this.off(
        e,
        /** @type {any} */
        r
      ), n(...o);
    };
    this.on(
      e,
      /** @type {any} */
      r
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(e, n) {
    const r = this._observers.get(e);
    r !== void 0 && (r.delete(n), r.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(e, n) {
    return yi((this._observers.get(e) || fr()).values()).forEach((r) => r(...n));
  }
  destroy() {
    this._observers = fr();
  }
}
const Mo = Math.floor, Ba = Math.abs, ym = (t, e) => t < e ? t : e, ji = (t, e) => t > e ? t : e, iE = (t) => t !== 0 ? t < 0 : 1 / t < 0, rh = 1, oh = 2, Mc = 4, Oc = 8, sE = 32, xm = 64, Za = 128, aE = 31, ih = 63, gs = 127, lE = 2147483647, cE = Number.isInteger || ((t) => typeof t == "number" && isFinite(t) && Mo(t) === t), uE = (t) => t.toLowerCase(), dE = /^\s*/g, pE = (t) => t.replace(dE, ""), fE = /([A-Z])/g, sh = (t, e) => pE(t.replace(fE, (n) => `${e}${uE(n)}`)), hE = (t) => {
  const e = unescape(encodeURIComponent(t)), n = e.length, r = new Uint8Array(n);
  for (let o = 0; o < n; o++)
    r[o] = /** @type {number} */
    e.codePointAt(o);
  return r;
}, Ss = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), wE = (t) => Ss.encode(t), gE = Ss ? wE : hE;
let Rc = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
Rc && Rc.decode(new Uint8Array()).length === 1 && (Rc = null);
class Ys {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const Pd = () => new Ys(), mE = (t) => {
  let e = t.cpos;
  for (let n = 0; n < t.bufs.length; n++)
    e += t.bufs[n].length;
  return e;
}, Ar = (t) => {
  const e = new Uint8Array(mE(t));
  let n = 0;
  for (let r = 0; r < t.bufs.length; r++) {
    const o = t.bufs[r];
    e.set(o, n), n += o.length;
  }
  return e.set(new Uint8Array(t.cbuf.buffer, 0, t.cpos), n), e;
}, bE = (t, e) => {
  const n = t.cbuf.length;
  n - t.cpos < e && (t.bufs.push(new Uint8Array(t.cbuf.buffer, 0, t.cpos)), t.cbuf = new Uint8Array(ji(n, e) * 2), t.cpos = 0);
}, It = (t, e) => {
  const n = t.cbuf.length;
  t.cpos === n && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(n * 2), t.cpos = 0), t.cbuf[t.cpos++] = e;
}, ku = It, Ye = (t, e) => {
  for (; e > gs; )
    It(t, Za | gs & e), e = Mo(e / 128);
  It(t, gs & e);
}, $d = (t, e) => {
  const n = iE(e);
  for (n && (e = -e), It(t, (e > ih ? Za : 0) | (n ? xm : 0) | ih & e), e = Mo(e / 64); e > 0; )
    It(t, (e > gs ? Za : 0) | gs & e), e = Mo(e / 128);
}, Nu = new Uint8Array(3e4), vE = Nu.length / 3, yE = (t, e) => {
  if (e.length < vE) {
    const n = Ss.encodeInto(e, Nu).written || 0;
    Ye(t, n);
    for (let r = 0; r < n; r++)
      It(t, Nu[r]);
  } else
    Tn(t, gE(e));
}, xE = (t, e) => {
  const n = unescape(encodeURIComponent(e)), r = n.length;
  Ye(t, r);
  for (let o = 0; o < r; o++)
    It(
      t,
      /** @type {number} */
      n.codePointAt(o)
    );
}, ui = Ss && /** @type {any} */
Ss.encodeInto ? yE : xE, Fd = (t, e) => {
  const n = t.cbuf.length, r = t.cpos, o = ym(n - r, e.length), i = e.length - o;
  t.cbuf.set(e.subarray(0, o), r), t.cpos += o, i > 0 && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(ji(n * 2, i)), t.cbuf.set(e.subarray(o)), t.cpos = i);
}, Tn = (t, e) => {
  Ye(t, e.byteLength), Fd(t, e);
}, Bd = (t, e) => {
  bE(t, e);
  const n = new DataView(t.cbuf.buffer, t.cpos, e);
  return t.cpos += e, n;
}, _E = (t, e) => Bd(t, 4).setFloat32(0, e, !1), CE = (t, e) => Bd(t, 8).setFloat64(0, e, !1), EE = (t, e) => (
  /** @type {any} */
  Bd(t, 8).setBigInt64(0, e, !1)
), ah = new DataView(new ArrayBuffer(4)), kE = (t) => (ah.setFloat32(0, t), ah.getFloat32(0) === t), Ds = (t, e) => {
  switch (typeof e) {
    case "string":
      It(t, 119), ui(t, e);
      break;
    case "number":
      cE(e) && Ba(e) <= lE ? (It(t, 125), $d(t, e)) : kE(e) ? (It(t, 124), _E(t, e)) : (It(t, 123), CE(t, e));
      break;
    case "bigint":
      It(t, 122), EE(t, e);
      break;
    case "object":
      if (e === null)
        It(t, 126);
      else if (rE(e)) {
        It(t, 117), Ye(t, e.length);
        for (let n = 0; n < e.length; n++)
          Ds(t, e[n]);
      } else if (e instanceof Uint8Array)
        It(t, 116), Tn(t, e);
      else {
        It(t, 118);
        const n = Object.keys(e);
        Ye(t, n.length);
        for (let r = 0; r < n.length; r++) {
          const o = n[r];
          ui(t, o), Ds(t, e[o]);
        }
      }
      break;
    case "boolean":
      It(t, e ? 120 : 121);
      break;
    default:
      It(t, 127);
  }
};
class lh extends Ys {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(e) {
    super(), this.w = e, this.s = null, this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(e) {
    this.s === e ? this.count++ : (this.count > 0 && Ye(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e);
  }
}
const ch = (t) => {
  t.count > 0 && ($d(t.encoder, t.count === 1 ? t.s : -t.s), t.count > 1 && Ye(t.encoder, t.count - 2));
};
class qa {
  constructor() {
    this.encoder = new Ys(), this.s = 0, this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.s === e ? this.count++ : (ch(this), this.count = 1, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return ch(this), Ar(this.encoder);
  }
}
const uh = (t) => {
  if (t.count > 0) {
    const e = t.diff * 2 + (t.count === 1 ? 0 : 1);
    $d(t.encoder, e), t.count > 1 && Ye(t.encoder, t.count - 2);
  }
};
class Ic {
  constructor() {
    this.encoder = new Ys(), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.diff === e - this.s ? (this.s = e, this.count++) : (uh(this), this.count = 1, this.diff = e - this.s, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return uh(this), Ar(this.encoder);
  }
}
class NE {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new qa();
  }
  /**
   * @param {string} string
   */
  write(e) {
    this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length);
  }
  toUint8Array() {
    const e = new Ys();
    return this.sarr.push(this.s), this.s = "", ui(e, this.sarr.join("")), Fd(e, this.lensE.toUint8Array()), Ar(e);
  }
}
const xi = (t) => new Error(t), hr = () => {
  throw xi("Method unimplemented");
}, Oo = () => {
  throw xi("Unexpected case");
}, TE = crypto.getRandomValues.bind(crypto), _m = () => TE(new Uint32Array(1))[0], AE = "10000000-1000-4000-8000" + -1e11, SE = () => AE.replace(
  /[018]/g,
  /** @param {number} c */
  (t) => (t ^ _m() & 15 >> t / 4).toString(16)
), dh = (t) => (
  /** @type {Promise<T>} */
  new Promise(t)
);
Promise.all.bind(Promise);
const ph = (t) => t === void 0 ? null : t;
class DE {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, n) {
    this.map.set(e, n);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}
let Cm = new DE(), ME = !0;
try {
  typeof localStorage < "u" && localStorage && (Cm = localStorage, ME = !1);
} catch {
}
const OE = Cm, RE = Object.assign, IE = Object.keys, LE = (t, e) => {
  for (const n in t)
    e(t[n], n);
}, fh = (t) => IE(t).length, PE = (t) => {
  for (const e in t)
    return !1;
  return !0;
}, $E = (t, e) => {
  for (const n in t)
    if (!e(t[n], n))
      return !1;
  return !0;
}, FE = (t, e) => Object.prototype.hasOwnProperty.call(t, e), BE = (t, e) => t === e || fh(t) === fh(e) && $E(t, (n, r) => (n !== void 0 || FE(e, r)) && e[r] === n), qE = Object.freeze, Em = (t) => {
  for (const e in t) {
    const n = t[e];
    (typeof n == "object" || typeof n == "function") && Em(t[e]);
  }
  return qE(t);
}, qd = (t, e, n = 0) => {
  try {
    for (; n < t.length; n++)
      t[n](...e);
  } finally {
    n < t.length && qd(t, e, n + 1);
  }
}, jE = (t, e) => e.includes(t), Ms = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
let ir;
const UE = () => {
  if (ir === void 0)
    if (Ms) {
      ir = fr();
      const t = process.argv;
      let e = null;
      for (let n = 0; n < t.length; n++) {
        const r = t[n];
        r[0] === "-" ? (e !== null && ir.set(e, ""), e = r) : e !== null && (ir.set(e, r), e = null);
      }
      e !== null && ir.set(e, "");
    } else typeof location == "object" ? (ir = fr(), (location.search || "?").slice(1).split("&").forEach((t) => {
      if (t.length !== 0) {
        const [e, n] = t.split("=");
        ir.set(`--${sh(e, "-")}`, n), ir.set(`-${sh(e, "-")}`, n);
      }
    })) : ir = fr();
  return ir;
}, Tu = (t) => UE().has(t), el = (t) => ph(Ms ? process.env[t.toUpperCase().replaceAll("-", "_")] : OE.getItem(t)), km = (t) => Tu("--" + t) || el(t) !== null;
km("production");
const VE = Ms && jE(process.env.FORCE_COLOR, ["true", "1", "2"]), HE = VE || !Tu("--no-colors") && // @todo deprecate --no-colors
!km("no-color") && (!Ms || process.stdout.isTTY) && (!Ms || Tu("--color") || el("COLORTERM") !== null || (el("TERM") || "").includes("color"));
class zE {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(e, n) {
    this.left = e, this.right = n;
  }
}
const Er = (t, e) => new zE(t, e);
typeof DOMParser < "u" && new DOMParser();
const GE = (t) => tE(t, (e, n) => `${n}:${e};`).join(""), Ir = Symbol, Nm = Ir(), Tm = Ir(), KE = Ir(), WE = Ir(), JE = Ir(), Am = Ir(), XE = Ir(), jd = Ir(), YE = Ir(), QE = (t) => {
  var o;
  t.length === 1 && ((o = t[0]) == null ? void 0 : o.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [], n = [];
  let r = 0;
  for (; r < t.length; r++) {
    const i = t[r];
    if (i === void 0)
      break;
    if (i.constructor === String || i.constructor === Number)
      e.push(i);
    else if (i.constructor === Object)
      break;
  }
  for (r > 0 && n.push(e.join("")); r < t.length; r++) {
    const i = t[r];
    i instanceof Symbol || n.push(i);
  }
  return n;
}, ZE = {
  [Nm]: Er("font-weight", "bold"),
  [Tm]: Er("font-weight", "normal"),
  [KE]: Er("color", "blue"),
  [JE]: Er("color", "green"),
  [WE]: Er("color", "grey"),
  [Am]: Er("color", "red"),
  [XE]: Er("color", "purple"),
  [jd]: Er("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [YE]: Er("color", "black")
}, ek = (t) => {
  var s;
  t.length === 1 && ((s = t[0]) == null ? void 0 : s.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [], n = [], r = fr();
  let o = [], i = 0;
  for (; i < t.length; i++) {
    const a = t[i], l = ZE[a];
    if (l !== void 0)
      r.set(l.left, l.right);
    else {
      if (a === void 0)
        break;
      if (a.constructor === String || a.constructor === Number) {
        const c = GE(r);
        i > 0 || c.length > 0 ? (e.push("%c" + a), n.push(c)) : e.push(a);
      } else
        break;
    }
  }
  for (i > 0 && (o = n, o.unshift(e.join(""))); i < t.length; i++) {
    const a = t[i];
    a instanceof Symbol || o.push(a);
  }
  return o;
}, Sm = HE ? ek : QE, tk = (...t) => {
  console.log(...Sm(t)), Dm.forEach((e) => e.print(t));
}, nk = (...t) => {
  console.warn(...Sm(t)), t.unshift(jd), Dm.forEach((e) => e.print(t));
}, Dm = vi(), Mm = (t) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: t
}), rk = (t, e) => Mm(() => {
  let n;
  do
    n = t.next();
  while (!n.done && !e(n.value));
  return n;
}), Lc = (t, e) => Mm(() => {
  const { done: n, value: r } = t.next();
  return { done: n, value: n ? void 0 : e(r) };
});
class ok {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(e, n) {
    this.clock = e, this.len = n;
  }
}
class ik {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const Om = (t, e, n) => e.clients.forEach((r, o) => {
  const i = (
    /** @type {Array<GC|Item>} */
    t.doc.store.clients.get(o)
  );
  if (i != null) {
    const s = i[i.length - 1], a = s.id.clock + s.length;
    for (let l = 0, c = r[l]; l < r.length && c.clock < a; c = r[++l])
      Bm(t, i, c.clock, c.len, n);
  }
}), sk = (t, e) => {
  let n = 0, r = t.length - 1;
  for (; n <= r; ) {
    const o = Mo((n + r) / 2), i = t[o], s = i.clock;
    if (s <= e) {
      if (e < s + i.len)
        return o;
      n = o + 1;
    } else
      r = o - 1;
  }
  return null;
}, Rm = (t, e) => {
  const n = t.clients.get(e.client);
  return n !== void 0 && sk(n, e.clock) !== null;
}, Im = (t) => {
  t.clients.forEach((e) => {
    e.sort((o, i) => o.clock - i.clock);
    let n, r;
    for (n = 1, r = 1; n < e.length; n++) {
      const o = e[r - 1], i = e[n];
      o.clock + o.len >= i.clock ? o.len = ji(o.len, i.clock + i.len - o.clock) : (r < n && (e[r] = i), r++);
    }
    e.length = r;
  });
}, Lm = (t, e, n, r) => {
  qi(t.clients, e, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new ok(n, r));
}, ak = (t, e) => {
  Ye(t.restEncoder, e.clients.size), yi(e.clients.entries()).sort((n, r) => r[0] - n[0]).forEach(([n, r]) => {
    t.resetDsCurVal(), Ye(t.restEncoder, n);
    const o = r.length;
    Ye(t.restEncoder, o);
    for (let i = 0; i < o; i++) {
      const s = r[i];
      t.writeDsClock(s.clock), t.writeDsLen(s.len);
    }
  });
}, Pm = _m;
class Qs extends oE {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid: e = SE(), collectionid: n = null, gc: r = !0, gcFilter: o = () => !0, meta: i = null, autoLoad: s = !1, shouldLoad: a = !0 } = {}) {
    super(), this.gc = r, this.gcFilter = o, this.clientID = Pm(), this.guid = e, this.collectionid = n, this.share = /* @__PURE__ */ new Map(), this.store = new mk(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = a, this.autoLoad = s, this.meta = i, this.isLoaded = !1, this.isSynced = !1, this.isDestroyed = !1, this.whenLoaded = dh((c) => {
      this.on("load", () => {
        this.isLoaded = !0, c(this);
      });
    });
    const l = () => dh((c) => {
      const u = (p) => {
        (p === void 0 || p === !0) && (this.off("sync", u), c());
      };
      this.on("sync", u);
    });
    this.on("sync", (c) => {
      c === !1 && this.isSynced && (this.whenSynced = l()), this.isSynced = c === void 0 || c === !0, this.isSynced && !this.isLoaded && this.emit("load", [this]);
    }), this.whenSynced = l();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const e = this._item;
    e !== null && !this.shouldLoad && rt(
      /** @type {any} */
      e.parent.doc,
      (n) => {
        n.subdocsLoaded.add(this);
      },
      null,
      !0
    ), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(yi(this.subdocs).map((e) => e.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(e, n = null) {
    return rt(this, e, n);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(e, n = (
    /** @type {any} */
    Ht
  )) {
    const r = qi(this.share, e, () => {
      const i = new n();
      return i._integrate(this, null), i;
    }), o = r.constructor;
    if (n !== Ht && o !== n)
      if (o === Ht) {
        const i = new n();
        i._map = r._map, r._map.forEach(
          /** @param {Item?} n */
          (s) => {
            for (; s !== null; s = s.left)
              s.parent = i;
          }
        ), i._start = r._start;
        for (let s = i._start; s !== null; s = s.right)
          s.parent = i;
        return i._length = r._length, this.share.set(e, i), i._integrate(this, null), /** @type {InstanceType<Type>} */
        i;
      } else
        throw new Error(`Type with the name ${e} has already been defined with a different constructor`);
    return (
      /** @type {InstanceType<Type>} */
      r
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(e = "") {
    return (
      /** @type {YArray<T>} */
      this.get(e, ko)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(e = "") {
    return this.get(e, rl);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(e = "") {
    return (
      /** @type {YMap<T>} */
      this.get(e, _i)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(e = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(e, Is)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(e = "") {
    return this.get(e, Ci);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const e = {};
    return this.share.forEach((n, r) => {
      e[r] = n.toJSON();
    }), e;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    this.isDestroyed = !0, yi(this.subdocs).forEach((n) => n.destroy());
    const e = this._item;
    if (e !== null) {
      this._item = null;
      const n = (
        /** @type {ContentDoc} */
        e.content
      );
      n.doc = new Qs({ guid: this.guid, ...n.opts, shouldLoad: !1 }), n.doc._item = e, rt(
        /** @type {any} */
        e.parent.doc,
        (r) => {
          const o = n.doc;
          e.deleted || r.subdocsAdded.add(o), r.subdocsRemoved.add(this);
        },
        null,
        !0
      );
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
}
class lk {
  constructor() {
    this.restEncoder = Pd();
  }
  toUint8Array() {
    return Ar(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    Ye(this.restEncoder, e);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    Ye(this.restEncoder, e);
  }
}
class ck extends lk {
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    Ye(this.restEncoder, e.client), Ye(this.restEncoder, e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    Ye(this.restEncoder, e.client), Ye(this.restEncoder, e.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(e) {
    Ye(this.restEncoder, e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    ku(this.restEncoder, e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    ui(this.restEncoder, e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    Ye(this.restEncoder, e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    Ye(this.restEncoder, e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    Ye(this.restEncoder, e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    Ds(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    Tn(this.restEncoder, e);
  }
  /**
   * @param {any} embed
   */
  writeJSON(e) {
    ui(this.restEncoder, JSON.stringify(e));
  }
  /**
   * @param {string} key
   */
  writeKey(e) {
    ui(this.restEncoder, e);
  }
}
class uk {
  constructor() {
    this.restEncoder = Pd(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return Ar(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    const n = e - this.dsCurrVal;
    this.dsCurrVal = e, Ye(this.restEncoder, n);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    e === 0 && Oo(), Ye(this.restEncoder, e - 1), this.dsCurrVal += e;
  }
}
class dk extends uk {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new Ic(), this.clientEncoder = new qa(), this.leftClockEncoder = new Ic(), this.rightClockEncoder = new Ic(), this.infoEncoder = new lh(ku), this.stringEncoder = new NE(), this.parentInfoEncoder = new lh(ku), this.typeRefEncoder = new qa(), this.lenEncoder = new qa();
  }
  toUint8Array() {
    const e = Pd();
    return Ye(e, 0), Tn(e, this.keyClockEncoder.toUint8Array()), Tn(e, this.clientEncoder.toUint8Array()), Tn(e, this.leftClockEncoder.toUint8Array()), Tn(e, this.rightClockEncoder.toUint8Array()), Tn(e, Ar(this.infoEncoder)), Tn(e, this.stringEncoder.toUint8Array()), Tn(e, Ar(this.parentInfoEncoder)), Tn(e, this.typeRefEncoder.toUint8Array()), Tn(e, this.lenEncoder.toUint8Array()), Fd(e, Ar(this.restEncoder)), Ar(e);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(e) {
    this.clientEncoder.write(e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    this.infoEncoder.write(e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    this.stringEncoder.write(e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    this.parentInfoEncoder.write(e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    this.typeRefEncoder.write(e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    this.lenEncoder.write(e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    Ds(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    Tn(this.restEncoder, e);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(e) {
    Ds(this.restEncoder, e);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(e) {
    const n = this.keyMap.get(e);
    n === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(n);
  }
}
const pk = (t, e, n, r) => {
  r = ji(r, e[0].id.clock);
  const o = Sr(e, r);
  Ye(t.restEncoder, e.length - o), t.writeClient(n), Ye(t.restEncoder, r);
  const i = e[o];
  i.write(t, r - i.id.clock);
  for (let s = o + 1; s < e.length; s++)
    e[s].write(t, 0);
}, fk = (t, e, n) => {
  const r = /* @__PURE__ */ new Map();
  n.forEach((o, i) => {
    fn(e, i) > o && r.set(i, o);
  }), Ud(e).forEach((o, i) => {
    n.has(i) || r.set(i, 0);
  }), Ye(t.restEncoder, r.size), yi(r.entries()).sort((o, i) => i[0] - o[0]).forEach(([o, i]) => {
    pk(
      t,
      /** @type {Array<GC|Item>} */
      e.clients.get(o),
      o,
      i
    );
  });
}, hk = (t, e) => fk(t, e.doc.store, e.beforeState);
class wk {
  constructor() {
    this.l = [];
  }
}
const hh = () => new wk(), wh = (t, e) => t.l.push(e), gh = (t, e) => {
  const n = t.l, r = n.length;
  t.l = n.filter((o) => e !== o), r === t.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, $m = (t, e, n) => qd(t.l, [e, n]);
class ja {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(e, n) {
    this.client = e, this.clock = n;
  }
}
const Da = (t, e) => t === e || t !== null && e !== null && t.client === e.client && t.clock === e.clock, bt = (t, e) => new ja(t, e), gk = (t) => {
  for (const [e, n] of t.doc.share.entries())
    if (n === t)
      return e;
  throw Oo();
}, oi = (t, e) => e === void 0 ? !t.deleted : e.sv.has(t.id.client) && (e.sv.get(t.id.client) || 0) > t.id.clock && !Rm(e.ds, t.id), Au = (t, e) => {
  const n = qi(t.meta, Au, vi), r = t.doc.store;
  n.has(e) || (e.sv.forEach((o, i) => {
    o < fn(r, i) && Xr(t, bt(i, o));
  }), Om(t, e.ds, (o) => {
  }), n.add(e));
};
class mk {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const Ud = (t) => {
  const e = /* @__PURE__ */ new Map();
  return t.clients.forEach((n, r) => {
    const o = n[n.length - 1];
    e.set(r, o.id.clock + o.length);
  }), e;
}, fn = (t, e) => {
  const n = t.clients.get(e);
  if (n === void 0)
    return 0;
  const r = n[n.length - 1];
  return r.id.clock + r.length;
}, Fm = (t, e) => {
  let n = t.clients.get(e.id.client);
  if (n === void 0)
    n = [], t.clients.set(e.id.client, n);
  else {
    const r = n[n.length - 1];
    if (r.id.clock + r.length !== e.id.clock)
      throw Oo();
  }
  n.push(e);
}, Sr = (t, e) => {
  let n = 0, r = t.length - 1, o = t[r], i = o.id.clock;
  if (i === e)
    return r;
  let s = Mo(e / (i + o.length - 1) * r);
  for (; n <= r; ) {
    if (o = t[s], i = o.id.clock, i <= e) {
      if (e < i + o.length)
        return s;
      n = s + 1;
    } else
      r = s - 1;
    s = Mo((n + r) / 2);
  }
  throw Oo();
}, bk = (t, e) => {
  const n = t.clients.get(e.client);
  return n[Sr(n, e.clock)];
}, Pc = (
  /** @type {function(StructStore,ID):Item} */
  bk
), Su = (t, e, n) => {
  const r = Sr(e, n), o = e[r];
  return o.id.clock < n && o instanceof Xt ? (e.splice(r + 1, 0, ob(t, o, n - o.id.clock)), r + 1) : r;
}, Xr = (t, e) => {
  const n = (
    /** @type {Array<Item>} */
    t.doc.store.clients.get(e.client)
  );
  return n[Su(t, n, e.clock)];
}, mh = (t, e, n) => {
  const r = e.clients.get(n.client), o = Sr(r, n.clock), i = r[o];
  return n.clock !== i.id.clock + i.length - 1 && i.constructor !== jr && r.splice(o + 1, 0, ob(t, i, n.clock - i.id.clock + 1)), i;
}, vk = (t, e, n) => {
  const r = (
    /** @type {Array<GC|Item>} */
    t.clients.get(e.id.client)
  );
  r[Sr(r, e.id.clock)] = n;
}, Bm = (t, e, n, r, o) => {
  if (r === 0)
    return;
  const i = n + r;
  let s = Su(t, e, n), a;
  do
    a = e[s++], i < a.id.clock + a.length && Su(t, e, i), o(a);
  while (s < e.length && e[s].id.clock < i);
};
class yk {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(e, n, r) {
    this.doc = e, this.deleteSet = new ik(), this.beforeState = Ud(e.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = n, this.meta = /* @__PURE__ */ new Map(), this.local = r, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const bh = (t, e) => e.deleteSet.clients.size === 0 && !nE(e.afterState, (n, r) => e.beforeState.get(r) !== n) ? !1 : (Im(e.deleteSet), hk(t, e), ak(t, e.deleteSet), !0), vh = (t, e, n) => {
  const r = e._item;
  (r === null || r.id.clock < (t.beforeState.get(r.id.client) || 0) && !r.deleted) && qi(t.changed, e, vi).add(n);
}, Ua = (t, e) => {
  let n = t[e], r = t[e - 1], o = e;
  for (; o > 0; n = r, r = t[--o - 1]) {
    if (r.deleted === n.deleted && r.constructor === n.constructor && r.mergeWith(n)) {
      n instanceof Xt && n.parentSub !== null && /** @type {AbstractType<any>} */
      n.parent._map.get(n.parentSub) === n && n.parent._map.set(
        n.parentSub,
        /** @type {Item} */
        r
      );
      continue;
    }
    break;
  }
  const i = e - o;
  return i && t.splice(e + 1 - i, i), i;
}, xk = (t, e, n) => {
  for (const [r, o] of t.clients.entries()) {
    const i = (
      /** @type {Array<GC|Item>} */
      e.clients.get(r)
    );
    for (let s = o.length - 1; s >= 0; s--) {
      const a = o[s], l = a.clock + a.len;
      for (let c = Sr(i, a.clock), u = i[c]; c < i.length && u.id.clock < l; u = i[++c]) {
        const p = i[c];
        if (a.clock + a.len <= p.id.clock)
          break;
        p instanceof Xt && p.deleted && !p.keep && n(p) && p.gc(e, !1);
      }
    }
  }
}, _k = (t, e) => {
  t.clients.forEach((n, r) => {
    const o = (
      /** @type {Array<GC|Item>} */
      e.clients.get(r)
    );
    for (let i = n.length - 1; i >= 0; i--) {
      const s = n[i], a = ym(o.length - 1, 1 + Sr(o, s.clock + s.len - 1));
      for (let l = a, c = o[l]; l > 0 && c.id.clock >= s.clock; c = o[l])
        l -= 1 + Ua(o, l);
    }
  });
}, qm = (t, e) => {
  if (e < t.length) {
    const n = t[e], r = n.doc, o = r.store, i = n.deleteSet, s = n._mergeStructs;
    try {
      Im(i), n.afterState = Ud(n.doc.store), r.emit("beforeObserverCalls", [n, r]);
      const a = [];
      n.changed.forEach(
        (l, c) => a.push(() => {
          (c._item === null || !c._item.deleted) && c._callObserver(n, l);
        })
      ), a.push(() => {
        n.changedParentTypes.forEach((l, c) => {
          c._dEH.l.length > 0 && (c._item === null || !c._item.deleted) && (l = l.filter(
            (u) => u.target._item === null || !u.target._item.deleted
          ), l.forEach((u) => {
            u.currentTarget = c, u._path = null;
          }), l.sort((u, p) => u.path.length - p.path.length), $m(c._dEH, l, n));
        });
      }), a.push(() => r.emit("afterTransaction", [n, r])), qd(a, []), n._needFormattingCleanup && Rk(n);
    } finally {
      r.gc && xk(i, o, r.gcFilter), _k(i, o), n.afterState.forEach((u, p) => {
        const f = n.beforeState.get(p) || 0;
        if (f !== u) {
          const h = (
            /** @type {Array<GC|Item>} */
            o.clients.get(p)
          ), g = ji(Sr(h, f), 1);
          for (let b = h.length - 1; b >= g; )
            b -= 1 + Ua(h, b);
        }
      });
      for (let u = s.length - 1; u >= 0; u--) {
        const { client: p, clock: f } = s[u].id, h = (
          /** @type {Array<GC|Item>} */
          o.clients.get(p)
        ), g = Sr(h, f);
        g + 1 < h.length && Ua(h, g + 1) > 1 || g > 0 && Ua(h, g);
      }
      if (!n.local && n.afterState.get(r.clientID) !== n.beforeState.get(r.clientID) && (tk(jd, Nm, "[yjs] ", Tm, Am, "Changed the client-id because another client seems to be using it."), r.clientID = Pm()), r.emit("afterTransactionCleanup", [n, r]), r._observers.has("update")) {
        const u = new ck();
        bh(u, n) && r.emit("update", [u.toUint8Array(), n.origin, r, n]);
      }
      if (r._observers.has("updateV2")) {
        const u = new dk();
        bh(u, n) && r.emit("updateV2", [u.toUint8Array(), n.origin, r, n]);
      }
      const { subdocsAdded: a, subdocsLoaded: l, subdocsRemoved: c } = n;
      (a.size > 0 || c.size > 0 || l.size > 0) && (a.forEach((u) => {
        u.clientID = r.clientID, u.collectionid == null && (u.collectionid = r.collectionid), r.subdocs.add(u);
      }), c.forEach((u) => r.subdocs.delete(u)), r.emit("subdocs", [{ loaded: l, added: a, removed: c }, r, n]), c.forEach((u) => u.destroy())), t.length <= e + 1 ? (r._transactionCleanups = [], r.emit("afterAllTransactions", [r, t])) : qm(t, e + 1);
    }
  }
}, rt = (t, e, n = null, r = !0) => {
  const o = t._transactionCleanups;
  let i = !1, s = null;
  t._transaction === null && (i = !0, t._transaction = new yk(t, n, r), o.push(t._transaction), o.length === 1 && t.emit("beforeAllTransactions", [t]), t.emit("beforeTransaction", [t._transaction, t]));
  try {
    s = e(t._transaction);
  } finally {
    if (i) {
      const a = t._transaction === o[0];
      t._transaction = null, a && qm(o, 0);
    }
  }
  return s;
}, yh = "You must not compute changes after the event-handler fired.";
class ql {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(e, n) {
    this.target = e, this.currentTarget = e, this.transaction = n, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = Ck(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(e) {
    return Rm(this.transaction.deleteSet, e.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw xi(yh);
      const e = /* @__PURE__ */ new Map(), n = this.target;
      /** @type Set<string|null> */
      this.transaction.changed.get(n).forEach((o) => {
        if (o !== null) {
          const i = (
            /** @type {Item} */
            n._map.get(o)
          );
          let s, a;
          if (this.adds(i)) {
            let l = i.left;
            for (; l !== null && this.adds(l); )
              l = l.left;
            if (this.deletes(i))
              if (l !== null && this.deletes(l))
                s = "delete", a = Dc(l.content.getContent());
              else
                return;
            else
              l !== null && this.deletes(l) ? (s = "update", a = Dc(l.content.getContent())) : (s = "add", a = void 0);
          } else if (this.deletes(i))
            s = "delete", a = Dc(
              /** @type {Item} */
              i.content.getContent()
            );
          else
            return;
          e.set(o, { action: s, oldValue: a });
        }
      }), this._keys = e;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(e) {
    return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let e = this._changes;
    if (e === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw xi(yh);
      const n = this.target, r = vi(), o = vi(), i = [];
      if (e = {
        added: r,
        deleted: o,
        delta: i,
        keys: this.keys
      }, /** @type Set<string|null> */
      this.transaction.changed.get(n).has(null)) {
        let a = null;
        const l = () => {
          a && i.push(a);
        };
        for (let c = n._start; c !== null; c = c.right)
          c.deleted ? this.deletes(c) && !this.adds(c) && ((a === null || a.delete === void 0) && (l(), a = { delete: 0 }), a.delete += c.length, o.add(c)) : this.adds(c) ? ((a === null || a.insert === void 0) && (l(), a = { insert: [] }), a.insert = a.insert.concat(c.content.getContent()), r.add(c)) : ((a === null || a.retain === void 0) && (l(), a = { retain: 0 }), a.retain += c.length);
        a !== null && a.retain === void 0 && l();
      }
      this._changes = e;
    }
    return (
      /** @type {any} */
      e
    );
  }
}
const Ck = (t, e) => {
  const n = [];
  for (; e._item !== null && e !== t; ) {
    if (e._item.parentSub !== null)
      n.unshift(e._item.parentSub);
    else {
      let r = 0, o = (
        /** @type {AbstractType<any>} */
        e._item.parent._start
      );
      for (; o !== e._item && o !== null; )
        !o.deleted && o.countable && (r += o.length), o = o.right;
      n.unshift(r);
    }
    e = /** @type {AbstractType<any>} */
    e._item.parent;
  }
  return n;
}, Qt = () => {
  nk("Invalid access: Add Yjs type to a document before reading data.");
}, jm = 80;
let Vd = 0;
class Ek {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(e, n) {
    e.marker = !0, this.p = e, this.index = n, this.timestamp = Vd++;
  }
}
const kk = (t) => {
  t.timestamp = Vd++;
}, Um = (t, e, n) => {
  t.p.marker = !1, t.p = e, e.marker = !0, t.index = n, t.timestamp = Vd++;
}, Nk = (t, e, n) => {
  if (t.length >= jm) {
    const r = t.reduce((o, i) => o.timestamp < i.timestamp ? o : i);
    return Um(r, e, n), r;
  } else {
    const r = new Ek(e, n);
    return t.push(r), r;
  }
}, jl = (t, e) => {
  if (t._start === null || e === 0 || t._searchMarker === null)
    return null;
  const n = t._searchMarker.length === 0 ? null : t._searchMarker.reduce((i, s) => Ba(e - i.index) < Ba(e - s.index) ? i : s);
  let r = t._start, o = 0;
  for (n !== null && (r = n.p, o = n.index, kk(n)); r.right !== null && o < e; ) {
    if (!r.deleted && r.countable) {
      if (e < o + r.length)
        break;
      o += r.length;
    }
    r = r.right;
  }
  for (; r.left !== null && o > e; )
    r = r.left, !r.deleted && r.countable && (o -= r.length);
  for (; r.left !== null && r.left.id.client === r.id.client && r.left.id.clock + r.left.length === r.id.clock; )
    r = r.left, !r.deleted && r.countable && (o -= r.length);
  return n !== null && Ba(n.index - o) < /** @type {YText|YArray<any>} */
  r.parent.length / jm ? (Um(n, r, o), n) : Nk(t._searchMarker, r, o);
}, Os = (t, e, n) => {
  for (let r = t.length - 1; r >= 0; r--) {
    const o = t[r];
    if (n > 0) {
      let i = o.p;
      for (i.marker = !1; i && (i.deleted || !i.countable); )
        i = i.left, i && !i.deleted && i.countable && (o.index -= i.length);
      if (i === null || i.marker === !0) {
        t.splice(r, 1);
        continue;
      }
      o.p = i, i.marker = !0;
    }
    (e < o.index || n > 0 && e === o.index) && (o.index = ji(e, o.index + n));
  }
}, Ul = (t, e, n) => {
  const r = t, o = e.changedParentTypes;
  for (; qi(o, t, () => []).push(n), t._item !== null; )
    t = /** @type {AbstractType<any>} */
    t._item.parent;
  $m(r._eH, n, e);
};
class Ht {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = hh(), this._dEH = hh(), this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(e, n) {
    this.doc = e, this._item = n;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw hr();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw hr();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(e) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let e = this._start;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    !e.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(e) {
    wh(this._eH, e);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(e) {
    wh(this._dEH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(e) {
    gh(this._eH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(e) {
    gh(this._dEH, e);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const Vm = (t, e, n) => {
  t.doc ?? Qt(), e < 0 && (e = t._length + e), n < 0 && (n = t._length + n);
  let r = n - e;
  const o = [];
  let i = t._start;
  for (; i !== null && r > 0; ) {
    if (i.countable && !i.deleted) {
      const s = i.content.getContent();
      if (s.length <= e)
        e -= s.length;
      else {
        for (let a = e; a < s.length && r > 0; a++)
          o.push(s[a]), r--;
        e = 0;
      }
    }
    i = i.right;
  }
  return o;
}, Hm = (t) => {
  t.doc ?? Qt();
  const e = [];
  let n = t._start;
  for (; n !== null; ) {
    if (n.countable && !n.deleted) {
      const r = n.content.getContent();
      for (let o = 0; o < r.length; o++)
        e.push(r[o]);
    }
    n = n.right;
  }
  return e;
}, Rs = (t, e) => {
  let n = 0, r = t._start;
  for (t.doc ?? Qt(); r !== null; ) {
    if (r.countable && !r.deleted) {
      const o = r.content.getContent();
      for (let i = 0; i < o.length; i++)
        e(o[i], n++, t);
    }
    r = r.right;
  }
}, zm = (t, e) => {
  const n = [];
  return Rs(t, (r, o) => {
    n.push(e(r, o, t));
  }), n;
}, Tk = (t) => {
  let e = t._start, n = null, r = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (n === null) {
        for (; e !== null && e.deleted; )
          e = e.right;
        if (e === null)
          return {
            done: !0,
            value: void 0
          };
        n = e.content.getContent(), r = 0, e = e.right;
      }
      const o = n[r++];
      return n.length <= r && (n = null), {
        done: !1,
        value: o
      };
    }
  };
}, Gm = (t, e) => {
  t.doc ?? Qt();
  const n = jl(t, e);
  let r = t._start;
  for (n !== null && (r = n.p, e -= n.index); r !== null; r = r.right)
    if (!r.deleted && r.countable) {
      if (e < r.length)
        return r.content.getContent()[e];
      e -= r.length;
    }
}, tl = (t, e, n, r) => {
  let o = n;
  const i = t.doc, s = i.clientID, a = i.store, l = n === null ? e._start : n.right;
  let c = [];
  const u = () => {
    c.length > 0 && (o = new Xt(bt(s, fn(a, s)), o, o && o.lastId, l, l && l.id, e, null, new Ei(c)), o.integrate(t, 0), c = []);
  };
  r.forEach((p) => {
    if (p === null)
      c.push(p);
    else
      switch (p.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          c.push(p);
          break;
        default:
          switch (u(), p.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              o = new Xt(bt(s, fn(a, s)), o, o && o.lastId, l, l && l.id, e, null, new Vl(new Uint8Array(
                /** @type {Uint8Array} */
                p
              ))), o.integrate(t, 0);
              break;
            case Qs:
              o = new Xt(bt(s, fn(a, s)), o, o && o.lastId, l, l && l.id, e, null, new Hl(
                /** @type {Doc} */
                p
              )), o.integrate(t, 0);
              break;
            default:
              if (p instanceof Ht)
                o = new Xt(bt(s, fn(a, s)), o, o && o.lastId, l, l && l.id, e, null, new so(p)), o.integrate(t, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), u();
}, Km = () => xi("Length exceeded!"), Wm = (t, e, n, r) => {
  if (n > e._length)
    throw Km();
  if (n === 0)
    return e._searchMarker && Os(e._searchMarker, n, r.length), tl(t, e, null, r);
  const o = n, i = jl(e, n);
  let s = e._start;
  for (i !== null && (s = i.p, n -= i.index, n === 0 && (s = s.prev, n += s && s.countable && !s.deleted ? s.length : 0)); s !== null; s = s.right)
    if (!s.deleted && s.countable) {
      if (n <= s.length) {
        n < s.length && Xr(t, bt(s.id.client, s.id.clock + n));
        break;
      }
      n -= s.length;
    }
  return e._searchMarker && Os(e._searchMarker, o, r.length), tl(t, e, s, r);
}, Ak = (t, e, n) => {
  let o = (e._searchMarker || []).reduce((i, s) => s.index > i.index ? s : i, { index: 0, p: e._start }).p;
  if (o)
    for (; o.right; )
      o = o.right;
  return tl(t, e, o, n);
}, Jm = (t, e, n, r) => {
  if (r === 0)
    return;
  const o = n, i = r, s = jl(e, n);
  let a = e._start;
  for (s !== null && (a = s.p, n -= s.index); a !== null && n > 0; a = a.right)
    !a.deleted && a.countable && (n < a.length && Xr(t, bt(a.id.client, a.id.clock + n)), n -= a.length);
  for (; r > 0 && a !== null; )
    a.deleted || (r < a.length && Xr(t, bt(a.id.client, a.id.clock + r)), a.delete(t), r -= a.length), a = a.right;
  if (r > 0)
    throw Km();
  e._searchMarker && Os(
    e._searchMarker,
    o,
    -i + r
    /* in case we remove the above exception */
  );
}, nl = (t, e, n) => {
  const r = e._map.get(n);
  r !== void 0 && r.delete(t);
}, Hd = (t, e, n, r) => {
  const o = e._map.get(n) || null, i = t.doc, s = i.clientID;
  let a;
  if (r == null)
    a = new Ei([r]);
  else
    switch (r.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
      case Date:
      case BigInt:
        a = new Ei([r]);
        break;
      case Uint8Array:
        a = new Vl(
          /** @type {Uint8Array} */
          r
        );
        break;
      case Qs:
        a = new Hl(
          /** @type {Doc} */
          r
        );
        break;
      default:
        if (r instanceof Ht)
          a = new so(r);
        else
          throw new Error("Unexpected content type");
    }
  new Xt(bt(s, fn(i.store, s)), o, o && o.lastId, null, null, e, n, a).integrate(t, 0);
}, zd = (t, e) => {
  t.doc ?? Qt();
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted ? n.content.getContent()[n.length - 1] : void 0;
}, Xm = (t) => {
  const e = {};
  return t.doc ?? Qt(), t._map.forEach((n, r) => {
    n.deleted || (e[r] = n.content.getContent()[n.length - 1]);
  }), e;
}, Ym = (t, e) => {
  t.doc ?? Qt();
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted;
}, Sk = (t, e) => {
  const n = {};
  return t._map.forEach((r, o) => {
    let i = r;
    for (; i !== null && (!e.sv.has(i.id.client) || i.id.clock >= (e.sv.get(i.id.client) || 0)); )
      i = i.left;
    i !== null && oi(i, e) && (n[o] = i.content.getContent()[i.length - 1]);
  }), n;
}, Ma = (t) => (t.doc ?? Qt(), rk(
  t._map.entries(),
  /** @param {any} entry */
  (e) => !e[1].deleted
));
class Qm extends ql {
}
class ko extends Ht {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(e) {
    const n = new ko();
    return n.push(e), n;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new ko();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const e = new ko();
    return e.insert(0, this.toArray().map(
      (n) => n instanceof Ht ? (
        /** @type {typeof el} */
        n.clone()
      ) : n
    )), e;
  }
  get length() {
    return this.doc ?? Qt(), this._length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n), Ul(this, e, new Qm(this, e));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? rt(this.doc, (r) => {
      Wm(
        r,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(e) {
    this.doc !== null ? rt(this.doc, (n) => {
      Ak(
        n,
        this,
        /** @type {any} */
        e
      );
    }) : this._prelimContent.push(...e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? rt(this.doc, (r) => {
      Jm(r, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(e) {
    return Gm(this, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return Hm(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(e = 0, n = this.length) {
    return Vm(this, e, n);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((e) => e instanceof Ht ? e.toJSON() : e);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(e) {
    return zm(
      this,
      /** @type {any} */
      e
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    Rs(this, e);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return Tk(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(Bk);
  }
}
class Dk extends ql {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(e, n, r) {
    super(e, n), this.keysChanged = r;
  }
}
class _i extends Ht {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(e) {
    super(), this._prelimContent = null, e === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(e);
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this._prelimContent.forEach((r, o) => {
      this.set(o, r);
    }), this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new _i();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const e = new _i();
    return this.forEach((n, r) => {
      e.set(r, n instanceof Ht ? (
        /** @type {typeof value} */
        n.clone()
      ) : n);
    }), e;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    Ul(this, e, new Dk(this, e, n));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    this.doc ?? Qt();
    const e = {};
    return this._map.forEach((n, r) => {
      if (!n.deleted) {
        const o = n.content.getContent()[n.length - 1];
        e[r] = o instanceof Ht ? o.toJSON() : o;
      }
    }), e;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...Ma(this)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return Lc(
      Ma(this),
      /** @param {any} v */
      (e) => e[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return Lc(
      Ma(this),
      /** @param {any} v */
      (e) => e[1].content.getContent()[e[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return Lc(
      Ma(this),
      /** @param {any} v */
      (e) => (
        /** @type {any} */
        [e[0], e[1].content.getContent()[e[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    this.doc ?? Qt(), this._map.forEach((n, r) => {
      n.deleted || e(n.content.getContent()[n.length - 1], r, this);
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(e) {
    this.doc !== null ? rt(this.doc, (n) => {
      nl(n, this, e);
    }) : this._prelimContent.delete(e);
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(e, n) {
    return this.doc !== null ? rt(this.doc, (r) => {
      Hd(
        r,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.set(e, n), n;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(e) {
    return (
      /** @type {any} */
      zd(this, e)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(e) {
    return Ym(this, e);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    this.doc !== null ? rt(this.doc, (e) => {
      this.forEach(function(n, r, o) {
        nl(e, o, r);
      });
    }) : this._prelimContent.clear();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(qk);
  }
}
const Hr = (t, e) => t === e || typeof t == "object" && typeof e == "object" && t && e && BE(t, e);
class Du {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(e, n, r, o) {
    this.left = e, this.right = n, this.index = r, this.currentAttributes = o;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    switch (this.right === null && Oo(), this.right.content.constructor) {
      case Pt:
        this.right.deleted || Ui(
          this.currentAttributes,
          /** @type {ContentFormat} */
          this.right.content
        );
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const xh = (t, e, n) => {
  for (; e.right !== null && n > 0; ) {
    switch (e.right.content.constructor) {
      case Pt:
        e.right.deleted || Ui(
          e.currentAttributes,
          /** @type {ContentFormat} */
          e.right.content
        );
        break;
      default:
        e.right.deleted || (n < e.right.length && Xr(t, bt(e.right.id.client, e.right.id.clock + n)), e.index += e.right.length, n -= e.right.length);
        break;
    }
    e.left = e.right, e.right = e.right.right;
  }
  return e;
}, Oa = (t, e, n, r) => {
  const o = /* @__PURE__ */ new Map(), i = r ? jl(e, n) : null;
  if (i) {
    const s = new Du(i.p.left, i.p, i.index, o);
    return xh(t, s, n - i.index);
  } else {
    const s = new Du(null, e._start, 0, o);
    return xh(t, s, n);
  }
}, Zm = (t, e, n, r) => {
  for (; n.right !== null && (n.right.deleted === !0 || n.right.content.constructor === Pt && Hr(
    r.get(
      /** @type {ContentFormat} */
      n.right.content.key
    ),
    /** @type {ContentFormat} */
    n.right.content.value
  )); )
    n.right.deleted || r.delete(
      /** @type {ContentFormat} */
      n.right.content.key
    ), n.forward();
  const o = t.doc, i = o.clientID;
  r.forEach((s, a) => {
    const l = n.left, c = n.right, u = new Xt(bt(i, fn(o.store, i)), l, l && l.lastId, c, c && c.id, e, null, new Pt(a, s));
    u.integrate(t, 0), n.right = u, n.forward();
  });
}, Ui = (t, e) => {
  const { key: n, value: r } = e;
  r === null ? t.delete(n) : t.set(n, r);
}, eb = (t, e) => {
  for (; t.right !== null; ) {
    if (!(t.right.deleted || t.right.content.constructor === Pt && Hr(
      e[
        /** @type {ContentFormat} */
        t.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      t.right.content.value
    ))) break;
    t.forward();
  }
}, tb = (t, e, n, r) => {
  const o = t.doc, i = o.clientID, s = /* @__PURE__ */ new Map();
  for (const a in r) {
    const l = r[a], c = n.currentAttributes.get(a) ?? null;
    if (!Hr(c, l)) {
      s.set(a, c);
      const { left: u, right: p } = n;
      n.right = new Xt(bt(i, fn(o.store, i)), u, u && u.lastId, p, p && p.id, e, null, new Pt(a, l)), n.right.integrate(t, 0), n.forward();
    }
  }
  return s;
}, $c = (t, e, n, r, o) => {
  n.currentAttributes.forEach((f, h) => {
    o[h] === void 0 && (o[h] = null);
  });
  const i = t.doc, s = i.clientID;
  eb(n, o);
  const a = tb(t, e, n, o), l = r.constructor === String ? new Dr(
    /** @type {string} */
    r
  ) : r instanceof Ht ? new so(r) : new Vi(r);
  let { left: c, right: u, index: p } = n;
  e._searchMarker && Os(e._searchMarker, n.index, l.getLength()), u = new Xt(bt(s, fn(i.store, s)), c, c && c.lastId, u, u && u.id, e, null, l), u.integrate(t, 0), n.right = u, n.index = p, n.forward(), Zm(t, e, n, a);
}, _h = (t, e, n, r, o) => {
  const i = t.doc, s = i.clientID;
  eb(n, o);
  const a = tb(t, e, n, o);
  e: for (; n.right !== null && (r > 0 || a.size > 0 && (n.right.deleted || n.right.content.constructor === Pt)); ) {
    if (!n.right.deleted)
      switch (n.right.content.constructor) {
        case Pt: {
          const { key: l, value: c } = (
            /** @type {ContentFormat} */
            n.right.content
          ), u = o[l];
          if (u !== void 0) {
            if (Hr(u, c))
              a.delete(l);
            else {
              if (r === 0)
                break e;
              a.set(l, c);
            }
            n.right.delete(t);
          } else
            n.currentAttributes.set(l, c);
          break;
        }
        default:
          r < n.right.length && Xr(t, bt(n.right.id.client, n.right.id.clock + r)), r -= n.right.length;
          break;
      }
    n.forward();
  }
  if (r > 0) {
    let l = "";
    for (; r > 0; r--)
      l += `
`;
    n.right = new Xt(bt(s, fn(i.store, s)), n.left, n.left && n.left.lastId, n.right, n.right && n.right.id, e, null, new Dr(l)), n.right.integrate(t, 0), n.forward();
  }
  Zm(t, e, n, a);
}, nb = (t, e, n, r, o) => {
  let i = e;
  const s = fr();
  for (; i && (!i.countable || i.deleted); ) {
    if (!i.deleted && i.content.constructor === Pt) {
      const c = (
        /** @type {ContentFormat} */
        i.content
      );
      s.set(c.key, c);
    }
    i = i.right;
  }
  let a = 0, l = !1;
  for (; e !== i; ) {
    if (n === e && (l = !0), !e.deleted) {
      const c = e.content;
      switch (c.constructor) {
        case Pt: {
          const { key: u, value: p } = (
            /** @type {ContentFormat} */
            c
          ), f = r.get(u) ?? null;
          (s.get(u) !== c || f === p) && (e.delete(t), a++, !l && (o.get(u) ?? null) === p && f !== p && (f === null ? o.delete(u) : o.set(u, f))), !l && !e.deleted && Ui(
            o,
            /** @type {ContentFormat} */
            c
          );
          break;
        }
      }
    }
    e = /** @type {Item} */
    e.right;
  }
  return a;
}, Mk = (t, e) => {
  for (; e && e.right && (e.right.deleted || !e.right.countable); )
    e = e.right;
  const n = /* @__PURE__ */ new Set();
  for (; e && (e.deleted || !e.countable); ) {
    if (!e.deleted && e.content.constructor === Pt) {
      const r = (
        /** @type {ContentFormat} */
        e.content.key
      );
      n.has(r) ? e.delete(t) : n.add(r);
    }
    e = e.left;
  }
}, Ok = (t) => {
  let e = 0;
  return rt(
    /** @type {Doc} */
    t.doc,
    (n) => {
      let r = (
        /** @type {Item} */
        t._start
      ), o = t._start, i = fr();
      const s = Eu(i);
      for (; o; ) {
        if (o.deleted === !1)
          switch (o.content.constructor) {
            case Pt:
              Ui(
                s,
                /** @type {ContentFormat} */
                o.content
              );
              break;
            default:
              e += nb(n, r, o, i, s), i = Eu(s), r = o;
              break;
          }
        o = o.right;
      }
    }
  ), e;
}, Rk = (t) => {
  const e = /* @__PURE__ */ new Set(), n = t.doc;
  for (const [r, o] of t.afterState.entries()) {
    const i = t.beforeState.get(r) || 0;
    o !== i && Bm(
      t,
      /** @type {Array<Item|GC>} */
      n.store.clients.get(r),
      i,
      o,
      (s) => {
        !s.deleted && /** @type {Item} */
        s.content.constructor === Pt && s.constructor !== jr && e.add(
          /** @type {any} */
          s.parent
        );
      }
    );
  }
  rt(n, (r) => {
    Om(t, t.deleteSet, (o) => {
      if (o instanceof jr || !/** @type {YText} */
      o.parent._hasFormatting || e.has(
        /** @type {YText} */
        o.parent
      ))
        return;
      const i = (
        /** @type {YText} */
        o.parent
      );
      o.content.constructor === Pt ? e.add(i) : Mk(r, o);
    });
    for (const o of e)
      Ok(o);
  });
}, Ch = (t, e, n) => {
  const r = n, o = Eu(e.currentAttributes), i = e.right;
  for (; n > 0 && e.right !== null; ) {
    if (e.right.deleted === !1)
      switch (e.right.content.constructor) {
        case so:
        case Vi:
        case Dr:
          n < e.right.length && Xr(t, bt(e.right.id.client, e.right.id.clock + n)), n -= e.right.length, e.right.delete(t);
          break;
      }
    e.forward();
  }
  i && nb(t, i, e.right, o, e.currentAttributes);
  const s = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (e.left || e.right).parent
  );
  return s._searchMarker && Os(s._searchMarker, e.index, -r + n), e;
};
class Ik extends ql {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(e, n, r) {
    super(e, n), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), r.forEach((o) => {
      o === null ? this.childListChanged = !0 : this.keysChanged.add(o);
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const e = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = e;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const e = (
        /** @type {Doc} */
        this.target.doc
      ), n = [];
      rt(e, (r) => {
        const o = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
        let s = this.target._start, a = null;
        const l = {};
        let c = "", u = 0, p = 0;
        const f = () => {
          if (a !== null) {
            let h = null;
            switch (a) {
              case "delete":
                p > 0 && (h = { delete: p }), p = 0;
                break;
              case "insert":
                (typeof c == "object" || c.length > 0) && (h = { insert: c }, o.size > 0 && (h.attributes = {}, o.forEach((g, b) => {
                  g !== null && (h.attributes[b] = g);
                }))), c = "";
                break;
              case "retain":
                u > 0 && (h = { retain: u }, PE(l) || (h.attributes = RE({}, l))), u = 0;
                break;
            }
            h && n.push(h), a = null;
          }
        };
        for (; s !== null; ) {
          switch (s.content.constructor) {
            case so:
            case Vi:
              this.adds(s) ? this.deletes(s) || (f(), a = "insert", c = s.content.getContent()[0], f()) : this.deletes(s) ? (a !== "delete" && (f(), a = "delete"), p += 1) : s.deleted || (a !== "retain" && (f(), a = "retain"), u += 1);
              break;
            case Dr:
              this.adds(s) ? this.deletes(s) || (a !== "insert" && (f(), a = "insert"), c += /** @type {ContentString} */
              s.content.str) : this.deletes(s) ? (a !== "delete" && (f(), a = "delete"), p += s.length) : s.deleted || (a !== "retain" && (f(), a = "retain"), u += s.length);
              break;
            case Pt: {
              const { key: h, value: g } = (
                /** @type {ContentFormat} */
                s.content
              );
              if (this.adds(s)) {
                if (!this.deletes(s)) {
                  const b = o.get(h) ?? null;
                  Hr(b, g) ? g !== null && s.delete(r) : (a === "retain" && f(), Hr(g, i.get(h) ?? null) ? delete l[h] : l[h] = g);
                }
              } else if (this.deletes(s)) {
                i.set(h, g);
                const b = o.get(h) ?? null;
                Hr(b, g) || (a === "retain" && f(), l[h] = b);
              } else if (!s.deleted) {
                i.set(h, g);
                const b = l[h];
                b !== void 0 && (Hr(b, g) ? b !== null && s.delete(r) : (a === "retain" && f(), g === null ? delete l[h] : l[h] = g));
              }
              s.deleted || (a === "insert" && f(), Ui(
                o,
                /** @type {ContentFormat} */
                s.content
              ));
              break;
            }
          }
          s = s.right;
        }
        for (f(); n.length > 0; ) {
          const h = n[n.length - 1];
          if (h.retain !== void 0 && h.attributes === void 0)
            n.pop();
          else
            break;
        }
      }), this._delta = n;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class rl extends Ht {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(e) {
    super(), this._pending = e !== void 0 ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this.doc ?? Qt(), this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n);
    try {
      this._pending.forEach((r) => r());
    } catch (r) {
      console.error(r);
    }
    this._pending = null;
  }
  _copy() {
    return new rl();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const e = new rl();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n);
    const r = new Ik(this, e, n);
    Ul(this, e, r), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    this.doc ?? Qt();
    let e = "", n = this._start;
    for (; n !== null; )
      !n.deleted && n.countable && n.content.constructor === Dr && (e += /** @type {ContentString} */
      n.content.str), n = n.right;
    return e;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {Array<any>} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(e, { sanitize: n = !0 } = {}) {
    this.doc !== null ? rt(this.doc, (r) => {
      const o = new Du(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let i = 0; i < e.length; i++) {
        const s = e[i];
        if (s.insert !== void 0) {
          const a = !n && typeof s.insert == "string" && i === e.length - 1 && o.right === null && s.insert.slice(-1) === `
` ? s.insert.slice(0, -1) : s.insert;
          (typeof a != "string" || a.length > 0) && $c(r, this, o, a, s.attributes || {});
        } else s.retain !== void 0 ? _h(r, this, o, s.retain, s.attributes || {}) : s.delete !== void 0 && Ch(r, o, s.delete);
      }
    }) : this._pending.push(() => this.applyDelta(e));
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(e, n, r) {
    this.doc ?? Qt();
    const o = [], i = /* @__PURE__ */ new Map(), s = (
      /** @type {Doc} */
      this.doc
    );
    let a = "", l = this._start;
    function c() {
      if (a.length > 0) {
        const p = {};
        let f = !1;
        i.forEach((g, b) => {
          f = !0, p[b] = g;
        });
        const h = { insert: a };
        f && (h.attributes = p), o.push(h), a = "";
      }
    }
    const u = () => {
      for (; l !== null; ) {
        if (oi(l, e) || n !== void 0 && oi(l, n))
          switch (l.content.constructor) {
            case Dr: {
              const p = i.get("ychange");
              e !== void 0 && !oi(l, e) ? (p === void 0 || p.user !== l.id.client || p.type !== "removed") && (c(), i.set("ychange", r ? r("removed", l.id) : { type: "removed" })) : n !== void 0 && !oi(l, n) ? (p === void 0 || p.user !== l.id.client || p.type !== "added") && (c(), i.set("ychange", r ? r("added", l.id) : { type: "added" })) : p !== void 0 && (c(), i.delete("ychange")), a += /** @type {ContentString} */
              l.content.str;
              break;
            }
            case so:
            case Vi: {
              c();
              const p = {
                insert: l.content.getContent()[0]
              };
              if (i.size > 0) {
                const f = (
                  /** @type {Object<string,any>} */
                  {}
                );
                p.attributes = f, i.forEach((h, g) => {
                  f[g] = h;
                });
              }
              o.push(p);
              break;
            }
            case Pt:
              oi(l, e) && (c(), Ui(
                i,
                /** @type {ContentFormat} */
                l.content
              ));
              break;
          }
        l = l.right;
      }
      c();
    };
    return e || n ? rt(s, (p) => {
      e && Au(p, e), n && Au(p, n), u();
    }, "cleanup") : u(), o;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(e, n, r) {
    if (n.length <= 0)
      return;
    const o = this.doc;
    o !== null ? rt(o, (i) => {
      const s = Oa(i, this, e, !r);
      r || (r = {}, s.currentAttributes.forEach((a, l) => {
        r[l] = a;
      })), $c(i, this, s, n, r);
    }) : this._pending.push(() => this.insert(e, n, r));
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(e, n, r) {
    const o = this.doc;
    o !== null ? rt(o, (i) => {
      const s = Oa(i, this, e, !r);
      $c(i, this, s, n, r || {});
    }) : this._pending.push(() => this.insertEmbed(e, n, r || {}));
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(e, n) {
    if (n === 0)
      return;
    const r = this.doc;
    r !== null ? rt(r, (o) => {
      Ch(o, Oa(o, this, e, !0), n);
    }) : this._pending.push(() => this.delete(e, n));
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(e, n, r) {
    if (n === 0)
      return;
    const o = this.doc;
    o !== null ? rt(o, (i) => {
      const s = Oa(i, this, e, !1);
      s.right !== null && _h(i, this, s, n, r);
    }) : this._pending.push(() => this.format(e, n, r));
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? rt(this.doc, (n) => {
      nl(n, this, e);
    }) : this._pending.push(() => this.removeAttribute(e));
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? rt(this.doc, (r) => {
      Hd(r, this, e, n);
    }) : this._pending.push(() => this.setAttribute(e, n));
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      zd(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return Xm(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(jk);
  }
}
class Fc {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(e, n = () => !0) {
    this._filter = n, this._root = e, this._currentNode = /** @type {Item} */
    e._start, this._firstCall = !0, e.doc ?? Qt();
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let e = this._currentNode, n = e && e.content && /** @type {any} */
    e.content.type;
    if (e !== null && (!this._firstCall || e.deleted || !this._filter(n)))
      do
        if (n = /** @type {any} */
        e.content.type, !e.deleted && (n.constructor === Is || n.constructor === Ci) && n._start !== null)
          e = n._start;
        else
          for (; e !== null; ) {
            const r = e.next;
            if (r !== null) {
              e = r;
              break;
            } else e.parent === this._root ? e = null : e = /** @type {AbstractType<any>} */
            e.parent._item;
          }
      while (e !== null && (e.deleted || !this._filter(
        /** @type {ContentType} */
        e.content.type
      )));
    return this._firstCall = !1, e === null ? { value: void 0, done: !0 } : (this._currentNode = e, { value: (
      /** @type {any} */
      e.content.type
    ), done: !1 });
  }
}
class Ci extends Ht {
  constructor() {
    super(), this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const e = this._first;
    return e ? e.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  _copy() {
    return new Ci();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const e = new Ci();
    return e.insert(0, this.toArray().map((n) => n instanceof Ht ? n.clone() : n)), e;
  }
  get length() {
    return this.doc ?? Qt(), this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(e) {
    return new Fc(this, e);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(e) {
    e = e.toUpperCase();
    const r = new Fc(this, (o) => o.nodeName && o.nodeName.toUpperCase() === e).next();
    return r.done ? null : r.value;
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(e) {
    return e = e.toUpperCase(), yi(new Fc(this, (n) => n.nodeName && n.nodeName.toUpperCase() === e));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    Ul(this, e, new Lk(this, n, e));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return zm(this, (e) => e.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, r) {
    const o = e.createDocumentFragment();
    return r !== void 0 && r._createAssociation(o, this), Rs(this, (i) => {
      o.insertBefore(i.toDOM(e, n, r), null);
    }), o;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? rt(this.doc, (r) => {
      Wm(r, this, e, n);
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(e, n) {
    if (this.doc !== null)
      rt(this.doc, (r) => {
        const o = e && e instanceof Ht ? e._item : e;
        tl(r, this, o, n);
      });
    else {
      const r = (
        /** @type {Array<any>} */
        this._prelimContent
      ), o = e === null ? 0 : r.findIndex((i) => i === e) + 1;
      if (o === 0 && e !== null)
        throw xi("Reference item not found");
      r.splice(o, 0, ...n);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? rt(this.doc, (r) => {
      Jm(r, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return Hm(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(e) {
    this.insert(this.length, e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(e) {
    return Gm(this, e);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(e = 0, n = this.length) {
    return Vm(this, e, n);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    Rs(this, e);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(Vk);
  }
}
class Is extends Ci {
  constructor(e = "UNDEFINED") {
    super(), this.nodeName = e, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((r, o) => {
      this.setAttribute(o, r);
    }), this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new Is(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const e = new Is(this.nodeName), n = this.getAttributes();
    return LE(n, (r, o) => {
      typeof r == "string" && e.setAttribute(o, r);
    }), e.insert(0, this.toArray().map((r) => r instanceof Ht ? r.clone() : r)), e;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const e = this.getAttributes(), n = [], r = [];
    for (const a in e)
      r.push(a);
    r.sort();
    const o = r.length;
    for (let a = 0; a < o; a++) {
      const l = r[a];
      n.push(l + '="' + e[l] + '"');
    }
    const i = this.nodeName.toLocaleLowerCase(), s = n.length > 0 ? " " + n.join(" ") : "";
    return `<${i}${s}>${super.toString()}</${i}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? rt(this.doc, (n) => {
      nl(n, this, e);
    }) : this._prelimAttrs.delete(e);
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? rt(this.doc, (r) => {
      Hd(r, this, e, n);
    }) : this._prelimAttrs.set(e, n);
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      zd(this, e)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(e) {
    return (
      /** @type {any} */
      Ym(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(e) {
    return (
      /** @type {any} */
      e ? Sk(this, e) : Xm(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, r) {
    const o = e.createElement(this.nodeName), i = this.getAttributes();
    for (const s in i) {
      const a = i[s];
      typeof a == "string" && o.setAttribute(s, a);
    }
    return Rs(this, (s) => {
      o.appendChild(s.toDOM(e, n, r));
    }), r !== void 0 && r._createAssociation(o, this), o;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(Uk), e.writeKey(this.nodeName);
  }
}
class Lk extends ql {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with which the
   *                                  change was created.
   */
  constructor(e, n, r) {
    super(e, r), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), n.forEach((o) => {
      o === null ? this.childListChanged = !0 : this.attributesChanged.add(o);
    });
  }
}
class rb {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(e, n) {
    this.id = e, this.length = n;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw hr();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} whether this merged with right
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(e, n, r) {
    throw hr();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    throw hr();
  }
}
const Pk = 0;
class jr extends rb {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    n > 0 && (this.id.clock += n, this.length -= n), Fm(e.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeInfo(Pk), e.writeLen(this.length - n);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    return null;
  }
}
class Vl {
  /**
   * @param {Uint8Array} content
   */
  constructor(e) {
    this.content = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new Vl(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(e) {
    throw hr();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
class ol {
  /**
   * @param {number} len
   */
  constructor(e) {
    this.len = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new ol(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(e) {
    const n = new ol(this.len - e);
    return this.len = e, n;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.len += e.len, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    Lm(e.deleteSet, n.id.client, n.id.clock, this.len), n.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeLen(this.len - n);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const $k = (t, e) => new Qs({ guid: t, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class Hl {
  /**
   * @param {Doc} doc
   */
  constructor(e) {
    e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
    const n = {};
    this.opts = n, e.gc || (n.gc = !1), e.autoLoad && (n.autoLoad = !0), e.meta !== null && (n.meta = e.meta);
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new Hl($k(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(e) {
    throw hr();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.doc._item = n, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(this.doc.guid), e.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
class Vi {
  /**
   * @param {Object} embed
   */
  constructor(e) {
    this.embed = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new Vi(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(e) {
    throw hr();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
class Pt {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(e, n) {
    this.key = e, this.value = n;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new Pt(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(e) {
    throw hr();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(e, n) {
    const r = (
      /** @type {YText} */
      n.parent
    );
    r._searchMarker = null, r._hasFormatting = !0;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeKey(this.key), e.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
const Fk = el("node_env") === "development";
class Ei {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e, Fk && Em(e);
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new Ei(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(e) {
    const n = new Ei(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), n;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    const r = this.arr.length;
    e.writeLen(r - n);
    for (let o = n; o < r; o++) {
      const i = this.arr[o];
      e.writeAny(i);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
class Dr {
  /**
   * @param {string} str
   */
  constructor(e) {
    this.str = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new Dr(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(e) {
    const n = new Dr(this.str.slice(e));
    this.str = this.str.slice(0, e);
    const r = this.str.charCodeAt(e - 1);
    return r >= 55296 && r <= 56319 && (this.str = this.str.slice(0, e - 1) + "ï¿½", n.str = "ï¿½" + n.str.slice(1)), n;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.str += e.str, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(n === 0 ? this.str : this.str.slice(n));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const Bk = 0, qk = 1, jk = 2, Uk = 3, Vk = 4;
class so {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(e) {
    this.type = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new so(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(e) {
    throw hr();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.type._integrate(e.doc, n);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.deleted ? n.id.clock < (e.beforeState.get(n.id.client) || 0) && e._mergeStructs.push(n) : n.delete(e), n = n.right;
    this.type._map.forEach((r) => {
      r.deleted ? r.id.clock < (e.beforeState.get(r.id.client) || 0) && e._mergeStructs.push(r) : r.delete(e);
    }), e.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.gc(e, !0), n = n.right;
    this.type._start = null, this.type._map.forEach(
      /** @param {Item | null} item */
      (r) => {
        for (; r !== null; )
          r.gc(e, !0), r = r.left;
      }
    ), this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    this.type._write(e);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const ob = (t, e, n) => {
  const { client: r, clock: o } = e.id, i = new Xt(
    bt(r, o + n),
    e,
    bt(r, o + n - 1),
    e.right,
    e.rightOrigin,
    e.parent,
    e.parentSub,
    e.content.splice(n)
  );
  return e.deleted && i.markDeleted(), e.keep && (i.keep = !0), e.redone !== null && (i.redone = bt(e.redone.client, e.redone.clock + n)), e.right = i, i.right !== null && (i.right.left = i), t._mergeStructs.push(i), i.parentSub !== null && i.right === null && i.parent._map.set(i.parentSub, i), e.length = n, i;
};
class Xt extends rb {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(e, n, r, o, i, s, a, l) {
    super(e, l.getLength()), this.origin = r, this.left = n, this.right = o, this.rightOrigin = i, this.parent = s, this.parentSub = a, this.redone = null, this.content = l, this.info = this.content.isCountable() ? oh : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(e) {
    (this.info & Oc) > 0 !== e && (this.info ^= Oc);
  }
  get marker() {
    return (this.info & Oc) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & rh) > 0;
  }
  set keep(e) {
    this.keep !== e && (this.info ^= rh);
  }
  get countable() {
    return (this.info & oh) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & Mc) > 0;
  }
  set deleted(e) {
    this.deleted !== e && (this.info ^= Mc);
  }
  markDeleted() {
    this.info |= Mc;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= fn(n, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= fn(n, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === ja && this.id.client !== this.parent.client && this.parent.clock >= fn(n, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = mh(e, n, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = Xr(e, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === jr || this.right && this.right.constructor === jr)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === Xt ? (this.parent = this.left.parent, this.parentSub = this.left.parentSub) : this.right && this.right.constructor === Xt && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === ja) {
      const r = Pc(n, this.parent);
      r.constructor === jr ? this.parent = null : this.parent = /** @type {ContentType} */
      r.content.type;
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    if (n > 0 && (this.id.clock += n, this.left = mh(e, e.doc.store, bt(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(n), this.length -= n), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let r = this.left, o;
        if (r !== null)
          o = r.right;
        else if (this.parentSub !== null)
          for (o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; o !== null && o.left !== null; )
            o = o.left;
        else
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        const i = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
        for (; o !== null && o !== this.right; ) {
          if (s.add(o), i.add(o), Da(this.origin, o.origin)) {
            if (o.id.client < this.id.client)
              r = o, i.clear();
            else if (Da(this.rightOrigin, o.rightOrigin))
              break;
          } else if (o.origin !== null && s.has(Pc(e.doc.store, o.origin)))
            i.has(Pc(e.doc.store, o.origin)) || (r = o, i.clear());
          else
            break;
          o = o.right;
        }
        this.left = r;
      }
      if (this.left !== null) {
        const r = this.left.right;
        this.right = r, this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null)
          for (r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; r !== null && r.left !== null; )
            r = r.left;
        else
          r = /** @type {AbstractType<any>} */
          this.parent._start, this.parent._start = this;
        this.right = r;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(e)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), Fm(e.doc.store, this), this.content.integrate(e, this), vh(
        e,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      ), /** @type {AbstractType<any>} */
      (this.parent._item !== null && /** @type {AbstractType<any>} */
      this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(e);
    } else
      new jr(this.id, this.length).integrate(e, 0);
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let e = this.right;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let e = this.left;
    for (; e !== null && e.deleted; )
      e = e.left;
    return e;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : bt(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(e) {
    if (this.constructor === e.constructor && Da(e.origin, this.lastId) && this.right === e && Da(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && this.redone === null && e.redone === null && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      return n && n.forEach((r) => {
        r.p === e && (r.p = this, !this.deleted && this.countable && (r.index -= this.length));
      }), e.keep && (this.keep = !0), this.right = e.right, this.right !== null && (this.right.left = this), this.length += e.length, !0;
    }
    return !1;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(e) {
    if (!this.deleted) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      this.countable && this.parentSub === null && (n._length -= this.length), this.markDeleted(), Lm(e.deleteSet, this.id.client, this.id.clock, this.length), vh(e, n, this.parentSub), this.content.delete(e);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(e, n) {
    if (!this.deleted)
      throw Oo();
    this.content.gc(e), n ? vk(e, this, new jr(this.id, this.length)) : this.content = new ol(this.length);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(e, n) {
    const r = n > 0 ? bt(this.id.client, this.id.clock + n - 1) : this.origin, o = this.rightOrigin, i = this.parentSub, s = this.content.getRef() & aE | (r === null ? 0 : Za) | // origin is defined
    (o === null ? 0 : xm) | // right origin is defined
    (i === null ? 0 : sE);
    if (e.writeInfo(s), r !== null && e.writeLeftID(r), o !== null && e.writeRightID(o), r === null && o === null) {
      const a = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (a._item !== void 0) {
        const l = a._item;
        if (l === null) {
          const c = gk(a);
          e.writeParentInfo(!0), e.writeString(c);
        } else
          e.writeParentInfo(!1), e.writeLeftID(l.id);
      } else a.constructor === String ? (e.writeParentInfo(!0), e.writeString(a)) : a.constructor === ja ? (e.writeParentInfo(!1), e.writeLeftID(a)) : Oo();
      i !== null && e.writeString(i);
    }
    this.content.write(e, n);
  }
}
const ib = (
  /** @type {any} */
  typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}
), sb = "__ $YJS$ __";
ib[sb] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
ib[sb] = !0;
Di("CONNECTED_COMMAND");
const Hk = Di("TOGGLE_CONNECT_COMMAND");
var zk = Object.defineProperty, Gk = (t, e, n) => e in t ? zk(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, fe = (t, e, n) => Gk(t, typeof e != "symbol" ? e + "" : e, n);
const Bc = (t) => Mt(xy(t)), Ro = Nw("cid", {
  parse: (t) => typeof t == "string" ? t : void 0
}), Io = Nw("segment", {
  parse: (t) => typeof t == "string" ? t : void 0
}), Mu = "unknown", ab = 1;
class Ko extends ro {
  constructor(e = "", n, r, o) {
    super(o), fe(this, "__tag"), fe(this, "__marker"), fe(this, "__unknownAttributes"), this.__tag = e, this.__marker = n, this.__unknownAttributes = r;
  }
  static getType() {
    return "unknown";
  }
  static clone(e) {
    const { __tag: n, __marker: r, __unknownAttributes: o, __key: i } = e;
    return new Ko(n, r, o, i);
  }
  static importDOM() {
    return {
      [Mu]: (e) => Wk(e) ? {
        conversion: Kk,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return lb().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setTag(e.tag).setMarker(e.marker).setUnknownAttributes(e.unknownAttributes);
  }
  setTag(e) {
    if (this.__tag === e)
      return this;
    const n = this.getWritable();
    return n.__tag = e, n;
  }
  getTag() {
    return this.getLatest().__tag;
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement(Mu);
    return e.style.display = "none", e;
  }
  updateDOM() {
    return !1;
  }
  exportDOM() {
    return { element: null };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      tag: this.getTag(),
      marker: this.getMarker(),
      unknownAttributes: this.getUnknownAttributes(),
      version: ab
    };
  }
  // Mutation
  canBeEmpty() {
    return !0;
  }
  isInline() {
    return !0;
  }
  extractWithChild() {
    return !1;
  }
  excludeFromCopy(e) {
    return e !== "clone";
  }
}
function Kk(t) {
  const e = t.getAttribute("data-tag") ?? "", n = t.getAttribute("data-marker") ?? "";
  return { node: lb(e, n) };
}
function lb(t, e, n) {
  return Mt(new Ko(t, e, n));
}
function Wk(t) {
  return (t == null ? void 0 : t.tagName) === Mu;
}
function Zs(t) {
  return t instanceof Ko;
}
const Ls = "id", cb = 1;
class In extends ro {
  constructor(e = "", n, r) {
    super(r), fe(this, "__marker", Ls), fe(this, "__code"), fe(this, "__unknownAttributes"), this.__code = e, this.__unknownAttributes = n;
  }
  static getType() {
    return "book";
  }
  static clone(e) {
    const { __code: n, __unknownAttributes: r, __key: o } = e;
    return new In(n, r, o);
  }
  static importJSON(e) {
    const { code: n } = e;
    return ub(n).updateFromJSON(e);
  }
  static isValidBookCode(e) {
    return r1(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setCode(e.code).setUnknownAttributes(e.unknownAttributes);
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setCode(e) {
    if (this.__code === e)
      return this;
    const n = this.getWritable();
    return n.__code = e, n;
  }
  /**
   * Get the book code (ID).
   * @returns the book code (ID).
   */
  getCode() {
    return this.getLatest().__code;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("p");
    return e.setAttribute("data-marker", this.__marker), e.classList.add(this.__type, `usfm_${this.__marker}`), e.setAttribute("data-code", this.__code), e;
  }
  updateDOM() {
    return !1;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      marker: this.getMarker(),
      code: this.getCode(),
      unknownAttributes: this.getUnknownAttributes(),
      version: cb
    };
  }
}
function ub(t, e) {
  return Mt(new In(t, e));
}
function wr(t) {
  return t instanceof In;
}
function Jk(t) {
  return (t == null ? void 0 : t.type) === In.getType();
}
const Ze = "Â ", Ou = "â€‹", Gd = `${Ze}|`, zl = "p", Lo = "+", Kd = "-", il = "chapter", Ru = "verse", Eh = "invalid", Xk = "text-spacing", Yk = "formatted-font", Qk = "marker-", Wd = "external-usj-mutation", db = "selection-change", Iu = "cursor-change", Lu = "annotation-change", Pu = "delta-change", Zk = [
  Wd,
  db,
  Iu,
  Lu,
  Pu
], sl = "c", pb = 1;
class Zn extends ro {
  constructor(e = "", n, r, o, i, s) {
    super(s), fe(this, "__marker"), fe(this, "__number"), fe(this, "__sid"), fe(this, "__altnumber"), fe(this, "__pubnumber"), fe(this, "__unknownAttributes"), this.__marker = sl, this.__number = e, this.__sid = n, this.__altnumber = r, this.__pubnumber = o, this.__unknownAttributes = i;
  }
  static getType() {
    return "chapter";
  }
  static clone(e) {
    const { __number: n, __sid: r, __altnumber: o, __pubnumber: i, __unknownAttributes: s, __key: a } = e;
    return new Zn(n, r, o, i, s, a);
  }
  static importJSON(e) {
    return fb().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setNumber(e.number).setSid(e.sid).setAltnumber(e.altnumber).setPubnumber(e.pubnumber).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setNumber(e) {
    if (this.__number === e)
      return this;
    const n = this.getWritable();
    return n.__number = e, n;
  }
  getNumber() {
    return this.getLatest().__number;
  }
  setSid(e) {
    if (this.__sid === e)
      return this;
    const n = this.getWritable();
    return n.__sid = e, n;
  }
  getSid() {
    return this.getLatest().__sid;
  }
  setAltnumber(e) {
    if (this.__altnumber === e)
      return this;
    const n = this.getWritable();
    return n.__altnumber = e, n;
  }
  getAltnumber() {
    return this.getLatest().__altnumber;
  }
  setPubnumber(e) {
    if (this.__pubnumber === e)
      return this;
    const n = this.getWritable();
    return n.__pubnumber = e, n;
  }
  getPubnumber() {
    return this.getLatest().__pubnumber;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("p");
    return e.setAttribute("data-marker", this.__marker), e.classList.add(il, `usfm_${this.__marker}`), e.setAttribute("data-number", this.__number), e;
  }
  updateDOM() {
    return !1;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      marker: this.getMarker(),
      number: this.getNumber(),
      sid: this.getSid(),
      altnumber: this.getAltnumber(),
      pubnumber: this.getPubnumber(),
      unknownAttributes: this.getUnknownAttributes(),
      version: pb
    };
  }
}
function fb(t, e, n, r, o) {
  return Mt(new Zn(t, e, n, r, o));
}
function Jd(t) {
  return t instanceof Zn;
}
function eN(t) {
  return (t == null ? void 0 : t.type) === Zn.getType();
}
const hb = [
  "fr",
  "fq",
  "fqa",
  "fk",
  "ft",
  "fl",
  "fw",
  "fp",
  "fv",
  "fdc",
  "fm"
], wb = [
  "xo",
  "xop",
  "xk",
  "xq",
  "xt",
  "xta",
  "xot",
  "xnt",
  "xdc"
], tN = [
  // Chapter & Verse
  "ca",
  "cp",
  "va",
  "vp",
  // Text Features
  "add",
  "bk",
  "dc",
  "em",
  "jmp",
  "k",
  "nd",
  "ord",
  "pn",
  "png",
  "qt",
  "rb",
  "rq",
  // "ref", // This has its own tag and is not a Char
  "sig",
  "sls",
  "tl",
  "w",
  "wa",
  "wg",
  "wh",
  "wj",
  // Note there are 2 deprecated markers intentionally not listed here: "addpn", "pro"
  // Text Formatting
  "bd",
  "it",
  "bdit",
  "no",
  "sc",
  "sup",
  // Introductions
  "ior",
  "iqt",
  // Poetry
  "qac",
  "qs",
  // Lists
  "litl",
  "lik",
  "liv",
  "liv1",
  "liv2",
  "liv3",
  "liv4",
  "liv5",
  ...hb,
  ...wb
], gb = 1;
class ht extends ro {
  constructor(e = "", n, r) {
    super(r), fe(this, "__marker"), fe(this, "__unknownAttributes"), this.__marker = e, this.__unknownAttributes = n;
  }
  static getType() {
    return "char";
  }
  static clone(e) {
    const { __marker: n, __unknownAttributes: r, __key: o } = e;
    return new ht(n, r, o);
  }
  static isValidMarker(e) {
    return e !== void 0 && tN.includes(e);
  }
  static isValidFootnoteMarker(e) {
    return e !== void 0 && hb.includes(e);
  }
  static isValidCrossReferenceMarker(e) {
    return e !== void 0 && wb.includes(e);
  }
  static importDOM() {
    return {
      span: (e) => rN(e) ? {
        conversion: nN,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return cr().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.setAttribute("data-marker", this.__marker), e.setAttribute("title", this.__marker), e.classList.add(this.__type, `usfm_${this.__marker}`), e;
  }
  updateDOM() {
    return !1;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && vr(n) && (n.setAttribute("data-marker", this.getMarker()), n.classList.add(this.getType(), `usfm_${this.getMarker()}`)), { element: n };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      marker: this.getMarker(),
      unknownAttributes: this.getUnknownAttributes(),
      version: gb
    };
  }
  // Mutation
  insertNewAfter(e, n) {
    const r = cr(this.getMarker());
    return r.setTextFormat(e.format), r.setTextStyle(e.style), r.setDirection(this.getDirection()), r.setFormat(this.getFormatType()), r.setStyle(this.getTextStyle()), this.insertAfter(r, n), r;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
}
function nN(t) {
  const e = t.getAttribute("data-marker") ?? "f";
  return { node: cr(e) };
}
function cr(t, e) {
  return Mt(new ht(t, e));
}
function rN(t) {
  if (!t)
    return !1;
  const e = t.getAttribute("data-marker") ?? "";
  return ht.isValidMarker(e) && t.classList.contains(ht.getType());
}
function et(t) {
  return t instanceof ht;
}
function oN(t) {
  return (t == null ? void 0 : t.type) === ht.getType();
}
const mb = 1, iN = "c", bb = "span";
class Lr extends Vo {
  constructor(e = "", n = !1, r, o, i, s, a) {
    super(a), fe(this, "__marker"), fe(this, "__number"), fe(this, "__showMarker"), fe(this, "__sid"), fe(this, "__altnumber"), fe(this, "__pubnumber"), fe(this, "__unknownAttributes"), this.__marker = iN, this.__number = e, this.__showMarker = n, this.__sid = r, this.__altnumber = o, this.__pubnumber = i, this.__unknownAttributes = s;
  }
  static getType() {
    return "immutable-chapter";
  }
  static clone(e) {
    const { __number: n, __showMarker: r, __sid: o, __altnumber: i, __pubnumber: s, __unknownAttributes: a, __key: l } = e;
    return new Lr(n, r, o, i, s, a, l);
  }
  static importDOM() {
    return {
      span: (e) => vb(e) ? {
        conversion: sN,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return Xd().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setNumber(e.number).setShowMarker(e.showMarker).setSid(e.sid).setAltnumber(e.altnumber).setPubnumber(e.pubnumber).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setNumber(e) {
    if (this.__number === e)
      return this;
    const n = this.getWritable();
    return n.__number = e, n;
  }
  getNumber() {
    return this.getLatest().__number;
  }
  setShowMarker(e = !1) {
    if (this.__showMarker === e)
      return this;
    const n = this.getWritable();
    return n.__showMarker = e, n;
  }
  getShowMarker() {
    return this.getLatest().__showMarker;
  }
  setSid(e) {
    if (this.__sid === e)
      return this;
    const n = this.getWritable();
    return n.__sid = e, n;
  }
  getSid() {
    return this.getLatest().__sid;
  }
  setAltnumber(e) {
    if (this.__altnumber === e)
      return this;
    const n = this.getWritable();
    return n.__altnumber = e, n;
  }
  getAltnumber() {
    return this.getLatest().__altnumber;
  }
  setPubnumber(e) {
    if (this.__pubnumber === e)
      return this;
    const n = this.getWritable();
    return n.__pubnumber = e, n;
  }
  getPubnumber() {
    return this.getLatest().__pubnumber;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement(bb);
    return e.setAttribute("data-marker", this.__marker), e.classList.add(il, `usfm_${this.__marker}`), this.__showMarker && e.classList.add("marker"), e.setAttribute("data-number", this.__number), e;
  }
  updateDOM() {
    return !1;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && vr(n) && (n.setAttribute("data-marker", this.getMarker()), n.classList.add(il, `usfm_${this.getMarker()}`), n.setAttribute("data-number", this.getNumber())), { element: n };
  }
  decorate() {
    return this.getShowMarker() ? ta(this.getMarker(), this.getNumber()) : this.getNumber();
  }
  exportJSON() {
    return {
      type: this.getType(),
      marker: this.getMarker(),
      number: this.getNumber(),
      showMarker: this.getShowMarker(),
      sid: this.getSid(),
      altnumber: this.getAltnumber(),
      pubnumber: this.getPubnumber(),
      unknownAttributes: this.getUnknownAttributes(),
      version: mb
    };
  }
  // Mutation
  isInline() {
    return !1;
  }
  isKeyboardSelectable() {
    return !1;
  }
}
function sN(t) {
  const e = t.getAttribute("data-number") ?? "0";
  return { node: Xd(e) };
}
function Xd(t, e, n, r, o, i) {
  return Mt(new Lr(t, e, n, r, o, i));
}
function vb(t) {
  return t ? t.classList.contains(il) && t.tagName.toLowerCase() === bb : !1;
}
function ea(t) {
  return t instanceof Lr;
}
function aN(t) {
  return (t == null ? void 0 : t.type) === Lr.getType();
}
const yb = 1;
class Yr extends Us {
  static getType() {
    return "implied-para";
  }
  static clone(e) {
    return new Yr(e.__key);
  }
  static importJSON(e) {
    return zn().updateFromJSON(e);
  }
  getMarker() {
    return zl;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      version: yb
    };
  }
  // Mutation
  insertNewAfter(e, n) {
    const r = zn();
    return r.setTextFormat(e.format), r.setTextStyle(e.style), r.setDirection(this.getDirection()), r.setFormat(this.getFormatType()), r.setStyle(this.getTextStyle()), this.insertAfter(r, n), r;
  }
}
function zn() {
  return Mt(new Yr());
}
function Mr(t) {
  return t instanceof Yr;
}
function Yd(t) {
  return (t == null ? void 0 : t.type) === Yr.getType();
}
const Po = "zmsc-s", di = "zmsc-e", lN = [Po, di], cN = [
  "ts-s",
  "ts-e",
  "t-s",
  "t-e",
  "ts",
  "qt1-s",
  "qt1-e",
  "qt2-s",
  "qt2-e",
  "qt3-s",
  "qt3-e",
  "qt4-s",
  "qt4-e",
  "qt5-s",
  "qt5-e",
  "qt-s",
  "qt-e",
  // custom markers used for annotations
  Po,
  di
], xb = 1;
class mr extends Vo {
  constructor(e = "", n, r, o, i) {
    super(i), fe(this, "__marker"), fe(this, "__sid"), fe(this, "__eid"), fe(this, "__unknownAttributes"), this.__marker = e, this.__sid = n, this.__eid = r, this.__unknownAttributes = o;
  }
  static getType() {
    return "ms";
  }
  static clone(e) {
    const { __marker: n, __sid: r, __eid: o, __unknownAttributes: i, __key: s } = e;
    return new mr(n, r, o, i, s);
  }
  static importJSON(e) {
    return _b().updateFromJSON(e);
  }
  static isValidMarker(e) {
    return e !== void 0 && (cN.includes(e) || e.startsWith("z"));
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setSid(e.sid).setEid(e.eid).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setSid(e) {
    if (this.__sid === e)
      return this;
    const n = this.getWritable();
    return n.__sid = e, n;
  }
  getSid() {
    return this.getLatest().__sid;
  }
  setEid(e) {
    if (this.__eid === e)
      return this;
    const n = this.getWritable();
    return n.__eid = e, n;
  }
  getEid() {
    return this.getLatest().__eid;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.setAttribute("data-marker", this.__marker), e.classList.add(this.__type, `usfm_${this.__marker}`), e;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return "";
  }
  exportJSON() {
    return {
      type: this.getType(),
      marker: this.getMarker(),
      sid: this.getSid(),
      eid: this.getEid(),
      unknownAttributes: this.getUnknownAttributes(),
      version: xb
    };
  }
  // Mutation
  isKeyboardSelectable() {
    return !1;
  }
}
function uN(t) {
  return lN.includes(t);
}
function _b(t, e, n, r) {
  return Mt(new mr(t, e, n, r));
}
function Gl(t) {
  return t instanceof mr;
}
const Qd = "f", dN = [
  // Footnote
  Qd,
  "fe",
  "ef",
  "efe",
  // Cross Reference
  "x",
  "ex"
], Cb = 1;
class $t extends ro {
  constructor(e = Qd, n, r = !0, o, i, s) {
    super(s), fe(this, "__marker"), fe(this, "__caller"), fe(this, "__isCollapsed"), fe(this, "__category"), fe(this, "__unknownAttributes"), this.__marker = e, this.__caller = n ?? (e === "x" || e === "ex" ? Kd : Lo), this.__isCollapsed = r, this.__category = o, this.__unknownAttributes = i;
  }
  static getType() {
    return "note";
  }
  static clone(e) {
    const { __marker: n, __caller: r, __isCollapsed: o, __category: i, __unknownAttributes: s, __key: a } = e;
    return new $t(n, r, o, i, s, a);
  }
  static importDOM() {
    return {
      span: (e) => fN(e) ? {
        conversion: pN,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return Zd().updateFromJSON(e);
  }
  static isValidMarker(e) {
    return e !== void 0 && dN.includes(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setCaller(e.caller).setIsCollapsed(e.isCollapsed).setCategory(e.category).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setCaller(e) {
    if (this.__caller === e)
      return this;
    const n = this.getWritable();
    return n.__caller = e, n;
  }
  getCaller() {
    return this.getLatest().__caller;
  }
  setIsCollapsed(e) {
    if (this.__isCollapsed === e)
      return this;
    const n = this.getWritable();
    return n.__isCollapsed = e, n;
  }
  toggleIsCollapsed() {
    const e = this.getWritable();
    return e.__isCollapsed = !e.__isCollapsed, e;
  }
  getIsCollapsed() {
    return this.getLatest().__isCollapsed;
  }
  setCategory(e) {
    if (this.__category === e)
      return this;
    const n = this.getWritable();
    return n.__category = e, n;
  }
  getCategory() {
    return this.getLatest().__category;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.setAttribute("data-marker", this.__marker), e.classList.add(this.__type, `usfm_${this.__marker}`, this.__isCollapsed ? "collapsed" : "expanded"), e.setAttribute("data-caller", this.__caller), e;
  }
  updateDOM(e) {
    return e.__isCollapsed !== this.__isCollapsed;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && vr(n) && (n.setAttribute("data-marker", this.getMarker()), n.classList.add(this.getType(), `usfm_${this.getMarker()}`, this.getIsCollapsed() ? "collapsed" : "expanded"), n.setAttribute("data-caller", this.getCaller())), { element: n };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      marker: this.getMarker(),
      caller: this.getCaller(),
      isCollapsed: this.getIsCollapsed(),
      category: this.getCategory(),
      unknownAttributes: this.getUnknownAttributes(),
      version: Cb
    };
  }
  // Mutation
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
}
function pN(t) {
  const e = t.getAttribute("data-marker") ?? "f", n = t.getAttribute("data-caller") ?? "", r = t.classList.contains("collapsed");
  return { node: Zd(e, n, r) };
}
function Zd(t, e, n, r, o) {
  return Mt(new $t(t, e, n, r, o));
}
function fN(t) {
  if (!t)
    return !1;
  const e = t.getAttribute("data-marker") ?? "";
  return $t.isValidMarker(e) && t.classList.contains($t.getType());
}
function Le(t) {
  return t instanceof $t;
}
const hN = [
  // Identification
  "ide",
  "sts",
  "rem",
  "h",
  "toc1",
  "toc2",
  "toc3",
  "toca1",
  "toca2",
  "toca3",
  // Introductions
  "imt",
  "imt1",
  "imt2",
  "imt3",
  "imt4",
  "is",
  "is1",
  "is2",
  "ip",
  "ipi",
  "im",
  "imi",
  "ipq",
  "imq",
  "ipr",
  "iq",
  "iq1",
  "iq2",
  "iq3",
  "ili",
  "ili1",
  "ili2",
  "ib",
  "iot",
  "io",
  "io1",
  "io2",
  "io3",
  "io4",
  "iex",
  "imte",
  "imte1",
  "imte2",
  "ie",
  // Titles and Headings
  "mt",
  "mt1",
  "mt2",
  "mt3",
  "mt4",
  "mte",
  "mte1",
  "mte2",
  "cl",
  "cd",
  "ms",
  "ms1",
  "ms2",
  "ms3",
  "mr",
  "s",
  "s1",
  "s2",
  "s3",
  "s4",
  "sr",
  "r",
  "d",
  "sp",
  "sd",
  "sd1",
  "sd2",
  "sd3",
  "sd4",
  // Body Paragraphs
  zl,
  "m",
  "po",
  "cls",
  "pr",
  "pc",
  "pm",
  "pmo",
  "pmc",
  "pmr",
  "pi",
  "pi1",
  "pi2",
  "pi3",
  "mi",
  "lit",
  "nb",
  // Note there is 1 deprecated marker not listed here: "ph#"
  // Poetry
  "q",
  "q1",
  "q2",
  "q3",
  "q4",
  "qr",
  "qc",
  "qa",
  "qm",
  "qm1",
  "qm2",
  "qm3",
  "qd",
  "b",
  // Lists
  "lh",
  "li",
  "li1",
  "li2",
  "li3",
  "li4",
  "lf",
  "lim",
  "lim1",
  "lim2",
  "lim3",
  "lim4",
  // Breaks - see https://docs.usfm.bible/usfm/3.1/char/breaks/pb.html
  "pb"
], Eb = 1;
class hn extends Us {
  constructor(e = zl, n, r) {
    super(r), fe(this, "__marker"), fe(this, "__unknownAttributes"), this.__marker = e, this.__unknownAttributes = n;
  }
  static getType() {
    return "para";
  }
  static clone(e) {
    const { __marker: n, __unknownAttributes: r, __key: o } = e;
    return new hn(n, r, o);
  }
  static isValidMarker(e) {
    return e !== void 0 && hN.includes(e);
  }
  static importDOM() {
    return {
      p: () => ({
        conversion: wN,
        priority: 1
      })
    };
  }
  static importJSON(e) {
    return Ps().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("p");
    return e.setAttribute("data-marker", this.__marker), e.classList.add(this.__type, `usfm_${this.__marker}`), e;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && vr(n) && (n.setAttribute("data-marker", this.getMarker()), n.classList.add(this.getType(), `usfm_${this.getMarker()}`)), { element: n };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      marker: this.getMarker(),
      unknownAttributes: this.getUnknownAttributes(),
      version: Eb
    };
  }
  // Mutation
  insertNewAfter(e, n) {
    const r = Ps(this.getMarker());
    return r.setTextFormat(e.format), r.setTextStyle(e.style), r.setDirection(this.getDirection()), r.setFormat(this.getFormatType()), r.setStyle(this.getTextStyle()), this.insertAfter(r, n), r;
  }
}
function wN(t) {
  const e = t.getAttribute("data-marker") ?? void 0, n = Ps(e);
  if (t.style) {
    n.setFormat(t.style.textAlign);
    const r = parseInt(t.style.textIndent, 10) / 20;
    r > 0 && n.setIndent(r);
  }
  return { node: n };
}
function Ps(t, e) {
  return Mt(new hn(t, e));
}
function Yt(t) {
  return t instanceof hn;
}
function gN(t) {
  return (t == null ? void 0 : t.type) === hn.getType();
}
const al = "v", kb = 1;
class on extends Hn {
  constructor(e = "", n, r, o, i, s, a) {
    super(n ?? e, a), fe(this, "__marker"), fe(this, "__number"), fe(this, "__sid"), fe(this, "__altnumber"), fe(this, "__pubnumber"), fe(this, "__unknownAttributes"), this.__marker = al, this.__number = e, this.__sid = r, this.__altnumber = o, this.__pubnumber = i, this.__unknownAttributes = s;
  }
  static getType() {
    return "verse";
  }
  static clone(e) {
    const { __number: n, __text: r, __sid: o, __altnumber: i, __pubnumber: s, __unknownAttributes: a, __key: l } = e;
    return new on(n, r, o, i, s, a, l);
  }
  static importJSON(e) {
    return Nb().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setNumber(e.number).setSid(e.sid).setAltnumber(e.altnumber).setPubnumber(e.pubnumber).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setNumber(e) {
    if (this.__number === e)
      return this;
    const n = this.getWritable();
    return n.__number = e, n;
  }
  getNumber() {
    return this.getLatest().__number;
  }
  setSid(e) {
    if (this.__sid === e)
      return this;
    const n = this.getWritable();
    return n.__sid = e, n;
  }
  getSid() {
    return this.getLatest().__sid;
  }
  setAltnumber(e) {
    if (this.__altnumber === e)
      return this;
    const n = this.getWritable();
    return n.__altnumber = e, n;
  }
  getAltnumber() {
    return this.getLatest().__altnumber;
  }
  setPubnumber(e) {
    if (this.__pubnumber === e)
      return this;
    const n = this.getWritable();
    return n.__pubnumber = e, n;
  }
  getPubnumber() {
    return this.getLatest().__pubnumber;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM(e) {
    const n = super.createDOM(e);
    return n.setAttribute("data-marker", this.__marker), n.classList.add(Ru, `usfm_${this.__marker}`), n.setAttribute("data-number", this.__number), n;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      marker: this.getMarker(),
      number: this.getNumber(),
      sid: this.getSid(),
      altnumber: this.getAltnumber(),
      pubnumber: this.getPubnumber(),
      unknownAttributes: this.getUnknownAttributes(),
      version: kb
    };
  }
}
function Nb(t, e, n, r, o, i) {
  return Mt(new on(t, e, n, r, o, i));
}
function ep(t) {
  return t instanceof on;
}
function mN(t) {
  return (t == null ? void 0 : t.type) === on.getType();
}
function bN(t) {
  return eN(t) || aN(t);
}
function On(t) {
  return Jd(t) || ea(t);
}
function vN(t, e) {
  return t.find((n) => On(n) && n.getNumber() === e.toString());
}
function yN(t, e = !1) {
  return t.find((n, r) => (!e || r > 0) && On(n));
}
function tp(t) {
  var e;
  if (!t)
    return;
  if (On(t))
    return t;
  let n = (e = t.getTopLevelElement()) == null ? void 0 : e.getPreviousSibling();
  for (; n && !On(n); )
    n = n.getPreviousSibling();
  if (n && On(n))
    return n;
}
function Tb(t) {
  let e = t;
  for (; e !== null; ) {
    if (Le(e))
      return e;
    e = e.getParent();
  }
}
function xN(t) {
  return wr(t) || Jd(t) || et(t) || ea(t) || Mr(t) || Gl(t) || Yt(t) || Le(t) || ep(t) || Zs(t);
}
function _N(t) {
  var e;
  if (t.anchor.type === "element") {
    const r = t.anchor.getNode(), o = t.anchor.offset;
    if (o < r.getChildrenSize())
      return r.getChildAtIndex(o);
  }
  const n = t.anchor.getNode();
  return n.getNextSibling() ?? ((e = n.getParent()) == null ? void 0 : e.getNextSibling()) ?? null;
}
function CN(t) {
  var e;
  const n = t.anchor.offset;
  if (t.anchor.type === "element" && n > 0)
    return t.anchor.getNode().getChildAtIndex(n - 1);
  const r = t.anchor.getNode();
  return r.getPreviousSibling() ?? ((e = r.getParent()) == null ? void 0 : e.getPreviousSibling()) ?? null;
}
function Vn(t) {
  return Yt(t) || Mr(t);
}
function EN(t, e) {
  let n = t.getParent();
  for (; n; ) {
    if (n.getKey() === e)
      return !0;
    n = n.getParent();
  }
  return !1;
}
function $o(t, e) {
  const n = bs(e, Ro), r = !!(t.cid && n), o = !t.cid && !n;
  return t.style === e.getMarker() && (o || r && t.cid === n);
}
function kN(t, e) {
  const n = Ae(t) ? t : t.getParent(), r = Ae(e) ? e : e.getParent(), o = n && r ? _y(n, r) : void 0;
  return o ? o.commonAncestor : void 0;
}
function NN(t) {
  const e = t.getStartEndPoints();
  if (!e)
    return;
  const [n, r] = e, o = t.isBackward() ? n : r;
  t.focus.set(o.key, o.offset, o.type), t.anchor.set(o.key, o.offset, o.type);
}
function np(t) {
  return (t == null ? void 0 : t.type) === Hn.getType();
}
function TN(t, e) {
  if (!e)
    return;
  const n = t.findIndex((r) => r === e);
  n && (t.length = n);
}
function AN(t, e) {
  if (!e)
    return t;
  const n = e.getIndexWithinParent();
  return t.splice(n + 1, t.length - n - 1);
}
function Pr(t) {
  return `\\${t}`;
}
function ki(t) {
  return `\\${t}*`;
}
function Ab(t, e, n) {
  const r = Pr(t);
  if (e != null && e.startsWith(r)) {
    const o = parseInt(e.slice(r.length), 10);
    isNaN(o) || (n = o.toString());
  }
  return n;
}
function ta(t, e) {
  let n = Pr(t);
  return e && (n += `${Ze}${e}`), n += " ", n;
}
function Sb(t) {
  return np(t) ? t.text : oN(t) ? t.children.map((e) => Sb(e)).join("") : "";
}
function SN(t) {
  return t.map((e) => Sb(e)).join(" ").trim();
}
function rp(t) {
  return Ze + t + " ";
}
function op(t) {
  return t.reduce((e, n) => e + (et(n) ? ` ${n.getTextContent()}` : ""), "").trim();
}
function Ft(t, e = n1) {
  const n = { ...t };
  return e.forEach((r) => {
    Reflect.deleteProperty(n, r);
  }), Object.keys(n).length === 0 ? void 0 : n;
}
function DN(t, e) {
  const n = e.getElementByKey(t.getKey());
  return n ? n.tagName.toLowerCase() : void 0;
}
function Dt(t) {
  return Object.fromEntries(Object.entries(t).filter(([, e]) => e !== void 0));
}
function Db(t) {
  if (!t)
    return;
  const e = t.getNodes();
  if (e.length > 0)
    return t.isBackward() ? e[e.length - 1] : e[0];
}
function $u(t, e) {
  if (!e)
    return (t + 1).toString();
  const n = e.split("-");
  if (n.length === 2)
    return parseInt(n[1]) ? `${parseInt(n[1]) + 1}` : `${parseInt(n[0]) + 1}`;
  const r = RegExp(/^(\d+)([a-yA-Y]{1,3})$/).exec(e);
  if (!r)
    return (parseInt(e) + 1).toString();
  const o = String.fromCharCode(r[2].charCodeAt(0) + 1);
  return `${r[1]}${o}`;
}
function ip(t, e) {
  if (!e)
    return !1;
  const n = e.split("-").map((r) => parseInt(r));
  if (n.length < 1 || n.length > 2 || n[0] > n[1])
    throw new Error("isVerseInRange: invalid range");
  return n.length === 1 ? t === n[0] : n.length === 2 && isNaN(n[1]) ? t >= n[0] : (n.length === 2 && isNaN(n[0]) || t >= n[0]) && t <= n[1];
}
function MN(t) {
  return !!t && t.includes("-");
}
const ON = 1;
class Wo extends Hn {
  constructor(e = "", n = "opening", r) {
    super(qc(e, n), r), fe(this, "__marker"), fe(this, "__markerSyntax"), this.__marker = e, this.__markerSyntax = n;
  }
  static getType() {
    return "marker";
  }
  static clone(e) {
    return new Wo(e.__marker, e.__markerSyntax, e.__key);
  }
  static importJSON(e) {
    return Ni().updateFromJSON(e);
  }
  updateFromJSON(e) {
    const { marker: n, markerSyntax: r = "opening" } = e;
    return super.updateFromJSON(e).setMarker(n).setMarkerSyntax(r);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n.__text = qc(e, n.__markerSyntax), n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setMarkerSyntax(e) {
    if (this.__markerSyntax === e)
      return this;
    const n = this.getWritable();
    return n.__markerSyntax = e, n.__text = qc(n.__marker, e), n;
  }
  getMarkerSyntax() {
    return this.getLatest().__markerSyntax;
  }
  createDOM(e) {
    const n = super.createDOM(e);
    return n.setAttribute("data-marker", this.__marker), n.classList.add(this.__markerSyntax), n;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      text: this.getTextContent(),
      marker: this.getMarker(),
      markerSyntax: this.getMarkerSyntax(),
      version: ON
    };
  }
}
function Ni(t, e) {
  return Mt(new Wo(t, e));
}
function na(t) {
  return t instanceof Wo;
}
function qc(t, e) {
  return e === "closing" ? ki(t) : e === "selfClosing" ? ki("") : Pr(t);
}
const zr = "internal-comment", RN = [zr], IN = {}, LN = 1;
class Vt extends ro {
  constructor(e = IN, n) {
    super(n), fe(this, "__typedIDs"), this.__typedIDs = e;
  }
  static getType() {
    return "typed-mark";
  }
  static clone(e) {
    const n = JSON.parse(JSON.stringify(e.__typedIDs));
    return new Vt(n, e.__key);
  }
  static isReservedType(e) {
    return RN.includes(e);
  }
  static importDOM() {
    return null;
  }
  static importJSON(e) {
    return $s().updateFromJSON(e);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      typedIDs: this.getTypedIDs(),
      version: LN
    };
  }
  createDOM(e) {
    const n = document.createElement("mark");
    for (const [r, o] of Object.entries(this.__typedIDs))
      Vr(n, Ra(e.theme.typedMark, r)), o.length > 1 && Vr(n, Ra(e.theme.typedMarkOverlap, r));
    return n;
  }
  updateDOM(e, n, r) {
    for (const [o, i] of Object.entries(this.__typedIDs)) {
      const s = e.__typedIDs[o].length, a = i.length, l = Ra(r.theme.typedMark, o), c = Ra(r.theme.typedMarkOverlap, o);
      s !== a && (s === 0 ? a === 1 && Vr(n, l) : a === 0 && hu(n, l), s === 1 ? a === 2 && Vr(n, c) : a === 1 && hu(n, c));
    }
    return !1;
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setTypedIDs(e.typedIDs);
  }
  hasID(e, n) {
    const r = this.getTypedIDs()[e];
    if (!r)
      return !1;
    for (const o of r)
      if (n === o)
        return !0;
    return !1;
  }
  getTypedIDs() {
    const e = this.getLatest();
    return zt(e) ? e.__typedIDs : {};
  }
  setTypedIDs(e) {
    const n = this.getWritable();
    return n.__typedIDs = e, n;
  }
  addID(e, n) {
    const r = this.getWritable();
    if (!zt(r))
      return;
    const o = r.__typedIDs[e] ?? [];
    r.__typedIDs[e] = o;
    for (const i of o)
      if (n === i)
        return;
    o.push(n);
  }
  deleteID(e, n) {
    const r = this.getWritable();
    if (!zt(r))
      return;
    const o = r.__typedIDs[e];
    for (let i = 0; i < o.length; i++)
      if (n === o[i]) {
        o.splice(i, 1);
        return;
      }
  }
  hasNoIDsForEveryType() {
    return Object.values(this.getTypedIDs()).every((e) => e === void 0 || e.length === 0);
  }
  insertNewAfter(e, n = !0) {
    const r = $s(this.__typedIDs);
    return this.insertAfter(r, n), r;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
  extractWithChild(e, n, r) {
    if (!me(n) || r === "html")
      return !1;
    const o = n.anchor, i = n.focus, s = o.getNode(), a = i.getNode(), l = n.isBackward() ? o.offset - i.offset : i.offset - o.offset;
    return this.isParentOf(s) && this.isParentOf(a) && this.getTextContent().length === l;
  }
  excludeFromCopy(e) {
    return e !== "clone";
  }
}
function Ra(t, e) {
  return `${t}-${e}`;
}
function $s(t) {
  return Mt(new Vt(t));
}
function zt(t) {
  return t instanceof Vt;
}
function PN(t) {
  return (t == null ? void 0 : t.type) === Vt.getType();
}
function Mb(t) {
  const e = t.getChildren();
  let n = null;
  for (const r of e)
    n === null ? t.insertBefore(r) : n.insertAfter(r), n = r;
  t.remove();
}
function Ob(t, e, n, r) {
  const o = t.getNodes(), i = t.anchor.offset, s = t.focus.offset, a = o.length, l = t.isBackward(), c = l ? s : i, u = l ? i : s;
  let p, f;
  for (let h = 0; h < a; h++) {
    const g = o[h];
    if (Ae(f) && f.isParentOf(g))
      continue;
    const b = h === 0, _ = h === a - 1;
    let x = null;
    if (xe(g)) {
      const y = g.getTextContentSize(), A = b ? c : 0, P = _ ? u : y;
      if (A === 0 && P === 0)
        continue;
      const V = g.splitText(A, P);
      x = V.length > 1 && (V.length === 3 || b && !_ || P === y) ? V[1] : V[0];
    } else {
      if (zt(g))
        continue;
      Ae(g) && g.isInline() && (x = g);
    }
    if (x !== null) {
      if (x && x.is(p))
        continue;
      const y = x.getParent();
      (y == null || !y.is(p)) && (f = void 0), p = y, f === void 0 && (f = $s({ [e]: [n] }), x.insertBefore(f)), f.append(x);
    } else
      p = void 0, f = void 0;
  }
  e === zr && Ae(f) && (l ? f.selectStart() : f.selectEnd());
}
function $N(t, e, n) {
  let r = t;
  for (; r !== null; ) {
    if (zt(r))
      return r.getTypedIDs()[e];
    if (xe(r) && n === r.getTextContentSize()) {
      const o = r.getNextSibling();
      if (zt(o))
        return o.getTypedIDs()[e];
    }
    r = r.getParent();
  }
}
function kh(t) {
  return `external-${t}`;
}
const Rb = 1;
class ao extends Vo {
  constructor(e = "", n = "", r) {
    super(r), fe(this, "__textType"), fe(this, "__text"), this.__textType = e, this.__text = n;
  }
  static getType() {
    return "immutable-typed-text";
  }
  static clone(e) {
    const { __textType: n, __text: r, __key: o } = e;
    return new ao(n, r, o);
  }
  static importDOM() {
    return {
      span: (e) => BN(e) ? {
        conversion: FN,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return Ti().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setTextType(e.textType).setTextContent(e.text);
  }
  setTextType(e) {
    if (this.__textType === e)
      return this;
    const n = this.getWritable();
    return n.__textType = e, n;
  }
  getTextType() {
    return this.getLatest().__textType;
  }
  setTextContent(e) {
    if (this.__text === e)
      return this;
    const n = this.getWritable();
    return n.__text = e, n;
  }
  getTextContent() {
    return this.getLatest().__text;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.setAttribute("data-text-type", this.__textType), e.classList.add(this.__textType), e;
  }
  updateDOM() {
    return !1;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && vr(n) && n.setAttribute("data-text-type", this.getTextType()), { element: n };
  }
  decorate() {
    return this.getTextContent();
  }
  exportJSON() {
    return {
      type: this.getType(),
      textType: this.getTextType(),
      text: this.getTextContent(),
      version: Rb
    };
  }
  // Mutation
  isKeyboardSelectable() {
    return !1;
  }
}
function FN(t) {
  const e = t.getAttribute("data-text-type") ?? "", n = t.textContent ?? "";
  return { node: Ti(e, n) };
}
function Ti(t, e) {
  return Mt(new ao(t, e));
}
function BN(t) {
  return (t == null ? void 0 : t.tagName) === "span";
}
function ll(t) {
  return t instanceof ao;
}
function qN(t) {
  return (t == null ? void 0 : t.type) === ao.getType();
}
const cl = "unmatched", Ib = 1;
class lo extends Vo {
  constructor(e = "", n) {
    super(n), fe(this, "__marker"), this.__marker = e;
  }
  static getType() {
    return "unmatched";
  }
  static clone(e) {
    const { __marker: n, __key: r } = e;
    return new lo(n, r);
  }
  static importDOM() {
    return {
      [cl]: (e) => UN(e) ? {
        conversion: jN,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return sp().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  createDOM() {
    const e = document.createElement(cl);
    e.setAttribute("data-marker", this.__marker), e.classList.add(Eh);
    const n = this.__marker.endsWith("*");
    return e.title = n ? "This closing marker has no matching opening marker!" : "This opening marker has no matching closing marker!", e;
  }
  updateDOM() {
    return !1;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && vr(n) && (n.setAttribute("data-marker", this.getMarker()), n.classList.add(Eh)), { element: n };
  }
  decorate() {
    return `\\${this.getMarker()}${Ou}`;
  }
  exportJSON() {
    return {
      type: this.getType(),
      marker: this.getMarker(),
      version: Ib
    };
  }
  // Mutation
  isKeyboardSelectable() {
    return !1;
  }
}
function jN(t) {
  const e = t.getAttribute("data-marker") ?? "";
  return { node: sp(e) };
}
function sp(t) {
  return Mt(new lo(t));
}
function UN(t) {
  return (t == null ? void 0 : t.tagName) === cl;
}
function Lb(t) {
  return t instanceof lo;
}
const VN = [
  In,
  Lr,
  Zn,
  on,
  ht,
  $t,
  mr,
  Wo,
  Ko,
  ao,
  lo,
  hn,
  Yr,
  {
    replace: Us,
    with: () => zn(),
    withKlass: Yr
  }
];
var j;
(function(t) {
  t.FileIdentification = "FileIdentification", t.Headers = "Headers", t.Remarks = "Remarks", t.Introduction = "Introduction", t.DivisionMarks = "DivisionMarks", t.Paragraphs = "Paragraphs", t.Poetry = "Poetry", t.TitlesHeadings = "TitlesHeadings", t.Tables = "Tables", t.CenterTables = "CenterTables", t.RightTables = "RightTables", t.Lists = "Lists", t.Footnotes = "Footnotes", t.CrossReferences = "CrossReferences", t.SpecialText = "SpecialText", t.CharacterStyling = "CharacterStyling", t.Breaks = "Breaks", t.SpecialFeatures = "SpecialFeatures", t.PeripheralReferences = "PeripheralReferences", t.PeripheralMaterials = "PeripheralMaterials", t.Uncategorized = "Uncategorized";
})(j || (j = {}));
var q;
(function(t) {
  t.Paragraph = "Paragraph", t.Character = "Character", t.Note = "Note", t.Unknown = "Unknown";
})(q || (q = {}));
const HN = {
  id: {
    category: j.FileIdentification,
    type: q.Paragraph,
    description: "File identification information (BOOKID, FILENAME, EDITOR, MODIFICATION DATE)",
    hasEndMarker: !1,
    children: {
      FileIdentification: ["usfm", "ide"],
      Headers: ["h", "h1", "h2", "h3", "toc1", "toc2", "toc3"],
      Remarks: ["rem", "sts", "restore"],
      Introduction: [
        "imt",
        "imt1",
        "imt2",
        "imt3",
        "imt4",
        "imte",
        "imte1",
        "imte2",
        "is",
        "is1",
        "is2",
        "iot",
        "io",
        "io1",
        "io2",
        "io3",
        "io4",
        "ior",
        "ip",
        "im",
        "ipi",
        "imi",
        "ili",
        "ili1",
        "ili2",
        "ipq",
        "imq",
        "ipr",
        "ib",
        "iq",
        "iq1",
        "iq2",
        "iq3",
        "iex",
        "ie"
      ],
      DivisionMarks: ["c", "cl"],
      TitlesHeadings: ["mt", "mt1", "mt2", "mt3", "mt4"]
    }
  },
  usfm: {
    category: j.FileIdentification,
    type: q.Paragraph,
    description: "File markup version information",
    hasEndMarker: !1,
    children: void 0
  },
  ide: {
    category: j.FileIdentification,
    type: q.Paragraph,
    description: "File encoding information",
    hasEndMarker: !1,
    children: {
      Remarks: ["rem", "sts"]
    }
  },
  h: {
    category: j.Headers,
    type: q.Paragraph,
    description: "Running header text for a book (basic)",
    hasEndMarker: !1,
    children: {
      Headers: ["toc1", "toc2", "toc3", "toca1", "toca2", "toca3"]
    }
  },
  h1: {
    category: j.Headers,
    type: q.Paragraph,
    description: "Running header text",
    hasEndMarker: !1,
    children: {
      Headers: ["toc1", "toc2", "toc3", "toca1", "toca2", "toca3"]
    }
  },
  h2: {
    category: j.Headers,
    type: q.Paragraph,
    description: "Running header text, left side of page",
    hasEndMarker: !1,
    children: {
      Headers: ["toc1", "toc2", "toc3", "toca1", "toca2", "toca3"]
    }
  },
  h3: {
    category: j.Headers,
    type: q.Paragraph,
    description: "Running header text, right side of page",
    hasEndMarker: !1,
    children: {
      Headers: ["toc1", "toc2", "toc3", "toca1", "toca2", "toca3"]
    }
  },
  toc1: {
    category: j.Headers,
    type: q.Paragraph,
    description: "Long table of contents text",
    hasEndMarker: !1,
    children: void 0
  },
  toc2: {
    category: j.Headers,
    type: q.Paragraph,
    description: "Short table of contents text",
    hasEndMarker: !1,
    children: void 0
  },
  toc3: {
    category: j.Headers,
    type: q.Paragraph,
    description: "Book Abbreviation",
    hasEndMarker: !1,
    children: void 0
  },
  toca1: {
    category: j.Headers,
    type: q.Paragraph,
    description: "Alternative language long table of contents text",
    hasEndMarker: !1,
    children: void 0
  },
  toca2: {
    category: j.Headers,
    type: q.Paragraph,
    description: "Alternative language short table of contents text",
    hasEndMarker: !1,
    children: void 0
  },
  toca3: {
    category: j.Headers,
    type: q.Paragraph,
    description: "Alternative language book Abbreviation",
    hasEndMarker: !1,
    children: void 0
  },
  rem: {
    category: j.Remarks,
    type: q.Paragraph,
    description: "Comments and remarks",
    hasEndMarker: !1,
    children: void 0
  },
  sts: {
    category: j.Remarks,
    type: q.Paragraph,
    description: "Status of this file",
    hasEndMarker: !1,
    children: void 0
  },
  restore: {
    category: j.Remarks,
    type: q.Paragraph,
    description: "Project restore information",
    hasEndMarker: !1,
    children: void 0
  },
  imt: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction major title, level 1 (if single level) (basic)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imt1: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction major title, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imt2: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction major title, level 2",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imt3: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction major title, level 3",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imt4: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction major title, level 4 (usually within parenthesis)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imte: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction major title at introduction end, level 1 (if single level)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imte1: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction major title at introduction end, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imte2: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction major title at introduction end, level 2",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  is: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction section heading, level 1 (if single level) (basic)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"],
      CharacterStyling: ["no"]
    }
  },
  is1: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction section heading, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  is2: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction section heading, level 2",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  iot: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction outline title (basic)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CharacterStyling: ["no"]
    }
  },
  io: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction outline text, level 1 (if single level)",
    hasEndMarker: !1,
    children: {
      Introduction: ["ior", "iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  io1: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction outline text, level 1 (if multiple levels) (basic)",
    hasEndMarker: !1,
    children: {
      Introduction: ["ior", "iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  io2: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction outline text, level 2",
    hasEndMarker: !1,
    children: {
      Introduction: ["ior", "iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  io3: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction outline text, level 3",
    hasEndMarker: !1,
    children: {
      Introduction: ["ior", "iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  io4: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction outline text, level 4",
    hasEndMarker: !1,
    children: {
      Introduction: ["ior", "iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ior: {
    category: j.Introduction,
    type: q.Character,
    description: "Introduction references range for outline entry; for marking references separately",
    hasEndMarker: !0,
    children: void 0
  },
  ip: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction prose paragraph (basic)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  im: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction prose paragraph, with no first line indent (may occur after poetry)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ipi: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction prose paragraph, indented, with first line indent",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  imi: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction prose paragraph text, indented, with no first line indent",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ili: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "A list entry, level 1 (if single level)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ili1: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "A list entry, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ili2: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "A list entry, level 2",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ipq: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction prose paragraph, quote from the body text",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  imq: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction prose paragraph, quote from the body text, with no first line indent",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ipr: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction prose paragraph, right aligned",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ib: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction blank line",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"]
    }
  },
  iq: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction poetry text, level 1 (if single level)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  iq1: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction poetry text, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  iq2: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction poetry text, level 2",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  iq3: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction poetry text, level 3",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  iex: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction explanatory or bridge text (e.g. explanation of missing book in Short Old Testament)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CharacterStyling: ["no"]
    }
  },
  iqt: {
    category: j.Introduction,
    type: q.Character,
    description: "For quoted scripture text appearing in the introduction",
    hasEndMarker: !0,
    children: void 0
  },
  ie: {
    category: j.Introduction,
    type: q.Paragraph,
    description: "Introduction ending marker",
    hasEndMarker: !1,
    children: void 0
  },
  c: {
    category: j.DivisionMarks,
    type: q.Paragraph,
    description: "Chapter number",
    hasEndMarker: !1,
    children: {
      DivisionMarks: ["ca", "cp", "cl", "cd"],
      Paragraphs: ["p", "m", "po", "pr", "cls", "pi", "pi1", "pi2", "pi3", "pc", "mi", "nb"],
      Poetry: ["q", "q1", "q2", "q3", "q4", "qc", "qr", "qa", "qd", "b"],
      TitlesHeadings: [
        "mte",
        "ms",
        "ms1",
        "ms2",
        "ms3",
        "s",
        "s1",
        "s2",
        "s3",
        "s4",
        "r",
        "sp",
        "d",
        "sd",
        "sd1",
        "sd2",
        "sd3",
        "sd4"
      ],
      Lists: ["lh", "li", "li1", "li2", "li3", "li4", "lf", "lim", "lim1", "lim2", "lim3", "lim4"],
      Footnotes: ["f", "fe"],
      SpecialText: ["lit"],
      Breaks: ["pb"]
    }
  },
  ca: {
    category: j.DivisionMarks,
    type: q.Character,
    description: "Second (alternate) chapter number (for coding dual versification; useful for places where different traditions of chapter breaks need to be supported in the same translation)",
    hasEndMarker: !0,
    children: void 0
  },
  cp: {
    category: j.DivisionMarks,
    type: q.Paragraph,
    description: "Published chapter number (chapter string that should appear in the published text)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f"]
    }
  },
  cl: {
    category: j.DivisionMarks,
    type: q.Paragraph,
    description: "Chapter label used for translations that add a word such as 'Chapter' before chapter numbers (e.g. Psalms). The subsequent text is the chapter label.",
    hasEndMarker: !1,
    children: void 0
  },
  cd: {
    category: j.DivisionMarks,
    type: q.Paragraph,
    description: "Chapter Description (Publishing option D, e.g. in Russian Bibles)",
    hasEndMarker: !1,
    children: {
      DivisionMarks: ["vp"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  v: {
    category: j.DivisionMarks,
    type: q.Character,
    description: "A verse number",
    hasEndMarker: !1,
    children: void 0
  },
  va: {
    category: j.DivisionMarks,
    type: q.Character,
    description: "Second (alternate) verse number (for coding dual numeration in Psalms; see also NRSV Exo 22.1-4)",
    hasEndMarker: !0,
    children: void 0
  },
  vp: {
    category: j.DivisionMarks,
    type: q.Character,
    description: "Published verse marker (verse string that should appear in the published text)",
    hasEndMarker: !0,
    children: void 0
  },
  p: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Paragraph text, with first line indent (basic)",
    hasEndMarker: !1,
    children: {
      Paragraphs: ["pmo", "pm", "pmc", "pmr"],
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  m: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Paragraph text, with no first line indent (may occur after poetry) (basic)",
    hasEndMarker: !1,
    children: {
      Paragraphs: ["pmo", "pm", "pmc", "pmr"],
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  po: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Letter opening",
    hasEndMarker: !1,
    children: {
      Paragraphs: ["pmo", "pm", "pmc", "pmr"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pr: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Text refrain (paragraph text, right aligned)",
    hasEndMarker: !1,
    children: {
      Paragraphs: ["pmo", "pm", "pmc", "pmr"],
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  cls: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Letter Closing",
    hasEndMarker: !1,
    children: {
      SpecialText: ["tl", "sig", "pn", "png", "addpn", "add"]
    }
  },
  pmo: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Embedded text opening",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pm: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Embedded text paragraph",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pmc: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Embedded text closing",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pmr: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Embedded text refrain (e.g. Then all the people shall say, 'Amen!')",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pi: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Paragraph text, level 1 indent (if single level), with first line indent; often used for discourse (basic)",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pi1: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Paragraph text, level 1 indent (if multiple levels), with first line indent; often used for discourse",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pi2: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Paragraph text, level 2 indent, with first line indent; often used for discourse",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pi3: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Paragraph text, level 3 indent, with first line indent; often used for discourse",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pc: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Paragraph text, centered (for Inscription)",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  mi: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Paragraph text, indented, with no first line indent; often used for discourse",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  nb: {
    category: j.Paragraphs,
    type: q.Paragraph,
    description: "Paragraph text, with no break from previous paragraph text (at chapter boundary) (basic)",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  q: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text, level 1 indent (if single level)",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  q1: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text, level 1 indent (if multiple levels) (basic)",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  q2: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text, level 2 indent (basic)",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  q3: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text, level 3 indent",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  q4: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text, level 4 indent",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qc: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text, centered",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qr: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text, Right Aligned",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qs: {
    category: j.Poetry,
    type: q.Character,
    description: "Poetry text, Selah",
    hasEndMarker: !0,
    children: {
      Footnotes: ["f"],
      CrossReferences: ["x"]
    }
  },
  qa: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text, Acrostic marker/heading",
    hasEndMarker: !1,
    children: void 0
  },
  qac: {
    category: j.Poetry,
    type: q.Character,
    description: "Poetry text, Acrostic markup of the first character of a line of acrostic poetry",
    hasEndMarker: !0,
    children: void 0
  },
  qm: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text, embedded, level 1 indent (if single level)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qm1: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text, embedded, level 1 indent (if multiple levels)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qm2: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text, embedded, level 2 indent",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qm3: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text, embedded, level 3 indent",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qd: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "A Hebrew musical performance annotation, similar in content to Hebrew descriptive title.",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  b: {
    category: j.Poetry,
    type: q.Paragraph,
    description: "Poetry text stanza break (e.g. stanza break) (basic)",
    hasEndMarker: !1,
    children: void 0
  },
  mt: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "The main title of the book (if single level)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f"],
      CrossReferences: ["x"]
    }
  },
  mt1: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "The main title of the book (if multiple levels) (basic)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f"],
      CrossReferences: ["x"]
    }
  },
  mt2: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A secondary title usually occurring before the main title (basic)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f"],
      CrossReferences: ["x"]
    }
  },
  mt3: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A secondary title occurring after the main title",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f"],
      CrossReferences: ["x"]
    }
  },
  mt4: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A small secondary title sometimes occurring within parentheses",
    hasEndMarker: !1,
    children: void 0
  },
  mte: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "The main title of the book repeated at the end of the book, level 1 (if single level)",
    hasEndMarker: !1,
    children: void 0
  },
  mte1: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "The main title of the book repeated at the end of the book, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte2"]
    }
  },
  mte2: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A secondary title occurring before or after the 'ending' main title",
    hasEndMarker: !1,
    children: void 0
  },
  ms: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A major section division heading, level 1 (if single level) (basic)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mr"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ms1: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A major section division heading, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mr"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ms2: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A major section division heading, level 2",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mr"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ms3: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A major section division heading, level 3",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mr"],
      Footnotes: ["f", "fe"]
    }
  },
  mr: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A major section division references range heading (basic)",
    hasEndMarker: !1,
    children: void 0
  },
  s: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A section heading, level 1 (if single level) (basic)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["sr", "r"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  s1: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A section heading, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["sr", "r"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  s2: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A section heading, level 2 (e.g. Proverbs 22-24)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["sr", "r"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  s3: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A section heading, level 3 (e.g. Genesis 'The First Day')",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["sr", "r"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  s4: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A section heading, level 4",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["sr", "r"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  sr: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A section division references range heading",
    hasEndMarker: !1,
    children: void 0
  },
  r: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "Parallel reference(s) (basic)",
    hasEndMarker: !1,
    children: void 0
  },
  sp: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A heading, to identify the speaker (e.g. Job)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  d: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "A Hebrew text heading, to provide description (e.g. Psalms)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  sd: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "Vertical space used to divide the text into sections, level 1 (if single level)",
    hasEndMarker: !1,
    children: void 0
  },
  sd1: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "Vertical space used to divide the text into sections, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: void 0
  },
  sd2: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "Vertical space used to divide the text into sections, level 2",
    hasEndMarker: !1,
    children: void 0
  },
  sd3: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "Vertical space used to divide the text into sections, level 3",
    hasEndMarker: !1,
    children: void 0
  },
  sd4: {
    category: j.TitlesHeadings,
    type: q.Paragraph,
    description: "Vertical space used to divide the text into sections, level 4",
    hasEndMarker: !1,
    children: void 0
  },
  lh: {
    category: j.Lists,
    type: q.Paragraph,
    description: "List header (introductory remark)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  li: {
    category: j.Lists,
    type: q.Paragraph,
    description: "A list entry, level 1 (if single level)",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  li1: {
    category: j.Lists,
    type: q.Paragraph,
    description: "A list entry, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  li2: {
    category: j.Lists,
    type: q.Paragraph,
    description: "A list entry, level 2",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  li3: {
    category: j.Lists,
    type: q.Paragraph,
    description: "A list entry, level 3",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  li4: {
    category: j.Lists,
    type: q.Paragraph,
    description: "A list entry, level 4",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  lf: {
    category: j.Lists,
    type: q.Paragraph,
    description: "List footer (concluding remark)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  lim: {
    category: j.Lists,
    type: q.Paragraph,
    description: "An embedded list entry, level 1 (if single level)",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  lim1: {
    category: j.Lists,
    type: q.Paragraph,
    description: "An embedded list entry, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  lim2: {
    category: j.Lists,
    type: q.Paragraph,
    description: "An embedded list entry, level 2",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  lim3: {
    category: j.Lists,
    type: q.Paragraph,
    description: "An embedded list item, level 3",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  lim4: {
    category: j.Lists,
    type: q.Paragraph,
    description: "An embedded list entry, level 4",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  litl: {
    category: j.Lists,
    type: q.Character,
    description: "List entry total text",
    hasEndMarker: !0,
    children: void 0
  },
  lik: {
    category: j.Lists,
    type: q.Character,
    description: "Structured list entry key text",
    hasEndMarker: !0,
    children: void 0
  },
  liv: {
    category: j.Lists,
    type: q.Character,
    description: "Structured list entry value 1 content (if single value)",
    hasEndMarker: !0,
    children: void 0
  },
  liv1: {
    category: j.Lists,
    type: q.Character,
    description: "Structured list entry value 1 content (if multiple values)",
    hasEndMarker: !0,
    children: void 0
  },
  liv2: {
    category: j.Lists,
    type: q.Character,
    description: "Structured list entry value 2 content",
    hasEndMarker: !0,
    children: void 0
  },
  liv3: {
    category: j.Lists,
    type: q.Character,
    description: "Structured list entry value 3 content",
    hasEndMarker: !0,
    children: void 0
  },
  liv4: {
    category: j.Lists,
    type: q.Character,
    description: "Structured list entry value 4 content",
    hasEndMarker: !0,
    children: void 0
  },
  liv5: {
    category: j.Lists,
    type: q.Character,
    description: "Structured list entry value 5 content",
    hasEndMarker: !0,
    children: void 0
  },
  f: {
    category: j.Footnotes,
    type: q.Note,
    description: "A Footnote text item (basic)",
    hasEndMarker: !0,
    children: {
      Footnotes: ["fr", "ft", "fk", "fq", "fqa", "fl", "fw", "fp", "fv", "fdc"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  fe: {
    category: j.Footnotes,
    type: q.Note,
    description: "An Endnote text item",
    hasEndMarker: !0,
    children: {
      Footnotes: ["fr", "ft", "fk", "fq", "fqa", "fl", "fw", "fp", "fv", "fdc"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  fr: {
    category: j.Footnotes,
    type: q.Character,
    description: "The origin reference for the footnote (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  ft: {
    category: j.Footnotes,
    type: q.Character,
    description: "Footnote text, Protocanon (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  fk: {
    category: j.Footnotes,
    type: q.Character,
    description: "A footnote keyword (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  fq: {
    category: j.Footnotes,
    type: q.Character,
    description: "A footnote scripture quote or alternate rendering (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  fqa: {
    category: j.Footnotes,
    type: q.Character,
    description: "A footnote alternate rendering for a portion of scripture text",
    hasEndMarker: !0,
    children: void 0
  },
  fl: {
    category: j.Footnotes,
    type: q.Character,
    description: "A footnote label text item, for marking or 'labelling' the type or alternate translation being provided in the note.",
    hasEndMarker: !0,
    children: void 0
  },
  fw: {
    category: j.Footnotes,
    type: q.Character,
    description: "A footnote witness list, for distinguishing a list of sigla representing witnesses in critical editions.",
    hasEndMarker: !0,
    children: void 0
  },
  fp: {
    category: j.Footnotes,
    type: q.Character,
    description: "A Footnote additional paragraph marker",
    hasEndMarker: !0,
    children: void 0
  },
  fv: {
    category: j.Footnotes,
    type: q.Character,
    description: "A verse number within the footnote text",
    hasEndMarker: !0,
    children: void 0
  },
  fdc: {
    category: j.Footnotes,
    type: q.Character,
    description: "Footnote text, applies to Deuterocanon only",
    hasEndMarker: !0,
    children: void 0
  },
  fm: {
    category: j.Footnotes,
    type: q.Character,
    description: "An additional footnote marker location for a previous footnote",
    hasEndMarker: !0,
    children: void 0
  },
  x: {
    category: j.CrossReferences,
    type: q.Note,
    description: "A list of cross references (basic)",
    hasEndMarker: !0,
    children: {
      CrossReferences: ["xo", "xop", "xt", "xta", "xk", "xq", "xot", "xnt", "xdc"],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  xo: {
    category: j.CrossReferences,
    type: q.Character,
    description: "The cross reference origin reference (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  xop: {
    category: j.CrossReferences,
    type: q.Character,
    description: "Published cross reference origin reference (origin reference that should appear in the published text)",
    hasEndMarker: !0,
    children: void 0
  },
  xt: {
    category: j.CrossReferences,
    type: q.Character,
    description: "The cross reference target reference(s), protocanon only (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  xta: {
    category: j.CrossReferences,
    type: q.Character,
    description: "Cross reference target references added text",
    hasEndMarker: !0,
    children: void 0
  },
  xk: {
    category: j.CrossReferences,
    type: q.Character,
    description: "A cross reference keyword",
    hasEndMarker: !0,
    children: void 0
  },
  xq: {
    category: j.CrossReferences,
    type: q.Character,
    description: "A cross-reference quotation from the scripture text",
    hasEndMarker: !0,
    children: void 0
  },
  xot: {
    category: j.CrossReferences,
    type: q.Character,
    description: "Cross-reference target reference(s), Old Testament only",
    hasEndMarker: !0,
    children: void 0
  },
  xnt: {
    category: j.CrossReferences,
    type: q.Character,
    description: "Cross-reference target reference(s), New Testament only",
    hasEndMarker: !0,
    children: void 0
  },
  xdc: {
    category: j.CrossReferences,
    type: q.Character,
    description: "Cross-reference target reference(s), Deuterocanon only",
    hasEndMarker: !0,
    children: void 0
  },
  rq: {
    category: j.CrossReferences,
    type: q.Character,
    description: "A cross-reference indicating the source text for the preceding quotation.",
    hasEndMarker: !0,
    children: void 0
  },
  qt: {
    category: j.SpecialText,
    type: q.Character,
    description: "For Old Testament quoted text appearing in the New Testament (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  nd: {
    category: j.SpecialText,
    type: q.Character,
    description: "For name of deity (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  tl: {
    category: j.SpecialText,
    type: q.Character,
    description: "For transliterated words",
    hasEndMarker: !0,
    children: void 0
  },
  dc: {
    category: j.SpecialText,
    type: q.Character,
    description: "Deuterocanonical/LXX additions or insertions in the Protocanonical text",
    hasEndMarker: !0,
    children: void 0
  },
  bk: {
    category: j.SpecialText,
    type: q.Character,
    description: "For the quoted name of a book",
    hasEndMarker: !0,
    children: void 0
  },
  sig: {
    category: j.SpecialText,
    type: q.Character,
    description: "For the signature of the author of an Epistle",
    hasEndMarker: !0,
    children: void 0
  },
  pn: {
    category: j.SpecialText,
    type: q.Character,
    description: "For a proper name",
    hasEndMarker: !0,
    children: void 0
  },
  png: {
    category: j.SpecialText,
    type: q.Character,
    description: "For a geographic proper name",
    hasEndMarker: !0,
    children: void 0
  },
  addpn: {
    category: j.SpecialText,
    type: q.Character,
    description: "For chinese words to be dot underline & underline",
    hasEndMarker: !0,
    children: void 0
  },
  wj: {
    category: j.SpecialText,
    type: q.Character,
    description: "For marking the words of Jesus",
    hasEndMarker: !0,
    children: void 0
  },
  k: {
    category: j.SpecialText,
    type: q.Character,
    description: "For a keyword",
    hasEndMarker: !0,
    children: void 0
  },
  sls: {
    category: j.SpecialText,
    type: q.Character,
    description: "To represent where the original text is in a secondary language or from an alternate text source",
    hasEndMarker: !0,
    children: void 0
  },
  ord: {
    category: j.SpecialText,
    type: q.Character,
    description: "For the text portion of an ordinal number",
    hasEndMarker: !0,
    children: void 0
  },
  add: {
    category: j.SpecialText,
    type: q.Character,
    description: "For a translational addition to the text",
    hasEndMarker: !0,
    children: void 0
  },
  lit: {
    category: j.SpecialText,
    type: q.Paragraph,
    description: "For a comment or note inserted for liturgical use",
    hasEndMarker: !1,
    children: void 0
  },
  no: {
    category: j.CharacterStyling,
    type: q.Character,
    description: "A character style, use normal text",
    hasEndMarker: !0,
    children: void 0
  },
  it: {
    category: j.CharacterStyling,
    type: q.Character,
    description: "A character style, use italic text",
    hasEndMarker: !0,
    children: void 0
  },
  bd: {
    category: j.CharacterStyling,
    type: q.Character,
    description: "A character style, use bold text",
    hasEndMarker: !0,
    children: void 0
  },
  bdit: {
    category: j.CharacterStyling,
    type: q.Character,
    description: "A character style, use bold + italic text",
    hasEndMarker: !0,
    children: void 0
  },
  em: {
    category: j.CharacterStyling,
    type: q.Character,
    description: "A character style, use emphasized text style",
    hasEndMarker: !0,
    children: void 0
  },
  sc: {
    category: j.CharacterStyling,
    type: q.Character,
    description: "A character style, for small capitalization text",
    hasEndMarker: !0,
    children: void 0
  },
  sup: {
    category: j.CharacterStyling,
    type: q.Character,
    description: "A character style, for superscript text. Typically for use in critical edition footnotes.",
    hasEndMarker: !0,
    children: void 0
  },
  pb: {
    category: j.Breaks,
    type: q.Paragraph,
    description: "Page Break used for new reader portions and children's bibles where content is controlled by the page",
    hasEndMarker: !1,
    children: void 0
  }
}, go = {
  DivisionMarks: { add: ["v", "c"], remove: [] },
  Paragraphs: { add: ["p"], remove: [] },
  Poetry: { add: ["q", "q1", "q2", "q3", "q4", "b"], remove: [] },
  TitlesHeadings: {
    add: [
      "mte",
      "ms",
      "ms1",
      "ms2",
      "ms3",
      "s",
      "s1",
      "s2",
      "s3",
      "s4",
      "r",
      "sp",
      "d",
      "sd",
      "sd1",
      "sd2",
      "sd3",
      "sd4"
    ],
    remove: []
  }
}, zN = {
  p: { children: go },
  q: { children: go },
  q1: { children: go },
  q2: { children: go },
  q3: { children: go },
  q4: { children: go },
  b: { children: go },
  qm: {
    children: {
      Paragraphs: { add: ["p"], remove: [] }
    }
  },
  c: {
    type: q.Paragraph,
    children: null
  },
  v: {
    children: null
  }
};
function Nh(t) {
  const e = HN[t], n = zN[t];
  if (!e)
    return;
  if (!n)
    return e;
  let r = e.children ? { ...e.children } : void 0;
  if (n.children === null && (r = void 0), n.children) {
    r = r || {};
    for (const [o, i] of Object.entries(n.children)) {
      const s = o;
      if (i === null)
        Reflect.deleteProperty(r, s);
      else {
        let a = r[s] || [];
        i.remove && (a = a.filter((l) => !i.remove.includes(l))), i.add && (a = [.../* @__PURE__ */ new Set([...a, ...i.add])]), a.length > 0 ? r[s] = a : Reflect.deleteProperty(r, s);
      }
    }
    Object.keys(r).length === 0 && (r = void 0);
  }
  return {
    ...e,
    ...n,
    children: r
  };
}
function Th(t, e, n) {
  const r = {
    type: ks,
    version: Ns,
    content: t
  }, o = e.serializeEditorState(r, n);
  return Yd(o.root.children[0]) ? o.root.children[0].children[0] : o.root.children[0];
}
function Fu(t, e) {
  if (!t || !xe(t))
    return [void 0, void 0];
  const n = t.getTextContent();
  if (e >= 0 && e < n.length)
    return [t, e];
  let r = t.getNextSibling();
  if (!r) {
    const i = t.getParent();
    zt(i) && (r = i.getNextSibling());
  }
  if (!r || !zt(r) && !xe(r))
    return [void 0, void 0];
  const o = e - n.length;
  return r && xe(r) ? Fu(r, o) : Fu(r.getFirstChild() ?? void 0, o);
}
function Ah(t) {
  const e = i1(t.jsonPath);
  let n = tt();
  for (const r of e) {
    if (!n || !Ae(n))
      return [void 0, void 0];
    n = n.getChildAtIndex(r) ?? void 0;
  }
  return Fu(n, t.offset);
}
function Sh(t) {
  return Ae(t) ? "element" : "text";
}
function ap(t) {
  const { start: e } = t;
  let { end: n } = t;
  n === void 0 && (n = e);
  const [r, o] = Ah(e), [i, s] = Ah(n);
  if (!r || !i || o === void 0 || s === void 0)
    return;
  const a = vl();
  return a.anchor = Mp(r.getKey(), o, Sh(r)), a.focus = Mp(i.getKey(), s, Sh(i)), a;
}
function Dh(t, e) {
  const n = [];
  let r = t;
  for (; r != null && r.getParent(); ) {
    const o = r.getParent();
    if (o) {
      const i = o == null ? void 0 : o.getChildren().indexOf(r);
      i >= 0 && n.unshift(i);
    }
    r = o;
  }
  return { jsonPath: s1(n), offset: e };
}
function Pb() {
  const t = ve();
  if (!t || !me(t))
    return;
  const e = t.isBackward() ? t.focus.getNode() : t.anchor.getNode(), n = t.isBackward() ? t.focus.offset : t.anchor.offset, r = Dh(e, n);
  if (t.isCollapsed())
    return { start: r };
  const o = t.isBackward() ? t.anchor.getNode() : t.focus.getNode(), i = t.isBackward() ? t.anchor.offset : t.focus.offset, s = Dh(o, i);
  return { start: r, end: s };
}
const $b = "v", Fb = 1;
class sn extends Vo {
  constructor(e = "", n = !1, r, o, i, s, a) {
    super(a), fe(this, "__marker"), fe(this, "__number"), fe(this, "__showMarker"), fe(this, "__sid"), fe(this, "__altnumber"), fe(this, "__pubnumber"), fe(this, "__unknownAttributes"), this.__marker = $b, this.__number = e, this.__showMarker = n, this.__sid = r, this.__altnumber = o, this.__pubnumber = i, this.__unknownAttributes = s;
  }
  static getType() {
    return "immutable-verse";
  }
  static clone(e) {
    const { __number: n, __showMarker: r, __sid: o, __altnumber: i, __pubnumber: s, __unknownAttributes: a, __key: l } = e;
    return new sn(n, r, o, i, s, a, l);
  }
  static importDOM() {
    return {
      span: (e) => KN(e) ? {
        conversion: GN,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return lp().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setNumber(e.number).setShowMarker(e.showMarker).setSid(e.sid).setAltnumber(e.altnumber).setPubnumber(e.pubnumber).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setNumber(e) {
    if (this.__number === e)
      return this;
    const n = this.getWritable();
    return n.__number = e, n;
  }
  getNumber() {
    return this.getLatest().__number;
  }
  setShowMarker(e = !1) {
    if (this.__showMarker === e)
      return this;
    const n = this.getWritable();
    return n.__showMarker = e, n;
  }
  getShowMarker() {
    return this.getLatest().__showMarker;
  }
  setSid(e) {
    if (this.__sid === e)
      return this;
    const n = this.getWritable();
    return n.__sid = e, n;
  }
  getSid() {
    return this.getLatest().__sid;
  }
  setAltnumber(e) {
    if (this.__altnumber === e)
      return this;
    const n = this.getWritable();
    return n.__altnumber = e, n;
  }
  getAltnumber() {
    return this.getLatest().__altnumber;
  }
  setPubnumber(e) {
    if (this.__pubnumber === e)
      return this;
    const n = this.getWritable();
    return n.__pubnumber = e, n;
  }
  getPubnumber() {
    return this.getLatest().__pubnumber;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.setAttribute("data-marker", this.__marker), e.classList.add(Ru, `usfm_${this.__marker}`), this.__showMarker && e.classList.add("marker"), e.setAttribute("data-number", this.__number), e;
  }
  updateDOM() {
    return !1;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && vr(n) && (n.setAttribute("data-marker", this.getMarker()), n.classList.add(Ru, `usfm_${this.getMarker()}`), n.setAttribute("data-number", this.getNumber())), { element: n };
  }
  decorate() {
    return d("span", { children: this.getShowMarker() ? ta(this.getMarker(), this.getNumber()) : (
      // ZWSP added so double click word selection works without including this number.
      Ou + this.getNumber() + Ou
    ) });
  }
  exportJSON() {
    return {
      type: this.getType(),
      marker: this.getMarker(),
      number: this.getNumber(),
      showMarker: this.getShowMarker(),
      sid: this.getSid(),
      altnumber: this.getAltnumber(),
      pubnumber: this.getPubnumber(),
      unknownAttributes: this.getUnknownAttributes(),
      version: Fb
    };
  }
  // Mutation
  isKeyboardSelectable() {
    return !1;
  }
}
function GN(t) {
  const e = t.getAttribute("data-number") ?? "0";
  return { node: lp(e) };
}
function lp(t, e, n, r, o, i) {
  return Mt(new sn(t, e, n, r, o, i));
}
function KN(t) {
  return ((t == null ? void 0 : t.getAttribute("data-marker")) ?? void 0) === $b;
}
function Hi(t) {
  return t instanceof sn;
}
function WN(t) {
  return (t == null ? void 0 : t.type) === sn.getType();
}
function Rn(t) {
  return ep(t) || Hi(t);
}
function JN(t) {
  return mN(t) || WN(t);
}
function XN(t, e, n, r, o, i, s) {
  if (!$t.isValidMarker(t))
    throw new Error(`$insertNote: Invalid note marker '${t}'`);
  const a = n ? ap(n) : ve();
  if (!me(a))
    return;
  const l = YN(a, t, r, s);
  if (l === void 0)
    return;
  const c = qb(t, e, l, o, i);
  return Bb(c, a, o), c;
}
function Bb(t, e, n) {
  const r = (n == null ? void 0 : n.noteMode) === "collapsed";
  if (t.setIsCollapsed(r), e.isCollapsed() || NN(e), e.insertNodes([t]), !r) {
    const o = t.getChildren().reverse().find(et);
    o == null || o.selectEnd();
  }
}
function YN(t, e, n, r) {
  const o = [], { chapterNum: i, verseNum: s } = n ?? {};
  switch (e) {
    case "f":
    case "fe":
    case "ef":
    case "efe":
      if (i !== void 0 && s !== void 0 && o.push(cr("fr").append(pt(`${i}:${s}`))), !t.isCollapsed()) {
        const a = t.getTextContent().trim();
        if (a.length > 0) {
          const l = cr("fq");
          l.append(pt(a)), o.push(l);
        }
      }
      o.push(cr("ft").append(pt("-")));
      break;
    case "x":
    case "ex":
      i !== void 0 && s !== void 0 && o.push(cr("xo").append(pt(`${i}:${s}`))), o.push(cr("xt").append(pt("-")));
      break;
    default:
      r == null || r.warn(`$createNoteChildren: Unsupported note marker '${e}'`);
      return;
  }
  return o;
}
function qb(t, e, n, r, o, i) {
  const s = (r == null ? void 0 : r.noteMode) !== "expanded", a = Zd(t, e, s);
  i && Nr(a, Io, () => i);
  let l, c;
  (r == null ? void 0 : r.markerMode) === "editable" ? (l = Ni(t), c = Ni(t, "closing")) : (r == null ? void 0 : r.markerMode) === "visible" && (l = Ti("marker", Pr(t) + Ze), c = Ti("marker", ki(t) + Ze));
  let u;
  if (l && a.append(l), (r == null ? void 0 : r.markerMode) === "editable")
    e === "" ? a.append(...n) : (u = pt(rp(a.__caller)), a.append(u, ...n));
  else {
    const p = () => pt(Ze), f = n.flatMap(ZN(p));
    if (e === "")
      a.append(...f);
    else {
      const h = op(n);
      let g = () => {
      };
      o != null && o.noteCallerOnClick && (g = o.noteCallerOnClick), u = pp(a.__caller, h, g), a.append(u, p(), ...f);
    }
  }
  return c && a.append(c), a;
}
function Mh(t) {
  var e;
  if (typeof t == "string") {
    const o = it(t);
    return Le(o) ? o : void 0;
  }
  const n = Js();
  if (n.length <= 0)
    return;
  const r = (e = n.filter((o) => Le(o.node))[t]) == null ? void 0 : e.node;
  if (Le(r))
    return r;
}
function QN(t, e) {
  const n = (e == null ? void 0 : e.noteMode) === "collapsed";
  if (t.setIsCollapsed(n), n) {
    const r = t.getPreviousSibling();
    if (Hi(r) || !r) {
      const o = t.getParent();
      if (o) {
        const i = t.getIndexWithinParent();
        o.select(i, i);
      }
    } else
      r.selectEnd();
  } else {
    const r = t.getChildren().reverse().find(et);
    r == null || r.selectEnd();
  }
}
function ZN(t) {
  return (e) => ll(e) ? [e] : [e, t()];
}
function eT(t) {
  return t.find((e) => Yt(e));
}
function tT(t, e) {
  return Ae(t) ? t.getChildren().find((n) => Rn(n) && ip(e, n.getNumber())) : void 0;
}
function nT(t, e) {
  return e === 0 ? eT(t) : t.map((n) => tT(n, e)).filter((n) => n)[0];
}
function Oh(t) {
  return !t || !Ae(t) ? void 0 : t.getChildren().findLast((e) => Rn(e));
}
function jb(t) {
  var e, n;
  if (!t || On(t))
    return;
  if (Rn(t))
    return t;
  let r = zt(t.getParent()) ? (e = t.getParent()) == null ? void 0 : e.getPreviousSibling() : t.getPreviousSibling();
  for (; r && !Rn(r) && !On(r); )
    r = r.getPreviousSibling();
  if (r && Rn(r))
    return r;
  let o = (n = t.getTopLevelElement()) == null ? void 0 : n.getPreviousSibling(), i = Oh(o), s = i;
  for (; o && !i && !On(o); )
    i = s, o = o.getPreviousSibling(), s = Oh(o);
  if (!(!i && On(o)))
    return i;
}
function rT(t) {
  return xN(t) || Hi(t);
}
function cp(t) {
  if (xe(t)) {
    const e = t.getTextContent();
    !e.endsWith(" ") && !e.endsWith(Ze) && t.setTextContent(`${e} `);
  }
}
function Ub(t) {
  if (xe(t)) {
    const e = t.getTextContent();
    e.startsWith(" ") && t.setTextContent(e.trimStart());
  }
}
function up(t, e) {
  return t.getEditorState().read(() => !it(e));
}
const oT = ["style"], iT = ["style", "code"], ul = ["style", "cid"], sT = [
  "style",
  "number",
  "sid",
  "altnumber",
  "pubnumber"
], aT = [
  "style",
  "number",
  "sid",
  "altnumber",
  "pubnumber"
], lT = ["style", "sid", "eid"], cT = ["style", "caller", "category", "contents"], uT = [
  "chapter",
  "immutable-chapter",
  "verse",
  "immutable-verse",
  "ms",
  "note",
  "unmatched"
], Fs = `
`;
function dT(t, e) {
  const n = it(t);
  if (!Xn(n))
    return;
  const r = Vb(n);
  return r === void 0 ? void 0 : [{ retain: r }, ...e, { delete: 1 }];
}
function Vb(t) {
  if (!t)
    return;
  const e = Js();
  let n = 0;
  const r = [];
  let o, i;
  const s = t.getKey();
  let a;
  for (const l of e) {
    const c = l.node;
    for (let u = r.length - 1; u >= 0; u--)
      if (Bs(r[u], l)) {
        const p = r[u];
        if (r.splice(u, 1), n += 1, a && p.getKey() === a.getKey())
          return n - 1;
      }
    if (o && Bs(o, l) && (o = void 0, i = void 0), o) {
      if (c.getKey() === s)
        return i;
      continue;
    }
    if (c.getKey() === s) {
      if (xe(c) || Xn(c))
        return n;
      Ln(c) && (a = c);
    }
    if (Ln(c) && (r.includes(c) || r.push(c)), Le(c)) {
      o = c, i = n, n += 1;
      continue;
    }
    n += Hb(c);
  }
  if (a)
    return n;
}
function Rh(t, e) {
  if (t.length < 2 || !hT(t[0]) || !fT(t[1]))
    return;
  const n = t[0].retain;
  return e.read(() => {
    const r = pT(n);
    return r == null ? void 0 : r.getKey();
  });
}
function pT(t) {
  const e = Js();
  let n = 0;
  const r = [];
  let o, i;
  for (const s of e) {
    const a = s.node;
    for (let c = r.length - 1; c >= 0; c--)
      if (Bs(r[c], s)) {
        const u = r[c];
        if (r.splice(c, 1), n === t)
          return u;
        n += 1;
      }
    if (o && Bs(o, s) && (o = void 0, i = void 0), o) {
      if (i === t)
        return o;
      continue;
    }
    if (Ln(a) && (r.includes(a) || r.push(a)), Le(a)) {
      if (o = a, i = n, n === t)
        return a;
      n += 1;
      continue;
    }
    const l = Hb(a);
    if (xe(a) && l > 0 && t >= n && t < n + l || Xn(a) && n === t)
      return a;
    n += l;
  }
  for (const s of r) {
    if (n === t)
      return s;
    n += 1;
  }
}
function Bs(t, e) {
  return t ? e ? !EN(e.node, t.getKey()) : !0 : !1;
}
function Xn(t) {
  return On(t) || Rn(t) || Gl(t) || Le(t) || Lb(t);
}
function Ln(t) {
  return Vn(t) || wr(t);
}
function ts(t, e) {
  return e.insert != null && typeof e.insert == "object" && t in e.insert;
}
function fT(t) {
  if (t.insert == null || typeof t.insert != "object")
    return !1;
  const e = Object.keys(t.insert)[0];
  return t.insert != null && typeof t.insert == "object" && e in t.insert && uT.includes(e);
}
function hT(t) {
  return t.retain != null && typeof t.retain == "number";
}
function Hb(t) {
  return xe(t) ? t.getTextContentSize() : Xn(t) ? 1 : 0;
}
function Bu(t, e) {
  const n = { insert: t.__text }, r = bs(t, Io);
  if (r && (n.attributes = { segment: r }), e && e.length > 0) {
    let o = e.map((i) => {
      const s = { style: i.__marker }, a = bs(i, Ro);
      a && (s.cid = a);
      const l = i.getUnknownAttributes();
      return l && Object.keys(l).length > 0 && Object.assign(s, l), s;
    });
    o.length === 1 && (o = o[0]), n.attributes = {
      ...n.attributes,
      char: o
    };
  }
  return n;
}
function Ih(t) {
  const e = new cs();
  return t.isEmpty() || t.read(() => {
    const n = tt();
    if (!n || n.isEmpty())
      return;
    const r = n.getChildren();
    if (r.length === 1 && Mr(r[0]) && (!r[0].getChildren() || r[0].getChildrenSize() === 0))
      return;
    const o = wT();
    for (const i of o)
      e.push(i);
  }), e;
}
function dp(t, e) {
  const n = [], r = Js(t), o = [], i = [], s = { children: [], contentsOps: [] };
  for (let a = 0; a < r.length; a++) {
    const l = r[a].node;
    n.push(...Lh(l, a, r, o, i, s));
  }
  for (const a of o)
    n.push(...Lh(a, r.length, r, o, i, s));
  return n;
}
function wT() {
  return dp();
}
function Lh(t, e, n, r, o, i) {
  if (!t)
    return [];
  const s = [];
  return gT(t, s, r), mT(t, s, o, i), bT(t, e, n, o), On(t) && s.push(xT(t)), Rn(t) && s.push(CT(t)), Gl(t) && s.push(ET(t)), Lb(t) && s.push(kT(t)), vT(t, s, i), s;
}
function gT(t, e, n) {
  if (!t.isInline()) {
    const r = n.pop();
    wr(r) ? e.push(yT(r)) : Yt(r) ? e.push(_T(r)) : Mr(r) && e.push({ insert: Fs });
  }
  Ln(t) && (n.includes(t) || n.push(t));
}
function mT(t, e, n, r) {
  var o;
  if (!xe(t))
    return;
  const i = t.getParent();
  if (Le(i) && i.getFirstChild() === t)
    return;
  const s = Bu(t, n);
  if (r.children.includes(t)) {
    const a = t.getTextContent();
    if (!a || a === Ze || a.startsWith(Gd))
      return;
    (o = r.contentsOps) == null || o.push(s);
  } else
    e.push(s);
}
function bT(t, e, n, r) {
  et(t) && !r.includes(t) && r.push(t);
  const o = n[e + 1];
  for (const i of r.toReversed())
    Bs(i, o) && r.pop();
}
function vT(t, e, n) {
  var r, o;
  if (!Le(t))
    return;
  Js(t).forEach((s) => n.children.push(s.node));
  const i = NT(t);
  n.contentsOps = (o = (r = i.insert.note) == null ? void 0 : r.contents) == null ? void 0 : o.ops, e.push(i);
}
function yT(t) {
  const e = { style: Ls, code: t.__code };
  return { insert: Fs, attributes: { book: e } };
}
function xT(t) {
  const e = { style: sl, number: t.__number };
  return t.__sid && (e.sid = t.__sid), t.__altnumber && (e.altnumber = t.__altnumber), t.__pubnumber && (e.pubnumber = t.__pubnumber), { insert: { chapter: e } };
}
function _T(t) {
  const e = { style: t.__marker };
  return { insert: Fs, attributes: { para: e } };
}
function CT(t) {
  const e = { style: al, number: t.__number };
  return t.__sid && (e.sid = t.__sid), t.__altnumber && (e.altnumber = t.__altnumber), t.__pubnumber && (e.pubnumber = t.__pubnumber), { insert: { verse: e } };
}
function ET(t) {
  const e = { style: t.__marker };
  return t.__sid && (e.sid = t.__sid), t.__eid && (e.eid = t.__eid), { insert: { milestone: e } };
}
function kT(t) {
  return { insert: { unmatched: { marker: t.__marker } } };
}
function NT(t) {
  const e = {
    style: t.__marker,
    caller: t.__caller
  };
  t.__category && (e.category = t.__category), t.getChildrenSize() > 1 && (e.contents = { ops: [] });
  const n = { insert: { note: e } }, r = bs(t, Io);
  return r && (n.attributes = { segment: r }), n;
}
const zb = 1;
class Gn extends Vo {
  constructor(e = Lo, n = "", r, o) {
    super(o), fe(this, "__caller"), fe(this, "__previewText"), fe(this, "__onClick"), this.__caller = e, this.__previewText = n, this.__onClick = r ?? (() => {
    });
  }
  static getType() {
    return "immutable-note-caller";
  }
  static clone(e) {
    const { __caller: n, __previewText: r, __onClick: o, __key: i } = e;
    return new Gn(n, r, o, i);
  }
  static importDOM() {
    return {
      span: (e) => AT(e) ? {
        conversion: TT,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return pp().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setCaller(e.caller).setPreviewText(e.previewText).setOnClick(e.onClick);
  }
  setCaller(e) {
    if (this.__caller === e)
      return this;
    const n = this.getWritable();
    return n.__caller = e, n;
  }
  getCaller() {
    return this.getLatest().__caller;
  }
  setPreviewText(e) {
    if (this.__previewText === e)
      return this;
    const n = this.getWritable();
    return n.__previewText = e, n;
  }
  getPreviewText() {
    return this.getLatest().__previewText;
  }
  setOnClick(e) {
    if (this.__onClick === e)
      return this;
    const n = this.getWritable();
    return n.__onClick = e, n;
  }
  getOnClick() {
    return this.getLatest().__onClick;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.classList.add(this.__type), e.setAttribute("data-caller", this.__caller), e.setAttribute("data-preview-text", this.__previewText), e;
  }
  updateDOM(e) {
    return e.__caller !== this.__caller;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && vr(n) && (n.classList.add(this.getType()), n.setAttribute("data-caller", this.getCaller()), n.setAttribute("data-preview-text", this.getPreviewText())), { element: n };
  }
  decorate(e) {
    const n = this.getParent();
    if (!n)
      return null;
    const r = n.getKey(), o = n.getIsCollapsed(), i = this.__key, s = (l) => {
      var c;
      return (c = this.__onClick) == null ? void 0 : c.call(this, l, r, o, () => ST(e, r), (u) => DT(e, r, i, u), () => MT(e, r));
    }, a = `${this.__caller}_${this.__previewText}}`.replace(/\s+/g, "").substring(0, 25);
    return d("button", { onClick: s, title: this.__previewText, "data-caller-id": a, children: this.__caller === Lo && o ? (
      // Caller is generated by CSS
      ""
    ) : this.__caller });
  }
  exportJSON() {
    return {
      type: this.getType(),
      caller: this.getCaller(),
      previewText: this.getPreviewText(),
      onClick: this.getOnClick(),
      version: zb
    };
  }
  // Mutation
  isKeyboardSelectable() {
    return !1;
  }
}
function TT(t) {
  const e = t.getAttribute("data-caller") ?? "", n = t.getAttribute("data-preview-text") ?? "";
  return { node: pp(e, n) };
}
function pp(t, e, n) {
  return Mt(new Gn(t, e, n));
}
function AT(t) {
  return t ? t.classList.contains(Gn.getType()) : !1;
}
function co(t) {
  return t instanceof Gn;
}
function ST(t, e) {
  return t.read(() => {
    const n = it(e);
    if (!Le(n))
      throw new Error(`getNoteCaller: Note node not found: ${e}`);
    return n.getCaller();
  });
}
function DT(t, e, n, r) {
  t.update(() => {
    const o = it(e);
    if (!Le(o))
      throw new Error(`setNoteCaller: Note node not found: ${e}`);
    o.setCaller(r);
    const i = it(n);
    if (!co(i))
      throw new Error(`setNoteCaller: Caller node not found: ${n}`);
    i.setCaller(r);
  });
}
function MT(t, e) {
  return t.read(() => {
    const n = it(e);
    if (!Le(n))
      throw new Error(`getNoteOps: Note node not found: ${e}`);
    return dp(n);
  });
}
const OT = [
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z"
], RT = [
  Gn,
  sn,
  ...VN
], IT = an((t, e) => {
  const { coords: n, children: r, style: o, ...i } = t, s = n !== void 0;
  return d("div", { ref: e, className: "floating-box", "aria-hidden": !s, style: {
    ...o,
    position: "absolute",
    zIndex: 1e3,
    top: n == null ? void 0 : n.y,
    left: n == null ? void 0 : n.x,
    visibility: s ? "visible" : "hidden",
    opacity: s ? 1 : 0
  }, ...i, children: r });
});
function LT() {
  const [t, e] = oe(void 0), [n, r] = oe(), o = he(null), i = ce((a, l) => {
    o.current && o.current();
    const c = a.commonAncestorContainer.nodeType === a.commonAncestorContainer.TEXT_NODE ? a : a.commonAncestorContainer;
    o.current = DC(c, l, () => {
      RC(c, l, {
        placement: "bottom-start",
        middleware: [MC(), OC()]
      }).then((u) => {
        r(u.placement), e((p) => (p == null ? void 0 : p.x) === u.x && (p == null ? void 0 : p.y) === u.y ? p : { x: u.x, y: u.y });
      }).catch(() => {
        e(void 0);
      });
    });
  }, []), s = ce(() => {
    o.current && (e(void 0), o.current(), o.current = null);
  }, []);
  return ie(() => s, [s]), { coords: t, placement: n, updatePosition: i, cleanup: s };
}
function PT({ isOpen: t, floatingBoxRef: e }) {
  const { coords: n, updatePosition: r, cleanup: o, placement: i } = LT();
  return ie(() => {
    var s;
    if (!t || !e.current) {
      o();
      return;
    }
    const a = (s = window.getSelection()) == null ? void 0 : s.getRangeAt(0);
    if (!a) {
      o();
      return;
    }
    return r(a, e.current), o;
  }, [o, t, e, r]), { coords: n, placement: i };
}
const $T = document.body, FT = U0(IT);
function BT({ isOpen: t = !1, children: e }) {
  const n = he(null), { coords: r, placement: o } = PT({ isOpen: t, floatingBoxRef: n }), i = ue(() => r ? typeof e == "function" ? e : () => e : () => null, [e, r]);
  return ur(d(FT, { ref: n, coords: r, style: r ? void 0 : { display: "none" }, children: i({ isOpen: t, placement: o }) }), $T);
}
const Gb = Zr(void 0);
function fp() {
  const t = jo(Gb);
  if (!t)
    throw new Error("useMenuContext must be used within a MenuProvider");
  return t;
}
function qT(t, e) {
  const [n, r] = oe(0), [o, i] = oe(-1), s = ue(() => t ?? [], [t]), a = {
    menuItems: s,
    activeIndex: n,
    selectedIndex: o,
    onSelectOption: e ?? (() => {
    })
  }, l = ce(() => {
    r((p) => {
      const f = s.length;
      return f ? (p - 1 + f) % f : 0;
    });
  }, [s.length]), c = ce(() => {
    r((p) => {
      const f = s.length;
      return f ? (p + 1) % f : 0;
    });
  }, [s.length]), u = ce(() => {
    const p = s.length;
    if (n >= 0 && n < p) {
      const f = s[n];
      e == null || e(f), i(n);
    }
  }, [n, s, e]);
  return {
    state: a,
    moveUp: l,
    moveDown: c,
    select: u,
    setActiveIndex: r,
    setSelectedIndex: i
  };
}
function jT({ children: t, menuItems: e, onSelectOption: n, ...r }) {
  const o = qT(e, n);
  return d(Gb.Provider, { value: o, children: d("div", { ...r, children: t }) });
}
const Kb = an(({ index: t, children: e, onMouseEnter: n, onClick: r, ...o }, i) => {
  const { state: { activeIndex: s }, setActiveIndex: a, setSelectedIndex: l, select: c } = fp(), u = ce((f) => {
    c(), l(-1), r == null || r(f);
  }, [r, c, l]), p = ce((f) => {
    a(t), n == null || n(f);
  }, [t, a, n]);
  return d("button", { ref: i, role: "menuitem", ...o, onClick: u, onMouseEnter: p, "aria-selected": t !== void 0 && s === t ? "true" : void 0, tabIndex: -1, children: e });
});
function UT({ children: t, autoIndex: e = !0, ...n }) {
  const r = he(null), { state: { activeIndex: o, menuItems: i } } = fp(), s = ue(() => i ? typeof t == "function" ? t : () => t : () => null, [t, i]), a = ue(() => {
    const l = s(i);
    return e ? V0.map(l, (c, u) => z0(c) && c.type === Kb && c.props.index === void 0 ? H0(c, { index: u }) : c) : l;
  }, [s, e, i]);
  return ie(() => {
    if (r.current) {
      const l = r.current, c = l.children[o];
      if (c) {
        const u = l.getBoundingClientRect(), p = c.getBoundingClientRect();
        p.bottom > u.bottom ? l.scrollTop += p.bottom - u.bottom : p.top < u.top && (l.scrollTop -= u.top - p.top);
      }
    }
  }, [o]), d("div", { ref: r, role: "menu", ...n, children: a });
}
const jc = {
  Root: jT,
  Options: UT,
  Option: Kb
}, VT = (t, e, n) => Va(t, n).toLowerCase().includes(e.toLowerCase()), Ph = (t) => Object.keys(t).find((e) => typeof t[e] == "string") || "", Va = (t, e) => {
  const n = t[e];
  return typeof n == "string" ? n : String(n);
};
function HT(t) {
  const { query: e, items: n, filterBy: r, filter: o, sortBy: i, sortingOptions: s } = t, { caseSensitive: a = !1, priorityOrder: l = ["exact", "startsWith", "contains"] } = s || {}, c = a ? e : e.toLowerCase();
  let u, p;
  o ? (p = o, u = n.length > 0 ? Ph(n[0]) : "") : (u = r || (n.length > 0 ? Ph(n[0]) : ""), p = (g, b) => VT(g, b, u));
  const f = i || u, h = /* @__PURE__ */ new Map();
  return n.filter((g) => {
    try {
      return p(g, e);
    } catch (b) {
      return console.warn("Error filtering item:", g, b), !1;
    }
  }).sort((g, b) => {
    const _ = (A) => (h.has(A) || h.set(A, Va(A, f).toLowerCase()), h.get(A) ?? ""), x = a ? Va(g, f) : _(g), y = a ? Va(b, f) : _(b);
    for (const A of l)
      switch (A) {
        case "exact":
          if (x === c && y !== c)
            return -1;
          if (y === c && x !== c)
            return 1;
          break;
        case "startsWith":
          if (x.startsWith(c) && !y.startsWith(c))
            return -1;
          if (y.startsWith(c) && !x.startsWith(c))
            return 1;
          break;
        case "contains": {
          const P = x.indexOf(c), V = y.indexOf(c);
          if (P !== -1 && V === -1)
            return -1;
          if (V !== -1 && P === -1)
            return 1;
          if (P !== -1 && V !== -1)
            return P - V;
          break;
        }
      }
    return x.localeCompare(y);
  });
}
function zT(t) {
  const { query: e, items: n, filterBy: r, filter: o, sortBy: i, sortingOptions: s } = t;
  return ue(() => HT({
    query: e,
    items: n,
    filterBy: r,
    filter: o,
    sortBy: i,
    sortingOptions: s
  }), [e, n, r, o, i, s]);
}
function GT() {
  const { moveUp: t, moveDown: e, select: n } = fp();
  return ue(() => ({
    moveUp: t,
    moveDown: e,
    select: n
  }), [t, e, n]);
}
const KT = () => {
  const t = GT(), [e] = De();
  ie(() => {
    const n = (r) => {
      const o = {
        ArrowDown: () => t == null ? void 0 : t.moveDown(),
        ArrowUp: () => t == null ? void 0 : t.moveUp(),
        Enter: () => t == null ? void 0 : t.select(),
        Tab: () => t == null ? void 0 : t.select()
      }[r.key];
      return o ? (o(), r.preventDefault(), r.stopPropagation(), !0) : !1;
    };
    return e.registerCommand(Hs, n, Cl);
  }, [e, t]);
};
function WT() {
  return KT(), null;
}
function JT(t) {
  const { options: e, onSelectOption: n, onClose: r, inverse: o, query: i, menuOpenKey: s } = t, [a] = De(), l = i !== void 0, [c, u] = oe(""), p = l ? i ?? "" : c, f = zT({ query: p, items: e, filterBy: "name" }), h = (g) => {
    r == null || r(), n ? n(g) : g.action(a);
  };
  return ie(() => a.registerCommand(Hs, (g) => {
    if (l)
      return !1;
    const b = {
      Escape: () => r == null ? void 0 : r(),
      Backspace: () => {
        p.length === 0 ? r == null || r() : u((_) => _.slice(0, -1));
      }
    }[g.key];
    return b ? (g.stopPropagation(), g.preventDefault(), b(), !0) : g.key.length === 1 ? (g.stopPropagation(), g.preventDefault(), g.key !== s && u((_) => _ + g.key), !0) : !1;
  }, Cl), [a, l, p, s, r]), M(jc.Root, { className: `autocomplete-menu-container ${o ? "inverse" : ""}`, menuItems: f, onSelectOption: (g) => h(g), children: [!l && d("input", { value: p, type: "text", disabled: !0 }), d(WT, {}), d(jc.Options, { className: "autocomplete-menu-options", autoIndex: !1, children: (g) => g.map((b, _) => M(jc.Option, { index: _, children: [d("span", { className: "label", children: b.label ?? b.name }), d("span", { className: "description", children: b.description })] }, b.name)) })] });
}
function XT({ trigger: t, items: e }) {
  const [n] = De(), [r, o] = oe(!1), i = ce((s) => {
    s.key === "Escape" && r ? (o(!1), n.focus()) : s.key === t && !r && (s.preventDefault(), o(!0));
  }, [n, t, r]);
  return ie(() => n.registerRootListener((s) => {
    if (s)
      return s.addEventListener("keydown", i), () => {
        s.removeEventListener("keydown", i);
      };
  }), [n, i]), ie(() => n.registerUpdateListener(({ prevEditorState: s, editorState: a }) => {
    const l = s.read(() => {
      const c = ve();
      if (me(c))
        return c;
    });
    a.read(() => {
      const c = ve();
      !me(c) || l != null && l.is(c) || o(!1);
    });
  }), [n]), e && d(BT, { isOpen: r, children: ({ placement: s }) => d(JT, { options: e, onClose: () => o(!1), inverse: s === "top-start", menuOpenKey: t }) });
}
function YT({ scriptureReference: t, contextMarker: e, getMarkerAction: n }) {
  return { markersMenuItems: ue(() => {
    if (!e || !t)
      return;
    const r = Nh(e);
    if (r != null && r.children)
      return Object.values(r.children).flatMap((o) => o.map((i) => {
        const s = Nh(i), { action: a } = n(i, s);
        return {
          name: i,
          label: i,
          description: (s == null ? void 0 : s.description) ?? "",
          action: (l) => {
            a({ editor: l, reference: t });
          }
        };
      }));
  }, [e, n, t]) };
}
function Ha(t, e) {
  return `${t}:${e}`;
}
function QT(t, e) {
  ie(() => {
    if (!t.hasNodes([Vt]))
      throw new Error("AnnotationPlugin: TypedMarkNode not registered on editor!");
    const n = /* @__PURE__ */ new Map();
    return Gt(Rg(t, Vt, (r) => $s(r.getTypedIDs()), (r, o) => {
      for (const [i, s] of Object.entries(r.getTypedIDs()))
        s.forEach((a) => {
          o.addID(i, a);
        });
    }), t.registerMutationListener(Vt, (r) => {
      t.getEditorState().read(() => {
        for (const [o, i] of r) {
          const s = it(o);
          let a = {};
          i === "destroyed" ? a = n.get(o) ?? {} : zt(s) && (a = s.getTypedIDs());
          for (const [l, c] of Object.entries(a))
            if (!Vt.isReservedType(l))
              for (const u of c) {
                let p = e.get(Ha(l, u));
                a[l] = c, n.set(o, a), i === "destroyed" ? p !== void 0 && (p.delete(o), p.size === 0 && e.delete(Ha(l, u))) : (p === void 0 && (p = /* @__PURE__ */ new Set(), e.set(Ha(l, u), p)), p.has(o) || p.add(o));
              }
        }
      });
    }, { skipInitialization: !0 }));
  }, [t, e]);
}
const ZT = an(function({ logger: t }, e) {
  const [n] = De(), r = ue(() => /* @__PURE__ */ new Map(), []);
  return QT(n, r), Qu(e, () => ({
    addAnnotation(o, i, s) {
      if (Vt.isReservedType(i))
        throw new Error(`addAnnotation: Can't directly add this reserved annotation type '${i}'. Use the appropriate plugin instead.`);
      n.update(() => {
        const a = ap(o);
        if (a === void 0) {
          t == null || t.error("Failed to find start or end node of the annotation.");
          return;
        }
        Ob(a, i, s);
      }, { tag: Lu });
    },
    removeAnnotation(o, i) {
      if (Vt.isReservedType(o))
        throw new Error(`removeAnnotation: Can't directly remove this reserved annotation type '${o}'. Use the appropriate plugin instead.`);
      const s = r.get(Ha(o, i));
      s !== void 0 && setTimeout(() => {
        n.update(() => {
          for (const a of s) {
            const l = it(a);
            zt(l) && (l.deleteID(o, i), l.hasNoIDsForEveryType() && Mb(l));
          }
        }, { tag: Lu });
      });
    }
  })), null;
});
function eA({ ignoreHistoryMergeTagChange: t = !0, ignoreSelectionChange: e = !1, onChange: n }) {
  const [r] = De();
  return xt(() => {
    if (n)
      return r.registerUpdateListener((o) => {
        const { editorState: i, dirtyElements: s, dirtyLeaves: a, prevEditorState: l, tags: c } = o;
        if (e && s.size === 0 && a.size === 0 || t && c.has(Uo) || l.isEmpty())
          return;
        const u = tA(r, o);
        u.length !== 0 && n(i, r, c, u);
      });
  }, [r, t, e, n]), null;
}
function tA(t, { dirtyLeaves: e, prevEditorState: n }) {
  let r = new cs();
  return t.getEditorState().read(() => {
    const o = e.values().next().value ?? "";
    if (e.size === 1 && xe(it(o))) {
      const i = it(o), s = Vb(i);
      if (xe(i) && s !== void 0) {
        const a = n.read(() => {
          const u = it(o);
          return new cs([xe(u) ? Bu(u) : { insert: "" }]);
        }), l = new cs([Bu(i)]), c = new cs(s > 0 ? [{ retain: s }] : []);
        r = r.concat(c).concat(a.diff(l));
      }
    } else {
      const i = Ih(n), s = Ih(t.getEditorState());
      r = i.diff(s);
    }
  }), r.ops;
}
function nA(t, e, n, r) {
  let o = 0;
  t.forEach((i) => {
    if ("retain" in i)
      o += rA(i, o, e, r);
    else if ("delete" in i) {
      if (typeof i.delete != "number" || i.delete <= 0) {
        r == null || r.error(`Invalid delete operation: ${JSON.stringify(i)}`);
        return;
      }
      r == null || r.debug(`Delete: ${i.delete}`), iA(o, i.delete, r);
    } else "insert" in i ? typeof i.insert == "string" ? (r == null || r.debug(`Insert: '${i.insert}'`), o += sA(o, i.insert, i.attributes, e, r)) : typeof i.insert == "object" && i.insert !== null ? (r == null || r.debug(`Insert embed: ${JSON.stringify(i.insert)}`), lA(o, i, e, n, r) ? o += 1 : r == null || r.error(`Failed to process insert embed operation: ${JSON.stringify(i.insert)} at index ${o}. Document may be inconsistent.`)) : r == null || r.error(`Insert of unknown type: ${JSON.stringify(i.insert)}`) : r == null || r.error(`Unknown operation: ${JSON.stringify(i)}`);
  });
}
function rA(t, e, n, r) {
  return typeof t.retain != "number" || t.retain < 0 ? (r == null || r.error(`Invalid retain operation: ${JSON.stringify(t)}`), 0) : (r == null || r.debug(`Retain: ${t.retain}`), t.attributes && (r == null || r.debug(`Retain attributes: ${JSON.stringify(t.attributes)}`), oA(e, t.retain, t.attributes, n, r)), t.retain);
}
function oA(t, e, n, r, o) {
  o == null || o.debug(`Applying attributes for range [${t}, ${t + e - 1}] with attributes: ${JSON.stringify(n)}`);
  let i = e, s = 0, a = -1;
  const l = tt();
  function c(u) {
    if (i <= 0)
      return !0;
    if (xe(u)) {
      const p = u.getTextContentSize();
      if (t < s + p && s < t + e) {
        const f = Math.max(0, t - s), h = p - f, g = Math.min(i, h);
        if (g > 0) {
          let b = u;
          const _ = f > 0, x = g < p - f;
          if (_ && x) {
            const [, y] = u.splitText(f);
            [b] = y.splitText(g);
          } else _ ? [, b] = u.splitText(f) : x && ([b] = u.splitText(g));
          if (Fo(n)) {
            const y = b.getParent();
            if (et(y)) {
              const A = n.char;
              let P;
              Array.isArray(A) ? a >= 0 && a <= A.length - 1 && (P = A[a]) : a === 0 && (P = A);
              const V = P ? $o(P, y) : !1;
              if (V && Array.isArray(A) && A.length > 1) {
                const O = pt("");
                b.replace(O);
                const U = typeof n.segment == "string" ? n.segment : void 0, B = ra(A.slice(1), r, b, U);
                let F = O;
                for (const K of B)
                  F.insertAfter(K), F = K;
                O.remove(), Mn(n, b);
              } else if (V)
                Mn(n, b);
              else {
                b.remove();
                const O = $h(b, n, r, o);
                if (O && O.length > 0) {
                  let U = y;
                  for (const B of O)
                    U.insertAfter(B), U = B;
                }
              }
            } else {
              const A = pt("");
              b.replace(A);
              const P = $h(b, n, r, o);
              if (P && P.length > 0) {
                let V = A;
                for (const O of P)
                  V.insertAfter(O), V = O;
                A.remove();
              } else
                A.replace(b);
            }
          } else
            Mn(n, b);
          i -= g;
        }
      }
      s += p;
    } else if (Xn(u))
      t <= s && s < t + e && i > 0 && (Fh(u, n), i -= 1), s += 1;
    else if (et(u)) {
      a += 1;
      let p = !1;
      if (t <= s && s < t + e && i > 0)
        if (Fo(n)) {
          const f = n.char;
          let h;
          if (Array.isArray(f) ? a >= 0 && a <= f.length - 1 && (h = f[a]) : a === 0 && (h = f), h) {
            u.setMarker(h.style), typeof h.cid == "string" && Nr(u, Ro, () => h.cid);
            const g = Ft(h, ul);
            g && Object.keys(g).length > 0 ? u.setUnknownAttributes({
              ...u.getUnknownAttributes() ?? {},
              ...g
            }) : u.setUnknownAttributes(void 0);
          }
        } else (n.char === !1 || n.char === null || gA(n.char)) && (p = !0);
      if (i > 0) {
        const f = u.getChildren();
        for (const h of f) {
          if (i <= 0)
            break;
          if (c(h) && i <= 0)
            return p && df(u), !0;
        }
      }
      p && df(u), a -= 1;
    } else if (Ln(u)) {
      const p = u.getChildren();
      for (const h of p) {
        if (i <= 0)
          break;
        if (c(h) && i <= 0)
          return !0;
      }
      const f = 1;
      if (t <= s && s < t + i && i > 0) {
        if (!Mr(u))
          Fh(u, n);
        else if (hp(n)) {
          const h = Jb(n.para);
          h && u.replace(h, !0);
        }
        i -= f;
      }
      s += f;
    } else if (Ae(u)) {
      const p = u.getChildren();
      for (const f of p) {
        if (i <= 0)
          break;
        if (c(f) && i <= 0)
          return !0;
      }
    }
    return i <= 0;
  }
  c(l), i > 0 && (o == null || o.warn(`$applyAttributes: Not all characters in the retain operation (length ${e}) could be processed. Remaining: ${i}. targetIndex: ${t}, final currentIndex: ${s}`));
}
function $h(t, e, n, r) {
  var o;
  const i = typeof e.segment == "string" ? e.segment : void 0, s = ra(e.char, n, t, i), a = s.find(et);
  if (!a) {
    r == null || r.error(`Failed to create CharNode for text transformation. Style: ${Array.isArray(e.char) ? e.char[0].style : (o = e.char) == null ? void 0 : o.style}. Falling back to standard text attributes.`), Mn(e, t);
    return;
  }
  const l = {};
  Xb.forEach((p) => {
    t.hasFormat(p) && (l[p] = "true");
  });
  const c = {};
  Object.entries(e).forEach(([p, f]) => {
    p === "segment" || p === "char" || (typeof f == "string" ? c[p] = f : f === !0 ? c[p] = "true" : f === !1 && (c[p] = "false"));
  });
  const u = {
    ...a.getUnknownAttributes() ?? {},
    ...l,
    ...c
  };
  return Object.keys(u).length > 0 && a.setUnknownAttributes(u), Mn(e, t), s;
}
function Fh(t, e) {
  for (const n of Object.keys(e)) {
    const r = e[n];
    if (n === "char" && et(t) && Fo(e)) {
      const o = r;
      if (t.setMarker(o.style), typeof o.cid == "string") {
        const s = o.cid;
        Nr(t, Ro, () => s);
      }
      const i = Ft(o, ul);
      i && Object.keys(i).length > 0 && t.setUnknownAttributes({
        ...t.getUnknownAttributes() ?? {},
        ...i
      });
      continue;
    }
    typeof r == "string" && (On(t) || Rn(t) || Gl(t) || Le(t) || Zs(t) ? t.setUnknownAttributes({
      ...t.getUnknownAttributes() ?? {},
      [n]: r
    }) : (wr(t) || Yt(t) || et(t)) && (n === "style" && !wr(t) ? t.setMarker(r) : n === "code" && wr(t) ? t.setCode(r) : t.setUnknownAttributes({
      ...t.getUnknownAttributes() ?? {},
      [n]: r
    })), n === "segment" && Nr(t, Io, () => r));
  }
}
function iA(t, e, n) {
  if (e <= 0)
    return;
  const r = tt();
  let o = 0, i = e;
  function s(a) {
    if (i <= 0)
      return !0;
    if (xe(a)) {
      let l = a.getTextContentSize();
      if (t < o + l && o < t + i) {
        const c = Math.max(0, t - o), u = l - c, p = Math.min(i, u);
        p > 0 && (a.spliceText(c, p, ""), a.getTextContentSize() === 0 && a.remove(), n == null || n.debug(`Deleted ${p} length from TextNode (key: ${a.getKey()}) at nodeOffset ${c}. Original targetIndex: ${t}, current currentIndex: ${o}.`), i -= p, l -= p);
      }
      o += l;
    } else if (Xn(a))
      t <= o && o < t + i ? (a.remove(), n == null || n.debug(`Deleted embed node (key: ${a.getKey()}) at currentIndex: ${o}. Original targetIndex: ${t}, remainingToDelete: ${i}.`), i -= 1) : o += 1;
    else if (Ln(a)) {
      const l = a.getChildren().slice(), c = a.getChildren();
      for (const u of c) {
        if (i <= 0)
          break;
        if (s(u) && i <= 0)
          return !0;
      }
      if (t <= o && o < t + i && Ln(a)) {
        i -= 1;
        const u = a.getChildren().length;
        if (l.length > 0 && u === 0) {
          const p = a.getParent();
          ((p == null ? void 0 : p.getChildren()) ?? []).length > 1 ? (a.remove(), n == null || n.debug(`Removed entire ParaNode that had all its content deleted at currentIndex: ${o}. Original targetIndex: ${t}, remainingToDelete: ${i}.`)) : (a.replace(zn(), !0), n == null || n.debug(`Replaced last ParaNode with ImpliedParaNode at currentIndex: ${o}. Original targetIndex: ${t}, remainingToDelete: ${i}.`));
        } else if (i > 0) {
          const p = a.getNextSibling();
          if (p && Vn(p)) {
            let f = o + 1;
            const h = p.getChildren();
            for (const b of h) {
              if (i <= 0)
                break;
              const _ = o;
              if (o = f, s(b)) {
                o = _;
                break;
              }
              xe(b) ? f += b.getTextContentSize() : Xn(b) && (f += 1), o = _;
            }
            const g = p.getChildren();
            for (const b of g)
              b.remove(), a.append(b);
            p.remove(), n == null || n.debug(`Merged next paragraph into current one after deleting symbolic close at currentIndex: ${o}. Original targetIndex: ${t}, remainingToDelete: ${i}.`);
          } else
            a.replace(zn(), !0);
        } else Yt(a) ? a.replace(zn(), !0) : a.remove();
      }
      o += 1;
    } else if (Ae(a)) {
      const l = a.getChildren();
      for (const c of l) {
        if (i <= 0)
          break;
        if (s(c) && i <= 0)
          return !0;
      }
    }
    return i <= 0;
  }
  s(r), i > 0 && (n == null || n.warn(`Delete operation could not remove all requested characters. Remaining to delete: ${i}. Original targetIndex: ${t}, OT length: ${e}. Final currentIndex: ${o}`));
}
function sA(t, e, n, r, o) {
  if (e === Fs)
    return Bh(t, n, o);
  if (e.endsWith(Fs) && !hp(n)) {
    const i = e.slice(0, -1);
    let s = 0;
    if (i.length > 0) {
      if (Fo(n))
        throw new Error("Text + LF should not have char attributes");
      s += dl(t, i, n, o);
    }
    return s += Bh(t + s, n, o), s;
  } else return Fo(n) ? aA(t, e, n, r, o) : dl(t, e, n, o);
}
function aA(t, e, n, r, o) {
  o == null || o.debug(`Attempting to insert CharNode with text "${e}" and attributes ${JSON.stringify(n.char)} at index ${t}`);
  const i = pt(e);
  Mn(n, i);
  let s;
  {
    let h = function(_) {
      if (xe(_)) {
        const x = _.getTextContentSize();
        if (t >= b && t < b + x) {
          const y = _.getParent();
          return et(y) && (s = y), !0;
        }
        b += x;
      } else if (Xn(_))
        b += 1;
      else if (et(_)) {
        const x = _.getChildren();
        for (const y of x)
          if (h(y))
            return !0;
      } else if (Ae(_)) {
        const x = _.getChildren();
        for (const y of x)
          if (h(y))
            return !0;
        Ln(_) && (b += 1);
      }
      return !1;
    };
    const g = tt();
    let b = 0;
    h(g);
  }
  let a = n.char;
  if (Array.isArray(a)) {
    if (s) {
      const h = a[0];
      h && $o(h, s) ? (a = a.slice(1), a.length === 1 && (a = a[0])) : s = void 0;
    }
  } else s && ($o(a, s) || (s = void 0));
  const l = typeof n.segment == "string" ? n.segment : void 0, c = ra(a, r, i, l, s ? [s] : void 0);
  if (c.length === 0)
    return e.length;
  const u = c.find(et);
  if (!u)
    return o == null || o.error(`CharNode style is missing for text "${e}". Attributes: ${JSON.stringify(n.char)}. Falling back to rich text insertion.`), dl(t, e, void 0, o);
  const p = {};
  for (const [h, g] of Object.entries(n))
    h !== "char" && h !== "segment" && typeof g == "string" && (p[h] = g);
  Object.keys(p).length > 0 && u.setUnknownAttributes(p);
  let f = !0;
  for (const h of c)
    if (!Wb(t, h, o)) {
      f = !1;
      break;
    }
  return f ? e.length : (o == null || o.error(`Failed to insert CharNode with text "${e}" at index ${t}. Falling back to rich text.`), dl(t, e, void 0, o));
}
function dl(t, e, n, r) {
  if (e.length <= 0)
    return r == null || r.debug("Attempted to insert empty string. No action taken."), 0;
  const o = tt();
  let i = 0, s = !1;
  function a(l) {
    if (s)
      return !0;
    if (xe(l)) {
      const c = l.getTextContentSize();
      if (t >= i && t <= i + c) {
        const u = t - i, p = pt(e);
        if (Mn(n, p), u === 0)
          l.insertBefore(p);
        else if (u === c) {
          const f = l.getParent();
          et(f) && !Fo(n) ? f.insertAfter(p) : l.insertAfter(p);
        } else {
          const [, f] = l.splitText(u);
          f.insertBefore(p);
        }
        return r == null || r.debug(`Inserted text "${e}" in/around TextNode (key: ${l.getKey()}) at nodeOffset ${u}. Original targetIndex: ${t}, currentIndex at node start: ${i}.`), s = !0, !0;
      }
      i += c;
    } else if (Xn(l))
      i += 1;
    else if (et(l)) {
      if (!s && t === i) {
        const u = pt(e);
        Mn(n, u);
        const p = l.getFirstChild();
        return p ? p.insertBefore(u) : l.append(u), r == null || r.debug(`Inserted text "${e}" at beginning of CharNode ${l.getType()} (key: ${l.getKey()}).`), s = !0, !0;
      }
      const c = l.getChildren();
      for (const u of c) {
        if (a(u))
          return !0;
        if (s)
          break;
      }
      if (!s && t === i) {
        const u = pt(e);
        return Mn(n, u), l.append(u), r == null || r.debug(`Appended text "${e}" to end of CharNode ${l.getType()} (key: ${l.getKey()}).`), s = !0, !0;
      }
    } else if (Ln(l)) {
      if (!s && t === i) {
        const u = pt(e);
        Mn(n, u);
        const p = l.getFirstChild();
        return p ? p.insertBefore(u) : l.append(u), r == null || r.debug(`Inserted text "${e}" at beginning of container ${l.getType()} (key: ${l.getKey()}).`), s = !0, !0;
      }
      const c = l.getChildren();
      for (const u of c) {
        if (a(u))
          return !0;
        if (s)
          break;
      }
      if (!s && t === i) {
        const u = pt(e);
        return Mn(n, u), l.append(u), r == null || r.debug(`Appended text "${e}" to end of container ${l.getType()} (key: ${l.getKey()}).`), s = !0, !0;
      }
      i += 1;
    } else if (Ae(l)) {
      const c = l.getChildren();
      for (const u of c) {
        if (a(u))
          return !0;
        if (s)
          break;
      }
    }
    return s;
  }
  if (a(o), !s && t === i) {
    r == null || r.debug(`Insertion point matches end of document (targetIndex: ${t}, final currentIndex: ${i}). Appending text to new ParaNode.`);
    const l = pt(e);
    Mn(n, l);
    const c = zn().append(l);
    o.append(c), s = !0;
  }
  return s ? e.length : (r == null || r.warn(`$insertRichText: Could not find insertion point for text "${e}" at targetIndex ${t}. Final currentIndex: ${i}. Text not inserted.`), 0);
}
function Wb(t, e, n) {
  const r = tt();
  let o = 0, i = !1;
  function s(a) {
    if (i)
      return !0;
    if (a === r && t === 0 && !r.getFirstChild())
      return e.isInline() ? (n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting inline node ${e.getType()} into empty root, wrapped in ImpliedParaNode. targetIndex: ${t}`), r.append(zn().append(e))) : (n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting block node ${e.getType()} directly into empty root. targetIndex: ${t}`), r.append(e)), i = !0, !0;
    if (!Ae(a))
      return !1;
    const l = a.getChildren();
    for (const c of l) {
      if (t === o && !i) {
        if (a === r && e.isInline())
          if (Vn(c)) {
            n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting inline node ${e.getType()} into existing ${c.getType()} at beginning. targetIndex: ${t}`);
            const u = c.getFirstChild();
            u ? u.insertBefore(e) : c.append(e);
          } else
            n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting inline node ${e.getType()} into root before ${c.getType()}, wrapping in ImpliedParaNode. targetIndex: ${t}`), c.insertBefore(zn().append(e));
        else
          c.insertBefore(e), n == null || n.debug(`$insertNodeAtCharacterOffset: Inserted node ${e.getType()} (key: ${e.getKey()}) before child ${c.getType()} (key: ${c.getKey()}) in ${a.getType()} (key: ${a.getKey()}). targetIndex: ${t}, currentIndex: ${o}`);
        return i = !0, !0;
      }
      if (xe(c)) {
        const u = c.getTextContentSize();
        if (!i && t > o && t < o + u) {
          const p = t - o, [f] = c.splitText(p);
          return f.insertAfter(e), n == null || n.debug(`$insertNodeAtCharacterOffset: Inserted node ${e.getType()} (key: ${e.getKey()}) by splitting TextNode (key: ${c.getKey()}) at offset ${p}. targetIndex: ${t}, currentIndex at node start: ${o}`), i = !0, !0;
        }
        o += u;
      } else if (Xn(c))
        o += 1;
      else if (et(c)) {
        if (s(c))
          return !0;
      } else if (Ln(c)) {
        const u = c;
        if (s(u))
          return !0;
        const p = o;
        if (Mr(u) && Ln(e) && // Target is at the ImpliedPara's implicit newline
        t === p && !i)
          return n == null || n.debug(`$insertNodeAtCharacterOffset: Replacing ImpliedParaNode (key: ${u.getKey()}) with block node '${e.getType()}' (key: ${e.getKey()}) at OT index ${t}.`), c.replace(e, !0), o = p + 1, i = !0, !0;
        o += 1;
      } else if (Ae(c) && s(c))
        return !0;
      if (i)
        return !0;
    }
    return Ae(a) && !i && (t === o || a === r && t > o) ? a === r ? (e.isInline() ? (n == null || n.debug(`$insertNodeAtCharacterOffset: Appending inline node ${e.getType()} to root. Wrapping in new ImpliedParaNode. targetIndex: ${t}, current document OT length: ${o}.`), r.append(zn().append(e))) : (n == null || n.debug(`$insertNodeAtCharacterOffset: Appending block node ${e.getType()} to root. targetIndex: ${t}, current document OT length: ${o}.`), r.append(e)), i = !0, !0) : (
      // Appending to an existing container (ParaNode, ImpliedParaNode)
      // currentNode here is the container itself. currentIndex is at the point of currentNode's
      // closing marker. targetIndex === currentIndex means we are inserting at the conceptual end
      // of this container.
      Vn(a) ? Mr(a) && Yt(e) && t === o ? (n == null || n.debug(`$insertNodeAtCharacterOffset: Replacing ImpliedParaNode container (key: ${a.getKey()}) with ParaNode ${e.getType()} (key: ${e.getKey()}) via append logic. targetIndex: ${t}`), a.replace(e, !0), i = !0, !0) : e.isInline() || !Vn(e) ? (n == null || n.debug(`$insertNodeAtCharacterOffset: Appending node ${e.getType()} to existing container ${a.getType()} (key: ${a.getKey()}). targetIndex: ${t}, container end OT index: ${o}.`), a.append(e), i = !0, !0) : (n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting block node ${e.getType()} after container ${a.getType()} (key: ${a.getKey()}). targetIndex: ${t}, container end OT index: ${o}.`), a.insertAfter(e), i = !0, !0) : (et(a) ? (n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting node ${e.getType()} after CharNode (key: ${a.getKey()}). targetIndex: ${t}, element end OT index: ${o}.`), a.insertAfter(e)) : e.isInline() || !Vn(e) ? (n == null || n.debug(`$insertNodeAtCharacterOffset: Appending node ${e.getType()} to generic element ${a.getType()} (key: ${a.getKey()}). targetIndex: ${t}, element end OT index: ${o}.`), a.append(e)) : (n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting block node ${e.getType()} after generic element ${a.getType()} (key: ${a.getKey()}). targetIndex: ${t}, element end OT index: ${o}.`), a.insertAfter(e)), i = !0, !0)
    ) : i;
  }
  return s(r), i || n == null || n.warn(`$insertNodeAtCharacterOffset: Could not find insertion point for node ${e.getType()} (key: ${e.getKey()}) at targetIndex ${t}. Final currentIndex: ${o}. Node not inserted.`), i;
}
function lA(t, e, n, r, o) {
  let i;
  return ts("chapter", e) ? i = cA(e.insert.chapter, n) : ts("verse", e) ? i = uA(e.insert.verse, n) : ts("ms", e) ? i = dA(e.insert.ms) : ts("unmatched", e) ? i = pA(e.insert.unmatched) : ts("note", e) && (i = fA(e, n, r, o)), i ? Wb(t, i, o) : (o == null || o.error(`$insertEmbedAtCurrentIndex: Cannot create LexicalNode for embed object: ${JSON.stringify(e.insert)}`), !1);
}
function Bh(t, e, n) {
  let r;
  hp(e) ? r = Jb(e.para) : wA(e) && (r = hA(e.book)), r ?? (r = zn());
  const o = r, i = Yt(o), s = Mr(o);
  let a = 0, l = !1;
  function c(u) {
    if (l)
      return !0;
    if (xe(u)) {
      const p = u.getTextContentSize();
      if (t >= a && t <= a + p) {
        const f = u.getParent();
        if (Yt(f) && (i || s)) {
          n == null || n.debug(`Splitting ParaNode (marker: ${f.getMarker()}) with LF attributes at targetIndex ${t}`);
          const h = t - a, [g] = h > 0 ? u.splitText(h) : [void 0];
          let b = g == null ? void 0 : g.getPreviousSibling();
          for (; b; ) {
            const _ = b;
            b = b.getPreviousSibling();
            const x = o.getFirstChild();
            x ? x.insertBefore(_) : o.append(_);
          }
          return g && o.append(g), f.insertBefore(o), l = !0, !0;
        }
      }
      a += p;
    } else if (Xn(u))
      a += 1;
    else if (Ln(u)) {
      const p = u.getChildren();
      for (const f of p) {
        if (c(f))
          return !0;
        if (l)
          break;
      }
      if (t === a) {
        if (Mr(u) && o)
          return n == null || n.debug(`Replacing ImpliedParaNode (key: ${u.getKey()}) with ParaNode at targetIndex ${t}`), u.replace(o, !0), l = !0, !0;
        if (Yt(u) && o) {
          const f = u;
          return n == null || n.debug(`Creating new block node with LF attributes after existing ParaNode (marker: ${f.getMarker()}) at targetIndex ${t}`), f.insertAfter(o), l = !0, !0;
        }
      }
      if (a += 1, t === a && Yt(u) && o)
        return n == null || n.debug(`Creating new block node after existing ParaNode (marker: ${u.getMarker()}) at targetIndex ${t}`), u.insertAfter(o), l = !0, !0;
    } else if (Ae(u)) {
      const p = u.getChildren();
      for (const f of p) {
        if (c(f))
          return !0;
        if (l)
          break;
      }
    }
    return l;
  }
  return c(tt()), l || n == null || n.warn(`Could not find location to handle newline with para attributes at targetIndex ${t}. Final currentIndex: ${a}.`), 1;
}
function cA(t, e) {
  if (!t)
    return;
  const { number: n, sid: r, altnumber: o, pubnumber: i } = t;
  if (!n)
    return;
  const s = Ft(t, sT);
  let a;
  if (e.markerMode === "editable")
    a = fb(n, r, o, i, s);
  else {
    const l = e.markerMode === "visible";
    a = Xd(n, l, r, o, i, s);
  }
  return a;
}
function uA(t, e) {
  if (!t)
    return;
  const { style: n, number: r, sid: o, altnumber: i, pubnumber: s } = t;
  if (!r)
    return;
  const a = Ft(t, aT);
  let l;
  if (e.markerMode === "editable") {
    if (!n)
      return;
    const c = ta(n, r);
    l = Nb(r, c, o, i, s, a);
  } else {
    const c = e.markerMode === "visible";
    l = lp(r, c, o, i, s, a);
  }
  return l;
}
function dA(t) {
  if (!t)
    return;
  const { style: e, sid: n, eid: r } = t;
  if (!e)
    return;
  const o = Ft(t, lT);
  return _b(e, n, r, o);
}
function pA(t) {
  if (!t)
    return;
  const { marker: e } = t;
  if (e)
    return sp(e);
}
function fA(t, e, n, r) {
  var o;
  const i = t.insert;
  if (!i.note)
    return;
  const { style: s, caller: a, category: l, contents: c } = i.note;
  if (!s || a == null)
    return;
  a === "" && (r == null || r.warn("Note has empty caller. Only use for note editing."));
  const u = Ft(i.note, cT), p = (o = t.attributes) == null ? void 0 : o.segment;
  let f;
  p && typeof p == "string" && (f = p);
  const h = [];
  for (const g of (c == null ? void 0 : c.ops) ?? [])
    if (typeof g.insert == "string")
      if (Fo(g.attributes)) {
        const b = ra(g.attributes.char, e, pt(g.insert), void 0, h);
        h.push(...b);
      } else
        h.push(pt(g.insert));
  return qb(s, a, h, e, n, f).setCategory(l).setUnknownAttributes(u);
}
function hA(t) {
  const { style: e, code: n } = t;
  if (!e || e !== Ls || !n || !In.isValidBookCode(n))
    return;
  const r = Ft(t, iT);
  return ub(n, r);
}
function Jb(t) {
  const { style: e } = t;
  if (!e)
    return;
  const n = Ft(t, oT);
  return Ps(e, n);
}
function ra(t, e, n, r, o) {
  if (Array.isArray(t)) {
    if (t.length === 0)
      throw new Error("Empty charAttr array");
    const i = t[0], s = o == null ? void 0 : o[o.length - 1];
    if (et(s) && $o(i, s))
      return t.length > 1 ? ra(t.slice(1), e, n).forEach((u) => s.append(u)) : n && s.append(n), [];
    const a = t.reduceRight((u, p, f) => {
      const h = cr(p.style, Ft(p, ul));
      if (typeof p.cid == "string" && Nr(h, Ro, () => p.cid), r && f === t.length - 1 && Nr(h, Io, () => r), u)
        if (et(u)) {
          const g = u.getMarker(), b = [];
          Uc(g, b, e), b.forEach((x) => h.append(x)), h.append(u);
          const _ = [];
          Vc(g, _, e), _.forEach((x) => h.append(x));
        } else
          h.append(u);
      return h;
    }, n), l = [], c = t[0];
    return Uc(c.style, l, e), l.push(a), Vc(c.style, l, e), l;
  } else {
    const i = o == null ? void 0 : o[o.length - 1];
    if (et(i) && $o(t, i))
      return n && i.append(n), [];
    const s = [];
    Uc(t.style, s, e);
    const a = cr(t.style, Ft(t, ul));
    return typeof t.cid == "string" && Nr(a, Ro, () => t.cid), r && Nr(a, Io, () => r), n && a.append(n), s.push(a), Vc(t.style, s, e), s;
  }
}
function Uc(t, e, n) {
  (n == null ? void 0 : n.markerMode) === "editable" ? e.push(Ni(t)) : (n == null ? void 0 : n.markerMode) === "visible" && e.push(Ti("marker", Pr(t)));
}
function Vc(t, e, n, r = !1) {
  ht.isValidFootnoteMarker(t) || ht.isValidCrossReferenceMarker(t) || ((n == null ? void 0 : n.markerMode) === "editable" ? r ? e.push(Ni("", "selfClosing")) : e.push(Ni(t, "closing")) : (n == null ? void 0 : n.markerMode) === "visible" && e.push(Ti("marker", ki(r ? "" : t))));
}
function wA(t) {
  return !!t && !!t.book && typeof t.book == "object" && t.book !== null && "style" in t.book && typeof t.book.style == "string" && "code" in t.book && typeof t.book.code == "string";
}
function hp(t) {
  return !!t && !!t.para && typeof t.para == "object" && t.para !== null && "style" in t.para && typeof t.para.style == "string";
}
function Fo(t) {
  return !!t && !!t.char && typeof t.char == "object" && t.char !== null && (!Array.isArray(t.char) && "style" in t.char && typeof t.char.style == "string" || Array.isArray(t.char) && t.char.length > 0 && "style" in t.char[0] && typeof t.char[0].style == "string");
}
function gA(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t) && Object.keys(t).length === 0;
}
function Mn(t, e) {
  if (t)
    for (const n of Object.keys(t)) {
      if (n === "segment" && typeof t[n] == "string") {
        const r = t[n];
        Nr(e, Io, () => r);
        continue;
      }
      if (mA(n)) {
        const r = !!t[n], o = n, i = e.hasFormat(o);
        (r && !i || !r && i) && e.toggleFormat(o);
      }
    }
}
const Xb = [
  "bold",
  "underline",
  "strikethrough",
  "italic",
  "highlight",
  "code",
  "subscript",
  "superscript",
  "lowercase",
  "uppercase",
  "capitalize"
];
function mA(t) {
  return Xb.includes(t);
}
function bA({ viewOptions: t }) {
  const [e] = De();
  return vA(e, t), null;
}
function vA(t, e) {
  ie(() => {
    if (!t.hasNodes([Lr, sn, $t]))
      throw new Error("ArrowNavigationPlugin: ImmutableChapterNode, ImmutableVerseNode or NoteNode not registered on editor!");
    const n = (r) => {
      if (r.key !== "ArrowLeft" && r.key !== "ArrowRight")
        return !1;
      const o = ve();
      if (!me(o) || !o.isCollapsed())
        return !1;
      const i = t.getRootElement();
      if (!i)
        return !1;
      const s = i.dir || "ltr";
      let a = !1;
      return yA(s, r.key) ? a = _A(o) : xA(s, r.key) && (a = CA(o, e)), a && r.preventDefault(), a;
    };
    return t.registerCommand(Hs, n, Cl);
  }, [t, e]);
}
function yA(t, e) {
  return t === "ltr" && e === "ArrowRight" || t === "rtl" && e === "ArrowLeft";
}
function xA(t, e) {
  return t === "ltr" && e === "ArrowLeft" || t === "rtl" && e === "ArrowRight";
}
function _A(t) {
  var e, n, r;
  const o = t.anchor.getNode(), i = _N(t);
  if (Le(i) && !na(i.getFirstChild())) {
    if (Vn(o)) {
      if (t.anchor.offset === o.getChildrenSize())
        return !1;
    } else if (t.anchor.offset !== o.getTextContentSize())
      return !1;
    if (i.getIsCollapsed()) {
      if (i.is((e = i.getParent()) == null ? void 0 : e.getLastChild()))
        return (r = (n = i.getParent()) == null ? void 0 : n.getNextSibling()) == null || r.selectStart(), !0;
    } else return ll(i.getFirstChild()) ? i.select(2, 2) : i.select(1, 1), !0;
  }
  if (Vn(o) && Le(i) && i.getIsCollapsed()) {
    const a = i.getNextSibling();
    return a ? a.selectStart() : i.selectEnd(), !0;
  }
  const s = i == null ? void 0 : i.getParent();
  if (ll(i) && Le(s) && i.is(s == null ? void 0 : s.getLastChild())) {
    const a = s.getNextSibling();
    return a ? a.selectStart() : s.selectEnd(), !0;
  }
  return !1;
}
function CA(t, e) {
  const n = CN(t);
  if (ea(n) && !n.getPreviousSibling())
    return !0;
  if (t.anchor.offset !== 0)
    return !1;
  const r = t.anchor.getNode();
  if (wr(r.getParent()))
    return !0;
  if (Le(n) && n.getIsCollapsed()) {
    const i = n.getPreviousSibling();
    if (!Hi(i))
      return !1;
    const s = n.getParent();
    if (!s)
      return !1;
    const a = n.getIndexWithinParent();
    return s.select(a, a), !0;
  }
  if (Vn(n) && (e == null ? void 0 : e.noteMode) === "collapsed") {
    const i = n.getLastChild();
    if (!i)
      return !1;
    const s = Ts(i, (a) => Le(a));
    if (Le(s) && s.getIsCollapsed()) {
      const a = s.getParent();
      if (!a)
        return !1;
      const l = s.getIndexWithinParent();
      return a.select(l, l), !0;
    }
  }
  const o = Tb(r);
  if (!o || o.getIsCollapsed())
    return !1;
  if (co(n)) {
    const i = o.getParent();
    if (!i)
      return !1;
    const s = o.getIndexWithinParent();
    return i.select(s, s), !0;
  }
  return !1;
}
function EA() {
  const [t] = De();
  return kA(t), null;
}
function kA(t) {
  ie(() => {
    if (!t.hasNodes([ht]))
      throw new Error("CharNodePlugin: CharNode not registered on editor!");
    return t.registerNodeTransform(ht, NA);
  }, [t]);
}
function NA(t) {
  if (!et(t))
    return;
  if (t.isEmpty()) {
    t.remove();
    return;
  }
  const e = t.getMarker(), n = bs(t, Ro), r = t.getUnknownAttributes(), o = t.getNextSibling();
  et(o) && $o({ style: e, cid: n }, o) && kr(r, o.getUnknownAttributes()) && (t.append(...o.getChildren()), o.remove());
  const i = t.getPreviousSibling();
  et(i) && $o({ style: e, cid: n }, i) && kr(r, i.getUnknownAttributes()) && (i.append(...t.getChildren()), t.remove());
}
function Yb(t) {
  return t.replaceAll("	", " ");
}
const wp = (t) => {
  navigator.clipboard.read().then(async (e) => {
    if ((await navigator.permissions.query({
      // @ts-expect-error These types are incorrect.
      name: "clipboard-read"
    })).state === "denied") {
      alert("Not allowed to paste from clipboard.");
      return;
    }
    const n = new DataTransfer(), r = e[0];
    for (const i of r.types) {
      const s = await (await r.getType(i)).text();
      n.setData(i, Yb(s));
    }
    const o = new ClipboardEvent("paste", {
      clipboardData: n
    });
    t.dispatchCommand(yl, o);
  });
}, gp = (t) => {
  navigator.clipboard.read().then(async () => {
    if ((await navigator.permissions.query({
      // @ts-expect-error These types are incorrect.
      name: "clipboard-read"
    })).state === "denied") {
      alert("Not allowed to paste from clipboard.");
      return;
    }
    const e = new DataTransfer(), n = await navigator.clipboard.readText();
    e.setData("text/plain", Yb(n));
    const r = new ClipboardEvent("paste", {
      clipboardData: e
    });
    t.dispatchCommand(yl, r);
  });
};
function TA() {
  const [t] = De();
  return ie(() => {
    const e = (n) => {
      const { key: r, shiftKey: o, metaKey: i, ctrlKey: s, altKey: a } = n;
      !(fu ? i : s) || a || (!o && r.toLowerCase() === "c" ? (n.preventDefault(), t.dispatchCommand(_l, null)) : !o && r.toLowerCase() === "x" ? (n.preventDefault(), t.dispatchCommand(xl, null)) : r.toLowerCase() === "v" && (n.preventDefault(), o ? gp(t) : wp(t)));
    };
    return t.registerRootListener((n, r) => {
      r !== null && r.removeEventListener("keydown", e), n !== null && n.addEventListener("keydown", e);
    });
  }, [t]), null;
}
function AA({ logger: t }) {
  const [e] = De();
  return ie(() => Gt(
    // When the backslash or forward slash key is typed.
    e.registerCommand(Hs, (n) => n.key !== "\\" && n.key !== "/" ? !1 : (n.preventDefault(), !0), Pa),
    // When the backslash or forward slash character is pasted into the editor.
    e.registerCommand(yl, (n) => {
      var r;
      const o = (r = n.clipboardData) == null ? void 0 : r.getData("text/plain");
      return !o || !o.includes("\\") && !o.includes("/") ? !1 : (t == null || t.info("CommandMenuPlugin: paste containing backslash or forward slash ignored."), n.preventDefault(), !0);
    }, Pa),
    // When the backslash or forward slash character is dragged into the editor.
    e.registerCommand(kw, (n) => {
      var r;
      const o = (r = n.dataTransfer) == null ? void 0 : r.getData("text/plain");
      return !o || !o.includes("\\") && !o.includes("/") ? !1 : (t == null || t.info("CommandMenuPlugin: drag containing backslash or forward slash ignored."), n.preventDefault(), !0);
    }, Pa)
  ), [e, t]), null;
}
function SA({ index: t, isSelected: e, onClick: n, onMouseEnter: r, option: o }) {
  let i = "item";
  return e && (i += " selected"), o.isDisabled && (i += " disabled"), d("li", { tabIndex: -1, className: i, ref: o.setRefElement, role: "option", "aria-selected": e, "aria-disabled": o.isDisabled, id: "typeahead-item-" + t, onMouseEnter: r, onClick: o.isDisabled ? void 0 : n, children: d("span", { className: "text", children: o.title }) }, o.key);
}
function DA({ options: t, selectedItemIndex: e, onOptionClick: n, onOptionMouseEnter: r }) {
  return d("div", { className: "typeahead-popover", children: d("ul", { children: t.map((o, i) => d(SA, { index: i, isSelected: e === i, onClick: () => n(o, i), onMouseEnter: () => r(i), option: o }, o.key)) }) });
}
class Ia extends LC {
  constructor(e, n) {
    super(e), fe(this, "title"), fe(this, "onSelect"), fe(this, "isDisabled"), this.title = e, this.onSelect = n.onSelect.bind(this), this.isDisabled = n.isDisabled || !1;
  }
}
function MA(t, e = "editor-input") {
  return t ? t.classList.contains(e) : !1;
}
function OA() {
  const [t] = De(), [e, n] = oe(() => !t.isEditable()), r = he(void 0), o = he(void 0), i = he(void 0), s = ue(() => [
    new Ia("Cut", {
      onSelect: () => {
        t.dispatchCommand(xl, null);
      },
      isDisabled: e
    }),
    new Ia("Copy", {
      onSelect: () => {
        t.dispatchCommand(_l, null);
      }
    }),
    new Ia("Paste", {
      onSelect: () => {
        wp(t);
      },
      isDisabled: e
    }),
    new Ia("Paste as Plain Text", {
      onSelect: () => {
        gp(t);
      },
      isDisabled: e
    })
  ], [t, e]), a = ce((l, c, u) => {
    t.update(() => {
      l == null || l.onSelect(c), u();
    });
  }, [t]);
  return ie(() => {
    var l;
    o.current = ((l = t.getRootElement()) == null ? void 0 : l.className) ?? "";
  }, [t]), ie(() => {
    const l = () => {
      var c;
      (c = i.current) == null || c.call(i);
    };
    return window.addEventListener("scroll", l, !0), () => {
      window.removeEventListener("scroll", l, !0);
    };
  }, []), ie(() => t.registerEditableListener((l) => {
    n(!l);
  }), [t]), d(FC, { options: s, onSelectOption: a, onWillOpen: (l) => {
    r.current = l.target;
  }, menuRenderFn: (l, { selectedIndex: c, options: u, selectOptionAndCleanUp: p, setHighlightedIndex: f }, { setMenuRef: h }) => (i.current = () => p(void 0), l.current && !MA(r.current, o.current) && !vb(r.current) ? Ny.createPortal(d("div", { className: "typeahead-popover auto-embed-menu", style: {
    marginLeft: l.current.style.width,
    userSelect: "none",
    width: 200
  }, ref: h, children: d(DA, { options: s, selectedItemIndex: c, onOptionClick: (g, b) => {
    g.isDisabled || (f(b), p(g));
  }, onOptionMouseEnter: (g) => {
    f(g);
  } }) }), l.current) : null) });
}
function RA({ isEditable: t }) {
  const [e] = De();
  return xt(() => {
    e.setEditable(t);
  }, [e, t]), null;
}
function IA({ scripture: t, nodeOptions: e, editorAdaptor: n, viewOptions: r, logger: o }) {
  const [i] = De();
  return ie(() => {
    var s;
    (s = n.initialize) == null || s.call(n, e, o);
  }, [n, o, e]), ie(() => {
    var s;
    (s = n.reset) == null || s.call(n);
    const a = n.serializeEditorState(t, r);
    if (a == null) {
      o == null || o.warn("LoadStatePlugin: serializedEditorState was null or undefined. Skipping editor update.");
      return;
    }
    try {
      const l = i.parseEditorState(a);
      queueMicrotask(() => {
        i.update(() => {
          i.setEditorState(l), i.dispatchCommand(_w, void 0);
        }, { tag: Wd });
      });
    } catch {
      o == null || o.error("LoadStatePlugin: error parsing or setting editor state.");
    }
  }, [i, n, o, t, r]), null;
}
function LA({ expandedNoteKeyRef: t, nodeOptions: e, viewOptions: n, logger: r }) {
  const [o] = De();
  return PA(e, r), $A(o, t, n, r), null;
}
function PA(t, e) {
  const n = he(void 0), r = t.noteCallers;
  ie(() => {
    let o = r;
    (!o || o.length <= 0) && (o = OT), n.current !== o && (n.current = o, zA("note-callers", o, e));
  }, [e, r]);
}
function $A(t, e, n, r) {
  ie(() => {
    if (!t.hasNodes([ht, $t, Gn]))
      throw new Error("NoteNodePlugin: CharNode, NoteNode or ImmutableNoteCallerNode not registered on editor!");
    const o = (i) => t.update(() => HA(i));
    return Gt(
      // Remove NoteNode if it doesn't contain a caller node and ensure typed text goes before it.
      t.registerNodeTransform($t, (i) => FA(i, n)),
      // Update NoteNodeCaller preview text when NoteNode children text is changed.
      t.registerNodeTransform(ht, BA),
      t.registerNodeTransform(Hn, qA),
      // Ensure NBSP after caller.
      t.registerNodeTransform(Gn, jA),
      // Re-generate all note callers when a note is removed.
      t.registerMutationListener(Gn, (i, { prevEditorState: s }) => UA(i, s)),
      // Handle the cursor moving next to a NoteNode. NoteNode arrow key navigation when note is
      // after a verse node is handled in the ArrowNavigationPlugin.
      t.registerCommand(no, () => VA(t, e, n, r), to),
      // Handle double-click of a word immediately following a NoteNode (no space between).
      t.registerRootListener((i, s) => {
        s !== null && s.removeEventListener("dblclick", o), i !== null && i.addEventListener("dblclick", o);
      })
    );
  }, [t, e, r, n]);
}
function FA(t, e) {
  const n = t.getChildren();
  if (!n.some((r) => co(r)) && (e == null ? void 0 : e.markerMode) !== "editable" && t.getCaller() !== "" && t.remove(), n.length > 0) {
    const r = n[0];
    xe(r) && !na(r) && t.insertBefore(r);
  }
}
function BA(t) {
  const e = t.getParentOrThrow(), n = e.getChildren(), r = n.find((s) => co(s));
  if (!et(t) || !Le(e) || !r)
    return;
  const o = op(n);
  r.getPreviewText() !== o && r.setPreviewText(o);
  const i = t.getNextSibling();
  xe(i) ? i.getTextContent() !== Ze && i.setTextContent(Ze) : t.insertAfter(pt(Ze));
}
function qA(t) {
  const e = Tb(t), n = e == null ? void 0 : e.getChildren(), r = n == null ? void 0 : n.find((i) => co(i));
  if (!xe(t) || !Le(e) || !r || !n)
    return;
  const o = op(n);
  r.getPreviewText() !== o && r.setPreviewText(o), !(na(t) || !Le(t.getParent())) && t.getTextContent() !== Ze && (t.setTextContent(Ze), t.selectEnd());
}
function jA(t) {
  if (!co(t))
    return;
  const e = t.getNextSibling();
  !xe(e) || na(e) ? t.insertAfter(pt(Ze)) : e.getTextContent() !== Ze && e.setTextContent(Ze);
}
function UA(t, e) {
  for (const [n, r] of t) {
    if (r !== "destroyed")
      continue;
    const o = e.read(() => {
      const s = it(n), a = s == null ? void 0 : s.getParent();
      return co(s) && Le(a) && a.getCaller() === Lo;
    }), i = document.querySelector(".editor-input");
    !o || !i || (i.classList.add("reset-counters"), i.offsetHeight, i.classList.remove("reset-counters"));
  }
}
function VA(t, e, n, r) {
  var o;
  if ((n == null ? void 0 : n.noteMode) !== "expandInline")
    return !1;
  const i = ve();
  if (!me(i) || !i.isCollapsed())
    return !1;
  const s = i.anchor, a = s.getNode();
  if (e.current) {
    const l = Ts(a, (c) => Le(c));
    if (l)
      e.current !== l.getKey() && (e.current = l.getKey());
    else {
      const c = it(e.current);
      c && !c.getIsCollapsed() && (r == null || r.debug("Cursor moved away from NoteNode, collapsing it"), ns(t, e.current, r)), e.current = void 0;
    }
  }
  if (s.offset === 0) {
    const l = a.getPreviousSibling();
    if (Le(l)) {
      r == null || r.debug("Cursor is just after a NoteNode");
      const c = l.getKey();
      l.getIsCollapsed() ? e.current = c : e.current = void 0, ns(t, c, r);
    }
  }
  if (s.offset === a.getTextContentSize()) {
    const l = a.getNextSibling();
    if (Le(l)) {
      r == null || r.debug("Cursor is just before a NoteNode");
      const c = l.getKey();
      l.getIsCollapsed() ? e.current = c : e.current = void 0, ns(t, c, r);
    } else if (!l) {
      const c = Ts(a, (u) => Le(u));
      if (c && c.getIsCollapsed() && Vn(c.getParent()) && c.is((o = c.getParent()) == null ? void 0 : o.getLastChild())) {
        r == null || r.debug("Cursor is at end of note at end of para");
        const u = c.getKey();
        e.current = u, ns(t, u, r);
      }
    }
  }
  if (Vn(a)) {
    const l = a.getChildAtIndex(s.offset), c = l == null ? void 0 : l.getPreviousSibling();
    if (Hi(c) && Le(l)) {
      r == null || r.debug("Cursor is between verse and NoteNode");
      const u = l.getKey();
      l.getIsCollapsed() ? e.current = u : e.current = void 0, ns(t, u, r);
    }
  }
  return !1;
}
function ns(t, e, n) {
  const r = it(e);
  try {
    r == null || r.toggleIsCollapsed();
  } catch (o) {
    if (o instanceof Error && o.message.includes("read only"))
      n == null || n.warn("Fallback triggered after stabilization - edge case"), setTimeout(() => {
        t.update(() => {
          r == null || r.toggleIsCollapsed();
        });
      }, 0);
    else
      throw o;
  }
}
function HA(t) {
  const e = ve();
  if (!me(e))
    return;
  const n = e.anchor, r = e.focus, o = n.getNode(), i = r.getNode();
  if (Le(o) && xe(i)) {
    t.preventDefault();
    const s = vl();
    s.anchor.set(i.getKey(), 0, "text"), s.focus.set(i.getKey(), r.offset, "text"), ml(s);
  }
}
function zA(t, e, n) {
  for (const r of document.styleSheets)
    try {
      const o = r.cssRules || r.rules;
      for (const i of o)
        if (GA(i, t)) {
          const s = e.map((a) => `"${a}"`).join(" ");
          i.symbols = s;
          return;
        }
    } catch {
      continue;
    }
  n == null || n.warn(`Editor: counter style "${t}" not found.`);
}
function GA(t, e) {
  return (
    // This check could be simpler but as is also works for test mocks.
    typeof t == "object" && t !== null && "name" in t && t.name === e && "symbols" in t && typeof t.symbols == "string"
  );
}
function KA({ onChange: t }) {
  const [e] = De();
  return ie(() => e.registerCommand(no, () => {
    const n = e.read(() => Pb());
    return t == null || t(n), !1;
  }, to), [e, t]), null;
}
function WA() {
  const [t] = De();
  return JA(t), null;
}
function JA(t) {
  ie(() => {
    if (!t.hasNodes([hn]))
      throw new Error("ParaNodePlugin: ParaNode not registered on editor!");
    return t.registerNodeTransform(hn, (e) => XA(e, t));
  }, [t]);
}
function XA(t, e) {
  up(e, t.getKey()) && Ub(t.getFirstChild()), !(!Yt(t) || t.getMarker() !== "b" || t.isEmpty() || !e.getEditorState().read(() => {
    const n = it(t.getKey());
    return Yt(n) && ((n == null ? void 0 : n.isEmpty()) ?? !1);
  })) && t.clear();
}
function Qb({ onStateChange: t }) {
  const [e] = De(), [n, r] = oe(e), o = he(!1), i = he(!1), s = he(), a = ce(() => {
    const l = ve();
    if (me(l)) {
      const c = l.anchor.getNode();
      let u = c.getKey() === "root" ? c : Ts(c, (f) => {
        const h = f.getParent();
        return h !== null && yy(h);
      });
      u === null && (u = c.getTopLevelElementOrThrow());
      const p = u.getKey();
      n.getElementByKey(p) !== null && (Yt(u) || wr(u) || ea(u)) && (s.current = u.getMarker(), t == null || t(o.current, i.current, s.current));
    }
  }, [n, t]);
  return ie(() => e.registerCommand(no, (l, c) => (a(), r(c), !1), Gr), [e, a]), ie(() => Gt(n.registerUpdateListener(({ editorState: l }) => {
    l.read(() => {
      a();
    });
  }), n.registerCommand(is, (l) => (o.current = l, t == null || t(o.current, i.current, s.current), !1), Gr), n.registerCommand(os, (l) => (i.current = l, t == null || t(o.current, i.current, s.current), !1), Gr)), [a, n, t]), null;
}
function YA({ textDirection: t }) {
  const [e] = De();
  return QA(e, t), ZA(e), null;
}
function QA(t, e) {
  ie(() => {
    function n() {
      const r = t.getRootElement();
      if (!r || e === "auto")
        return;
      r.dir = e;
      const o = t._config.theme.placeholder, i = document.getElementsByClassName(o)[0];
      i && (i.dir = e);
    }
    return n(), t.registerUpdateListener(({ dirtyElements: r }) => {
      r.size > 0 && n();
    });
  }, [t, e]);
}
function ZA(t) {
  ie(() => {
    const e = (n) => {
      if (n.key !== "ArrowLeft" && n.key !== "ArrowRight")
        return !1;
      const r = ve();
      if (!me(r))
        return !1;
      const o = r.anchor.getNode(), i = Ts(o, (p) => DN(p, t) === "p");
      if (!i)
        return !1;
      const s = t.getElementByKey(i.getKey());
      if (!s)
        return !1;
      const a = s.parentElement, l = s.dir || "ltr", c = ((a == null ? void 0 : a.dir) ?? "") || "ltr";
      if (!a || l === c)
        return !1;
      const u = a.dir === "rtl" && n.key === "ArrowLeft" || a.dir === "ltr" && n.key === "ArrowRight";
      return r.modify("move", u, "character"), n.preventDefault(), !0;
    };
    return t.registerCommand(Hs, e, Cl);
  }, [t]);
}
function eS() {
  const [t] = De();
  return tS(t), null;
}
function tS(t) {
  ie(() => {
    if (!t.hasNodes([ht, sn, $t, Hn, on]))
      throw new Error("TextSpacingPlugin: CharNode, ImmutableVerseNode, NoteNode, TextNode or VerseNode not registered on editor!");
    return Gt(t.registerNodeTransform(Hn, nS), t.registerNodeTransform(Hn, (e) => rS(e, t)), t.registerNodeTransform(on, qh), t.registerNodeTransform(sn, qh));
  }, [t]);
}
function nS(t) {
  if (!t.isAttached())
    return;
  const e = t.getTextContent(), n = t.getNextSibling(), r = t.getParent();
  t.getMode() !== "normal" || e.endsWith(" ") && e.length > 1 || Le(n) || et(r) || zt(r) || Zs(r) || (e === " " && !Rn(n) ? t.setTextContent("") : cp(t));
}
function rS(t, e) {
  const n = t.getParent();
  !Zs(n) || !t.isAttached() || up(e, t.getKey()) && n.insertAfter(t);
}
function qh(t) {
  if (!t.isAttached())
    return;
  const e = t.getPreviousSibling();
  e && !Rn(e) && !xe(e) && !Zs(e) && t.insertBefore(pt(" "));
}
function oS({ trigger: t, scriptureReference: e, contextMarker: n, getMarkerAction: r }) {
  const { markersMenuItems: o } = YT({
    scriptureReference: e,
    contextMarker: n,
    getMarkerAction: r
  });
  return d(XT, { trigger: t, items: o });
}
function iS({ trigger: t, scrRef: e, getMarkerAction: n }) {
  const { book: r, chapterNum: o, verseNum: i, verse: s } = e, a = ue(() => e, [r, o, i, s]), [l] = De(), [c] = sS(l);
  return aS(l), d(oS, { trigger: t, scriptureReference: a, contextMarker: c, getMarkerAction: n });
}
function sS(t) {
  const [e, n] = oe();
  return ie(() => t.registerCommand(no, () => (t.read(() => {
    const r = ve();
    if (!me(r)) {
      e && n(void 0);
      return;
    }
    const o = it(r.anchor.key), i = it(r.focus.key);
    if (!o || !i) {
      e && n(void 0);
      return;
    }
    const s = kN(o, i);
    if (!s || !rT(s)) {
      e && n(void 0);
      return;
    }
    const a = s.getMarker();
    e !== a && n(a);
  }), !1), to), [e, t]), [e];
}
function aS(t) {
  ie(() => {
    if (!t.hasNodes([on, sn]))
      throw new Error("UsjNodesMenuPlugin: VerseNode or ImmutableVerseNode not registered on editor!");
    const e = {}, n = {};
    return Gt(t.registerNodeTransform(sn, (r) => jh(r, t, e)), t.registerNodeTransform(on, (r) => jh(r, t, e)), t.registerMutationListener(sn, (r) => zh(r, t, e, n)), t.registerMutationListener(on, (r) => zh(r, t, e, n)));
  }, [t]);
}
function jh(t, e, n) {
  Cy(Wd) || up(e, t.getKey()) && uS(t, n);
}
function Uh(t) {
  return RegExp(/(\d+)([a-zA-Z]+)?(-(\d+)([a-zA-Z]+)?)?/).exec(t);
}
const Vh = 2, lS = 3, Hh = 4, cS = 5;
function uS(t, e) {
  var n;
  const r = tp(t), o = r == null ? void 0 : r.getNumber();
  if (!o)
    return;
  const i = e[o];
  if (!i)
    return;
  let s = parseInt(t.getNumber()), a = ((n = Uh(t.getNumber())) == null ? void 0 : n[Vh]) ?? "";
  i.forEach((l) => {
    const c = it(l);
    if (!c)
      return;
    const u = c.getNumber(), p = parseInt(u), f = Uh(u), h = !!(f != null && f[lS]), g = h ? parseInt(f[Hh]) : p;
    if (g < s || // e.g. insert 3b before 4 => 4
    p > s || // e.g. insert 3 before 3a => 4a
    g === s && a)
      return;
    const b = (f == null ? void 0 : f[Vh]) ?? "", _ = (f == null ? void 0 : f[cS]) ?? "", x = h ? $u(parseInt(f[Hh]), void 0) : "";
    let y = `${b}`;
    y += h ? `-${x}${_}` : "";
    const A = $u(p, void 0);
    c.setNumber(`${A}${y}`), s = parseInt(h ? x : A), a = h ? _ : b;
  });
}
function zh(t, e, n, r) {
  e.getEditorState().read(() => {
    for (const [o, i] of t) {
      const s = it(o);
      if (Rn(s)) {
        if (i === "created") {
          const a = tp(s);
          if (!a)
            continue;
          const l = a.getNumber();
          n[l] || (n[l] = []), n[l].push(o), r[o] = l;
        } else if (i === "destroyed") {
          const a = r[o], l = n[a];
          if (!l)
            continue;
          const c = l.findIndex((u) => u === o);
          if (c === -1)
            continue;
          l.splice(c, 1), Reflect.deleteProperty(r, o);
        }
      }
    }
  });
}
const Zb = "formatted", dS = "unformatted";
let mp;
function pS(t) {
  const e = fS(t);
  if (!e)
    throw new Error(`Invalid view mode: ${t}`);
  mp = e;
}
pS(Zb);
const bp = () => mp;
function fS(t) {
  let e;
  switch (t) {
    case Zb:
      e = {
        markerMode: "hidden",
        noteMode: "collapsed",
        hasSpacing: !0,
        isFormattedFont: !0
      };
      break;
    case dS:
      e = {
        markerMode: "editable",
        noteMode: "expanded",
        hasSpacing: !1,
        isFormattedFont: !1
      };
      break;
  }
  return e;
}
function hS(t) {
  if (t)
    return t.markerMode === "editable" ? on : sn;
}
function wS(t) {
  const e = [], n = t ?? mp;
  return n && (e.push(`${Qk}${n.markerMode}`), n.hasSpacing && e.push(Xk), n.isFormattedFont && e.push(Yk)), e;
}
let qu;
function gS(t) {
  t && (qu = t);
}
function mS(t) {
  return t.isEmpty() ? Sd : bS(t.toJSON());
}
function bS(t) {
  if (!t.root || !t.root.children) return;
  const e = t.root.children;
  if (e.length === 1 && Yd(e[0]) && (!e[0].children || e[0].children.length === 0))
    return Sd;
  const n = e0(e), r = Br(n);
  return r ? { type: ks, version: Ns, content: r } : void 0;
}
function vS(t, e) {
  const { type: n, marker: r, unknownAttributes: o } = t;
  let i;
  return t.code !== "" && (i = t.code), Dt({
    type: n,
    marker: r,
    code: i,
    ...o,
    content: e
  });
}
function yS(t) {
  const { marker: e, number: n, sid: r, altnumber: o, pubnumber: i, unknownAttributes: s } = t;
  return Dt({
    type: Zn.getType(),
    marker: e,
    number: n,
    sid: r,
    altnumber: o,
    pubnumber: i,
    ...s
  });
}
function xS(t, e) {
  const { marker: n, sid: r, altnumber: o, pubnumber: i, unknownAttributes: s } = t, a = e && typeof e[0] == "string" ? e[0] : void 0;
  let { number: l } = t;
  return l = Ab(n, a, l), Dt({
    type: Zn.getType(),
    marker: n,
    number: l,
    sid: r,
    altnumber: o,
    pubnumber: i,
    ...s
  });
}
function _S(t) {
  const { marker: e, sid: n, altnumber: r, pubnumber: o, unknownAttributes: i } = t, { text: s } = t;
  let { number: a } = t;
  return a = Ab(e, s, a), Dt({
    type: on.getType(),
    marker: e,
    number: a,
    sid: n,
    altnumber: r,
    pubnumber: o,
    ...i
  });
}
function CS(t, e) {
  const { type: n, marker: r, unknownAttributes: o } = t, i = r === "" ? void 0 : r;
  return e == null || e.forEach((s, a) => {
    typeof s == "string" && s.startsWith(Ze) && (e[a] = s.slice(1));
  }), Dt({
    type: n,
    marker: i,
    ...o,
    content: e
  });
}
function ES(t, e) {
  const { type: n, marker: r, unknownAttributes: o } = t;
  return Dt({
    type: n,
    marker: r,
    ...o,
    content: e
  });
}
function kS(t, e) {
  const { type: n, marker: r, caller: o, category: i, unknownAttributes: s } = t;
  return Dt({
    type: n,
    marker: r,
    caller: o,
    category: i,
    ...s,
    content: e
  });
}
function ii(t) {
  const { type: e, marker: n, sid: r, eid: o, unknownAttributes: i } = t;
  return Dt({
    type: e,
    marker: n === "" ? void 0 : n,
    sid: r,
    eid: o,
    ...i
  });
}
function NS(t) {
  return t.text;
}
function TS(t, e) {
  const { tag: n, marker: r, unknownAttributes: o } = t;
  return Dt({
    type: n,
    marker: r,
    ...o,
    content: e
  });
}
function AS(t) {
  const { marker: e } = t;
  return {
    type: cl,
    marker: e === "" ? void 0 : e
  };
}
function Gh(t, e) {
  const n = t[t.length - 1];
  n && typeof n == "string" ? t[t.length - 1] = n + e : t.push(e);
}
function SS(t, e, n, r, o) {
  const i = mr.getType(), s = e.filter((a) => !n.includes(a));
  if (n.filter((a) => !e.includes(a)).forEach((a) => {
    const l = ii({
      type: i,
      marker: di,
      eid: a
    });
    o.push(l);
  }), s.forEach((a) => {
    const l = ii({
      type: i,
      marker: Po,
      sid: a
    });
    o.push(l);
  }), e.length === 0) {
    const a = ii({
      type: i,
      marker: Po
    });
    o.push(a);
  }
  if (o.push(...t), e.length === 0) {
    const a = ii({
      type: i,
      marker: di
    });
    o.push(a);
  }
  (!r || !PN(r)) && e.forEach((a) => {
    const l = ii({
      type: i,
      marker: di,
      eid: a
    });
    o.push(l);
  });
}
function Br(t, e) {
  const n = [];
  let r, o = [];
  return t.forEach((i, s) => {
    const a = i, l = i, c = i, u = i, p = i, f = i, h = i, g = i;
    switch (i.type) {
      case In.getType():
        n.push(
          vS(a, Br(a.children))
        );
        break;
      case Lr.getType():
        n.push(yS(i));
        break;
      case Zn.getType():
        n.push(
          xS(l, Br(l.children))
        );
        break;
      case sn.getType():
      case on.getType():
        n.push(_S(i));
        break;
      case ht.getType():
        n.push(
          CS(c, Br(c.children))
        );
        break;
      case hn.getType():
        n.push(
          ES(u, Br(u.children))
        );
        break;
      case $t.getType():
        n.push(
          kS(
            p,
            Br(p.children, p.caller)
          )
        );
        break;
      case ao.getType():
      case Gn.getType():
      case td.getType():
      case Wo.getType():
        break;
      case Vt.getType():
        if (r = Br(h.children), r) {
          const b = h.typedIDs[zr];
          if (b)
            SS(r, b, o, t[s + 1], n), o = b;
          else {
            const _ = r.shift();
            _ && (typeof _ == "string" ? Gh(n, _) : n.push(_)), r.length > 0 && n.push(...r);
          }
        }
        break;
      case mr.getType():
        n.push(ii(i));
        break;
      case Hn.getType():
        f.text && f.text !== Ze && !f.text.startsWith(Gd) && (!e || f.text !== rp(e)) && Gh(n, NS(f));
        break;
      case Ko.getType():
        n.push(
          TS(g, Br(g.children))
        );
        break;
      case lo.getType():
        n.push(AS(i));
        break;
      default:
        qu == null || qu.error(`Unexpected node type '${i.type}'!`);
    }
  }), n && n.length > 0 ? n : void 0;
}
function e0(t) {
  const e = t.findIndex((n) => Yd(n));
  if (e >= 0) {
    const n = t.slice(0, e), r = t[e].children, o = e0(t.slice(e + 1));
    t = [...n, ...r, ...o];
  }
  return t;
}
const Hc = {
  initialize: gS,
  deserializeEditorState: mS
}, Kh = t0([]), DS = {
  type: td.getType(),
  version: 1
};
let pl = [], Ee, za, ju, ot;
function MS(t, e) {
  pl = [], IS(t), LS(e);
}
function OS(t = 0) {
}
function RS(t, e) {
  Ee = e ?? bp();
  let n;
  return t ? (t.type !== ks && (ot == null || ot.warn(`This USJ type '${t.type}' didn't match the expected type '${ks}'.`)), t.version !== Ns && (ot == null || ot.warn(
    `This USJ version '${t.version}' didn't match the expected version '${Ns}'.`
  )), t.content.length > 0 ? n = Vu(us(t.content)) : n = [Kh]) : n = [Kh], ju == null || ju(pl), {
    root: {
      children: n,
      direction: null,
      format: "",
      indent: 0,
      type: "root",
      version: 1
    }
  };
}
function IS(t) {
  t && (za = t), t != null && t.addMissingComments && (ju = t.addMissingComments);
}
function LS(t) {
  t && (ot = t);
}
function PS(t) {
  return !t || t.length !== 1 || typeof t[0] != "string" ? "" : t[0];
}
function $S(t) {
  let { marker: e } = t;
  e !== Ls && (ot == null || ot.warn(`Unexpected book marker '${e}'!`)), e = e ?? Ls;
  const { code: n } = t;
  (!n || !In.isValidBookCode(n)) && (ot == null || ot.warn(`Unexpected book code '${n}'!`));
  const r = [];
  ((Ee == null ? void 0 : Ee.markerMode) === "editable" || (Ee == null ? void 0 : Ee.markerMode) === "visible") && r.push(
    qo("marker", Pr(e) + " " + n + Ze)
  );
  const o = PS(t.content);
  o && r.push(Bo(o));
  const i = Ft(t);
  return Dt({
    type: In.getType(),
    marker: e,
    code: n ?? "",
    unknownAttributes: i,
    children: r,
    direction: null,
    format: "",
    indent: 0,
    version: cb
  });
}
function FS(t) {
  let { marker: e } = t;
  e !== sl && (ot == null || ot.warn(`Unexpected chapter marker '${e}'!`)), e = e ?? sl;
  const { number: n, sid: r, altnumber: o, pubnumber: i } = t, s = Ft(t);
  let a;
  return (Ee == null ? void 0 : Ee.markerMode) === "visible" && (a = !0), (Ee == null ? void 0 : Ee.markerMode) === "editable" ? Dt({
    type: Zn.getType(),
    marker: e,
    number: n ?? "",
    sid: r,
    altnumber: o,
    pubnumber: i,
    unknownAttributes: s,
    children: [Bo(ta(e, n) ?? "")],
    direction: null,
    format: "",
    indent: 0,
    version: pb
  }) : Dt({
    type: Lr.getType(),
    marker: e,
    number: n ?? "",
    showMarker: a,
    sid: r,
    altnumber: o,
    pubnumber: i,
    unknownAttributes: s,
    version: mb
  });
}
function BS(t) {
  let { marker: e } = t;
  e !== al && (ot == null || ot.warn(`Unexpected verse marker '${e}'!`)), e = e ?? al;
  const { number: n, sid: r, altnumber: o, pubnumber: i } = t, s = (hS(Ee) ?? sn).getType(), a = (Ee == null ? void 0 : Ee.markerMode) === "editable" ? kb : Fb;
  let l, c;
  (Ee == null ? void 0 : Ee.markerMode) === "editable" ? l = ta(e, n) : (Ee == null ? void 0 : Ee.markerMode) === "visible" && (c = !0);
  const u = Ft(t);
  return Dt({
    type: s,
    text: l,
    marker: e,
    number: n ?? "",
    sid: r,
    altnumber: o,
    pubnumber: i,
    showMarker: c,
    unknownAttributes: u,
    version: a
  });
}
function qS(t, e = []) {
  let { marker: n } = t;
  ht.isValidMarker(n) || ot == null || ot.warn(`Unexpected char marker '${n}'!`), n = n ?? "", (Ee == null ? void 0 : Ee.markerMode) === "editable" && e.forEach((o) => {
    np(o) && (o.text = Ze + o.text);
  });
  const r = Ft(t);
  return Dt({
    type: ht.getType(),
    marker: n,
    unknownAttributes: r,
    children: [...e],
    direction: null,
    format: "",
    indent: 0,
    textFormat: 0,
    textStyle: "",
    version: gb
  });
}
function t0(t) {
  return {
    type: Yr.getType(),
    children: t,
    direction: null,
    format: "",
    indent: 0,
    textFormat: 0,
    textStyle: "",
    version: yb
  };
}
function jS(t, e = []) {
  let { marker: n } = t;
  hn.isValidMarker(n) || ot == null || ot.warn(`Unexpected para marker '${n}'!`), n = n ?? zl;
  const r = [];
  (Ee == null ? void 0 : Ee.markerMode) === "editable" ? r.push(Ai(n), Bo(Ze)) : (Ee == null ? void 0 : Ee.markerMode) === "visible" && r.push(qo("marker", Pr(n) + Ze)), r.push(...e);
  const o = Ft(t);
  return Dt({
    type: hn.getType(),
    marker: n,
    unknownAttributes: o,
    children: r,
    direction: null,
    format: "",
    indent: 0,
    textFormat: 0,
    textStyle: "",
    version: Eb
  });
}
function US(t, e) {
  const n = SN(e);
  let r = () => {
  };
  return za != null && za.noteCallerOnClick && (r = za.noteCallerOnClick), Dt({
    type: Gn.getType(),
    caller: t,
    previewText: n,
    onClick: r,
    version: zb
  });
}
function VS(t, e) {
  let { marker: n } = t;
  $t.isValidMarker(n) || ot == null || ot.warn(`Unexpected note marker '${n}'!`), n = n ?? Qd;
  const { category: r } = t, o = t.caller ?? "*", i = (Ee == null ? void 0 : Ee.noteMode) !== "expanded", s = Ft(t);
  let a, l;
  (Ee == null ? void 0 : Ee.markerMode) === "editable" ? (a = Ai(n), l = Ai(n, "closing")) : (Ee == null ? void 0 : Ee.markerMode) === "visible" && (a = qo("marker", Pr(n) + Ze), l = qo("marker", ki(n) + Ze));
  const c = [];
  let u;
  if (a && c.push(a), (Ee == null ? void 0 : Ee.markerMode) === "editable")
    u = Bo(rp(o)), c.push(u, ...e);
  else {
    const p = Bo(Ze);
    u = US(o, e), c.push(u, p, ...e.flatMap(HS(p)));
  }
  return l && c.push(l), Dt({
    type: $t.getType(),
    marker: n,
    caller: o,
    isCollapsed: i,
    category: r,
    unknownAttributes: s,
    children: c,
    direction: null,
    format: "",
    indent: 0,
    version: Cb
  });
}
function HS(t) {
  return (e) => qN(e) ? [e] : [e, t];
}
function zS(t) {
  let { marker: e } = t;
  (!e || !mr.isValidMarker(e)) && (ot == null || ot.warn(`Unexpected milestone marker '${e}'!`)), e = e ?? "";
  const { sid: n, eid: r } = t, o = Ft(t);
  return Dt({
    type: mr.getType(),
    marker: e,
    sid: n,
    eid: r,
    unknownAttributes: o,
    version: xb
  });
}
function Wh(t, e = []) {
  return {
    type: Vt.getType(),
    typedIDs: { [zr]: e },
    children: t,
    direction: null,
    format: "",
    indent: 0,
    version: 1
  };
}
function GS(t, e) {
  const { marker: n } = t, r = t.type, o = Ft(t), i = [...e];
  return i.forEach((s) => {
    np(s) && (s.mode = "token");
  }), Dt({
    type: Ko.getType(),
    tag: r,
    marker: n,
    unknownAttributes: o,
    children: i,
    direction: null,
    format: "",
    indent: 0,
    version: ab
  });
}
function KS(t) {
  return {
    type: lo.getType(),
    marker: t,
    version: Ib
  };
}
function Ai(t, e = "opening") {
  return {
    type: Wo.getType(),
    marker: t,
    markerSyntax: e,
    text: "",
    detail: 0,
    format: 0,
    mode: "normal",
    style: "",
    version: 1
  };
}
function Bo(t, e = "normal") {
  return {
    type: Hn.getType(),
    text: t,
    detail: 0,
    format: 0,
    mode: e,
    style: "",
    version: 1
  };
}
function qo(t, e) {
  return {
    type: ao.getType(),
    text: e,
    textType: t,
    version: Rb
  };
}
function Jh(t, e) {
  (Ee == null ? void 0 : Ee.markerMode) === "editable" ? e.push(Ai(t)) : (Ee == null ? void 0 : Ee.markerMode) === "visible" && e.push(qo("marker", Pr(t)));
}
function Xh(t, e, n = !1) {
  ht.isValidFootnoteMarker(t) || ht.isValidCrossReferenceMarker(t) || ((Ee == null ? void 0 : Ee.markerMode) === "editable" ? n ? e.push(Ai("", "selfClosing")) : e.push(Ai(t, "closing")) : (Ee == null ? void 0 : Ee.markerMode) === "visible" && e.push(qo("marker", ki(n ? "" : t))));
}
function WS(t, e) {
  if (t.type !== "ms") return;
  const n = [];
  if (t.sid && n.push(`sid="${t.sid}"`), t.eid && n.push(`eid="${t.eid}"`), n.length <= 0) return;
  const r = Gd + n.join(" ");
  (Ee == null ? void 0 : Ee.markerMode) === "editable" ? e.push(Bo(r)) : (Ee == null ? void 0 : Ee.markerMode) === "visible" && e.push(qo("attribute", r));
}
function Yh(t, e) {
  return t.length <= 0 || e === 0 ? t : t.map((n) => n - e);
}
function JS(t, e) {
  const n = t.indexOf(e, 0);
  n > -1 && t.splice(n, 1);
}
function Qh(t, e) {
  e.marker === Po && e.sid !== void 0 && t.push(e.sid), e.marker === di && e.eid !== void 0 && JS(t, e.eid);
}
function Uu(t, e, n = !1, r = []) {
  if (e.length <= 0 || e[0] >= t.length) return t;
  const o = e.shift(), i = e.length > 0 ? e.shift() : t.length - 1;
  if (o === void 0 || i === void 0 || i >= t.length || t.length <= 0)
    return t;
  const s = t.slice(0, o), a = n ? [Wh(s, [...r])] : s, l = t[o];
  Qh(r, l);
  const c = Uu(
    t.slice(o + 1, i),
    Yh(e, o + 1),
    l.marker === Po,
    r
  ), u = Wh(c, [...r]), p = t[i];
  Qh(r, p);
  const f = Uu(
    t.slice(i + 1),
    Yh(e, i + 1),
    p.marker === Po,
    r
  );
  return [...a, u, ...f];
}
function us(t) {
  const e = [], n = [];
  return t == null || t.forEach((r) => {
    if (typeof r == "string")
      r && n.push(Bo(r));
    else if (!r.type)
      ot == null || ot.error("Marker type is missing!");
    else
      switch (r.type) {
        case In.getType():
          n.push($S(r));
          break;
        case Zn.getType():
          n.push(FS(r));
          break;
        case on.getType():
          Ee != null && Ee.hasSpacing || n.push(DS), n.push(BS(r));
          break;
        case ht.getType():
          Jh(r.marker ?? "", n), n.push(qS(r, us(r.content))), Xh(r.marker ?? "", n);
          break;
        case hn.getType():
          n.push(jS(r, us(r.content)));
          break;
        case $t.getType():
          n.push(VS(r, us(r.content)));
          break;
        case mr.getType():
          uN(r.marker ?? "") && (e.push(n.length), r.sid !== void 0 && (pl == null || pl.push(r.sid))), n.push(zS(r)), Jh(r.marker ?? "", n), WS(r, n), Xh(r.marker ?? "", n, !0);
          break;
        case lo.getType():
          n.push(KS(r.marker ?? ""));
          break;
        default:
          ot == null || ot.warn(`Unknown type-marker '${r.type}-${r.marker}'!`), n.push(GS(r, us(r.content)));
      }
  }), Uu(n, e);
}
function Vu(t) {
  const e = t.findIndex(
    (n) => Jk(n) || bN(n) || gN(n)
  );
  if (e >= 0) {
    const n = Vu(t.slice(0, e)), r = t[e], o = Vu(t.slice(e + 1));
    return [...n, r, ...o];
  } else if (t.some((n) => "text" in n && "mode" in n || JN(n)))
    return [t0(t)];
  return t;
}
const Hu = {
  initialize: MS,
  reset: OS,
  serializeEditorState: RS
}, La = (t) => {
  if (!$t.isValidMarker(t) || !t.includes("f"))
    throw new Error(`Invalid footnote marker '${t}'`);
  return {
    action: (e) => {
      const { chapterNum: n, verseNum: r } = e.reference, o = [];
      return n !== void 0 && r !== void 0 && o.push({
        type: "char",
        marker: "fr",
        content: [`${n}:${r}`]
      }), e.noteText && o.push({
        type: "char",
        marker: "fq",
        content: [e.noteText]
      }), o.push({ type: "char", marker: "ft", content: ["-"] }), [{
        type: "note",
        marker: t,
        caller: Lo,
        content: o
      }];
    }
  };
}, Zh = (t) => {
  if (!$t.isValidMarker(t) || !t.includes("x"))
    throw new Error(`Invalid cross-reference marker '${t}'`);
  return {
    action: (e) => {
      const { chapterNum: n, verseNum: r } = e.reference, o = [];
      return n !== void 0 && r !== void 0 && o.push({
        type: "char",
        marker: "xo",
        content: [`${n}:${r}`]
      }), o.push({ type: "char", marker: "xt", content: ["-"] }), [{
        type: "note",
        marker: t,
        caller: Kd,
        content: o
      }];
    }
  };
}, XS = {
  c: {
    action: (t) => {
      const { chapterNum: e } = t.reference;
      return [{
        type: "chapter",
        marker: "c",
        number: `${e + 1}`
      }];
    }
  },
  v: {
    action: (t) => {
      const { verseNum: e, verse: n } = t.reference;
      return [{
        type: "verse",
        marker: "v",
        number: `${$u(e, n)}`
      }];
    }
  },
  f: La("f"),
  fe: La("fe"),
  ef: La("ef"),
  efe: La("efe"),
  x: Zh("x"),
  ex: Zh("ex")
};
function YS(t, e, n, r, o) {
  const i = QS(t);
  return { action: (s) => {
    s.editor.update(() => {
      var a;
      const l = ve();
      me(l) && (s.noteText = l.getTextContent());
      const c = (a = i == null ? void 0 : i.action) == null ? void 0 : a.call(i, s);
      if (!c) return;
      const u = Th(c, Hu, r), p = Bc(u);
      if (me(l)) {
        const f = l.anchor.getNode();
        if (Le(p))
          Bb(p, l, r), p.getIsCollapsed() || (e.current = p.getKey());
        else if (l.getTextContent().length > 0)
          ZS(
            l,
            () => Bc(u)
          );
        else if (Ae(p) && !p.isInline()) {
          const h = l.insertParagraph();
          if (h) {
            const g = h.getChildren();
            p.append(...g), h.replace(p), p.selectStart();
          }
        } else if (xe(f) && !na(f) && Le(f.getParent()) && l.isCollapsed()) {
          let h = f.insertAfter(p);
          if (ll(p)) {
            const g = {
              ...r || bp(),
              markerMode: "hidden"
            }, b = Th(
              c,
              Hu,
              g
            ), _ = Bc(b);
            h = h.insertAfter(_);
          }
          h.insertAfter(pt(Ze));
        } else {
          l.insertNodes([p]), oD(p);
          const h = p.getNextSibling();
          h ? h.selectStart() : p.selectStart();
        }
      } else
        l == null || l.insertNodes([p]);
    }, o);
  }, label: i == null ? void 0 : i.label };
}
function QS(t) {
  let e = XS[t];
  return e || (hn.isValidMarker(t) ? e = {
    action: () => [{
      type: hn.getType(),
      marker: t,
      content: []
    }]
  } : ht.isValidMarker(t) && (e = {
    action: () => [{
      type: ht.getType(),
      marker: t,
      content: ["-"]
    }]
  })), e;
}
function ZS(t, e) {
  const n = t.getNodes(), [r, o] = eD(t);
  let i;
  n.forEach((s, a) => {
    if (Ae(i) && i.isParentOf(s))
      return;
    const l = tD(
      s,
      a === 0,
      a === n.length - 1,
      r,
      o
    );
    if (!l) {
      i = void 0;
      return;
    }
    i || (i = e(), l.insertBefore(i)), rD(l, i);
  }), (xe(i) || Ae(i)) && i.selectEnd();
}
function eD(t) {
  const e = t.anchor.offset, n = t.focus.offset;
  return t.isBackward() ? [n, e] : [e, n];
}
function tD(t, e, n, r, o) {
  if (!(zt(t) || Le(t) || Le(t.getParent()))) {
    if (xe(t))
      return nD(t, e, n, r, o);
    if (Ae(t) && t.isInline())
      return t;
  }
}
function nD(t, e, n, r, o) {
  const i = t.getTextContentSize(), s = e ? r : 0, a = n ? o : i;
  if (s === 0 && a === 0) return;
  const l = t.splitText(s, a);
  return l.length === 1 ? l[0] : l.length === 3 || a === i ? l[1] : l[0];
}
function rD(t, e) {
  var n;
  if (xe(e)) {
    const r = ew(t, e);
    e.setTextContent(r), t.remove();
  } else if (Ae(e)) {
    const r = e.getChildrenSize();
    e.append(t);
    for (let o = 0; o < r; o++) (n = e.getFirstChild()) == null || n.remove();
    ew(t, e);
  }
}
function ew(t, e) {
  let n = t.getTextContent();
  if (xe(t) && e.isInline() && n.startsWith(" ")) {
    n = n.trimStart(), t.setTextContent(n);
    const r = e.getPreviousSibling();
    cp(r), xe(r) || e.insertBefore(pt(" "));
  }
  return n;
}
function oD(t) {
  Rn(t) && (cp(t.getPreviousSibling()), Ub(t.getNextSibling()));
}
const n0 = {
  chapter: "chapter",
  verse: "verse",
  char: "char",
  para: "para",
  typedMark: "editor-typed-mark",
  typedMarkOverlap: "editor-typed-markOverlap",
  mark: "editor-mark",
  markOverlap: "editor-markOverlap",
  placeholder: "editor-placeholder",
  paragraph: "editor-paragraph",
  quote: "editor-quote",
  heading: {
    h1: "editor-heading-h1",
    h2: "editor-heading-h2",
    h3: "editor-heading-h3",
    h4: "editor-heading-h4",
    h5: "editor-heading-h5"
  },
  list: {
    nested: {
      listitem: "editor-nested-listitem"
    },
    ol: "editor-list-ol",
    ul: "editor-list-ul",
    listitem: "editor-listitem"
  },
  image: "editor-image",
  link: "editor-link",
  text: {
    bold: "editor-text-bold",
    italic: "editor-text-italic",
    overflowed: "editor-text-overflowed",
    hashtag: "editor-text-hashtag",
    underline: "editor-text-underline",
    strikethrough: "editor-text-strikethrough",
    underlineStrikethrough: "editor-text-underlineStrikethrough"
  }
};
function iD({
  options: t,
  editedUsjRef: e,
  usj: n,
  setUsj: r
}) {
  const { view: o, nodes: i } = t || {}, { hasSpacing: s, isFormattedFont: a, markerMode: l } = o || {};
  return ie(() => {
    e.current && !kr(e.current, n) && r(e.current);
  }, [e, s, a, l, i, r, n]), null;
}
function sD({
  scrRef: t,
  onScrRefChange: e
}) {
  const [n] = De(), r = he(!1), o = he(!1), { book: i, chapterNum: s, verseNum: a } = t;
  return ie(
    () => n.registerMutationListener(
      In,
      (l) => {
        n.update(
          () => {
            for (const [c, u] of l) {
              const p = it(c);
              p && wr(p) && u === "created" && tw(s, a, o);
            }
          },
          { tag: Iu }
        );
      },
      { skipInitialization: !0 }
    ),
    [n, s, a]
  ), ie(() => {
    r.current ? r.current = !1 : n.update(() => tw(s, a, o), {
      tag: Iu
    });
  }, [n, s, a]), ie(
    () => n.registerCommand(
      no,
      () => (o.current ? o.current = !1 : aD(
        i,
        s,
        a,
        e,
        r
      ), !1),
      to
    ),
    [n, i, s, a, e]
  ), null;
}
function tw(t, e, n) {
  var r;
  const o = Db(ve()), i = (r = jb(o)) == null ? void 0 : r.getNumber();
  if (MN(i) && ip(e, i)) return;
  const s = tt().getChildren(), a = vN(s, t), l = AN(s, a), c = yN(l, !!a);
  if (c && !a || !a) return;
  TN(l, c);
  const u = nT(l, e);
  if (u) {
    if (Yt(u)) {
      const p = u.getFirstChild();
      xe(p) ? p.select(0, 0) : u.select(0, 0);
    } else u.selectNext(0, 0);
    n.current = !0;
  }
}
function aD(t, e, n, r, o) {
  const i = Db(ve());
  if (!i) return;
  const s = tp(i), a = parseInt((s == null ? void 0 : s.getNumber()) ?? "1", 10), l = jb(i), c = l == null ? void 0 : l.getNumber(), u = parseInt(c ?? "0", 10), p = c ? ip(n, c) : n === u;
  if (o.current = !!(s && a !== e || !p), o.current) {
    const f = {
      book: t,
      chapterNum: a,
      verseNum: u
    };
    c != null && u.toString() !== c && (f.verse = c), r(f);
  }
}
function lD(t) {
  return wr(t) ? `${t.__code}` : Jd(t) ? `${t.__marker} "${t.__number}"` : et(t) ? `${t.__marker}` : ea(t) ? `${t.__marker} "${t.__number}"` : co(t) ? `${t.__caller}` : Hi(t) ? `${t.__marker} "${t.__number}"` : Le(t) ? `${t.__marker} "${t.__caller}"` + (t.__isCollapsed ? " (collapsed)" : " (expanded)") : Yt(t) ? `${t.__marker}` : zt(t) ? `ids: [ ${JSON.stringify(t.getTypedIDs())} ]` : ep(t) ? `${t.__marker} "${t.__number}"` : "";
}
function cD() {
  const [t] = De();
  return /* @__PURE__ */ d(
    N_,
    {
      viewClassName: "tree-view-output",
      treeTypeButtonClassName: "debug-treetype-button",
      timeTravelPanelClassName: "debug-timetravel-panel",
      timeTravelButtonClassName: "debug-timetravel-button",
      timeTravelPanelSliderClassName: "debug-timetravel-panel-slider",
      timeTravelPanelButtonClassName: "debug-timetravel-panel-button",
      customPrintNode: lD,
      editor: t
    }
  );
}
const r0 = Zr(null), nw = 4;
function uD({
  children: t,
  className: e,
  onClick: n,
  title: r
}) {
  const o = he(null), i = jo(r0);
  if (i === null)
    throw new Error("DropDownItem must be used within a DropDown");
  const { registerItem: s } = i;
  return ie(() => {
    o && o.current && s(o);
  }, [o, s]), /* @__PURE__ */ d("button", { className: e, onClick: n, ref: o, title: r, type: "button", children: t });
}
function dD({
  children: t,
  dropDownRef: e,
  onClose: n
}) {
  const [r, o] = oe(), [i, s] = oe(), a = ce(
    (u) => {
      o((p) => p ? [...p, u] : [u]);
    },
    [o]
  ), l = (u) => {
    if (!r) return;
    const p = u.key;
    ["Escape", "ArrowUp", "ArrowDown", "Tab"].includes(p) && u.preventDefault(), p === "Escape" || p === "Tab" ? n() : p === "ArrowUp" ? s((f) => {
      if (!f) return r[0];
      const h = r.indexOf(f) - 1;
      return r[h === -1 ? r.length - 1 : h];
    }) : p === "ArrowDown" && s((f) => f ? r[r.indexOf(f) + 1] : r[0]);
  }, c = ue(
    () => ({
      registerItem: a
    }),
    [a]
  );
  return ie(() => {
    r && !i && s(r[0]), i && i.current && i.current.focus();
  }, [r, i]), /* @__PURE__ */ d(r0.Provider, { value: c, children: /* @__PURE__ */ d("div", { className: "dropdown", ref: e, onKeyDown: l, children: t }) });
}
function pD({
  disabled: t = !1,
  buttonLabel: e,
  buttonAriaLabel: n,
  buttonClassName: r,
  buttonIconClassName: o,
  children: i,
  stopCloseOnClickSelf: s
}) {
  const a = he(null), l = he(null), [c, u] = oe(!1), p = () => {
    u(!1), l && l.current && l.current.focus();
  };
  return ie(() => {
    const f = l.current, h = a.current;
    if (c && f !== null && h !== null) {
      const { top: g, left: b } = f.getBoundingClientRect();
      h.style.top = `${g + f.offsetHeight + nw}px`, h.style.left = `${Math.min(b, window.innerWidth - h.offsetWidth - 20)}px`;
    }
  }, [a, l, c]), ie(() => {
    const f = l.current;
    if (f !== null && c) {
      const h = (g) => {
        const b = g.target;
        s && a.current && a.current.contains(b) || f.contains(b) || u(!1);
      };
      return document.addEventListener("click", h), () => {
        document.removeEventListener("click", h);
      };
    }
    return () => {
    };
  }, [a, l, c, s]), ie(() => {
    const f = () => {
      if (c) {
        const h = l.current, g = a.current;
        if (h !== null && g !== null) {
          const { top: b } = h.getBoundingClientRect(), _ = b + h.offsetHeight + nw;
          _ !== g.getBoundingClientRect().top && (g.style.top = `${_}px`);
        }
      }
    };
    return document.addEventListener("scroll", f), () => {
      document.removeEventListener("scroll", f);
    };
  }, [l, a, c]), /* @__PURE__ */ M(ft, { children: [
    /* @__PURE__ */ M(
      "button",
      {
        type: "button",
        disabled: t,
        "aria-label": n || e,
        className: r,
        onClick: () => u(!c),
        ref: l,
        children: [
          o && /* @__PURE__ */ d("span", { className: o }),
          e && /* @__PURE__ */ d("span", { className: "text dropdown-button-text", children: e }),
          /* @__PURE__ */ d("i", { className: "chevron-down" })
        ]
      }
    ),
    c && ur(
      /* @__PURE__ */ d(dD, { dropDownRef: a, onClose: p, children: i }),
      document.body
    )
  ] });
}
const zu = {
  m: "m - Paragraph - Margin - No First Line Indent",
  ms: "ms - Heading - Major Section Level 1",
  nb: "nb - Paragraph - No Break with Previous Paragraph",
  p: "p - Paragraph - Normal - First Line Indent",
  pi: "pi - Paragraph - Indented - Level 1 - First Line Indent",
  q1: "q1 - Poetry - Indent Level 1",
  q2: "q2 - Poetry - Indent Level 2",
  r: "r - Heading - Parallel References",
  s: "s - Heading - Section Level 1"
  // do not allow `b - Poetry - Stanza Break (Blank Line)` here to avoid a USFM validity issue.
}, Gu = {
  ...zu,
  ide: "ide - File - Encoding",
  h: "h - File - Header",
  h1: "h1 - File - Header",
  h2: "h2 - File - Left Header",
  h3: "h3 - File - Right Header",
  toc1: "toc1 - File - Long Table of Contents Text",
  toc2: "toc2 - File - Short Table of Contents Text",
  toc3: "toc3 - File - Book Abbreviation",
  cl: "cl - Chapter - Publishing Label",
  mt: "mt - Title - Major Title Level 1",
  mt1: "mt1 - Title - Major Title Level 1",
  mt2: "mt2 - Title - Major Title Level 2",
  mt3: "mt3 - Title - Major Title Level 3",
  mt4: "mt4 - Title - Major Title Level 4",
  ms1: "ms1 - Heading - Major Section Level 1",
  ms2: "ms2 - Heading - Major Section Level 2",
  ms3: "ms3 - Heading - Major Section Level 3",
  b: "b - Poetry - Stanza Break (Blank Line)"
};
function fD({
  editorRef: t,
  blockMarker: e,
  disabled: n = !1
}) {
  return /* @__PURE__ */ d(
    pD,
    {
      disabled: n,
      buttonClassName: "toolbar-item block-controls",
      buttonIconClassName: "icon block-marker " + hD(e),
      buttonLabel: wD(e),
      buttonAriaLabel: "Formatting options for block type",
      children: Object.keys(zu).map((r) => /* @__PURE__ */ M(
        uD,
        {
          className: "item block-marker " + gD(e === r),
          onClick: () => {
            var o;
            return (o = t.current) == null ? void 0 : o.formatPara(r);
          },
          children: [
            /* @__PURE__ */ d("i", { className: "icon block-marker " + r }),
            /* @__PURE__ */ d("span", { className: "text usfm_" + r, children: zu[r] })
          ]
        },
        r
      ))
    }
  );
}
function hD(t) {
  return t && t in Gu ? t : "ban";
}
function wD(t) {
  return t && t in Gu ? Gu[t] : "No Style";
}
function gD(t) {
  return t ? "active dropdown-item-active" : "";
}
function rw() {
  return /* @__PURE__ */ d("div", { className: "divider" });
}
const mD = an(function({ editorRef: t, isReadonly: e = !1, onStateChange: n }, r) {
  const [o] = De(), [i, s] = oe(o), [a, l] = oe(), [c, u] = oe(!1), [p, f] = oe(!1), h = ce(
    (g, b, _) => {
      u(g), f(b), l(_), n == null || n(g, b, _);
    },
    [n]
  );
  return ie(() => o.registerCommand(
    no,
    (g, b) => (s(b), !1),
    Gr
  ), [o]), /* @__PURE__ */ M(ft, { children: [
    /* @__PURE__ */ d(Qb, { onStateChange: h }),
    /* @__PURE__ */ M("div", { className: "toolbar", children: [
      /* @__PURE__ */ d(
        "button",
        {
          disabled: !c || e,
          onClick: () => {
            i.dispatchCommand(sd, void 0);
          },
          title: fu ? "Undo (âŒ˜Z)" : "Undo (Ctrl+Z)",
          type: "button",
          className: "toolbar-item spaced",
          "aria-label": "Undo",
          children: /* @__PURE__ */ d("i", { className: "format undo" })
        }
      ),
      /* @__PURE__ */ d(
        "button",
        {
          disabled: !p || e,
          onClick: () => {
            i.dispatchCommand(id, void 0);
          },
          title: fu ? "Redo (âŒ˜Y)" : "Redo (Ctrl+Y)",
          type: "button",
          className: "toolbar-item",
          "aria-label": "Redo",
          children: /* @__PURE__ */ d("i", { className: "format redo" })
        }
      ),
      /* @__PURE__ */ d(rw, {}),
      i === o && /* @__PURE__ */ M(ft, { children: [
        /* @__PURE__ */ d(
          fD,
          {
            editorRef: t,
            blockMarker: a,
            disabled: e
          }
        ),
        /* @__PURE__ */ d(rw, {})
      ] }),
      /* @__PURE__ */ d("div", { ref: r, className: "end-container" })
    ] })
  ] });
}), ow = {
  namespace: "platformEditor",
  theme: n0,
  editable: !0,
  editorState: void 0,
  // Handling of errors during update
  onError(t) {
    throw t;
  },
  nodes: [Vt, ...RT]
}, bD = bp(), vD = {}, yD = {};
function xD() {
  return /* @__PURE__ */ d("div", { className: "editor-placeholder", children: "Enter some Scripture..." });
}
const o0 = an(function({
  defaultUsj: t,
  scrRef: e,
  onScrRefChange: n,
  onSelectionChange: r,
  onUsjChange: o,
  onStateChange: i,
  options: s,
  logger: a,
  children: l
}, c) {
  const u = he(null), p = he(null), f = he(null), h = he(t), g = he(), [b, _] = oe(t), [x, y] = oe(0), {
    isReadonly: A = !1,
    hasExternalUI: P = !1,
    hasSpellCheck: V = !1,
    textDirection: O = "ltr",
    markerMenuTrigger: U = "\\",
    view: B = bD,
    nodes: F = vD,
    debug: K = !1
  } = s ?? yD;
  ow.editable = !A, Hc.initialize(a), Qu(c, () => ({
    focus() {
      var S;
      (S = u.current) == null || S.focus();
    },
    undo() {
      var S;
      (S = u.current) == null || S.dispatchCommand(sd, void 0);
    },
    redo() {
      var S;
      (S = u.current) == null || S.dispatchCommand(id, void 0);
    },
    cut() {
      var S;
      (S = u.current) == null || S.dispatchCommand(xl, null);
    },
    copy() {
      var S;
      (S = u.current) == null || S.dispatchCommand(_l, null);
    },
    paste() {
      u.current && wp(u.current);
    },
    pastePlainText() {
      u.current && gp(u.current);
    },
    getUsj() {
      return h.current;
    },
    setUsj(S) {
      if (!kr(h.current, S)) {
        h.current = S;
        const k = kr(b, S);
        _(S), k && y((I) => I + 1);
      }
    },
    applyUpdate(S, k = "remote") {
      var I, N;
      (I = u.current) == null || I.update(
        () => {
          k === "remote" && vy(Pu), nA(S, B, F, a);
        },
        { discrete: !0 }
      );
      const T = (N = u.current) == null ? void 0 : N.getEditorState();
      if (!T) return;
      const $ = Hc.deserializeEditorState(T);
      if ($) {
        const L = !kr(h.current, $);
        if (L && (h.current = $), L || !kr(b, $)) {
          const J = Rh(S, T);
          o == null || o($, S, k, J);
        }
      }
    },
    replaceEmbedUpdate(S, k) {
      var I;
      const N = (I = u.current) == null ? void 0 : I.read(() => dT(S, k));
      N && this.applyUpdate(N);
    },
    getSelection() {
      var S;
      return (S = u.current) == null ? void 0 : S.read(Pb);
    },
    setSelection(S) {
      var k;
      (k = u.current) == null || k.update(
        () => {
          const I = ap(S);
          I !== void 0 && ml(I);
        },
        { tag: db }
      );
    },
    addAnnotation(S, k, I) {
      var N;
      (N = p.current) == null || N.addAnnotation(S, kh(k), I);
    },
    removeAnnotation(S, k) {
      var I;
      (I = p.current) == null || I.removeAnnotation(kh(S), k);
    },
    formatPara(S) {
      var k;
      (k = u.current) == null || k.update(() => {
        const I = ve();
        me(I) && d1(I, () => Ps(S));
      });
    },
    getElementByKey(S) {
      var k;
      return (k = u.current) == null ? void 0 : k.read(
        () => {
          var I;
          return ((I = u.current) == null ? void 0 : I.getElementByKey(S)) ?? void 0;
        }
      );
    },
    insertNote(S, k, I) {
      var N;
      (N = u.current) == null || N.update(() => {
        const T = XN(
          S,
          k,
          I,
          e,
          B,
          F,
          a
        );
        T && !T.getIsCollapsed() && (g.current = T.getKey());
      });
    },
    selectNote(S) {
      var k;
      (k = u.current) == null || k.update(() => {
        const I = Mh(S);
        I && (QN(I, B), I.getIsCollapsed() || (g.current = I.getKey()));
      });
    },
    getNoteOps(S) {
      var k;
      return (k = u.current) == null ? void 0 : k.read(() => {
        const I = Mh(S);
        if (I)
          return dp(I);
      });
    },
    get toolbarEndRef() {
      return f;
    }
  }));
  const E = ce(
    (S, k, I, N) => {
      if (Zk.some(($) => I.has($))) return;
      const T = Hc.deserializeEditorState(S);
      if (T) {
        const $ = !kr(h.current, T);
        if ($ && (h.current = T), $ || !kr(b, T)) {
          const L = I.has(Pu) ? "remote" : "local", J = Rh(N, S);
          o == null || o(T, N, L, J);
        }
      }
    },
    [b, o]
  );
  return /* @__PURE__ */ M(Yg, { initialConfig: ow, children: [
    /* @__PURE__ */ d(RA, { isEditable: !A }),
    /* @__PURE__ */ M("div", { className: "editor-container", children: [
      P ? /* @__PURE__ */ d(Qb, { onStateChange: i }) : /* @__PURE__ */ d("div", { className: "editor-toolbar-container" + (A ? "-readonly" : "-editable"), children: /* @__PURE__ */ d(
        mD,
        {
          ref: f,
          editorRef: c,
          isReadonly: A,
          onStateChange: i
        }
      ) }),
      /* @__PURE__ */ M("div", { className: "editor-inner", children: [
        /* @__PURE__ */ d(nm, { editorRef: u }),
        /* @__PURE__ */ d(
          V_,
          {
            contentEditable: /* @__PURE__ */ d(
              tm,
              {
                className: `editor-input usfm ${wS(B).join(" ")}`,
                spellCheck: V
              }
            ),
            placeholder: /* @__PURE__ */ d(xD, {}),
            ErrorBoundary: rm
          }
        ),
        /* @__PURE__ */ d(om, {}),
        e && n && /* @__PURE__ */ d(sD, { scrRef: e, onScrRefChange: n }),
        e && /* @__PURE__ */ d(
          iS,
          {
            trigger: U,
            scrRef: e,
            getMarkerAction: (S, k) => YS(S, g, k, B)
          }
        ),
        /* @__PURE__ */ d(
          iD,
          {
            options: { view: B, nodes: F },
            editedUsjRef: h,
            usj: b,
            setUsj: _
          }
        ),
        /* @__PURE__ */ d(
          IA,
          {
            scripture: b,
            nodeOptions: F,
            editorAdaptor: Hu,
            viewOptions: B,
            logger: a
          },
          x
        ),
        /* @__PURE__ */ d(KA, { onChange: r }),
        /* @__PURE__ */ d(
          eA,
          {
            onChange: E,
            ignoreSelectionChange: !0,
            ignoreHistoryMergeTagChange: !0
          }
        ),
        /* @__PURE__ */ d(ZT, { ref: p, logger: a }),
        /* @__PURE__ */ d(bA, { viewOptions: B }),
        /* @__PURE__ */ d(EA, {}),
        /* @__PURE__ */ d(TA, {}),
        /* @__PURE__ */ d(AA, { logger: a }),
        /* @__PURE__ */ d(OA, {}),
        /* @__PURE__ */ d(
          LA,
          {
            expandedNoteKeyRef: g,
            nodeOptions: F,
            viewOptions: B,
            logger: a
          }
        ),
        /* @__PURE__ */ d(WA, {}),
        /* @__PURE__ */ d(YA, { textDirection: O }),
        /* @__PURE__ */ d(eS, {}),
        l
      ] }),
      K && /* @__PURE__ */ d(cD, {})
    ] })
  ] });
}), _D = an(function(t, e) {
  const { children: n, ...r } = t;
  return /* @__PURE__ */ d(o0, { ref: e, ...r });
});
function i0() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function fl(t, e, n, r, o) {
  return {
    author: e,
    content: t,
    deleted: o === void 0 ? !1 : o,
    id: n === void 0 ? i0() : n,
    timeStamp: r === void 0 ? performance.timeOrigin + performance.now() : r,
    type: "comment"
  };
}
function s0(t, e, n) {
  return {
    comments: e,
    id: n === void 0 ? i0() : n,
    quote: t,
    type: "thread"
  };
}
function iw(t) {
  return {
    comments: Array.from(t.comments),
    id: t.id,
    quote: t.quote,
    type: "thread"
  };
}
function CD(t) {
  return {
    author: t.author,
    content: "[Deleted Comment]",
    deleted: !0,
    id: t.id,
    timeStamp: t.timeStamp,
    type: "comment"
  };
}
function zc(t) {
  const e = t._changeListeners;
  for (const n of e)
    n();
}
class ED {
  /**
   * Creates a new CommentStore instance.
   *
   * @param editor - The LexicalEditor instance.
   * @param logger - Optional logger instance.
   */
  constructor(e, n) {
    fe(this, "_editor"), fe(this, "_comments"), fe(this, "_changeListeners"), fe(this, "_collabProvider"), fe(this, "logger"), this._comments = [], this._editor = e, this.logger = n, this._collabProvider = null, this._changeListeners = /* @__PURE__ */ new Set();
  }
  /**
   * Checks if collaborative editing is enabled.
   *
   * @returns True if collaborative editing is enabled, false otherwise.
   */
  isCollaborative() {
    return this._collabProvider !== null;
  }
  /**
   * Gets the current list of comments and threads.
   *
   * @returns The Comments array.
   */
  getComments() {
    return this._comments;
  }
  /**
   * Sets the list of comments and threads.
   *
   * @param comments - The new Comments array.
   */
  setComments(e) {
    this._comments = e, zc(this);
  }
  /**
   * Adds a comment or thread to the store.
   *
   * @param commentOrThread - The comment or thread to add.
   * @param thread - Optional parent thread to add the comment to.
   * @param offset - Optional offset for insertion.
   */
  addComment(e, n, r) {
    const o = Array.from(this._comments), i = this._getCollabComments();
    if (n !== void 0 && e.type === "comment")
      for (let s = 0; s < o.length; s++) {
        const a = o[s];
        if (a.type === "thread" && a.id === n.id) {
          const l = iw(a);
          o.splice(s, 1, l);
          const c = r !== void 0 ? r : l.comments.length;
          if (this.isCollaborative() && i !== null) {
            const u = i.get(s).get("comments");
            this._withRemoteTransaction(() => {
              const p = this._createCollabSharedMap(e);
              u.insert(c, [p]);
            });
          }
          l.comments.splice(c, 0, e);
          break;
        }
      }
    else {
      const s = r !== void 0 ? r : o.length;
      this.isCollaborative() && i !== null && this._withRemoteTransaction(() => {
        const a = this._createCollabSharedMap(e);
        i.insert(s, [a]);
      }), o.splice(s, 0, e);
    }
    this._comments = o, zc(this);
  }
  /**
   * Deletes a comment or thread from the store.
   *
   * @param commentOrThread - The comment or thread to delete.
   * @param thread - Optional parent thread if deleting a comment within a thread.
   * @returns An object containing the marked comment and its index, or null.
   */
  deleteCommentOrThread(e, n) {
    const r = Array.from(this._comments), o = this._getCollabComments();
    let i = null;
    if (n !== void 0)
      for (let s = 0; s < r.length; s++) {
        const a = r[s];
        if (a.type === "thread" && a.id === n.id) {
          const l = iw(a);
          r.splice(s, 1, l);
          const c = l.comments;
          if (i = c.indexOf(e), this.isCollaborative() && o !== null) {
            const u = o.get(s).get("comments"), p = i;
            this._withRemoteTransaction(() => {
              u.delete(p);
            });
          }
          c.splice(i, 1);
          break;
        }
      }
    else
      i = r.indexOf(e), this.isCollaborative() && o !== null && this._withRemoteTransaction(() => {
        o.delete(i);
      }), r.splice(i, 1);
    return this._comments = r, zc(this), e.type === "comment" ? {
      index: i,
      markedComment: CD(e)
    } : null;
  }
  /**
   * Registers a callback to be called when the comments change.
   *
   * @param onChange - The callback function.
   * @returns A function to unregister the callback.
   */
  registerOnChange(e) {
    const n = this._changeListeners;
    return n.add(e), () => {
      n.delete(e);
    };
  }
  _withRemoteTransaction(e) {
    const n = this._collabProvider;
    n !== null && n.doc.transact(e, this);
  }
  _withLocalTransaction(e) {
    const n = this._collabProvider;
    try {
      this._collabProvider = null, e();
    } finally {
      this._collabProvider = n;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _getCollabComments() {
    const e = this._collabProvider;
    return e !== null ? e.doc.get("comments", ko) : null;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _createCollabSharedMap(e) {
    const n = new _i(), r = e.type, o = e.id;
    if (n.set("type", r), n.set("id", o), r === "comment")
      n.set("author", e.author), n.set("content", e.content), n.set("deleted", e.deleted), n.set("timeStamp", e.timeStamp);
    else {
      n.set("quote", e.quote);
      const i = new ko();
      e.comments.forEach((s, a) => {
        const l = this._createCollabSharedMap(s);
        i.insert(a, [l]);
      }), n.set("comments", i);
    }
    return n;
  }
  /**
   * Registers collaborative editing support using a Yjs provider.
   *
   * @param provider - The Yjs Provider instance.
   * @returns A function to unregister collaboration and cleanup.
   */
  registerCollaboration(e) {
    this._collabProvider = e;
    const n = this._getCollabComments(), r = () => {
      e.connect();
    }, o = () => {
      try {
        e.disconnect();
      } catch {
      }
    }, i = this._editor.registerCommand(
      Hk,
      (a) => {
        var l, c;
        return r !== void 0 && o !== void 0 && (a ? ((l = this.logger) == null || l.info("Comments connected!"), r()) : ((c = this.logger) == null || c.info("Comments disconnected!"), o())), !1;
      },
      to
    ), s = (a, l) => {
      if (l.origin !== this) {
        for (const c of a)
          if (c instanceof Qm) {
            const u = c.target, p = c.delta;
            let f = 0;
            for (const h of p) {
              const g = h.insert, b = h.retain, _ = h.delete, x = u.parent, y = u === n ? void 0 : x instanceof _i && this._comments.find((A) => A.id === x.get("id"));
              if (Array.isArray(g)) {
                const A = f;
                g.slice().reverse().forEach((P) => {
                  const V = P.get("id"), O = P.get("type") === "thread" ? s0(
                    P.get("quote"),
                    P.get("comments").toArray().map(
                      (U) => fl(
                        U.get("content"),
                        U.get("author"),
                        U.get("id"),
                        U.get("timeStamp"),
                        U.get("deleted")
                      )
                    ),
                    V
                  ) : fl(
                    P.get("content"),
                    P.get("author"),
                    V,
                    P.get("timeStamp"),
                    P.get("deleted")
                  );
                  this._withLocalTransaction(() => {
                    this.addComment(O, y, A);
                  });
                });
              } else if (typeof b == "number")
                f += b;
              else if (typeof _ == "number")
                for (let A = 0; A < _; A++) {
                  const P = y === void 0 || y === !1 ? this._comments[f] : y.comments[f];
                  this._withLocalTransaction(() => {
                    this.deleteCommentOrThread(P, y);
                  }), f++;
                }
            }
          }
      }
    };
    return n === null ? () => null : (n.observeDeep(s), r(), () => {
      n.unobserveDeep(s), i(), this._collabProvider = null;
    });
  }
}
function kD(t) {
  const [e, n] = oe(t.getComments());
  return ie(() => t.registerOnChange(() => {
    n(t.getComments());
  }), [t]), e;
}
function ND({
  onClose: t,
  children: e,
  title: n,
  closeOnClickOutside: r
}) {
  const o = he(null);
  return ie(() => {
    o.current !== null && o.current.focus();
  }, []), ie(() => {
    let i = null;
    const s = (c) => {
      c.key === "Escape" && t();
    }, a = (c) => {
      const u = c.target;
      o.current !== null && !o.current.contains(u) && r && t();
    }, l = o.current;
    return l !== null && (i = l.parentElement, i !== null && i.addEventListener("click", a)), window.addEventListener("keydown", s), () => {
      window.removeEventListener("keydown", s), i !== null && (i == null || i.removeEventListener("click", a));
    };
  }, [r, t]), /* @__PURE__ */ d("div", { className: "Modal__overlay", role: "dialog", children: /* @__PURE__ */ M("div", { className: "Modal__modal", tabIndex: -1, ref: o, children: [
    /* @__PURE__ */ d("h2", { className: "Modal__title", children: n }),
    /* @__PURE__ */ d(
      "button",
      {
        className: "Modal__closeButton",
        "aria-label": "Close modal",
        type: "button",
        onClick: t,
        children: "X"
      }
    ),
    /* @__PURE__ */ d("div", { className: "Modal__content", children: e })
  ] }) });
}
function TD({
  onClose: t,
  children: e,
  title: n,
  closeOnClickOutside: r = !1
}) {
  return ur(
    /* @__PURE__ */ d(ND, { onClose: t, title: n, closeOnClickOutside: r, children: e }),
    document.body
  );
}
function a0() {
  const [t, e] = oe(null), n = ce(() => {
    e(null);
  }, []), r = ue(() => {
    if (t === null)
      return null;
    const { title: i, content: s, closeOnClickOutside: a } = t;
    return /* @__PURE__ */ d(TD, { onClose: n, title: i, closeOnClickOutside: a, children: s });
  }, [t, n]), o = ce(
    (i, s, a = !1) => {
      e({
        closeOnClickOutside: a,
        content: s(n),
        title: i
      });
    },
    [n]
  );
  return [r, o];
}
const AD = {
  ...n0,
  paragraph: "CommentEditorTheme__paragraph"
};
function SD(...t) {
  return t.filter(Boolean).join(" ");
}
function Qr({
  "data-test-id": t,
  children: e,
  className: n,
  onClick: r,
  disabled: o,
  small: i,
  title: s
}) {
  return /* @__PURE__ */ d(
    "button",
    {
      disabled: o,
      className: SD(
        "Button__root",
        o && "Button__disabled",
        i && "Button__small",
        n
      ),
      onClick: r,
      title: s,
      "aria-label": s,
      ...t && { "data-test-id": t },
      children: e
    }
  );
}
function DD({
  className: t
}) {
  return /* @__PURE__ */ d(tm, { className: t || "ContentEditable__root" });
}
function MD({
  children: t,
  className: e
}) {
  return /* @__PURE__ */ d("div", { className: e || "Placeholder__root", children: t });
}
const sw = Di("INSERT_INLINE_COMMAND");
function OD({
  anchorKey: t,
  editor: e,
  showComments: n,
  onAddComment: r
}) {
  const o = he(null), i = ce(() => {
    const s = o.current, a = e.getRootElement(), l = e.getElementByKey(t);
    if (s !== null && a !== null && l !== null) {
      const { right: c } = a.getBoundingClientRect(), { top: u } = l.getBoundingClientRect();
      s.style.left = `${c - 20}px`, s.style.top = `${u - 30}px`;
    }
  }, [t, e]);
  return ie(() => (window.addEventListener("resize", i), () => {
    window.removeEventListener("resize", i);
  }), [e, i]), xt(() => {
    i();
  }, [t, e, n, i]), /* @__PURE__ */ d("div", { className: "CommentPlugin_AddCommentBox", ref: o, children: /* @__PURE__ */ d("button", { className: "CommentPlugin_AddCommentBox_button", onClick: r, children: /* @__PURE__ */ d("i", { className: "icon add-comment" }) }) });
}
function RD({ onEscape: t }) {
  const [e] = De();
  return ie(() => e.registerCommand(
    Ew,
    (n) => t(n),
    Pa
  ), [e, t]), null;
}
function l0({
  className: t,
  autoFocus: e,
  onEscape: n,
  onChange: r,
  editorRef: o,
  placeholder: i = "Type a comment..."
}) {
  return /* @__PURE__ */ d(Yg, { initialConfig: {
    namespace: "Commenting",
    nodes: [],
    onError: (s) => {
      throw s;
    },
    theme: AD
  }, children: /* @__PURE__ */ M("div", { className: "CommentPlugin_CommentInputBox_EditorContainer", children: [
    /* @__PURE__ */ d(
      ZC,
      {
        contentEditable: /* @__PURE__ */ d(DD, { className: t }),
        placeholder: /* @__PURE__ */ d(MD, { children: i }),
        ErrorBoundary: rm
      }
    ),
    /* @__PURE__ */ d(HC, { onChange: r }),
    /* @__PURE__ */ d(om, {}),
    e !== !1 && /* @__PURE__ */ d(BC, {}),
    /* @__PURE__ */ d(RD, { onEscape: n }),
    /* @__PURE__ */ d(jC, {}),
    o !== void 0 && /* @__PURE__ */ d(nm, { editorRef: o })
  ] }) });
}
function c0(t, e) {
  return ce(
    (n, r) => {
      n.read(() => {
        t(Qg()), e(!Zg(r.isComposing(), !0));
      });
    },
    [e, t]
  );
}
function ID({
  editor: t,
  cancelAddComment: e,
  submitAddComment: n
}) {
  const [r, o] = oe(""), [i, s] = oe(!1), a = he(null), l = ue(
    () => ({
      container: document.createElement("div"),
      elements: []
    }),
    []
  ), c = he(null), u = d0(), p = ce(() => {
    t.getEditorState().read(() => {
      const b = ve();
      if (me(b)) {
        c.current = b.clone();
        const _ = b.anchor, x = b.focus, y = a1(
          t,
          _.getNode(),
          _.offset,
          x.getNode(),
          x.offset
        ), A = a.current;
        if (y !== null && A !== null) {
          const { left: P, bottom: V, width: O } = y.getBoundingClientRect(), U = l1(t, y);
          let B = U.length === 1 ? P + O / 2 - 125 : P - 125;
          B < 10 && (B = 10), A.style.left = `${B}px`, A.style.top = `${V + 20 + (window.pageYOffset || document.documentElement.scrollTop)}px`;
          const F = U.length, { container: K } = l, E = l.elements, S = E.length;
          for (let k = 0; k < F; k++) {
            const I = U[k];
            let N = E[k];
            N === void 0 && (N = document.createElement("span"), E[k] = N, K.appendChild(N));
            const T = `position:absolute;top:${I.top + (window.pageYOffset || document.documentElement.scrollTop)}px;left:${I.left}px;height:${I.height}px;width:${I.width}px;background-color:rgba(255, 212, 0, 0.3);pointer-events:none;z-index:5;`;
            N.style.cssText = T;
          }
          for (let k = S - 1; k >= F; k--) {
            const I = E[k];
            K.removeChild(I), E.pop();
          }
        }
      }
    });
  }, [t, l]);
  xt(() => {
    p();
    const b = l.container, _ = document.body;
    return _ !== null ? (_.appendChild(b), () => {
      _.removeChild(b);
    }) : () => {
    };
  }, [l.container, p]), ie(() => (window.addEventListener("resize", p), () => {
    window.removeEventListener("resize", p);
  }), [p]);
  const f = (b) => (b.preventDefault(), e(), !0), h = () => {
    if (i) {
      let b = t.getEditorState().read(() => {
        const _ = c.current;
        return _ ? _.getTextContent() : "";
      });
      b.length > 100 && (b = b.slice(0, 99) + "â€¦"), n(
        s0(b, [fl(r, u)]),
        !0,
        void 0,
        c.current
      ), c.current = null;
    }
  }, g = c0(o, s);
  return /* @__PURE__ */ M("div", { className: "CommentPlugin_CommentInputBox", ref: a, children: [
    /* @__PURE__ */ d(
      l0,
      {
        className: "CommentPlugin_CommentInputBox_Editor",
        onEscape: f,
        onChange: g
      }
    ),
    /* @__PURE__ */ M("div", { className: "CommentPlugin_CommentInputBox_Buttons", children: [
      /* @__PURE__ */ d(Qr, { onClick: e, className: "CommentPlugin_CommentInputBox_Button", children: "Cancel" }),
      /* @__PURE__ */ d(
        Qr,
        {
          onClick: h,
          disabled: !i,
          className: "CommentPlugin_CommentInputBox_Button primary",
          children: "Comment"
        }
      )
    ] })
  ] });
}
function LD({
  submitAddComment: t,
  thread: e,
  placeholder: n
}) {
  const [r, o] = oe(""), [i, s] = oe(!1), a = he(null), l = d0(), c = c0(o, s);
  return /* @__PURE__ */ M(ft, { children: [
    /* @__PURE__ */ d(
      l0,
      {
        className: "CommentPlugin_CommentsPanel_Editor",
        autoFocus: !1,
        onEscape: () => !0,
        onChange: c,
        editorRef: a,
        placeholder: n
      }
    ),
    /* @__PURE__ */ d(
      Qr,
      {
        className: "CommentPlugin_CommentsPanel_SendButton",
        onClick: () => {
          if (i) {
            t(fl(r, l), !1, e);
            const u = a.current;
            u !== null && u.dispatchCommand(bl, void 0);
          }
        },
        disabled: !i,
        children: /* @__PURE__ */ d("i", { className: "send" })
      }
    )
  ] });
}
function u0({
  commentOrThread: t,
  deleteCommentOrThread: e,
  onClose: n,
  thread: r = void 0
}) {
  return /* @__PURE__ */ M(ft, { children: [
    "Are you sure you want to delete this ",
    t.type,
    "?",
    /* @__PURE__ */ M("div", { className: "Modal__content", children: [
      /* @__PURE__ */ d(
        Qr,
        {
          onClick: () => {
            e(t, r), n();
          },
          children: "Delete"
        }
      ),
      " ",
      /* @__PURE__ */ d(
        Qr,
        {
          onClick: () => {
            n();
          },
          children: "Cancel"
        }
      )
    ] })
  ] });
}
function aw({
  comment: t,
  deleteComment: e,
  thread: n,
  rtf: r
}) {
  const o = Math.round(
    (t.timeStamp - (performance.timeOrigin + performance.now())) / 1e3
  ), i = Math.round(o / 60), [s, a] = a0();
  return /* @__PURE__ */ M("li", { className: "CommentPlugin_CommentsPanel_List_Comment", children: [
    /* @__PURE__ */ M("div", { className: "CommentPlugin_CommentsPanel_List_Details", children: [
      /* @__PURE__ */ d("span", { className: "CommentPlugin_CommentsPanel_List_Comment_Author", children: t.author }),
      /* @__PURE__ */ M("span", { className: "CommentPlugin_CommentsPanel_List_Comment_Time", children: [
        "Â· ",
        o > -10 ? "Just now" : r.format(i, "minute")
      ] })
    ] }),
    /* @__PURE__ */ d("p", { className: t.deleted ? "CommentPlugin_CommentsPanel_DeletedComment" : "", children: t.content }),
    !t.deleted && /* @__PURE__ */ M(ft, { children: [
      /* @__PURE__ */ d(
        Qr,
        {
          onClick: () => {
            a("Delete Comment", (l) => /* @__PURE__ */ d(
              u0,
              {
                commentOrThread: t,
                deleteCommentOrThread: e,
                thread: n,
                onClose: l
              }
            ));
          },
          className: "CommentPlugin_CommentsPanel_List_DeleteButton",
          children: /* @__PURE__ */ d("i", { className: "delete" })
        }
      ),
      s
    ] })
  ] });
}
function PD({
  activeIDs: t,
  comments: e,
  deleteCommentOrThread: n,
  listRef: r,
  submitAddComment: o,
  markNodeMap: i
}) {
  const [s] = De(), [a, l] = oe(0), [c, u] = a0(), p = ue(
    () => new Intl.RelativeTimeFormat("en", {
      localeMatcher: "best fit",
      numeric: "auto",
      style: "short"
    }),
    []
  );
  return ie(() => {
    const f = setTimeout(() => {
      l(a + 1);
    }, 1e4);
    return () => {
      clearTimeout(f);
    };
  }, [a]), /* @__PURE__ */ d("ul", { className: "CommentPlugin_CommentsPanel_List", ref: r, children: e.map((f) => {
    const h = f.id;
    return f.type === "thread" ? /* @__PURE__ */ M(
      "li",
      {
        onClick: () => {
          const g = i.get(h);
          if (g !== void 0 && (t === null || t.indexOf(h) === -1)) {
            const b = document.activeElement;
            s.update(
              () => {
                const _ = Array.from(g)[0], x = it(_);
                zt(x) && x.selectStart();
              },
              {
                onUpdate() {
                  b !== null && b.focus();
                }
              }
            );
          }
        },
        className: `CommentPlugin_CommentsPanel_List_Thread ${i.has(h) ? "interactive" : ""} ${t.indexOf(h) === -1 ? "" : "active"}`,
        children: [
          /* @__PURE__ */ M("div", { className: "CommentPlugin_CommentsPanel_List_Thread_QuoteBox", children: [
            /* @__PURE__ */ M("blockquote", { className: "CommentPlugin_CommentsPanel_List_Thread_Quote", children: [
              "> ",
              /* @__PURE__ */ d("span", { children: f.quote })
            ] }),
            /* @__PURE__ */ d(
              Qr,
              {
                onClick: () => {
                  u("Delete Thread", (g) => /* @__PURE__ */ d(
                    u0,
                    {
                      commentOrThread: f,
                      deleteCommentOrThread: n,
                      onClose: g
                    }
                  ));
                },
                className: "CommentPlugin_CommentsPanel_List_DeleteButton",
                children: /* @__PURE__ */ d("i", { className: "delete" })
              }
            ),
            c
          ] }),
          /* @__PURE__ */ d("ul", { className: "CommentPlugin_CommentsPanel_List_Thread_Comments", children: f.comments.map((g) => /* @__PURE__ */ d(
            aw,
            {
              comment: g,
              deleteComment: n,
              thread: f,
              rtf: p
            },
            g.id
          )) }),
          /* @__PURE__ */ d("div", { className: "CommentPlugin_CommentsPanel_List_Thread_Editor", children: /* @__PURE__ */ d(
            LD,
            {
              submitAddComment: o,
              thread: f,
              placeholder: "Reply to comment..."
            }
          ) })
        ]
      },
      h
    ) : /* @__PURE__ */ d(
      aw,
      {
        comment: f,
        deleteComment: n,
        rtf: p
      },
      h
    );
  }) });
}
function $D({
  activeIDs: t,
  deleteCommentOrThread: e,
  comments: n,
  submitAddComment: r,
  markNodeMap: o
}) {
  const i = he(null), s = n.length === 0;
  return /* @__PURE__ */ M("div", { className: "CommentPlugin_CommentsPanel", children: [
    /* @__PURE__ */ d("h2", { className: "CommentPlugin_CommentsPanel_Heading", children: "Comments" }),
    s ? /* @__PURE__ */ d("div", { className: "CommentPlugin_CommentsPanel_Empty", children: "No Comments" }) : /* @__PURE__ */ d(
      PD,
      {
        activeIDs: t,
        comments: n,
        deleteCommentOrThread: e,
        listRef: i,
        submitAddComment: r,
        markNodeMap: o
      }
    )
  ] });
}
function d0() {
  const t = vm(), { yjsDocMap: e, name: n } = t;
  return e.has("comments") ? n : "Scripture User";
}
function FD({
  providerFactory: t,
  setCommentStore: e,
  onChange: n,
  showCommentsContainerRef: r,
  commentContainerRef: o,
  logger: i
}) {
  const s = vm(), [a] = De(), l = ue(() => {
    const B = new ED(a, i);
    return n && B.registerOnChange(n), e == null || e(B), B;
  }, [a, i, n, e]), c = kD(l), u = ue(() => /* @__PURE__ */ new Map(), []), [p, f] = oe(), [h, g] = oe([]), [b, _] = oe(!1), [x, y] = oe(!1), { yjsDocMap: A } = s;
  ie(() => {
    if (t) {
      const B = t("comments", A);
      return l.registerCollaboration(B);
    }
    return () => {
    };
  }, [l, t, A]);
  const P = ce(() => {
    a.update(() => {
      const B = ve();
      B !== null && (B.dirty = !0);
    }), _(!1);
  }, [a]), V = ce(
    (B, F) => {
      if (B.type === "comment") {
        const K = l.deleteCommentOrThread(B, F);
        if (!K)
          return;
        const { markedComment: E, index: S } = K;
        l.addComment(E, F, S);
      } else {
        l.deleteCommentOrThread(B);
        const K = F !== void 0 ? F.id : B.id, E = u.get(K);
        E !== void 0 && setTimeout(() => {
          a.update(() => {
            for (const S of E) {
              const k = it(S);
              zt(k) && (k.deleteID(zr, K), k.hasNoIDsForEveryType() && Mb(k));
            }
          });
        });
      }
    },
    [l, a, u]
  ), O = ce(
    (B, F, K, E) => {
      l.addComment(B, K), F && (a.update(() => {
        me(E) && Ob(E, zr, B.id);
      }), _(!1));
    },
    [l, a]
  );
  ie(() => {
    const B = [];
    for (const F of h) {
      const K = u.get(F);
      if (K !== void 0)
        for (const E of K) {
          const S = a.getElementByKey(E);
          S !== null && (S.classList.add("selected"), B.push(S), y(!0));
        }
    }
    return () => {
      for (const F of B)
        F.classList.remove("selected");
    };
  }, [h, a, u]), ie(() => {
    if (!a.hasNodes([Vt]))
      throw new Error("CommentPlugin: TypedMarkNode not registered on editor!");
    const B = /* @__PURE__ */ new Map();
    return Gt(
      Rg(
        a,
        Vt,
        (F) => $s(F.getTypedIDs()),
        (F, K) => {
          for (const [E, S] of Object.entries(F.getTypedIDs()))
            S.forEach((k) => {
              K.addID(E, k);
            });
        }
      ),
      a.registerMutationListener(
        Vt,
        (F) => {
          a.getEditorState().read(() => {
            for (const [K, E] of F) {
              const S = it(K);
              let k = [];
              E === "destroyed" ? k = B.get(K) ?? [] : zt(S) && (k = S.getTypedIDs()[zr] ?? []);
              for (const I of k) {
                let N = u.get(I);
                B.set(K, k), E === "destroyed" ? N !== void 0 && (N.delete(K), N.size === 0 && u.delete(I)) : (N === void 0 && (N = /* @__PURE__ */ new Set(), u.set(I, N)), N.has(K) || N.add(K));
              }
            }
          });
        },
        { skipInitialization: !1 }
      ),
      a.registerUpdateListener(({ editorState: F, tags: K }) => {
        F.read(() => {
          const E = ve();
          let S = !1, k = !1;
          if (me(E)) {
            const I = E.anchor.getNode();
            if (xe(I)) {
              const N = $N(I, zr, E.anchor.offset) ?? [];
              N !== null && (g(N), S = !0), E.isCollapsed() || (f(I.getKey()), k = !0);
            }
          }
          S || g((I) => I.length === 0 ? I : []), k || f(null), !K.has("collaboration") && me(E) && _(!1);
        });
      }),
      a.registerCommand(
        sw,
        () => {
          const F = window.getSelection();
          return F !== null && F.removeAllRanges(), _(!0), !0;
        },
        Qe
      )
    );
  }, [a, u]);
  const U = () => {
    a.dispatchCommand(sw, void 0);
  };
  return /* @__PURE__ */ M(ft, { children: [
    b && ur(
      /* @__PURE__ */ d(
        ID,
        {
          editor: a,
          cancelAddComment: P,
          submitAddComment: O
        }
      ),
      document.body
    ),
    p != null && !b && ur(
      /* @__PURE__ */ d(
        OD,
        {
          anchorKey: p,
          editor: a,
          showComments: x,
          onAddComment: U
        }
      ),
      document.body
    ),
    r !== null && ur(
      /* @__PURE__ */ d(
        Qr,
        {
          className: `CommentPlugin_ShowCommentsButton ${x ? "active" : ""}`,
          onClick: () => y(!x),
          title: x ? "Hide Comments" : "Show Comments",
          children: /* @__PURE__ */ d("i", { className: "comments" })
        }
      ),
      (r == null ? void 0 : r.current) ?? document.body
    ),
    x && ur(
      /* @__PURE__ */ d(
        $D,
        {
          comments: c,
          submitAddComment: O,
          deleteCommentOrThread: V,
          activeIDs: h,
          markNodeMap: u
        }
      ),
      (o == null ? void 0 : o.current) ?? document.body
    )
  ] });
}
function BD() {
  const t = he(void 0), e = ce((n) => {
    t.current = n;
  }, []);
  return [t, e];
}
function qD(t, e) {
  var n, r;
  const o = ((n = e.current) == null ? void 0 : n.getComments()) ?? [], i = o == null ? void 0 : o.map((a) => a.id), s = t.map((a) => {
    const l = i.findIndex((c) => c === a);
    return l !== void 0 && l >= 0 ? o[l] : {
      comments: [
        {
          author: "unknown",
          content: "Comment not found",
          deleted: !1,
          id: "",
          timeStamp: 0,
          type: "comment"
        }
      ],
      id: a,
      quote: "",
      type: "thread"
    };
  });
  o.forEach((a) => {
    t.includes(a.id) || s.push(a);
  }), s && ((r = e.current) == null || r.setComments(s));
}
function jD(t, e) {
  ie(() => {
    var n;
    t.options ?? (t.options = {}), (n = t.options).nodes ?? (n.nodes = {}), t.options.nodes.addMissingComments = (r) => {
      qD(r, e);
    };
  }, [e, t]);
}
an(function(t, e) {
  const n = he(null), r = he(!0), o = he(null), [i, s] = oe(null), { children: a, onCommentChange: l, onUsjChange: c, showCommentsContainerRef: u, ...p } = t, { options: { isReadonly: f } = {} } = t, [h, g] = BD();
  jD(p, h), Qu(e, () => ({
    focus() {
      var x;
      (x = n.current) == null || x.focus();
    },
    undo() {
      var x;
      (x = n.current) == null || x.undo();
    },
    redo() {
      var x;
      (x = n.current) == null || x.redo();
    },
    cut() {
      var x;
      (x = n.current) == null || x.cut();
    },
    copy() {
      var x;
      (x = n.current) == null || x.copy();
    },
    paste() {
      var x;
      (x = n.current) == null || x.paste();
    },
    pastePlainText() {
      var x;
      (x = n.current) == null || x.pastePlainText();
    },
    getUsj() {
      var x;
      return (x = n.current) == null ? void 0 : x.getUsj();
    },
    setUsj(x) {
      var y;
      (y = n.current) == null || y.setUsj(x);
    },
    applyUpdate(x, y) {
      var A;
      (A = n.current) == null || A.applyUpdate(x, y);
    },
    replaceEmbedUpdate(x, y) {
      var A;
      return (A = n.current) == null ? void 0 : A.replaceEmbedUpdate(x, y);
    },
    getSelection() {
      var x;
      return (x = n.current) == null ? void 0 : x.getSelection();
    },
    setSelection(x) {
      var y;
      (y = n.current) == null || y.setSelection(x);
    },
    addAnnotation(x, y, A) {
      var P;
      (P = n.current) == null || P.addAnnotation(x, y, A);
    },
    removeAnnotation(x, y) {
      var A;
      (A = n.current) == null || A.removeAnnotation(x, y);
    },
    formatPara(x) {
      var y;
      (y = n.current) == null || y.formatPara(x);
    },
    getElementByKey(x) {
      var y;
      return (y = n.current) == null ? void 0 : y.getElementByKey(x);
    },
    insertNote(x, y, A) {
      var P;
      (P = n.current) == null || P.insertNote(x, y, A);
    },
    selectNote(x) {
      var y;
      (y = n.current) == null || y.selectNote(x);
    },
    getNoteOps(x) {
      var y;
      return (y = n.current) == null ? void 0 : y.getNoteOps(x);
    },
    setComments(x) {
      var y;
      (y = h.current) == null || y.setComments(x), r.current = !0;
    },
    get toolbarEndRef() {
      return i;
    }
  }));
  const b = ce(
    (x, y, A, P) => {
      var V;
      if (!c) return;
      const O = (V = h.current) == null ? void 0 : V.getComments();
      c(x, O, y, A, P);
    },
    [h, c]
  ), _ = ce(() => {
    var x;
    if (!l || r.current) {
      r.current = !1;
      return;
    }
    const y = (x = h.current) == null ? void 0 : x.getComments();
    l(y);
  }, [h, r, l]);
  return ie(() => {
    var x;
    return s(((x = n.current) == null ? void 0 : x.toolbarEndRef) ?? null), () => s(null);
  }, []), /* @__PURE__ */ M(o0, { ref: n, onUsjChange: b, ...p, children: [
    /* @__PURE__ */ d(
      FD,
      {
        setCommentStore: g,
        onChange: _,
        showCommentsContainerRef: f ? null : u ?? i,
        commentContainerRef: o,
        logger: p.logger
      }
    ),
    /* @__PURE__ */ d("div", { ref: o, className: "comment-container" })
  ] });
});
function G5({
  noteOps: t,
  onSave: e,
  onClose: n,
  scrRef: r,
  noteKey: o,
  viewOptions: i
}) {
  const s = he(null), a = G0(), l = ue(
    () => ({
      isReadonly: !1,
      hasSpellCheck: !1,
      hasExternalUI: !0,
      // Might need to change this later
      textDirection: "auto",
      nodes: {
        noteCallerOnClick: (p, f, h, g, b) => {
          h || (g() === Lo ? b(Kd) : b(Lo));
        }
      },
      view: { ...i, noteMode: "expanded" }
    }),
    [i]
  );
  return ie(() => {
    var f, h;
    let p;
    return t && !((h = (f = s.current) == null ? void 0 : f.getUsj()) != null && h.content) && (p = setTimeout(() => {
      var g, b;
      (g = s.current) == null || g.setUsj(Sd), (b = s.current) == null || b.applyUpdate(t);
    }, 0)), () => {
      p && clearTimeout(p);
    };
  }, [t, o]), /* @__PURE__ */ M("div", { className: "footnote-editor tw-grid tw-gap-[12px]", children: [
    /* @__PURE__ */ M("div", { className: "tw-flex tw-w-full tw-justify-end tw-gap-4", children: [
      /* @__PURE__ */ d(Ne, { onClick: n, className: "tw-h-6 tw-w-6", size: "icon", variant: "secondary", children: /* @__PURE__ */ d(wl, {}) }),
      /* @__PURE__ */ d(Ne, { onClick: () => {
        var f;
        const p = (f = s.current) == null ? void 0 : f.getNoteOps(0);
        p && e(p);
      }, className: "tw-h-6 tw-w-6", size: "icon", variant: "default", children: /* @__PURE__ */ d(br, {}) })
    ] }),
    /* @__PURE__ */ M(
      "div",
      {
        ref: a,
        className: "tw-relative tw-rounded-[6px] tw-border-2 tw-border-ring",
        children: [
          /* @__PURE__ */ d(_D, { options: l, onScrRefChange: () => {
          }, scrRef: r, ref: s }),
          /* @__PURE__ */ d("div", { className: "tw-absolute tw-bottom-0 tw-right-0", children: /* @__PURE__ */ d(Ne, { onClick: () => {
            var f;
            const p = (f = a.current) == null ? void 0 : f.getElementsByClassName("editor-input")[0];
            p != null && p.textContent && navigator.clipboard.writeText(p.textContent);
          }, className: "tw-h-6 tw-w-6", variant: "ghost", size: "icon", children: /* @__PURE__ */ d(pw, {}) }) })
        ]
      }
    )
  ] });
}
function p0(t, e) {
  if (!e || e.length === 0) return t ?? "empty";
  const n = e.find((o) => typeof o == "string");
  if (n)
    return `key-${t ?? "unknown"}-${n.slice(0, 10)}`;
  const r = typeof e[0] == "string" ? "impossible" : e[0].marker ?? "unknown";
  return `key-${t ?? "unknown"}-${r}`;
}
function UD(t, e, n = !0, r = void 0) {
  if (!e || e.length === 0) return;
  const o = [], i = [];
  let s = [];
  return e.forEach((a) => {
    typeof a != "string" && a.marker === "fp" ? (s.length > 0 && i.push(s), s = [a]) : s.push(a);
  }), s.length > 0 && i.push(s), i.map((a, l) => {
    const c = l === i.length - 1;
    return /* @__PURE__ */ M("p", { className: "tw-mb-2", children: [
      vp(t, a, n, !0, o),
      c && r
    ] }, p0(t, a));
  });
}
function vp(t, e, n = !0, r = !0, o = []) {
  if (!(!e || e.length === 0))
    return e.map((i) => {
      if (typeof i == "string") {
        const s = `${t}-text-${i.slice(0, 10)}`;
        if (r) {
          const a = z(`usfm_${t}`);
          return /* @__PURE__ */ d("span", { className: a, children: i }, s);
        }
        return /* @__PURE__ */ M(
          "span",
          {
            className: "tw-inline-flex tw-items-center tw-gap-1 tw-underline tw-decoration-destructive",
            children: [
              /* @__PURE__ */ d(Qc, { className: "tw-h-4 tw-w-4 tw-fill-destructive" }),
              /* @__PURE__ */ d("span", { children: i }),
              /* @__PURE__ */ d(Qc, { className: "tw-h-4 tw-w-4 tw-fill-destructive" })
            ]
          },
          s
        );
      }
      return VD(
        i,
        p0(`${t}\\${i.marker}`, [i]),
        n,
        [...o, t ?? "unknown"]
      );
    });
}
function VD(t, e, n, r = []) {
  const { marker: o } = t;
  return /* @__PURE__ */ M("span", { children: [
    o ? n && /* @__PURE__ */ d("span", { className: "marker", children: `\\${o} ` }) : /* @__PURE__ */ d(
      Qc,
      {
        className: "tw-text-error tw-mr-1 tw-inline-block tw-h-4 tw-w-4",
        "aria-label": "Missing marker"
      }
    ),
    vp(o, t.content, n, !0, [
      ...r,
      o ?? "unknown"
    ])
  ] }, e);
}
function HD({
  footnote: t,
  layout: e = "horizontal",
  formatCaller: n,
  showMarkers: r = !0
}) {
  const o = n ? n(t.caller) : t.caller, i = o !== t.caller;
  let s, a = t.content;
  Array.isArray(t.content) && t.content.length > 0 && typeof t.content[0] != "string" && (t.content[0].marker === "fr" || t.content[0].marker === "xo") && ([s, ...a] = t.content);
  const l = r ? /* @__PURE__ */ d("span", { className: "marker", children: `\\${t.marker} ` }) : void 0, c = r ? /* @__PURE__ */ d("span", { className: "marker", children: ` \\${t.marker}*` }) : void 0, u = /* @__PURE__ */ M(ft, { children: [
    o && // USFM does not specify a marker for caller, so instead of a usfm_* class, we use a
    // specific class name in case styling is needed.
    /* @__PURE__ */ M("span", { className: z("note-caller", { formatted: i }), children: [
      o,
      " "
    ] }),
    s && /* @__PURE__ */ M(ft, { children: [
      vp(t.marker, [s], r, !1),
      " "
    ] })
  ] }), h = z(e === "horizontal" ? "horizontal tw-table-cell" : "vertical", r ? "marker-visible" : "");
  return /* @__PURE__ */ M(ft, { children: [
    /* @__PURE__ */ M("div", { className: z("textual-note-header tw-text-nowrap tw-pr-2", h), children: [
      l,
      u
    ] }),
    /* @__PURE__ */ d("div", { className: z("textual-note-body tw-pr-0.5", h), children: a && a.length > 0 && /* @__PURE__ */ d(ft, { children: UD(t.marker, a, r, c) }) })
  ] });
}
const K5 = ["%webView_footnoteList_header%"], zD = (t, e) => t[e] ?? e;
function W5({
  className: t,
  classNameForItems: e,
  footnotes: n,
  layout: r = "horizontal",
  listId: o,
  selectedFootnote: i,
  showMarkers: s = !0,
  suppressFormatting: a = !1,
  formatCaller: l,
  onFootnoteSelected: c,
  localizedStrings: u
}) {
  const p = u ? zD(u, "%webView_footnoteList_header%") : "Footnotes", f = l ?? Rv(n, void 0), h = (A, P) => {
    c == null || c(A, P, o);
  }, g = i ? n.findIndex((A) => A === i) : 0, [b, _] = oe(g), x = (A) => {
    if (n.length)
      switch (A.key) {
        case "ArrowDown":
          A.preventDefault(), _((P) => Math.min(P + 1, n.length - 1));
          break;
        case "ArrowUp":
          A.preventDefault(), _((P) => Math.max(P - 1, 0));
          break;
        case "Enter":
        case " ":
          A.preventDefault(), c == null || c(n[b], b, o);
          break;
      }
  }, y = he([]);
  return ie(() => {
    var A;
    b >= 0 && b < y.current.length && ((A = y.current[b]) == null || A.focus());
  }, [b]), /* @__PURE__ */ M(ft, { children: [
    r === "vertical" && /* @__PURE__ */ d("h2", { className: "tw-mb-1 tw-font-semibold", children: p }),
    /* @__PURE__ */ d(
      "div",
      {
        role: "listbox",
        "aria-label": "Footnotes",
        tabIndex: 0,
        className: z("tw-h-full tw-overflow-y-auto", t),
        onKeyDown: x,
        children: /* @__PURE__ */ d(
          "div",
          {
            className: z(
              "tw-p-0.5 tw-pt-1",
              r === "horizontal" ? "tw-table" : "tw-flex tw-flex-col tw-gap-1",
              !a && "formatted-font"
            ),
            children: n.map((A, P) => {
              const V = A === i, O = `${o}-${P}`;
              return /* @__PURE__ */ d(
                wd,
                {
                  ref: (U) => {
                    y.current[P] = U;
                  },
                  role: "option",
                  "aria-selected": V,
                  "data-marker": A.marker,
                  "data-state": V ? "selected" : void 0,
                  tabIndex: -1,
                  className: z(
                    "data-[state=selected]:tw-bg-muted",
                    c && "hover:tw-bg-muted/50",
                    "tw-w-full tw-rounded-sm tw-border-0 tw-bg-transparent tw-shadow-none",
                    "focus:tw-outline-none focus-visible:tw-outline-none",
                    /* ENHANCE: After considerable fiddling, this set of styles makes a focus ring
                       that looks great in Storybook. However, the left edge of the ring is clipped in
                       P.B app. These are similar, but not identical to, the customizations made in
                       our shadcn table component.
                    */
                    "focus-visible:tw-ring-offset-0.5 focus-visible:tw-relative focus-visible:tw-z-10 focus-visible:tw-ring-2 focus-visible:tw-ring-ring",
                    r === "horizontal" ? "horizontal tw-table-row" : "vertical tw-block tw-text-sm",
                    e
                  ),
                  onClick: () => h(A, P),
                  children: /* @__PURE__ */ d(
                    HD,
                    {
                      footnote: A,
                      layout: r,
                      formatCaller: () => f(A.caller, P),
                      showMarkers: s
                    }
                  )
                },
                O
              );
            })
          }
        )
      }
    )
  ] });
}
function GD({
  occurrenceData: t,
  setScriptureReference: e,
  localizedStrings: n
}) {
  const r = n["%webView_inventory_occurrences_table_header_reference%"], o = n["%webView_inventory_occurrences_table_header_occurrence%"], i = ue(() => {
    const s = [];
    return t.forEach((a) => {
      s.some((l) => ed(l, a)) || s.push(a);
    }), s;
  }, [t]);
  return /* @__PURE__ */ M(Ol, { stickyHeader: !0, children: [
    /* @__PURE__ */ d(Rl, { stickyHeader: !0, children: /* @__PURE__ */ M(Tr, { children: [
      /* @__PURE__ */ d(Es, { children: r }),
      /* @__PURE__ */ d(Es, { children: o })
    ] }) }),
    /* @__PURE__ */ d(Il, { children: i.length > 0 && i.map((s) => /* @__PURE__ */ M(
      Tr,
      {
        onClick: () => {
          e(s.reference);
        },
        children: [
          /* @__PURE__ */ d(Co, { children: `${We.bookIdToEnglishName(s.reference.book)} ${s.reference.chapterNum}:${s.reference.verseNum}` }),
          /* @__PURE__ */ d(Co, { children: s.text })
        ]
      },
      `${s.reference.book} ${s.reference.chapterNum}:${s.reference.verseNum}-${s.text}`
    )) })
  ] });
}
const yp = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  ru.Root,
  {
    ref: n,
    className: z(
      "tw-peer pr-twp tw-h-4 tw-w-4 tw-shrink-0 tw-rounded-sm tw-border tw-border-primary tw-ring-offset-background focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-cursor-not-allowed disabled:tw-opacity-50 data-[state=checked]:tw-bg-primary data-[state=checked]:tw-text-primary-foreground",
      t
    ),
    ...e,
    children: /* @__PURE__ */ d(
      ru.Indicator,
      {
        className: z("tw-flex tw-items-center tw-justify-center tw-text-current"),
        children: /* @__PURE__ */ d(br, { className: "tw-h-4 tw-w-4" })
      }
    )
  }
));
yp.displayName = ru.Root.displayName;
const oa = X.forwardRef(
  ({ className: t, type: e, ...n }, r) => /* @__PURE__ */ d(
    "input",
    {
      type: e,
      className: z(
        "pr-twp tw-flex tw-h-10 tw-rounded-md tw-border tw-border-input tw-bg-background tw-px-3 tw-py-2 tw-text-sm tw-ring-offset-background file:tw-border-0 file:tw-bg-transparent file:tw-text-sm file:tw-font-medium file:tw-text-foreground placeholder:tw-text-muted-foreground focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-cursor-not-allowed disabled:tw-opacity-50",
        t
      ),
      ref: r,
      ...n
    }
  )
);
oa.displayName = "Input";
const Kl = (t) => t === "asc" ? /* @__PURE__ */ d(hv, { className: "tw-ms-2 tw-h-4 tw-w-4" }) : t === "desc" ? /* @__PURE__ */ d(wv, { className: "tw-ms-2 tw-h-4 tw-w-4" }) : /* @__PURE__ */ d(gv, { className: "tw-ms-2 tw-h-4 tw-w-4" }), J5 = (t) => ({
  accessorKey: "item",
  accessorFn: (e) => e.items[0],
  header: ({ column: e }) => /* @__PURE__ */ M(Ne, { variant: "ghost", onClick: () => e.toggleSorting(void 0), children: [
    t,
    Kl(e.getIsSorted())
  ] })
}), KD = (t, e) => ({
  accessorKey: `item${e}`,
  accessorFn: (n) => n.items[e],
  header: ({ column: n }) => /* @__PURE__ */ M(Ne, { variant: "ghost", onClick: () => n.toggleSorting(void 0), children: [
    t,
    Kl(n.getIsSorted())
  ] })
}), X5 = (t) => ({
  accessorKey: "count",
  header: ({ column: e }) => /* @__PURE__ */ d("div", { className: "tw-flex tw-justify-end tw-tabular-nums", children: /* @__PURE__ */ M(Ne, { variant: "ghost", onClick: () => e.toggleSorting(void 0), children: [
    t,
    Kl(e.getIsSorted())
  ] }) }),
  cell: ({ row: e }) => /* @__PURE__ */ d("div", { className: "tw-flex tw-justify-end", children: e.getValue("count") })
}), Gc = (t, e, n, r, o, i) => {
  let s = [...n];
  t.forEach((l) => {
    e === "approved" ? s.includes(l) || s.push(l) : s = s.filter((c) => c !== l);
  }), r(s);
  let a = [...o];
  t.forEach((l) => {
    e === "unapproved" ? a.includes(l) || a.push(l) : a = a.filter((c) => c !== l);
  }), i(a);
}, Y5 = (t, e, n, r, o) => ({
  accessorKey: "status",
  header: ({ column: i }) => /* @__PURE__ */ d("div", { className: "tw-flex tw-justify-center", children: /* @__PURE__ */ M(Ne, { variant: "ghost", onClick: () => i.toggleSorting(void 0), children: [
    t,
    Kl(i.getIsSorted())
  ] }) }),
  cell: ({ row: i }) => {
    const s = i.getValue("status"), a = i.getValue("item");
    return /* @__PURE__ */ M(Ed, { value: s, variant: "outline", type: "single", children: [
      /* @__PURE__ */ d(
        ws,
        {
          onClick: (l) => {
            l.stopPropagation(), Gc(
              [a],
              "approved",
              e,
              n,
              r,
              o
            );
          },
          value: "approved",
          children: /* @__PURE__ */ d(dv, {})
        }
      ),
      /* @__PURE__ */ d(
        ws,
        {
          onClick: (l) => {
            l.stopPropagation(), Gc(
              [a],
              "unapproved",
              e,
              n,
              r,
              o
            );
          },
          value: "unapproved",
          children: /* @__PURE__ */ d(pv, {})
        }
      ),
      /* @__PURE__ */ d(
        ws,
        {
          onClick: (l) => {
            l.stopPropagation(), Gc(
              [a],
              "unknown",
              e,
              n,
              r,
              o
            );
          },
          value: "unknown",
          children: /* @__PURE__ */ d(fv, {})
        }
      )
    ] });
  }
}), Q5 = (t) => t.split(/(?:\r?\n|\r)|(?=(?:\\(?:v|c|id)))/g), Z5 = (t) => {
  const e = /^\\[vc]\s+(\d+)/, n = t.match(e);
  if (n)
    return +n[1];
}, eO = (t) => {
  const e = t.match(/^\\id\s+([A-Za-z]+)/);
  return e ? e[1] : "";
}, WD = (t, e, n) => n.includes(t) ? "unapproved" : e.includes(t) ? "approved" : "unknown", tO = Object.freeze([
  "%webView_inventory_all%",
  "%webView_inventory_approved%",
  "%webView_inventory_unapproved%",
  "%webView_inventory_unknown%",
  "%webView_inventory_scope_currentBook%",
  "%webView_inventory_scope_chapter%",
  "%webView_inventory_scope_verse%",
  "%webView_inventory_filter_text%",
  "%webView_inventory_show_additional_items%",
  "%webView_inventory_occurrences_table_header_reference%",
  "%webView_inventory_occurrences_table_header_occurrence%",
  "%webView_inventory_no_results%"
]), JD = (t, e, n) => {
  let r = t;
  return e !== "all" && (r = r.filter(
    (o) => e === "approved" && o.status === "approved" || e === "unapproved" && o.status === "unapproved" || e === "unknown" && o.status === "unknown"
  )), n !== "" && (r = r.filter((o) => o.items[0].includes(n))), r;
}, XD = (t, e, n) => {
  const r = [];
  return t.forEach((o) => {
    const i = r.find(
      (s) => ed(
        s.items,
        wc(o.inventoryText) ? [o.inventoryText] : o.inventoryText
      )
    );
    if (i)
      i.count += 1, i.occurrences.push({
        reference: o.verseRef,
        text: o.verse
      });
    else {
      const s = {
        items: wc(o.inventoryText) ? [o.inventoryText] : o.inventoryText,
        count: 1,
        status: WD(
          wc(o.inventoryText) ? o.inventoryText : o.inventoryText[0],
          e,
          n
        ),
        occurrences: [
          {
            reference: o.verseRef,
            text: o.verse
          }
        ]
      };
      r.push(s);
    }
  }), r;
}, sr = (t, e) => t[e] ?? e;
function nO({
  inventoryItems: t,
  setVerseRef: e,
  localizedStrings: n,
  additionalItemsLabels: r,
  approvedItems: o,
  unapprovedItems: i,
  scope: s,
  onScopeChange: a,
  columns: l,
  id: c,
  areInventoryItemsLoading: u = !1
}) {
  const p = sr(n, "%webView_inventory_all%"), f = sr(n, "%webView_inventory_approved%"), h = sr(n, "%webView_inventory_unapproved%"), g = sr(n, "%webView_inventory_unknown%"), b = sr(n, "%webView_inventory_scope_currentBook%"), _ = sr(n, "%webView_inventory_scope_chapter%"), x = sr(n, "%webView_inventory_scope_verse%"), y = sr(n, "%webView_inventory_filter_text%"), A = sr(
    n,
    "%webView_inventory_show_additional_items%"
  ), P = sr(n, "%webView_inventory_no_results%"), [V, O] = oe(!1), [U, B] = oe("all"), [F, K] = oe(""), [E, S] = oe([]), k = ue(() => {
    const W = t ?? [];
    return W.length === 0 ? [] : XD(W, o, i);
  }, [t, o, i]), I = ue(() => {
    if (V) return k;
    const W = [];
    return k.forEach((ee) => {
      const te = ee.items[0], Z = W.find(
        (Y) => Y.items[0] === te
      );
      Z ? (Z.count += ee.count, Z.occurrences = Z.occurrences.concat(ee.occurrences)) : W.push({
        items: [te],
        count: ee.count,
        occurrences: ee.occurrences,
        status: ee.status
      });
    }), W;
  }, [V, k]), N = ue(() => I.length === 0 ? [] : JD(I, U, F), [I, U, F]), T = ue(() => {
    var te, Z;
    if (!V) return l;
    const W = (te = r == null ? void 0 : r.tableHeaders) == null ? void 0 : te.length;
    if (!W) return l;
    const ee = [];
    for (let Y = 0; Y < W; Y++)
      ee.push(
        KD(
          ((Z = r == null ? void 0 : r.tableHeaders) == null ? void 0 : Z[Y]) || "Additional Item",
          Y + 1
        )
      );
    return [...ee, ...l];
  }, [r == null ? void 0 : r.tableHeaders, l, V]);
  ie(() => {
    N.length === 0 ? S([]) : N.length === 1 && S(N[0].items);
  }, [N]);
  const $ = (W, ee) => {
    ee.setRowSelection(() => {
      const te = {};
      return te[W.index] = !0, te;
    }), S(W.original.items);
  }, L = (W) => {
    if (W === "book" || W === "chapter" || W === "verse")
      a(W);
    else
      throw new Error(`Invalid scope value: ${W}`);
  }, J = (W) => {
    if (W === "all" || W === "approved" || W === "unapproved" || W === "unknown")
      B(W);
    else
      throw new Error(`Invalid status filter value: ${W}`);
  }, G = ue(() => {
    if (I.length === 0 || E.length === 0) return [];
    const W = I.filter((ee) => ed(
      V ? ee.items : [ee.items[0]],
      E
    ));
    if (W.length > 1) throw new Error("Selected item is not unique");
    return W.length === 0 ? [] : W[0].occurrences;
  }, [E, V, I]);
  return /* @__PURE__ */ M("div", { id: c, className: "pr-twp tw-flex tw-h-full tw-flex-col", children: [
    /* @__PURE__ */ M("div", { className: "tw-flex tw-items-stretch", children: [
      /* @__PURE__ */ M(
        wi,
        {
          onValueChange: (W) => J(W),
          defaultValue: U,
          children: [
            /* @__PURE__ */ d(Ao, { className: "tw-m-1", children: /* @__PURE__ */ d(gi, { placeholder: "Select filter" }) }),
            /* @__PURE__ */ M(So, { children: [
              /* @__PURE__ */ d(Dn, { value: "all", children: p }),
              /* @__PURE__ */ d(Dn, { value: "approved", children: f }),
              /* @__PURE__ */ d(Dn, { value: "unapproved", children: h }),
              /* @__PURE__ */ d(Dn, { value: "unknown", children: g })
            ] })
          ]
        }
      ),
      /* @__PURE__ */ M(wi, { onValueChange: (W) => L(W), defaultValue: s, children: [
        /* @__PURE__ */ d(Ao, { className: "tw-m-1", children: /* @__PURE__ */ d(gi, { placeholder: "Select scope" }) }),
        /* @__PURE__ */ M(So, { children: [
          /* @__PURE__ */ d(Dn, { value: "book", children: b }),
          /* @__PURE__ */ d(Dn, { value: "chapter", children: _ }),
          /* @__PURE__ */ d(Dn, { value: "verse", children: x })
        ] })
      ] }),
      /* @__PURE__ */ d(
        oa,
        {
          className: "tw-m-1 tw-rounded-md tw-border",
          placeholder: y,
          value: F,
          onChange: (W) => {
            K(W.target.value);
          }
        }
      ),
      r && /* @__PURE__ */ M("div", { className: "tw-m-1 tw-flex tw-items-center tw-rounded-md tw-border", children: [
        /* @__PURE__ */ d(
          yp,
          {
            className: "tw-m-1",
            checked: V,
            onCheckedChange: (W) => {
              O(W);
            }
          }
        ),
        /* @__PURE__ */ d(Lt, { className: "tw-m-1 tw-flex-shrink-0 tw-whitespace-nowrap", children: (r == null ? void 0 : r.checkboxText) ?? A })
      ] })
    ] }),
    /* @__PURE__ */ d("div", { className: "tw-m-1 tw-flex-1 tw-overflow-auto tw-rounded-md tw-border", children: /* @__PURE__ */ d(
      zx,
      {
        columns: T,
        data: N,
        onRowClickHandler: $,
        stickyHeader: !0,
        isLoading: u,
        noResultsMessage: P
      }
    ) }),
    G.length > 0 && /* @__PURE__ */ d("div", { className: "tw-m-1 tw-flex-1 tw-overflow-auto tw-rounded-md tw-border", children: /* @__PURE__ */ d(
      GD,
      {
        occurrenceData: G,
        setScriptureReference: e,
        localizedStrings: n
      }
    ) })
  ] });
}
const YD = "16rem", QD = "3rem", f0 = X.createContext(void 0);
function Wl() {
  const t = X.useContext(f0);
  if (!t)
    throw new Error("useSidebar must be used within a SidebarProvider.");
  return t;
}
const h0 = X.forwardRef(
  ({
    defaultOpen: t = !0,
    open: e,
    onOpenChange: n,
    className: r,
    style: o,
    children: i,
    side: s = "primary",
    ...a
  }, l) => {
    const [c, u] = X.useState(t), p = e ?? c, f = X.useCallback(
      (A) => {
        const P = typeof A == "function" ? A(p) : A;
        n ? n(P) : u(P);
      },
      [n, p]
    ), h = X.useCallback(() => f((A) => !A), [f]), g = p ? "expanded" : "collapsed", x = Bt() === "ltr" ? s : s === "primary" ? "secondary" : "primary", y = X.useMemo(
      () => ({
        state: g,
        open: p,
        setOpen: f,
        toggleSidebar: h,
        side: x
      }),
      [g, p, f, h, x]
    );
    return /* @__PURE__ */ d(f0.Provider, { value: y, children: /* @__PURE__ */ d(Nl, { delayDuration: 0, children: /* @__PURE__ */ d(
      "div",
      {
        style: (
          // eslint-disable-next-line no-type-assertion/no-type-assertion
          {
            "--sidebar-width": YD,
            "--sidebar-width-icon": QD,
            ...o
          }
        ),
        className: z(
          // Removed tw-min-h-svh
          "tw-group/sidebar-wrapper pr-twp tw-flex tw-w-full has-[[data-variant=inset]]:tw-bg-sidebar",
          r
        ),
        ref: l,
        ...a,
        children: i
      }
    ) }) });
  }
);
h0.displayName = "SidebarProvider";
const w0 = X.forwardRef(({ variant: t = "sidebar", collapsible: e = "offcanvas", className: n, children: r, ...o }, i) => {
  const s = Wl();
  return e === "none" ? /* @__PURE__ */ d(
    "div",
    {
      className: z(
        "tw-flex tw-h-full tw-w-[--sidebar-width] tw-flex-col tw-bg-sidebar tw-text-sidebar-foreground",
        n
      ),
      ref: i,
      ...o,
      children: r
    }
  ) : /* @__PURE__ */ M(
    "div",
    {
      ref: i,
      className: "tw-group tw-peer tw-hidden tw-text-sidebar-foreground md:tw-block",
      "data-state": s.state,
      "data-collapsible": s.state === "collapsed" ? e : "",
      "data-variant": t,
      "data-side": s.side,
      children: [
        /* @__PURE__ */ d(
          "div",
          {
            className: z(
              "tw-relative tw-h-svh tw-w-[--sidebar-width] tw-bg-transparent tw-transition-[width] tw-duration-200 tw-ease-linear",
              "group-data-[collapsible=offcanvas]:tw-w-0",
              "group-data-[side=secondary]:tw-rotate-180",
              t === "floating" || t === "inset" ? "group-data-[collapsible=icon]:tw-w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]" : "group-data-[collapsible=icon]:tw-w-[--sidebar-width-icon]"
            )
          }
        ),
        /* @__PURE__ */ d(
          "div",
          {
            className: z(
              // CUSTOM: Switched tw-fixed to tw-absolute here to scope the sidebar inside of it's container
              "tw-absolute tw-inset-y-0 tw-z-10 tw-hidden tw-h-svh tw-w-[--sidebar-width] tw-transition-[left,right,width] tw-duration-200 tw-ease-linear md:tw-flex",
              s.side === "primary" ? "tw-left-0 group-data-[collapsible=offcanvas]:tw-left-[calc(var(--sidebar-width)*-1)]" : "tw-right-0 group-data-[collapsible=offcanvas]:tw-right-[calc(var(--sidebar-width)*-1)]",
              // Adjust the padding for floating and inset variants.
              t === "floating" || t === "inset" ? "tw-p-2 group-data-[collapsible=icon]:tw-w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]" : "group-data-[collapsible=icon]:tw-w-[--sidebar-width-icon] group-data-[side=primary]:tw-border-r group-data-[side=secondary]:tw-border-l",
              n
            ),
            ...o,
            children: /* @__PURE__ */ d(
              "div",
              {
                "data-sidebar": "sidebar",
                className: "tw-flex tw-h-full tw-w-full tw-flex-col tw-bg-sidebar group-data-[variant=floating]:tw-rounded-lg group-data-[variant=floating]:tw-border group-data-[variant=floating]:tw-border-sidebar-border group-data-[variant=floating]:tw-shadow",
                children: r
              }
            )
          }
        )
      ]
    }
  );
});
w0.displayName = "Sidebar";
const ZD = X.forwardRef(({ className: t, onClick: e, ...n }, r) => {
  const o = Wl();
  return /* @__PURE__ */ M(
    Ne,
    {
      ref: r,
      "data-sidebar": "trigger",
      variant: "ghost",
      size: "icon",
      className: z("tw-h-7 tw-w-7", t),
      onClick: (i) => {
        e == null || e(i), o.toggleSidebar();
      },
      ...n,
      children: [
        o.side === "primary" ? /* @__PURE__ */ d(mv, {}) : /* @__PURE__ */ d(bv, {}),
        /* @__PURE__ */ d("span", { className: "tw-sr-only", children: "Toggle Sidebar" })
      ]
    }
  );
});
ZD.displayName = "SidebarTrigger";
const eM = X.forwardRef(
  ({ className: t, ...e }, n) => {
    const { toggleSidebar: r } = Wl();
    return /* @__PURE__ */ d(
      "button",
      {
        type: "button",
        ref: n,
        "data-sidebar": "rail",
        "aria-label": "Toggle Sidebar",
        tabIndex: -1,
        onClick: r,
        title: "Toggle Sidebar",
        className: z(
          "tw-absolute tw-inset-y-0 tw-z-20 tw-hidden tw-w-4 tw--translate-x-1/2 tw-transition-all tw-ease-linear after:tw-absolute after:tw-inset-y-0 after:tw-left-1/2 after:tw-w-[2px] hover:after:tw-bg-sidebar-border group-data-[side=primary]:tw--right-4 group-data-[side=secondary]:tw-left-0 sm:tw-flex",
          "[[data-side=secondary]_&]:tw-cursor-e-resize [[data-side=secondary]_&]:tw-cursor-w-resize",
          "[[data-side=primary][data-state=collapsed]_&]:tw-cursor-e-resize [[data-side=secondary][data-state=collapsed]_&]:tw-cursor-w-resize",
          "group-data-[collapsible=offcanvas]:tw-translate-x-0 group-data-[collapsible=offcanvas]:after:tw-left-full group-data-[collapsible=offcanvas]:hover:tw-bg-sidebar",
          "[[data-side=primary][data-collapsible=offcanvas]_&]:tw--right-2",
          "[[data-side=secondary][data-collapsible=offcanvas]_&]:tw--left-2",
          t
        ),
        ...e
      }
    );
  }
);
eM.displayName = "SidebarRail";
const g0 = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "main",
    {
      ref: n,
      className: z(
        // CUSTOM: Removed tw-min-h-svh
        "tw-relative tw-flex tw-flex-1 tw-flex-col tw-bg-background",
        "peer-data-[variant=inset]:tw-min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:tw-m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:tw-ml-2 md:peer-data-[variant=inset]:tw-ml-0 md:peer-data-[variant=inset]:tw-rounded-xl md:peer-data-[variant=inset]:tw-shadow",
        t
      ),
      ...e
    }
  )
);
g0.displayName = "SidebarInset";
const tM = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  oa,
  {
    ref: n,
    "data-sidebar": "input",
    className: z(
      "tw-h-8 tw-w-full tw-bg-background tw-shadow-none focus-visible:tw-ring-2 focus-visible:tw-ring-sidebar-ring",
      t
    ),
    ...e
  }
));
tM.displayName = "SidebarInput";
const nM = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "div",
    {
      ref: n,
      "data-sidebar": "header",
      className: z("tw-flex tw-flex-col tw-gap-2 tw-p-2", t),
      ...e
    }
  )
);
nM.displayName = "SidebarHeader";
const rM = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "div",
    {
      ref: n,
      "data-sidebar": "footer",
      className: z("tw-flex tw-flex-col tw-gap-2 tw-p-2", t),
      ...e
    }
  )
);
rM.displayName = "SidebarFooter";
const oM = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  vs,
  {
    ref: n,
    "data-sidebar": "separator",
    className: z("tw-mx-2 tw-w-auto tw-bg-sidebar-border", t),
    ...e
  }
));
oM.displayName = "SidebarSeparator";
const m0 = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "div",
    {
      ref: n,
      "data-sidebar": "content",
      className: z(
        "tw-flex tw-min-h-0 tw-flex-1 tw-flex-col tw-gap-2 tw-overflow-auto group-data-[collapsible=icon]:tw-overflow-hidden",
        t
      ),
      ...e
    }
  )
);
m0.displayName = "SidebarContent";
const Ku = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "div",
    {
      ref: n,
      "data-sidebar": "group",
      className: z("tw-relative tw-flex tw-w-full tw-min-w-0 tw-flex-col tw-p-2", t),
      ...e
    }
  )
);
Ku.displayName = "SidebarGroup";
const Wu = X.forwardRef(({ className: t, asChild: e = !1, ...n }, r) => /* @__PURE__ */ d(
  e ? Si : "div",
  {
    ref: r,
    "data-sidebar": "group-label",
    className: z(
      "tw-flex tw-h-8 tw-shrink-0 tw-items-center tw-rounded-md tw-px-2 tw-text-xs tw-font-medium tw-text-sidebar-foreground/70 tw-outline-none tw-ring-sidebar-ring tw-transition-[margin,opa] tw-duration-200 tw-ease-linear focus-visible:tw-ring-2 [&>svg]:tw-size-4 [&>svg]:tw-shrink-0",
      "group-data-[collapsible=icon]:tw--mt-8 group-data-[collapsible=icon]:tw-opacity-0",
      t
    ),
    ...n
  }
));
Wu.displayName = "SidebarGroupLabel";
const iM = X.forwardRef(({ className: t, asChild: e = !1, ...n }, r) => /* @__PURE__ */ d(
  e ? Si : "button",
  {
    ref: r,
    "data-sidebar": "group-action",
    className: z(
      "tw-absolute tw-right-3 tw-top-3.5 tw-flex tw-aspect-square tw-w-5 tw-items-center tw-justify-center tw-rounded-md tw-p-0 tw-text-sidebar-foreground tw-outline-none tw-ring-sidebar-ring tw-transition-transform hover:tw-bg-sidebar-accent hover:tw-text-sidebar-accent-foreground focus-visible:tw-ring-2 [&>svg]:tw-size-4 [&>svg]:tw-shrink-0",
      // Increases the hit area of the button on mobile.
      "after:tw-absolute after:tw--inset-2 after:md:tw-hidden",
      "group-data-[collapsible=icon]:tw-hidden",
      t
    ),
    ...n
  }
));
iM.displayName = "SidebarGroupAction";
const Ju = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "div",
    {
      ref: n,
      "data-sidebar": "group-content",
      className: z("tw-w-full tw-text-sm", t),
      ...e
    }
  )
);
Ju.displayName = "SidebarGroupContent";
const b0 = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "ul",
    {
      ref: n,
      "data-sidebar": "menu",
      className: z("tw-flex tw-w-full tw-min-w-0 tw-flex-col tw-gap-1", t),
      ...e
    }
  )
);
b0.displayName = "SidebarMenu";
const v0 = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "li",
    {
      ref: n,
      "data-sidebar": "menu-item",
      className: z("tw-group/menu-item tw-relative", t),
      ...e
    }
  )
);
v0.displayName = "SidebarMenuItem";
const sM = eo(
  "tw-peer/menu-button tw-flex tw-w-full tw-items-center tw-gap-2 tw-overflow-hidden tw-rounded-md tw-p-2 tw-text-left tw-text-sm tw-outline-none tw-ring-sidebar-ring tw-transition-[width,height,padding] hover:tw-bg-sidebar-accent hover:tw-text-sidebar-accent-foreground focus-visible:tw-ring-2 active:tw-bg-sidebar-accent active:tw-text-sidebar-accent-foreground disabled:tw-pointer-events-none disabled:tw-opacity-50 tw-group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:tw-pointer-events-none aria-disabled:tw-opacity-50 data-[active=true]:tw-font-medium data-[active=true]:tw-text-sidebar-accent-foreground data-[active=true]:tw-bg-sidebar-accent data-[state=open]:hover:tw-bg-sidebar-accent data-[state=open]:hover:tw-text-sidebar-accent-foreground group-data-[collapsible=icon]:tw-!size-8 group-data-[collapsible=icon]:tw-!p-2 [&>span:last-child]:tw-truncate [&>svg]:tw-size-4 [&>svg]:tw-shrink-0",
  {
    variants: {
      variant: {
        default: "hover:tw-bg-sidebar-accent hover:tw-text-sidebar-accent-foreground",
        outline: "tw-bg-background tw-shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:tw-bg-sidebar-accent hover:tw-text-sidebar-accent-foreground hover:tw-shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
      },
      size: {
        default: "tw-h-8 tw-text-sm",
        sm: "tw-h-7 tw-text-xs",
        lg: "tw-h-12 tw-text-sm group-data-[collapsible=icon]:tw-!p-0"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), y0 = X.forwardRef(
  ({
    asChild: t = !1,
    isActive: e = !1,
    variant: n = "default",
    size: r = "default",
    tooltip: o,
    className: i,
    ...s
  }, a) => {
    const l = t ? Si : "button", { state: c } = Wl(), u = /* @__PURE__ */ d(
      l,
      {
        ref: a,
        "data-sidebar": "menu-button",
        "data-size": r,
        "data-active": e,
        className: z(sM({ variant: n, size: r }), i),
        ...s
      }
    );
    return o ? (typeof o == "string" && (o = {
      children: o
    }), /* @__PURE__ */ M(md, { children: [
      /* @__PURE__ */ d(bd, { asChild: !0, children: u }),
      /* @__PURE__ */ d(Tl, { side: "right", align: "center", hidden: c !== "collapsed", ...o })
    ] })) : u;
  }
);
y0.displayName = "SidebarMenuButton";
const aM = X.forwardRef(({ className: t, asChild: e = !1, showOnHover: n = !1, ...r }, o) => /* @__PURE__ */ d(
  e ? Si : "button",
  {
    ref: o,
    "data-sidebar": "menu-action",
    className: z(
      "tw-peer-hover/menu-button:text-sidebar-accent-foreground tw-absolute tw-right-1 tw-top-1.5 tw-flex tw-aspect-square tw-w-5 tw-items-center tw-justify-center tw-rounded-md tw-p-0 tw-text-sidebar-foreground tw-outline-none tw-ring-sidebar-ring tw-transition-transform hover:tw-bg-sidebar-accent hover:tw-text-sidebar-accent-foreground focus-visible:tw-ring-2 [&>svg]:tw-size-4 [&>svg]:tw-shrink-0",
      // Increases the hit area of the button on mobile.
      "after:tw-absolute after:tw--inset-2 after:md:tw-hidden",
      "tw-peer-data-[size=sm]/menu-button:top-1",
      "tw-peer-data-[size=default]/menu-button:top-1.5",
      "tw-peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:tw-hidden",
      n && "tw-group-focus-within/menu-item:opacity-100 tw-group-hover/menu-item:opacity-100 tw-peer-data-[active=true]/menu-button:text-sidebar-accent-foreground data-[state=open]:tw-opacity-100 md:tw-opacity-0",
      t
    ),
    ...r
  }
));
aM.displayName = "SidebarMenuAction";
const lM = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "div",
    {
      ref: n,
      "data-sidebar": "menu-badge",
      className: z(
        "tw-pointer-events-none tw-absolute tw-right-1 tw-flex tw-h-5 tw-min-w-5 tw-select-none tw-items-center tw-justify-center tw-rounded-md tw-px-1 tw-text-xs tw-font-medium tw-tabular-nums tw-text-sidebar-foreground",
        "tw-peer-hover/menu-button:text-sidebar-accent-foreground tw-peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "tw-peer-data-[size=sm]/menu-button:top-1",
        "tw-peer-data-[size=default]/menu-button:top-1.5",
        "tw-peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:tw-hidden",
        t
      ),
      ...e
    }
  )
);
lM.displayName = "SidebarMenuBadge";
const cM = X.forwardRef(({ className: t, showIcon: e = !1, ...n }, r) => {
  const o = X.useMemo(() => `${Math.floor(Math.random() * 40) + 50}%`, []);
  return /* @__PURE__ */ M(
    "div",
    {
      ref: r,
      "data-sidebar": "menu-skeleton",
      className: z("tw-flex tw-h-8 tw-items-center tw-gap-2 tw-rounded-md tw-px-2", t),
      ...n,
      children: [
        e && /* @__PURE__ */ d(du, { className: "tw-size-4 tw-rounded-md", "data-sidebar": "menu-skeleton-icon" }),
        /* @__PURE__ */ d(
          du,
          {
            className: "tw-h-4 tw-max-w-[--skeleton-width] tw-flex-1",
            "data-sidebar": "menu-skeleton-text",
            style: (
              // eslint-disable-next-line no-type-assertion/no-type-assertion
              {
                "--skeleton-width": o
              }
            )
          }
        )
      ]
    }
  );
});
cM.displayName = "SidebarMenuSkeleton";
const uM = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "ul",
    {
      ref: n,
      "data-sidebar": "menu-sub",
      className: z(
        "tw-mx-3.5 tw-flex tw-min-w-0 tw-translate-x-px tw-flex-col tw-gap-1 tw-border-l tw-border-sidebar-border tw-px-2.5 tw-py-0.5",
        "group-data-[collapsible=icon]:tw-hidden",
        t
      ),
      ...e
    }
  )
);
uM.displayName = "SidebarMenuSub";
const dM = X.forwardRef(
  ({ ...t }, e) => /* @__PURE__ */ d("li", { ref: e, ...t })
);
dM.displayName = "SidebarMenuSubItem";
const pM = X.forwardRef(({ asChild: t = !1, size: e = "md", isActive: n, className: r, ...o }, i) => /* @__PURE__ */ d(
  t ? Si : "a",
  {
    ref: i,
    "data-sidebar": "menu-sub-button",
    "data-size": e,
    "data-active": n,
    className: z(
      "tw-flex tw-h-7 tw-min-w-0 tw--translate-x-px tw-items-center tw-gap-2 tw-overflow-hidden tw-rounded-md tw-px-2 tw-text-sidebar-foreground tw-outline-none tw-ring-sidebar-ring hover:tw-bg-sidebar-accent hover:tw-text-sidebar-accent-foreground focus-visible:tw-ring-2 active:tw-bg-sidebar-accent active:tw-text-sidebar-accent-foreground disabled:tw-pointer-events-none disabled:tw-opacity-50 aria-disabled:tw-pointer-events-none aria-disabled:tw-opacity-50 [&>span:last-child]:tw-truncate [&>svg]:tw-size-4 [&>svg]:tw-shrink-0 [&>svg]:tw-text-sidebar-accent-foreground",
      "data-[active=true]:tw-bg-sidebar-accent data-[active=true]:tw-text-sidebar-accent-foreground",
      e === "sm" && "tw-text-xs",
      e === "md" && "tw-text-sm",
      "group-data-[collapsible=icon]:tw-hidden",
      r
    ),
    ...o
  }
));
pM.displayName = "SidebarMenuSubButton";
function fM({
  id: t,
  extensionLabels: e,
  projectInfo: n,
  handleSelectSidebarItem: r,
  selectedSidebarItem: o,
  extensionsSidebarGroupLabel: i,
  projectsSidebarGroupLabel: s,
  buttonPlaceholderText: a,
  className: l
}) {
  const c = ce(
    (f, h) => {
      r(f, h);
    },
    [r]
  ), u = ce(
    (f) => {
      const h = n.find((g) => g.projectId === f);
      return h ? h.projectName : f;
    },
    [n]
  ), p = ce(
    (f) => !o.projectId && f === o.label,
    [o]
  );
  return /* @__PURE__ */ d(
    w0,
    {
      id: t,
      collapsible: "none",
      variant: "inset",
      className: z("tw-w-96 tw-gap-2 tw-overflow-y-auto", l),
      children: /* @__PURE__ */ M(m0, { children: [
        /* @__PURE__ */ M(Ku, { children: [
          /* @__PURE__ */ d(Wu, { className: "tw-text-sm", children: i }),
          /* @__PURE__ */ d(Ju, { children: /* @__PURE__ */ d(b0, { children: Object.entries(e).map(([f, h]) => /* @__PURE__ */ d(v0, { children: /* @__PURE__ */ d(
            y0,
            {
              onClick: () => c(f),
              isActive: p(f),
              children: /* @__PURE__ */ d("span", { className: "tw-pl-3", children: h })
            }
          ) }, f)) }) })
        ] }),
        /* @__PURE__ */ M(Ku, { children: [
          /* @__PURE__ */ d(Wu, { className: "tw-text-sm", children: s }),
          /* @__PURE__ */ d(Ju, { className: "tw-pl-3", children: /* @__PURE__ */ d(
            au,
            {
              buttonVariant: "ghost",
              buttonClassName: z("tw-w-full", {
                "tw-bg-sidebar-accent tw-text-sidebar-accent-foreground": o == null ? void 0 : o.projectId
              }),
              popoverContentClassName: "tw-z-[1000]",
              options: n.flatMap((f) => f.projectId),
              getOptionLabel: u,
              buttonPlaceholder: a,
              onChange: (f) => {
                const h = u(f);
                c(h, f);
              },
              value: (o == null ? void 0 : o.projectId) ?? void 0,
              icon: /* @__PURE__ */ d(vv, {})
            }
          ) })
        ] })
      ] })
    }
  );
}
const xp = an(
  ({ value: t, onSearch: e, placeholder: n, isFullWidth: r, className: o, isDisabled: i = !1, id: s }, a) => {
    const l = Bt();
    return /* @__PURE__ */ M("div", { id: s, className: z("tw-relative", { "tw-w-full": r }, o), children: [
      /* @__PURE__ */ d(
        dw,
        {
          className: z(
            "tw-absolute tw-top-1/2 tw-h-4 tw-w-4 tw--translate-y-1/2 tw-transform tw-opacity-50",
            { "tw-right-3": l === "rtl" },
            { "tw-left-3": l === "ltr" }
          )
        }
      ),
      /* @__PURE__ */ d(
        oa,
        {
          ref: a,
          className: "tw-w-full tw-text-ellipsis tw-pe-9 tw-ps-9",
          placeholder: n,
          value: t,
          onChange: (c) => e(c.target.value),
          disabled: i
        }
      ),
      t && /* @__PURE__ */ M(
        Ne,
        {
          variant: "ghost",
          size: "icon",
          className: z(
            "tw-absolute tw-top-1/2 tw-h-7 tw--translate-y-1/2 tw-transform hover:tw-bg-transparent",
            { "tw-left-0": l === "rtl" },
            { "tw-right-0": l === "ltr" }
          ),
          onClick: () => {
            e("");
          },
          children: [
            /* @__PURE__ */ d(wl, { className: "tw-h-4 tw-w-4" }),
            /* @__PURE__ */ d("span", { className: "tw-sr-only", children: "Clear" })
          ]
        }
      )
    ] });
  }
);
xp.displayName = "SearchBar";
function rO({
  id: t,
  extensionLabels: e,
  projectInfo: n,
  children: r,
  handleSelectSidebarItem: o,
  selectedSidebarItem: i,
  searchValue: s,
  onSearch: a,
  extensionsSidebarGroupLabel: l,
  projectsSidebarGroupLabel: c,
  buttonPlaceholderText: u
}) {
  return /* @__PURE__ */ M("div", { className: "tw-box-border tw-flex tw-h-full tw-flex-col", children: [
    /* @__PURE__ */ d("div", { className: "tw-box-border tw-flex tw-items-center tw-justify-center tw-py-4", children: /* @__PURE__ */ d(
      xp,
      {
        className: "tw-w-9/12",
        value: s,
        onSearch: a,
        placeholder: "Search app settings, extension settings, and project settings"
      }
    ) }),
    /* @__PURE__ */ M(
      h0,
      {
        id: t,
        className: "tw-h-full tw-flex-1 tw-gap-4 tw-overflow-auto tw-border-t",
        children: [
          /* @__PURE__ */ d(
            fM,
            {
              className: "tw-w-1/2 tw-min-w-[140px] tw-max-w-[220px] tw-border-e",
              extensionLabels: e,
              projectInfo: n,
              handleSelectSidebarItem: o,
              selectedSidebarItem: i,
              extensionsSidebarGroupLabel: l,
              projectsSidebarGroupLabel: c,
              buttonPlaceholderText: u
            }
          ),
          /* @__PURE__ */ d(g0, { className: "tw-min-w-[215px]", children: r })
        ]
      }
    )
  ] });
}
const qr = "scrBook", hM = "scrRef", yo = "source", wM = "details", gM = "Scripture Reference", mM = "Scripture Book", x0 = "Type", bM = "Details";
function vM(t, e) {
  const n = e ?? !1;
  return [
    {
      accessorFn: (r) => `${r.start.book} ${r.start.chapterNum}:${r.start.verseNum}`,
      id: qr,
      header: (t == null ? void 0 : t.scriptureReferenceColumnName) ?? gM,
      cell: (r) => {
        const o = r.row.original;
        return r.row.getIsGrouped() ? We.bookIdToEnglishName(o.start.book) : r.row.groupingColumnId === qr ? ai(o.start) : void 0;
      },
      getGroupingValue: (r) => We.bookIdToNumber(r.start.book),
      sortingFn: (r, o) => Zc(r.original.start, o.original.start),
      enableGrouping: !0
    },
    {
      accessorFn: (r) => ai(r.start),
      id: hM,
      header: void 0,
      cell: (r) => {
        const o = r.row.original;
        return r.row.getIsGrouped() ? void 0 : ai(o.start);
      },
      sortingFn: (r, o) => Zc(r.original.start, o.original.start),
      enableGrouping: !1
    },
    {
      accessorFn: (r) => r.source.displayName,
      id: yo,
      header: n ? (t == null ? void 0 : t.typeColumnName) ?? x0 : void 0,
      cell: (r) => n || r.row.getIsGrouped() ? r.getValue() : void 0,
      getGroupingValue: (r) => r.source.id,
      sortingFn: (r, o) => r.original.source.displayName.localeCompare(o.original.source.displayName),
      enableGrouping: !0
    },
    {
      accessorFn: (r) => r.detail,
      id: wM,
      header: (t == null ? void 0 : t.detailsColumnName) ?? bM,
      cell: (r) => r.getValue(),
      enableGrouping: !1
    }
  ];
}
const yM = (t) => {
  if (!("offset" in t.start))
    throw new Error("No offset available in range start");
  if (t.end && !("offset" in t.end))
    throw new Error("No offset available in range end");
  const { offset: e } = t.start;
  let n = 0;
  return t.end && ({ offset: n } = t.end), !t.end || Zc(t.start, t.end) === 0 ? `${gc(t.start)}+${e}` : `${gc(t.start)}+${e}-${gc(t.end)}+${n}`;
}, lw = (t) => `${yM({ start: t.start, end: t.end })} ${t.source.displayName} ${t.detail}`;
function oO({
  sources: t,
  showColumnHeaders: e = !1,
  showSourceColumn: n = !1,
  scriptureReferenceColumnName: r,
  scriptureBookGroupName: o,
  typeColumnName: i,
  detailsColumnName: s,
  onRowSelected: a,
  id: l
}) {
  const [c, u] = oe([]), [p, f] = oe([{ id: qr, desc: !1 }]), [h, g] = oe({}), b = ue(
    () => t.flatMap((F) => F.data.map((K) => ({
      ...K,
      source: F.source
    }))),
    [t]
  ), _ = ue(
    () => vM(
      {
        scriptureReferenceColumnName: r,
        typeColumnName: i,
        detailsColumnName: s
      },
      n
    ),
    [r, i, s, n]
  );
  ie(() => {
    c.includes(yo) ? f([
      { id: yo, desc: !1 },
      { id: qr, desc: !1 }
    ]) : f([{ id: qr, desc: !1 }]);
  }, [c]);
  const x = Dw({
    data: b,
    columns: _,
    state: {
      grouping: c,
      sorting: p,
      rowSelection: h
    },
    onGroupingChange: u,
    onSortingChange: f,
    onRowSelectionChange: g,
    getExpandedRowModel: My(),
    getGroupedRowModel: Dy(),
    getCoreRowModel: Ow(),
    getSortedRowModel: Mw(),
    getRowId: lw,
    autoResetExpanded: !1,
    enableMultiRowSelection: !1,
    enableSubRowSelection: !1
  });
  ie(() => {
    if (a) {
      const F = x.getSelectedRowModel().rowsById, K = Object.keys(F);
      if (K.length === 1) {
        const E = b.find((S) => lw(S) === K[0]) || void 0;
        E && a(E);
      }
    }
  }, [h, b, a, x]);
  const y = o ?? mM, A = i ?? x0, P = [
    { label: "No Grouping", value: [] },
    { label: `Group by ${y}`, value: [qr] },
    { label: `Group by ${A}`, value: [yo] },
    {
      label: `Group by ${y} and ${A}`,
      value: [qr, yo]
    },
    {
      label: `Group by ${A} and ${y}`,
      value: [yo, qr]
    }
  ], V = (F) => {
    u(JSON.parse(F));
  }, O = (F, K) => {
    !F.getIsGrouped() && !F.getIsSelected() && F.getToggleSelectedHandler()(K);
  }, U = (F, K) => F.getIsGrouped() ? "" : z("banded-row", K % 2 === 0 ? "even" : "odd"), B = (F, K, E) => {
    if (!((F == null ? void 0 : F.length) === 0 || K.depth < E.column.getGroupedIndex())) {
      if (K.getIsGrouped())
        switch (K.depth) {
          case 1:
            return "tw-ps-4";
          default:
            return;
        }
      switch (K.depth) {
        case 1:
          return "tw-ps-8";
        case 2:
          return "tw-ps-12";
        default:
          return;
      }
    }
  };
  return /* @__PURE__ */ M("div", { id: l, className: "pr-twp tw-flex tw-h-full tw-w-full tw-flex-col", children: [
    !e && /* @__PURE__ */ M(
      wi,
      {
        value: JSON.stringify(c),
        onValueChange: (F) => {
          V(F);
        },
        children: [
          /* @__PURE__ */ d(Ao, { className: "tw-mb-1 tw-mt-2", children: /* @__PURE__ */ d(gi, {}) }),
          /* @__PURE__ */ d(So, { position: "item-aligned", children: /* @__PURE__ */ d(Ix, { children: P.map((F) => /* @__PURE__ */ d(Dn, { value: JSON.stringify(F.value), children: F.label }, F.label)) }) })
        ]
      }
    ),
    /* @__PURE__ */ M(Ol, { className: "tw-relative tw-flex tw-flex-col tw-overflow-y-auto tw-p-0", children: [
      e && /* @__PURE__ */ d(Rl, { children: x.getHeaderGroups().map((F) => /* @__PURE__ */ d(Tr, { children: F.headers.filter((K) => K.column.columnDef.header).map((K) => (
        /* For sticky column headers to work, we probably need to change the default definition of the shadcn Table component. See https://github.com/shadcn-ui/ui/issues/1151 */
        /* @__PURE__ */ d(Es, { colSpan: K.colSpan, className: "top-0 tw-sticky", children: K.isPlaceholder ? void 0 : /* @__PURE__ */ M("div", { children: [
          K.column.getCanGroup() ? /* @__PURE__ */ d(
            Ne,
            {
              variant: "ghost",
              title: `Toggle grouping by ${K.column.columnDef.header}`,
              onClick: K.column.getToggleGroupingHandler(),
              type: "button",
              children: K.column.getIsGrouped() ? "ðŸ›‘" : "ðŸ‘Š "
            }
          ) : void 0,
          " ",
          fs(K.column.columnDef.header, K.getContext())
        ] }) }, K.id)
      )) }, F.id)) }),
      /* @__PURE__ */ d(Il, { children: x.getRowModel().rows.map((F, K) => {
        const E = Bt();
        return /* @__PURE__ */ d(
          Tr,
          {
            "data-state": F.getIsSelected() ? "selected" : "",
            className: z(U(F, K)),
            onClick: (S) => O(F, S),
            children: F.getVisibleCells().map((S) => {
              if (!(S.getIsPlaceholder() || S.column.columnDef.enableGrouping && !S.getIsGrouped() && (S.column.columnDef.id !== yo || !n)))
                return /* @__PURE__ */ d(
                  Co,
                  {
                    className: z(
                      S.column.columnDef.id,
                      "tw-p-[1px]",
                      B(c, F, S)
                    ),
                    children: S.getIsGrouped() ? /* @__PURE__ */ M(
                      Ne,
                      {
                        variant: "link",
                        onClick: F.getToggleExpandedHandler(),
                        type: "button",
                        children: [
                          F.getIsExpanded() && /* @__PURE__ */ d(fi, {}),
                          !F.getIsExpanded() && (E === "ltr" ? /* @__PURE__ */ d(pi, {}) : /* @__PURE__ */ d(Xc, {})),
                          " ",
                          fs(S.column.columnDef.cell, S.getContext()),
                          " (",
                          F.subRows.length,
                          ")"
                        ]
                      }
                    ) : fs(S.column.columnDef.cell, S.getContext())
                  },
                  S.id
                );
            })
          },
          F.id
        );
      }) })
    ] })
  ] });
}
const _p = (t, e) => t.filter((n) => {
  try {
    return ds(n) === e;
  } catch {
    return !1;
  }
}), _0 = (t, e, n) => _p(t, e).every((r) => n.includes(r));
function xM({
  section: t,
  availableBookIds: e,
  selectedBookIds: n,
  onToggle: r,
  localizedStrings: o
}) {
  const i = _p(e, t).length === 0, s = o["%scripture_section_ot_short%"], a = o["%scripture_section_nt_short%"], l = o["%scripture_section_dc_short%"], c = o["%scripture_section_extra_short%"];
  return /* @__PURE__ */ d(
    Ne,
    {
      variant: "outline",
      size: "sm",
      onClick: () => r(t),
      className: z(
        _0(e, t, n) && !i && "tw-bg-primary tw-text-primary-foreground hover:tw-bg-primary/70 hover:tw-text-primary-foreground"
      ),
      disabled: i,
      children: Qy(
        t,
        s,
        a,
        l,
        c
      )
    }
  );
}
const cw = 5, Kc = 6;
function _M({
  availableBookInfo: t,
  selectedBookIds: e,
  onChangeSelectedBookIds: n,
  localizedStrings: r,
  localizedBookNames: o
}) {
  const i = r["%webView_book_selector_books_selected%"], s = r["%webView_book_selector_select_books%"], a = r["%webView_book_selector_search_books%"], l = r["%webView_book_selector_select_all%"], c = r["%webView_book_selector_clear_all%"], u = r["%webView_book_selector_no_book_found%"], p = r["%webView_book_selector_more%"], { otLong: f, ntLong: h, dcLong: g, extraLong: b } = {
    otLong: r == null ? void 0 : r["%scripture_section_ot_long%"],
    ntLong: r == null ? void 0 : r["%scripture_section_nt_long%"],
    dcLong: r == null ? void 0 : r["%scripture_section_dc_long%"],
    extraLong: r == null ? void 0 : r["%scripture_section_extra_long%"]
  }, [_, x] = oe(!1), [y, A] = oe(""), P = he(void 0), V = he(!1);
  if (t.length !== We.allBookIds.length)
    throw new Error("availableBookInfo length must match Canon.allBookIds length");
  const O = ue(() => We.allBookIds.filter(
    (I, N) => t[N] === "1" && !We.isObsolete(We.bookIdToNumber(I))
  ), [t]), U = ue(() => {
    if (!y.trim()) {
      const T = {
        [$e.OT]: [],
        [$e.NT]: [],
        [$e.DC]: [],
        [$e.Extra]: []
      };
      return O.forEach(($) => {
        const L = ds($);
        T[L].push($);
      }), T;
    }
    const I = O.filter(
      (T) => fd(T, y, o)
    ), N = {
      [$e.OT]: [],
      [$e.NT]: [],
      [$e.DC]: [],
      [$e.Extra]: []
    };
    return I.forEach((T) => {
      const $ = ds(T);
      N[$].push(T);
    }), N;
  }, [O, y, o]), B = ce(
    (I, N = !1) => {
      if (!N || !P.current) {
        n(
          e.includes(I) ? e.filter((W) => W !== I) : [...e, I]
        ), P.current = I;
        return;
      }
      const T = O.findIndex((W) => W === P.current), $ = O.findIndex((W) => W === I);
      if (T === -1 || $ === -1) return;
      const [L, J] = [
        Math.min(T, $),
        Math.max(T, $)
      ], G = O.slice(L, J + 1).map((W) => W);
      n(
        e.includes(I) ? e.filter((W) => !G.includes(W)) : [.../* @__PURE__ */ new Set([...e, ...G])]
      );
    },
    [e, n, O]
  ), F = (I) => {
    B(I, V.current), V.current = !1;
  }, K = (I, N) => {
    I.preventDefault(), B(N, I.shiftKey);
  }, E = ce(
    (I) => {
      const N = _p(O, I).map((T) => T);
      n(
        _0(O, I, e) ? e.filter((T) => !N.includes(T)) : [.../* @__PURE__ */ new Set([...e, ...N])]
      );
    },
    [e, n, O]
  ), S = () => {
    n(O.map((I) => I));
  }, k = () => {
    n([]);
  };
  return /* @__PURE__ */ M("div", { className: "tw-space-y-2", children: [
    /* @__PURE__ */ d("div", { className: "tw-flex tw-flex-wrap tw-gap-2", children: Object.values($e).map((I) => /* @__PURE__ */ d(
      xM,
      {
        section: I,
        availableBookIds: O,
        selectedBookIds: e,
        onToggle: E,
        localizedStrings: r
      },
      I
    )) }),
    /* @__PURE__ */ M(
      Li,
      {
        open: _,
        onOpenChange: (I) => {
          x(I), I || A("");
        },
        children: [
          /* @__PURE__ */ d(Pi, { asChild: !0, children: /* @__PURE__ */ M(
            Ne,
            {
              variant: "outline",
              role: "combobox",
              "aria-expanded": _,
              className: "tw-max-w-64 tw-justify-between",
              children: [
                e.length > 0 ? `${i}: ${e.length}` : s,
                /* @__PURE__ */ d(Zu, { className: "tw-ml-2 tw-h-4 tw-w-4 tw-shrink-0 tw-opacity-50" })
              ]
            }
          ) }),
          /* @__PURE__ */ d(zo, { className: "tw-w-full tw-p-0", align: "start", children: /* @__PURE__ */ M(
            Oi,
            {
              shouldFilter: !1,
              onKeyDown: (I) => {
                I.key === "Enter" && (V.current = I.shiftKey);
              },
              children: [
                /* @__PURE__ */ d(
                  Gs,
                  {
                    placeholder: a,
                    value: y,
                    onValueChange: A
                  }
                ),
                /* @__PURE__ */ M("div", { className: "tw-flex tw-justify-between tw-border-b tw-p-2", children: [
                  /* @__PURE__ */ d(Ne, { variant: "ghost", size: "sm", onClick: S, children: l }),
                  /* @__PURE__ */ d(Ne, { variant: "ghost", size: "sm", onClick: k, children: c })
                ] }),
                /* @__PURE__ */ M(Ri, { children: [
                  /* @__PURE__ */ d(kl, { children: u }),
                  Object.values($e).map((I, N) => {
                    const T = U[I];
                    if (T.length !== 0)
                      return /* @__PURE__ */ M(uw, { children: [
                        /* @__PURE__ */ d(
                          No,
                          {
                            heading: Hw(I, f, h, g, b),
                            children: T.map(($) => /* @__PURE__ */ d(
                              Gw,
                              {
                                bookId: $,
                                isSelected: e.includes($),
                                onSelect: () => F($),
                                onMouseDown: (L) => K(L, $),
                                section: ds($),
                                showCheck: !0,
                                localizedBookNames: o,
                                commandValue: su($, o),
                                className: "tw-flex tw-items-center"
                              },
                              $
                            ))
                          }
                        ),
                        N < Object.values($e).length - 1 && /* @__PURE__ */ d($w, {})
                      ] }, I);
                  })
                ] })
              ]
            }
          ) })
        ]
      }
    ),
    e.length > 0 && /* @__PURE__ */ M("div", { className: "tw-mt-2 tw-flex tw-flex-wrap tw-gap-1", children: [
      e.slice(
        0,
        e.length === Kc ? Kc : cw
      ).map((I) => /* @__PURE__ */ d(ys, { className: "hover:tw-bg-secondary", variant: "secondary", children: li(I, o) }, I)),
      e.length > Kc && /* @__PURE__ */ d(
        ys,
        {
          className: "hover:tw-bg-secondary",
          variant: "secondary",
          children: `+${e.length - cw} ${p}`
        }
      )
    ] })
  ] });
}
const iO = Object.freeze([
  "%webView_scope_selector_selected_text%",
  "%webView_scope_selector_current_verse%",
  "%webView_scope_selector_current_chapter%",
  "%webView_scope_selector_current_book%",
  "%webView_scope_selector_choose_books%",
  "%webView_scope_selector_scope%",
  "%webView_scope_selector_select_books%",
  "%webView_book_selector_books_selected%",
  "%webView_book_selector_select_books%",
  "%webView_book_selector_search_books%",
  "%webView_book_selector_select_all%",
  "%webView_book_selector_clear_all%",
  "%webView_book_selector_no_book_found%",
  "%webView_book_selector_more%",
  "%scripture_section_ot_long%",
  "%scripture_section_ot_short%",
  "%scripture_section_nt_long%",
  "%scripture_section_nt_short%",
  "%scripture_section_dc_long%",
  "%scripture_section_dc_short%",
  "%scripture_section_extra_long%",
  "%scripture_section_extra_short%"
]), mo = (t, e) => t[e] ?? e;
function sO({
  scope: t,
  availableScopes: e,
  onScopeChange: n,
  availableBookInfo: r,
  selectedBookIds: o,
  onSelectedBookIdsChange: i,
  localizedStrings: s,
  localizedBookNames: a,
  id: l
}) {
  const c = mo(
    s,
    "%webView_scope_selector_selected_text%"
  ), u = mo(
    s,
    "%webView_scope_selector_current_verse%"
  ), p = mo(
    s,
    "%webView_scope_selector_current_chapter%"
  ), f = mo(s, "%webView_scope_selector_current_book%"), h = mo(s, "%webView_scope_selector_choose_books%"), g = mo(s, "%webView_scope_selector_scope%"), b = mo(s, "%webView_scope_selector_select_books%"), _ = [
    { value: "selectedText", label: c, id: "scope-selected-text" },
    { value: "verse", label: u, id: "scope-verse" },
    { value: "chapter", label: p, id: "scope-chapter" },
    { value: "book", label: f, id: "scope-book" },
    { value: "selectedBooks", label: h, id: "scope-selected" }
  ], x = e ? _.filter((y) => e.includes(y.value)) : _;
  return /* @__PURE__ */ M("div", { id: l, className: "tw-grid tw-gap-4", children: [
    /* @__PURE__ */ M("div", { className: "tw-grid tw-gap-2", children: [
      /* @__PURE__ */ d(Lt, { children: g }),
      /* @__PURE__ */ d(
        hd,
        {
          value: t,
          onValueChange: n,
          className: "tw-flex tw-flex-col tw-space-y-1",
          children: x.map(({ value: y, label: A, id: P }) => /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center", children: [
            /* @__PURE__ */ d(Ka, { className: "tw-me-2", value: y, id: P }),
            /* @__PURE__ */ d(Lt, { htmlFor: P, children: A })
          ] }, P))
        }
      )
    ] }),
    t === "selectedBooks" && /* @__PURE__ */ M("div", { className: "tw-grid tw-gap-2", children: [
      /* @__PURE__ */ d(Lt, { children: b }),
      /* @__PURE__ */ d(
        _M,
        {
          availableBookInfo: r,
          selectedBookIds: o,
          onChangeSelectedBookIds: i,
          localizedStrings: s,
          localizedBookNames: a
        }
      )
    ] })
  ] });
}
const Wc = {
  [Ke("undefined")]: "Ã˜",
  [Ke(0)]: "A",
  [Ke(1)]: "B",
  [Ke(2)]: "C",
  [Ke(3)]: "D",
  [Ke(4)]: "E",
  [Ke(5)]: "F",
  [Ke(6)]: "G",
  [Ke(7)]: "H",
  [Ke(8)]: "I",
  [Ke(9)]: "J",
  [Ke(10)]: "K",
  [Ke(11)]: "L",
  [Ke(12)]: "M",
  [Ke(13)]: "N",
  [Ke(14)]: "O",
  [Ke(15)]: "P",
  [Ke(16)]: "Q",
  [Ke(17)]: "R",
  [Ke(18)]: "S",
  [Ke(19)]: "T",
  [Ke(20)]: "U",
  [Ke(21)]: "V",
  [Ke(22)]: "W",
  [Ke(23)]: "X",
  [Ke(24)]: "Y",
  [Ke(25)]: "Z"
};
function aO({
  availableScrollGroupIds: t,
  scrollGroupId: e,
  onChangeScrollGroupId: n,
  localizedStrings: r = {},
  size: o = "sm",
  className: i,
  id: s
}) {
  const a = {
    ...Wc,
    ...Object.fromEntries(
      Object.entries(r).map(
        ([c, u]) => [
          c,
          c === u && c in Wc ? Wc[c] : u
        ]
      )
    )
  }, l = Bt();
  return /* @__PURE__ */ M(
    wi,
    {
      value: `${e}`,
      onValueChange: (c) => n(
        c === "undefined" ? void 0 : parseInt(c, 10)
      ),
      children: [
        /* @__PURE__ */ d(Ao, { size: o, className: z("pr-twp tw-w-auto", i), children: /* @__PURE__ */ d(
          gi,
          {
            placeholder: a[Ke(e)] ?? e
          }
        ) }),
        /* @__PURE__ */ d(
          So,
          {
            id: s,
            align: l === "rtl" ? "end" : "start",
            style: { zIndex: 250 },
            children: t.map((c) => /* @__PURE__ */ d(Dn, { value: `${c}`, children: a[Ke(c)] }, `${c}`))
          }
        )
      ]
    }
  );
}
function lO({ children: t }) {
  return /* @__PURE__ */ d("div", { className: "pr-twp tw-grid", children: t });
}
function cO({
  primary: t,
  secondary: e,
  children: n,
  isLoading: r = !1,
  loadingMessage: o
}) {
  return /* @__PURE__ */ M("div", { className: "tw-flex tw-items-center tw-justify-between tw-space-x-4 tw-py-2", children: [
    /* @__PURE__ */ M("div", { children: [
      /* @__PURE__ */ d("p", { className: "tw-text-sm tw-font-medium tw-leading-none", children: t }),
      /* @__PURE__ */ d("p", { className: "tw-whitespace-normal tw-break-words tw-text-sm tw-text-muted-foreground", children: e })
    ] }),
    r ? /* @__PURE__ */ d("p", { className: "tw-text-sm tw-text-muted-foreground", children: o }) : /* @__PURE__ */ d("div", { children: n })
  ] });
}
function uO({
  primary: t,
  secondary: e,
  includeSeparator: n = !1
}) {
  return /* @__PURE__ */ M("div", { className: "tw-space-y-4 tw-py-2", children: [
    /* @__PURE__ */ M("div", { children: [
      /* @__PURE__ */ d("h3", { className: "tw-text-lg tw-font-medium", children: t }),
      /* @__PURE__ */ d("p", { className: "tw-text-sm tw-text-muted-foreground", children: e })
    ] }),
    n ? /* @__PURE__ */ d(vs, {}) : ""
  ] });
}
function C0(t, e) {
  var n;
  return (n = Object.entries(t).find(
    ([, r]) => "menuItem" in r && r.menuItem === e
  )) == null ? void 0 : n[0];
}
function hl({ icon: t, menuLabel: e, leading: n }) {
  return t ? /* @__PURE__ */ d(
    "img",
    {
      className: z("tw-max-h-5 tw-max-w-5", n ? "tw-me-2" : "tw-ms-2"),
      src: t,
      alt: `${n ? "Leading" : "Trailing"} icon for ${e}`
    }
  ) : void 0;
}
const E0 = (t, e, n, r) => n ? Object.entries(t).filter(
  ([i, s]) => "column" in s && s.column === n || i === n
).sort(([, i], [, s]) => i.order - s.order).flatMap(([i]) => e.filter((a) => a.group === i).sort((a, l) => a.order - l.order).map((a) => /* @__PURE__ */ M(md, { children: [
  /* @__PURE__ */ d(bd, { asChild: !0, children: "command" in a ? /* @__PURE__ */ M(
    Cg,
    {
      onClick: () => {
        r(a);
      },
      children: [
        a.iconPathBefore && /* @__PURE__ */ d(hl, { icon: a.iconPathBefore, menuLabel: a.label, leading: !0 }),
        a.label,
        a.iconPathAfter && /* @__PURE__ */ d(hl, { icon: a.iconPathAfter, menuLabel: a.label })
      ]
    },
    `dropdown-menu-item-${a.label}-${a.command}`
  ) : /* @__PURE__ */ M(Dx, { children: [
    /* @__PURE__ */ d(xg, { children: a.label }),
    /* @__PURE__ */ d(Sx, { children: /* @__PURE__ */ d(_g, { children: E0(
      t,
      e,
      C0(t, a.id),
      r
    ) }) })
  ] }, `dropdown-menu-sub-${a.label}-${a.id}`) }),
  a.tooltip && /* @__PURE__ */ d(Tl, { children: a.tooltip })
] }, `tooltip-${a.label}-${"command" in a ? a.command : a.id}`))) : void 0;
function Xu({
  onSelectMenuItem: t,
  menuData: e,
  tabLabel: n,
  icon: r,
  className: o,
  variant: i,
  buttonVariant: s = "ghost",
  id: a
}) {
  return /* @__PURE__ */ M(Dl, { variant: i, children: [
    /* @__PURE__ */ d(Nd, { "aria-label": n, className: o, asChild: !0, id: a, children: /* @__PURE__ */ d(Ne, { variant: s, size: "icon", children: r ?? /* @__PURE__ */ d(yv, {}) }) }),
    /* @__PURE__ */ d(Ks, { align: "start", className: "tw-z-[250]", children: Object.entries(e.columns).filter(([, l]) => typeof l == "object").sort(([, l], [, c]) => typeof l == "boolean" || typeof c == "boolean" ? 0 : l.order - c.order).map(([l], c, u) => /* @__PURE__ */ M(uw, { children: [
      /* @__PURE__ */ d(yg, { children: /* @__PURE__ */ d(Nl, { children: E0(e.groups, e.items, l, t) }) }),
      c < u.length - 1 && /* @__PURE__ */ d(Ml, {})
    ] }, l)) })
  ] });
}
const k0 = X.forwardRef(
  ({ id: t, className: e, children: n }, r) => /* @__PURE__ */ d(
    "div",
    {
      ref: r,
      className: `tw-sticky tw-top-0 tw-box-border tw-flex tw-h-14 tw-flex-row tw-items-center tw-justify-between tw-gap-2 tw-overflow-clip tw-px-4 tw-py-2 tw-text-foreground tw-@container/toolbar ${e}`,
      id: t,
      children: n
    }
  )
);
function dO({
  onSelectProjectMenuItem: t,
  onSelectViewInfoMenuItem: e,
  projectMenuData: n,
  tabViewMenuData: r,
  id: o,
  className: i,
  startAreaChildren: s,
  centerAreaChildren: a,
  endAreaChildren: l,
  menuButtonIcon: c
}) {
  return /* @__PURE__ */ M(k0, { className: `tw-w-full tw-border ${i}`, id: o, children: [
    n && /* @__PURE__ */ d(
      Xu,
      {
        onSelectMenuItem: t,
        menuData: n,
        tabLabel: "Project",
        icon: c ?? /* @__PURE__ */ d(xv, {}),
        buttonVariant: "ghost"
      }
    ),
    s && /* @__PURE__ */ d("div", { className: "tw-flex tw-h-full tw-shrink tw-grow-[2] tw-flex-row tw-flex-wrap tw-items-start tw-gap-2 tw-overflow-clip tw-@container/tab-toolbar-start", children: s }),
    a && /* @__PURE__ */ d("div", { className: "tw-flex tw-h-full tw-shrink tw-basis-0 tw-flex-row tw-flex-wrap tw-items-start tw-justify-center tw-gap-2 tw-overflow-clip tw-@container/tab-toolbar-center @sm:tw-grow @sm:tw-basis-auto", children: a }),
    /* @__PURE__ */ M("div", { className: "tw-flex tw-h-full tw-shrink tw-grow-[2] tw-flex-row-reverse tw-flex-wrap tw-items-start tw-gap-2 tw-overflow-clip tw-@container/tab-toolbar-end", children: [
      r && /* @__PURE__ */ d(
        Xu,
        {
          onSelectMenuItem: e,
          menuData: r,
          tabLabel: "View Info",
          icon: /* @__PURE__ */ d(_v, {}),
          className: "tw-h-full"
        }
      ),
      l
    ] })
  ] });
}
function pO({
  onSelectProjectMenuItem: t,
  projectMenuData: e,
  id: n,
  className: r,
  menuButtonIcon: o
}) {
  return /* @__PURE__ */ d(k0, { className: "tw-pointer-events-none", id: n, children: e && /* @__PURE__ */ d(
    Xu,
    {
      onSelectMenuItem: t,
      menuData: e,
      tabLabel: "Project",
      icon: o,
      className: `tw-pointer-events-auto tw-shadow-lg ${r}`,
      buttonVariant: "outline"
    }
  ) });
}
const N0 = X.forwardRef(({ className: t, ...e }, n) => {
  const r = Bt();
  return /* @__PURE__ */ d(
    gn.Root,
    {
      orientation: "vertical",
      ref: n,
      className: z("tw-flex tw-gap-1 tw-rounded-md tw-text-muted-foreground", t),
      ...e,
      dir: r
    }
  );
});
N0.displayName = gn.List.displayName;
const T0 = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  gn.List,
  {
    ref: n,
    className: z(
      "tw-flex-fit tw-mlk-items-center tw-w-[124px] tw-justify-center tw-rounded-md tw-bg-muted tw-p-1 tw-text-muted-foreground",
      t
    ),
    ...e
  }
));
T0.displayName = gn.List.displayName;
const CM = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  gn.Trigger,
  {
    ref: n,
    ...e,
    className: z(
      "overflow-clip tw-inline-flex tw-w-[116px] tw-cursor-pointer tw-items-center tw-justify-center tw-break-words tw-rounded-sm tw-border-0 tw-bg-muted tw-px-3 tw-py-1.5 tw-text-sm tw-font-medium tw-text-inherit tw-ring-offset-background tw-transition-all hover:tw-text-foreground focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-pointer-events-none disabled:tw-opacity-50 data-[state=active]:tw-bg-background data-[state=active]:tw-text-foreground data-[state=active]:tw-shadow-sm",
      t
    )
  }
)), A0 = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  gn.Content,
  {
    ref: n,
    className: z(
      // Removed tw-mt-2 because Sebastian said so
      "tw-ms-5 tw-flex-grow tw-text-foreground tw-ring-offset-background focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2",
      t
    ),
    ...e
  }
));
A0.displayName = gn.Content.displayName;
function fO({
  tabList: t,
  searchValue: e,
  onSearch: n,
  searchPlaceholder: r,
  headerTitle: o,
  searchClassName: i,
  id: s
}) {
  return /* @__PURE__ */ M("div", { id: s, className: "pr-twp", children: [
    /* @__PURE__ */ M("div", { className: "tw-sticky tw-top-0 tw-space-y-2 tw-pb-2", children: [
      o ? /* @__PURE__ */ d("h1", { children: o }) : "",
      /* @__PURE__ */ d(
        xp,
        {
          className: i,
          value: e,
          onSearch: n,
          placeholder: r
        }
      )
    ] }),
    /* @__PURE__ */ M(N0, { children: [
      /* @__PURE__ */ d(T0, { children: t.map((a) => /* @__PURE__ */ d(CM, { value: a.value, children: a.value }, a.key)) }),
      t.map((a) => /* @__PURE__ */ d(A0, { value: a.value, children: a.content }, a.key))
    ] })
  ] });
}
function EM({ ...t }) {
  return /* @__PURE__ */ d(at.Menu, { ...t });
}
function kM({ ...t }) {
  return /* @__PURE__ */ d(at.Sub, { "data-slot": "menubar-sub", ...t });
}
const S0 = X.forwardRef(({ className: t, variant: e = "default", ...n }, r) => {
  const o = X.useMemo(
    () => ({
      variant: e
    }),
    [e]
  );
  return /* @__PURE__ */ d(kd.Provider, { value: o, children: /* @__PURE__ */ d(
    at.Root,
    {
      ref: r,
      className: z(
        "tw-flex tw-h-10 tw-items-center tw-space-x-1 tw-rounded-md tw-border tw-bg-background tw-p-1",
        t
      ),
      ...n
    }
  ) });
});
S0.displayName = at.Root.displayName;
const D0 = X.forwardRef(({ className: t, ...e }, n) => {
  const r = Qn();
  return /* @__PURE__ */ d(
    at.Trigger,
    {
      ref: n,
      className: z(
        "tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-3 tw-py-1.5 tw-text-sm tw-font-medium tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[state=open]:tw-bg-accent data-[state=open]:tw-text-accent-foreground",
        // CUSTOM
        "pr-twp",
        Rr({ variant: r.variant, className: t })
        // CUSTOM use context to add variants
      ),
      ...e
    }
  );
});
D0.displayName = at.Trigger.displayName;
const M0 = X.forwardRef(({ className: t, inset: e, children: n, ...r }, o) => {
  const i = Qn();
  return /* @__PURE__ */ M(
    at.SubTrigger,
    {
      ref: o,
      className: z(
        "tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[state=open]:tw-bg-accent data-[state=open]:tw-text-accent-foreground",
        e && "tw-pl-8",
        Rr({ variant: i.variant, className: t }),
        // CUSTOM use context to add variants
        t
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ d(pi, { className: "tw-ml-auto tw-h-4 tw-w-4" })
      ]
    }
  );
});
M0.displayName = at.SubTrigger.displayName;
const O0 = X.forwardRef(({ className: t, ...e }, n) => {
  const r = Qn();
  return /* @__PURE__ */ d(
    at.SubContent,
    {
      ref: n,
      className: z(
        "tw-z-50 tw-min-w-[8rem] tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-p-1 tw-text-popover-foreground data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
        // CUSTOM use context to add variants
        {
          "tw-bg-popover": r.variant === "muted"
        },
        t
      ),
      ...e
    }
  );
});
O0.displayName = at.SubContent.displayName;
const R0 = X.forwardRef(({ className: t, align: e = "start", alignOffset: n = -4, sideOffset: r = 8, ...o }, i) => {
  const s = Qn();
  return /* @__PURE__ */ d(at.Portal, { children: /* @__PURE__ */ d(
    at.Content,
    {
      ref: i,
      align: e,
      alignOffset: n,
      sideOffset: r,
      className: z(
        "tw-z-50 tw-min-w-[12rem] tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-p-1 tw-text-popover-foreground tw-shadow-md data-[state=open]:tw-animate-in data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
        // CUSTOM reset styles so that only shadcn styles are applied
        "pr-twp",
        // CUSTOM use context to add variants
        {
          "tw-bg-popover": s.variant === "muted"
        },
        t
      ),
      ...o
    }
  ) });
});
R0.displayName = at.Content.displayName;
const I0 = X.forwardRef(({ className: t, inset: e, ...n }, r) => {
  const o = Qn();
  return /* @__PURE__ */ d(
    at.Item,
    {
      ref: r,
      className: z(
        "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
        e && "tw-pl-8",
        Rr({ variant: o.variant, className: t }),
        // CUSTOM use context to add variants
        t
      ),
      ...n
    }
  );
});
I0.displayName = at.Item.displayName;
const NM = X.forwardRef(({ className: t, children: e, checked: n, ...r }, o) => {
  const i = Qn();
  return /* @__PURE__ */ M(
    at.CheckboxItem,
    {
      ref: o,
      className: z(
        "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pl-8 tw-pr-2 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
        Rr({ variant: i.variant, className: t }),
        // CUSTOM use context to add variants
        t
      ),
      checked: n,
      ...r,
      children: [
        /* @__PURE__ */ d("span", { className: "tw-absolute tw-left-2 tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center", children: /* @__PURE__ */ d(at.ItemIndicator, { children: /* @__PURE__ */ d(br, { className: "tw-h-4 tw-w-4" }) }) }),
        e
      ]
    }
  );
});
NM.displayName = at.CheckboxItem.displayName;
const TM = X.forwardRef(({ className: t, children: e, ...n }, r) => {
  const o = Qn();
  return /* @__PURE__ */ M(
    at.RadioItem,
    {
      ref: r,
      className: z(
        "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pl-8 tw-pr-2 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
        Rr({ variant: o.variant, className: t }),
        // CUSTOM use context to add variants
        t
      ),
      ...n,
      children: [
        /* @__PURE__ */ d("span", { className: "tw-absolute tw-left-2 tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center", children: /* @__PURE__ */ d(at.ItemIndicator, { children: /* @__PURE__ */ d(gl, { className: "tw-h-2 tw-w-2 tw-fill-current" }) }) }),
        e
      ]
    }
  );
});
TM.displayName = at.RadioItem.displayName;
const AM = X.forwardRef(({ className: t, inset: e, ...n }, r) => /* @__PURE__ */ d(
  at.Label,
  {
    ref: r,
    className: z("tw-px-2 tw-py-1.5 tw-text-sm tw-font-semibold", e && "tw-pl-8", t),
    ...n
  }
));
AM.displayName = at.Label.displayName;
const L0 = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  at.Separator,
  {
    ref: n,
    className: z("tw--mx-1 tw-my-1 tw-h-px tw-bg-muted", t),
    ...e
  }
));
L0.displayName = at.Separator.displayName;
const rs = (t, e) => {
  setTimeout(() => {
    e.forEach((n) => {
      var r;
      (r = t.current) == null || r.dispatchEvent(new KeyboardEvent("keydown", n));
    });
  }, 0);
}, P0 = (t, e, n, r) => {
  if (!n) return;
  const o = Object.entries(t).filter(
    ([i, s]) => "column" in s && s.column === n || i === n
  ).sort(([, i], [, s]) => i.order - s.order);
  return o.flatMap(([i], s) => {
    const a = e.filter((c) => c.group === i).sort((c, u) => c.order - u.order).map((c) => /* @__PURE__ */ M(md, { children: [
      /* @__PURE__ */ d(bd, { asChild: !0, children: "command" in c ? /* @__PURE__ */ M(
        I0,
        {
          onClick: () => {
            r(c);
          },
          children: [
            c.iconPathBefore && /* @__PURE__ */ d(hl, { icon: c.iconPathBefore, menuLabel: c.label, leading: !0 }),
            c.label,
            c.iconPathAfter && /* @__PURE__ */ d(hl, { icon: c.iconPathAfter, menuLabel: c.label })
          ]
        },
        `menubar-item-${c.label}-${c.command}`
      ) : /* @__PURE__ */ M(kM, { children: [
        /* @__PURE__ */ d(M0, { children: c.label }),
        /* @__PURE__ */ d(O0, { children: P0(
          t,
          e,
          C0(t, c.id),
          r
        ) })
      ] }, `menubar-sub-${c.label}-${c.id}`) }),
      c.tooltip && /* @__PURE__ */ d(Tl, { children: c.tooltip })
    ] }, `tooltip-${c.label}-${"command" in c ? c.command : c.id}`)), l = [...a];
    return a.length > 0 && s < o.length - 1 && l.push(/* @__PURE__ */ d(L0, {}, `separator-${i}`)), l;
  });
};
function SM({
  menuData: t,
  onSelectMenuItem: e,
  onOpenChange: n,
  variant: r
}) {
  const o = he(void 0), i = he(void 0), s = he(void 0), a = he(void 0), l = he(void 0), c = (u) => {
    switch (u) {
      case "platform.app":
        return i;
      case "platform.window":
        return s;
      case "platform.layout":
        return a;
      case "platform.help":
        return l;
      default:
        return;
    }
  };
  if (Ry(["alt", "alt+p", "alt+l", "alt+n", "alt+h"], (u, p) => {
    var g, b, _, x;
    u.preventDefault();
    const f = { key: "Escape", code: "Escape", keyCode: 27, bubbles: !0 }, h = { key: " ", code: "Space", keyCode: 32, bubbles: !0 };
    switch (p.hotkey) {
      case "alt":
        rs(i, [f]);
        break;
      case "alt+p":
        (g = i.current) == null || g.focus(), rs(i, [f, h]);
        break;
      case "alt+l":
        (b = s.current) == null || b.focus(), rs(s, [f, h]);
        break;
      case "alt+n":
        (_ = a.current) == null || _.focus(), rs(a, [f, h]);
        break;
      case "alt+h":
        (x = l.current) == null || x.focus(), rs(l, [f, h]);
        break;
    }
  }), ie(() => {
    if (!n || !o.current) return;
    const u = new MutationObserver((h) => {
      h.forEach((g) => {
        if (g.attributeName === "data-state" && g.target instanceof HTMLElement) {
          const b = g.target.getAttribute("data-state");
          n(b === "open");
        }
      });
    });
    return o.current.querySelectorAll("[data-state]").forEach((h) => {
      u.observe(h, { attributes: !0 });
    }), () => u.disconnect();
  }, [n]), !!t)
    return /* @__PURE__ */ d(S0, { ref: o, className: "pr-twp tw-border-0 tw-bg-transparent", variant: r, children: Object.entries(t.columns).filter(([, u]) => typeof u == "object").sort(([, u], [, p]) => typeof u == "boolean" || typeof p == "boolean" ? 0 : u.order - p.order).map(([u, p]) => /* @__PURE__ */ M(EM, { children: [
      /* @__PURE__ */ d(D0, { ref: c(u), children: typeof p == "object" && "label" in p && p.label }),
      /* @__PURE__ */ d(
        R0,
        {
          className: "tw-z-[250]",
          children: /* @__PURE__ */ d(Nl, { children: P0(t.groups, t.items, u, e) })
        }
      )
    ] }, u)) });
}
function hO(t) {
  switch (t) {
    case void 0:
      return;
    case "darwin":
      return "tw-ps-[85px]";
    default:
      return "tw-pe-[calc(138px+1rem)]";
  }
}
function wO({
  menuData: t,
  onOpenChange: e,
  onSelectMenuItem: n,
  className: r,
  id: o,
  children: i,
  appMenuAreaChildren: s,
  configAreaChildren: a,
  shouldUseAsAppDragArea: l,
  menubarVariant: c = "default"
}) {
  const u = he(void 0);
  return /* @__PURE__ */ d(
    "div",
    {
      className: z("tw-border tw-px-4 tw-text-foreground", r),
      ref: u,
      style: { position: "relative" },
      id: o,
      children: /* @__PURE__ */ M(
        "div",
        {
          className: "tw-flex tw-h-full tw-w-full tw-justify-between tw-overflow-hidden",
          style: l ? { WebkitAppRegion: "drag" } : void 0,
          children: [
            /* @__PURE__ */ d("div", { className: "tw-flex tw-grow tw-basis-0", children: /* @__PURE__ */ M(
              "div",
              {
                className: "tw-flex tw-items-center tw-gap-2",
                style: l ? { WebkitAppRegion: "no-drag" } : void 0,
                children: [
                  s,
                  t && /* @__PURE__ */ d(
                    SM,
                    {
                      menuData: t,
                      onOpenChange: e,
                      onSelectMenuItem: n,
                      variant: c
                    }
                  )
                ]
              }
            ) }),
            /* @__PURE__ */ d(
              "div",
              {
                className: "tw-flex tw-items-center tw-gap-2 tw-px-2",
                style: l ? { WebkitAppRegion: "no-drag" } : void 0,
                children: i
              }
            ),
            /* @__PURE__ */ d("div", { className: "tw-flex tw-min-w-0 tw-grow tw-basis-0 tw-justify-end", children: /* @__PURE__ */ d(
              "div",
              {
                className: "tw-flex tw-min-w-0 tw-items-center tw-gap-2 tw-pe-1",
                style: l ? { WebkitAppRegion: "no-drag" } : void 0,
                children: a
              }
            ) })
          ]
        }
      )
    }
  );
}
const DM = (t, e) => t[e] ?? e;
function gO({
  knownUiLanguages: t,
  primaryLanguage: e = "en",
  fallbackLanguages: n = [],
  onLanguagesChange: r,
  onPrimaryLanguageChange: o,
  onFallbackLanguagesChange: i,
  localizedStrings: s,
  className: a,
  id: l
}) {
  const c = DM(
    s,
    "%settings_uiLanguageSelector_fallbackLanguages%"
  ), [u, p] = oe(!1), f = (g) => {
    o && o(g), r && r([g, ...n.filter((b) => b !== g)]), i && n.find((b) => b === g) && i([...n.filter((b) => b !== g)]), p(!1);
  }, h = (g, b) => {
    var x, y, A, P, V, O;
    const _ = b !== g ? ((y = (x = t[g]) == null ? void 0 : x.uiNames) == null ? void 0 : y[b]) ?? ((P = (A = t[g]) == null ? void 0 : A.uiNames) == null ? void 0 : P.en) : void 0;
    return _ ? `${(V = t[g]) == null ? void 0 : V.autonym} (${_})` : (O = t[g]) == null ? void 0 : O.autonym;
  };
  return /* @__PURE__ */ M("div", { id: l, className: z("pr-twp tw-max-w-sm", a), children: [
    /* @__PURE__ */ M(
      wi,
      {
        name: "uiLanguage",
        value: e,
        onValueChange: f,
        open: u,
        onOpenChange: (g) => p(g),
        children: [
          /* @__PURE__ */ d(Ao, { children: /* @__PURE__ */ d(gi, {}) }),
          /* @__PURE__ */ d(
            So,
            {
              className: "tw-z-[250]",
              children: Object.keys(t).map((g) => /* @__PURE__ */ d(Dn, { value: g, children: h(g, e) }, g))
            }
          )
        ]
      }
    ),
    e !== "en" && /* @__PURE__ */ d("div", { className: "tw-pt-3", children: /* @__PURE__ */ d(Lt, { className: "tw-font-normal tw-text-muted-foreground", children: ps(c, {
      fallbackLanguages: (n == null ? void 0 : n.length) > 0 ? n.map((g) => h(g, e)).join(", ") : t.en.autonym
    }) }) })
  ] });
}
function MM({ item: t, createLabel: e, createComplexLabel: n }) {
  return e ? /* @__PURE__ */ d(Lt, { children: e(t) }) : n ? /* @__PURE__ */ d(Lt, { children: n(t) }) : /* @__PURE__ */ d(Lt, { children: t });
}
function mO({
  id: t,
  className: e,
  listItems: n,
  selectedListItems: r,
  handleSelectListItem: o,
  createLabel: i,
  createComplexLabel: s
}) {
  return /* @__PURE__ */ d("div", { id: t, className: e, children: n.map((a) => /* @__PURE__ */ M("div", { className: "tw-m-2 tw-flex tw-items-center", children: [
    /* @__PURE__ */ d(
      yp,
      {
        className: "tw-me-2 tw-align-middle",
        checked: r.includes(a),
        onCheckedChange: (l) => o(a, l)
      }
    ),
    /* @__PURE__ */ d(
      MM,
      {
        item: a,
        createLabel: i,
        createComplexLabel: s
      }
    )
  ] }, a)) });
}
function bO({
  cardKey: t,
  isSelected: e,
  onSelect: n,
  isDenied: r,
  isHidden: o = !1,
  className: i,
  children: s,
  dropdownContent: a,
  additionalSelectedContent: l,
  accentColor: c
}) {
  return /* @__PURE__ */ M(
    "div",
    {
      hidden: o,
      onClick: n,
      onKeyDown: (p) => {
        (p.key === "Enter" || p.key === " ") && (p.preventDefault(), n());
      },
      role: "button",
      tabIndex: 0,
      "aria-pressed": e,
      className: z(
        "tw-relative tw-min-w-36 tw-rounded-xl tw-border tw-shadow-none hover:tw-bg-muted/50",
        { "tw-opacity-50 hover:tw-opacity-100": r && !e },
        { "tw-bg-accent": e },
        { "tw-bg-transparent": !e },
        i
      ),
      children: [
        /* @__PURE__ */ M("div", { className: "tw-flex tw-flex-col tw-gap-2 tw-p-4", children: [
          /* @__PURE__ */ M("div", { className: "tw-flex tw-justify-between tw-overflow-hidden", children: [
            /* @__PURE__ */ d("div", { className: "tw-min-w-0 tw-flex-1", children: s }),
            e && a && /* @__PURE__ */ M(Dl, { children: [
              /* @__PURE__ */ d(Nd, { className: z(c && "tw-me-1"), asChild: !0, children: /* @__PURE__ */ d(Ne, { className: "tw-m-1 tw-h-6 tw-w-6", variant: "ghost", size: "icon", children: /* @__PURE__ */ d(Cv, {}) }) }),
              /* @__PURE__ */ d(Ks, { align: "end", children: a })
            ] })
          ] }),
          e && l && /* @__PURE__ */ d("div", { className: "tw-w-fit tw-min-w-0 tw-max-w-full tw-overflow-hidden", children: l })
        ] }),
        c && /* @__PURE__ */ d(
          "div",
          {
            className: `tw-absolute tw-right-0 tw-top-0 tw-h-full tw-w-2 tw-rounded-r-xl ${c}`
          }
        )
      ]
    },
    t
  );
}
const OM = an(({ className: t, ...e }, n) => /* @__PURE__ */ d(Ev, { size: 35, className: z("tw-animate-spin", t), ...e, ref: n }));
OM.displayName = "Spinner";
function vO({
  id: t,
  isDisabled: e = !1,
  hasError: n = !1,
  isFullWidth: r = !1,
  helperText: o,
  label: i,
  placeholder: s,
  isRequired: a = !1,
  className: l,
  defaultValue: c,
  value: u,
  onChange: p,
  onFocus: f,
  onBlur: h
}) {
  return /* @__PURE__ */ M("div", { className: z("tw-inline-grid tw-items-center tw-gap-1.5", { "tw-w-full": r }), children: [
    /* @__PURE__ */ d(
      Lt,
      {
        htmlFor: t,
        className: z({
          "tw-text-red-600": n,
          "tw-hidden": !i
        }),
        children: `${i}${a ? "*" : ""}`
      }
    ),
    /* @__PURE__ */ d(
      oa,
      {
        id: t,
        disabled: e,
        placeholder: s,
        required: a,
        className: z(l, { "tw-border-red-600": n }),
        defaultValue: c,
        value: u,
        onChange: p,
        onFocus: f,
        onBlur: h
      }
    ),
    /* @__PURE__ */ d("p", { className: z({ "tw-hidden": !o }), children: o })
  ] });
}
const RM = eo(
  // CUSTOM: Copied all `svg` arbitrary selector variant classes as `img` variants so we can use
  // images (or svgs from file) as icons
  // Implemented by TJ Couch
  // Approved by Alex Mercado
  // 20 February 2025
  "tw-relative tw-w-full tw-rounded-lg tw-border tw-p-4 [&>svg~*]:tw-pl-7 [&>svg+div]:tw-translate-y-[-3px] [&>svg]:tw-absolute [&>svg]:tw-left-4 [&>svg]:tw-top-4 [&>svg]:tw-text-foreground [&>img~*]:tw-pl-7 [&>img+div]:tw-translate-y-[-3px] [&>img]:tw-absolute [&>img]:tw-left-4 [&>img]:tw-top-4 [&>img]:tw-text-foreground",
  {
    variants: {
      variant: {
        default: "tw-bg-background tw-text-foreground",
        destructive: (
          // CUSTOM: Copied all `svg` arbitrary selector variant classes as `img` variants so we can
          // use images (or svgs from file) as icons
          // Implemented by TJ Couch
          // Approved by Alex Mercado
          // 20 February 2025
          "tw-border-destructive/50 tw-text-destructive dark:tw-border-destructive [&>svg]:tw-text-destructive [&>img]:tw-text-destructive"
        )
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), IM = X.forwardRef(({ className: t, variant: e, ...n }, r) => /* @__PURE__ */ d(
  "div",
  {
    ref: r,
    role: "alert",
    className: z(
      // CUSTOM
      "pr-twp",
      RM({ variant: e }),
      t
    ),
    ...n
  }
));
IM.displayName = "Alert";
const LM = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ M(
    "h5",
    {
      ref: n,
      className: z("tw-mb-1 tw-font-medium tw-leading-none tw-tracking-tight", t),
      ...e,
      children: [
        e.children,
        " "
      ]
    }
  )
);
LM.displayName = "AlertTitle";
const PM = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d("div", { ref: n, className: z("tw-text-sm [&_p]:tw-leading-relaxed", t), ...e }));
PM.displayName = "AlertDescription";
const yO = lt.Root, xO = lt.Trigger, _O = lt.Group, CO = lt.Portal, EO = lt.Sub, kO = lt.RadioGroup, $M = X.forwardRef(({ className: t, inset: e, children: n, ...r }, o) => /* @__PURE__ */ M(
  lt.SubTrigger,
  {
    ref: o,
    className: z(
      "pr-twp tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[state=open]:tw-bg-accent data-[state=open]:tw-text-accent-foreground",
      e && "tw-pl-8",
      t
    ),
    ...r,
    children: [
      n,
      /* @__PURE__ */ d(pi, { className: "tw-ml-auto tw-h-4 tw-w-4" })
    ]
  }
));
$M.displayName = lt.SubTrigger.displayName;
const FM = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  lt.SubContent,
  {
    ref: n,
    className: z(
      "pr-twp tw-z-50 tw-min-w-[8rem] tw-origin-[--radix-context-menu-content-transform-origin] tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-p-1 tw-text-popover-foreground tw-shadow-md data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
      t
    ),
    ...e
  }
));
FM.displayName = lt.SubContent.displayName;
const BM = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(lt.Portal, { children: /* @__PURE__ */ d(
  lt.Content,
  {
    ref: n,
    className: z(
      "pr-twp tw-z-50 tw-max-h-[--radix-context-menu-content-available-height] tw-min-w-[8rem] tw-origin-[--radix-context-menu-content-transform-origin] tw-overflow-y-auto tw-overflow-x-hidden tw-rounded-md tw-border tw-bg-popover tw-p-1 tw-text-popover-foreground tw-shadow-md tw-animate-in tw-fade-in-80 data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
      t
    ),
    ...e
  }
) }));
BM.displayName = lt.Content.displayName;
const qM = X.forwardRef(({ className: t, inset: e, ...n }, r) => /* @__PURE__ */ d(
  lt.Item,
  {
    ref: r,
    className: z(
      "pr-twp tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
      e && "tw-pl-8",
      t
    ),
    ...n
  }
));
qM.displayName = lt.Item.displayName;
const jM = X.forwardRef(({ className: t, children: e, checked: n, ...r }, o) => /* @__PURE__ */ M(
  lt.CheckboxItem,
  {
    ref: o,
    className: z(
      "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pl-8 tw-pr-2 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
      t
    ),
    checked: n,
    ...r,
    children: [
      /* @__PURE__ */ d("span", { className: "tw-absolute tw-left-2 tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center", children: /* @__PURE__ */ d(lt.ItemIndicator, { children: /* @__PURE__ */ d(br, { className: "tw-h-4 tw-w-4" }) }) }),
      e
    ]
  }
));
jM.displayName = lt.CheckboxItem.displayName;
const UM = X.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ M(
  lt.RadioItem,
  {
    ref: r,
    className: z(
      "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pl-8 tw-pr-2 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
      t
    ),
    ...n,
    children: [
      /* @__PURE__ */ d("span", { className: "tw-absolute tw-left-2 tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center", children: /* @__PURE__ */ d(lt.ItemIndicator, { children: /* @__PURE__ */ d(gl, { className: "tw-h-2 tw-w-2 tw-fill-current" }) }) }),
      e
    ]
  }
));
UM.displayName = lt.RadioItem.displayName;
const VM = X.forwardRef(({ className: t, inset: e, ...n }, r) => /* @__PURE__ */ d(
  lt.Label,
  {
    ref: r,
    className: z(
      "tw-px-2 tw-py-1.5 tw-text-sm tw-font-semibold tw-text-foreground",
      e && "tw-pl-8",
      t
    ),
    ...n
  }
));
VM.displayName = lt.Label.displayName;
const HM = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  lt.Separator,
  {
    ref: n,
    className: z("tw--mx-1 tw-my-1 tw-h-px tw-bg-border", t),
    ...e
  }
));
HM.displayName = lt.Separator.displayName;
function zM({ className: t, ...e }) {
  return /* @__PURE__ */ d(
    "span",
    {
      className: z("tw-ml-auto tw-text-xs tw-tracking-widest tw-text-muted-foreground", t),
      ...e
    }
  );
}
zM.displayName = "ContextMenuShortcut";
const $0 = X.createContext({
  direction: "bottom"
});
function GM({
  shouldScaleBackground: t = !0,
  direction: e = "bottom",
  ...n
}) {
  const r = X.useMemo(() => ({ direction: e }), [e]);
  return /* @__PURE__ */ d($0.Provider, { value: r, children: /* @__PURE__ */ d(
    Yn.Root,
    {
      shouldScaleBackground: t,
      direction: e,
      ...n
    }
  ) });
}
GM.displayName = "Drawer";
const NO = Yn.Trigger, KM = Yn.Portal, TO = Yn.Close, F0 = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  Yn.Overlay,
  {
    ref: n,
    className: z("tw-fixed tw-inset-0 tw-z-50 tw-bg-black/80", t),
    ...e
  }
));
F0.displayName = Yn.Overlay.displayName;
const WM = X.forwardRef(({ className: t, children: e, hideDrawerHandle: n = !1, ...r }, o) => {
  const { direction: i = "bottom" } = X.useContext($0), s = {
    bottom: "tw-inset-x-0 tw-bottom-0 tw-mt-24 tw-rounded-t-[10px]",
    top: "tw-inset-x-0 tw-top-0 tw-mb-24 tw-rounded-b-[10px]",
    left: "tw-inset-y-0 tw-left-0 tw-mr-24 tw-rounded-r-[10px] tw-w-auto tw-max-w-sm",
    right: "tw-inset-y-0 tw-right-0 tw-ml-24 tw-rounded-l-[10px] tw-w-auto tw-max-w-sm"
  }, a = {
    bottom: "tw-mx-auto tw-mt-4 tw-h-2 tw-w-[100px] tw-rounded-full tw-bg-muted",
    top: "tw-mx-auto tw-mb-4 tw-h-2 tw-w-[100px] tw-rounded-full tw-bg-muted",
    left: "tw-my-auto tw-mr-4 tw-w-2 tw-h-[100px] tw-rounded-full tw-bg-muted",
    right: "tw-my-auto tw-ml-4 tw-w-2 tw-h-[100px] tw-rounded-full tw-bg-muted"
  };
  return /* @__PURE__ */ M(KM, { children: [
    /* @__PURE__ */ d(F0, {}),
    /* @__PURE__ */ M(
      Yn.Content,
      {
        ref: o,
        className: z(
          // CUSTOM: Change Tailwind CSS classes for styling
          // Removed tw-inset-x-0 tw-bottom-0 tw-mt-24 tw-rounded-t-[10px] tw-flex-col
          "pr-twp tw-fixed tw-z-50 tw-flex tw-h-auto tw-border tw-bg-background",
          i === "bottom" || i === "top" ? "tw-flex-col" : "tw-flex-row",
          s[i],
          t
        ),
        ...r,
        children: [
          !n && (i === "bottom" || i === "right") && /* @__PURE__ */ d("div", { className: a[i] }),
          /* @__PURE__ */ d("div", { className: "tw-flex tw-flex-col", children: e }),
          !n && (i === "top" || i === "left") && /* @__PURE__ */ d("div", { className: a[i] })
        ]
      }
    )
  ] });
});
WM.displayName = "DrawerContent";
function JM({ className: t, ...e }) {
  return /* @__PURE__ */ d(
    "div",
    {
      className: z("tw-grid tw-gap-1.5 tw-p-4 tw-text-center sm:tw-text-left", t),
      ...e
    }
  );
}
JM.displayName = "DrawerHeader";
function XM({ className: t, ...e }) {
  return /* @__PURE__ */ d("div", { className: z("tw-mt-auto tw-flex tw-flex-col tw-gap-2 tw-p-4", t), ...e });
}
XM.displayName = "DrawerFooter";
const YM = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  Yn.Title,
  {
    ref: n,
    className: z("tw-text-lg tw-font-semibold tw-leading-none tw-tracking-tight", t),
    ...e
  }
));
YM.displayName = Yn.Title.displayName;
const QM = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  Yn.Description,
  {
    ref: n,
    className: z("tw-text-sm tw-text-muted-foreground", t),
    ...e
  }
));
QM.displayName = Yn.Description.displayName;
const ZM = X.forwardRef(({ className: t, value: e, ...n }, r) => /* @__PURE__ */ d(
  ou.Root,
  {
    ref: r,
    className: z(
      "pr-twp tw-relative tw-h-4 tw-w-full tw-overflow-hidden tw-rounded-full tw-bg-secondary",
      t
    ),
    ...n,
    children: /* @__PURE__ */ d(
      ou.Indicator,
      {
        className: "tw-h-full tw-w-full tw-flex-1 tw-bg-primary tw-transition-all",
        style: { transform: `translateX(-${100 - (e || 0)}%)` }
      }
    )
  }
));
ZM.displayName = ou.Root.displayName;
function AO({
  className: t,
  ...e
}) {
  return /* @__PURE__ */ d(
    ld.PanelGroup,
    {
      className: z(
        "tw-flex tw-h-full tw-w-full data-[panel-group-direction=vertical]:tw-flex-col",
        t
      ),
      ...e
    }
  );
}
const SO = ld.Panel;
function DO({
  withHandle: t,
  className: e,
  ...n
}) {
  return /* @__PURE__ */ d(
    ld.PanelResizeHandle,
    {
      className: z(
        "tw-relative tw-flex tw-w-px tw-items-center tw-justify-center tw-bg-border after:tw-absolute after:tw-inset-y-0 after:tw-left-1/2 after:tw-w-1 after:tw--translate-x-1/2 focus-visible:tw-outline-none focus-visible:tw-ring-1 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-1 data-[panel-group-direction=vertical]:tw-h-px data-[panel-group-direction=vertical]:tw-w-full data-[panel-group-direction=vertical]:after:tw-left-0 data-[panel-group-direction=vertical]:after:tw-h-1 data-[panel-group-direction=vertical]:after:tw-w-full data-[panel-group-direction=vertical]:after:tw--translate-y-1/2 data-[panel-group-direction=vertical]:after:tw-translate-x-0 [&[data-panel-group-direction=vertical]>div]:tw-rotate-90",
        e
      ),
      ...n,
      children: t && /* @__PURE__ */ d("div", { className: "tw-z-10 tw-flex tw-h-4 tw-w-3 tw-items-center tw-justify-center tw-rounded-sm tw-border tw-bg-border", children: /* @__PURE__ */ d(kv, { className: "tw-h-2.5 tw-w-2.5" }) })
    }
  );
}
function MO({ ...t }) {
  return /* @__PURE__ */ d(
    Iy,
    {
      className: "tw-toaster tw-group",
      toastOptions: {
        classNames: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      },
      ...t
    }
  );
}
const e5 = X.forwardRef(({ className: t, ...e }, n) => {
  const r = Bt();
  return /* @__PURE__ */ M(
    ss.Root,
    {
      ref: n,
      className: z(
        "pr-twp tw-relative tw-flex tw-w-full tw-touch-none tw-select-none tw-items-center",
        t
      ),
      ...e,
      dir: r,
      children: [
        /* @__PURE__ */ d(ss.Track, { className: "tw-relative tw-h-2 tw-w-full tw-grow tw-overflow-hidden tw-rounded-full tw-bg-secondary", children: /* @__PURE__ */ d(ss.Range, { className: "tw-absolute tw-h-full tw-bg-primary" }) }),
        /* @__PURE__ */ d(ss.Thumb, { className: "tw-block tw-h-5 tw-w-5 tw-rounded-full tw-border-2 tw-border-primary tw-bg-background tw-ring-offset-background tw-transition-colors focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-pointer-events-none disabled:tw-opacity-50" })
      ]
    }
  );
});
e5.displayName = ss.Root.displayName;
const t5 = X.forwardRef(({ className: t, ...e }, n) => {
  const r = Bt();
  return /* @__PURE__ */ d(
    iu.Root,
    {
      className: z(
        "tw-peer pr-twp tw-inline-flex tw-h-6 tw-w-11 tw-shrink-0 tw-cursor-pointer tw-items-center tw-rounded-full tw-border-2 tw-border-transparent tw-transition-colors focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 focus-visible:tw-ring-offset-background disabled:tw-cursor-not-allowed disabled:tw-opacity-50 data-[state=checked]:tw-bg-primary data-[state=unchecked]:tw-bg-input",
        t
      ),
      ...e,
      ref: n,
      children: /* @__PURE__ */ d(
        iu.Thumb,
        {
          className: z(
            "pr-twp tw-pointer-events-none tw-block tw-h-5 tw-w-5 tw-rounded-full tw-bg-background tw-shadow-lg tw-ring-0 tw-transition-transform",
            {
              "data-[state=checked]:tw-translate-x-5 data-[state=unchecked]:tw-translate-x-0": r === "ltr"
            },
            {
              "data-[state=checked]:tw-translate-x-[-20px] data-[state=unchecked]:tw-translate-x-0": r === "rtl"
            }
          )
        }
      )
    }
  );
});
t5.displayName = iu.Root.displayName;
const OO = gn.Root, n5 = X.forwardRef(({ className: t, ...e }, n) => {
  const r = Bt();
  return /* @__PURE__ */ d(
    gn.List,
    {
      ref: n,
      className: z(
        "pr-twp tw-inline-flex tw-h-10 tw-items-center tw-justify-center tw-rounded-md tw-bg-muted tw-p-1 tw-text-muted-foreground",
        t
      ),
      ...e,
      dir: r
    }
  );
});
n5.displayName = gn.List.displayName;
const r5 = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  gn.Trigger,
  {
    ref: n,
    className: z(
      "pr-twp tw-inline-flex tw-items-center tw-justify-center tw-whitespace-nowrap tw-rounded-sm tw-px-3 tw-py-1.5 tw-text-sm tw-font-medium tw-ring-offset-background tw-transition-all hover:tw-text-foreground focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-pointer-events-none disabled:tw-opacity-50 data-[state=active]:tw-bg-background data-[state=active]:tw-text-foreground data-[state=active]:tw-shadow-sm",
      t
    ),
    ...e
  }
));
r5.displayName = gn.Trigger.displayName;
const o5 = X.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ d(
  gn.Content,
  {
    ref: n,
    className: z(
      "pr-twp tw-mt-2 tw-ring-offset-background focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2",
      t
    ),
    ...e
  }
));
o5.displayName = gn.Content.displayName;
const i5 = X.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ d(
    "textarea",
    {
      className: z(
        "pr-twp tw-flex tw-min-h-[80px] tw-w-full tw-rounded-md tw-border tw-border-input tw-bg-background tw-px-3 tw-py-2 tw-text-base tw-ring-offset-background placeholder:tw-text-muted-foreground focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-cursor-not-allowed disabled:tw-opacity-50 md:tw-text-sm",
        t
      ),
      ref: n,
      ...e
    }
  )
);
i5.displayName = "Textarea";
const RO = (t, e) => {
  ie(() => {
    if (!t) return () => {
    };
    const n = t(e);
    return () => {
      n();
    };
  }, [t, e]);
};
function s5(t) {
  return {
    preserveValue: !0,
    ...t
  };
}
const a5 = (t, e, n = {}) => {
  const r = he(e);
  r.current = e;
  const o = he(n);
  o.current = s5(o.current);
  const [i, s] = oe(() => r.current), [a, l] = oe(!0);
  return ie(() => {
    let c = !0;
    return l(!!t), (async () => {
      if (t) {
        const u = await t();
        c && (s(() => u), l(!1));
      }
    })(), () => {
      c = !1, o.current.preserveValue || s(() => r.current);
    };
  }, [t]), [i, a];
}, Jc = () => !1, IO = (t, e) => {
  const [n] = a5(
    ce(async () => {
      if (!t) return Jc;
      const r = await Promise.resolve(t(e));
      return async () => r();
    }, [e, t]),
    Jc,
    // We want the unsubscriber to return to default value immediately upon changing subscription
    // So the useEffect below will unsubscribe asap
    { preserveValue: !1 }
  );
  ie(() => () => {
    n !== Jc && n();
  }, [n]);
};
function l5(t, e = "top") {
  if (!t || typeof document > "u") return;
  const n = document.head || document.querySelector("head"), r = n.querySelector(":first-child"), o = document.createElement("style");
  o.appendChild(document.createTextNode(t)), e === "top" && r ? n.insertBefore(o, r) : n.appendChild(o);
}
l5(`*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}/*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*:where(.pr-twp,.pr-twp *),
::before:where(.pr-twp,.pr-twp *),
::after:where(.pr-twp,.pr-twp *) {
  box-sizing: border-box; /* 1 */
  border-width: 0; /* 2 */
  border-style: solid; /* 2 */
  border-color: #e5e7eb; /* 2 */
}

::before:where(.pr-twp,.pr-twp *),
::after:where(.pr-twp,.pr-twp *) {
  --tw-content: '';
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured \`sans\` font-family by default.
5. Use the user's configured \`sans\` font-feature-settings by default.
6. Use the user's configured \`sans\` font-variation-settings by default.
7. Disable tap highlights on iOS
*/

html:where(.pr-twp,.pr-twp *),
:host:where(.pr-twp,.pr-twp *) {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */ /* 3 */
  tab-size: 4; /* 3 */
  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
  font-feature-settings: normal; /* 5 */
  font-variation-settings: normal; /* 6 */
  -webkit-tap-highlight-color: transparent; /* 7 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from \`html\` so users can set them as a class directly on the \`html\` element.
*/

body:where(.pr-twp,.pr-twp *) {
  margin: 0; /* 1 */
  line-height: inherit; /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr:where(.pr-twp,.pr-twp *) {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]):where(.pr-twp,.pr-twp *) {
  text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1:where(.pr-twp,.pr-twp *),
h2:where(.pr-twp,.pr-twp *),
h3:where(.pr-twp,.pr-twp *),
h4:where(.pr-twp,.pr-twp *),
h5:where(.pr-twp,.pr-twp *),
h6:where(.pr-twp,.pr-twp *) {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a:where(.pr-twp,.pr-twp *) {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b:where(.pr-twp,.pr-twp *),
strong:where(.pr-twp,.pr-twp *) {
  font-weight: bolder;
}

/*
1. Use the user's configured \`mono\` font-family by default.
2. Use the user's configured \`mono\` font-feature-settings by default.
3. Use the user's configured \`mono\` font-variation-settings by default.
4. Correct the odd \`em\` font sizing in all browsers.
*/

code:where(.pr-twp,.pr-twp *),
kbd:where(.pr-twp,.pr-twp *),
samp:where(.pr-twp,.pr-twp *),
pre:where(.pr-twp,.pr-twp *) {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
  font-feature-settings: normal; /* 2 */
  font-variation-settings: normal; /* 3 */
  font-size: 1em; /* 4 */
}

/*
Add the correct font size in all browsers.
*/

small:where(.pr-twp,.pr-twp *) {
  font-size: 80%;
}

/*
Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/

sub:where(.pr-twp,.pr-twp *),
sup:where(.pr-twp,.pr-twp *) {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub:where(.pr-twp,.pr-twp *) {
  bottom: -0.25em;
}

sup:where(.pr-twp,.pr-twp *) {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table:where(.pr-twp,.pr-twp *) {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button:where(.pr-twp,.pr-twp *),
input:where(.pr-twp,.pr-twp *),
optgroup:where(.pr-twp,.pr-twp *),
select:where(.pr-twp,.pr-twp *),
textarea:where(.pr-twp,.pr-twp *) {
  font-family: inherit; /* 1 */
  font-feature-settings: inherit; /* 1 */
  font-variation-settings: inherit; /* 1 */
  font-size: 100%; /* 1 */
  font-weight: inherit; /* 1 */
  line-height: inherit; /* 1 */
  letter-spacing: inherit; /* 1 */
  color: inherit; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button:where(.pr-twp,.pr-twp *),
select:where(.pr-twp,.pr-twp *) {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button:where(.pr-twp,.pr-twp *),
input:where([type='button']):where(.pr-twp,.pr-twp *),
input:where([type='reset']):where(.pr-twp,.pr-twp *),
input:where([type='submit']):where(.pr-twp,.pr-twp *) {
  -webkit-appearance: button; /* 1 */
  background-color: transparent; /* 2 */
  background-image: none; /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring:where(.pr-twp,.pr-twp *) {
  outline: auto;
}

/*
Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid:where(.pr-twp,.pr-twp *) {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress:where(.pr-twp,.pr-twp *) {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button:where(.pr-twp,.pr-twp *),
::-webkit-outer-spin-button:where(.pr-twp,.pr-twp *) {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search']:where(.pr-twp,.pr-twp *) {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration:where(.pr-twp,.pr-twp *) {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to \`inherit\` in Safari.
*/

::-webkit-file-upload-button:where(.pr-twp,.pr-twp *) {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary:where(.pr-twp,.pr-twp *) {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote:where(.pr-twp,.pr-twp *),
dl:where(.pr-twp,.pr-twp *),
dd:where(.pr-twp,.pr-twp *),
h1:where(.pr-twp,.pr-twp *),
h2:where(.pr-twp,.pr-twp *),
h3:where(.pr-twp,.pr-twp *),
h4:where(.pr-twp,.pr-twp *),
h5:where(.pr-twp,.pr-twp *),
h6:where(.pr-twp,.pr-twp *),
hr:where(.pr-twp,.pr-twp *),
figure:where(.pr-twp,.pr-twp *),
p:where(.pr-twp,.pr-twp *),
pre:where(.pr-twp,.pr-twp *) {
  margin: 0;
}

fieldset:where(.pr-twp,.pr-twp *) {
  margin: 0;
  padding: 0;
}

legend:where(.pr-twp,.pr-twp *) {
  padding: 0;
}

ol:where(.pr-twp,.pr-twp *),
ul:where(.pr-twp,.pr-twp *),
menu:where(.pr-twp,.pr-twp *) {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Reset default styling for dialogs.
*/
dialog:where(.pr-twp,.pr-twp *) {
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea:where(.pr-twp,.pr-twp *) {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

input::placeholder:where(.pr-twp,.pr-twp *),
textarea::placeholder:where(.pr-twp,.pr-twp *) {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

/*
Set the default cursor for buttons.
*/

button:where(.pr-twp,.pr-twp *),
[role="button"]:where(.pr-twp,.pr-twp *) {
  cursor: pointer;
}

/*
Make sure disabled buttons don't get the pointer cursor.
*/
:disabled:where(.pr-twp,.pr-twp *) {
  cursor: default;
}

/*
1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img:where(.pr-twp,.pr-twp *),
svg:where(.pr-twp,.pr-twp *),
video:where(.pr-twp,.pr-twp *),
canvas:where(.pr-twp,.pr-twp *),
audio:where(.pr-twp,.pr-twp *),
iframe:where(.pr-twp,.pr-twp *),
embed:where(.pr-twp,.pr-twp *),
object:where(.pr-twp,.pr-twp *) {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img:where(.pr-twp,.pr-twp *),
video:where(.pr-twp,.pr-twp *) {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */
[hidden]:where(:not([hidden="until-found"])):where(.pr-twp,.pr-twp *) {
  display: none;
}
  /* Adding the preflight selector (pr-twp) to components was not changing the font as desired.
  So this piece of code adds tw-font-sans everywhere we include preflight. */
  .pr-twp {
  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
  @font-face {
    font-family: 'Inter';
    font-display: 'swap';
    src: url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
  }

  /**
   * Theme colors and other CSS variable properties in Platform.Bible. These are applied in CSS
   * properties using \`hsl(var(--variableName))\` or Tailwind classes like \`tw-bg-primary\`
   *
   * See the wiki's [Matching Application
   * Theme](https://github.com/paranext/paranext-extension-template/wiki/Extension-Anatomy#matching-application-theme)
   * section for more information
   */
  /* ["Slate" base theme by shadcn/ui](https://ui.shadcn.com/docs/theming#slate) */
  :root {
    --background: 0 0% 100%; /* white */
    --foreground: 222.2 84% 4.9%; /* slate-950 */
    --card: 0 0% 100%; /* white */
    --card-foreground: 222.2 84% 4.9%; /* slate-950 */
    --popover: 210 20% 98%; /* popover platform */
    --popover-foreground: 222.2 84% 4.9%; /* slate-950 */
    --primary: 222.2 47.4% 11.2%; /* slate-900 */
    --primary-foreground: 210 40% 98%; /* slate-50 */
    --secondary: 210 50% 95%;
    --secondary-foreground: 222.2 47.4% 11.2%; /* slate-900 */
    --muted: 210 50% 95%;
    --muted-foreground: 215.4 16.3% 46.9%; /* slate-500 */
    --accent: 210 50% 95%;
    --accent-foreground: 222.2 47.4% 11.2%; /* slate-900 */
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%; /* slate-50 */
    --border: 214.3 31.8% 91.4%; /* slate-200 */
    --input: 214.3 31.8% 91.4%; /* slate-200 */
    --ring: 222.2 84% 4.9%; /* slate-950 */

    --sidebar-background: 210 20% 98%; /* popover platform */
    --sidebar-foreground: 222.2 84% 4.9%; /* slate-950 */
    --sidebar-primary: 222.2 47.4% 11.2%; /* slate-900 */
    --sidebar-primary-foreground: 210 40% 98%; /* slate-50 */
    --sidebar-accent: 210 50% 95%;
    --sidebar-accent-foreground: 222.2 47.4% 11.2%; /* slate-900 */
    --sidebar-border: 214.3 31.8% 91.4%; /* slate-200 */
    --sidebar-ring: 222.2 84% 4.9%; /* slate-950 */

    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%; /* slate-950 */
    --foreground: 210 40% 98%; /* slate-50 */
    --card: 222.2 84% 4.9%; /* slate-950 */
    --card-foreground: 210 40% 98%; /* slate-50 */
    --popover: 222.2 84% 4.9%; /* slate-950 */
    --popover-foreground: 210 40% 98%; /* slate-50 */
    --primary: 210 40% 98%; /* slate-50 */
    --primary-foreground: 222.2 47.4% 11.2%; /* slate-900 */
    --secondary: 217.2 32.6% 17.5%; /* slate-800 */
    --secondary-foreground: 210 40% 98%; /* slate-50 */
    --muted: 217.2 32.6% 17.5%; /* slate-800 */
    --muted-foreground: 215 20.2% 65.1%; /* slate-400 */
    --accent: 217.2 32.6% 17.5%; /* slate-800 */
    --accent-foreground: 210 40% 98%; /* slate-50 */
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%; /* slate-50 */
    --border: 215.3 19.3% 34.5%; /* slate-600 */
    --input: 215.3 19.3% 34.5%; /* slate-600 */
    --ring: 212.7 26.8% 83.9%; /* slate-300 */

    --sidebar-background: 222.2 84% 4.9%; /* slate-950 */
    --sidebar-foreground: 215 20.2% 65.1%; /* slate-400 */
    --sidebar-primary: 210 40% 98%; /* slate-50 */
    --sidebar-primary-foreground: 222.2 47.4% 11.2%; /* slate-900 */
    --sidebar-accent: 217.2 32.6% 17.5%; /* slate-800 */
    --sidebar-accent-foreground: 215 20.2% 65.1%; /* slate-400 */
    --sidebar-border: 217.2 32.6% 17.5%; /* slate-800 */
    --sidebar-ring: 212.7 26.8% 83.9%; /* slate-300 */
  }

  /* Palette built in https://tweakcn.com/themes/cmeukcpoj000204l45lxw5a74 based on "Caffeine" theme*/
  .pr-twp,
  .pr-twp * {
  border-color: hsl(var(--border));
  outline-color: hsl(var(--ring) / 0.5);
}

  /**
    * disabled because tslint does not like it, but it is the selector that's needed
    */
  /* stylelint-disable-next-line selector-no-qualifying-type */
  body.pr-twp {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
}
.tw-prose {
  color: var(--tw-prose-body);
  max-width: 65ch;
}
.tw-prose :where(p):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.25em;
  margin-bottom: 1.25em;
}
.tw-prose :where([class~="lead"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-lead);
  font-size: 1.25em;
  line-height: 1.6;
  margin-top: 1.2em;
  margin-bottom: 1.2em;
}
.tw-prose :where(a):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-links);
  text-decoration: underline;
  font-weight: 500;
}
.tw-prose :where(strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-bold);
  font-weight: 600;
}
.tw-prose :where(a strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(blockquote strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(thead th strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(ol):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: decimal;
  margin-top: 1.25em;
  margin-bottom: 1.25em;
  padding-inline-start: 1.625em;
}
.tw-prose :where(ol[type="A"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: upper-alpha;
}
.tw-prose :where(ol[type="a"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: lower-alpha;
}
.tw-prose :where(ol[type="A" s]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: upper-alpha;
}
.tw-prose :where(ol[type="a" s]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: lower-alpha;
}
.tw-prose :where(ol[type="I"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: upper-roman;
}
.tw-prose :where(ol[type="i"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: lower-roman;
}
.tw-prose :where(ol[type="I" s]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: upper-roman;
}
.tw-prose :where(ol[type="i" s]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: lower-roman;
}
.tw-prose :where(ol[type="1"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: decimal;
}
.tw-prose :where(ul):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: disc;
  margin-top: 1.25em;
  margin-bottom: 1.25em;
  padding-inline-start: 1.625em;
}
.tw-prose :where(ol > li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::marker {
  font-weight: 400;
  color: var(--tw-prose-counters);
}
.tw-prose :where(ul > li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::marker {
  color: var(--tw-prose-bullets);
}
.tw-prose :where(dt):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  margin-top: 1.25em;
}
.tw-prose :where(hr):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  border-color: var(--tw-prose-hr);
  border-top-width: 1px;
  margin-top: 3em;
  margin-bottom: 3em;
}
.tw-prose :where(blockquote):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-weight: 500;
  font-style: italic;
  color: var(--tw-prose-quotes);
  border-inline-start-width: 0.25rem;
  border-inline-start-color: var(--tw-prose-quote-borders);
  quotes: "0o201C""0o201D""0o2018""0o2019";
  margin-top: 1.6em;
  margin-bottom: 1.6em;
  padding-inline-start: 1em;
}
.tw-prose :where(blockquote p:first-of-type):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::before {
  content: open-quote;
}
.tw-prose :where(blockquote p:last-of-type):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::after {
  content: close-quote;
}
.tw-prose :where(h1):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 800;
  font-size: 2.25em;
  margin-top: 0;
  margin-bottom: 0.8888889em;
  line-height: 1.1111111;
}
.tw-prose :where(h1 strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-weight: 900;
  color: inherit;
}
.tw-prose :where(h2):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 700;
  font-size: 1.5em;
  margin-top: 2em;
  margin-bottom: 1em;
  line-height: 1.3333333;
}
.tw-prose :where(h2 strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-weight: 800;
  color: inherit;
}
.tw-prose :where(h3):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  font-size: 1.25em;
  margin-top: 1.6em;
  margin-bottom: 0.6em;
  line-height: 1.6;
}
.tw-prose :where(h3 strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-weight: 700;
  color: inherit;
}
.tw-prose :where(h4):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  margin-top: 1.5em;
  margin-bottom: 0.5em;
  line-height: 1.5;
}
.tw-prose :where(h4 strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-weight: 700;
  color: inherit;
}
.tw-prose :where(img):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 2em;
  margin-bottom: 2em;
}
.tw-prose :where(picture):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  display: block;
  margin-top: 2em;
  margin-bottom: 2em;
}
.tw-prose :where(video):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 2em;
  margin-bottom: 2em;
}
.tw-prose :where(kbd):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-weight: 500;
  font-family: inherit;
  color: var(--tw-prose-kbd);
  box-shadow: 0 0 0 1px rgb(var(--tw-prose-kbd-shadows) / 10%), 0 3px 0 rgb(var(--tw-prose-kbd-shadows) / 10%);
  font-size: 0.875em;
  border-radius: 0.3125rem;
  padding-top: 0.1875em;
  padding-inline-end: 0.375em;
  padding-bottom: 0.1875em;
  padding-inline-start: 0.375em;
}
.tw-prose :where(code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-code);
  font-weight: 600;
  font-size: 0.875em;
}
.tw-prose :where(code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::before {
  content: "\`";
}
.tw-prose :where(code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::after {
  content: "\`";
}
.tw-prose :where(a code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(h1 code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(h2 code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
  font-size: 0.875em;
}
.tw-prose :where(h3 code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
  font-size: 0.9em;
}
.tw-prose :where(h4 code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(blockquote code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(thead th code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(pre):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-pre-code);
  background-color: var(--tw-prose-pre-bg);
  overflow-x: auto;
  font-weight: 400;
  font-size: 0.875em;
  line-height: 1.7142857;
  margin-top: 1.7142857em;
  margin-bottom: 1.7142857em;
  border-radius: 0.375rem;
  padding-top: 0.8571429em;
  padding-inline-end: 1.1428571em;
  padding-bottom: 0.8571429em;
  padding-inline-start: 1.1428571em;
}
.tw-prose :where(pre code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  background-color: transparent;
  border-width: 0;
  border-radius: 0;
  padding: 0;
  font-weight: inherit;
  color: inherit;
  font-size: inherit;
  font-family: inherit;
  line-height: inherit;
}
.tw-prose :where(pre code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::before {
  content: none;
}
.tw-prose :where(pre code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::after {
  content: none;
}
.tw-prose :where(table):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  width: 100%;
  table-layout: auto;
  margin-top: 2em;
  margin-bottom: 2em;
  font-size: 0.875em;
  line-height: 1.7142857;
}
.tw-prose :where(thead):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  border-bottom-width: 1px;
  border-bottom-color: var(--tw-prose-th-borders);
}
.tw-prose :where(thead th):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  vertical-align: bottom;
  padding-inline-end: 0.5714286em;
  padding-bottom: 0.5714286em;
  padding-inline-start: 0.5714286em;
}
.tw-prose :where(tbody tr):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  border-bottom-width: 1px;
  border-bottom-color: var(--tw-prose-td-borders);
}
.tw-prose :where(tbody tr:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  border-bottom-width: 0;
}
.tw-prose :where(tbody td):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  vertical-align: baseline;
}
.tw-prose :where(tfoot):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  border-top-width: 1px;
  border-top-color: var(--tw-prose-th-borders);
}
.tw-prose :where(tfoot td):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  vertical-align: top;
}
.tw-prose :where(th, td):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  text-align: start;
}
.tw-prose :where(figure > *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
  margin-bottom: 0;
}
.tw-prose :where(figcaption):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-captions);
  font-size: 0.875em;
  line-height: 1.4285714;
  margin-top: 0.8571429em;
}
.tw-prose {
  --tw-prose-body: hsl(var(--foreground));
  --tw-prose-headings: hsl(var(--foreground));
  --tw-prose-lead: hsl(var(--muted-foreground));
  --tw-prose-links: hsl(var(--primary));
  --tw-prose-bold: hsl(var(--foreground));
  --tw-prose-counters: hsl(var(--muted-foreground));
  --tw-prose-bullets: hsl(var(--muted-foreground));
  --tw-prose-hr: hsl(var(--border));
  --tw-prose-quotes: hsl(var(--foreground));
  --tw-prose-quote-borders: hsl(var(--border));
  --tw-prose-captions: hsl(var(--muted-foreground));
  --tw-prose-kbd: #111827;
  --tw-prose-kbd-shadows: 17 24 39;
  --tw-prose-code: hsl(var(--foreground));
  --tw-prose-pre-code: hsl(var(--muted-foreground));
  --tw-prose-pre-bg: hsl(var(--muted));
  --tw-prose-th-borders: hsl(var(--border));
  --tw-prose-td-borders: hsl(var(--border));
  --tw-prose-invert-body: #d1d5db;
  --tw-prose-invert-headings: #fff;
  --tw-prose-invert-lead: #9ca3af;
  --tw-prose-invert-links: #fff;
  --tw-prose-invert-bold: #fff;
  --tw-prose-invert-counters: #9ca3af;
  --tw-prose-invert-bullets: #4b5563;
  --tw-prose-invert-hr: #374151;
  --tw-prose-invert-quotes: #f3f4f6;
  --tw-prose-invert-quote-borders: #374151;
  --tw-prose-invert-captions: #9ca3af;
  --tw-prose-invert-kbd: #fff;
  --tw-prose-invert-kbd-shadows: 255 255 255;
  --tw-prose-invert-code: #fff;
  --tw-prose-invert-pre-code: #d1d5db;
  --tw-prose-invert-pre-bg: rgb(0 0 0 / 50%);
  --tw-prose-invert-th-borders: #4b5563;
  --tw-prose-invert-td-borders: #374151;
  font-size: 1rem;
  line-height: 1.75;
}
.tw-prose :where(picture > img):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
  margin-bottom: 0;
}
.tw-prose :where(li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}
.tw-prose :where(ol > li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0.375em;
}
.tw-prose :where(ul > li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0.375em;
}
.tw-prose :where(.tw-prose > ul > li p):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.75em;
  margin-bottom: 0.75em;
}
.tw-prose :where(.tw-prose > ul > li > p:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.25em;
}
.tw-prose :where(.tw-prose > ul > li > p:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-bottom: 1.25em;
}
.tw-prose :where(.tw-prose > ol > li > p:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.25em;
}
.tw-prose :where(.tw-prose > ol > li > p:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-bottom: 1.25em;
}
.tw-prose :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.75em;
  margin-bottom: 0.75em;
}
.tw-prose :where(dl):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.25em;
  margin-bottom: 1.25em;
}
.tw-prose :where(dd):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.5em;
  padding-inline-start: 1.625em;
}
.tw-prose :where(hr + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose :where(h2 + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose :where(h3 + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose :where(h4 + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose :where(thead th:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0;
}
.tw-prose :where(thead th:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-end: 0;
}
.tw-prose :where(tbody td, tfoot td):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-top: 0.5714286em;
  padding-inline-end: 0.5714286em;
  padding-bottom: 0.5714286em;
  padding-inline-start: 0.5714286em;
}
.tw-prose :where(tbody td:first-child, tfoot td:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0;
}
.tw-prose :where(tbody td:last-child, tfoot td:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-end: 0;
}
.tw-prose :where(figure):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 2em;
  margin-bottom: 2em;
}
.tw-prose :where(.tw-prose > :first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose :where(.tw-prose > :last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-bottom: 0;
}
.tw-prose-sm {
  font-size: 0.875rem;
  line-height: 1.7142857;
}
.tw-prose-sm :where(p):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
  margin-bottom: 1.1428571em;
}
.tw-prose-sm :where([class~="lead"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 1.2857143em;
  line-height: 1.5555556;
  margin-top: 0.8888889em;
  margin-bottom: 0.8888889em;
}
.tw-prose-sm :where(blockquote):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.3333333em;
  margin-bottom: 1.3333333em;
  padding-inline-start: 1.1111111em;
}
.tw-prose-sm :where(h1):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 2.1428571em;
  margin-top: 0;
  margin-bottom: 0.8em;
  line-height: 1.2;
}
.tw-prose-sm :where(h2):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 1.4285714em;
  margin-top: 1.6em;
  margin-bottom: 0.8em;
  line-height: 1.4;
}
.tw-prose-sm :where(h3):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 1.2857143em;
  margin-top: 1.5555556em;
  margin-bottom: 0.4444444em;
  line-height: 1.5555556;
}
.tw-prose-sm :where(h4):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.4285714em;
  margin-bottom: 0.5714286em;
  line-height: 1.4285714;
}
.tw-prose-sm :where(img):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.7142857em;
  margin-bottom: 1.7142857em;
}
.tw-prose-sm :where(picture):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.7142857em;
  margin-bottom: 1.7142857em;
}
.tw-prose-sm :where(picture > img):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
  margin-bottom: 0;
}
.tw-prose-sm :where(video):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.7142857em;
  margin-bottom: 1.7142857em;
}
.tw-prose-sm :where(kbd):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.8571429em;
  border-radius: 0.3125rem;
  padding-top: 0.1428571em;
  padding-inline-end: 0.3571429em;
  padding-bottom: 0.1428571em;
  padding-inline-start: 0.3571429em;
}
.tw-prose-sm :where(code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.8571429em;
}
.tw-prose-sm :where(h2 code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.9em;
}
.tw-prose-sm :where(h3 code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.8888889em;
}
.tw-prose-sm :where(pre):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.8571429em;
  line-height: 1.6666667;
  margin-top: 1.6666667em;
  margin-bottom: 1.6666667em;
  border-radius: 0.25rem;
  padding-top: 0.6666667em;
  padding-inline-end: 1em;
  padding-bottom: 0.6666667em;
  padding-inline-start: 1em;
}
.tw-prose-sm :where(ol):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
  margin-bottom: 1.1428571em;
  padding-inline-start: 1.5714286em;
}
.tw-prose-sm :where(ul):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
  margin-bottom: 1.1428571em;
  padding-inline-start: 1.5714286em;
}
.tw-prose-sm :where(li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.2857143em;
  margin-bottom: 0.2857143em;
}
.tw-prose-sm :where(ol > li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0.4285714em;
}
.tw-prose-sm :where(ul > li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0.4285714em;
}
.tw-prose-sm :where(.tw-prose-sm > ul > li p):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.5714286em;
  margin-bottom: 0.5714286em;
}
.tw-prose-sm :where(.tw-prose-sm > ul > li > p:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
}
.tw-prose-sm :where(.tw-prose-sm > ul > li > p:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-bottom: 1.1428571em;
}
.tw-prose-sm :where(.tw-prose-sm > ol > li > p:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
}
.tw-prose-sm :where(.tw-prose-sm > ol > li > p:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-bottom: 1.1428571em;
}
.tw-prose-sm :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.5714286em;
  margin-bottom: 0.5714286em;
}
.tw-prose-sm :where(dl):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
  margin-bottom: 1.1428571em;
}
.tw-prose-sm :where(dt):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
}
.tw-prose-sm :where(dd):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.2857143em;
  padding-inline-start: 1.5714286em;
}
.tw-prose-sm :where(hr):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 2.8571429em;
  margin-bottom: 2.8571429em;
}
.tw-prose-sm :where(hr + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose-sm :where(h2 + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose-sm :where(h3 + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose-sm :where(h4 + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose-sm :where(table):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.8571429em;
  line-height: 1.5;
}
.tw-prose-sm :where(thead th):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-end: 1em;
  padding-bottom: 0.6666667em;
  padding-inline-start: 1em;
}
.tw-prose-sm :where(thead th:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0;
}
.tw-prose-sm :where(thead th:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-end: 0;
}
.tw-prose-sm :where(tbody td, tfoot td):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-top: 0.6666667em;
  padding-inline-end: 1em;
  padding-bottom: 0.6666667em;
  padding-inline-start: 1em;
}
.tw-prose-sm :where(tbody td:first-child, tfoot td:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0;
}
.tw-prose-sm :where(tbody td:last-child, tfoot td:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-end: 0;
}
.tw-prose-sm :where(figure):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.7142857em;
  margin-bottom: 1.7142857em;
}
.tw-prose-sm :where(figure > *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
  margin-bottom: 0;
}
.tw-prose-sm :where(figcaption):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.8571429em;
  line-height: 1.3333333;
  margin-top: 0.6666667em;
}
.tw-prose-sm :where(.tw-prose-sm > :first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose-sm :where(.tw-prose-sm > :last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-bottom: 0;
}
.tw-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
.tw-pointer-events-none {
  pointer-events: none;
}
.tw-pointer-events-auto {
  pointer-events: auto;
}
.tw-fixed {
  position: fixed;
}
.tw-absolute {
  position: absolute;
}
.tw-relative {
  position: relative;
}
.tw-sticky {
  position: sticky;
}
.tw-inset-0 {
  inset: 0px;
}
.tw-inset-x-0 {
  left: 0px;
  right: 0px;
}
.tw-inset-y-0 {
  top: 0px;
  bottom: 0px;
}
.tw--left-\\[1px\\] {
  left: -1px;
}
.tw--right-1 {
  right: -0.25rem;
}
.tw--top-\\[1px\\] {
  top: -1px;
}
.tw-bottom-0 {
  bottom: 0px;
}
.tw-left-0 {
  left: 0px;
}
.tw-left-2 {
  left: 0.5rem;
}
.tw-left-3 {
  left: 0.75rem;
}
.tw-left-4 {
  left: 1rem;
}
.tw-left-\\[50\\%\\] {
  left: 50%;
}
.tw-right-0 {
  right: 0px;
}
.tw-right-1 {
  right: 0.25rem;
}
.tw-right-3 {
  right: 0.75rem;
}
.tw-right-4 {
  right: 1rem;
}
.tw-start-2 {
  inset-inline-start: 0.5rem;
}
.tw-top-0 {
  top: 0px;
}
.tw-top-1\\.5 {
  top: 0.375rem;
}
.tw-top-1\\/2 {
  top: 50%;
}
.tw-top-2\\.5 {
  top: 0.625rem;
}
.tw-top-3\\.5 {
  top: 0.875rem;
}
.tw-top-4 {
  top: 1rem;
}
.tw-top-\\[-1px\\] {
  top: -1px;
}
.tw-top-\\[50\\%\\] {
  top: 50%;
}
.tw-z-10 {
  z-index: 10;
}
.tw-z-20 {
  z-index: 20;
}
.tw-z-50 {
  z-index: 50;
}
.tw-z-\\[1000\\] {
  z-index: 1000;
}
.tw-z-\\[250\\] {
  z-index: 250;
}
.tw-col-span-2 {
  grid-column: span 2 / span 2;
}
.tw-col-span-3 {
  grid-column: span 3 / span 3;
}
.tw-m-0 {
  margin: 0px;
}
.tw-m-1 {
  margin: 0.25rem;
}
.tw-m-2 {
  margin: 0.5rem;
}
.tw--mx-1 {
  margin-left: -0.25rem;
  margin-right: -0.25rem;
}
.tw-mx-0 {
  margin-left: 0px;
  margin-right: 0px;
}
.tw-mx-1 {
  margin-left: 0.25rem;
  margin-right: 0.25rem;
}
.tw-mx-2 {
  margin-left: 0.5rem;
  margin-right: 0.5rem;
}
.tw-mx-3\\.5 {
  margin-left: 0.875rem;
  margin-right: 0.875rem;
}
.tw-mx-8 {
  margin-left: 2rem;
  margin-right: 2rem;
}
.tw-mx-auto {
  margin-left: auto;
  margin-right: auto;
}
.tw-my-1 {
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
}
.tw-my-2\\.5 {
  margin-top: 0.625rem;
  margin-bottom: 0.625rem;
}
.tw-my-auto {
  margin-top: auto;
  margin-bottom: auto;
}
.tw-mb-1 {
  margin-bottom: 0.25rem;
}
.tw-mb-2 {
  margin-bottom: 0.5rem;
}
.tw-mb-24 {
  margin-bottom: 6rem;
}
.tw-mb-4 {
  margin-bottom: 1rem;
}
.tw-me-1 {
  margin-inline-end: 0.25rem;
}
.tw-me-2 {
  margin-inline-end: 0.5rem;
}
.tw-ml-2 {
  margin-left: 0.5rem;
}
.tw-ml-24 {
  margin-left: 6rem;
}
.tw-ml-4 {
  margin-left: 1rem;
}
.tw-ml-auto {
  margin-left: auto;
}
.tw-mr-1 {
  margin-right: 0.25rem;
}
.tw-mr-2 {
  margin-right: 0.5rem;
}
.tw-mr-24 {
  margin-right: 6rem;
}
.tw-mr-4 {
  margin-right: 1rem;
}
.tw-ms-1 {
  margin-inline-start: 0.25rem;
}
.tw-ms-2 {
  margin-inline-start: 0.5rem;
}
.tw-ms-5 {
  margin-inline-start: 1.25rem;
}
.tw-ms-auto {
  margin-inline-start: auto;
}
.tw-mt-1 {
  margin-top: 0.25rem;
}
.tw-mt-2 {
  margin-top: 0.5rem;
}
.tw-mt-24 {
  margin-top: 6rem;
}
.tw-mt-3 {
  margin-top: 0.75rem;
}
.tw-mt-4 {
  margin-top: 1rem;
}
.tw-mt-6 {
  margin-top: 1.5rem;
}
.tw-mt-auto {
  margin-top: auto;
}
.tw-box-border {
  box-sizing: border-box;
}
.tw-block {
  display: block;
}
.tw-inline-block {
  display: inline-block;
}
.tw-flex {
  display: flex;
}
.tw-inline-flex {
  display: inline-flex;
}
.tw-table {
  display: table;
}
.tw-table-cell {
  display: table-cell;
}
.tw-table-row {
  display: table-row;
}
.tw-grid {
  display: grid;
}
.tw-inline-grid {
  display: inline-grid;
}
.tw-hidden {
  display: none;
}
.tw-aspect-square {
  aspect-ratio: 1 / 1;
}
.tw-size-4 {
  width: 1rem;
  height: 1rem;
}
.tw-h-1 {
  height: 0.25rem;
}
.tw-h-10 {
  height: 2.5rem;
}
.tw-h-11 {
  height: 2.75rem;
}
.tw-h-12 {
  height: 3rem;
}
.tw-h-14 {
  height: 3.5rem;
}
.tw-h-2 {
  height: 0.5rem;
}
.tw-h-2\\.5 {
  height: 0.625rem;
}
.tw-h-20 {
  height: 5rem;
}
.tw-h-24 {
  height: 6rem;
}
.tw-h-3 {
  height: 0.75rem;
}
.tw-h-3\\.5 {
  height: 0.875rem;
}
.tw-h-32 {
  height: 8rem;
}
.tw-h-4 {
  height: 1rem;
}
.tw-h-40 {
  height: 10rem;
}
.tw-h-5 {
  height: 1.25rem;
}
.tw-h-6 {
  height: 1.5rem;
}
.tw-h-64 {
  height: 16rem;
}
.tw-h-7 {
  height: 1.75rem;
}
.tw-h-8 {
  height: 2rem;
}
.tw-h-9 {
  height: 2.25rem;
}
.tw-h-96 {
  height: 24rem;
}
.tw-h-\\[1\\.2rem\\] {
  height: 1.2rem;
}
.tw-h-\\[100px\\] {
  height: 100px;
}
.tw-h-\\[1px\\] {
  height: 1px;
}
.tw-h-\\[300px\\] {
  height: 300px;
}
.tw-h-\\[5px\\] {
  height: 5px;
}
.tw-h-\\[calc\\(100\\%-2px\\)\\] {
  height: calc(100% - 2px);
}
.tw-h-\\[var\\(--radix-select-trigger-height\\)\\] {
  height: var(--radix-select-trigger-height);
}
.tw-h-auto {
  height: auto;
}
.tw-h-full {
  height: 100%;
}
.tw-h-px {
  height: 1px;
}
.tw-h-svh {
  height: 100svh;
}
.tw-max-h-5 {
  max-height: 1.25rem;
}
.tw-max-h-80 {
  max-height: 20rem;
}
.tw-max-h-96 {
  max-height: 24rem;
}
.tw-max-h-\\[--radix-context-menu-content-available-height\\] {
  max-height: var(--radix-context-menu-content-available-height);
}
.tw-max-h-\\[300px\\] {
  max-height: 300px;
}
.tw-max-h-\\[96\\%\\] {
  max-height: 96%;
}
.tw-min-h-0 {
  min-height: 0px;
}
.tw-min-h-11 {
  min-height: 2.75rem;
}
.tw-min-h-\\[80px\\] {
  min-height: 80px;
}
.tw-min-h-svh {
  min-height: 100svh;
}
.tw-w-1\\/2 {
  width: 50%;
}
.tw-w-10 {
  width: 2.5rem;
}
.tw-w-11 {
  width: 2.75rem;
}
.tw-w-12 {
  width: 3rem;
}
.tw-w-2 {
  width: 0.5rem;
}
.tw-w-2\\.5 {
  width: 0.625rem;
}
.tw-w-20 {
  width: 5rem;
}
.tw-w-24 {
  width: 6rem;
}
.tw-w-3 {
  width: 0.75rem;
}
.tw-w-3\\.5 {
  width: 0.875rem;
}
.tw-w-3\\/4 {
  width: 75%;
}
.tw-w-32 {
  width: 8rem;
}
.tw-w-4 {
  width: 1rem;
}
.tw-w-4\\/5 {
  width: 80%;
}
.tw-w-4\\/6 {
  width: 66.666667%;
}
.tw-w-48 {
  width: 12rem;
}
.tw-w-5 {
  width: 1.25rem;
}
.tw-w-5\\/6 {
  width: 83.333333%;
}
.tw-w-56 {
  width: 14rem;
}
.tw-w-6 {
  width: 1.5rem;
}
.tw-w-60 {
  width: 15rem;
}
.tw-w-64 {
  width: 16rem;
}
.tw-w-7 {
  width: 1.75rem;
}
.tw-w-72 {
  width: 18rem;
}
.tw-w-8 {
  width: 2rem;
}
.tw-w-80 {
  width: 20rem;
}
.tw-w-9\\/12 {
  width: 75%;
}
.tw-w-96 {
  width: 24rem;
}
.tw-w-\\[--sidebar-width\\] {
  width: var(--sidebar-width);
}
.tw-w-\\[1\\.2rem\\] {
  width: 1.2rem;
}
.tw-w-\\[100px\\] {
  width: 100px;
}
.tw-w-\\[116px\\] {
  width: 116px;
}
.tw-w-\\[124px\\] {
  width: 124px;
}
.tw-w-\\[150px\\] {
  width: 150px;
}
.tw-w-\\[180px\\] {
  width: 180px;
}
.tw-w-\\[1px\\] {
  width: 1px;
}
.tw-w-\\[200px\\] {
  width: 200px;
}
.tw-w-\\[250px\\] {
  width: 250px;
}
.tw-w-\\[280px\\] {
  width: 280px;
}
.tw-w-\\[300px\\] {
  width: 300px;
}
.tw-w-\\[350px\\] {
  width: 350px;
}
.tw-w-\\[400px\\] {
  width: 400px;
}
.tw-w-\\[500px\\] {
  width: 500px;
}
.tw-w-\\[5px\\] {
  width: 5px;
}
.tw-w-\\[600px\\] {
  width: 600px;
}
.tw-w-\\[70px\\] {
  width: 70px;
}
.tw-w-\\[calc\\(100\\%-2px\\)\\] {
  width: calc(100% - 2px);
}
.tw-w-auto {
  width: auto;
}
.tw-w-fit {
  width: fit-content;
}
.tw-w-full {
  width: 100%;
}
.tw-w-px {
  width: 1px;
}
.tw-min-w-0 {
  min-width: 0px;
}
.tw-min-w-16 {
  min-width: 4rem;
}
.tw-min-w-36 {
  min-width: 9rem;
}
.tw-min-w-5 {
  min-width: 1.25rem;
}
.tw-min-w-80 {
  min-width: 20rem;
}
.tw-min-w-\\[12rem\\] {
  min-width: 12rem;
}
.tw-min-w-\\[140px\\] {
  min-width: 140px;
}
.tw-min-w-\\[215px\\] {
  min-width: 215px;
}
.tw-min-w-\\[8rem\\] {
  min-width: 8rem;
}
.tw-min-w-\\[var\\(--radix-select-trigger-width\\)\\] {
  min-width: var(--radix-select-trigger-width);
}
.tw-max-w-2xl {
  max-width: 42rem;
}
.tw-max-w-3xl {
  max-width: 48rem;
}
.tw-max-w-48 {
  max-width: 12rem;
}
.tw-max-w-4xl {
  max-width: 56rem;
}
.tw-max-w-5 {
  max-width: 1.25rem;
}
.tw-max-w-64 {
  max-width: 16rem;
}
.tw-max-w-6xl {
  max-width: 72rem;
}
.tw-max-w-96 {
  max-width: 24rem;
}
.tw-max-w-\\[--skeleton-width\\] {
  max-width: var(--skeleton-width);
}
.tw-max-w-\\[220px\\] {
  max-width: 220px;
}
.tw-max-w-full {
  max-width: 100%;
}
.tw-max-w-lg {
  max-width: 32rem;
}
.tw-max-w-md {
  max-width: 28rem;
}
.tw-max-w-none {
  max-width: none;
}
.tw-max-w-screen-md {
  max-width: 768px;
}
.tw-max-w-sm {
  max-width: 24rem;
}
.tw-flex-1 {
  flex: 1 1 0%;
}
.tw-flex-shrink-0 {
  flex-shrink: 0;
}
.tw-shrink {
  flex-shrink: 1;
}
.tw-shrink-0 {
  flex-shrink: 0;
}
.tw-flex-grow {
  flex-grow: 1;
}
.tw-grow {
  flex-grow: 1;
}
.tw-grow-\\[2\\] {
  flex-grow: 2;
}
.tw-basis-0 {
  flex-basis: 0px;
}
.tw-caption-bottom {
  caption-side: bottom;
}
.tw-border-collapse {
  border-collapse: collapse;
}
.tw-origin-\\[--radix-context-menu-content-transform-origin\\] {
  transform-origin: var(--radix-context-menu-content-transform-origin);
}
.tw--translate-x-1\\/2 {
  --tw-translate-x: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw--translate-x-px {
  --tw-translate-x: -1px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw--translate-y-1\\/2 {
  --tw-translate-y: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-translate-x-0 {
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-translate-x-\\[-50\\%\\] {
  --tw-translate-x: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-translate-x-px {
  --tw-translate-x: 1px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-translate-y-\\[-50\\%\\] {
  --tw-translate-y: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
@keyframes tw-pulse {

  50% {
    opacity: .5;
  }
}
.tw-animate-pulse {
  animation: tw-pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}
@keyframes tw-spin {

  to {
    transform: rotate(360deg);
  }
}
.tw-animate-spin {
  animation: tw-spin 1s linear infinite;
}
.tw-cursor-default {
  cursor: default;
}
.tw-cursor-ew-resize {
  cursor: ew-resize;
}
.tw-cursor-pointer {
  cursor: pointer;
}
.tw-touch-none {
  touch-action: none;
}
.tw-select-none {
  user-select: none;
}
.tw-scroll-m-20 {
  scroll-margin: 5rem;
}
.tw-list-inside {
  list-style-position: inside;
}
.tw-list-outside {
  list-style-position: outside;
}
.\\!tw-list-\\[lower-alpha\\] {
  list-style-type: lower-alpha !important;
}
.\\!tw-list-\\[lower-roman\\] {
  list-style-type: lower-roman !important;
}
.\\!tw-list-\\[upper-alpha\\] {
  list-style-type: upper-alpha !important;
}
.\\!tw-list-\\[upper-roman\\] {
  list-style-type: upper-roman !important;
}
.\\!tw-list-decimal {
  list-style-type: decimal !important;
}
.\\!tw-list-disc {
  list-style-type: disc !important;
}
.tw-list-decimal {
  list-style-type: decimal;
}
.tw-list-disc {
  list-style-type: disc;
}
.tw-list-none {
  list-style-type: none;
}
.tw-grid-cols-1 {
  grid-template-columns: repeat(1, minmax(0, 1fr));
}
.tw-grid-cols-2 {
  grid-template-columns: repeat(2, minmax(0, 1fr));
}
.tw-grid-cols-3 {
  grid-template-columns: repeat(3, minmax(0, 1fr));
}
.tw-grid-cols-4 {
  grid-template-columns: repeat(4, minmax(0, 1fr));
}
.tw-grid-cols-6 {
  grid-template-columns: repeat(6, minmax(0, 1fr));
}
.tw-grid-cols-\\[25\\%\\,25\\%\\,50\\%\\] {
  grid-template-columns: 25% 25% 50%;
}
.tw-grid-cols-\\[25\\%\\,50\\%\\,25\\%\\] {
  grid-template-columns: 25% 50% 25%;
}
.tw-flex-row {
  flex-direction: row;
}
.tw-flex-row-reverse {
  flex-direction: row-reverse;
}
.tw-flex-col {
  flex-direction: column;
}
.tw-flex-col-reverse {
  flex-direction: column-reverse;
}
.tw-flex-wrap {
  flex-wrap: wrap;
}
.tw-content-center {
  align-content: center;
}
.tw-items-start {
  align-items: flex-start;
}
.tw-items-end {
  align-items: flex-end;
}
.tw-items-center {
  align-items: center;
}
.tw-items-baseline {
  align-items: baseline;
}
.tw-items-stretch {
  align-items: stretch;
}
.tw-justify-start {
  justify-content: flex-start;
}
.tw-justify-end {
  justify-content: flex-end;
}
.tw-justify-center {
  justify-content: center;
}
.tw-justify-between {
  justify-content: space-between;
}
.tw-gap-1 {
  gap: 0.25rem;
}
.tw-gap-1\\.5 {
  gap: 0.375rem;
}
.tw-gap-2 {
  gap: 0.5rem;
}
.tw-gap-2\\.5 {
  gap: 0.625rem;
}
.tw-gap-3 {
  gap: 0.75rem;
}
.tw-gap-4 {
  gap: 1rem;
}
.tw-gap-5 {
  gap: 1.25rem;
}
.tw-gap-6 {
  gap: 1.5rem;
}
.tw-gap-\\[12px\\] {
  gap: 12px;
}
.tw-gap-x-2 {
  column-gap: 0.5rem;
}
.tw-gap-x-4 {
  column-gap: 1rem;
}
.tw-space-x-1 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(0.25rem * var(--tw-space-x-reverse));
  margin-left: calc(0.25rem * calc(1 - var(--tw-space-x-reverse)));
}
.tw-space-x-2 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(0.5rem * var(--tw-space-x-reverse));
  margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
}
.tw-space-x-3 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(0.75rem * var(--tw-space-x-reverse));
  margin-left: calc(0.75rem * calc(1 - var(--tw-space-x-reverse)));
}
.tw-space-x-4 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(1rem * var(--tw-space-x-reverse));
  margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
}
.tw-space-x-6 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(1.5rem * var(--tw-space-x-reverse));
  margin-left: calc(1.5rem * calc(1 - var(--tw-space-x-reverse)));
}
.tw-space-y-1 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(0.25rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(0.25rem * var(--tw-space-y-reverse));
}
.tw-space-y-1\\.5 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(0.375rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(0.375rem * var(--tw-space-y-reverse));
}
.tw-space-y-2 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(0.5rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(0.5rem * var(--tw-space-y-reverse));
}
.tw-space-y-3 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(0.75rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(0.75rem * var(--tw-space-y-reverse));
}
.tw-space-y-4 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(1rem * var(--tw-space-y-reverse));
}
.tw-space-y-6 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(1.5rem * var(--tw-space-y-reverse));
}
.tw-space-y-8 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(2rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(2rem * var(--tw-space-y-reverse));
}
.tw-divide-x > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-x-reverse: 0;
  border-right-width: calc(1px * var(--tw-divide-x-reverse));
  border-left-width: calc(1px * calc(1 - var(--tw-divide-x-reverse)));
}
.tw-divide-y > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-y-reverse: 0;
  border-top-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));
  border-bottom-width: calc(1px * var(--tw-divide-y-reverse));
}
.tw-self-stretch {
  align-self: stretch;
}
.tw-overflow-auto {
  overflow: auto;
}
.tw-overflow-hidden {
  overflow: hidden;
}
.tw-overflow-clip {
  overflow: clip;
}
.tw-overflow-visible {
  overflow: visible;
}
.tw-overflow-scroll {
  overflow: scroll;
}
.tw-overflow-x-auto {
  overflow-x: auto;
}
.tw-overflow-y-auto {
  overflow-y: auto;
}
.tw-overflow-x-hidden {
  overflow-x: hidden;
}
.tw-overflow-y-hidden {
  overflow-y: hidden;
}
.tw-truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.tw-text-ellipsis {
  text-overflow: ellipsis;
}
.tw-text-clip {
  text-overflow: clip;
}
.tw-whitespace-normal {
  white-space: normal;
}
.tw-whitespace-nowrap {
  white-space: nowrap;
}
.tw-text-nowrap {
  text-wrap: nowrap;
}
.tw-text-balance {
  text-wrap: balance;
}
.tw-break-words {
  overflow-wrap: break-word;
}
.tw-rounded {
  border-radius: 0.25rem;
}
.tw-rounded-2xl {
  border-radius: 1rem;
}
.tw-rounded-\\[6px\\] {
  border-radius: 6px;
}
.tw-rounded-full {
  border-radius: 9999px;
}
.tw-rounded-lg {
  border-radius: var(--radius);
}
.tw-rounded-md {
  border-radius: calc(var(--radius) - 2px);
}
.tw-rounded-none {
  border-radius: 0px;
}
.tw-rounded-sm {
  border-radius: calc(var(--radius) - 4px);
}
.tw-rounded-xl {
  border-radius: 0.75rem;
}
.tw-rounded-b-\\[10px\\] {
  border-bottom-right-radius: 10px;
  border-bottom-left-radius: 10px;
}
.tw-rounded-l-\\[10px\\] {
  border-top-left-radius: 10px;
  border-bottom-left-radius: 10px;
}
.tw-rounded-r-\\[10px\\] {
  border-top-right-radius: 10px;
  border-bottom-right-radius: 10px;
}
.tw-rounded-r-xl {
  border-top-right-radius: 0.75rem;
  border-bottom-right-radius: 0.75rem;
}
.tw-rounded-t-\\[10px\\] {
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
}
.tw-border {
  border-width: 1px;
}
.tw-border-0 {
  border-width: 0px;
}
.tw-border-2 {
  border-width: 2px;
}
.tw-border-b {
  border-bottom-width: 1px;
}
.tw-border-b-0 {
  border-bottom-width: 0px;
}
.tw-border-e {
  border-inline-end-width: 1px;
}
.tw-border-e-0 {
  border-inline-end-width: 0px;
}
.tw-border-l {
  border-left-width: 1px;
}
.tw-border-l-2 {
  border-left-width: 2px;
}
.tw-border-l-4 {
  border-left-width: 4px;
}
.tw-border-s-2 {
  border-inline-start-width: 2px;
}
.tw-border-t {
  border-top-width: 1px;
}
.tw-border-t-0 {
  border-top-width: 0px;
}
.tw-border-solid {
  border-style: solid;
}
.tw-border-dashed {
  border-style: dashed;
}
.tw-border-none {
  border-style: none;
}
.tw-border-black {
  --tw-border-opacity: 1;
  border-color: rgb(0 0 0 / var(--tw-border-opacity, 1));
}
.tw-border-blue-400 {
  --tw-border-opacity: 1;
  border-color: rgb(96 165 250 / var(--tw-border-opacity, 1));
}
.tw-border-blue-500 {
  --tw-border-opacity: 1;
  border-color: rgb(59 130 246 / var(--tw-border-opacity, 1));
}
.tw-border-border {
  border-color: hsl(var(--border));
}
.tw-border-destructive\\/50 {
  border-color: hsl(var(--destructive) / 0.5);
}
.tw-border-gray-300 {
  --tw-border-opacity: 1;
  border-color: rgb(209 213 219 / var(--tw-border-opacity, 1));
}
.tw-border-input {
  border-color: hsl(var(--input));
}
.tw-border-primary {
  border-color: hsl(var(--primary));
}
.tw-border-red-300 {
  --tw-border-opacity: 1;
  border-color: rgb(252 165 165 / var(--tw-border-opacity, 1));
}
.tw-border-red-400 {
  --tw-border-opacity: 1;
  border-color: rgb(248 113 113 / var(--tw-border-opacity, 1));
}
.tw-border-red-500 {
  --tw-border-opacity: 1;
  border-color: rgb(239 68 68 / var(--tw-border-opacity, 1));
}
.tw-border-red-600 {
  --tw-border-opacity: 1;
  border-color: rgb(220 38 38 / var(--tw-border-opacity, 1));
}
.tw-border-ring {
  border-color: hsl(var(--ring));
}
.tw-border-sidebar-border {
  border-color: hsl(var(--sidebar-border));
}
.tw-border-slate-300 {
  --tw-border-opacity: 1;
  border-color: rgb(203 213 225 / var(--tw-border-opacity, 1));
}
.tw-border-transparent {
  border-color: transparent;
}
.tw-border-yellow-400 {
  --tw-border-opacity: 1;
  border-color: rgb(250 204 21 / var(--tw-border-opacity, 1));
}
.tw-border-yellow-500 {
  --tw-border-opacity: 1;
  border-color: rgb(234 179 8 / var(--tw-border-opacity, 1));
}
.tw-border-s-amber-200 {
  --tw-border-opacity: 1;
  border-inline-start-color: rgb(253 230 138 / var(--tw-border-opacity, 1));
}
.tw-border-s-indigo-200 {
  --tw-border-opacity: 1;
  border-inline-start-color: rgb(199 210 254 / var(--tw-border-opacity, 1));
}
.tw-border-s-purple-200 {
  --tw-border-opacity: 1;
  border-inline-start-color: rgb(233 213 255 / var(--tw-border-opacity, 1));
}
.tw-border-s-red-200 {
  --tw-border-opacity: 1;
  border-inline-start-color: rgb(254 202 202 / var(--tw-border-opacity, 1));
}
.\\!tw-bg-destructive\\/50 {
  background-color: hsl(var(--destructive) / 0.5) !important;
}
.tw-bg-accent {
  background-color: hsl(var(--accent));
}
.tw-bg-background {
  background-color: hsl(var(--background));
}
.tw-bg-black\\/80 {
  background-color: rgb(0 0 0 / 0.8);
}
.tw-bg-blue-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(219 234 254 / var(--tw-bg-opacity, 1));
}
.tw-bg-blue-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(96 165 250 / var(--tw-bg-opacity, 1));
}
.tw-bg-blue-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(239 246 255 / var(--tw-bg-opacity, 1));
}
.tw-bg-blue-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(59 130 246 / var(--tw-bg-opacity, 1));
}
.tw-bg-border {
  background-color: hsl(var(--border));
}
.tw-bg-card {
  background-color: hsl(var(--card));
}
.tw-bg-destructive {
  background-color: hsl(var(--destructive));
}
.tw-bg-gray-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(243 244 246 / var(--tw-bg-opacity, 1));
}
.tw-bg-gray-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1));
}
.tw-bg-gray-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(107 114 128 / var(--tw-bg-opacity, 1));
}
.tw-bg-green-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(220 252 231 / var(--tw-bg-opacity, 1));
}
.tw-bg-green-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(240 253 244 / var(--tw-bg-opacity, 1));
}
.tw-bg-green-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(34 197 94 / var(--tw-bg-opacity, 1));
}
.tw-bg-input {
  background-color: hsl(var(--input));
}
.tw-bg-muted {
  background-color: hsl(var(--muted));
}
.tw-bg-muted\\/50 {
  background-color: hsl(var(--muted) / 0.5);
}
.tw-bg-neutral-300 {
  --tw-bg-opacity: 1;
  background-color: rgb(212 212 212 / var(--tw-bg-opacity, 1));
}
.tw-bg-orange-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(255 237 213 / var(--tw-bg-opacity, 1));
}
.tw-bg-popover {
  background-color: hsl(var(--popover));
}
.tw-bg-primary {
  background-color: hsl(var(--primary));
}
.tw-bg-purple-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(250 245 255 / var(--tw-bg-opacity, 1));
}
.tw-bg-red-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(254 226 226 / var(--tw-bg-opacity, 1));
}
.tw-bg-red-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(239 68 68 / var(--tw-bg-opacity, 1));
}
.tw-bg-secondary {
  background-color: hsl(var(--secondary));
}
.tw-bg-sidebar {
  background-color: hsl(var(--sidebar-background));
}
.tw-bg-sidebar-accent {
  background-color: hsl(var(--sidebar-accent));
}
.tw-bg-sidebar-border {
  background-color: hsl(var(--sidebar-border));
}
.tw-bg-slate-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(248 250 252 / var(--tw-bg-opacity, 1));
}
.tw-bg-transparent {
  background-color: transparent;
}
.tw-bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1));
}
.tw-bg-yellow-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(254 249 195 / var(--tw-bg-opacity, 1));
}
.tw-bg-yellow-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(254 252 232 / var(--tw-bg-opacity, 1));
}
.tw-bg-yellow-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(234 179 8 / var(--tw-bg-opacity, 1));
}
.tw-bg-zinc-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(161 161 170 / var(--tw-bg-opacity, 1));
}
.tw-fill-current {
  fill: currentColor;
}
.tw-fill-destructive {
  fill: hsl(var(--destructive));
}
.tw-fill-yellow-400 {
  fill: #facc15;
}
.tw-fill-yellow-400\\/50 {
  fill: rgb(250 204 21 / 0.5);
}
.tw-p-0 {
  padding: 0px;
}
.tw-p-0\\.5 {
  padding: 0.125rem;
}
.tw-p-1 {
  padding: 0.25rem;
}
.tw-p-2 {
  padding: 0.5rem;
}
.tw-p-3 {
  padding: 0.75rem;
}
.tw-p-4 {
  padding: 1rem;
}
.tw-p-6 {
  padding: 1.5rem;
}
.tw-p-8 {
  padding: 2rem;
}
.tw-p-\\[10px\\] {
  padding: 10px;
}
.tw-p-\\[1px\\] {
  padding: 1px;
}
.tw-px-0 {
  padding-left: 0px;
  padding-right: 0px;
}
.tw-px-1 {
  padding-left: 0.25rem;
  padding-right: 0.25rem;
}
.tw-px-2 {
  padding-left: 0.5rem;
  padding-right: 0.5rem;
}
.tw-px-2\\.5 {
  padding-left: 0.625rem;
  padding-right: 0.625rem;
}
.tw-px-3 {
  padding-left: 0.75rem;
  padding-right: 0.75rem;
}
.tw-px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}
.tw-px-5 {
  padding-left: 1.25rem;
  padding-right: 1.25rem;
}
.tw-px-6 {
  padding-left: 1.5rem;
  padding-right: 1.5rem;
}
.tw-px-8 {
  padding-left: 2rem;
  padding-right: 2rem;
}
.tw-py-0 {
  padding-top: 0px;
  padding-bottom: 0px;
}
.tw-py-0\\.5 {
  padding-top: 0.125rem;
  padding-bottom: 0.125rem;
}
.tw-py-1 {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}
.tw-py-1\\.5 {
  padding-top: 0.375rem;
  padding-bottom: 0.375rem;
}
.tw-py-2 {
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}
.tw-py-3 {
  padding-top: 0.75rem;
  padding-bottom: 0.75rem;
}
.tw-py-4 {
  padding-top: 1rem;
  padding-bottom: 1rem;
}
.tw-py-6 {
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
}
.tw-py-8 {
  padding-top: 2rem;
  padding-bottom: 2rem;
}
.\\!tw-pr-10 {
  padding-right: 2.5rem !important;
}
.tw-pb-0 {
  padding-bottom: 0px;
}
.tw-pb-2 {
  padding-bottom: 0.5rem;
}
.tw-pb-3 {
  padding-bottom: 0.75rem;
}
.tw-pb-4 {
  padding-bottom: 1rem;
}
.tw-pe-1 {
  padding-inline-end: 0.25rem;
}
.tw-pe-2 {
  padding-inline-end: 0.5rem;
}
.tw-pe-9 {
  padding-inline-end: 2.25rem;
}
.tw-pe-\\[calc\\(138px\\+1rem\\)\\] {
  padding-inline-end: calc(138px + 1rem);
}
.tw-pl-2 {
  padding-left: 0.5rem;
}
.tw-pl-3 {
  padding-left: 0.75rem;
}
.tw-pl-4 {
  padding-left: 1rem;
}
.tw-pl-5 {
  padding-left: 1.25rem;
}
.tw-pl-6 {
  padding-left: 1.5rem;
}
.tw-pl-8 {
  padding-left: 2rem;
}
.tw-pr-0 {
  padding-right: 0px;
}
.tw-pr-0\\.5 {
  padding-right: 0.125rem;
}
.tw-pr-2 {
  padding-right: 0.5rem;
}
.tw-pr-3 {
  padding-right: 0.75rem;
}
.tw-pr-4 {
  padding-right: 1rem;
}
.tw-ps-12 {
  padding-inline-start: 3rem;
}
.tw-ps-4 {
  padding-inline-start: 1rem;
}
.tw-ps-8 {
  padding-inline-start: 2rem;
}
.tw-ps-9 {
  padding-inline-start: 2.25rem;
}
.tw-ps-\\[85px\\] {
  padding-inline-start: 85px;
}
.tw-pt-0 {
  padding-top: 0px;
}
.tw-pt-1 {
  padding-top: 0.25rem;
}
.tw-pt-2 {
  padding-top: 0.5rem;
}
.tw-pt-3 {
  padding-top: 0.75rem;
}
.tw-pt-6 {
  padding-top: 1.5rem;
}
.tw-text-left {
  text-align: left;
}
.tw-text-center {
  text-align: center;
}
.tw-text-right {
  text-align: right;
}
.tw-text-start {
  text-align: start;
}
.tw-text-end {
  text-align: end;
}
.tw-align-middle {
  vertical-align: middle;
}
.tw-text-2xl {
  font-size: 1.5rem;
  line-height: 2rem;
}
.tw-text-3xl {
  font-size: 1.875rem;
  line-height: 2.25rem;
}
.tw-text-4xl {
  font-size: 2.25rem;
  line-height: 2.5rem;
}
.tw-text-base {
  font-size: 1rem;
  line-height: 1.5rem;
}
.tw-text-lg {
  font-size: 1.125rem;
  line-height: 1.75rem;
}
.tw-text-sm {
  font-size: 0.875rem;
  line-height: 1.25rem;
}
.tw-text-xl {
  font-size: 1.25rem;
  line-height: 1.75rem;
}
.tw-text-xs {
  font-size: 0.75rem;
  line-height: 1rem;
}
.tw-font-bold {
  font-weight: 700;
}
.tw-font-extrabold {
  font-weight: 800;
}
.tw-font-medium {
  font-weight: 500;
}
.tw-font-normal {
  font-weight: 400;
}
.tw-font-semibold {
  font-weight: 600;
}
.tw-capitalize {
  text-transform: capitalize;
}
.tw-italic {
  font-style: italic;
}
.tw-tabular-nums {
  --tw-numeric-spacing: tabular-nums;
  font-variant-numeric: var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction);
}
.tw-leading-loose {
  line-height: 2;
}
.tw-leading-none {
  line-height: 1;
}
.tw-leading-relaxed {
  line-height: 1.625;
}
.tw-leading-tight {
  line-height: 1.25;
}
.tw-tracking-tight {
  letter-spacing: -0.025em;
}
.tw-tracking-widest {
  letter-spacing: 0.1em;
}
.tw-text-blue-400 {
  --tw-text-opacity: 1;
  color: rgb(96 165 250 / var(--tw-text-opacity, 1));
}
.tw-text-blue-500 {
  --tw-text-opacity: 1;
  color: rgb(59 130 246 / var(--tw-text-opacity, 1));
}
.tw-text-blue-600 {
  --tw-text-opacity: 1;
  color: rgb(37 99 235 / var(--tw-text-opacity, 1));
}
.tw-text-blue-800 {
  --tw-text-opacity: 1;
  color: rgb(30 64 175 / var(--tw-text-opacity, 1));
}
.tw-text-card-foreground {
  color: hsl(var(--card-foreground));
}
.tw-text-current {
  color: currentColor;
}
.tw-text-destructive {
  color: hsl(var(--destructive));
}
.tw-text-destructive-foreground {
  color: hsl(var(--destructive-foreground));
}
.tw-text-foreground {
  color: hsl(var(--foreground));
}
.tw-text-gray-300 {
  --tw-text-opacity: 1;
  color: rgb(209 213 219 / var(--tw-text-opacity, 1));
}
.tw-text-gray-500 {
  --tw-text-opacity: 1;
  color: rgb(107 114 128 / var(--tw-text-opacity, 1));
}
.tw-text-gray-600 {
  --tw-text-opacity: 1;
  color: rgb(75 85 99 / var(--tw-text-opacity, 1));
}
.tw-text-gray-700 {
  --tw-text-opacity: 1;
  color: rgb(55 65 81 / var(--tw-text-opacity, 1));
}
.tw-text-gray-800 {
  --tw-text-opacity: 1;
  color: rgb(31 41 55 / var(--tw-text-opacity, 1));
}
.tw-text-green-600 {
  --tw-text-opacity: 1;
  color: rgb(22 163 74 / var(--tw-text-opacity, 1));
}
.tw-text-green-700 {
  --tw-text-opacity: 1;
  color: rgb(21 128 61 / var(--tw-text-opacity, 1));
}
.tw-text-green-800 {
  --tw-text-opacity: 1;
  color: rgb(22 101 52 / var(--tw-text-opacity, 1));
}
.tw-text-inherit {
  color: inherit;
}
.tw-text-muted-foreground {
  color: hsl(var(--muted-foreground));
}
.tw-text-muted-foreground\\/50 {
  color: hsl(var(--muted-foreground) / 0.5);
}
.tw-text-orange-800 {
  --tw-text-opacity: 1;
  color: rgb(154 52 18 / var(--tw-text-opacity, 1));
}
.tw-text-popover-foreground {
  color: hsl(var(--popover-foreground));
}
.tw-text-primary {
  color: hsl(var(--primary));
}
.tw-text-primary-foreground {
  color: hsl(var(--primary-foreground));
}
.tw-text-purple-900 {
  --tw-text-opacity: 1;
  color: rgb(88 28 135 / var(--tw-text-opacity, 1));
}
.tw-text-red-500 {
  --tw-text-opacity: 1;
  color: rgb(239 68 68 / var(--tw-text-opacity, 1));
}
.tw-text-red-600 {
  --tw-text-opacity: 1;
  color: rgb(220 38 38 / var(--tw-text-opacity, 1));
}
.tw-text-red-700 {
  --tw-text-opacity: 1;
  color: rgb(185 28 28 / var(--tw-text-opacity, 1));
}
.tw-text-red-800 {
  --tw-text-opacity: 1;
  color: rgb(153 27 27 / var(--tw-text-opacity, 1));
}
.tw-text-secondary-foreground {
  color: hsl(var(--secondary-foreground));
}
.tw-text-sidebar-accent-foreground {
  color: hsl(var(--sidebar-accent-foreground));
}
.tw-text-sidebar-foreground {
  color: hsl(var(--sidebar-foreground));
}
.tw-text-sidebar-foreground\\/70 {
  color: hsl(var(--sidebar-foreground) / 0.7);
}
.tw-text-slate-900 {
  --tw-text-opacity: 1;
  color: rgb(15 23 42 / var(--tw-text-opacity, 1));
}
.tw-text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity, 1));
}
.tw-text-yellow-400 {
  --tw-text-opacity: 1;
  color: rgb(250 204 21 / var(--tw-text-opacity, 1));
}
.tw-text-yellow-600 {
  --tw-text-opacity: 1;
  color: rgb(202 138 4 / var(--tw-text-opacity, 1));
}
.tw-text-yellow-700 {
  --tw-text-opacity: 1;
  color: rgb(161 98 7 / var(--tw-text-opacity, 1));
}
.tw-underline {
  text-decoration-line: underline;
}
.tw-line-through {
  text-decoration-line: line-through;
}
.tw-decoration-destructive {
  text-decoration-color: hsl(var(--destructive));
}
.tw-underline-offset-4 {
  text-underline-offset: 4px;
}
.tw-opacity-0 {
  opacity: 0;
}
.tw-opacity-100 {
  opacity: 1;
}
.tw-opacity-50 {
  opacity: 0.5;
}
.tw-opacity-60 {
  opacity: 0.6;
}
.tw-opacity-70 {
  opacity: 0.7;
}
.tw-shadow {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-shadow-\\[0_0_0_1px_hsl\\(var\\(--sidebar-border\\)\\)\\] {
  --tw-shadow: 0 0 0 1px hsl(var(--sidebar-border));
  --tw-shadow-colored: 0 0 0 1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-shadow-lg {
  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-shadow-md {
  --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-shadow-none {
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-shadow-sm {
  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-outline-none {
  outline: 2px solid transparent;
  outline-offset: 2px;
}
.tw-ring-0 {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.tw-ring-2 {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.tw-ring-primary {
  --tw-ring-color: hsl(var(--primary));
}
.tw-ring-sidebar-ring {
  --tw-ring-color: hsl(var(--sidebar-ring));
}
.tw-ring-offset-2 {
  --tw-ring-offset-width: 2px;
}
.tw-ring-offset-background {
  --tw-ring-offset-color: hsl(var(--background));
}
.tw-drop-shadow-sm {
  --tw-drop-shadow: drop-shadow(0 1px 1px rgb(0 0 0 / 0.05));
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.tw-transition {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-\\[left\\,right\\,width\\] {
  transition-property: left,right,width;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-\\[margin\\,opa\\] {
  transition-property: margin,opa;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-\\[width\\,height\\,padding\\] {
  transition-property: width,height,padding;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-\\[width\\] {
  transition-property: width;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-colors {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-opacity {
  transition-property: opacity;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-transform {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-duration-200 {
  transition-duration: 200ms;
}
.tw-ease-linear {
  transition-timing-function: linear;
}
@keyframes enter {

  from {
    opacity: var(--tw-enter-opacity, 1);
    transform: translate3d(var(--tw-enter-translate-x, 0), var(--tw-enter-translate-y, 0), 0) scale3d(var(--tw-enter-scale, 1), var(--tw-enter-scale, 1), var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0));
  }
}
@keyframes exit {

  to {
    opacity: var(--tw-exit-opacity, 1);
    transform: translate3d(var(--tw-exit-translate-x, 0), var(--tw-exit-translate-y, 0), 0) scale3d(var(--tw-exit-scale, 1), var(--tw-exit-scale, 1), var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0));
  }
}
.tw-animate-in {
  animation-name: enter;
  animation-duration: 150ms;
  --tw-enter-opacity: initial;
  --tw-enter-scale: initial;
  --tw-enter-rotate: initial;
  --tw-enter-translate-x: initial;
  --tw-enter-translate-y: initial;
}
.tw-fade-in-0 {
  --tw-enter-opacity: 0;
}
.tw-fade-in-80 {
  --tw-enter-opacity: 0.8;
}
.tw-zoom-in-95 {
  --tw-enter-scale: .95;
}
.tw-duration-200 {
  animation-duration: 200ms;
}
.tw-ease-linear {
  animation-timing-function: linear;
}
.tw-\\@container\\/tab-toolbar-center {
  container-type: inline-size;
  container-name: tab-toolbar-center;
}
.tw-\\@container\\/tab-toolbar-end {
  container-type: inline-size;
  container-name: tab-toolbar-end;
}
.tw-\\@container\\/tab-toolbar-start {
  container-type: inline-size;
  container-name: tab-toolbar-start;
}
.tw-\\@container\\/toolbar {
  container-type: inline-size;
  container-name: toolbar;
}
.\\[--lexical-indent-base-value\\:40px\\] {
  --lexical-indent-base-value: 40px;
}

/*
 * WARNING: These themes are also represented in paranext-core/src/shared/data/themes.data.json!
 * Please update in both locations
*/
/* #region shared with https://github.com/paranext/paranext-extension-template/blob/main/src/tailwind.css */
/* #endregion */

/* Note that the following region is from shadcn/ui's styles
 * https://ui.shadcn.com/docs/installation/manual#configure-styles but is scoped down to .pr-twp
 * because this is just a component library and should not apply its styles to the entire page.
 *
 * There is now a section in this library's README.md that explains how to apply these styles to the
 * entire page if desired.
 *
 * The template has the original shadcn/ui styles because it intentionally applies the styles to the
 * entire page. The same is true for Platform.Bible - see \`app.component.scss\`
 */
/* #region shared with https://github.com/paranext/paranext-extension-template/blob/main/src/tailwind.css but with the difference of being scoped to .pr-twp here */
.file\\:tw-border-0::file-selector-button {
  border-width: 0px;
}
.file\\:tw-bg-transparent::file-selector-button {
  background-color: transparent;
}
.file\\:tw-text-sm::file-selector-button {
  font-size: 0.875rem;
  line-height: 1.25rem;
}
.file\\:tw-font-medium::file-selector-button {
  font-weight: 500;
}
.file\\:tw-text-foreground::file-selector-button {
  color: hsl(var(--foreground));
}
.placeholder\\:tw-text-muted-foreground::placeholder {
  color: hsl(var(--muted-foreground));
}
.before\\:tw-absolute::before {
  content: var(--tw-content);
  position: absolute;
}
.before\\:tw-left-0::before {
  content: var(--tw-content);
  left: 0px;
}
.before\\:tw-top-0\\.5::before {
  content: var(--tw-content);
  top: 0.125rem;
}
.before\\:tw-block::before {
  content: var(--tw-content);
  display: block;
}
.before\\:tw-hidden::before {
  content: var(--tw-content);
  display: none;
}
.before\\:tw-h-4::before {
  content: var(--tw-content);
  height: 1rem;
}
.before\\:tw-w-4::before {
  content: var(--tw-content);
  width: 1rem;
}
.before\\:tw-cursor-pointer::before {
  content: var(--tw-content);
  cursor: pointer;
}
.before\\:tw-rounded::before {
  content: var(--tw-content);
  border-radius: 0.25rem;
}
.before\\:tw-border::before {
  content: var(--tw-content);
  border-width: 1px;
}
.before\\:tw-border-primary::before {
  content: var(--tw-content);
  border-color: hsl(var(--primary));
}
.before\\:tw-bg-primary::before {
  content: var(--tw-content);
  background-color: hsl(var(--primary));
}
.before\\:tw-bg-cover::before {
  content: var(--tw-content);
  background-size: cover;
}
.before\\:tw-bg-no-repeat::before {
  content: var(--tw-content);
  background-repeat: no-repeat;
}
.before\\:tw-content-\\[\\"\\"\\]::before {
  --tw-content: "";
  content: var(--tw-content);
}
.after\\:tw-absolute::after {
  content: var(--tw-content);
  position: absolute;
}
.after\\:tw--inset-2::after {
  content: var(--tw-content);
  inset: -0.5rem;
}
.after\\:tw-inset-y-0::after {
  content: var(--tw-content);
  top: 0px;
  bottom: 0px;
}
.after\\:tw-left-1\\/2::after {
  content: var(--tw-content);
  left: 50%;
}
.after\\:tw-left-\\[7px\\]::after {
  content: var(--tw-content);
  left: 7px;
}
.after\\:tw-right-\\[7px\\]::after {
  content: var(--tw-content);
  right: 7px;
}
.after\\:tw-top-\\[6px\\]::after {
  content: var(--tw-content);
  top: 6px;
}
.after\\:tw-block::after {
  content: var(--tw-content);
  display: block;
}
.after\\:tw-hidden::after {
  content: var(--tw-content);
  display: none;
}
.after\\:tw-h-0\\.5::after {
  content: var(--tw-content);
  height: 0.125rem;
}
.after\\:tw-h-\\[6px\\]::after {
  content: var(--tw-content);
  height: 6px;
}
.after\\:tw-w-1::after {
  content: var(--tw-content);
  width: 0.25rem;
}
.after\\:tw-w-\\[2px\\]::after {
  content: var(--tw-content);
  width: 2px;
}
.after\\:tw-w-\\[3px\\]::after {
  content: var(--tw-content);
  width: 3px;
}
.after\\:tw--translate-x-1\\/2::after {
  content: var(--tw-content);
  --tw-translate-x: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.after\\:tw-rotate-45::after {
  content: var(--tw-content);
  --tw-rotate: 45deg;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.after\\:tw-cursor-pointer::after {
  content: var(--tw-content);
  cursor: pointer;
}
.after\\:tw-border-b-2::after {
  content: var(--tw-content);
  border-bottom-width: 2px;
}
.after\\:tw-border-l-0::after {
  content: var(--tw-content);
  border-left-width: 0px;
}
.after\\:tw-border-r-2::after {
  content: var(--tw-content);
  border-right-width: 2px;
}
.after\\:tw-border-t-0::after {
  content: var(--tw-content);
  border-top-width: 0px;
}
.after\\:tw-border-solid::after {
  content: var(--tw-content);
  border-style: solid;
}
.after\\:tw-border-white::after {
  content: var(--tw-content);
  --tw-border-opacity: 1;
  border-color: rgb(255 255 255 / var(--tw-border-opacity, 1));
}
.after\\:tw-bg-muted::after {
  content: var(--tw-content);
  background-color: hsl(var(--muted));
}
.after\\:tw-content-\\[\\"\\"\\]::after {
  --tw-content: "";
  content: var(--tw-content);
}
.first\\:tw-mt-0:first-child {
  margin-top: 0px;
}
.even\\:tw-bg-muted:nth-child(even) {
  background-color: hsl(var(--muted));
}
.hover\\:tw-cursor-pointer:hover {
  cursor: pointer;
}
.hover\\:tw-bg-accent:hover {
  background-color: hsl(var(--accent));
}
.hover\\:tw-bg-blue-600:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(37 99 235 / var(--tw-bg-opacity, 1));
}
.hover\\:tw-bg-destructive\\/80:hover {
  background-color: hsl(var(--destructive) / 0.8);
}
.hover\\:tw-bg-destructive\\/90:hover {
  background-color: hsl(var(--destructive) / 0.9);
}
.hover\\:tw-bg-input:hover {
  background-color: hsl(var(--input));
}
.hover\\:tw-bg-muted:hover {
  background-color: hsl(var(--muted));
}
.hover\\:tw-bg-muted\\/50:hover {
  background-color: hsl(var(--muted) / 0.5);
}
.hover\\:tw-bg-muted\\/80:hover {
  background-color: hsl(var(--muted) / 0.8);
}
.hover\\:tw-bg-primary\\/70:hover {
  background-color: hsl(var(--primary) / 0.7);
}
.hover\\:tw-bg-primary\\/80:hover {
  background-color: hsl(var(--primary) / 0.8);
}
.hover\\:tw-bg-primary\\/90:hover {
  background-color: hsl(var(--primary) / 0.9);
}
.hover\\:tw-bg-secondary:hover {
  background-color: hsl(var(--secondary));
}
.hover\\:tw-bg-secondary\\/80:hover {
  background-color: hsl(var(--secondary) / 0.8);
}
.hover\\:tw-bg-sidebar-accent:hover {
  background-color: hsl(var(--sidebar-accent));
}
.hover\\:tw-bg-transparent:hover {
  background-color: transparent;
}
.hover\\:tw-text-accent-foreground:hover {
  color: hsl(var(--accent-foreground));
}
.hover\\:tw-text-foreground:hover {
  color: hsl(var(--foreground));
}
.hover\\:tw-text-muted-foreground:hover {
  color: hsl(var(--muted-foreground));
}
.hover\\:tw-text-primary-foreground:hover {
  color: hsl(var(--primary-foreground));
}
.hover\\:tw-text-sidebar-accent-foreground:hover {
  color: hsl(var(--sidebar-accent-foreground));
}
.hover\\:tw-underline:hover {
  text-decoration-line: underline;
}
.hover\\:tw-opacity-100:hover {
  opacity: 1;
}
.hover\\:tw-opacity-80:hover {
  opacity: 0.8;
}
.hover\\:tw-shadow-\\[0_0_0_1px_hsl\\(var\\(--sidebar-accent\\)\\)\\]:hover {
  --tw-shadow: 0 0 0 1px hsl(var(--sidebar-accent));
  --tw-shadow-colored: 0 0 0 1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.hover\\:tw-shadow-md:hover {
  --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.hover\\:after\\:tw-bg-sidebar-border:hover::after {
  content: var(--tw-content);
  background-color: hsl(var(--sidebar-border));
}
.focus\\:tw-relative:focus {
  position: relative;
}
.focus\\:tw-z-10:focus {
  z-index: 10;
}
.focus\\:tw-bg-accent:focus {
  background-color: hsl(var(--accent));
}
.focus\\:tw-bg-muted:focus {
  background-color: hsl(var(--muted));
}
.focus\\:tw-text-accent-foreground:focus {
  color: hsl(var(--accent-foreground));
}
.focus\\:tw-text-foreground:focus {
  color: hsl(var(--foreground));
}
.focus\\:tw-outline-none:focus {
  outline: 2px solid transparent;
  outline-offset: 2px;
}
.focus\\:tw-ring-2:focus {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus\\:tw-ring-ring:focus {
  --tw-ring-color: hsl(var(--ring));
}
.focus\\:tw-ring-offset-1:focus {
  --tw-ring-offset-width: 1px;
}
.focus\\:tw-ring-offset-2:focus {
  --tw-ring-offset-width: 2px;
}
.focus\\:tw-ring-offset-background:focus {
  --tw-ring-offset-color: hsl(var(--background));
}
.focus-visible\\:tw-relative:focus-visible {
  position: relative;
}
.focus-visible\\:tw-z-10:focus-visible {
  z-index: 10;
}
.focus-visible\\:tw-outline-none:focus-visible {
  outline: 2px solid transparent;
  outline-offset: 2px;
}
.focus-visible\\:tw-ring-1:focus-visible {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus-visible\\:tw-ring-2:focus-visible {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus-visible\\:tw-ring-\\[color\\:hsl\\(2400o2c 5\\%0o2c 64\\.9\\%\\)\\]:focus-visible {
  --tw-ring-opacity: 1;
  --tw-ring-color: hsl(240 5% 64.9% / var(--tw-ring-opacity, 1));
}
.focus-visible\\:tw-ring-ring:focus-visible {
  --tw-ring-color: hsl(var(--ring));
}
.focus-visible\\:tw-ring-sidebar-ring:focus-visible {
  --tw-ring-color: hsl(var(--sidebar-ring));
}
.focus-visible\\:tw-ring-offset-1:focus-visible {
  --tw-ring-offset-width: 1px;
}
.focus-visible\\:tw-ring-offset-2:focus-visible {
  --tw-ring-offset-width: 2px;
}
.focus-visible\\:tw-ring-offset-background:focus-visible {
  --tw-ring-offset-color: hsl(var(--background));
}
.active\\:tw-bg-sidebar-accent:active {
  background-color: hsl(var(--sidebar-accent));
}
.active\\:tw-text-sidebar-accent-foreground:active {
  color: hsl(var(--sidebar-accent-foreground));
}
.disabled\\:tw-pointer-events-none:disabled {
  pointer-events: none;
}
.disabled\\:tw-cursor-not-allowed:disabled {
  cursor: not-allowed;
}
.disabled\\:tw-opacity-50:disabled {
  opacity: 0.5;
}
.tw-peer:disabled ~ .peer-disabled\\:tw-cursor-not-allowed {
  cursor: not-allowed;
}
.tw-peer:disabled ~ .peer-disabled\\:tw-opacity-70 {
  opacity: 0.7;
}
.has-\\[\\>\\[data-slot\\=button-group\\]\\]\\:tw-gap-2:has(>[data-slot=button-group]) {
  gap: 0.5rem;
}
.has-\\[\\[data-variant\\=inset\\]\\]\\:tw-bg-sidebar:has([data-variant=inset]) {
  background-color: hsl(var(--sidebar-background));
}
.aria-disabled\\:tw-pointer-events-none[aria-disabled="true"] {
  pointer-events: none;
}
.aria-disabled\\:tw-opacity-50[aria-disabled="true"] {
  opacity: 0.5;
}
.data-\\[disabled\\=true\\]\\:tw-pointer-events-none[data-disabled="true"] {
  pointer-events: none;
}
.data-\\[disabled\\]\\:tw-pointer-events-none[data-disabled] {
  pointer-events: none;
}
.data-\\[orientation\\=vertical\\]\\:tw-h-auto[data-orientation="vertical"] {
  height: auto;
}
.data-\\[panel-group-direction\\=vertical\\]\\:tw-h-px[data-panel-group-direction="vertical"] {
  height: 1px;
}
.data-\\[panel-group-direction\\=vertical\\]\\:tw-w-full[data-panel-group-direction="vertical"] {
  width: 100%;
}
.data-\\[side\\=bottom\\]\\:tw-translate-y-1[data-side="bottom"] {
  --tw-translate-y: 0.25rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[side\\=left\\]\\:tw--translate-x-1[data-side="left"] {
  --tw-translate-x: -0.25rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[side\\=right\\]\\:tw-translate-x-1[data-side="right"] {
  --tw-translate-x: 0.25rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[side\\=top\\]\\:tw--translate-y-1[data-side="top"] {
  --tw-translate-y: -0.25rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[state\\=checked\\]\\:tw-translate-x-5[data-state="checked"] {
  --tw-translate-x: 1.25rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[state\\=checked\\]\\:tw-translate-x-\\[-20px\\][data-state="checked"] {
  --tw-translate-x: -20px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[state\\=unchecked\\]\\:tw-translate-x-0[data-state="unchecked"] {
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[panel-group-direction\\=vertical\\]\\:tw-flex-col[data-panel-group-direction="vertical"] {
  flex-direction: column;
}
.data-\\[active\\=true\\]\\:tw-bg-sidebar-accent[data-active="true"] {
  background-color: hsl(var(--sidebar-accent));
}
.data-\\[selected\\=true\\]\\:tw-bg-accent[data-selected="true"] {
  background-color: hsl(var(--accent));
}
.data-\\[state\\=active\\]\\:tw-bg-background[data-state="active"] {
  background-color: hsl(var(--background));
}
.data-\\[state\\=checked\\]\\:tw-bg-primary[data-state="checked"] {
  background-color: hsl(var(--primary));
}
.data-\\[state\\=on\\]\\:tw-bg-accent[data-state="on"] {
  background-color: hsl(var(--accent));
}
.data-\\[state\\=open\\]\\:tw-bg-accent[data-state="open"] {
  background-color: hsl(var(--accent));
}
.data-\\[state\\=open\\]\\:tw-bg-muted[data-state="open"] {
  background-color: hsl(var(--muted));
}
.data-\\[state\\=selected\\]\\:tw-bg-muted[data-state="selected"] {
  background-color: hsl(var(--muted));
}
.data-\\[state\\=unchecked\\]\\:tw-bg-input[data-state="unchecked"] {
  background-color: hsl(var(--input));
}
.data-\\[active\\=true\\]\\:tw-font-medium[data-active="true"] {
  font-weight: 500;
}
.data-\\[active\\=true\\]\\:tw-text-sidebar-accent-foreground[data-active="true"] {
  color: hsl(var(--sidebar-accent-foreground));
}
.data-\\[selected\\=true\\]\\:tw-text-accent-foreground[data-selected="true"] {
  color: hsl(var(--accent-foreground));
}
.data-\\[state\\=active\\]\\:tw-text-foreground[data-state="active"] {
  color: hsl(var(--foreground));
}
.data-\\[state\\=checked\\]\\:tw-text-primary-foreground[data-state="checked"] {
  color: hsl(var(--primary-foreground));
}
.data-\\[state\\=on\\]\\:tw-text-accent-foreground[data-state="on"] {
  color: hsl(var(--accent-foreground));
}
.data-\\[state\\=open\\]\\:tw-text-accent-foreground[data-state="open"] {
  color: hsl(var(--accent-foreground));
}
.data-\\[state\\=open\\]\\:tw-text-foreground[data-state="open"] {
  color: hsl(var(--foreground));
}
.data-\\[state\\=open\\]\\:tw-text-muted-foreground[data-state="open"] {
  color: hsl(var(--muted-foreground));
}
.data-\\[disabled\\=true\\]\\:tw-opacity-50[data-disabled="true"] {
  opacity: 0.5;
}
.data-\\[disabled\\]\\:tw-opacity-50[data-disabled] {
  opacity: 0.5;
}
.data-\\[state\\=open\\]\\:tw-opacity-100[data-state="open"] {
  opacity: 1;
}
.data-\\[state\\=active\\]\\:tw-shadow-sm[data-state="active"] {
  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.data-\\[state\\=open\\]\\:tw-animate-in[data-state="open"] {
  animation-name: enter;
  animation-duration: 150ms;
  --tw-enter-opacity: initial;
  --tw-enter-scale: initial;
  --tw-enter-rotate: initial;
  --tw-enter-translate-x: initial;
  --tw-enter-translate-y: initial;
}
.data-\\[state\\=closed\\]\\:tw-animate-out[data-state="closed"] {
  animation-name: exit;
  animation-duration: 150ms;
  --tw-exit-opacity: initial;
  --tw-exit-scale: initial;
  --tw-exit-rotate: initial;
  --tw-exit-translate-x: initial;
  --tw-exit-translate-y: initial;
}
.data-\\[state\\=closed\\]\\:tw-fade-out-0[data-state="closed"] {
  --tw-exit-opacity: 0;
}
.data-\\[state\\=open\\]\\:tw-fade-in-0[data-state="open"] {
  --tw-enter-opacity: 0;
}
.data-\\[state\\=closed\\]\\:tw-zoom-out-95[data-state="closed"] {
  --tw-exit-scale: .95;
}
.data-\\[state\\=open\\]\\:tw-zoom-in-95[data-state="open"] {
  --tw-enter-scale: .95;
}
.data-\\[side\\=bottom\\]\\:tw-slide-in-from-top-2[data-side="bottom"] {
  --tw-enter-translate-y: -0.5rem;
}
.data-\\[side\\=left\\]\\:tw-slide-in-from-right-2[data-side="left"] {
  --tw-enter-translate-x: 0.5rem;
}
.data-\\[side\\=right\\]\\:tw-slide-in-from-left-2[data-side="right"] {
  --tw-enter-translate-x: -0.5rem;
}
.data-\\[side\\=top\\]\\:tw-slide-in-from-bottom-2[data-side="top"] {
  --tw-enter-translate-y: 0.5rem;
}
.data-\\[state\\=closed\\]\\:tw-slide-out-to-left-1\\/2[data-state="closed"] {
  --tw-exit-translate-x: -50%;
}
.data-\\[state\\=closed\\]\\:tw-slide-out-to-top-\\[48\\%\\][data-state="closed"] {
  --tw-exit-translate-y: -48%;
}
.data-\\[state\\=open\\]\\:tw-slide-in-from-left-1\\/2[data-state="open"] {
  --tw-enter-translate-x: -50%;
}
.data-\\[state\\=open\\]\\:tw-slide-in-from-top-\\[48\\%\\][data-state="open"] {
  --tw-enter-translate-y: -48%;
}
.data-\\[panel-group-direction\\=vertical\\]\\:after\\:tw-left-0[data-panel-group-direction="vertical"]::after {
  content: var(--tw-content);
  left: 0px;
}
.data-\\[panel-group-direction\\=vertical\\]\\:after\\:tw-h-1[data-panel-group-direction="vertical"]::after {
  content: var(--tw-content);
  height: 0.25rem;
}
.data-\\[panel-group-direction\\=vertical\\]\\:after\\:tw-w-full[data-panel-group-direction="vertical"]::after {
  content: var(--tw-content);
  width: 100%;
}
.data-\\[panel-group-direction\\=vertical\\]\\:after\\:tw--translate-y-1\\/2[data-panel-group-direction="vertical"]::after {
  content: var(--tw-content);
  --tw-translate-y: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[panel-group-direction\\=vertical\\]\\:after\\:tw-translate-x-0[data-panel-group-direction="vertical"]::after {
  content: var(--tw-content);
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[state\\=open\\]\\:hover\\:tw-bg-sidebar-accent:hover[data-state="open"] {
  background-color: hsl(var(--sidebar-accent));
}
.data-\\[state\\=open\\]\\:hover\\:tw-text-sidebar-accent-foreground:hover[data-state="open"] {
  color: hsl(var(--sidebar-accent-foreground));
}
.tw-group[data-collapsible="offcanvas"] .group-data-\\[collapsible\\=offcanvas\\]\\:tw-left-\\[calc\\(var\\(--sidebar-width\\)\\*-1\\)\\] {
  left: calc(var(--sidebar-width) * -1);
}
.tw-group[data-collapsible="offcanvas"] .group-data-\\[collapsible\\=offcanvas\\]\\:tw-right-\\[calc\\(var\\(--sidebar-width\\)\\*-1\\)\\] {
  right: calc(var(--sidebar-width) * -1);
}
.tw-group[data-side="primary"] .group-data-\\[side\\=primary\\]\\:tw--right-4 {
  right: -1rem;
}
.tw-group[data-side="secondary"] .group-data-\\[side\\=secondary\\]\\:tw-left-0 {
  left: 0px;
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw--mt-8 {
  margin-top: -2rem;
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw-hidden {
  display: none;
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw-w-\\[--sidebar-width-icon\\] {
  width: var(--sidebar-width-icon);
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw-w-\\[calc\\(var\\(--sidebar-width-icon\\)_\\+_theme\\(spacing\\.4\\)\\)\\] {
  width: calc(var(--sidebar-width-icon) + 1rem);
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw-w-\\[calc\\(var\\(--sidebar-width-icon\\)_\\+_theme\\(spacing\\.4\\)_\\+2px\\)\\] {
  width: calc(var(--sidebar-width-icon) + 1rem + 2px);
}
.tw-group[data-collapsible="offcanvas"] .group-data-\\[collapsible\\=offcanvas\\]\\:tw-w-0 {
  width: 0px;
}
.tw-group[data-collapsible="offcanvas"] .group-data-\\[collapsible\\=offcanvas\\]\\:tw-translate-x-0 {
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-group[data-side="secondary"] .group-data-\\[side\\=secondary\\]\\:tw-rotate-180 {
  --tw-rotate: 180deg;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw-overflow-hidden {
  overflow: hidden;
}
.tw-group[data-variant="floating"] .group-data-\\[variant\\=floating\\]\\:tw-rounded-lg {
  border-radius: var(--radius);
}
.tw-group[data-variant="floating"] .group-data-\\[variant\\=floating\\]\\:tw-border {
  border-width: 1px;
}
.tw-group[data-side="primary"] .group-data-\\[side\\=primary\\]\\:tw-border-r {
  border-right-width: 1px;
}
.tw-group[data-side="secondary"] .group-data-\\[side\\=secondary\\]\\:tw-border-l {
  border-left-width: 1px;
}
.tw-group[data-variant="floating"] .group-data-\\[variant\\=floating\\]\\:tw-border-sidebar-border {
  border-color: hsl(var(--sidebar-border));
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw-opacity-0 {
  opacity: 0;
}
.tw-group[data-variant="floating"] .group-data-\\[variant\\=floating\\]\\:tw-shadow {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-group[data-collapsible="offcanvas"] .group-data-\\[collapsible\\=offcanvas\\]\\:after\\:tw-left-full::after {
  content: var(--tw-content);
  left: 100%;
}
.tw-group[data-collapsible="offcanvas"] .group-data-\\[collapsible\\=offcanvas\\]\\:hover\\:tw-bg-sidebar:hover {
  background-color: hsl(var(--sidebar-background));
}
.tw-peer[data-variant="inset"] ~ .peer-data-\\[variant\\=inset\\]\\:tw-min-h-\\[calc\\(100svh-theme\\(spacing\\.4\\)\\)\\] {
  min-height: calc(100svh - 1rem);
}
@container (min-width: 24rem) {

  .\\@sm\\:tw-grow {
    flex-grow: 1;
  }

  .\\@sm\\:tw-basis-auto {
    flex-basis: auto;
  }
}
@media (min-width: 640px) {

  .sm\\:tw-flex {
    display: flex;
  }

  .sm\\:tw-flex-row {
    flex-direction: row;
  }

  .sm\\:tw-justify-end {
    justify-content: flex-end;
  }

  .sm\\:tw-space-x-2 > :not([hidden]) ~ :not([hidden]) {
    --tw-space-x-reverse: 0;
    margin-right: calc(0.5rem * var(--tw-space-x-reverse));
    margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
  }

  .sm\\:tw-rounded-lg {
    border-radius: var(--radius);
  }

  .sm\\:tw-text-left {
    text-align: left;
  }

  .sm\\:tw-text-start {
    text-align: start;
  }
}
@media (min-width: 768px) {

  .md\\:tw-block {
    display: block;
  }

  .md\\:tw-flex {
    display: flex;
  }

  .md\\:tw-grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .md\\:tw-text-sm {
    font-size: 0.875rem;
    line-height: 1.25rem;
  }

  .md\\:tw-opacity-0 {
    opacity: 0;
  }

  .after\\:md\\:tw-hidden::after {
    content: var(--tw-content);
    display: none;
  }

  .tw-peer[data-variant="inset"] ~ .md\\:peer-data-\\[variant\\=inset\\]\\:tw-m-2 {
    margin: 0.5rem;
  }

  .tw-peer[data-state="collapsed"][data-variant="inset"] ~ .md\\:peer-data-\\[state\\=collapsed\\]\\:peer-data-\\[variant\\=inset\\]\\:tw-ml-2 {
    margin-left: 0.5rem;
  }

  .tw-peer[data-variant="inset"] ~ .md\\:peer-data-\\[variant\\=inset\\]\\:tw-ml-0 {
    margin-left: 0px;
  }

  .tw-peer[data-variant="inset"] ~ .md\\:peer-data-\\[variant\\=inset\\]\\:tw-rounded-xl {
    border-radius: 0.75rem;
  }

  .tw-peer[data-variant="inset"] ~ .md\\:peer-data-\\[variant\\=inset\\]\\:tw-shadow {
    --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
    --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
  }
}
@media (min-width: 1024px) {

  .lg\\:tw-flex {
    display: flex;
  }

  .lg\\:tw-grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .lg\\:tw-space-x-8 > :not([hidden]) ~ :not([hidden]) {
    --tw-space-x-reverse: 0;
    margin-right: calc(2rem * var(--tw-space-x-reverse));
    margin-left: calc(2rem * calc(1 - var(--tw-space-x-reverse)));
  }

  .lg\\:tw-text-5xl {
    font-size: 3rem;
    line-height: 1;
  }
}
.ltr\\:tw-left-2:where([dir="ltr"], [dir="ltr"] *) {
  left: 0.5rem;
}
.rtl\\:tw-right-2:where([dir="rtl"], [dir="rtl"] *) {
  right: 0.5rem;
}
@media (prefers-color-scheme: dark) {

  .dark\\:tw-border-destructive {
    border-color: hsl(var(--destructive));
  }
}
.\\[\\&\\:has\\(\\[role\\=checkbox\\]\\)\\]\\:tw-pe-0:has([role=checkbox]) {
  padding-inline-end: 0px;
}
.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:tw-rounded-l-none>*:not(:first-child) {
  border-top-left-radius: 0px;
  border-bottom-left-radius: 0px;
}
.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:tw-rounded-t-none>*:not(:first-child) {
  border-top-left-radius: 0px;
  border-top-right-radius: 0px;
}
.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:tw-border-l-0>*:not(:first-child) {
  border-left-width: 0px;
}
.\\[\\&\\>\\*\\:not\\(\\:first-child\\)\\]\\:tw-border-t-0>*:not(:first-child) {
  border-top-width: 0px;
}
.\\[\\&\\>\\*\\:not\\(\\:last-child\\)\\]\\:tw-rounded-b-none>*:not(:last-child) {
  border-bottom-right-radius: 0px;
  border-bottom-left-radius: 0px;
}
.\\[\\&\\>\\*\\:not\\(\\:last-child\\)\\]\\:tw-rounded-r-none>*:not(:last-child) {
  border-top-right-radius: 0px;
  border-bottom-right-radius: 0px;
}
.\\[\\&\\>\\*\\]\\:focus-visible\\:tw-relative:focus-visible>* {
  position: relative;
}
.\\[\\&\\>\\*\\]\\:focus-visible\\:tw-z-10:focus-visible>* {
  z-index: 10;
}
.has-\\[select\\[aria-hidden\\=true\\]\\:last-child\\]\\:\\[\\&\\>\\[data-slot\\=select-trigger\\]\\:last-of-type\\]\\:tw-rounded-r-md>[data-slot=select-trigger]:last-of-type:has(select[aria-hidden=true]:last-child) {
  border-top-right-radius: calc(var(--radius) - 2px);
  border-bottom-right-radius: calc(var(--radius) - 2px);
}
.\\[\\&\\>\\[data-slot\\=select-trigger\\]\\:not\\(\\[class\\*\\=w-\\]\\)\\]\\:tw-w-fit>[data-slot=select-trigger]:not([class*=w-]) {
  width: fit-content;
}
.\\[\\&\\>img\\+div\\]\\:tw-translate-y-\\[-3px\\]>img+div {
  --tw-translate-y: -3px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.\\[\\&\\>img\\]\\:tw-absolute>img {
  position: absolute;
}
.\\[\\&\\>img\\]\\:tw-left-4>img {
  left: 1rem;
}
.\\[\\&\\>img\\]\\:tw-top-4>img {
  top: 1rem;
}
.\\[\\&\\>img\\]\\:tw-text-destructive>img {
  color: hsl(var(--destructive));
}
.\\[\\&\\>img\\]\\:tw-text-foreground>img {
  color: hsl(var(--foreground));
}
.\\[\\&\\>img\\~\\*\\]\\:tw-pl-7>img~* {
  padding-left: 1.75rem;
}
.\\[\\&\\>input\\]\\:tw-flex-1>input {
  flex: 1 1 0%;
}
.\\[\\&\\>li\\]\\:tw-mt-2>li {
  margin-top: 0.5rem;
}
.\\[\\&\\>span\\:last-child\\]\\:tw-truncate>span:last-child {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.\\[\\&\\>span\\]\\:tw-line-clamp-1>span {
  overflow: hidden;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 1;
}
.\\[\\&\\>svg\\+div\\]\\:tw-translate-y-\\[-3px\\]>svg+div {
  --tw-translate-y: -3px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.\\[\\&\\>svg\\]\\:tw-absolute>svg {
  position: absolute;
}
.\\[\\&\\>svg\\]\\:tw-left-4>svg {
  left: 1rem;
}
.\\[\\&\\>svg\\]\\:tw-top-4>svg {
  top: 1rem;
}
.\\[\\&\\>svg\\]\\:tw-size-4>svg {
  width: 1rem;
  height: 1rem;
}
.\\[\\&\\>svg\\]\\:tw-shrink-0>svg {
  flex-shrink: 0;
}
.\\[\\&\\>svg\\]\\:tw-text-destructive>svg {
  color: hsl(var(--destructive));
}
.\\[\\&\\>svg\\]\\:tw-text-foreground>svg {
  color: hsl(var(--foreground));
}
.\\[\\&\\>svg\\]\\:tw-text-sidebar-accent-foreground>svg {
  color: hsl(var(--sidebar-accent-foreground));
}
.\\[\\&\\>svg\\~\\*\\]\\:tw-pl-7>svg~* {
  padding-left: 1.75rem;
}
.\\[\\&\\>tr\\]\\:last\\:tw-border-b-0:last-child>tr {
  border-bottom-width: 0px;
}
.\\[\\&\\[align\\=center\\]\\]\\:tw-text-center[align=center] {
  text-align: center;
}
.\\[\\&\\[align\\=right\\]\\]\\:tw-text-right[align=right] {
  text-align: right;
}
.\\[\\&\\[data-panel-group-direction\\=vertical\\]\\>div\\]\\:tw-rotate-90[data-panel-group-direction=vertical]>div {
  --tw-rotate: 90deg;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.\\[\\&_\\[cmdk-group-heading\\]\\]\\:tw-px-2 [cmdk-group-heading] {
  padding-left: 0.5rem;
  padding-right: 0.5rem;
}
.\\[\\&_\\[cmdk-group-heading\\]\\]\\:tw-py-1\\.5 [cmdk-group-heading] {
  padding-top: 0.375rem;
  padding-bottom: 0.375rem;
}
.\\[\\&_\\[cmdk-group-heading\\]\\]\\:tw-text-xs [cmdk-group-heading] {
  font-size: 0.75rem;
  line-height: 1rem;
}
.\\[\\&_\\[cmdk-group-heading\\]\\]\\:tw-font-medium [cmdk-group-heading] {
  font-weight: 500;
}
.\\[\\&_\\[cmdk-group-heading\\]\\]\\:tw-text-muted-foreground [cmdk-group-heading] {
  color: hsl(var(--muted-foreground));
}
.\\[\\&_\\[cmdk-group\\]\\:not\\(\\[hidden\\]\\)_\\~\\[cmdk-group\\]\\]\\:tw-pt-0 [cmdk-group]:not([hidden]) ~[cmdk-group] {
  padding-top: 0px;
}
.\\[\\&_\\[cmdk-group\\]\\]\\:tw-px-2 [cmdk-group] {
  padding-left: 0.5rem;
  padding-right: 0.5rem;
}
.\\[\\&_\\[cmdk-input-wrapper\\]_svg\\]\\:tw-h-5 [cmdk-input-wrapper] svg {
  height: 1.25rem;
}
.\\[\\&_\\[cmdk-input-wrapper\\]_svg\\]\\:tw-w-5 [cmdk-input-wrapper] svg {
  width: 1.25rem;
}
.\\[\\&_\\[cmdk-input\\]\\]\\:tw-h-12 [cmdk-input] {
  height: 3rem;
}
.\\[\\&_\\[cmdk-item\\]\\]\\:tw-px-2 [cmdk-item] {
  padding-left: 0.5rem;
  padding-right: 0.5rem;
}
.\\[\\&_\\[cmdk-item\\]\\]\\:tw-py-3 [cmdk-item] {
  padding-top: 0.75rem;
  padding-bottom: 0.75rem;
}
.\\[\\&_\\[cmdk-item\\]_svg\\]\\:tw-h-5 [cmdk-item] svg {
  height: 1.25rem;
}
.\\[\\&_\\[cmdk-item\\]_svg\\]\\:tw-w-5 [cmdk-item] svg {
  width: 1.25rem;
}
.\\[\\&_p\\]\\:tw-leading-relaxed p {
  line-height: 1.625;
}
.\\[\\&_svg\\:not\\(\\[class\\*\\=size-\\]\\)\\]\\:tw-size-4 svg:not([class*=size-]) {
  width: 1rem;
  height: 1rem;
}
.\\[\\&_svg\\]\\:tw-pointer-events-none svg {
  pointer-events: none;
}
.\\[\\&_svg\\]\\:tw-size-4 svg {
  width: 1rem;
  height: 1rem;
}
.\\[\\&_svg\\]\\:tw-shrink-0 svg {
  flex-shrink: 0;
}
.\\[\\&_tr\\:last-child\\]\\:tw-border-0 tr:last-child {
  border-width: 0px;
}
.\\[\\&_tr\\]\\:tw-border-b tr {
  border-bottom-width: 1px;
}
[data-side=primary][data-collapsible=offcanvas] .\\[\\[data-side\\=primary\\]\\[data-collapsible\\=offcanvas\\]_\\&\\]\\:tw--right-2 {
  right: -0.5rem;
}
[data-side=primary][data-state=collapsed] .\\[\\[data-side\\=primary\\]\\[data-state\\=collapsed\\]_\\&\\]\\:tw-cursor-e-resize {
  cursor: e-resize;
}
[data-side=secondary][data-collapsible=offcanvas] .\\[\\[data-side\\=secondary\\]\\[data-collapsible\\=offcanvas\\]_\\&\\]\\:tw--left-2 {
  left: -0.5rem;
}
[data-side=secondary][data-state=collapsed] .\\[\\[data-side\\=secondary\\]\\[data-state\\=collapsed\\]_\\&\\]\\:tw-cursor-w-resize {
  cursor: w-resize;
}
[data-side=secondary] .\\[\\[data-side\\=secondary\\]_\\&\\]\\:tw-cursor-e-resize {
  cursor: e-resize;
}
[data-side=secondary] .\\[\\[data-side\\=secondary\\]_\\&\\]\\:tw-cursor-w-resize {
  cursor: w-resize;
}
/* By default the editor is too tall for the footnote editor, even while empty, so this makes it 
   shorter. */
.footnote-editor .editor-input {
  min-height: 75px;
}
.banded-row:hover {
  cursor: pointer;
}

.banded-row[data-state='selected']:hover {
  cursor: default;
}
/* stylelint-disable selector-class-pattern */
/* Lexical editor theme classes use camelCase naming convention */

.EditorTheme__code {
  background-color: transparent;
  font-family: Menlo, Consolas, Monaco, monospace;
  display: block;
  padding: 8px 8px 8px 52px;
  line-height: 1.53;
  font-size: 13px;
  margin: 0;
  margin-top: 8px;
  margin-bottom: 8px;
  overflow-x: auto;
  border: 1px solid #ccc;
  position: relative;
  border-radius: 8px;
  tab-size: 2;
}

.EditorTheme__code::before {
  content: attr(data-gutter);
  position: absolute;
  background-color: transparent;
  border-right: 1px solid #ccc;
  left: 0;
  top: 0;
  padding: 8px;
  color: #777;
  white-space: pre-wrap;
  text-align: right;
  min-width: 25px;
}

.EditorTheme__table {
  border-collapse: collapse;
  border-spacing: 0;
  overflow-y: scroll;
  overflow-x: scroll;
  table-layout: fixed;
  width: fit-content;
  width: 100%;
  margin: 0 0 30px;
}

.EditorTheme__tokenComment {
  color: slategray;
}

.EditorTheme__tokenPunctuation {
  color: #999;
}

.EditorTheme__tokenProperty {
  color: #905;
}

.EditorTheme__tokenSelector {
  color: #690;
}

.EditorTheme__tokenOperator {
  color: #9a6e3a;
}

.EditorTheme__tokenAttr {
  color: #07a;
}

.EditorTheme__tokenVariable {
  color: #e90;
}

.EditorTheme__tokenFunction {
  color: #dd4a68;
}

.Collapsible__container {
  background-color: var(--background);
  border: 1px solid #ccc;
  border-radius: 0.5rem;
  margin-bottom: 0.5rem;
}

.Collapsible__title {
  padding: 0.25rem;
  padding-left: 1rem;
  position: relative;
  font-weight: bold;
  outline: none;
  cursor: pointer;
  list-style-type: disclosure-closed;
  list-style-position: inside;
}

.Collapsible__title p {
  display: inline-flex;
}

.Collapsible__title::marker {
  color: lightgray;
}

.Collapsible__container[open] > .Collapsible__title {
  list-style-type: disclosure-open;
}
`, "after-all");
export {
  IM as Alert,
  PM as AlertDescription,
  LM as AlertTitle,
  bg as Avatar,
  vg as AvatarFallback,
  Tx as AvatarImage,
  I5 as BOOK_CHAPTER_CONTROL_STRING_KEYS,
  L5 as BOOK_SELECTOR_STRING_KEYS,
  ys as Badge,
  R5 as BookChapterControl,
  a2 as BookSelectionMode,
  P5 as BookSelector,
  Ne as Button,
  wd as Card,
  Kw as CardContent,
  f2 as CardDescription,
  h2 as CardFooter,
  d2 as CardHeader,
  p2 as CardTitle,
  s2 as ChapterRangeSelector,
  yp as Checkbox,
  mO as Checklist,
  au as ComboBox,
  Oi as Command,
  kl as CommandEmpty,
  No as CommandGroup,
  Gs as CommandInput,
  Ho as CommandItem,
  Ri as CommandList,
  F5 as CommentList,
  yO as ContextMenu,
  jM as ContextMenuCheckboxItem,
  BM as ContextMenuContent,
  _O as ContextMenuGroup,
  qM as ContextMenuItem,
  VM as ContextMenuLabel,
  CO as ContextMenuPortal,
  kO as ContextMenuRadioGroup,
  UM as ContextMenuRadioItem,
  HM as ContextMenuSeparator,
  zM as ContextMenuShortcut,
  EO as ContextMenuSub,
  FM as ContextMenuSubContent,
  $M as ContextMenuSubTrigger,
  xO as ContextMenuTrigger,
  zx as DataTable,
  GM as Drawer,
  TO as DrawerClose,
  WM as DrawerContent,
  QM as DrawerDescription,
  XM as DrawerFooter,
  JM as DrawerHeader,
  F0 as DrawerOverlay,
  KM as DrawerPortal,
  YM as DrawerTitle,
  NO as DrawerTrigger,
  Dl as DropdownMenu,
  Td as DropdownMenuCheckboxItem,
  Ks as DropdownMenuContent,
  yg as DropdownMenuGroup,
  Cg as DropdownMenuItem,
  Wx as DropdownMenuItemType,
  Ad as DropdownMenuLabel,
  Sx as DropdownMenuPortal,
  Mx as DropdownMenuRadioGroup,
  Eg as DropdownMenuRadioItem,
  Ml as DropdownMenuSeparator,
  Ox as DropdownMenuShortcut,
  Dx as DropdownMenuSub,
  _g as DropdownMenuSubContent,
  xg as DropdownMenuSubTrigger,
  Nd as DropdownMenuTrigger,
  Gx as ERROR_DUMP_STRING_KEYS,
  B5 as ERROR_POPOVER_STRING_KEYS,
  Kx as ErrorDump,
  q5 as ErrorPopover,
  K5 as FOOTNOTE_LIST_STRING_KEYS,
  H5 as Filter,
  j5 as FilterDropdown,
  V5 as Footer,
  G5 as FootnoteEditor,
  HD as FootnoteItem,
  W5 as FootnoteList,
  tO as INVENTORY_STRING_KEYS,
  oa as Input,
  nO as Inventory,
  Lt as Label,
  Nx as MarkdownRenderer,
  U5 as MoreInfo,
  Xx as MultiSelectComboBox,
  fO as NavigationContentSearch,
  Li as Popover,
  M5 as PopoverAnchor,
  zo as PopoverContent,
  Pi as PopoverTrigger,
  ZM as Progress,
  hd as RadioGroup,
  Ka as RadioGroupItem,
  e2 as RecentSearches,
  DO as ResizableHandle,
  SO as ResizablePanel,
  AO as ResizablePanelGroup,
  bO as ResultsCard,
  iO as SCOPE_SELECTOR_STRING_KEYS,
  sO as ScopeSelector,
  oO as ScriptureResultsViewer,
  aO as ScrollGroupSelector,
  xp as SearchBar,
  wi as Select,
  So as SelectContent,
  Ix as SelectGroup,
  Dn as SelectItem,
  Px as SelectLabel,
  Ng as SelectScrollDownButton,
  kg as SelectScrollUpButton,
  $x as SelectSeparator,
  Ao as SelectTrigger,
  gi as SelectValue,
  vs as Separator,
  lO as SettingsList,
  uO as SettingsListHeader,
  cO as SettingsListItem,
  fM as SettingsSidebar,
  rO as SettingsSidebarContentSearch,
  w0 as Sidebar,
  m0 as SidebarContent,
  rM as SidebarFooter,
  Ku as SidebarGroup,
  iM as SidebarGroupAction,
  Ju as SidebarGroupContent,
  Wu as SidebarGroupLabel,
  nM as SidebarHeader,
  tM as SidebarInput,
  g0 as SidebarInset,
  b0 as SidebarMenu,
  aM as SidebarMenuAction,
  lM as SidebarMenuBadge,
  y0 as SidebarMenuButton,
  v0 as SidebarMenuItem,
  cM as SidebarMenuSkeleton,
  uM as SidebarMenuSub,
  pM as SidebarMenuSubButton,
  dM as SidebarMenuSubItem,
  h0 as SidebarProvider,
  eM as SidebarRail,
  oM as SidebarSeparator,
  ZD as SidebarTrigger,
  du as Skeleton,
  e5 as Slider,
  MO as Sonner,
  OM as Spinner,
  t5 as Switch,
  Xu as TabDropdownMenu,
  pO as TabFloatingMenu,
  dO as TabToolbar,
  Ol as Table,
  Il as TableBody,
  Hx as TableCaption,
  Co as TableCell,
  qx as TableFooter,
  Es as TableHead,
  Rl as TableHeader,
  Tr as TableRow,
  OO as Tabs,
  o5 as TabsContent,
  n5 as TabsList,
  r5 as TabsTrigger,
  vO as TextField,
  i5 as Textarea,
  Ed as ToggleGroup,
  ws as ToggleGroupItem,
  wO as Toolbar,
  md as Tooltip,
  Tl as TooltipContent,
  Nl as TooltipProvider,
  bd as TooltipTrigger,
  gO as UiLanguageSelector,
  N0 as VerticalTabs,
  A0 as VerticalTabsContent,
  T0 as VerticalTabsList,
  CM as VerticalTabsTrigger,
  w2 as badgeVariants,
  Zy as buttonVariants,
  z as cn,
  eO as getBookIdFromUSFM,
  Q5 as getLinesFromUSFM,
  Z5 as getNumberFromUSFM,
  WD as getStatusForItem,
  hO as getToolbarOSReservedSpaceClassName,
  X5 as inventoryCountColumn,
  J5 as inventoryItemColumn,
  Y5 as inventoryStatusColumn,
  Lx as selectTriggerVariants,
  $O as sonner,
  RO as useEvent,
  IO as useEventAsync,
  u2 as useListbox,
  a5 as usePromise,
  O5 as useRecentSearches,
  Wl as useSidebar
};
//# sourceMappingURL=index.js.map
