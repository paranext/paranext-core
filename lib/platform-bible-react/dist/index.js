var $2 = Object.defineProperty;
var F2 = (t, e, n) => e in t ? $2(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var Zn = (t, e, n) => F2(t, typeof e != "symbol" ? e + "" : e, n);
import { jsx as p, jsxs as B, Fragment as Lt } from "react/jsx-runtime";
import * as vs from "react";
import Y, { forwardRef as Yn, useRef as ye, useMemo as Ne, useState as ue, useCallback as be, useLayoutEffect as kn, createContext as Sl, useContext as Tl, useEffect as de, Suspense as wy, memo as B2, useImperativeHandle as Kh, Children as q2, cloneElement as j2, isValidElement as U2, createRef as z2, Fragment as my } from "react";
import { Command as Rn } from "cmdk";
import { X as Ou, Search as by, Check as xi, Clock as Ug, ChevronsLeft as zg, ChevronsRight as Vg, ChevronLeft as Sf, ChevronRight as Ds, ArrowLeft as V2, ArrowRight as H2, Circle as Iu, ChevronsUpDown as Wh, FilterIcon as K2, ChevronDown as Ru, ChevronUp as W2, ArrowLeftIcon as G2, ChevronLeftIcon as J2, ChevronRightIcon as X2, ArrowRightIcon as Y2, Copy as yy, Filter as Q2, User as Z2, Link as e1, CircleHelp as t1, Star as n1, SquareSigma as Hg, FunctionSquare as r1, Plus as i1, SquareFunction as o1, SquareX as s1, AlertCircle as Tf, CircleCheckIcon as a1, CircleXIcon as l1, CircleHelpIcon as c1, ArrowUpIcon as u1, ArrowDownIcon as d1, ArrowUpDownIcon as f1, PanelLeft as h1, PanelRight as p1, ScrollText as g1, MenuIcon as w1, Menu as m1, EllipsisVertical as b1, MoreHorizontal as y1, LoaderCircle as v1, GripVertical as _1 } from "lucide-react";
import { clsx as x1 } from "clsx";
import { extendTailwindMerge as C1 } from "tailwind-merge";
import * as Xr from "@radix-ui/react-dialog";
import { includes as lc, Section as ze, getChaptersForBook as k1, formatScrRef as _s, getSectionForBook as Wa, NumberFormat as E1, formatBytes as N1, getCurrentLocale as S1, getFormatCallerFunction as T1, deepEqual as Gh, isString as $d, compareScrRefs as Af, scrRefToBBBCCCVVV as Fd, getLocalizeKeyForScrollGroupId as tt, formatReplacementString as A1 } from "platform-bible-utils";
import { Slot as na } from "@radix-ui/react-slot";
import { cva as Xi } from "class-variance-authority";
import * as Ms from "@radix-ui/react-popover";
import * as vy from "@radix-ui/react-label";
import * as tl from "@radix-ui/react-radio-group";
import { useReactTable as _y, getFilteredRowModel as D1, getSortedRowModel as xy, getPaginationRowModel as M1, getCoreRowModel as Cy, flexRender as Ga, getGroupedRowModel as O1, getExpandedRowModel as I1 } from "@tanstack/react-table";
import * as ft from "@radix-ui/react-dropdown-menu";
import { DropdownMenuTrigger as R1 } from "@radix-ui/react-dropdown-menu";
import * as kt from "@radix-ui/react-select";
import P1 from "markdown-to-jsx";
import * as L1 from "react-dom";
import { flushSync as ky, createPortal as fi } from "react-dom";
import * as Df from "@radix-ui/react-checkbox";
import * as Pu from "@radix-ui/react-toggle-group";
import * as Ey from "@radix-ui/react-toggle";
import * as Ny from "@radix-ui/react-separator";
import * as Al from "@radix-ui/react-tooltip";
import * as Pn from "@radix-ui/react-tabs";
import * as ht from "@radix-ui/react-menubar";
import { useHotkeys as $1 } from "react-hotkeys-hook";
import * as ra from "@radix-ui/react-avatar";
import * as pt from "@radix-ui/react-context-menu";
import { Drawer as Nr } from "vaul";
import * as Mf from "@radix-ui/react-progress";
import * as Jh from "react-resizable-panels";
import { Toaster as F1 } from "sonner";
import { toast as B3 } from "sonner";
import * as Ba from "@radix-ui/react-slider";
import * as Of from "@radix-ui/react-switch";
const B1 = C1({ prefix: "tw-" });
function G(...t) {
  return B1(x1(t));
}
const q1 = "layoutDirection";
function Jt() {
  const t = localStorage.getItem(q1);
  return t === "rtl" ? t : "ltr";
}
const j1 = Xr.Portal, Sy = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Xr.Overlay,
  {
    ref: n,
    className: G(
      "tw-fixed tw-inset-0 tw-z-50 tw-bg-black/80 data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0",
      t
    ),
    ...e
  }
));
Sy.displayName = Xr.Overlay.displayName;
const U1 = Y.forwardRef(({ className: t, children: e, ...n }, r) => {
  const i = Jt();
  return /* @__PURE__ */ B(j1, { children: [
    /* @__PURE__ */ p(Sy, {}),
    /* @__PURE__ */ B(
      Xr.Content,
      {
        ref: r,
        className: G(
          "pr-twp tw-fixed tw-left-[50%] tw-top-[50%] tw-z-50 tw-grid tw-w-full tw-max-w-lg tw-translate-x-[-50%] tw-translate-y-[-50%] tw-gap-4 tw-border tw-bg-background tw-p-6 tw-shadow-lg tw-duration-200 data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[state=closed]:tw-slide-out-to-left-1/2 data-[state=closed]:tw-slide-out-to-top-[48%] data-[state=open]:tw-slide-in-from-left-1/2 data-[state=open]:tw-slide-in-from-top-[48%] sm:tw-rounded-lg",
          t
        ),
        ...n,
        dir: i,
        children: [
          e,
          /* @__PURE__ */ B(
            Xr.Close,
            {
              className: G(
                "tw-absolute tw-top-4 tw-rounded-sm tw-opacity-70 tw-ring-offset-background tw-transition-opacity hover:tw-opacity-100 focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-ring focus:tw-ring-offset-2 disabled:tw-pointer-events-none data-[state=open]:tw-bg-accent data-[state=open]:tw-text-muted-foreground",
                { "tw-right-4": i === "ltr" },
                { "tw-left-4": i === "rtl" }
              ),
              children: [
                /* @__PURE__ */ p(Ou, { className: "tw-h-4 tw-w-4" }),
                /* @__PURE__ */ p("span", { className: "tw-sr-only", children: "Close" })
              ]
            }
          )
        ]
      }
    )
  ] });
});
U1.displayName = Xr.Content.displayName;
const z1 = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Xr.Title,
  {
    ref: n,
    className: G("tw-text-lg tw-font-semibold tw-leading-none tw-tracking-tight", t),
    ...e
  }
));
z1.displayName = Xr.Title.displayName;
const V1 = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Xr.Description,
  {
    ref: n,
    className: G("tw-text-sm tw-text-muted-foreground", t),
    ...e
  }
));
V1.displayName = Xr.Description.displayName;
const ia = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Rn,
  {
    ref: n,
    className: G(
      "tw-flex tw-h-full tw-w-full tw-flex-col tw-overflow-hidden tw-rounded-md tw-bg-popover tw-text-popover-foreground",
      t
    ),
    ...e
  }
));
ia.displayName = Rn.displayName;
const Dl = Y.forwardRef(({ className: t, ...e }, n) => {
  const r = Jt();
  return /* @__PURE__ */ B("div", { className: "tw-flex tw-items-center tw-border-b tw-px-3", dir: r, children: [
    /* @__PURE__ */ p(by, { className: "tw-me-2 tw-h-4 tw-w-4 tw-shrink-0 tw-opacity-50" }),
    /* @__PURE__ */ p(
      Rn.Input,
      {
        ref: n,
        className: G(
          "tw-flex tw-h-11 tw-w-full tw-rounded-md tw-bg-transparent tw-py-3 tw-text-sm tw-outline-none placeholder:tw-text-muted-foreground disabled:tw-cursor-not-allowed disabled:tw-opacity-50",
          t
        ),
        ...e
      }
    )
  ] });
});
Dl.displayName = Rn.Input.displayName;
const oa = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Rn.List,
  {
    ref: n,
    className: G("tw-max-h-[300px] tw-overflow-y-auto tw-overflow-x-hidden", t),
    ...e
  }
));
oa.displayName = Rn.List.displayName;
const Lu = Y.forwardRef((t, e) => /* @__PURE__ */ p(Rn.Empty, { ref: e, className: "tw-py-6 tw-text-center tw-text-sm", ...t }));
Lu.displayName = Rn.Empty.displayName;
const Mo = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Rn.Group,
  {
    ref: n,
    className: G(
      "tw-overflow-hidden tw-p-1 tw-text-foreground [&_[cmdk-group-heading]]:tw-px-2 [&_[cmdk-group-heading]]:tw-py-1.5 [&_[cmdk-group-heading]]:tw-text-xs [&_[cmdk-group-heading]]:tw-font-medium [&_[cmdk-group-heading]]:tw-text-muted-foreground",
      t
    ),
    ...e
  }
));
Mo.displayName = Rn.Group.displayName;
const Ty = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Rn.Separator,
  {
    ref: n,
    className: G("tw--mx-1 tw-h-px tw-bg-border", t),
    ...e
  }
));
Ty.displayName = Rn.Separator.displayName;
const Qo = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Rn.Item,
  {
    ref: n,
    className: G(
      "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none data-[disabled=true]:tw-pointer-events-none data-[selected=true]:tw-bg-accent data-[selected=true]:tw-text-accent-foreground data-[disabled=true]:tw-opacity-50",
      t
    ),
    ...e
  }
));
Qo.displayName = Rn.Item.displayName;
var H1 = Object.defineProperty, K1 = (t, e, n) => e in t ? H1(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, qe = (t, e, n) => K1(t, typeof e != "symbol" ? e + "" : e, n);
const Oo = [
  "GEN",
  "EXO",
  "LEV",
  "NUM",
  "DEU",
  "JOS",
  "JDG",
  "RUT",
  "1SA",
  "2SA",
  // 10
  "1KI",
  "2KI",
  "1CH",
  "2CH",
  "EZR",
  "NEH",
  "EST",
  "JOB",
  "PSA",
  "PRO",
  // 20
  "ECC",
  "SNG",
  "ISA",
  "JER",
  "LAM",
  "EZK",
  "DAN",
  "HOS",
  "JOL",
  "AMO",
  // 30
  "OBA",
  "JON",
  "MIC",
  "NAM",
  "HAB",
  "ZEP",
  "HAG",
  "ZEC",
  "MAL",
  "MAT",
  // 40
  "MRK",
  "LUK",
  "JHN",
  "ACT",
  "ROM",
  "1CO",
  "2CO",
  "GAL",
  "EPH",
  "PHP",
  // 50
  "COL",
  "1TH",
  "2TH",
  "1TI",
  "2TI",
  "TIT",
  "PHM",
  "HEB",
  "JAS",
  "1PE",
  // 60
  "2PE",
  "1JN",
  "2JN",
  "3JN",
  "JUD",
  "REV",
  "TOB",
  "JDT",
  "ESG",
  "WIS",
  // 70
  "SIR",
  "BAR",
  "LJE",
  "S3Y",
  "SUS",
  "BEL",
  "1MA",
  "2MA",
  "3MA",
  "4MA",
  // 80
  "1ES",
  "2ES",
  "MAN",
  "PS2",
  "ODA",
  "PSS",
  "JSA",
  // actual variant text for JOS, now in LXA text
  "JDB",
  // actual variant text for JDG, now in LXA text
  "TBS",
  // actual variant text for TOB, now in LXA text
  "SST",
  // actual variant text for SUS, now in LXA text // 90
  "DNT",
  // actual variant text for DAN, now in LXA text
  "BLT",
  // actual variant text for BEL, now in LXA text
  "XXA",
  "XXB",
  "XXC",
  "XXD",
  "XXE",
  "XXF",
  "XXG",
  "FRT",
  // 100
  "BAK",
  "OTH",
  "3ES",
  // Used previously but really should be 2ES
  "EZA",
  // Used to be called 4ES, but not actually in any known project
  "5EZ",
  // Used to be called 5ES, but not actually in any known project
  "6EZ",
  // Used to be called 6ES, but not actually in any known project
  "INT",
  "CNC",
  "GLO",
  "TDX",
  // 110
  "NDX",
  "DAG",
  "PS3",
  "2BA",
  "LBA",
  "JUB",
  "ENO",
  "1MQ",
  "2MQ",
  "3MQ",
  // 120
  "REP",
  "4BA",
  "LAO"
], Xh = [
  "XXA",
  "XXB",
  "XXC",
  "XXD",
  "XXE",
  "XXF",
  "XXG",
  "FRT",
  "BAK",
  "OTH",
  "INT",
  "CNC",
  "GLO",
  "TDX",
  "NDX"
], Ay = [
  "Genesis",
  "Exodus",
  "Leviticus",
  "Numbers",
  "Deuteronomy",
  "Joshua",
  "Judges",
  "Ruth",
  "1 Samuel",
  "2 Samuel",
  "1 Kings",
  "2 Kings",
  "1 Chronicles",
  "2 Chronicles",
  "Ezra",
  "Nehemiah",
  "Esther (Hebrew)",
  "Job",
  "Psalms",
  "Proverbs",
  "Ecclesiastes",
  "Song of Songs",
  "Isaiah",
  "Jeremiah",
  "Lamentations",
  "Ezekiel",
  "Daniel (Hebrew)",
  "Hosea",
  "Joel",
  "Amos",
  "Obadiah",
  "Jonah",
  "Micah",
  "Nahum",
  "Habakkuk",
  "Zephaniah",
  "Haggai",
  "Zechariah",
  "Malachi",
  "Matthew",
  "Mark",
  "Luke",
  "John",
  "Acts",
  "Romans",
  "1 Corinthians",
  "2 Corinthians",
  "Galatians",
  "Ephesians",
  "Philippians",
  "Colossians",
  "1 Thessalonians",
  "2 Thessalonians",
  "1 Timothy",
  "2 Timothy",
  "Titus",
  "Philemon",
  "Hebrews",
  "James",
  "1 Peter",
  "2 Peter",
  "1 John",
  "2 John",
  "3 John",
  "Jude",
  "Revelation",
  "Tobit",
  "Judith",
  "Esther Greek",
  "Wisdom of Solomon",
  "Sirach (Ecclesiasticus)",
  "Baruch",
  "Letter of Jeremiah",
  "Song of 3 Young Men",
  "Susanna",
  "Bel and the Dragon",
  "1 Maccabees",
  "2 Maccabees",
  "3 Maccabees",
  "4 Maccabees",
  "1 Esdras (Greek)",
  "2 Esdras (Latin)",
  "Prayer of Manasseh",
  "Psalm 151",
  "Odes",
  "Psalms of Solomon",
  // WARNING, if you change the spelling of the *obsolete* tag be sure to update
  // IsObsolete routine
  "Joshua A. *obsolete*",
  "Judges B. *obsolete*",
  "Tobit S. *obsolete*",
  "Susanna Th. *obsolete*",
  "Daniel Th. *obsolete*",
  "Bel Th. *obsolete*",
  "Extra A",
  "Extra B",
  "Extra C",
  "Extra D",
  "Extra E",
  "Extra F",
  "Extra G",
  "Front Matter",
  "Back Matter",
  "Other Matter",
  "3 Ezra *obsolete*",
  "Apocalypse of Ezra",
  "5 Ezra (Latin Prologue)",
  "6 Ezra (Latin Epilogue)",
  "Introduction",
  "Concordance ",
  "Glossary ",
  "Topical Index",
  "Names Index",
  "Daniel Greek",
  "Psalms 152-155",
  "2 Baruch (Apocalypse)",
  "Letter of Baruch",
  "Jubilees",
  "Enoch",
  "1 Meqabyan",
  "2 Meqabyan",
  "3 Meqabyan",
  "Reproof (Proverbs 25-31)",
  "4 Baruch (Rest of Baruch)",
  "Laodiceans"
], Kg = nC();
function sa(t, e = !0) {
  return e && (t = t.toUpperCase()), t in Kg ? Kg[t] : 0;
}
function Yh(t) {
  return sa(t) > 0;
}
function W1(t) {
  const e = typeof t == "string" ? sa(t) : t;
  return e >= 40 && e <= 66;
}
function G1(t) {
  return (typeof t == "string" ? sa(t) : t) <= 39;
}
function Dy(t) {
  return t <= 66;
}
function J1(t) {
  const e = typeof t == "string" ? sa(t) : t;
  return Iy(e) && !Dy(e);
}
function* X1() {
  for (let t = 1; t <= Oo.length; t++) yield t;
}
const Y1 = 1, My = Oo.length;
function Q1() {
  return ["XXA", "XXB", "XXC", "XXD", "XXE", "XXF", "XXG"];
}
function Qh(t, e = "***") {
  const n = t - 1;
  return n < 0 || n >= Oo.length ? e : Oo[n];
}
function Oy(t) {
  return t <= 0 || t > My ? "******" : Ay[t - 1];
}
function Z1(t) {
  return Oy(sa(t));
}
function Iy(t) {
  const e = typeof t == "number" ? Qh(t) : t;
  return Yh(e) && !Xh.includes(e);
}
function eC(t) {
  const e = typeof t == "number" ? Qh(t) : t;
  return Yh(e) && Xh.includes(e);
}
function tC(t) {
  return Ay[t - 1].includes("*obsolete*");
}
function nC() {
  const t = {};
  for (let e = 0; e < Oo.length; e++)
    t[Oo[e]] = e + 1;
  return t;
}
const nt = {
  allBookIds: Oo,
  nonCanonicalIds: Xh,
  bookIdToNumber: sa,
  isBookIdValid: Yh,
  isBookNT: W1,
  isBookOT: G1,
  isBookOTNT: Dy,
  isBookDC: J1,
  allBookNumbers: X1,
  firstBook: Y1,
  lastBook: My,
  extraBooks: Q1,
  bookNumberToId: Qh,
  bookNumberToEnglishName: Oy,
  bookIdToEnglishName: Z1,
  isCanonical: Iy,
  isExtraMaterial: eC,
  isObsolete: tC
};
var Br = /* @__PURE__ */ ((t) => (t[t.Unknown = 0] = "Unknown", t[t.Original = 1] = "Original", t[t.Septuagint = 2] = "Septuagint", t[t.Vulgate = 3] = "Vulgate", t[t.English = 4] = "English", t[t.RussianProtestant = 5] = "RussianProtestant", t[t.RussianOrthodox = 6] = "RussianOrthodox", t))(Br || {});
const Hn = class {
  // private versInfo: Versification;
  constructor(e) {
    if (qe(this, "name"), qe(this, "fullPath"), qe(this, "isPresent"), qe(this, "hasVerseSegments"), qe(this, "isCustomized"), qe(this, "baseVersification"), qe(this, "scriptureBooks"), qe(this, "_type"), e == null)
      throw new Error("Argument undefined");
    typeof e == "string" ? (this.name = e, this._type = Br[e]) : (this._type = e, this.name = Br[e]);
  }
  get type() {
    return this._type;
  }
  equals(e) {
    return !e.type || !this.type ? !1 : e.type === this.type;
  }
};
qe(Hn, "Original", new Hn(Br.Original)), qe(Hn, "Septuagint", new Hn(Br.Septuagint)), qe(Hn, "Vulgate", new Hn(Br.Vulgate)), qe(Hn, "English", new Hn(Br.English)), qe(Hn, "RussianProtestant", new Hn(Br.RussianProtestant)), qe(Hn, "RussianOrthodox", new Hn(Br.RussianOrthodox));
let wo = Hn;
function Wg(t, e) {
  const n = e[0];
  for (let r = 1; r < e.length; r++)
    t = t.split(e[r]).join(n);
  return t.split(n);
}
var Ry = /* @__PURE__ */ ((t) => (t[t.Valid = 0] = "Valid", t[t.UnknownVersification = 1] = "UnknownVersification", t[t.OutOfRange = 2] = "OutOfRange", t[t.VerseOutOfOrder = 3] = "VerseOutOfOrder", t[t.VerseRepeated = 4] = "VerseRepeated", t))(Ry || {});
const An = class We {
  constructor(e, n, r, i) {
    if (qe(this, "firstChapter"), qe(this, "lastChapter"), qe(this, "lastVerse"), qe(this, "hasSegmentsDefined"), qe(this, "text"), qe(this, "BBBCCCVVVS"), qe(this, "longHashCode"), qe(this, "versification"), qe(this, "rtlMark", "â€"), qe(this, "_bookNum", 0), qe(this, "_chapterNum", 0), qe(this, "_verseNum", 0), qe(this, "_verse"), r == null && i == null)
      if (e != null && typeof e == "string") {
        const o = e, s = n != null && n instanceof wo ? n : void 0;
        this.setEmpty(s), this.parse(o);
      } else if (e != null && typeof e == "number") {
        const o = n != null && n instanceof wo ? n : void 0;
        this.setEmpty(o), this._verseNum = e % We.chapterDigitShifter, this._chapterNum = Math.floor(
          e % We.bookDigitShifter / We.chapterDigitShifter
        ), this._bookNum = Math.floor(e / We.bookDigitShifter);
      } else if (n == null)
        if (e != null && e instanceof We) {
          const o = e;
          this._bookNum = o.bookNum, this._chapterNum = o.chapterNum, this._verseNum = o.verseNum, this._verse = o.verse, this.versification = o.versification;
        } else {
          if (e == null) return;
          const o = e instanceof wo ? e : We.defaultVersification;
          this.setEmpty(o);
        }
      else
        throw new Error("VerseRef constructor not supported.");
    else if (e != null && n != null && r != null)
      if (typeof e == "string" && typeof n == "string" && typeof r == "string")
        this.setEmpty(i), this.updateInternal(e, n, r);
      else if (typeof e == "number" && typeof n == "number" && typeof r == "number")
        this._bookNum = e, this._chapterNum = n, this._verseNum = r, this.versification = i ?? We.defaultVersification;
      else
        throw new Error("VerseRef constructor not supported.");
    else
      throw new Error("VerseRef constructor not supported.");
  }
  /**
   * Determines if the verse string is in a valid format (does not consider versification).
   */
  static isVerseParseable(e) {
    return e.length > 0 && "0123456789".includes(e[0]) && !e.endsWith(this.verseRangeSeparator) && !e.endsWith(this.verseSequenceIndicator);
  }
  /**
   * Tries to parse the specified string into a verse reference.
   * @param str - The string to attempt to parse.
   * @returns success: `true` if the specified string was successfully parsed, `false` otherwise.
   * @returns verseRef: The result of the parse if successful, or empty VerseRef if it failed
   */
  static tryParse(e) {
    let n;
    try {
      return n = new We(e), { success: !0, verseRef: n };
    } catch (r) {
      if (r instanceof Da)
        return n = new We(), { success: !1, verseRef: n };
      throw r;
    }
  }
  /**
   * Gets the reference as a comparable integer where the book, chapter, and verse each occupy 3
   * digits.
   * @param bookNum - Book number (this is 1-based, not an index).
   * @param chapterNum - Chapter number.
   * @param verseNum - Verse number.
   * @returns The reference as a comparable integer where the book, chapter, and verse each occupy 3
   * digits.
   */
  static getBBBCCCVVV(e, n, r) {
    return e % We.bcvMaxValue * We.bookDigitShifter + (n >= 0 ? n % We.bcvMaxValue * We.chapterDigitShifter : 0) + (r >= 0 ? r % We.bcvMaxValue : 0);
  }
  /**
   * Deserializes a serialized VerseRef.
   * @param serializedVerseRef - Serialized VerseRef to create from.
   * @returns the deserialized VerseRef.
   */
  static fromJSON(e) {
    const { book: n, chapterNum: r, verseNum: i, verse: o, versificationStr: s } = e, a = o || i.toString();
    let l;
    return s && (l = new wo(s)), n ? new We(n, r.toString(), a, l) : new We();
  }
  /**
   * Parses a verse string and gets the leading numeric portion as a number.
   * @param verseStr - verse string to parse
   * @returns true if the entire string could be parsed as a single, simple verse number (1-999);
   *    false if the verse string represented a verse bridge, contained segment letters, or was invalid
   */
  static tryGetVerseNum(e) {
    let n;
    if (!e)
      return n = -1, { success: !0, vNum: n };
    n = 0;
    let r;
    for (let i = 0; i < e.length; i++) {
      if (r = e[i], r < "0" || r > "9")
        return i === 0 && (n = -1), { success: !1, vNum: n };
      if (n = n * 10 + +r - 0, n > We.bcvMaxValue)
        return n = -1, { success: !1, vNum: n };
    }
    return { success: !0, vNum: n };
  }
  /**
   * Checks to see if a VerseRef hasn't been set - all values are the default.
   */
  get isDefault() {
    return this.bookNum === 0 && this.chapterNum === 0 && this.verseNum === 0 && this.versification == null;
  }
  /**
   * Gets whether the verse contains multiple verses.
   */
  get hasMultiple() {
    return this._verse != null && (this._verse.includes(We.verseRangeSeparator) || this._verse.includes(We.verseSequenceIndicator));
  }
  /**
   * Gets or sets the book of the reference. Book is the 3-letter abbreviation in capital letters,
   * e.g. `'MAT'`.
   */
  get book() {
    return nt.bookNumberToId(this.bookNum, "");
  }
  set book(e) {
    this.bookNum = nt.bookIdToNumber(e);
  }
  /**
   * Gets or sets the chapter of the reference,. e.g. `'3'`.
   */
  get chapter() {
    return this.isDefault || this._chapterNum < 0 ? "" : this._chapterNum.toString();
  }
  set chapter(e) {
    const n = +e;
    this._chapterNum = Number.isInteger(n) ? n : -1;
  }
  /**
   * Gets or sets the verse of the reference, including range, segments, and sequences, e.g. `'4'`,
   * or `'4b-5a, 7'`.
   */
  get verse() {
    return this._verse != null ? this._verse : this.isDefault || this._verseNum < 0 ? "" : this._verseNum.toString();
  }
  set verse(e) {
    const { success: n, vNum: r } = We.tryGetVerseNum(e);
    this._verse = n ? void 0 : e.replace(this.rtlMark, ""), this._verseNum = r, !(this._verseNum >= 0) && ({ vNum: this._verseNum } = We.tryGetVerseNum(this._verse));
  }
  /**
   * Get or set Book based on book number, e.g. `42`.
   */
  get bookNum() {
    return this._bookNum;
  }
  set bookNum(e) {
    if (e <= 0 || e > nt.lastBook)
      throw new Da(
        "BookNum must be greater than zero and less than or equal to last book"
      );
    this._bookNum = e;
  }
  /**
   * Gets or sets the chapter number, e.g. `3`. `-1` if not valid.
   */
  get chapterNum() {
    return this._chapterNum;
  }
  set chapterNum(e) {
    this.chapterNum = e;
  }
  /**
   * Gets or sets verse start number, e.g. `4`. `-1` if not valid.
   */
  get verseNum() {
    return this._verseNum;
  }
  set verseNum(e) {
    this._verseNum = e;
  }
  /**
   * String representing the versification (should ONLY be used for serialization/deserialization).
   *
   * @remarks This is for backwards compatibility when ScrVers was an enumeration.
   */
  get versificationStr() {
    var e;
    return (e = this.versification) == null ? void 0 : e.name;
  }
  set versificationStr(e) {
    this.versification = this.versification != null ? new wo(e) : void 0;
  }
  /**
   * Determines if the reference is valid.
   */
  get valid() {
    return this.validStatus === 0;
  }
  /**
   * Get the valid status for this reference.
   */
  get validStatus() {
    return this.validateVerse(We.verseRangeSeparators, We.verseSequenceIndicators);
  }
  /**
   * Gets the reference as a comparable integer where the book,
   * chapter, and verse each occupy three digits and the verse is 0.
   */
  get BBBCCC() {
    return We.getBBBCCCVVV(this._bookNum, this._chapterNum, 0);
  }
  /**
   * Gets the reference as a comparable integer where the book,
   * chapter, and verse each occupy three digits. If verse is not null
   * (i.e., this reference represents a complex reference with verse
   * segments or bridge) this cannot be used for an exact comparison.
   */
  get BBBCCCVVV() {
    return We.getBBBCCCVVV(this._bookNum, this._chapterNum, this._verseNum);
  }
  /**
   * Gets whether the verse is defined as an excluded verse in the versification.
   * Does not handle verse ranges.
   */
  // eslint-disable-next-line @typescript-eslint/class-literal-property-style
  get isExcluded() {
    return !1;
  }
  /**
   * Parses the reference in the specified string.
   * Optionally versification can follow reference as in GEN 3:11/4
   * Throw an exception if
   * - invalid book name
   * - chapter number is missing or not a number
   * - verse number is missing or does not start with a number
   * - versification is invalid
   * @param verseStr - string to parse e.g. 'MAT 3:11'
   */
  parse(e) {
    if (e = e.replace(this.rtlMark, ""), e.includes("/")) {
      const o = e.split("/");
      if (e = o[0], o.length > 1)
        try {
          const s = +o[1].trim();
          this.versification = new wo(Br[s]);
        } catch {
          throw new Da("Invalid reference : " + e);
        }
    }
    const n = e.trim().split(" ");
    if (n.length !== 2)
      throw new Da("Invalid reference : " + e);
    const r = n[1].split(":"), i = +r[0];
    if (r.length !== 2 || nt.bookIdToNumber(n[0]) === 0 || !Number.isInteger(i) || i < 0 || !We.isVerseParseable(r[1]))
      throw new Da("Invalid reference : " + e);
    this.updateInternal(n[0], r[0], r[1]);
  }
  /**
   * Simplifies this verse ref so that it has no bridging of verses or
   * verse segments like `'1a'`.
   */
  simplify() {
    this._verse = void 0;
  }
  /**
   * Makes a clone of the reference.
   *
   * @returns The cloned VerseRef.
   */
  clone() {
    return new We(this);
  }
  toString() {
    const e = this.book;
    return e === "" ? "" : `${e} ${this.chapter}:${this.verse}`;
  }
  toJSON() {
    let e = this.verse;
    (e === "" || e === this.verseNum.toString()) && (e = void 0);
    const n = {
      book: this.book,
      chapterNum: this.chapterNum,
      verseNum: this.verseNum,
      verse: e,
      versificationStr: this.versificationStr
    };
    return e || delete n.verse, n;
  }
  /**
   * Compares this `VerseRef` with supplied one.
   * @param verseRef - object to compare this one to.
   * @returns `true` if this `VerseRef` is equal to the supplied one, `false` otherwise.
   */
  equals(e) {
    return e instanceof We ? e._bookNum === this._bookNum && e._chapterNum === this._chapterNum && e._verseNum === this._verseNum && e.verse === this.verse && (e.versification == null && this.versification == null || e.versification != null && this.versification != null && e.versification.equals(this.versification)) : !1;
  }
  /**
   * Enumerate all individual verses contained in a VerseRef.
   * Verse ranges are indicated by "-" and consecutive verses by ","s.
   * Examples:
   * GEN 1:2 returns GEN 1:2
   * GEN 1:1a-3b,5 returns GEN 1:1a, GEN 1:2, GEN 1:3b, GEN 1:5
   * GEN 1:2a-2c returns //! ??????
   *
   * @param specifiedVersesOnly - if set to <c>true</c> return only verses that are
   * explicitly specified only, not verses within a range. Defaults to `false`.
   * @param verseRangeSeparators - Verse range separators.
   * Defaults to `VerseRef.verseRangeSeparators`.
   * @param verseSequenceSeparators - Verse sequence separators.
   * Defaults to `VerseRef.verseSequenceIndicators`.
   * @returns An array of all single verse references in this VerseRef.
   */
  allVerses(e = !1, n = We.verseRangeSeparators, r = We.verseSequenceIndicators) {
    if (this._verse == null || this.chapterNum <= 0)
      return [this.clone()];
    const i = [], o = Wg(this._verse, r);
    for (const s of o.map((a) => Wg(a, n))) {
      const a = this.clone();
      a.verse = s[0];
      const l = a.verseNum;
      if (i.push(a), s.length > 1) {
        const c = this.clone();
        if (c.verse = s[1], !e)
          for (let u = l + 1; u < c.verseNum; u++) {
            const f = new We(
              this._bookNum,
              this._chapterNum,
              u,
              this.versification
            );
            this.isExcluded || i.push(f);
          }
        i.push(c);
      }
    }
    return i;
  }
  /**
   * Validates a verse number using the supplied separators rather than the defaults.
   */
  validateVerse(e, n) {
    if (!this.verse)
      return this.internalValid;
    let r = 0;
    for (const i of this.allVerses(!0, e, n)) {
      const o = i.internalValid;
      if (o !== 0)
        return o;
      const s = i.BBBCCCVVV;
      if (r > s)
        return 3;
      if (r === s)
        return 4;
      r = s;
    }
    return 0;
  }
  /**
   * Gets whether a single verse reference is valid.
   */
  get internalValid() {
    return this.versification == null ? 1 : this._bookNum <= 0 || this._bookNum > nt.lastBook ? 2 : (nt.isCanonical(this._bookNum), 0);
  }
  setEmpty(e = We.defaultVersification) {
    this._bookNum = 0, this._chapterNum = -1, this._verse = void 0, this.versification = e;
  }
  updateInternal(e, n, r) {
    this.bookNum = nt.bookIdToNumber(e), this.chapter = n, this.verse = r;
  }
};
qe(An, "defaultVersification", wo.English), qe(An, "verseRangeSeparator", "-"), qe(An, "verseSequenceIndicator", ","), qe(An, "verseRangeSeparators", [An.verseRangeSeparator]), qe(An, "verseSequenceIndicators", [An.verseSequenceIndicator]), qe(An, "chapterDigitShifter", 1e3), qe(An, "bookDigitShifter", An.chapterDigitShifter * An.chapterDigitShifter), qe(An, "bcvMaxValue", An.chapterDigitShifter - 1), /**
* The valid status of the VerseRef.
*/
qe(An, "ValidStatusType", Ry);
let Da = class extends Error {
};
const Py = (t, e, n, r, i) => {
  switch (t) {
    case ze.OT:
      return e ?? "Old Testament";
    case ze.NT:
      return n ?? "New Testament";
    case ze.DC:
      return r ?? "Deuterocanon";
    case ze.Extra:
      return i ?? "Extra Materials";
    default:
      throw new Error(`Unknown section: ${t}`);
  }
}, rC = (t, e, n, r, i) => {
  switch (t) {
    case ze.OT:
      return e ?? "OT";
    case ze.NT:
      return n ?? "NT";
    case ze.DC:
      return r ?? "DC";
    case ze.Extra:
      return i ?? "Extra";
    default:
      throw new Error(`Unknown section: ${t}`);
  }
};
function xs(t, e) {
  var r;
  return ((r = e == null ? void 0 : e.get(t)) == null ? void 0 : r.localizedName) ?? nt.bookIdToEnglishName(t);
}
function Zh(t, e) {
  var r;
  return ((r = e == null ? void 0 : e.get(t)) == null ? void 0 : r.localizedId) ?? t.toUpperCase();
}
const Ly = nt.allBookIds.filter(
  (t) => !nt.isObsolete(nt.bookIdToNumber(t))
), _o = Object.fromEntries(
  Ly.map((t) => [t, nt.bookIdToEnglishName(t)])
);
function ep(t, e, n) {
  const r = e.trim().toLowerCase();
  if (!r) return !1;
  const i = nt.bookIdToEnglishName(t), o = n == null ? void 0 : n.get(t);
  return !!(lc(i.toLowerCase(), r) || lc(t.toLowerCase(), r) || (o ? lc(o.localizedName.toLowerCase(), r) || lc(o.localizedId.toLowerCase(), r) : !1));
}
const $y = Yn(
  ({
    bookId: t,
    isSelected: e,
    onSelect: n,
    onMouseDown: r,
    section: i,
    className: o,
    showCheck: s = !1,
    localizedBookNames: a,
    commandValue: l
  }, c) => {
    const u = ye(!1), f = () => {
      u.current || n == null || n(t), setTimeout(() => {
        u.current = !1;
      }, 100);
    }, d = (w) => {
      u.current = !0, r ? r(w) : n == null || n(t);
    }, h = Ne(
      () => xs(t, a),
      [t, a]
    ), g = Ne(
      () => Zh(t, a),
      [t, a]
    );
    return /* @__PURE__ */ p(
      "div",
      {
        className: G(
          "tw-mx-1 tw-my-1 tw-border-b-0 tw-border-e-0 tw-border-s-2 tw-border-t-0 tw-border-solid",
          {
            "tw-border-s-red-200": i === ze.OT,
            "tw-border-s-purple-200": i === ze.NT,
            "tw-border-s-indigo-200": i === ze.DC,
            "tw-border-s-amber-200": i === ze.Extra
          }
        ),
        children: /* @__PURE__ */ B(
          Qo,
          {
            ref: c,
            value: l || `${t} ${nt.bookIdToEnglishName(t)}`,
            onSelect: f,
            onMouseDown: d,
            role: "option",
            "aria-selected": e,
            "aria-label": `${nt.bookIdToEnglishName(t)} (${t.toLocaleUpperCase()})`,
            className: o,
            children: [
              s && /* @__PURE__ */ p(
                xi,
                {
                  className: G(
                    "tw-me-2 tw-h-4 tw-w-4 tw-flex-shrink-0",
                    e ? "tw-opacity-100" : "tw-opacity-0"
                  )
                }
              ),
              /* @__PURE__ */ p("span", { className: "tw-min-w-0 tw-flex-1", children: h }),
              /* @__PURE__ */ p("span", { className: "tw-ms-2 tw-flex-shrink-0 tw-text-xs tw-text-muted-foreground", children: g })
            ]
          }
        )
      }
    );
  }
), iC = Xi(
  "pr-twp tw-inline-flex tw-items-center tw-justify-center tw-gap-2 tw-whitespace-nowrap tw-rounded-md tw-text-sm tw-font-medium tw-ring-offset-background tw-transition-colors focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-pointer-events-none disabled:tw-opacity-50 [&_svg]:tw-pointer-events-none [&_svg]:tw-size-4 [&_svg]:tw-shrink-0",
  {
    variants: {
      variant: {
        default: "tw-bg-primary tw-text-primary-foreground hover:tw-bg-primary/90",
        destructive: "tw-bg-destructive tw-text-destructive-foreground hover:tw-bg-destructive/90",
        outline: "tw-border tw-border-input tw-bg-background hover:tw-bg-accent hover:tw-text-accent-foreground",
        secondary: "tw-bg-secondary tw-text-secondary-foreground hover:tw-bg-secondary/80",
        ghost: "hover:tw-bg-accent hover:tw-text-accent-foreground",
        link: "tw-text-primary tw-underline-offset-4 hover:tw-underline"
      },
      size: {
        default: "tw-h-10 tw-px-4 tw-py-2",
        sm: "tw-h-9 tw-rounded-md tw-px-3",
        lg: "tw-h-11 tw-rounded-md tw-px-8",
        icon: "tw-h-10 tw-w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Me = Y.forwardRef(
  ({ className: t, variant: e, size: n, asChild: r = !1, ...i }, o) => /* @__PURE__ */ p(r ? na : "button", { className: G(iC({ variant: e, size: n, className: t })), ref: o, ...i })
);
Me.displayName = "Button";
const aa = Ms.Root, la = Ms.Trigger, TL = Ms.Anchor, Zo = Y.forwardRef(({ className: t, align: e = "center", sideOffset: n = 4, ...r }, i) => {
  const o = Jt();
  return /* @__PURE__ */ p(Ms.Portal, { children: /* @__PURE__ */ p(
    Ms.Content,
    {
      ref: i,
      align: e,
      sideOffset: n,
      className: G(
        // CUSTOM Changed z-order from 50 to 250 to make them appear on floating tabs (200)
        "tw-z-[250]",
        "pr-twp tw-w-72 tw-rounded-md tw-border tw-bg-popover tw-p-4 tw-text-popover-foreground tw-shadow-md tw-outline-none data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
        t
      ),
      ...r,
      dir: o
    }
  ) });
});
Zo.displayName = Ms.Content.displayName;
function If(t, e, n) {
  return `${t} ${_o[t]}${e ? ` ${Zh(t, e)} ${xs(t, e)}` : ""}${n ? ` ${n}` : ""}`;
}
function oC({
  recentSearches: t,
  onSearchItemSelect: e,
  renderItem: n = (a) => String(a),
  getItemKey: r = (a) => String(a),
  ariaLabel: i = "Show recent searches",
  groupHeading: o = "Recent",
  id: s
}) {
  const [a, l] = ue(!1);
  if (t.length === 0)
    return;
  const c = (u) => {
    e(u), l(!1);
  };
  return /* @__PURE__ */ B(aa, { open: a, onOpenChange: l, children: [
    /* @__PURE__ */ p(la, { asChild: !0, children: /* @__PURE__ */ p(
      Me,
      {
        variant: "ghost",
        size: "icon",
        className: "tw-absolute tw-right-0 tw-top-0 tw-h-full tw-px-3 tw-py-2",
        "aria-label": i,
        children: /* @__PURE__ */ p(Ug, { className: "tw-h-4 tw-w-4" })
      }
    ) }),
    /* @__PURE__ */ p(Zo, { id: s, className: "tw-w-[300px] tw-p-0", align: "start", children: /* @__PURE__ */ p(ia, { children: /* @__PURE__ */ p(oa, { children: /* @__PURE__ */ p(Mo, { heading: o, children: t.map((u) => /* @__PURE__ */ B(
      Qo,
      {
        onSelect: () => c(u),
        className: "tw-flex tw-items-center",
        children: [
          /* @__PURE__ */ p(Ug, { className: "tw-mr-2 tw-h-4 tw-w-4 tw-opacity-50" }),
          /* @__PURE__ */ p("span", { children: n(u) })
        ]
      },
      r(u)
    )) }) }) }) })
  ] });
}
function AL(t, e, n = (i, o) => i === o, r = 15) {
  return (i) => {
    const o = t.filter(
      (a) => !n(a, i)
    ), s = [i, ...o.slice(0, r - 1)];
    e(s);
  };
}
const Bd = {
  // Matches start of string (`^`), one or more non-colon/space words, optionally followed by space and more words (`([^:\s]+(?:\s+[^:\s]+)*)`), end of string (`$`), case-insensitive (`i`)
  BOOK_ONLY: /^([^:\s]+(?:\s+[^:\s]+)*)$/i,
  // Same as above, but followed by a space and a chapter number (`\s+(\d+)`)
  BOOK_CHAPTER: /^([^:\s]+(?:\s+[^:\s]+)*)\s+(\d+)$/i,
  // Same as above, but followed by a colon and optionally a verse number (`:(\d*)`)
  BOOK_CHAPTER_VERSE: /^([^:\s]+(?:\s+[^:\s]+)*)\s+(\d+):(\d*)$/i
}, sC = [
  Bd.BOOK_ONLY,
  Bd.BOOK_CHAPTER,
  Bd.BOOK_CHAPTER_VERSE
];
function Gg(t) {
  const e = /^[a-zA-Z]$/.test(t), n = /^[0-9]$/.test(t);
  return { isLetter: e, isDigit: n };
}
function zr(t) {
  return k1(nt.bookIdToNumber(t));
}
function aC(t, e, n) {
  if (!t.trim() || e.length === 0) return;
  const r = sC.reduce(
    (i, o) => {
      if (i) return i;
      const s = o.exec(t.trim());
      if (s) {
        const [a, l = void 0, c = void 0] = s.slice(1);
        let u;
        const f = e.filter((d) => ep(d, a, n));
        if (f.length === 1 && ([u] = f), !u && l) {
          if (nt.isBookIdValid(a)) {
            const d = a.toUpperCase();
            e.includes(d) && (u = d);
          }
          if (!u && n) {
            const d = Array.from(n.entries()).find(
              ([, h]) => h.localizedId.toLowerCase() === a.toLowerCase()
            );
            d && e.includes(d[0]) && ([u] = d);
          }
        }
        if (!u && l) {
          const h = ((g) => Object.keys(_o).find(
            (w) => _o[w].toLowerCase() === g.toLowerCase()
          ))(a);
          if (h && e.includes(h) && (u = h), !u && n) {
            const g = Array.from(n.entries()).find(
              ([, w]) => w.localizedName.toLowerCase() === a.toLowerCase()
            );
            g && e.includes(g[0]) && ([u] = g);
          }
        }
        if (u) {
          let d = l ? parseInt(l, 10) : void 0;
          d && d > zr(u) && (d = Math.max(zr(u), 1));
          const h = c ? parseInt(c, 10) : void 0;
          return {
            book: u,
            chapterNum: d,
            verseNum: h
          };
        }
      }
    },
    void 0
  );
  if (r) return r;
}
function lC(t, e, n, r) {
  const i = be(() => {
    if (t.chapterNum > 1)
      r({
        book: t.book,
        chapterNum: t.chapterNum - 1,
        verseNum: 1
      });
    else {
      const l = e.indexOf(t.book);
      if (l > 0) {
        const c = e[l - 1], u = Math.max(zr(c), 1);
        r({
          book: c,
          chapterNum: u,
          verseNum: 1
        });
      }
    }
  }, [t, e, r]), o = be(() => {
    const l = zr(t.book);
    if (t.chapterNum < l)
      r({
        book: t.book,
        chapterNum: t.chapterNum + 1,
        verseNum: 1
      });
    else {
      const c = e.indexOf(t.book);
      if (c < e.length - 1) {
        const u = e[c + 1];
        r({
          book: u,
          chapterNum: 1,
          verseNum: 1
        });
      }
    }
  }, [t, e, r]), s = be(() => {
    r({
      book: t.book,
      chapterNum: t.chapterNum,
      verseNum: t.verseNum > 1 ? t.verseNum - 1 : 0
    });
  }, [t, r]), a = be(() => {
    r({
      book: t.book,
      chapterNum: t.chapterNum,
      verseNum: t.verseNum + 1
    });
  }, [t, r]);
  return Ne(() => [
    {
      onClick: i,
      disabled: e.length === 0 || t.chapterNum === 1 && e.indexOf(t.book) === 0,
      title: "Previous chapter",
      icon: n === "ltr" ? zg : Vg
    },
    {
      onClick: s,
      disabled: e.length === 0 || t.verseNum === 0,
      title: "Previous verse",
      icon: n === "ltr" ? Sf : Ds
    },
    {
      onClick: a,
      disabled: e.length === 0,
      title: "Next verse",
      icon: n === "ltr" ? Ds : Sf
    },
    {
      onClick: o,
      disabled: e.length === 0 || (t.chapterNum === zr(t.book) || zr(t.book) === -1) && e.indexOf(t.book) === e.length - 1,
      title: "Next chapter",
      icon: n === "ltr" ? Vg : zg
    }
  ], [
    t,
    e,
    n,
    i,
    s,
    a,
    o
  ]);
}
function Jg({
  bookId: t,
  scrRef: e,
  onChapterSelect: n,
  setChapterRef: r,
  isChapterDimmed: i,
  className: o
}) {
  if (t)
    return /* @__PURE__ */ p(Mo, { children: /* @__PURE__ */ p("div", { className: G("tw-grid tw-grid-cols-6 tw-gap-1", o), children: Array.from({ length: zr(t) }, (s, a) => a + 1).map((s) => /* @__PURE__ */ p(
      Qo,
      {
        value: `${t} ${_o[t] || ""} ${s}`,
        onSelect: () => n(s),
        ref: r(s),
        className: G(
          "tw-h-8 tw-w-8 tw-cursor-pointer tw-justify-center tw-rounded-md tw-text-center tw-text-sm",
          {
            "tw-bg-primary tw-text-primary-foreground": t === e.book && s === e.chapterNum
          },
          {
            "tw-bg-muted/50 tw-text-muted-foreground/50": (i == null ? void 0 : i(s)) ?? !1
          }
        ),
        children: s
      },
      s
    )) }) });
}
function DL({
  scrRef: t,
  handleSubmit: e,
  className: n,
  getActiveBookIds: r,
  localizedBookNames: i,
  localizedStrings: o,
  recentSearches: s,
  onAddRecentSearch: a,
  id: l
}) {
  const c = Jt(), [u, f] = ue(!1), [d, h] = ue(""), [g, w] = ue(""), [b, _] = ue("books"), [y, C] = ue(void 0), [D, P] = ue(!1), S = ye(void 0), L = ye(void 0), O = ye(void 0), M = ye(void 0), F = ye({}), k = be(
    (ae) => {
      e(ae), a && a(ae);
    },
    [e, a]
  ), I = Ne(() => r ? r() : Ly, [r]), N = Ne(() => ({
    [ze.OT]: I.filter((Te) => nt.isBookOT(Te)),
    [ze.NT]: I.filter((Te) => nt.isBookNT(Te)),
    [ze.DC]: I.filter((Te) => nt.isBookDC(Te)),
    [ze.Extra]: I.filter((Te) => nt.extraBooks().includes(Te))
  }), [I]), R = Ne(() => Object.values(N).flat(), [N]), T = Ne(() => {
    if (!g.trim()) return N;
    const ae = {
      [ze.OT]: [],
      [ze.NT]: [],
      [ze.DC]: [],
      [ze.Extra]: []
    };
    return [ze.OT, ze.NT, ze.DC, ze.Extra].forEach((Be) => {
      ae[Be] = N[Be].filter((Ge) => ep(Ge, g, i));
    }), ae;
  }, [N, g, i]), A = Ne(
    () => aC(g, R, i),
    [g, R, i]
  ), q = be(() => {
    A && (k({
      book: A.book,
      chapterNum: A.chapterNum ?? 1,
      verseNum: A.verseNum ?? 1
    }), f(!1), w(""), h(""));
  }, [k, A]), V = be(
    (ae) => {
      if (zr(ae) <= 1) {
        k({
          book: ae,
          chapterNum: 1,
          verseNum: 1
        }), f(!1), w("");
        return;
      }
      C(ae), _("chapters");
    },
    [k]
  ), J = be(
    (ae) => {
      const Te = b === "chapters" ? y : A == null ? void 0 : A.book;
      Te && (k({
        book: Te,
        chapterNum: ae,
        verseNum: 1
      }), f(!1), _("books"), C(void 0), w(""));
    },
    [k, b, y, A]
  ), H = be(
    (ae) => {
      k(ae), f(!1), w("");
    },
    [k]
  ), W = lC(t, R, c, e), ne = be(() => {
    _("books"), C(void 0), setTimeout(() => {
      L.current && L.current.focus();
    }, 0);
  }, []), re = be(
    (ae) => {
      if (!ae && b === "chapters") {
        ne();
        return;
      }
      f(ae), ae && (_("books"), C(void 0), w(""));
    },
    [b, ne]
  ), { otLong: te, ntLong: Q, dcLong: ce, extraLong: pe } = {
    otLong: o == null ? void 0 : o["%scripture_section_ot_long%"],
    ntLong: o == null ? void 0 : o["%scripture_section_nt_long%"],
    dcLong: o == null ? void 0 : o["%scripture_section_dc_long%"],
    extraLong: o == null ? void 0 : o["%scripture_section_extra_long%"]
  }, we = be(
    (ae) => Py(ae, te, Q, ce, pe),
    [te, Q, ce, pe]
  ), ve = be(
    (ae) => A ? !!A.chapterNum && !ae.toString().includes(A.chapterNum.toString()) : !1,
    [A]
  ), _e = Ne(
    () => _s(
      t,
      i ? xs(t.book, i) : "English"
    ),
    [t, i]
  ), Ee = be((ae) => (Te) => {
    F.current[ae] = Te;
  }, []), fe = be((ae) => {
    (ae.key === "Home" || ae.key === "End") && ae.stopPropagation();
  }, []), Pe = be(
    (ae) => {
      if (ae.ctrlKey) return;
      const { isLetter: Te, isDigit: Be } = Gg(ae.key);
      if (b === "chapters") {
        if (ae.key === "Backspace") {
          ae.preventDefault(), ae.stopPropagation(), ne();
          return;
        }
        if (Te || Be) {
          if (ae.preventDefault(), ae.stopPropagation(), _("books"), C(void 0), Be && y) {
            const Ge = _o[y];
            w(`${Ge} ${ae.key}`);
          } else
            w(ae.key);
          setTimeout(() => {
            L.current && L.current.focus();
          }, 0);
          return;
        }
      }
      if ((b === "chapters" || b === "books" && A) && ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(ae.key)) {
        const Ge = b === "chapters" ? y : A == null ? void 0 : A.book;
        if (!Ge) return;
        const rt = (() => {
          if (!d) return 1;
          const $e = d.match(/(\d+)$/);
          return $e ? parseInt($e[1], 10) : 0;
        })(), vt = zr(Ge);
        if (!vt) return;
        let mt = rt;
        const Et = 6;
        switch (ae.key) {
          case "ArrowLeft":
            rt !== 0 && (mt = rt > 1 ? rt - 1 : vt);
            break;
          case "ArrowRight":
            rt !== 0 && (mt = rt < vt ? rt + 1 : 1);
            break;
          case "ArrowUp":
            mt = rt === 0 ? vt : Math.max(1, rt - Et);
            break;
          case "ArrowDown":
            mt = rt === 0 ? 1 : Math.min(vt, rt + Et);
            break;
          default:
            return;
        }
        mt !== rt && (ae.preventDefault(), ae.stopPropagation(), h(If(Ge, i, mt)), setTimeout(() => {
          const $e = F.current[mt];
          $e && $e.scrollIntoView({ block: "nearest", behavior: "smooth" });
        }, 0));
      }
    },
    [
      b,
      A,
      ne,
      y,
      d,
      i
    ]
  ), He = be((ae) => {
    if (ae.shiftKey || ae.key === "Tab" || ae.key === " ") return;
    const { isLetter: Te, isDigit: Be } = Gg(ae.key);
    (Te || Be) && (ae.preventDefault(), w((Ge) => Ge + ae.key), L.current.focus(), P(!1));
  }, []);
  return kn(() => {
    const ae = setTimeout(() => {
      if (u && b === "books" && O.current && M.current) {
        const Te = O.current, Be = M.current, Ge = Be.offsetTop, rt = Te.clientHeight, vt = Be.clientHeight, mt = Ge - rt / 2 + vt / 2;
        Te.scrollTo({
          top: Math.max(0, mt),
          behavior: "smooth"
        }), h(If(t.book));
      }
    }, 0);
    return () => {
      clearTimeout(ae);
    };
  }, [u, b, g, A, t.book]), kn(() => {
    if (b === "chapters" && y) {
      const ae = y === t.book;
      setTimeout(() => {
        if (O.current)
          if (ae) {
            const Te = F.current[t.chapterNum];
            Te && Te.scrollIntoView({ block: "center", behavior: "smooth" });
          } else
            O.current.scrollTo({ top: 0 });
        S.current && S.current.focus();
      }, 0);
    }
  }, [b, y, A, t.book, t.chapterNum]), /* @__PURE__ */ B(aa, { open: u, onOpenChange: re, children: [
    /* @__PURE__ */ p(la, { asChild: !0, children: /* @__PURE__ */ p(
      Me,
      {
        "aria-label": "book-chapter-trigger",
        variant: "outline",
        role: "combobox",
        "aria-expanded": u,
        className: G(
          "tw-h-8 tw-w-full tw-min-w-16 tw-max-w-48 tw-overflow-hidden tw-px-1",
          n
        ),
        children: /* @__PURE__ */ p("span", { className: "tw-truncate", children: _e })
      }
    ) }),
    /* @__PURE__ */ p(Zo, { id: l, forceMount: !0, className: "tw-w-[280px] tw-p-0", align: "center", children: /* @__PURE__ */ B(
      ia,
      {
        ref: S,
        onKeyDown: Pe,
        loop: !0,
        value: d,
        onValueChange: h,
        shouldFilter: !1,
        children: [
          b === "books" ? /* @__PURE__ */ B("div", { className: "tw-flex tw-items-end", children: [
            /* @__PURE__ */ B("div", { className: "tw-relative tw-flex-1", children: [
              /* @__PURE__ */ p(
                Dl,
                {
                  ref: L,
                  value: g,
                  onValueChange: w,
                  onKeyDown: fe,
                  onFocus: () => P(!1),
                  className: s && s.length > 0 ? "!tw-pr-10" : ""
                }
              ),
              s && s.length > 0 && /* @__PURE__ */ p(
                oC,
                {
                  recentSearches: s,
                  onSearchItemSelect: H,
                  renderItem: (ae) => _s(ae, "English"),
                  getItemKey: (ae) => `${ae.book}-${ae.chapterNum}-${ae.verseNum}`,
                  ariaLabel: o == null ? void 0 : o["%history_recentSearches_ariaLabel%"],
                  groupHeading: o == null ? void 0 : o["%history_recent%"]
                }
              )
            ] }),
            /* @__PURE__ */ p("div", { className: "tw-flex tw-items-center tw-gap-1 tw-border-b tw-pe-2", children: W.map(({ onClick: ae, disabled: Te, title: Be, icon: Ge }) => /* @__PURE__ */ p(
              Me,
              {
                variant: "ghost",
                size: "sm",
                onClick: () => {
                  P(!0), ae();
                },
                disabled: Te,
                className: "tw-h-10 tw-w-4 tw-p-0",
                title: Be,
                onKeyDown: He,
                children: /* @__PURE__ */ p(Ge, {})
              },
              Be
            )) })
          ] }) : /* @__PURE__ */ B("div", { className: "tw-flex tw-items-center tw-border-b tw-px-3 tw-py-2", children: [
            /* @__PURE__ */ p(
              Me,
              {
                variant: "ghost",
                size: "sm",
                onClick: ne,
                className: "tw-mr-2 tw-h-6 tw-w-6 tw-p-0",
                tabIndex: -1,
                children: c === "ltr" ? /* @__PURE__ */ p(V2, { className: "tw-h-4 tw-w-4" }) : /* @__PURE__ */ p(H2, { className: "tw-h-4 tw-w-4" })
              }
            ),
            y && /* @__PURE__ */ p("span", { tabIndex: -1, className: "tw-text-sm tw-font-medium", children: xs(y, i) })
          ] }),
          !D && /* @__PURE__ */ B(oa, { ref: O, children: [
            b === "books" && /* @__PURE__ */ B(Lt, { children: [
              !A && Object.entries(T).map(([ae, Te]) => {
                if (Te.length !== 0)
                  return (
                    // We are mapping over filteredBooksByType, which uses Section as key type
                    // eslint-disable-next-line no-type-assertion/no-type-assertion
                    /* @__PURE__ */ p(Mo, { heading: we(ae), children: Te.map((Be) => /* @__PURE__ */ p(
                      $y,
                      {
                        bookId: Be,
                        onSelect: (Ge) => V(Ge),
                        section: Wa(Be),
                        commandValue: `${Be} ${_o[Be]}`,
                        ref: Be === t.book ? M : void 0,
                        localizedBookNames: i
                      },
                      Be
                    )) }, ae)
                  );
              }),
              A && /* @__PURE__ */ p(Mo, { children: /* @__PURE__ */ p(
                Qo,
                {
                  value: `${A.book} ${_o[A.book]} ${A.chapterNum || ""}:${A.verseNum || ""})}`,
                  onSelect: q,
                  className: "tw-font-semibold tw-text-primary",
                  children: _s(
                    {
                      book: A.book,
                      chapterNum: A.chapterNum ?? 1,
                      verseNum: A.verseNum ?? 1
                    },
                    i ? Zh(A.book, i) : void 0
                  )
                },
                "top-match"
              ) }),
              A && zr(A.book) > 1 && /* @__PURE__ */ B(Lt, { children: [
                /* @__PURE__ */ p("div", { className: "tw-mb-2 tw-px-3 tw-text-sm tw-font-medium tw-text-muted-foreground", children: xs(A.book, i) }),
                /* @__PURE__ */ p(
                  Jg,
                  {
                    bookId: A.book,
                    scrRef: t,
                    onChapterSelect: J,
                    setChapterRef: Ee,
                    isChapterDimmed: ve,
                    className: "tw-px-4 tw-pb-4"
                  }
                )
              ] })
            ] }),
            b === "chapters" && y && /* @__PURE__ */ p(
              Jg,
              {
                bookId: y,
                scrRef: t,
                onChapterSelect: J,
                setChapterRef: Ee,
                className: "tw-p-4"
              }
            )
          ] })
        ]
      }
    ) })
  ] });
}
const ML = Object.freeze([
  "%scripture_section_ot_long%",
  "%scripture_section_nt_long%",
  "%scripture_section_dc_long%",
  "%scripture_section_extra_long%",
  "%history_recent%",
  "%history_recentSearches_ariaLabel%"
]), cC = Xi(
  "tw-text-sm tw-font-medium tw-leading-none peer-disabled:tw-cursor-not-allowed peer-disabled:tw-opacity-70"
), Vt = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(vy.Root, { ref: n, className: G("pr-twp", cC(), t), ...e }));
Vt.displayName = vy.Root.displayName;
const tp = Y.forwardRef(({ className: t, ...e }, n) => {
  const r = Jt();
  return /* @__PURE__ */ p(
    tl.Root,
    {
      className: G("pr-twp tw-grid tw-gap-2", t),
      ...e,
      ref: n,
      dir: r
    }
  );
});
tp.displayName = tl.Root.displayName;
const zc = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  tl.Item,
  {
    ref: n,
    className: G(
      "pr-twp tw-aspect-square tw-h-4 tw-w-4 tw-rounded-full tw-border tw-border-primary tw-text-primary tw-ring-offset-background focus:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-cursor-not-allowed disabled:tw-opacity-50",
      t
    ),
    ...e,
    children: /* @__PURE__ */ p(tl.Indicator, { className: "tw-flex tw-items-center tw-justify-center", children: /* @__PURE__ */ p(Iu, { className: "tw-h-2.5 tw-w-2.5 tw-fill-current tw-text-current" }) })
  }
));
zc.displayName = tl.Item.displayName;
function uC(t) {
  return typeof t == "string" ? t : typeof t == "number" ? t.toString() : t.label;
}
function Rf({
  id: t,
  options: e = [],
  className: n,
  buttonClassName: r,
  popoverContentClassName: i,
  value: o,
  onChange: s = () => {
  },
  getOptionLabel: a = uC,
  icon: l = void 0,
  buttonPlaceholder: c = "",
  textPlaceholder: u = "",
  commandEmptyMessage: f = "No option found",
  buttonVariant: d = "outline",
  alignDropDown: h = "start",
  isDisabled: g = !1,
  ...w
}) {
  const [b, _] = ue(!1);
  return /* @__PURE__ */ B(aa, { open: b, onOpenChange: _, ...w, children: [
    /* @__PURE__ */ p(la, { asChild: !0, children: /* @__PURE__ */ B(
      Me,
      {
        variant: d,
        role: "combobox",
        "aria-expanded": b,
        id: t,
        className: G(
          "tw-flex tw-w-[200px] tw-items-center tw-justify-between tw-overflow-hidden",
          r ?? n
        ),
        disabled: g,
        children: [
          /* @__PURE__ */ B("div", { className: "tw-flex tw-flex-1 tw-items-center tw-overflow-hidden", children: [
            l && /* @__PURE__ */ p("div", { className: "tw-pe-2", children: l }),
            /* @__PURE__ */ p("span", { className: G("tw-overflow-hidden tw-text-ellipsis tw-whitespace-nowrap"), children: o ? a(o) : c })
          ] }),
          /* @__PURE__ */ p(Wh, { className: "tw-ms-2 tw-h-4 tw-w-4 tw-shrink-0 tw-opacity-50" })
        ]
      }
    ) }),
    /* @__PURE__ */ p(
      Zo,
      {
        align: h,
        className: G("tw-w-[200px] tw-p-0", i),
        children: /* @__PURE__ */ B(ia, { children: [
          /* @__PURE__ */ p(Dl, { placeholder: u, className: "tw-text-inherit" }),
          /* @__PURE__ */ p(Lu, { children: f }),
          /* @__PURE__ */ p(oa, { children: e.map((y) => /* @__PURE__ */ B(
            Qo,
            {
              value: a(y),
              onSelect: () => {
                s(y), _(!1);
              },
              children: [
                /* @__PURE__ */ p(
                  xi,
                  {
                    className: G("tw-me-2 tw-h-4 tw-w-4", {
                      "tw-opacity-0": !o || a(o) !== a(y)
                    })
                  }
                ),
                a(y)
              ]
            },
            a(y)
          )) })
        ] })
      }
    )
  ] });
}
function dC({
  startChapter: t,
  endChapter: e,
  handleSelectStartChapter: n,
  handleSelectEndChapter: r,
  isDisabled: i = !1,
  chapterCount: o
}) {
  const s = Ne(
    () => Array.from({ length: o }, (c, u) => u + 1),
    [o]
  );
  return /* @__PURE__ */ B(Lt, { children: [
    /* @__PURE__ */ p(Vt, { htmlFor: "start-chapters-combobox", children: "Chapters" }),
    /* @__PURE__ */ p(
      Rf,
      {
        isDisabled: i,
        onChange: (c) => {
          n(c), c > e && r(c);
        },
        buttonClassName: "tw-me-2 tw-ms-2 tw-w-20",
        options: s,
        getOptionLabel: (c) => c.toString(),
        value: t
      },
      "start chapter"
    ),
    /* @__PURE__ */ p(Vt, { htmlFor: "end-chapters-combobox", children: "to" }),
    /* @__PURE__ */ p(
      Rf,
      {
        isDisabled: i,
        onChange: (c) => {
          r(c), c < t && n(c);
        },
        buttonClassName: "tw-ms-2 tw-w-20",
        options: s,
        getOptionLabel: (c) => c.toString(),
        value: e
      },
      "end chapter"
    )
  ] });
}
var fC = /* @__PURE__ */ ((t) => (t.CURRENT_BOOK = "current book", t.CHOOSE_BOOKS = "choose books", t))(fC || {});
const OL = Object.freeze([
  "%webView_bookSelector_currentBook%",
  "%webView_bookSelector_choose%",
  "%webView_bookSelector_chooseBooks%"
]), qd = (t, e) => t[e] ?? e;
function IL({
  handleBookSelectionModeChange: t,
  currentBookName: e,
  onSelectBooks: n,
  selectedBookIds: r,
  chapterCount: i,
  endChapter: o,
  handleSelectEndChapter: s,
  startChapter: a,
  handleSelectStartChapter: l,
  localizedStrings: c
}) {
  const u = qd(c, "%webView_bookSelector_currentBook%"), f = qd(c, "%webView_bookSelector_choose%"), d = qd(c, "%webView_bookSelector_chooseBooks%"), [h, g] = ue(
    "current book"
    /* CURRENT_BOOK */
  ), w = (b) => {
    g(b), t(b);
  };
  return /* @__PURE__ */ p(
    tp,
    {
      className: "pr-twp tw-flex",
      value: h,
      onValueChange: (b) => w(b),
      children: /* @__PURE__ */ B("div", { className: "tw-flex tw-w-full tw-flex-col tw-gap-4", children: [
        /* @__PURE__ */ B("div", { className: "tw-grid tw-grid-cols-[25%,25%,50%]", children: [
          /* @__PURE__ */ B("div", { className: "tw-flex tw-items-center", children: [
            /* @__PURE__ */ p(zc, {
              value: "current book"
              /* CURRENT_BOOK */
            }),
            /* @__PURE__ */ p(Vt, { className: "tw-ms-1", children: u })
          ] }),
          /* @__PURE__ */ p(Vt, { className: "tw-flex tw-items-center", children: e }),
          /* @__PURE__ */ p("div", { className: "tw-flex tw-items-center tw-justify-end", children: /* @__PURE__ */ p(
            dC,
            {
              isDisabled: h === "choose books",
              handleSelectStartChapter: l,
              handleSelectEndChapter: s,
              chapterCount: i,
              startChapter: a,
              endChapter: o
            }
          ) })
        ] }),
        /* @__PURE__ */ B("div", { className: "tw-grid tw-grid-cols-[25%,50%,25%]", children: [
          /* @__PURE__ */ B("div", { className: "tw-flex tw-items-center", children: [
            /* @__PURE__ */ p(zc, {
              value: "choose books"
              /* CHOOSE_BOOKS */
            }),
            /* @__PURE__ */ p(Vt, { className: "tw-ms-1", children: d })
          ] }),
          /* @__PURE__ */ p(Vt, { className: "tw-flex tw-items-center", children: r.map((b) => nt.bookIdToEnglishName(b)).join(", ") }),
          /* @__PURE__ */ p(
            Me,
            {
              disabled: h === "current book",
              onClick: () => n(),
              children: f
            }
          )
        ] })
      ] })
    }
  );
}
const np = Sl(void 0);
function Sr() {
  const t = Tl(np);
  if (!t)
    throw new Error("useMenuContext must be used within a MenuContext.Provider.");
  return t;
}
const Ci = Xi("", {
  variants: {
    variant: {
      default: "",
      muted: "hover:tw-bg-muted hover:tw-text-foreground focus:tw-bg-muted focus:tw-text-foreground data-[state=open]:tw-bg-muted data-[state=open]:tw-text-foreground"
    }
  },
  defaultVariants: {
    variant: "default"
  }
}), nl = ft.Trigger, Fy = ft.Group, hC = ft.Portal, pC = ft.Sub, Pf = ft.RadioGroup;
function Os({ variant: t = "default", ...e }) {
  const n = Y.useMemo(
    () => ({
      variant: t
    }),
    [t]
  );
  return /* @__PURE__ */ p(np.Provider, { value: n, children: /* @__PURE__ */ p(ft.Root, { ...e }) });
}
const By = Y.forwardRef(({ className: t, inset: e, children: n, ...r }, i) => {
  const o = Sr();
  return /* @__PURE__ */ B(
    ft.SubTrigger,
    {
      ref: i,
      className: G(
        "tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none focus:tw-bg-accent data-[state=open]:tw-bg-accent",
        e && "tw-pl-8",
        t,
        Ci({ variant: o.variant })
        // CUSTOM use context to add variants
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ p(Ds, { className: "tw-ml-auto tw-h-4 tw-w-4" })
      ]
    }
  );
});
By.displayName = ft.SubTrigger.displayName;
const qy = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  ft.SubContent,
  {
    ref: n,
    className: G(
      "pr-twp tw-z-50 tw-min-w-[8rem] tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-p-1 tw-text-popover-foreground tw-shadow-lg data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
      t
    ),
    ...e
  }
));
qy.displayName = ft.SubContent.displayName;
const Io = Y.forwardRef(({ className: t, sideOffset: e = 4, children: n, ...r }, i) => {
  const o = Jt();
  return /* @__PURE__ */ p(ft.Portal, { children: /* @__PURE__ */ p(
    ft.Content,
    {
      ref: i,
      sideOffset: e,
      className: G(
        /* adding pr-twp because the dropdown content is added to the dom as a sibling to the app root */
        "pr-twp tw-z-50 tw-min-w-[8rem] tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-p-1 tw-text-popover-foreground tw-shadow-md data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
        t
      ),
      ...r,
      children: /* @__PURE__ */ p("div", { dir: o, children: n })
    }
  ) });
});
Io.displayName = ft.Content.displayName;
const jy = Y.forwardRef(({ className: t, inset: e, ...n }, r) => {
  const i = Jt(), o = Sr();
  return /* @__PURE__ */ p(
    ft.Item,
    {
      ref: r,
      className: G(
        // removed: tw-relative focus:tw-text-accent-foreground
        "tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none tw-transition-colors focus:tw-bg-accent data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
        e && "tw-pl-8",
        t,
        Ci({ variant: o.variant })
        // CUSTOM use context to add variants
      ),
      ...n,
      dir: i
    }
  );
});
jy.displayName = ft.Item.displayName;
const rp = Y.forwardRef(({ className: t, children: e, checked: n, ...r }, i) => {
  const o = Sr();
  return /* @__PURE__ */ B(
    ft.CheckboxItem,
    {
      ref: i,
      className: G(
        "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pe-2 tw-ps-8 tw-text-sm tw-outline-none tw-transition-colors focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
        t,
        Ci({ variant: o.variant })
        // CUSTOM use context to add variants
      ),
      checked: n,
      ...r,
      children: [
        /* @__PURE__ */ p("span", { className: "tw-absolute tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center ltr:tw-left-2 rtl:tw-right-2", children: /* @__PURE__ */ p(ft.ItemIndicator, { children: /* @__PURE__ */ p(xi, { className: "tw-h-4 tw-w-4" }) }) }),
        e
      ]
    }
  );
});
rp.displayName = ft.CheckboxItem.displayName;
const bo = Y.forwardRef(({ className: t, children: e, ...n }, r) => {
  const i = Sr();
  return /* @__PURE__ */ B(
    ft.RadioItem,
    {
      ref: r,
      className: G(
        "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pe-2 tw-ps-8 tw-text-sm tw-outline-none tw-transition-colors focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
        t,
        Ci({ variant: i.variant })
        // CUSTOM use context to add variants
      ),
      ...n,
      children: [
        /* @__PURE__ */ p("span", { className: "tw-absolute tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center ltr:tw-left-2 rtl:tw-right-2", children: /* @__PURE__ */ p(ft.ItemIndicator, { children: /* @__PURE__ */ p(Iu, { className: "tw-h-2 tw-w-2 tw-fill-current" }) }) }),
        e
      ]
    }
  );
});
bo.displayName = ft.RadioItem.displayName;
const $u = Y.forwardRef(({ className: t, inset: e, ...n }, r) => /* @__PURE__ */ p(
  ft.Label,
  {
    ref: r,
    className: G("tw-px-2 tw-py-1.5 tw-text-sm tw-font-semibold", e && "tw-pl-8", t),
    ...n
  }
));
$u.displayName = ft.Label.displayName;
const Ml = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  ft.Separator,
  {
    ref: n,
    className: G("tw--mx-1 tw-my-1 tw-h-px tw-bg-muted", t),
    ...e
  }
));
Ml.displayName = ft.Separator.displayName;
function gC({ className: t, ...e }) {
  return /* @__PURE__ */ p(
    "span",
    {
      className: G("tw-ms-auto tw-text-xs tw-tracking-widest tw-opacity-60", t),
      ...e
    }
  );
}
gC.displayName = "DropdownMenuShortcut";
function wC({ table: t }) {
  return /* @__PURE__ */ B(Os, { children: [
    /* @__PURE__ */ p(R1, { asChild: !0, children: /* @__PURE__ */ B(Me, { variant: "outline", size: "sm", className: "tw-ml-auto tw-hidden tw-h-8 lg:tw-flex", children: [
      /* @__PURE__ */ p(K2, { className: "tw-mr-2 tw-h-4 tw-w-4" }),
      "View"
    ] }) }),
    /* @__PURE__ */ B(Io, { align: "end", className: "tw-w-[150px]", children: [
      /* @__PURE__ */ p($u, { children: "Toggle columns" }),
      /* @__PURE__ */ p(Ml, {}),
      t.getAllColumns().filter((e) => e.getCanHide()).map((e) => /* @__PURE__ */ p(
        rp,
        {
          className: "tw-capitalize",
          checked: e.getIsVisible(),
          onCheckedChange: (n) => e.toggleVisibility(!!n),
          children: e.id
        },
        e.id
      ))
    ] })
  ] });
}
const Is = kt.Root, mC = kt.Group, Rs = kt.Value, bC = Xi(
  "tw-flex tw-h-10 tw-w-full tw-items-center tw-justify-between tw-rounded-md tw-border tw-border-input tw-bg-background tw-px-3 tw-py-2 tw-text-sm tw-ring-offset-background placeholder:tw-text-muted-foreground focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-ring focus:tw-ring-offset-2 disabled:tw-cursor-not-allowed disabled:tw-opacity-50 [&>span]:tw-line-clamp-1",
  {
    variants: {
      size: {
        default: "tw-h-10 tw-px-4 tw-py-2",
        sm: "tw-h-8 tw-rounded-md tw-px-3",
        lg: "tw-h-11 tw-rounded-md tw-px-8",
        icon: "tw-h-10 tw-w-10"
      }
    },
    defaultVariants: {
      size: "default"
    }
  }
), Ro = Y.forwardRef(({ className: t, children: e, size: n, ...r }, i) => {
  const o = Jt();
  return /* @__PURE__ */ B(
    kt.Trigger,
    {
      className: G(bC({ size: n, className: t })),
      ref: i,
      ...r,
      dir: o,
      children: [
        e,
        /* @__PURE__ */ p(kt.Icon, { asChild: !0, children: /* @__PURE__ */ p(Ru, { className: "tw-h-4 tw-w-4 tw-opacity-50" }) })
      ]
    }
  );
});
Ro.displayName = kt.Trigger.displayName;
const Uy = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  kt.ScrollUpButton,
  {
    ref: n,
    className: G("tw-flex tw-cursor-default tw-items-center tw-justify-center tw-py-1", t),
    ...e,
    children: /* @__PURE__ */ p(W2, { className: "tw-h-4 tw-w-4" })
  }
));
Uy.displayName = kt.ScrollUpButton.displayName;
const zy = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  kt.ScrollDownButton,
  {
    ref: n,
    className: G("tw-flex tw-cursor-default tw-items-center tw-justify-center tw-py-1", t),
    ...e,
    children: /* @__PURE__ */ p(Ru, { className: "tw-h-4 tw-w-4" })
  }
));
zy.displayName = kt.ScrollDownButton.displayName;
const Po = Y.forwardRef(({ className: t, children: e, position: n = "popper", ...r }, i) => {
  const o = Jt();
  return /* @__PURE__ */ p(kt.Portal, { children: /* @__PURE__ */ B(
    kt.Content,
    {
      ref: i,
      className: G(
        "pr-twp tw-relative tw-z-50 tw-max-h-96 tw-min-w-[8rem] tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-text-popover-foreground tw-shadow-md data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
        n === "popper" && "data-[side=bottom]:tw-translate-y-1 data-[side=left]:tw--translate-x-1 data-[side=right]:tw-translate-x-1 data-[side=top]:tw--translate-y-1",
        t
      ),
      position: n,
      ...r,
      children: [
        /* @__PURE__ */ p(Uy, {}),
        /* @__PURE__ */ p(
          kt.Viewport,
          {
            className: G(
              "tw-p-1",
              n === "popper" && "tw-h-[var(--radix-select-trigger-height)] tw-w-full tw-min-w-[var(--radix-select-trigger-width)]"
            ),
            children: /* @__PURE__ */ p("div", { dir: o, children: e })
          }
        ),
        /* @__PURE__ */ p(zy, {})
      ]
    }
  ) });
});
Po.displayName = kt.Content.displayName;
const yC = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  kt.Label,
  {
    ref: n,
    className: G("tw-py-1.5 tw-pl-8 tw-pr-2 tw-text-sm tw-font-semibold", t),
    ...e
  }
));
yC.displayName = kt.Label.displayName;
const er = Y.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ B(
  kt.Item,
  {
    ref: r,
    className: G(
      "tw-relative tw-flex tw-w-full tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pe-2 tw-ps-8 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
      t
    ),
    ...n,
    children: [
      /* @__PURE__ */ p("span", { className: "tw-absolute tw-start-2 tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center", children: /* @__PURE__ */ p(kt.ItemIndicator, { children: /* @__PURE__ */ p(xi, { className: "tw-h-4 tw-w-4" }) }) }),
      /* @__PURE__ */ p(kt.ItemText, { children: e })
    ]
  }
));
er.displayName = kt.Item.displayName;
const vC = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  kt.Separator,
  {
    ref: n,
    className: G("tw--mx-1 tw-my-1 tw-h-px tw-bg-muted", t),
    ...e
  }
));
vC.displayName = kt.Separator.displayName;
function _C({ table: t }) {
  return /* @__PURE__ */ p("div", { className: "tw-flex tw-items-center tw-justify-between tw-px-2 tw-pb-3 tw-pt-3", children: /* @__PURE__ */ B("div", { className: "tw-flex tw-items-center tw-space-x-6 lg:tw-space-x-8", children: [
    /* @__PURE__ */ B("div", { className: "tw-flex-1 tw-text-sm tw-text-muted-foreground", children: [
      t.getFilteredSelectedRowModel().rows.length,
      " of",
      " ",
      t.getFilteredRowModel().rows.length,
      " row(s) selected"
    ] }),
    /* @__PURE__ */ B("div", { className: "tw-flex tw-items-center tw-space-x-2", children: [
      /* @__PURE__ */ p("p", { className: "tw-text-nowrap tw-text-sm tw-font-medium", children: "Rows per page" }),
      /* @__PURE__ */ B(
        Is,
        {
          value: `${t.getState().pagination.pageSize}`,
          onValueChange: (e) => {
            t.setPageSize(Number(e));
          },
          children: [
            /* @__PURE__ */ p(Ro, { className: "tw-h-8 tw-w-[70px]", children: /* @__PURE__ */ p(Rs, { placeholder: t.getState().pagination.pageSize }) }),
            /* @__PURE__ */ p(Po, { side: "top", children: [10, 20, 30, 40, 50].map((e) => /* @__PURE__ */ p(er, { value: `${e}`, children: e }, e)) })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ B("div", { className: "tw-flex tw-w-[100px] tw-items-center tw-justify-center tw-text-sm tw-font-medium", children: [
      "Page ",
      t.getState().pagination.pageIndex + 1,
      " of ",
      t.getPageCount()
    ] }),
    /* @__PURE__ */ B("div", { className: "tw-flex tw-items-center tw-space-x-2", children: [
      /* @__PURE__ */ B(
        Me,
        {
          variant: "outline",
          size: "icon",
          className: "tw-hidden tw-h-8 tw-w-8 tw-p-0 lg:tw-flex",
          onClick: () => t.setPageIndex(0),
          disabled: !t.getCanPreviousPage(),
          children: [
            /* @__PURE__ */ p("span", { className: "tw-sr-only", children: "Go to first page" }),
            /* @__PURE__ */ p(G2, { className: "tw-h-4 tw-w-4" })
          ]
        }
      ),
      /* @__PURE__ */ B(
        Me,
        {
          variant: "outline",
          size: "icon",
          className: "tw-h-8 tw-w-8 tw-p-0",
          onClick: () => t.previousPage(),
          disabled: !t.getCanPreviousPage(),
          children: [
            /* @__PURE__ */ p("span", { className: "tw-sr-only", children: "Go to previous page" }),
            /* @__PURE__ */ p(J2, { className: "tw-h-4 tw-w-4" })
          ]
        }
      ),
      /* @__PURE__ */ B(
        Me,
        {
          variant: "outline",
          size: "icon",
          className: "tw-h-8 tw-w-8 tw-p-0",
          onClick: () => t.nextPage(),
          disabled: !t.getCanNextPage(),
          children: [
            /* @__PURE__ */ p("span", { className: "tw-sr-only", children: "Go to next page" }),
            /* @__PURE__ */ p(X2, { className: "tw-h-4 tw-w-4" })
          ]
        }
      ),
      /* @__PURE__ */ B(
        Me,
        {
          variant: "outline",
          size: "icon",
          className: "tw-hidden tw-h-8 tw-w-8 tw-p-0 lg:tw-flex",
          onClick: () => t.setPageIndex(t.getPageCount() - 1),
          disabled: !t.getCanNextPage(),
          children: [
            /* @__PURE__ */ p("span", { className: "tw-sr-only", children: "Go to last page" }),
            /* @__PURE__ */ p(Y2, { className: "tw-h-4 tw-w-4" })
          ]
        }
      )
    ] })
  ] }) });
}
const Xg = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [contenteditable],
  tr:not([disabled])
`;
function xC(t) {
  return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length);
}
function rl(t, e) {
  const n = e ? `${Xg}, ${e}` : Xg;
  return Array.from(t.querySelectorAll(n)).filter(
    (r) => !r.hasAttribute("disabled") && !r.getAttribute("aria-hidden") && xC(r)
  );
}
const Fu = Y.forwardRef(({ className: t, stickyHeader: e, ...n }, r) => {
  const i = Y.useRef(null);
  Y.useEffect(() => {
    typeof r == "function" ? r(i.current) : r && "current" in r && (r.current = i.current);
  }, [r]), Y.useEffect(() => {
    const s = i.current;
    if (!s) return;
    const a = () => {
      requestAnimationFrame(() => {
        rl(s, '[tabindex]:not([tabindex="-1"])').forEach((u) => {
          u.setAttribute("tabindex", "-1");
        });
      });
    };
    a();
    const l = new MutationObserver(() => {
      a();
    });
    return l.observe(s, {
      childList: !0,
      // Watch for added/removed elements
      subtree: !0,
      // Include descendants
      attributes: !0,
      attributeFilter: ["tabindex"]
      // Watch for tabindex changes
    }), () => {
      l.disconnect();
    };
  }, []);
  const o = (s) => {
    const { current: a } = i;
    if (a) {
      if (s.key === "ArrowDown") {
        s.preventDefault(), rl(a)[0].focus();
        return;
      }
      s.key === " " && document.activeElement === a && s.preventDefault();
    }
  };
  return /* @__PURE__ */ p("div", { className: G("pr-twp tw-relative tw-w-full", { "tw-p-1": e }), children: /* @__PURE__ */ p(
    "table",
    {
      tabIndex: 0,
      onKeyDown: o,
      ref: i,
      className: G(
        "tw-w-full tw-caption-bottom tw-text-sm tw-outline-none",
        // CUSTOM: Add outline-none to remove duplicate outline
        "focus:tw-relative focus:tw-z-10 focus:tw-ring-2 focus:tw-ring-ring focus:tw-ring-offset-1 focus:tw-ring-offset-background",
        // CUSTOM: Add focus styles
        t
      ),
      "aria-label": "Table",
      "aria-labelledby": "table-label",
      ...n
    }
  ) });
});
Fu.displayName = "Table";
const Bu = Y.forwardRef(({ className: t, stickyHeader: e, ...n }, r) => /* @__PURE__ */ p(
  "thead",
  {
    ref: r,
    className: G(
      {
        "tw-sticky tw-top-[-1px] tw-z-20 tw-bg-background tw-drop-shadow-sm": e
      },
      "[&_tr]:tw-border-b",
      t
    ),
    ...n
  }
));
Bu.displayName = "TableHeader";
const qu = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p("tbody", { ref: n, className: G("[&_tr:last-child]:tw-border-0", t), ...e }));
qu.displayName = "TableBody";
const CC = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  "tfoot",
  {
    ref: n,
    className: G("tw-border-t tw-bg-muted/50 tw-font-medium [&>tr]:last:tw-border-b-0", t),
    ...e
  }
));
CC.displayName = "TableFooter";
function kC(t) {
  Y.useEffect(() => {
    const e = t.current;
    if (!e) return;
    const n = (r) => {
      if (e.contains(document.activeElement)) {
        if (r.key === "ArrowRight" || r.key === "ArrowLeft") {
          r.preventDefault(), r.stopPropagation();
          const i = t.current ? rl(t.current) : [], o = i.indexOf(document.activeElement), s = r.key === "ArrowRight" ? o + 1 : o - 1;
          s >= 0 && s < i.length && i[s].focus();
        }
        r.key === "Escape" && (r.preventDefault(), e.focus()), (r.key === "ArrowDown" || r.key === "ArrowUp") && r.preventDefault();
      }
    };
    return e.addEventListener("keydown", n), () => {
      e.removeEventListener("keydown", n);
    };
  }, [t]);
}
function EC(t, e, n) {
  let r;
  return n === "ArrowLeft" && e > 0 ? r = t[e - 1] : n === "ArrowRight" && e < t.length - 1 && (r = t[e + 1]), r ? (requestAnimationFrame(() => r.focus()), !0) : !1;
}
function NC(t, e, n) {
  let r;
  return n === "ArrowDown" && e < t.length - 1 ? r = t[e + 1] : n === "ArrowUp" && e > 0 && (r = t[e - 1]), r ? (requestAnimationFrame(() => r.focus()), !0) : !1;
}
const hi = Y.forwardRef(({ className: t, onKeyDown: e, onSelect: n, setFocusAlsoRunsSelect: r = !1, ...i }, o) => {
  const s = Y.useRef(null);
  Y.useEffect(() => {
    typeof o == "function" ? o(s.current) : o && "current" in o && (o.current = s.current);
  }, [o]), kC(s);
  const a = Y.useMemo(
    () => s.current ? rl(s.current) : [],
    [s]
  ), l = Y.useCallback(
    (u) => {
      const { current: f } = s;
      if (!f || !f.parentElement) return;
      const d = f.closest("table"), h = d ? (
        // getFocusableElements returns an HTMLElement[] but we are filtering for HTMLTableRowElements
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        rl(d).filter(
          (b) => b.tagName === "TR"
        )
      ) : [], g = h.indexOf(f), w = a.indexOf(
        // activeElement is generic Element, so we need to cast it to HTMLElement
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        document.activeElement
      );
      if (u.key === "ArrowDown" || u.key === "ArrowUp")
        u.preventDefault(), NC(h, g, u.key);
      else if (u.key === "ArrowLeft" || u.key === "ArrowRight")
        u.preventDefault(), EC(a, w, u.key);
      else if (u.key === "Escape") {
        u.preventDefault();
        const b = f.closest("table");
        b && b.focus();
      }
      e == null || e(u);
    },
    [s, a, e]
  ), c = Y.useCallback(
    (u) => {
      r && (n == null || n(u));
    },
    [r, n]
  );
  return /* @__PURE__ */ p(
    "tr",
    {
      ref: s,
      tabIndex: -1,
      onKeyDown: l,
      onFocus: c,
      className: G(
        // CUSTOM: Add focus styles and add tw-outline-none so there isn't a duplicate outline
        "tw-border-b tw-outline-none tw-transition-colors hover:tw-bg-muted/50",
        "focus:tw-relative focus:tw-z-10 focus:tw-ring-2 focus:tw-ring-ring focus:tw-ring-offset-1 focus:tw-ring-offset-background",
        "data-[state=selected]:tw-bg-muted",
        t
      ),
      ...i
    }
  );
});
hi.displayName = "TableRow";
const il = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  "th",
  {
    ref: n,
    className: G(
      "tw-h-12 tw-px-4 tw-text-start tw-align-middle tw-font-medium tw-text-muted-foreground [&:has([role=checkbox])]:tw-pe-0",
      t
    ),
    ...e
  }
));
il.displayName = "TableHead";
const xo = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  "td",
  {
    ref: n,
    className: G("tw-p-4 tw-align-middle [&:has([role=checkbox])]:tw-pe-0", t),
    ...e
  }
));
xo.displayName = "TableCell";
const SC = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  "caption",
  {
    ref: n,
    className: G("tw-mt-4 tw-text-sm tw-text-muted-foreground", t),
    ...e
  }
));
SC.displayName = "TableCaption";
function Lf({ className: t, ...e }) {
  return /* @__PURE__ */ p(
    "div",
    {
      className: G("pr-twp tw-animate-pulse tw-rounded-md tw-bg-muted", t),
      ...e
    }
  );
}
function TC({
  columns: t,
  data: e,
  enablePagination: n = !1,
  showPaginationControls: r = !1,
  showColumnVisibilityControls: i = !1,
  stickyHeader: o = !1,
  onRowClickHandler: s = () => {
  },
  id: a,
  isLoading: l = !1,
  noResultsMessage: c
}) {
  var S;
  const [u, f] = ue([]), [d, h] = ue([]), [g, w] = ue({}), [b, _] = ue({}), y = Ne(() => e ?? [], [e]), C = _y({
    data: y,
    columns: t,
    getCoreRowModel: Cy(),
    ...n && { getPaginationRowModel: M1() },
    onSortingChange: f,
    getSortedRowModel: xy(),
    onColumnFiltersChange: h,
    getFilteredRowModel: D1(),
    onColumnVisibilityChange: w,
    onRowSelectionChange: _,
    state: {
      sorting: u,
      columnFilters: d,
      columnVisibility: g,
      rowSelection: b
    }
  }), D = C.getVisibleFlatColumns();
  let P;
  return l ? P = Array.from({ length: 10 }).map((M, F) => `skeleton-row-${F}`).map((M) => /* @__PURE__ */ p(hi, { children: /* @__PURE__ */ p(xo, { colSpan: D.length ?? t.length, className: "tw-border-0 tw-p-0", children: /* @__PURE__ */ p("div", { className: "tw-w-full tw-py-2", children: /* @__PURE__ */ p(Lf, { className: "tw-h-14 tw-w-full tw-rounded-md" }) }) }) }, M)) : ((S = C.getRowModel().rows) == null ? void 0 : S.length) > 0 ? P = C.getRowModel().rows.map((L) => /* @__PURE__ */ p(
    hi,
    {
      onClick: () => s(L, C),
      "data-state": L.getIsSelected() && "selected",
      children: L.getVisibleCells().map((O) => /* @__PURE__ */ p(xo, { children: Ga(O.column.columnDef.cell, O.getContext()) }, O.id))
    },
    L.id
  )) : P = /* @__PURE__ */ p(hi, { children: /* @__PURE__ */ p(xo, { colSpan: t.length, className: "tw-h-24 tw-text-center", children: c }) }), /* @__PURE__ */ B("div", { className: "pr-twp", id: a, children: [
    i && /* @__PURE__ */ p(wC, { table: C }),
    /* @__PURE__ */ B(Fu, { stickyHeader: o, children: [
      /* @__PURE__ */ p(Bu, { stickyHeader: o, children: C.getHeaderGroups().map((L) => /* @__PURE__ */ p(hi, { children: L.headers.map((O) => /* @__PURE__ */ p(il, { children: O.isPlaceholder ? void 0 : Ga(O.column.columnDef.header, O.getContext()) }, O.id)) }, L.id)) }),
      /* @__PURE__ */ p(qu, { children: P })
    ] }),
    n && /* @__PURE__ */ B("div", { className: "tw-flex tw-items-center tw-justify-end tw-space-x-2 tw-py-4", children: [
      /* @__PURE__ */ p(
        Me,
        {
          variant: "outline",
          size: "sm",
          onClick: () => C.previousPage(),
          disabled: !C.getCanPreviousPage(),
          children: "Previous"
        }
      ),
      /* @__PURE__ */ p(
        Me,
        {
          variant: "outline",
          size: "sm",
          onClick: () => C.nextPage(),
          disabled: !C.getCanNextPage(),
          children: "Next"
        }
      )
    ] }),
    n && r && /* @__PURE__ */ p(_C, { table: C })
  ] });
}
function RL({ id: t, markdown: e, className: n, anchorTarget: r }) {
  const i = Ne(
    () => ({
      overrides: {
        a: {
          props: {
            target: r
          }
        }
      }
    }),
    [r]
  );
  return /* @__PURE__ */ p("div", { id: t, className: G("pr-twp tw-prose", n), children: /* @__PURE__ */ p(P1, { options: i, children: e }) });
}
const AC = Object.freeze([
  "%webView_error_dump_header%",
  "%webView_error_dump_info_message%"
]), Yg = (t, e) => t[e] ?? e;
function DC({
  errorDetails: t,
  handleCopyNotify: e,
  localizedStrings: n,
  id: r
}) {
  const i = Yg(n, "%webView_error_dump_header%"), o = Yg(n, "%webView_error_dump_info_message%");
  function s() {
    navigator.clipboard.writeText(t), e && e();
  }
  return /* @__PURE__ */ B(
    "div",
    {
      id: r,
      className: "tw-inline-flex tw-w-full tw-flex-col tw-items-start tw-justify-start tw-gap-4",
      children: [
        /* @__PURE__ */ B("div", { className: "tw-inline-flex tw-items-start tw-justify-start tw-gap-4 tw-self-stretch", children: [
          /* @__PURE__ */ B("div", { className: "tw-inline-flex tw-flex-1 tw-flex-col tw-items-start tw-justify-start", children: [
            /* @__PURE__ */ p("div", { className: "tw-text-color-text tw-justify-center tw-text-center tw-text-lg tw-font-semibold tw-leading-loose", children: i }),
            /* @__PURE__ */ p("div", { className: "tw-justify-center tw-self-stretch tw-text-sm tw-font-normal tw-leading-tight tw-text-muted-foreground", children: o })
          ] }),
          /* @__PURE__ */ p(Me, { variant: "secondary", size: "icon", className: "size-8", onClick: () => s(), children: /* @__PURE__ */ p(yy, {}) })
        ] }),
        /* @__PURE__ */ p("div", { className: "tw-prose tw-w-full", children: /* @__PURE__ */ p("pre", { className: "tw-text-xs", children: t }) })
      ]
    }
  );
}
const PL = Object.freeze([
  ...AC,
  "%webView_error_dump_copied_message%"
]);
function LL({
  errorDetails: t,
  handleCopyNotify: e,
  localizedStrings: n,
  children: r,
  className: i,
  id: o
}) {
  const [s, a] = ue(!1), l = () => {
    a(!0), e && e();
  };
  return /* @__PURE__ */ B(aa, { onOpenChange: (u) => {
    u || a(!1);
  }, children: [
    /* @__PURE__ */ p(la, { asChild: !0, children: r }),
    /* @__PURE__ */ B(Zo, { id: o, className: G("tw-min-w-80 tw-max-w-96", i), children: [
      s && n["%webView_error_dump_copied_message%"] && /* @__PURE__ */ p(Vt, { children: n["%webView_error_dump_copied_message%"] }),
      /* @__PURE__ */ p(
        DC,
        {
          errorDetails: t,
          handleCopyNotify: l,
          localizedStrings: n
        }
      )
    ] })
  ] });
}
var MC = /* @__PURE__ */ ((t) => (t[t.Check = 0] = "Check", t[t.Radio = 1] = "Radio", t))(MC || {});
function $L({ id: t, label: e, groups: n }) {
  const [r, i] = ue(
    Object.fromEntries(
      n.map(
        (c, u) => c.itemType === 0 ? [u, []] : void 0
      ).filter((c) => !!c)
    )
  ), [o, s] = ue({}), a = (c, u) => {
    const f = !r[c][u];
    i((h) => (h[c][u] = f, { ...h }));
    const d = n[c].items[u];
    d.onUpdate(d.id, f);
  }, l = (c, u) => {
    s((d) => (d[c] = u, { ...d }));
    const f = n[c].items.find((d) => d.id === u);
    f ? f.onUpdate(u) : console.error(`Could not find dropdown radio item with id '${u}'!`);
  };
  return /* @__PURE__ */ p("div", { id: t, children: /* @__PURE__ */ B(Os, { children: [
    /* @__PURE__ */ p(nl, { asChild: !0, children: /* @__PURE__ */ B(Me, { variant: "default", children: [
      /* @__PURE__ */ p(Q2, { size: 16, className: "tw-mr-2 tw-h-4 tw-w-4" }),
      e,
      /* @__PURE__ */ p(Ru, { size: 16, className: "tw-ml-2 tw-h-4 tw-w-4" })
    ] }) }),
    /* @__PURE__ */ p(Io, { children: n.map((c, u) => /* @__PURE__ */ B("div", { children: [
      /* @__PURE__ */ p($u, { children: c.label }),
      /* @__PURE__ */ p(Fy, { children: c.itemType === 0 ? /* @__PURE__ */ p(Lt, { children: c.items.map((f, d) => /* @__PURE__ */ p("div", { children: /* @__PURE__ */ p(
        rp,
        {
          checked: r[u][d],
          onCheckedChange: () => a(u, d),
          children: f.label
        }
      ) }, f.id)) }) : /* @__PURE__ */ p(
        Pf,
        {
          value: o[u],
          onValueChange: (f) => l(u, f),
          children: c.items.map((f) => /* @__PURE__ */ p("div", { children: /* @__PURE__ */ p(bo, { value: f.id, children: f.label }) }, f.id))
        }
      ) }),
      /* @__PURE__ */ p(Ml, {})
    ] }, c.label)) })
  ] }) });
}
function FL({
  id: t,
  category: e,
  downloads: n,
  languages: r,
  moreInfoUrl: i,
  handleMoreInfoLinkClick: o,
  supportUrl: s,
  handleSupportLinkClick: a
}) {
  const l = new E1("en", {
    notation: "compact",
    compactDisplay: "short"
  }).format(Object.values(n).reduce((u, f) => u + f, 0)), c = () => {
    window.scrollTo(0, document.body.scrollHeight);
  };
  return /* @__PURE__ */ B(
    "div",
    {
      id: t,
      className: "pr-twp tw-flex tw-items-center tw-justify-center tw-gap-4 tw-divide-x tw-border-b tw-border-t tw-py-2 tw-text-center",
      children: [
        e && /* @__PURE__ */ B("div", { className: "tw-flex tw-flex-col tw-items-center tw-gap-1", children: [
          /* @__PURE__ */ p("div", { className: "tw-flex", children: /* @__PURE__ */ p("span", { className: "tw-text-xs tw-font-semibold tw-text-foreground", children: e }) }),
          /* @__PURE__ */ p("span", { className: "tw-text-xs tw-text-foreground", children: "CATEGORY" })
        ] }),
        /* @__PURE__ */ B("div", { className: "tw-flex tw-flex-col tw-items-center tw-gap-1 tw-ps-4", children: [
          /* @__PURE__ */ B("div", { className: "tw-flex tw-gap-1", children: [
            /* @__PURE__ */ p(Z2, { className: "tw-h-4 tw-w-4" }),
            /* @__PURE__ */ p("span", { className: "tw-text-xs tw-font-semibold tw-text-foreground", children: l })
          ] }),
          /* @__PURE__ */ p("span", { className: "tw-text-xs tw-text-foreground", children: "USERS" })
        ] }),
        /* @__PURE__ */ B("div", { className: "tw-flex tw-flex-col tw-items-center tw-gap-1 tw-ps-4", children: [
          /* @__PURE__ */ p("div", { className: "tw-flex tw-gap-2", children: r.slice(0, 3).map((u) => /* @__PURE__ */ p("span", { className: "tw-text-xs tw-font-semibold tw-text-foreground", children: u.toUpperCase() }, u)) }),
          r.length > 3 && /* @__PURE__ */ B(
            "button",
            {
              type: "button",
              onClick: () => c(),
              className: "tw-text-xs tw-text-foreground tw-underline",
              children: [
                "+",
                r.length - 3,
                " more languages"
              ]
            }
          )
        ] }),
        (i || s) && /* @__PURE__ */ B("div", { className: "tw-flex tw-flex-col tw-gap-1 tw-ps-4", children: [
          i && /* @__PURE__ */ p("div", { className: "tw-flex tw-gap-1", children: /* @__PURE__ */ B(
            Me,
            {
              onClick: () => o(),
              variant: "link",
              className: "tw-flex tw-h-auto tw-gap-1 tw-py-0 tw-text-xs tw-font-semibold tw-text-foreground",
              children: [
                "Website",
                /* @__PURE__ */ p(e1, { className: "tw-h-4 tw-w-4" })
              ]
            }
          ) }),
          s && /* @__PURE__ */ p("div", { className: "tw-flex tw-gap-1", children: /* @__PURE__ */ B(
            Me,
            {
              onClick: () => a(),
              variant: "link",
              className: "tw-flex tw-h-auto tw-gap-1 tw-py-0 tw-text-xs tw-font-semibold tw-text-foreground",
              children: [
                "Support",
                /* @__PURE__ */ p(t1, { className: "tw-h-4 tw-w-4" })
              ]
            }
          ) })
        ] })
      ]
    }
  );
}
function OC({ id: t, versionHistory: e }) {
  const [n, r] = ue(!1), i = /* @__PURE__ */ new Date();
  function o(a) {
    const l = new Date(a), c = new Date(i.getTime() - l.getTime()), u = c.getUTCFullYear() - 1970, f = c.getUTCMonth(), d = c.getUTCDate() - 1;
    let h = "";
    return u > 0 ? h = `${u.toString()} year${u === 1 ? "" : "s"} ago` : f > 0 ? h = `${f.toString()} month${f === 1 ? "" : "s"} ago` : d === 0 ? h = "today" : h = `${d.toString()} day${d === 1 ? "" : "s"} ago`, h;
  }
  const s = Object.entries(e).sort((a, l) => l[0].localeCompare(a[0]));
  return /* @__PURE__ */ B("div", { className: "pr-twp", id: t, children: [
    /* @__PURE__ */ p("h3", { className: "tw-text-md tw-font-semibold", children: "What`s New" }),
    /* @__PURE__ */ p("ul", { className: "tw-list-disc tw-pl-5 tw-pr-4 tw-text-xs tw-text-foreground", children: (n ? s : s.slice(0, 5)).map((a) => /* @__PURE__ */ B("div", { className: "tw-mt-3 tw-flex tw-justify-between", children: [
      /* @__PURE__ */ p("div", { className: "tw-text-foreground", children: /* @__PURE__ */ p("li", { className: "tw-prose tw-text-xs", children: /* @__PURE__ */ p("span", { children: a[1].description }) }) }),
      /* @__PURE__ */ B("div", { className: "tw-justify-end tw-text-right", children: [
        /* @__PURE__ */ B("div", { children: [
          "Version ",
          a[0]
        ] }),
        /* @__PURE__ */ p("div", { children: o(a[1].date) })
      ] })
    ] }, a[0])) }),
    s.length > 5 && /* @__PURE__ */ p(
      "button",
      {
        type: "button",
        onClick: () => r(!n),
        className: "tw-text-xs tw-text-foreground tw-underline",
        children: n ? "Show Less Version History" : "Show All Version History"
      }
    )
  ] });
}
function BL({
  id: t,
  publisherDisplayName: e,
  fileSize: n,
  locales: r,
  versionHistory: i,
  currentVersion: o
}) {
  const s = Ne(() => N1(n), [n]), l = ((c) => {
    const u = new Intl.DisplayNames(S1(), { type: "language" });
    return c.map((f) => u.of(f));
  })(r);
  return /* @__PURE__ */ p("div", { id: t, className: "pr-twp tw-border-t tw-py-2", children: /* @__PURE__ */ B("div", { className: "tw-flex tw-flex-col tw-gap-2 tw-divide-y", children: [
    Object.entries(i).length > 0 && /* @__PURE__ */ p(OC, { versionHistory: i }),
    /* @__PURE__ */ B("div", { className: "tw-flex tw-flex-col tw-gap-2 tw-py-2", children: [
      /* @__PURE__ */ p("h2", { className: "tw-text-md tw-font-semibold", children: "Information" }),
      /* @__PURE__ */ B("div", { className: "tw-flex tw-items-start tw-justify-between tw-text-xs tw-text-foreground", children: [
        /* @__PURE__ */ B("p", { className: "tw-flex tw-flex-col tw-justify-start tw-gap-1", children: [
          /* @__PURE__ */ p("span", { children: "Publisher" }),
          /* @__PURE__ */ p("span", { className: "tw-font-semibold", children: e }),
          /* @__PURE__ */ p("span", { children: "Size" }),
          /* @__PURE__ */ p("span", { className: "tw-font-semibold", children: s })
        ] }),
        /* @__PURE__ */ p("div", { className: "tw-flex tw-w-3/4 tw-items-center tw-justify-between tw-text-xs tw-text-foreground", children: /* @__PURE__ */ B("p", { className: "tw-flex tw-flex-col tw-justify-start tw-gap-1", children: [
          /* @__PURE__ */ p("span", { children: "Version" }),
          /* @__PURE__ */ p("span", { className: "tw-font-semibold", children: o }),
          /* @__PURE__ */ p("span", { children: "Languages" }),
          /* @__PURE__ */ p("span", { className: "tw-font-semibold", children: l.join(", ") })
        ] }) })
      ] })
    ] })
  ] }) });
}
const IC = Xi(
  "pr-twp tw-inline-flex tw-items-center tw-rounded-full tw-px-2.5 tw-py-0.5 tw-text-xs tw-font-semibold tw-transition-colors focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-ring focus:tw-ring-offset-2",
  {
    variants: {
      variant: {
        default: "tw-border tw-border-transparent tw-bg-primary tw-text-primary-foreground hover:tw-bg-primary/80",
        secondary: "tw-border tw-border-transparent tw-bg-secondary tw-text-secondary-foreground hover:tw-bg-secondary/80",
        muted: "tw-border tw-border-transparent tw-bg-muted tw-text-muted-foreground hover:tw-bg-muted/80",
        destructive: "tw-border tw-border-transparent tw-bg-destructive tw-text-destructive-foreground hover:tw-bg-destructive/80",
        outline: "tw-border tw-text-foreground",
        blueIndicator: "tw-w-[5px] tw-h-[5px] tw-bg-blue-400 tw-px-0",
        mutedIndicator: "tw-w-[5px] tw-h-[5px] tw-bg-zinc-400 tw-px-0",
        ghost: "hover:tw-bg-accent hover:tw-text-accent-foreground tw-text-mu"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), Vc = Y.forwardRef(
  ({ className: t, variant: e, ...n }, r) => /* @__PURE__ */ p("div", { ref: r, className: G("pr-twp", IC({ variant: e }), t), ...n })
);
Vc.displayName = "Badge";
function RC({
  entries: t,
  selected: e,
  onChange: n,
  placeholder: r,
  hasToggleAllFeature: i = !1,
  selectAllText: o = "Select All",
  clearAllText: s = "Clear All",
  commandEmptyMessage: a = "No entries found",
  customSelectedText: l,
  isOpen: c = void 0,
  onOpenChange: u = void 0,
  isDisabled: f = !1,
  sortSelected: d = !1,
  icon: h = void 0,
  className: g = void 0,
  variant: w = "ghost",
  id: b
}) {
  const [_, y] = ue(!1), C = be(
    (F) => {
      var I;
      const k = (I = t.find((N) => N.label === F)) == null ? void 0 : I.value;
      k && n(
        e.includes(k) ? e.filter((N) => N !== k) : [...e, k]
      );
    },
    [t, e, n]
  ), D = () => l || r, P = Ne(() => {
    if (!d) return t;
    const F = t.filter((I) => I.starred).sort((I, N) => I.label.localeCompare(N.label)), k = t.filter((I) => !I.starred).sort((I, N) => {
      const R = e.includes(I.value), T = e.includes(N.value);
      return R && !T ? -1 : !R && T ? 1 : I.label.localeCompare(N.label);
    });
    return [...F, ...k];
  }, [t, e, d]), S = () => {
    n(t.map((F) => F.value));
  }, L = () => {
    n([]);
  }, O = c ?? _;
  return /* @__PURE__ */ p("div", { id: b, className: g, children: /* @__PURE__ */ B(aa, { open: O, onOpenChange: u ?? y, children: [
    /* @__PURE__ */ p(la, { asChild: !0, children: /* @__PURE__ */ B(
      Me,
      {
        variant: w,
        role: "combobox",
        "aria-expanded": O,
        className: "tw-group tw-w-full tw-justify-between",
        disabled: f,
        children: [
          /* @__PURE__ */ B("div", { className: "tw-flex tw-items-center tw-gap-2", children: [
            h && /* @__PURE__ */ p("div", { className: "tw-ml-2 tw-h-4 tw-w-4 tw-shrink-0 tw-opacity-50", children: /* @__PURE__ */ p("span", { className: "tw-flex tw-h-full tw-w-full tw-items-center tw-justify-center", children: h }) }),
            /* @__PURE__ */ p("div", { className: "tw-font-normal", children: D() })
          ] }),
          /* @__PURE__ */ p(Wh, { className: "tw-ml-2 tw-h-4 tw-w-4 tw-shrink-0 tw-opacity-50" })
        ]
      }
    ) }),
    /* @__PURE__ */ p(Zo, { align: "start", className: "tw-w-full tw-p-0", children: /* @__PURE__ */ B(ia, { children: [
      /* @__PURE__ */ p(Dl, { placeholder: `Search ${r.toLowerCase()}...` }),
      i && /* @__PURE__ */ B("div", { className: "tw-flex tw-justify-between tw-border-b tw-p-2", children: [
        /* @__PURE__ */ p(Me, { variant: "ghost", size: "sm", onClick: S, children: o }),
        /* @__PURE__ */ p(Me, { variant: "ghost", size: "sm", onClick: L, children: s })
      ] }),
      /* @__PURE__ */ B(oa, { children: [
        /* @__PURE__ */ p(Lu, { children: a }),
        /* @__PURE__ */ p(Mo, { children: P.map((F) => /* @__PURE__ */ B(
          Qo,
          {
            value: F.label,
            onSelect: C,
            className: "tw-flex tw-items-center tw-gap-2",
            children: [
              /* @__PURE__ */ p("div", { className: "w-4", children: /* @__PURE__ */ p(
                xi,
                {
                  className: G(
                    "tw-h-4 tw-w-4",
                    e.includes(F.value) ? "tw-opacity-100" : "tw-opacity-0"
                  )
                }
              ) }),
              F.starred && /* @__PURE__ */ p(n1, { className: "tw-h-4 tw-w-4" }),
              /* @__PURE__ */ p("div", { className: "tw-flex-grow", children: F.label }),
              F.secondaryLabel && /* @__PURE__ */ p("div", { className: "tw-text-end tw-text-muted-foreground", children: F.secondaryLabel })
            ]
          },
          F.label
        )) })
      ] })
    ] }) })
  ] }) });
}
function qL({
  entries: t,
  selected: e,
  onChange: n,
  placeholder: r,
  commandEmptyMessage: i,
  customSelectedText: o,
  isDisabled: s,
  sortSelected: a,
  icon: l,
  className: c,
  badgesPlaceholder: u,
  id: f
}) {
  return /* @__PURE__ */ B("div", { id: f, className: "tw-flex tw-items-center tw-gap-2", children: [
    /* @__PURE__ */ p(
      RC,
      {
        entries: t,
        selected: e,
        onChange: n,
        placeholder: r,
        commandEmptyMessage: i,
        customSelectedText: o,
        isDisabled: s,
        sortSelected: a,
        icon: l,
        className: c
      }
    ),
    e.length > 0 ? /* @__PURE__ */ p("div", { className: "tw-flex tw-flex-wrap tw-items-center tw-gap-2", children: e.map((d) => {
      var h;
      return /* @__PURE__ */ B(Vc, { variant: "muted", className: "tw-flex tw-items-center tw-gap-1", children: [
        /* @__PURE__ */ p(
          Me,
          {
            variant: "ghost",
            size: "icon",
            className: "tw-h-4 tw-w-4 tw-p-0 hover:tw-bg-transparent",
            onClick: () => n(e.filter((g) => g !== d)),
            children: /* @__PURE__ */ p(Ou, { className: "tw-h-3 tw-w-3" })
          }
        ),
        (h = t.find((g) => g.value === d)) == null ? void 0 : h.label
      ] }, d);
    }) }) : /* @__PURE__ */ p(Vt, { children: u })
  ] });
}
var Ii = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function PC(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Ue = {}, qt = {}, Qg;
function ca() {
  if (Qg) return qt;
  Qg = 1;
  function t(_, y, C) {
    if (C === void 0 && (C = Array.prototype), _ && typeof C.find == "function")
      return C.find.call(_, y);
    for (var D = 0; D < _.length; D++)
      if (n(_, D)) {
        var P = _[D];
        if (y.call(void 0, P, D, _))
          return P;
      }
  }
  function e(_, y) {
    return y === void 0 && (y = Object), y && typeof y.getOwnPropertyDescriptors == "function" && (_ = y.create(null, y.getOwnPropertyDescriptors(_))), y && typeof y.freeze == "function" ? y.freeze(_) : _;
  }
  function n(_, y) {
    return Object.prototype.hasOwnProperty.call(_, y);
  }
  function r(_, y) {
    if (_ === null || typeof _ != "object")
      throw new TypeError("target is not an object");
    for (var C in y)
      n(y, C) && (_[C] = y[C]);
    return _;
  }
  var i = e({
    allowfullscreen: !0,
    async: !0,
    autofocus: !0,
    autoplay: !0,
    checked: !0,
    controls: !0,
    default: !0,
    defer: !0,
    disabled: !0,
    formnovalidate: !0,
    hidden: !0,
    ismap: !0,
    itemscope: !0,
    loop: !0,
    multiple: !0,
    muted: !0,
    nomodule: !0,
    novalidate: !0,
    open: !0,
    playsinline: !0,
    readonly: !0,
    required: !0,
    reversed: !0,
    selected: !0
  });
  function o(_) {
    return n(i, _.toLowerCase());
  }
  var s = e({
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
  });
  function a(_) {
    return n(s, _.toLowerCase());
  }
  var l = e({
    script: !1,
    style: !1,
    textarea: !0,
    title: !0
  });
  function c(_) {
    var y = _.toLowerCase();
    return n(l, y) && !l[y];
  }
  function u(_) {
    var y = _.toLowerCase();
    return n(l, y) && l[y];
  }
  function f(_) {
    return _ === h.HTML;
  }
  function d(_) {
    return f(_) || _ === h.XML_XHTML_APPLICATION;
  }
  var h = e({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring
     *      WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType
     *      registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/xml`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType
     *      registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  }), g = Object.keys(h).map(function(_) {
    return h[_];
  });
  function w(_) {
    return g.indexOf(_) > -1;
  }
  var b = e({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace.
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });
  return qt.assign = r, qt.find = t, qt.freeze = e, qt.HTML_BOOLEAN_ATTRIBUTES = i, qt.HTML_RAW_TEXT_ELEMENTS = l, qt.HTML_VOID_ELEMENTS = s, qt.hasDefaultHTMLNamespace = d, qt.hasOwn = n, qt.isHTMLBooleanAttribute = o, qt.isHTMLRawTextElement = c, qt.isHTMLEscapableRawTextElement = u, qt.isHTMLMimeType = f, qt.isHTMLVoidElement = a, qt.isValidMimeType = w, qt.MIME_TYPE = h, qt.NAMESPACE = b, qt;
}
var ps = {}, Zg;
function ju() {
  if (Zg) return ps;
  Zg = 1;
  var t = ca();
  function e(d, h) {
    d.prototype = Object.create(Error.prototype, {
      constructor: { value: d },
      name: { value: d.name, enumerable: !0, writable: h }
    });
  }
  var n = t.freeze({
    /**
     * the default value as defined by the spec
     */
    Error: "Error",
    /**
     * @deprecated
     * Use RangeError instead.
     */
    IndexSizeError: "IndexSizeError",
    /**
     * @deprecated
     * Just to match the related static code, not part of the spec.
     */
    DomstringSizeError: "DomstringSizeError",
    HierarchyRequestError: "HierarchyRequestError",
    WrongDocumentError: "WrongDocumentError",
    InvalidCharacterError: "InvalidCharacterError",
    /**
     * @deprecated
     * Just to match the related static code, not part of the spec.
     */
    NoDataAllowedError: "NoDataAllowedError",
    NoModificationAllowedError: "NoModificationAllowedError",
    NotFoundError: "NotFoundError",
    NotSupportedError: "NotSupportedError",
    InUseAttributeError: "InUseAttributeError",
    InvalidStateError: "InvalidStateError",
    SyntaxError: "SyntaxError",
    InvalidModificationError: "InvalidModificationError",
    NamespaceError: "NamespaceError",
    /**
     * @deprecated
     * Use TypeError for invalid arguments,
     * "NotSupportedError" DOMException for unsupported operations,
     * and "NotAllowedError" DOMException for denied requests instead.
     */
    InvalidAccessError: "InvalidAccessError",
    /**
     * @deprecated
     * Just to match the related static code, not part of the spec.
     */
    ValidationError: "ValidationError",
    /**
     * @deprecated
     * Use TypeError instead.
     */
    TypeMismatchError: "TypeMismatchError",
    SecurityError: "SecurityError",
    NetworkError: "NetworkError",
    AbortError: "AbortError",
    /**
     * @deprecated
     * Just to match the related static code, not part of the spec.
     */
    URLMismatchError: "URLMismatchError",
    QuotaExceededError: "QuotaExceededError",
    TimeoutError: "TimeoutError",
    InvalidNodeTypeError: "InvalidNodeTypeError",
    DataCloneError: "DataCloneError",
    EncodingError: "EncodingError",
    NotReadableError: "NotReadableError",
    UnknownError: "UnknownError",
    ConstraintError: "ConstraintError",
    DataError: "DataError",
    TransactionInactiveError: "TransactionInactiveError",
    ReadOnlyError: "ReadOnlyError",
    VersionError: "VersionError",
    OperationError: "OperationError",
    NotAllowedError: "NotAllowedError",
    OptOutError: "OptOutError"
  }), r = Object.keys(n);
  function i(d) {
    return typeof d == "number" && d >= 1 && d <= 25;
  }
  function o(d) {
    return typeof d == "string" && d.substring(d.length - n.Error.length) === n.Error;
  }
  function s(d, h) {
    i(d) ? (this.name = r[d], this.message = h || "") : (this.message = d, this.name = o(h) ? h : n.Error), Error.captureStackTrace && Error.captureStackTrace(this, s);
  }
  e(s, !0), Object.defineProperties(s.prototype, {
    code: {
      enumerable: !0,
      get: function() {
        var d = r.indexOf(this.name);
        return i(d) ? d : 0;
      }
    }
  });
  for (var a = {
    INDEX_SIZE_ERR: 1,
    DOMSTRING_SIZE_ERR: 2,
    HIERARCHY_REQUEST_ERR: 3,
    WRONG_DOCUMENT_ERR: 4,
    INVALID_CHARACTER_ERR: 5,
    NO_DATA_ALLOWED_ERR: 6,
    NO_MODIFICATION_ALLOWED_ERR: 7,
    NOT_FOUND_ERR: 8,
    NOT_SUPPORTED_ERR: 9,
    INUSE_ATTRIBUTE_ERR: 10,
    INVALID_STATE_ERR: 11,
    SYNTAX_ERR: 12,
    INVALID_MODIFICATION_ERR: 13,
    NAMESPACE_ERR: 14,
    INVALID_ACCESS_ERR: 15,
    VALIDATION_ERR: 16,
    TYPE_MISMATCH_ERR: 17,
    SECURITY_ERR: 18,
    NETWORK_ERR: 19,
    ABORT_ERR: 20,
    URL_MISMATCH_ERR: 21,
    QUOTA_EXCEEDED_ERR: 22,
    TIMEOUT_ERR: 23,
    INVALID_NODE_TYPE_ERR: 24,
    DATA_CLONE_ERR: 25
  }, l = Object.entries(a), c = 0; c < l.length; c++) {
    var u = l[c][0];
    s[u] = l[c][1];
  }
  function f(d, h) {
    this.message = d, this.locator = h, Error.captureStackTrace && Error.captureStackTrace(this, f);
  }
  return e(f), ps.DOMException = s, ps.DOMExceptionName = n, ps.ExceptionCode = a, ps.ParseError = f, ps;
}
var xt = {}, Ie = {}, ew;
function Vy() {
  if (ew) return Ie;
  ew = 1;
  function t(Ze) {
    try {
      typeof Ze != "function" && (Ze = RegExp);
      var bt = new Ze("ðŒ†", "u").exec("ðŒ†");
      return !!bt && bt[0].length === 2;
    } catch {
    }
    return !1;
  }
  var e = t();
  function n(Ze) {
    if (Ze.source[0] !== "[")
      throw new Error(Ze + " can not be used with chars");
    return Ze.source.slice(1, Ze.source.lastIndexOf("]"));
  }
  function r(Ze, bt) {
    if (Ze.source[0] !== "[")
      throw new Error("/" + Ze.source + "/ can not be used with chars_without");
    if (!bt || typeof bt != "string")
      throw new Error(JSON.stringify(bt) + " is not a valid search");
    if (Ze.source.indexOf(bt) === -1)
      throw new Error('"' + bt + '" is not is /' + Ze.source + "/");
    if (bt === "-" && Ze.source.indexOf(bt) !== 1)
      throw new Error('"' + bt + '" is not at the first postion of /' + Ze.source + "/");
    return new RegExp(Ze.source.replace(bt, ""), e ? "u" : "");
  }
  function i(Ze) {
    var bt = this;
    return new RegExp(
      Array.prototype.slice.call(arguments).map(function(gn) {
        var wn = typeof gn == "string";
        if (wn && bt === void 0 && gn === "|")
          throw new Error("use regg instead of reg to wrap expressions with `|`!");
        return wn ? gn : gn.source;
      }).join(""),
      e ? "mu" : "m"
    );
  }
  function o(Ze) {
    if (arguments.length === 0)
      throw new Error("no parameters provided");
    return i.apply(o, ["(?:"].concat(Array.prototype.slice.call(arguments), [")"]));
  }
  var s = "ï¿½", a = /[-\x09\x0A\x0D\x20-\x2C\x2E-\uD7FF\uE000-\uFFFD]/;
  e && (a = i("[", n(a), "\\u{10000}-\\u{10FFFF}", "]"));
  var l = /[\x20\x09\x0D\x0A]/, c = n(l), u = i(l, "+"), f = i(l, "*"), d = /[:_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  e && (d = i("[", n(d), "\\u{10000}-\\u{10FFFF}", "]"));
  var h = n(d), g = i("[", h, n(/[-.0-9\xB7]/), n(/[\u0300-\u036F\u203F-\u2040]/), "]"), w = i(d, g, "*"), b = i(g, "+"), _ = i("&", w, ";"), y = o(/&#[0-9]+;|&#x[0-9a-fA-F]+;/), C = o(_, "|", y), D = i("%", w, ";"), P = o(
    i('"', o(/[^%&"]/, "|", D, "|", C), "*", '"'),
    "|",
    i("'", o(/[^%&']/, "|", D, "|", C), "*", "'")
  ), S = o('"', o(/[^<&"]/, "|", C), "*", '"', "|", "'", o(/[^<&']/, "|", C), "*", "'"), L = r(d, ":"), O = r(g, ":"), M = i(L, O, "*"), F = i(M, o(":", M), "?"), k = i("^", F, "$"), I = i("(", F, ")"), N = o(/"[^"]*"|'[^']*'/), R = i(/^<\?/, "(", w, ")", o(u, "(", a, "*?)"), "?", /\?>/), T = /[\x20\x0D\x0Aa-zA-Z0-9-'()+,./:=?;!*#@$_%]/, A = o('"', T, '*"', "|", "'", r(T, "'"), "*'"), q = "<!--", V = "-->", J = i(q, o(r(a, "-"), "|", i("-", r(a, "-"))), "*", V), H = "#PCDATA", W = o(
    i(/\(/, f, H, o(f, /\|/, f, F), "*", f, /\)\*/),
    "|",
    i(/\(/, f, H, f, /\)/)
  ), ne = /[?*+]?/, re = i(
    /\([^>]+\)/,
    ne
    /*regg(choice, '|', seq), _children_quantity*/
  ), te = o("EMPTY", "|", "ANY", "|", W, "|", re), Q = "<!ELEMENT", ce = i(Q, u, o(F, "|", D), u, o(te, "|", D), f, ">"), pe = i("NOTATION", u, /\(/, f, w, o(f, /\|/, f, w), "*", f, /\)/), we = i(/\(/, f, b, o(f, /\|/, f, b), "*", f, /\)/), ve = o(pe, "|", we), _e = o(/CDATA|ID|IDREF|IDREFS|ENTITY|ENTITIES|NMTOKEN|NMTOKENS/, "|", ve), Ee = o(/#REQUIRED|#IMPLIED/, "|", o(o("#FIXED", u), "?", S)), fe = o(u, w, u, _e, u, Ee), Pe = "<!ATTLIST", He = i(Pe, u, w, fe, "*", f, ">"), ae = "about:legacy-compat", Te = o('"' + ae + '"', "|", "'" + ae + "'"), Be = "SYSTEM", Ge = "PUBLIC", rt = o(o(Be, u, N), "|", o(Ge, u, A, u, N)), vt = i(
    "^",
    o(
      o(Be, u, "(?<SystemLiteralOnly>", N, ")"),
      "|",
      o(Ge, u, "(?<PubidLiteral>", A, ")", u, "(?<SystemLiteral>", N, ")")
    )
  ), mt = o(u, "NDATA", u, w), Et = o(P, "|", o(rt, mt, "?")), $e = "<!ENTITY", Dt = i($e, u, w, u, Et, f, ">"), ct = o(P, "|", rt), lr = i($e, u, "%", u, w, u, ct, f, ">"), Ln = o(Dt, "|", lr), En = i(Ge, u, A), $n = i("<!NOTATION", u, w, u, o(rt, "|", En), f, ">"), Ce = i(f, "=", f), Qe = /1[.]\d+/, Mt = i(u, "version", Ce, o("'", Qe, "'", "|", '"', Qe, '"')), Bt = /[A-Za-z][-A-Za-z0-9._]*/, Fn = o(u, "encoding", Ce, o('"', Bt, '"', "|", "'", Bt, "'")), Bn = o(u, "standalone", Ce, o("'", o("yes", "|", "no"), "'", "|", '"', o("yes", "|", "no"), '"')), cr = i(/^<\?xml/, Mt, Fn, "?", Bn, "?", f, /\?>/), qn = "<!DOCTYPE", jn = "<![CDATA[", Xt = "]]>", Un = /<!\[CDATA\[/, zn = /\]\]>/, Nn = i(a, "*?", zn), Dr = i(Un, Nn);
  return Ie.chars = n, Ie.chars_without = r, Ie.detectUnicodeSupport = t, Ie.reg = i, Ie.regg = o, Ie.ABOUT_LEGACY_COMPAT = ae, Ie.ABOUT_LEGACY_COMPAT_SystemLiteral = Te, Ie.AttlistDecl = He, Ie.CDATA_START = jn, Ie.CDATA_END = Xt, Ie.CDSect = Dr, Ie.Char = a, Ie.Comment = J, Ie.COMMENT_START = q, Ie.COMMENT_END = V, Ie.DOCTYPE_DECL_START = qn, Ie.elementdecl = ce, Ie.EntityDecl = Ln, Ie.EntityValue = P, Ie.ExternalID = rt, Ie.ExternalID_match = vt, Ie.Name = w, Ie.NotationDecl = $n, Ie.Reference = C, Ie.PEReference = D, Ie.PI = R, Ie.PUBLIC = Ge, Ie.PubidLiteral = A, Ie.QName = F, Ie.QName_exact = k, Ie.QName_group = I, Ie.S = u, Ie.SChar_s = c, Ie.S_OPT = f, Ie.SYSTEM = Be, Ie.SystemLiteral = N, Ie.UNICODE_REPLACEMENT_CHARACTER = s, Ie.UNICODE_SUPPORT = e, Ie.XMLDecl = cr, Ie;
}
var tw;
function Hy() {
  if (tw) return xt;
  tw = 1;
  var t = ca(), e = t.find, n = t.hasDefaultHTMLNamespace, r = t.hasOwn, i = t.isHTMLMimeType, o = t.isHTMLRawTextElement, s = t.isHTMLVoidElement, a = t.MIME_TYPE, l = t.NAMESPACE, c = Symbol(), u = ju(), f = u.DOMException, d = u.DOMExceptionName, h = Vy();
  function g(v) {
    if (v !== c)
      throw new TypeError("Illegal constructor");
  }
  function w(v) {
    return v !== "";
  }
  function b(v) {
    return v ? v.split(/[\t\n\f\r ]+/).filter(w) : [];
  }
  function _(v, x) {
    return r(v, x) || (v[x] = !0), v;
  }
  function y(v) {
    if (!v) return [];
    var x = b(v);
    return Object.keys(x.reduce(_, {}));
  }
  function C(v) {
    return function(x) {
      return v && v.indexOf(x) !== -1;
    };
  }
  function D(v) {
    if (!h.QName_exact.test(v))
      throw new f(f.INVALID_CHARACTER_ERR, 'invalid character in qualified name "' + v + '"');
  }
  function P(v, x) {
    D(x), v = v || null;
    var $ = null, K = x;
    if (x.indexOf(":") >= 0) {
      var se = x.split(":");
      $ = se[0], K = se[1];
    }
    if ($ !== null && v === null)
      throw new f(f.NAMESPACE_ERR, "prefix is non-null and namespace is null");
    if ($ === "xml" && v !== t.NAMESPACE.XML)
      throw new f(f.NAMESPACE_ERR, 'prefix is "xml" and namespace is not the XML namespace');
    if (($ === "xmlns" || x === "xmlns") && v !== t.NAMESPACE.XMLNS)
      throw new f(
        f.NAMESPACE_ERR,
        'either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace'
      );
    if (v === t.NAMESPACE.XMLNS && $ !== "xmlns" && x !== "xmlns")
      throw new f(
        f.NAMESPACE_ERR,
        'namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns"'
      );
    return [v, $, K];
  }
  function S(v, x) {
    for (var $ in v)
      r(v, $) && (x[$] = v[$]);
  }
  function L(v, x) {
    var $ = v.prototype;
    if (!($ instanceof x)) {
      let K = function() {
      };
      K.prototype = x.prototype, K = new K(), S($, K), v.prototype = $ = K;
    }
    $.constructor != v && (typeof v != "function" && console.error("unknown Class:" + v), $.constructor = v);
  }
  var O = {}, M = O.ELEMENT_NODE = 1, F = O.ATTRIBUTE_NODE = 2, k = O.TEXT_NODE = 3, I = O.CDATA_SECTION_NODE = 4, N = O.ENTITY_REFERENCE_NODE = 5, R = O.ENTITY_NODE = 6, T = O.PROCESSING_INSTRUCTION_NODE = 7, A = O.COMMENT_NODE = 8, q = O.DOCUMENT_NODE = 9, V = O.DOCUMENT_TYPE_NODE = 10, J = O.DOCUMENT_FRAGMENT_NODE = 11, H = O.NOTATION_NODE = 12, W = t.freeze({
    DOCUMENT_POSITION_DISCONNECTED: 1,
    DOCUMENT_POSITION_PRECEDING: 2,
    DOCUMENT_POSITION_FOLLOWING: 4,
    DOCUMENT_POSITION_CONTAINS: 8,
    DOCUMENT_POSITION_CONTAINED_BY: 16,
    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32
  });
  function ne(v, x) {
    if (x.length < v.length) return ne(x, v);
    var $ = null;
    for (var K in v) {
      if (v[K] !== x[K]) return $;
      $ = v[K];
    }
    return $;
  }
  function re(v) {
    return v.guid || (v.guid = Math.random()), v.guid;
  }
  function te() {
  }
  te.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1
     * inclusive.
     *
     * @type {number}
     */
    length: 0,
    /**
     * Returns the item at `index`. If index is greater than or equal to the number of nodes in
     * the list, this returns null.
     *
     * @param index
     * Unsigned long Index into the collection.
     * @returns {Node | null}
     * The node at position `index` in the NodeList,
     * or null if that is not a valid index.
     */
    item: function(v) {
      return v >= 0 && v < this.length ? this[v] : null;
    },
    /**
     * Returns a string representation of the NodeList.
     *
     * @param {unknown} nodeFilter
     * __A filter function? Not implemented according to the spec?__.
     * @returns {string}
     * A string representation of the NodeList.
     */
    toString: function(v) {
      for (var x = [], $ = 0; $ < this.length; $++)
        wn(this[$], x, v);
      return x.join("");
    },
    /**
     * Filters the NodeList based on a predicate.
     *
     * @param {function(Node): boolean} predicate
     * - A predicate function to filter the NodeList.
     * @returns {Node[]}
     * An array of nodes that satisfy the predicate.
     * @private
     */
    filter: function(v) {
      return Array.prototype.filter.call(this, v);
    },
    /**
     * Returns the first index at which a given node can be found in the NodeList, or -1 if it is
     * not present.
     *
     * @param {Node} item
     * - The Node item to locate in the NodeList.
     * @returns {number}
     * The first index of the node in the NodeList; -1 if not found.
     * @private
     */
    indexOf: function(v) {
      return Array.prototype.indexOf.call(this, v);
    }
  }, te.prototype[Symbol.iterator] = function() {
    var v = this, x = 0;
    return {
      next: function() {
        return x < v.length ? {
          value: v[x++],
          done: !1
        } : {
          done: !0
        };
      },
      return: function() {
        return {
          done: !0
        };
      }
    };
  };
  function Q(v, x) {
    this._node = v, this._refresh = x, ce(this);
  }
  function ce(v) {
    var x = v._node._inc || v._node.ownerDocument._inc;
    if (v._inc !== x) {
      var $ = v._refresh(v._node);
      if (Qn(v, "length", $.length), !v.$$length || $.length < v.$$length)
        for (var K = $.length; K in v; K++)
          r(v, K) && delete v[K];
      S($, v), v._inc = x;
    }
  }
  Q.prototype.item = function(v) {
    return ce(this), this[v] || null;
  }, L(Q, te);
  function pe() {
  }
  function we(v, x) {
    for (var $ = 0; $ < v.length; ) {
      if (v[$] === x)
        return $;
      $++;
    }
  }
  function ve(v, x, $, K) {
    if (K ? x[we(x, K)] = $ : (x[x.length] = $, x.length++), v) {
      $.ownerElement = v;
      var se = v.ownerDocument;
      se && (K && Be(se, v, K), Te(se, v, $));
    }
  }
  function _e(v, x, $) {
    var K = we(x, $);
    if (K >= 0) {
      for (var se = x.length - 1; K <= se; )
        x[K] = x[++K];
      if (x.length = se, v) {
        var he = v.ownerDocument;
        he && Be(he, v, $), $.ownerElement = null;
      }
    }
  }
  pe.prototype = {
    length: 0,
    item: te.prototype.item,
    /**
     * Get an attribute by name. Note: Name is in lower case in case of HTML namespace and
     * document.
     *
     * @param {string} localName
     * The local name of the attribute.
     * @returns {Attr | null}
     * The attribute with the given local name, or null if no such attribute exists.
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name
     */
    getNamedItem: function(v) {
      this._ownerElement && this._ownerElement._isInHTMLDocumentAndNamespace() && (v = v.toLowerCase());
      for (var x = 0; x < this.length; ) {
        var $ = this[x];
        if ($.nodeName === v)
          return $;
        x++;
      }
      return null;
    },
    /**
     * Set an attribute.
     *
     * @param {Attr} attr
     * The attribute to set.
     * @returns {Attr | null}
     * The old attribute with the same local name and namespace URI as the new one, or null if no
     * such attribute exists.
     * @throws {DOMException}
     * With code:
     * - {@link INUSE_ATTRIBUTE_ERR} - If the attribute is already an attribute of another
     * element.
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
     */
    setNamedItem: function(v) {
      var x = v.ownerElement;
      if (x && x !== this._ownerElement)
        throw new f(f.INUSE_ATTRIBUTE_ERR);
      var $ = this.getNamedItemNS(v.namespaceURI, v.localName);
      return $ === v ? v : (ve(this._ownerElement, this, v, $), $);
    },
    /**
     * Set an attribute, replacing an existing attribute with the same local name and namespace
     * URI if one exists.
     *
     * @param {Attr} attr
     * The attribute to set.
     * @returns {Attr | null}
     * The old attribute with the same local name and namespace URI as the new one, or null if no
     * such attribute exists.
     * @throws {DOMException}
     * Throws a DOMException with the name "InUseAttributeError" if the attribute is already an
     * attribute of another element.
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
     */
    setNamedItemNS: function(v) {
      return this.setNamedItem(v);
    },
    /**
     * Removes an attribute specified by the local name.
     *
     * @param {string} localName
     * The local name of the attribute to be removed.
     * @returns {Attr}
     * The attribute node that was removed.
     * @throws {DOMException}
     * With code:
     * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given name is found.
     * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditem
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name
     */
    removeNamedItem: function(v) {
      var x = this.getNamedItem(v);
      if (!x)
        throw new f(f.NOT_FOUND_ERR, v);
      return _e(this._ownerElement, this, x), x;
    },
    /**
     * Removes an attribute specified by the namespace and local name.
     *
     * @param {string | null} namespaceURI
     * The namespace URI of the attribute to be removed.
     * @param {string} localName
     * The local name of the attribute to be removed.
     * @returns {Attr}
     * The attribute node that was removed.
     * @throws {DOMException}
     * With code:
     * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given namespace URI and local
     * name is found.
     * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditemns
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace
     */
    removeNamedItemNS: function(v, x) {
      var $ = this.getNamedItemNS(v, x);
      if (!$)
        throw new f(f.NOT_FOUND_ERR, v ? v + " : " + x : x);
      return _e(this._ownerElement, this, $), $;
    },
    /**
     * Get an attribute by namespace and local name.
     *
     * @param {string | null} namespaceURI
     * The namespace URI of the attribute.
     * @param {string} localName
     * The local name of the attribute.
     * @returns {Attr | null}
     * The attribute with the given namespace URI and local name, or null if no such attribute
     * exists.
     * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace
     */
    getNamedItemNS: function(v, x) {
      v || (v = null);
      for (var $ = 0; $ < this.length; ) {
        var K = this[$];
        if (K.localName === x && K.namespaceURI === v)
          return K;
        $++;
      }
      return null;
    }
  }, pe.prototype[Symbol.iterator] = function() {
    var v = this, x = 0;
    return {
      next: function() {
        return x < v.length ? {
          value: v[x++],
          done: !1
        } : {
          done: !0
        };
      },
      return: function() {
        return {
          done: !0
        };
      }
    };
  };
  function Ee() {
  }
  Ee.prototype = {
    /**
     * Test if the DOM implementation implements a specific feature and version, as specified in
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMFeatures DOM Features}.
     *
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given
     * feature is supported. The different implementations fairly diverged in what kind of
     * features were reported. The latest version of the spec settled to force this method to
     * always return true, where the functionality was accurate and in use.
     *
     * @deprecated
     * It is deprecated and modern browsers return true in all cases.
     * @function DOMImplementation#hasFeature
     * @param {string} feature
     * The name of the feature to test.
     * @param {string} [version]
     * This is the version number of the feature to test.
     * @returns {boolean}
     * Always returns true.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-5CED94D7 DOM Level 3 Core
     */
    hasFeature: function(v, x) {
      return !0;
    },
    /**
     * Creates a DOM Document object of the specified type with its document element. Note that
     * based on the {@link DocumentType}
     * given to create the document, the implementation may instantiate specialized
     * {@link Document} objects that support additional features than the "Core", such as "HTML"
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML}.
     * On the other hand, setting the {@link DocumentType} after the document was created makes
     * this very unlikely to happen. Alternatively, specialized {@link Document} creation methods,
     * such as createHTMLDocument
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML},
     * can be used to obtain specific types of {@link Document} objects.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document`
     * instance (with it's `type` set to `'xml'`).
     * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     *
     * @function DOMImplementation.createDocument
     * @param {string | null} namespaceURI
     * The
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-namespaceURI namespace URI}
     * of the document element to create or null.
     * @param {string | null} qualifiedName
     * The
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified name}
     * of the document element to be created or null.
     * @param {DocumentType | null} [doctype=null]
     * The type of document to be created or null. When doctype is not null, its
     * {@link Node#ownerDocument} attribute is set to the document being created. Default is
     * `null`
     * @returns {Document}
     * A new {@link Document} object with its document element. If the NamespaceURI,
     * qualifiedName, and doctype are null, the returned {@link Document} is empty with no
     * document element.
     * @throws {DOMException}
     * With code:
     *
     * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
     * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
     * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed, if the qualifiedName has a
     * prefix and the namespaceURI is null, or if the qualifiedName is null and the namespaceURI
     * is different from null, or if the qualifiedName has a prefix that is "xml" and the
     * namespaceURI is different from "{@link http://www.w3.org/XML/1998/namespace}"
     * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#Namespaces XML Namespaces},
     * or if the DOM implementation does not support the "XML" feature but a non-null namespace
     * URI was provided, since namespaces were defined by XML.
     * - `WRONG_DOCUMENT_ERR`: Raised if doctype has already been used with a different document
     * or was created from a different implementation.
     * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
     * "XML" and the language exposed through the Document does not support XML Namespaces (such
     * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
     * @since DOM Level 2.
     * @see {@link #createHTMLDocument}
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument DOM Living Standard
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-2-Core-DOM-createDocument DOM
     *      Level 3 Core
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM
     *      Level 2 Core (initial)
     */
    createDocument: function(v, x, $) {
      var K = a.XML_APPLICATION;
      v === l.HTML ? K = a.XML_XHTML_APPLICATION : v === l.SVG && (K = a.XML_SVG_IMAGE);
      var se = new ae(c, { contentType: K });
      if (se.implementation = this, se.childNodes = new te(), se.doctype = $ || null, $ && se.appendChild($), x) {
        var he = se.createElementNS(v, x);
        se.appendChild(he);
      }
      return se;
    },
    /**
     * Creates an empty DocumentType node. Entity declarations and notations are not made
     * available. Entity reference expansions and default attribute additions do not occur.
     *
     * **This behavior is slightly different from the one in the specs**:
     * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - `publicId` and `systemId` contain the raw data including any possible quotes,
     *   so they can always be serialized back to the original value
     * - `internalSubset` contains the raw string between `[` and `]` if present,
     *   but is not parsed or validated in any form.
     *
     * @function DOMImplementation#createDocumentType
     * @param {string} qualifiedName
     * The {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified
     * name} of the document type to be created.
     * @param {string} [publicId]
     * The external subset public identifier.
     * @param {string} [systemId]
     * The external subset system identifier.
     * @param {string} [internalSubset]
     * the internal subset or an empty string if it is not present
     * @returns {DocumentType}
     * A new {@link DocumentType} node with {@link Node#ownerDocument} set to null.
     * @throws {DOMException}
     * With code:
     *
     * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
     * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
     * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed.
     * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
     * "XML" and the language exposed through the Document does not support XML Namespaces (such
     * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
     * @since DOM Level 2.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType
     *      MDN
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living
     *      Standard
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-3-Core-DOM-createDocType DOM
     *      Level 3 Core
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM
     *      Level 2 Core
     * @see https://github.com/xmldom/xmldom/blob/master/CHANGELOG.md#050
     * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-Core-DocType-internalSubset
     * @prettierignore
     */
    createDocumentType: function(v, x, $, K) {
      D(v);
      var se = new qn(c);
      return se.name = v, se.nodeName = v, se.publicId = x || "", se.systemId = $ || "", se.internalSubset = K || "", se.childNodes = new te(), se;
    },
    /**
     * Returns an HTML document, that might already have a basic DOM structure.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - If the first argument is `false` no initial nodes are added (steps 3-7 in the specs are
     * omitted)
     * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     *
     * @param {string | false} [title]
     * A string containing the title to give the new HTML document.
     * @returns {Document}
     * The HTML document.
     * @since WHATWG Living Standard.
     * @see {@link #createDocument}
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument
     * @see https://dom.spec.whatwg.org/#html-document
     */
    createHTMLDocument: function(v) {
      var x = new ae(c, { contentType: a.HTML });
      if (x.implementation = this, x.childNodes = new te(), v !== !1) {
        x.doctype = this.createDocumentType("html"), x.doctype.ownerDocument = x, x.appendChild(x.doctype);
        var $ = x.createElement("html");
        x.appendChild($);
        var K = x.createElement("head");
        if ($.appendChild(K), typeof v == "string") {
          var se = x.createElement("title");
          se.appendChild(x.createTextNode(v)), K.appendChild(se);
        }
        $.appendChild(x.createElement("body"));
      }
      return x;
    }
  };
  function fe(v) {
    g(v);
  }
  fe.prototype = {
    /**
     * The first child of this node.
     *
     * @type {Node | null}
     */
    firstChild: null,
    /**
     * The last child of this node.
     *
     * @type {Node | null}
     */
    lastChild: null,
    /**
     * The previous sibling of this node.
     *
     * @type {Node | null}
     */
    previousSibling: null,
    /**
     * The next sibling of this node.
     *
     * @type {Node | null}
     */
    nextSibling: null,
    /**
     * The parent node of this node.
     *
     * @type {Node | null}
     */
    parentNode: null,
    /**
     * The parent element of this node.
     *
     * @type {Element | null}
     */
    get parentElement() {
      return this.parentNode && this.parentNode.nodeType === this.ELEMENT_NODE ? this.parentNode : null;
    },
    /**
     * The child nodes of this node.
     *
     * @type {NodeList}
     */
    childNodes: null,
    /**
     * The document object associated with this node.
     *
     * @type {Document | null}
     */
    ownerDocument: null,
    /**
     * The value of this node.
     *
     * @type {string | null}
     */
    nodeValue: null,
    /**
     * The namespace URI of this node.
     *
     * @type {string | null}
     */
    namespaceURI: null,
    /**
     * The prefix of the namespace for this node.
     *
     * @type {string | null}
     */
    prefix: null,
    /**
     * The local part of the qualified name of this node.
     *
     * @type {string | null}
     */
    localName: null,
    /**
     * The baseURI is currently always `about:blank`,
     * since that's what happens when you create a document from scratch.
     *
     * @type {'about:blank'}
     */
    baseURI: "about:blank",
    /**
     * Is true if this node is part of a document.
     *
     * @type {boolean}
     */
    get isConnected() {
      var v = this.getRootNode();
      return v && v.nodeType === v.DOCUMENT_NODE;
    },
    /**
     * Checks whether `other` is an inclusive descendant of this node.
     *
     * @param {Node | null | undefined} other
     * The node to check.
     * @returns {boolean}
     * True if `other` is an inclusive descendant of this node; false otherwise.
     * @see https://dom.spec.whatwg.org/#dom-node-contains
     */
    contains: function(v) {
      if (!v) return !1;
      var x = v;
      do {
        if (this === x) return !0;
        x = v.parentNode;
      } while (x);
      return !1;
    },
    /**
     * @typedef GetRootNodeOptions
     * @property {boolean} [composed=false]
     */
    /**
     * Searches for the root node of this node.
     *
     * **This behavior is slightly different from the in the specs**:
     * - ignores `options.composed`, since `ShadowRoot`s are unsupported, always returns root.
     *
     * @param {GetRootNodeOptions} [options]
     * @returns {Node}
     * Root node.
     * @see https://dom.spec.whatwg.org/#dom-node-getrootnode
     * @see https://dom.spec.whatwg.org/#concept-shadow-including-root
     */
    getRootNode: function(v) {
      var x = this;
      do {
        if (!x.parentNode)
          return x;
        x = x.parentNode;
      } while (x);
    },
    /**
     * Checks whether the given node is equal to this node.
     *
     * @param {Node} [otherNode]
     * @see https://dom.spec.whatwg.org/#concept-node-equals
     */
    isEqualNode: function(v) {
      if (!v || this.nodeType !== v.nodeType) return !1;
      switch (this.nodeType) {
        case this.DOCUMENT_TYPE_NODE:
          if (this.name !== v.name || this.publicId !== v.publicId || this.systemId !== v.systemId) return !1;
          break;
        case this.ELEMENT_NODE:
          if (this.namespaceURI !== v.namespaceURI || this.prefix !== v.prefix || this.localName !== v.localName || this.attributes.length !== v.attributes.length) return !1;
          for (var x = 0; x < this.attributes.length; x++) {
            var $ = this.attributes.item(x);
            if (!$.isEqualNode(v.getAttributeNodeNS($.namespaceURI, $.localName)))
              return !1;
          }
          break;
        case this.ATTRIBUTE_NODE:
          if (this.namespaceURI !== v.namespaceURI || this.localName !== v.localName || this.value !== v.value) return !1;
          break;
        case this.PROCESSING_INSTRUCTION_NODE:
          if (this.target !== v.target || this.data !== v.data)
            return !1;
          break;
        case this.TEXT_NODE:
        case this.COMMENT_NODE:
          if (this.data !== v.data) return !1;
          break;
      }
      if (this.childNodes.length !== v.childNodes.length)
        return !1;
      for (var x = 0; x < this.childNodes.length; x++)
        if (!this.childNodes[x].isEqualNode(v.childNodes[x]))
          return !1;
      return !0;
    },
    /**
     * Checks whether or not the given node is this node.
     *
     * @param {Node} [otherNode]
     */
    isSameNode: function(v) {
      return this === v;
    },
    /**
     * Inserts a node before a reference node as a child of this node.
     *
     * @param {Node} newChild
     * The new child node to be inserted.
     * @param {Node | null} refChild
     * The reference node before which newChild will be inserted.
     * @returns {Node}
     * The new child node successfully inserted.
     * @throws {DOMException}
     * Throws a DOMException if inserting the node would result in a DOM tree that is not
     * well-formed, or if `child` is provided but is not a child of `parent`.
     * See {@link _insertBefore} for more details.
     * @since Modified in DOM L2
     */
    insertBefore: function(v, x) {
      return Ce(this, v, x);
    },
    /**
     * Replaces an old child node with a new child node within this node.
     *
     * @param {Node} newChild
     * The new node that is to replace the old node.
     * If it already exists in the DOM, it is removed from its original position.
     * @param {Node} oldChild
     * The existing child node to be replaced.
     * @returns {Node}
     * Returns the replaced child node.
     * @throws {DOMException}
     * Throws a DOMException if replacing the node would result in a DOM tree that is not
     * well-formed, or if `oldChild` is not a child of `this`.
     * This can also occur if the pre-replacement validity assertion fails.
     * See {@link _insertBefore}, {@link Node.removeChild}, and
     * {@link assertPreReplacementValidityInDocument} for more details.
     * @see https://dom.spec.whatwg.org/#concept-node-replace
     */
    replaceChild: function(v, x) {
      Ce(this, v, x, $n), x && this.removeChild(x);
    },
    /**
     * Removes an existing child node from this node.
     *
     * @param {Node} oldChild
     * The child node to be removed.
     * @returns {Node}
     * Returns the removed child node.
     * @throws {DOMException}
     * Throws a DOMException if `oldChild` is not a child of `this`.
     * See {@link _removeChild} for more details.
     */
    removeChild: function(v) {
      return rt(this, v);
    },
    /**
     * Appends a child node to this node.
     *
     * @param {Node} newChild
     * The child node to be appended to this node.
     * If it already exists in the DOM, it is removed from its original position.
     * @returns {Node}
     * Returns the appended child node.
     * @throws {DOMException}
     * Throws a DOMException if appending the node would result in a DOM tree that is not
     * well-formed, or if `newChild` is not a valid Node.
     * See {@link insertBefore} for more details.
     */
    appendChild: function(v) {
      return this.insertBefore(v, null);
    },
    /**
     * Determines whether this node has any child nodes.
     *
     * @returns {boolean}
     * Returns true if this node has any child nodes, and false otherwise.
     */
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    /**
     * Creates a copy of the calling node.
     *
     * @param {boolean} deep
     * If true, the contents of the node are recursively copied.
     * If false, only the node itself (and its attributes, if it is an element) are copied.
     * @returns {Node}
     * Returns the newly created copy of the node.
     * @throws {DOMException}
     * May throw a DOMException if operations within {@link Element#setAttributeNode} or
     * {@link Node#appendChild} (which are potentially invoked in this method) do not meet their
     * specific constraints.
     * @see {@link cloneNode}
     */
    cloneNode: function(v) {
      return Ti(this.ownerDocument || this, this, v);
    },
    /**
     * Puts the specified node and all of its subtree into a "normalized" form. In a normalized
     * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.
     *
     * Specifically, this method merges any adjacent text nodes (i.e., nodes for which `nodeType`
     * is `TEXT_NODE`) into a single node with the combined data. It also removes any empty text
     * nodes.
     *
     * This method operates recursively, so it also normalizes any and all descendent nodes within
     * the subtree.
     *
     * @throws {DOMException}
     * May throw a DOMException if operations within removeChild or appendData (which are
     * potentially invoked in this method) do not meet their specific constraints.
     * @since Modified in DOM Level 2
     * @see {@link Node.removeChild}
     * @see {@link CharacterData.appendData}
     */
    normalize: function() {
      for (var v = this.firstChild; v; ) {
        var x = v.nextSibling;
        x && x.nodeType == k && v.nodeType == k ? (this.removeChild(x), v.appendData(x.data)) : (v.normalize(), v = x);
      }
    },
    /**
     * Checks whether the DOM implementation implements a specific feature and its version.
     *
     * @deprecated
     * Since `DOMImplementation.hasFeature` is deprecated and always returns true.
     * @param {string} feature
     * The package name of the feature to test. This is the same name that can be passed to the
     * method `hasFeature` on `DOMImplementation`.
     * @param {string} version
     * This is the version number of the package name to test.
     * @returns {boolean}
     * Returns true in all cases in the current implementation.
     * @since Introduced in DOM Level 2
     * @see {@link DOMImplementation.hasFeature}
     */
    isSupported: function(v, x) {
      return this.ownerDocument.implementation.hasFeature(v, x);
    },
    /**
     * Look up the prefix associated to the given namespace URI, starting from this node.
     * **The default namespace declarations are ignored by this method.**
     * See Namespace Prefix Lookup for details on the algorithm used by this method.
     *
     * **This behavior is different from the in the specs**:
     * - no node type specific handling
     * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
     *
     * @param {string | null} namespaceURI
     * The namespace URI for which to find the associated prefix.
     * @returns {string | null}
     * The associated prefix, if found; otherwise, null.
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
     * @see https://github.com/xmldom/xmldom/issues/322
     * @prettierignore
     */
    lookupPrefix: function(v) {
      for (var x = this; x; ) {
        var $ = x._nsMap;
        if ($) {
          for (var K in $)
            if (r($, K) && $[K] === v)
              return K;
        }
        x = x.nodeType == F ? x.ownerDocument : x.parentNode;
      }
      return null;
    },
    /**
     * This function is used to look up the namespace URI associated with the given prefix,
     * starting from this node.
     *
     * **This behavior is different from the in the specs**:
     * - no node type specific handling
     * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
     *
     * @param {string | null} prefix
     * The prefix for which to find the associated namespace URI.
     * @returns {string | null}
     * The associated namespace URI, if found; otherwise, null.
     * @since DOM Level 3
     * @see https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI
     * @prettierignore
     */
    lookupNamespaceURI: function(v) {
      for (var x = this; x; ) {
        var $ = x._nsMap;
        if ($ && r($, v))
          return $[v];
        x = x.nodeType == F ? x.ownerDocument : x.parentNode;
      }
      return null;
    },
    /**
     * Determines whether the given namespace URI is the default namespace.
     *
     * The function works by looking up the prefix associated with the given namespace URI. If no
     * prefix is found (i.e., the namespace URI is not registered in the namespace map of this
     * node or any of its ancestors), it returns `true`, implying the namespace URI is considered
     * the default.
     *
     * **This behavior is different from the in the specs**:
     * - no node type specific handling
     * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
     *
     * @param {string | null} namespaceURI
     * The namespace URI to be checked.
     * @returns {boolean}
     * Returns true if the given namespace URI is the default namespace, false otherwise.
     * @since DOM Level 3
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isDefaultNamespace
     * @see https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
     * @prettierignore
     */
    isDefaultNamespace: function(v) {
      var x = this.lookupPrefix(v);
      return x == null;
    },
    /**
     * Compares the reference node with a node with regard to their position in the document and
     * according to the document order.
     *
     * @param {Node} other
     * The node to compare the reference node to.
     * @returns {number}
     * Returns how the node is positioned relatively to the reference node according to the
     * bitmask. 0 if reference node and given node are the same.
     * @since DOM Level 3
     * @see https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-compare
     * @see https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
     */
    compareDocumentPosition: function(v) {
      if (this === v) return 0;
      var x = v, $ = this, K = null, se = null;
      if (x instanceof Mt && (K = x, x = K.ownerElement), $ instanceof Mt && (se = $, $ = se.ownerElement, K && x && $ === x))
        for (var he = 0, Fe; Fe = $.attributes[he]; he++) {
          if (Fe === K)
            return W.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + W.DOCUMENT_POSITION_PRECEDING;
          if (Fe === se)
            return W.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + W.DOCUMENT_POSITION_FOLLOWING;
        }
      if (!x || !$ || $.ownerDocument !== x.ownerDocument)
        return W.DOCUMENT_POSITION_DISCONNECTED + W.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + (re($.ownerDocument) > re(x.ownerDocument) ? W.DOCUMENT_POSITION_FOLLOWING : W.DOCUMENT_POSITION_PRECEDING);
      if (se && x === $)
        return W.DOCUMENT_POSITION_CONTAINS + W.DOCUMENT_POSITION_PRECEDING;
      if (K && x === $)
        return W.DOCUMENT_POSITION_CONTAINED_BY + W.DOCUMENT_POSITION_FOLLOWING;
      for (var _t = [], Nt = x.parentNode; Nt; ) {
        if (!se && Nt === $)
          return W.DOCUMENT_POSITION_CONTAINED_BY + W.DOCUMENT_POSITION_FOLLOWING;
        _t.push(Nt), Nt = Nt.parentNode;
      }
      _t.reverse();
      for (var Yt = [], Ot = $.parentNode; Ot; ) {
        if (!K && Ot === x)
          return W.DOCUMENT_POSITION_CONTAINS + W.DOCUMENT_POSITION_PRECEDING;
        Yt.push(Ot), Ot = Ot.parentNode;
      }
      Yt.reverse();
      var gt = ne(_t, Yt);
      for (var Vn in gt.childNodes) {
        var an = gt.childNodes[Vn];
        if (an === $) return W.DOCUMENT_POSITION_FOLLOWING;
        if (an === x) return W.DOCUMENT_POSITION_PRECEDING;
        if (Yt.indexOf(an) >= 0) return W.DOCUMENT_POSITION_FOLLOWING;
        if (_t.indexOf(an) >= 0) return W.DOCUMENT_POSITION_PRECEDING;
      }
      return 0;
    }
  };
  function Pe(v) {
    return v == "<" && "&lt;" || v == ">" && "&gt;" || v == "&" && "&amp;" || v == '"' && "&quot;" || "&#" + v.charCodeAt() + ";";
  }
  S(O, fe), S(O, fe.prototype), S(W, fe), S(W, fe.prototype);
  function He(v, x) {
    if (x(v))
      return !0;
    if (v = v.firstChild)
      do
        if (He(v, x))
          return !0;
      while (v = v.nextSibling);
  }
  function ae(v, x) {
    g(v);
    var $ = x || {};
    this.ownerDocument = this, this.contentType = $.contentType || a.XML_APPLICATION, this.type = i(this.contentType) ? "html" : "xml";
  }
  function Te(v, x, $) {
    v && v._inc++;
    var K = $.namespaceURI;
    K === l.XMLNS && (x._nsMap[$.prefix ? $.localName : ""] = $.value);
  }
  function Be(v, x, $, K) {
    v && v._inc++;
    var se = $.namespaceURI;
    se === l.XMLNS && delete x._nsMap[$.prefix ? $.localName : ""];
  }
  function Ge(v, x, $) {
    if (v && v._inc) {
      v._inc++;
      var K = x.childNodes;
      if ($ && !$.nextSibling)
        K[K.length++] = $;
      else {
        for (var se = x.firstChild, he = 0; se; )
          K[he++] = se, se = se.nextSibling;
        K.length = he, delete K[K.length];
      }
    }
  }
  function rt(v, x) {
    if (v !== x.parentNode)
      throw new f(f.NOT_FOUND_ERR, "child's parent is not parent");
    var $ = x.previousSibling, K = x.nextSibling;
    return $ ? $.nextSibling = K : v.firstChild = K, K ? K.previousSibling = $ : v.lastChild = $, Ge(v.ownerDocument, v), x.parentNode = null, x.previousSibling = null, x.nextSibling = null, x;
  }
  function vt(v) {
    return v && (v.nodeType === fe.DOCUMENT_NODE || v.nodeType === fe.DOCUMENT_FRAGMENT_NODE || v.nodeType === fe.ELEMENT_NODE);
  }
  function mt(v) {
    return v && (v.nodeType === fe.CDATA_SECTION_NODE || v.nodeType === fe.COMMENT_NODE || v.nodeType === fe.DOCUMENT_FRAGMENT_NODE || v.nodeType === fe.DOCUMENT_TYPE_NODE || v.nodeType === fe.ELEMENT_NODE || v.nodeType === fe.PROCESSING_INSTRUCTION_NODE || v.nodeType === fe.TEXT_NODE);
  }
  function Et(v) {
    return v && v.nodeType === fe.DOCUMENT_TYPE_NODE;
  }
  function $e(v) {
    return v && v.nodeType === fe.ELEMENT_NODE;
  }
  function Dt(v) {
    return v && v.nodeType === fe.TEXT_NODE;
  }
  function ct(v, x) {
    var $ = v.childNodes || [];
    if (e($, $e) || Et(x))
      return !1;
    var K = e($, Et);
    return !(x && K && $.indexOf(K) > $.indexOf(x));
  }
  function lr(v, x) {
    var $ = v.childNodes || [];
    function K(he) {
      return $e(he) && he !== x;
    }
    if (e($, K))
      return !1;
    var se = e($, Et);
    return !(x && se && $.indexOf(se) > $.indexOf(x));
  }
  function Ln(v, x, $) {
    if (!vt(v))
      throw new f(f.HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + v.nodeType);
    if ($ && $.parentNode !== v)
      throw new f(f.NOT_FOUND_ERR, "child not in parent");
    if (
      // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
      !mt(x) || // 5. If either `node` is a Text node and `parent` is a document,
      // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
      // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
      // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
      Et(x) && v.nodeType !== fe.DOCUMENT_NODE
    )
      throw new f(
        f.HIERARCHY_REQUEST_ERR,
        "Unexpected node type " + x.nodeType + " for parent node type " + v.nodeType
      );
  }
  function En(v, x, $) {
    var K = v.childNodes || [], se = x.childNodes || [];
    if (x.nodeType === fe.DOCUMENT_FRAGMENT_NODE) {
      var he = se.filter($e);
      if (he.length > 1 || e(se, Dt))
        throw new f(f.HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      if (he.length === 1 && !ct(v, $))
        throw new f(f.HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
    }
    if ($e(x) && !ct(v, $))
      throw new f(f.HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
    if (Et(x)) {
      if (e(K, Et))
        throw new f(f.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      var Fe = e(K, $e);
      if ($ && K.indexOf(Fe) < K.indexOf($))
        throw new f(f.HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      if (!$ && Fe)
        throw new f(f.HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
    }
  }
  function $n(v, x, $) {
    var K = v.childNodes || [], se = x.childNodes || [];
    if (x.nodeType === fe.DOCUMENT_FRAGMENT_NODE) {
      var he = se.filter($e);
      if (he.length > 1 || e(se, Dt))
        throw new f(f.HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      if (he.length === 1 && !lr(v, $))
        throw new f(f.HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
    }
    if ($e(x) && !lr(v, $))
      throw new f(f.HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
    if (Et(x)) {
      if (e(K, function(Nt) {
        return Et(Nt) && Nt !== $;
      }))
        throw new f(f.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      var Fe = e(K, $e);
      if ($ && K.indexOf(Fe) < K.indexOf($))
        throw new f(f.HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
    }
  }
  function Ce(v, x, $, K) {
    Ln(v, x, $), v.nodeType === fe.DOCUMENT_NODE && (K || En)(v, x, $);
    var se = x.parentNode;
    if (se && se.removeChild(x), x.nodeType === J) {
      var he = x.firstChild;
      if (he == null)
        return x;
      var Fe = x.lastChild;
    } else
      he = Fe = x;
    var _t = $ ? $.previousSibling : v.lastChild;
    he.previousSibling = _t, Fe.nextSibling = $, _t ? _t.nextSibling = he : v.firstChild = he, $ == null ? v.lastChild = Fe : $.previousSibling = Fe;
    do
      he.parentNode = v;
    while (he !== Fe && (he = he.nextSibling));
    return Ge(v.ownerDocument || v, v, x), x.nodeType == J && (x.firstChild = x.lastChild = null), x;
  }
  ae.prototype = {
    /**
     * The implementation that created this document.
     *
     * @type DOMImplementation
     * @readonly
     */
    implementation: null,
    nodeName: "#document",
    nodeType: q,
    /**
     * The DocumentType node of the document.
     *
     * @type DocumentType
     * @readonly
     */
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(v, x) {
      if (v.nodeType === J) {
        for (var $ = v.firstChild; $; ) {
          var K = $.nextSibling;
          this.insertBefore($, x), $ = K;
        }
        return v;
      }
      return Ce(this, v, x), v.ownerDocument = this, this.documentElement === null && v.nodeType === M && (this.documentElement = v), v;
    },
    removeChild: function(v) {
      var x = rt(this, v);
      return x === this.documentElement && (this.documentElement = null), x;
    },
    replaceChild: function(v, x) {
      Ce(this, v, x, $n), v.ownerDocument = this, x && this.removeChild(x), $e(v) && (this.documentElement = v);
    },
    // Introduced in DOM Level 2:
    importNode: function(v, x) {
      return ur(this, v, x);
    },
    // Introduced in DOM Level 2:
    getElementById: function(v) {
      var x = null;
      return He(this.documentElement, function($) {
        if ($.nodeType == M && $.getAttribute("id") == v)
          return x = $, !0;
      }), x;
    },
    /**
     * Creates a new `Element` that is owned by this `Document`.
     * In HTML Documents `localName` is the lower cased `tagName`,
     * otherwise no transformation is being applied.
     * When `contentType` implies the HTML namespace, it will be set as `namespaceURI`.
     *
     * __This implementation differs from the specification:__ - The provided name is not checked
     * against the `Name` production,
     * so no related error will be thrown.
     * - There is no interface `HTMLElement`, it is always an `Element`.
     * - There is no support for a second argument to indicate using custom elements.
     *
     * @param {string} tagName
     * @returns {Element}
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
     * @see https://dom.spec.whatwg.org/#dom-document-createelement
     * @see https://dom.spec.whatwg.org/#concept-create-element
     */
    createElement: function(v) {
      var x = new Qe(c);
      x.ownerDocument = this, this.type === "html" && (v = v.toLowerCase()), n(this.contentType) && (x.namespaceURI = l.HTML), x.nodeName = v, x.tagName = v, x.localName = v, x.childNodes = new te();
      var $ = x.attributes = new pe();
      return $._ownerElement = x, x;
    },
    /**
     * @returns {DocumentFragment}
     */
    createDocumentFragment: function() {
      var v = new zn(c);
      return v.ownerDocument = this, v.childNodes = new te(), v;
    },
    /**
     * @param {string} data
     * @returns {Text}
     */
    createTextNode: function(v) {
      var x = new Fn(c);
      return x.ownerDocument = this, x.childNodes = new te(), x.appendData(v), x;
    },
    /**
     * @param {string} data
     * @returns {Comment}
     */
    createComment: function(v) {
      var x = new Bn(c);
      return x.ownerDocument = this, x.childNodes = new te(), x.appendData(v), x;
    },
    /**
     * @param {string} data
     * @returns {CDATASection}
     */
    createCDATASection: function(v) {
      var x = new cr(c);
      return x.ownerDocument = this, x.childNodes = new te(), x.appendData(v), x;
    },
    /**
     * @param {string} target
     * @param {string} data
     * @returns {ProcessingInstruction}
     */
    createProcessingInstruction: function(v, x) {
      var $ = new Nn(c);
      return $.ownerDocument = this, $.childNodes = new te(), $.nodeName = $.target = v, $.nodeValue = $.data = x, $;
    },
    /**
     * Creates an `Attr` node that is owned by this document.
     * In HTML Documents `localName` is the lower cased `name`,
     * otherwise no transformation is being applied.
     *
     * __This implementation differs from the specification:__ - The provided name is not checked
     * against the `Name` production,
     * so no related error will be thrown.
     *
     * @param {string} name
     * @returns {Attr}
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createAttribute
     * @see https://dom.spec.whatwg.org/#dom-document-createattribute
     */
    createAttribute: function(v) {
      if (!h.QName_exact.test(v))
        throw new f(f.INVALID_CHARACTER_ERR, 'invalid character in name "' + v + '"');
      return this.type === "html" && (v = v.toLowerCase()), this._createAttribute(v);
    },
    _createAttribute: function(v) {
      var x = new Mt(c);
      return x.ownerDocument = this, x.childNodes = new te(), x.name = v, x.nodeName = v, x.localName = v, x.specified = !0, x;
    },
    /**
     * Creates an EntityReference object.
     * The current implementation does not fill the `childNodes` with those of the corresponding
     * `Entity`
     *
     * @deprecated
     * In DOM Level 4.
     * @param {string} name
     * The name of the entity to reference. No namespace well-formedness checks are performed.
     * @returns {EntityReference}
     * @throws {DOMException}
     * With code `INVALID_CHARACTER_ERR` when `name` is not valid.
     * @throws {DOMException}
     * with code `NOT_SUPPORTED_ERR` when the document is of type `html`
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-392B75AE
     */
    createEntityReference: function(v) {
      if (!h.Name.test(v))
        throw new f(f.INVALID_CHARACTER_ERR, 'not a valid xml name "' + v + '"');
      if (this.type === "html")
        throw new f("document is an html document", d.NotSupportedError);
      var x = new Un(c);
      return x.ownerDocument = this, x.childNodes = new te(), x.nodeName = v, x;
    },
    // Introduced in DOM Level 2:
    /**
     * @param {string} namespaceURI
     * @param {string} qualifiedName
     * @returns {Element}
     */
    createElementNS: function(v, x) {
      var $ = P(v, x), K = new Qe(c), se = K.attributes = new pe();
      return K.childNodes = new te(), K.ownerDocument = this, K.nodeName = x, K.tagName = x, K.namespaceURI = $[0], K.prefix = $[1], K.localName = $[2], se._ownerElement = K, K;
    },
    // Introduced in DOM Level 2:
    /**
     * @param {string} namespaceURI
     * @param {string} qualifiedName
     * @returns {Attr}
     */
    createAttributeNS: function(v, x) {
      var $ = P(v, x), K = new Mt(c);
      return K.ownerDocument = this, K.childNodes = new te(), K.nodeName = x, K.name = x, K.specified = !0, K.namespaceURI = $[0], K.prefix = $[1], K.localName = $[2], K;
    }
  }, L(ae, fe);
  function Qe(v) {
    g(v), this._nsMap = /* @__PURE__ */ Object.create(null);
  }
  Qe.prototype = {
    nodeType: M,
    /**
     * The attributes of this element.
     *
     * @type {NamedNodeMap | null}
     */
    attributes: null,
    getQualifiedName: function() {
      return this.prefix ? this.prefix + ":" + this.localName : this.localName;
    },
    _isInHTMLDocumentAndNamespace: function() {
      return this.ownerDocument.type === "html" && this.namespaceURI === l.HTML;
    },
    /**
     * Implementaton of Level2 Core function hasAttributes.
     *
     * @returns {boolean}
     * True if attribute list is not empty.
     * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-NodeHasAttrs
     */
    hasAttributes: function() {
      return !!(this.attributes && this.attributes.length);
    },
    hasAttribute: function(v) {
      return !!this.getAttributeNode(v);
    },
    /**
     * Returns elementâ€™s first attribute whose qualified name is `name`, and `null`
     * if there is no such attribute.
     *
     * @param {string} name
     * @returns {string | null}
     */
    getAttribute: function(v) {
      var x = this.getAttributeNode(v);
      return x ? x.value : null;
    },
    getAttributeNode: function(v) {
      return this._isInHTMLDocumentAndNamespace() && (v = v.toLowerCase()), this.attributes.getNamedItem(v);
    },
    /**
     * Sets the value of elementâ€™s first attribute whose qualified name is qualifiedName to value.
     *
     * @param {string} name
     * @param {string} value
     */
    setAttribute: function(v, x) {
      this._isInHTMLDocumentAndNamespace() && (v = v.toLowerCase());
      var $ = this.getAttributeNode(v);
      $ ? $.value = $.nodeValue = "" + x : ($ = this.ownerDocument._createAttribute(v), $.value = $.nodeValue = "" + x, this.setAttributeNode($));
    },
    removeAttribute: function(v) {
      var x = this.getAttributeNode(v);
      x && this.removeAttributeNode(x);
    },
    setAttributeNode: function(v) {
      return this.attributes.setNamedItem(v);
    },
    setAttributeNodeNS: function(v) {
      return this.attributes.setNamedItemNS(v);
    },
    removeAttributeNode: function(v) {
      return this.attributes.removeNamedItem(v.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(v, x) {
      var $ = this.getAttributeNodeNS(v, x);
      $ && this.removeAttributeNode($);
    },
    hasAttributeNS: function(v, x) {
      return this.getAttributeNodeNS(v, x) != null;
    },
    /**
     * Returns elementâ€™s attribute whose namespace is `namespaceURI` and local name is
     * `localName`,
     * or `null` if there is no such attribute.
     *
     * @param {string} namespaceURI
     * @param {string} localName
     * @returns {string | null}
     */
    getAttributeNS: function(v, x) {
      var $ = this.getAttributeNodeNS(v, x);
      return $ ? $.value : null;
    },
    /**
     * Sets the value of elementâ€™s attribute whose namespace is `namespaceURI` and local name is
     * `localName` to value.
     *
     * @param {string} namespaceURI
     * @param {string} qualifiedName
     * @param {string} value
     * @see https://dom.spec.whatwg.org/#dom-element-setattributens
     */
    setAttributeNS: function(v, x, $) {
      var K = P(v, x), se = K[2], he = this.getAttributeNodeNS(v, se);
      he ? he.value = he.nodeValue = "" + $ : (he = this.ownerDocument.createAttributeNS(v, x), he.value = he.nodeValue = "" + $, this.setAttributeNode(he));
    },
    getAttributeNodeNS: function(v, x) {
      return this.attributes.getNamedItemNS(v, x);
    },
    /**
     * Returns a LiveNodeList of all child elements which have **all** of the given class name(s).
     *
     * Returns an empty list if `classNames` is an empty string or only contains HTML white space
     * characters.
     *
     * Warning: This returns a live LiveNodeList.
     * Changes in the DOM will reflect in the array as the changes occur.
     * If an element selected by this array no longer qualifies for the selector,
     * it will automatically be removed. Be aware of this for iteration purposes.
     *
     * @param {string} classNames
     * Is a string representing the class name(s) to match; multiple class names are separated by
     * (ASCII-)whitespace.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
     */
    getElementsByClassName: function(v) {
      var x = y(v);
      return new Q(this, function($) {
        var K = [];
        return x.length > 0 && He($, function(se) {
          if (se !== $ && se.nodeType === M) {
            var he = se.getAttribute("class");
            if (he) {
              var Fe = v === he;
              if (!Fe) {
                var _t = y(he);
                Fe = x.every(C(_t));
              }
              Fe && K.push(se);
            }
          }
        }), K;
      });
    },
    /**
     * Returns a LiveNodeList of elements with the given qualifiedName.
     * Searching for all descendants can be done by passing `*` as `qualifiedName`.
     *
     * All descendants of the specified element are searched, but not the element itself.
     * The returned list is live, which means it updates itself with the DOM tree automatically.
     * Therefore, there is no need to call `Element.getElementsByTagName()`
     * with the same element and arguments repeatedly if the DOM changes in between calls.
     *
     * When called on an HTML element in an HTML document,
     * `getElementsByTagName` lower-cases the argument before searching for it.
     * This is undesirable when trying to match camel-cased SVG elements (such as
     * `<linearGradient>`) in an HTML document.
     * Instead, use `Element.getElementsByTagNameNS()`,
     * which preserves the capitalization of the tag name.
     *
     * `Element.getElementsByTagName` is similar to `Document.getElementsByTagName()`,
     * except that it only searches for elements that are descendants of the specified element.
     *
     * @param {string} qualifiedName
     * @returns {LiveNodeList}
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbytagname
     */
    getElementsByTagName: function(v) {
      var x = (this.nodeType === q ? this : this.ownerDocument).type === "html", $ = v.toLowerCase();
      return new Q(this, function(K) {
        var se = [];
        return He(K, function(he) {
          if (!(he === K || he.nodeType !== M))
            if (v === "*")
              se.push(he);
            else {
              var Fe = he.getQualifiedName(), _t = x && he.namespaceURI === l.HTML ? $ : v;
              Fe === _t && se.push(he);
            }
        }), se;
      });
    },
    getElementsByTagNameNS: function(v, x) {
      return new Q(this, function($) {
        var K = [];
        return He($, function(se) {
          se !== $ && se.nodeType === M && (v === "*" || se.namespaceURI === v) && (x === "*" || se.localName == x) && K.push(se);
        }), K;
      });
    }
  }, ae.prototype.getElementsByClassName = Qe.prototype.getElementsByClassName, ae.prototype.getElementsByTagName = Qe.prototype.getElementsByTagName, ae.prototype.getElementsByTagNameNS = Qe.prototype.getElementsByTagNameNS, L(Qe, fe);
  function Mt(v) {
    g(v), this.namespaceURI = null, this.prefix = null, this.ownerElement = null;
  }
  Mt.prototype.nodeType = F, L(Mt, fe);
  function Bt(v) {
    g(v);
  }
  Bt.prototype = {
    data: "",
    substringData: function(v, x) {
      return this.data.substring(v, v + x);
    },
    appendData: function(v) {
      v = this.data + v, this.nodeValue = this.data = v, this.length = v.length;
    },
    insertData: function(v, x) {
      this.replaceData(v, 0, x);
    },
    deleteData: function(v, x) {
      this.replaceData(v, x, "");
    },
    replaceData: function(v, x, $) {
      var K = this.data.substring(0, v), se = this.data.substring(v + x);
      $ = K + $ + se, this.nodeValue = this.data = $, this.length = $.length;
    }
  }, L(Bt, fe);
  function Fn(v) {
    g(v);
  }
  Fn.prototype = {
    nodeName: "#text",
    nodeType: k,
    splitText: function(v) {
      var x = this.data, $ = x.substring(v);
      x = x.substring(0, v), this.data = this.nodeValue = x, this.length = x.length;
      var K = this.ownerDocument.createTextNode($);
      return this.parentNode && this.parentNode.insertBefore(K, this.nextSibling), K;
    }
  }, L(Fn, Bt);
  function Bn(v) {
    g(v);
  }
  Bn.prototype = {
    nodeName: "#comment",
    nodeType: A
  }, L(Bn, Bt);
  function cr(v) {
    g(v);
  }
  cr.prototype = {
    nodeName: "#cdata-section",
    nodeType: I
  }, L(cr, Fn);
  function qn(v) {
    g(v);
  }
  qn.prototype.nodeType = V, L(qn, fe);
  function jn(v) {
    g(v);
  }
  jn.prototype.nodeType = H, L(jn, fe);
  function Xt(v) {
    g(v);
  }
  Xt.prototype.nodeType = R, L(Xt, fe);
  function Un(v) {
    g(v);
  }
  Un.prototype.nodeType = N, L(Un, fe);
  function zn(v) {
    g(v);
  }
  zn.prototype.nodeName = "#document-fragment", zn.prototype.nodeType = J, L(zn, fe);
  function Nn(v) {
    g(v);
  }
  Nn.prototype.nodeType = T, L(Nn, Bt);
  function Dr() {
  }
  Dr.prototype.serializeToString = function(v, x) {
    return Ze.call(v, x);
  }, fe.prototype.toString = Ze;
  function Ze(v) {
    var x = [], $ = this.nodeType === q && this.documentElement || this, K = $.prefix, se = $.namespaceURI;
    if (se && K == null) {
      var K = $.lookupPrefix(se);
      if (K == null)
        var he = [
          { namespace: se, prefix: null }
          //{namespace:uri,prefix:''}
        ];
    }
    return wn(this, x, v, he), x.join("");
  }
  function bt(v, x, $) {
    var K = v.prefix || "", se = v.namespaceURI;
    if (!se || K === "xml" && se === l.XML || se === l.XMLNS)
      return !1;
    for (var he = $.length; he--; ) {
      var Fe = $[he];
      if (Fe.prefix === K)
        return Fe.namespace !== se;
    }
    return !0;
  }
  function gn(v, x, $) {
    v.push(" ", x, '="', $.replace(/[<>&"\t\n\r]/g, Pe), '"');
  }
  function wn(v, x, $, K) {
    K || (K = []);
    var se = v.nodeType === q ? v : v.ownerDocument, he = se.type === "html";
    if ($)
      if (v = $(v), v) {
        if (typeof v == "string") {
          x.push(v);
          return;
        }
      } else
        return;
    switch (v.nodeType) {
      case M:
        var Fe = v.attributes, _t = Fe.length, Tt = v.firstChild, Nt = v.tagName, Yt = Nt;
        if (!he && !v.prefix && v.namespaceURI) {
          for (var Ot, gt = 0; gt < Fe.length; gt++)
            if (Fe.item(gt).name === "xmlns") {
              Ot = Fe.item(gt).value;
              break;
            }
          if (!Ot)
            for (var Vn = K.length - 1; Vn >= 0; Vn--) {
              var an = K[Vn];
              if (an.prefix === "" && an.namespace === v.namespaceURI) {
                Ot = an.namespace;
                break;
              }
            }
          if (Ot !== v.namespaceURI)
            for (var Vn = K.length - 1; Vn >= 0; Vn--) {
              var an = K[Vn];
              if (an.namespace === v.namespaceURI) {
                an.prefix && (Yt = an.prefix + ":" + Nt);
                break;
              }
            }
        }
        x.push("<", Yt);
        for (var dr = 0; dr < _t; dr++) {
          var Sn = Fe.item(dr);
          Sn.prefix == "xmlns" ? K.push({
            prefix: Sn.localName,
            namespace: Sn.value
          }) : Sn.nodeName == "xmlns" && K.push({ prefix: "", namespace: Sn.value });
        }
        for (var dr = 0; dr < _t; dr++) {
          var Sn = Fe.item(dr);
          if (bt(Sn, he, K)) {
            var fr = Sn.prefix || "", St = Sn.namespaceURI;
            gn(x, fr ? "xmlns:" + fr : "xmlns", St), K.push({ prefix: fr, namespace: St });
          }
          wn(Sn, x, $, K);
        }
        if (Nt === Yt && bt(v, he, K)) {
          var fr = v.prefix || "", St = v.namespaceURI;
          gn(x, fr ? "xmlns:" + fr : "xmlns", St), K.push({ prefix: fr, namespace: St });
        }
        var ao = !Tt;
        if (ao && (he || v.namespaceURI === l.HTML) && (ao = s(Nt)), ao)
          x.push("/>");
        else {
          if (x.push(">"), he && o(Nt))
            for (; Tt; )
              Tt.data ? x.push(Tt.data) : wn(Tt, x, $, K.slice()), Tt = Tt.nextSibling;
          else
            for (; Tt; )
              wn(Tt, x, $, K.slice()), Tt = Tt.nextSibling;
          x.push("</", Yt, ">");
        }
        return;
      case q:
      case J:
        for (var Tt = v.firstChild; Tt; )
          wn(Tt, x, $, K.slice()), Tt = Tt.nextSibling;
        return;
      case F:
        return gn(x, v.name, v.value);
      case k:
        return x.push(v.data.replace(/[<&>]/g, Pe));
      case I:
        return x.push(h.CDATA_START, v.data, h.CDATA_END);
      case A:
        return x.push(h.COMMENT_START, v.data, h.COMMENT_END);
      case V:
        var ls = v.publicId, Mr = v.systemId;
        x.push(h.DOCTYPE_DECL_START, " ", v.name), ls ? (x.push(" ", h.PUBLIC, " ", ls), Mr && Mr !== "." && x.push(" ", Mr)) : Mr && Mr !== "." && x.push(" ", h.SYSTEM, " ", Mr), v.internalSubset && x.push(" [", v.internalSubset, "]"), x.push(">");
        return;
      case T:
        return x.push("<?", v.target, " ", v.data, "?>");
      case N:
        return x.push("&", v.nodeName, ";");
      //case ENTITY_NODE:
      //case NOTATION_NODE:
      default:
        x.push("??", v.nodeName);
    }
  }
  function ur(v, x, $) {
    var K;
    switch (x.nodeType) {
      case M:
        K = x.cloneNode(!1), K.ownerDocument = v;
      //var attrs = node2.attributes;
      //var len = attrs.length;
      //for(var i=0;i<len;i++){
      //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
      //}
      case J:
        break;
      case F:
        $ = !0;
        break;
    }
    if (K || (K = x.cloneNode(!1)), K.ownerDocument = v, K.parentNode = null, $)
      for (var se = x.firstChild; se; )
        K.appendChild(ur(v, se, $)), se = se.nextSibling;
    return K;
  }
  function Ti(v, x, $) {
    var K = new x.constructor(c);
    for (var se in x)
      if (r(x, se)) {
        var he = x[se];
        typeof he != "object" && he != K[se] && (K[se] = he);
      }
    switch (x.childNodes && (K.childNodes = new te()), K.ownerDocument = v, K.nodeType) {
      case M:
        var Fe = x.attributes, _t = K.attributes = new pe(), Nt = Fe.length;
        _t._ownerElement = K;
        for (var Yt = 0; Yt < Nt; Yt++)
          K.setAttributeNode(Ti(v, Fe.item(Yt), !0));
        break;
      case F:
        $ = !0;
    }
    if ($)
      for (var Ot = x.firstChild; Ot; )
        K.appendChild(Ti(v, Ot, $)), Ot = Ot.nextSibling;
    return K;
  }
  function Qn(v, x, $) {
    v[x] = $;
  }
  try {
    if (Object.defineProperty) {
      let v = function(x) {
        switch (x.nodeType) {
          case M:
          case J:
            var $ = [];
            for (x = x.firstChild; x; )
              x.nodeType !== 7 && x.nodeType !== 8 && $.push(v(x)), x = x.nextSibling;
            return $.join("");
          default:
            return x.nodeValue;
        }
      };
      Object.defineProperty(Q.prototype, "length", {
        get: function() {
          return ce(this), this.$$length;
        }
      }), Object.defineProperty(fe.prototype, "textContent", {
        get: function() {
          return v(this);
        },
        set: function(x) {
          switch (this.nodeType) {
            case M:
            case J:
              for (; this.firstChild; )
                this.removeChild(this.firstChild);
              (x || String(x)) && this.appendChild(this.ownerDocument.createTextNode(x));
              break;
            default:
              this.data = x, this.value = x, this.nodeValue = x;
          }
        }
      }), Qn = function(x, $, K) {
        x["$$" + $] = K;
      };
    }
  } catch {
  }
  return xt._updateLiveList = ce, xt.Attr = Mt, xt.CDATASection = cr, xt.CharacterData = Bt, xt.Comment = Bn, xt.Document = ae, xt.DocumentFragment = zn, xt.DocumentType = qn, xt.DOMImplementation = Ee, xt.Element = Qe, xt.Entity = Xt, xt.EntityReference = Un, xt.LiveNodeList = Q, xt.NamedNodeMap = pe, xt.Node = fe, xt.NodeList = te, xt.Notation = jn, xt.Text = Fn, xt.ProcessingInstruction = Nn, xt.XMLSerializer = Dr, xt;
}
var fo = {}, jd = {}, nw;
function LC() {
  return nw || (nw = 1, function(t) {
    var e = ca().freeze;
    t.XML_ENTITIES = e({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    }), t.HTML_ENTITIES = e({
      Aacute: "Ã",
      aacute: "Ã¡",
      Abreve: "Ä‚",
      abreve: "Äƒ",
      ac: "âˆ¾",
      acd: "âˆ¿",
      acE: "âˆ¾Ì³",
      Acirc: "Ã‚",
      acirc: "Ã¢",
      acute: "Â´",
      Acy: "Ð",
      acy: "Ð°",
      AElig: "Ã†",
      aelig: "Ã¦",
      af: "â¡",
      Afr: "ð”„",
      afr: "ð”ž",
      Agrave: "Ã€",
      agrave: "Ã ",
      alefsym: "â„µ",
      aleph: "â„µ",
      Alpha: "Î‘",
      alpha: "Î±",
      Amacr: "Ä€",
      amacr: "Ä",
      amalg: "â¨¿",
      AMP: "&",
      amp: "&",
      And: "â©“",
      and: "âˆ§",
      andand: "â©•",
      andd: "â©œ",
      andslope: "â©˜",
      andv: "â©š",
      ang: "âˆ ",
      ange: "â¦¤",
      angle: "âˆ ",
      angmsd: "âˆ¡",
      angmsdaa: "â¦¨",
      angmsdab: "â¦©",
      angmsdac: "â¦ª",
      angmsdad: "â¦«",
      angmsdae: "â¦¬",
      angmsdaf: "â¦­",
      angmsdag: "â¦®",
      angmsdah: "â¦¯",
      angrt: "âˆŸ",
      angrtvb: "âŠ¾",
      angrtvbd: "â¦",
      angsph: "âˆ¢",
      angst: "Ã…",
      angzarr: "â¼",
      Aogon: "Ä„",
      aogon: "Ä…",
      Aopf: "ð”¸",
      aopf: "ð•’",
      ap: "â‰ˆ",
      apacir: "â©¯",
      apE: "â©°",
      ape: "â‰Š",
      apid: "â‰‹",
      apos: "'",
      ApplyFunction: "â¡",
      approx: "â‰ˆ",
      approxeq: "â‰Š",
      Aring: "Ã…",
      aring: "Ã¥",
      Ascr: "ð’œ",
      ascr: "ð’¶",
      Assign: "â‰”",
      ast: "*",
      asymp: "â‰ˆ",
      asympeq: "â‰",
      Atilde: "Ãƒ",
      atilde: "Ã£",
      Auml: "Ã„",
      auml: "Ã¤",
      awconint: "âˆ³",
      awint: "â¨‘",
      backcong: "â‰Œ",
      backepsilon: "Ï¶",
      backprime: "â€µ",
      backsim: "âˆ½",
      backsimeq: "â‹",
      Backslash: "âˆ–",
      Barv: "â«§",
      barvee: "âŠ½",
      Barwed: "âŒ†",
      barwed: "âŒ…",
      barwedge: "âŒ…",
      bbrk: "âŽµ",
      bbrktbrk: "âŽ¶",
      bcong: "â‰Œ",
      Bcy: "Ð‘",
      bcy: "Ð±",
      bdquo: "â€ž",
      becaus: "âˆµ",
      Because: "âˆµ",
      because: "âˆµ",
      bemptyv: "â¦°",
      bepsi: "Ï¶",
      bernou: "â„¬",
      Bernoullis: "â„¬",
      Beta: "Î’",
      beta: "Î²",
      beth: "â„¶",
      between: "â‰¬",
      Bfr: "ð”…",
      bfr: "ð”Ÿ",
      bigcap: "â‹‚",
      bigcirc: "â—¯",
      bigcup: "â‹ƒ",
      bigodot: "â¨€",
      bigoplus: "â¨",
      bigotimes: "â¨‚",
      bigsqcup: "â¨†",
      bigstar: "â˜…",
      bigtriangledown: "â–½",
      bigtriangleup: "â–³",
      biguplus: "â¨„",
      bigvee: "â‹",
      bigwedge: "â‹€",
      bkarow: "â¤",
      blacklozenge: "â§«",
      blacksquare: "â–ª",
      blacktriangle: "â–´",
      blacktriangledown: "â–¾",
      blacktriangleleft: "â—‚",
      blacktriangleright: "â–¸",
      blank: "â£",
      blk12: "â–’",
      blk14: "â–‘",
      blk34: "â–“",
      block: "â–ˆ",
      bne: "=âƒ¥",
      bnequiv: "â‰¡âƒ¥",
      bNot: "â«­",
      bnot: "âŒ",
      Bopf: "ð”¹",
      bopf: "ð•“",
      bot: "âŠ¥",
      bottom: "âŠ¥",
      bowtie: "â‹ˆ",
      boxbox: "â§‰",
      boxDL: "â•—",
      boxDl: "â•–",
      boxdL: "â••",
      boxdl: "â”",
      boxDR: "â•”",
      boxDr: "â•“",
      boxdR: "â•’",
      boxdr: "â”Œ",
      boxH: "â•",
      boxh: "â”€",
      boxHD: "â•¦",
      boxHd: "â•¤",
      boxhD: "â•¥",
      boxhd: "â”¬",
      boxHU: "â•©",
      boxHu: "â•§",
      boxhU: "â•¨",
      boxhu: "â”´",
      boxminus: "âŠŸ",
      boxplus: "âŠž",
      boxtimes: "âŠ ",
      boxUL: "â•",
      boxUl: "â•œ",
      boxuL: "â•›",
      boxul: "â”˜",
      boxUR: "â•š",
      boxUr: "â•™",
      boxuR: "â•˜",
      boxur: "â””",
      boxV: "â•‘",
      boxv: "â”‚",
      boxVH: "â•¬",
      boxVh: "â•«",
      boxvH: "â•ª",
      boxvh: "â”¼",
      boxVL: "â•£",
      boxVl: "â•¢",
      boxvL: "â•¡",
      boxvl: "â”¤",
      boxVR: "â• ",
      boxVr: "â•Ÿ",
      boxvR: "â•ž",
      boxvr: "â”œ",
      bprime: "â€µ",
      Breve: "Ë˜",
      breve: "Ë˜",
      brvbar: "Â¦",
      Bscr: "â„¬",
      bscr: "ð’·",
      bsemi: "â",
      bsim: "âˆ½",
      bsime: "â‹",
      bsol: "\\",
      bsolb: "â§…",
      bsolhsub: "âŸˆ",
      bull: "â€¢",
      bullet: "â€¢",
      bump: "â‰Ž",
      bumpE: "âª®",
      bumpe: "â‰",
      Bumpeq: "â‰Ž",
      bumpeq: "â‰",
      Cacute: "Ä†",
      cacute: "Ä‡",
      Cap: "â‹’",
      cap: "âˆ©",
      capand: "â©„",
      capbrcup: "â©‰",
      capcap: "â©‹",
      capcup: "â©‡",
      capdot: "â©€",
      CapitalDifferentialD: "â……",
      caps: "âˆ©ï¸€",
      caret: "â",
      caron: "Ë‡",
      Cayleys: "â„­",
      ccaps: "â©",
      Ccaron: "ÄŒ",
      ccaron: "Ä",
      Ccedil: "Ã‡",
      ccedil: "Ã§",
      Ccirc: "Äˆ",
      ccirc: "Ä‰",
      Cconint: "âˆ°",
      ccups: "â©Œ",
      ccupssm: "â©",
      Cdot: "ÄŠ",
      cdot: "Ä‹",
      cedil: "Â¸",
      Cedilla: "Â¸",
      cemptyv: "â¦²",
      cent: "Â¢",
      CenterDot: "Â·",
      centerdot: "Â·",
      Cfr: "â„­",
      cfr: "ð” ",
      CHcy: "Ð§",
      chcy: "Ñ‡",
      check: "âœ“",
      checkmark: "âœ“",
      Chi: "Î§",
      chi: "Ï‡",
      cir: "â—‹",
      circ: "Ë†",
      circeq: "â‰—",
      circlearrowleft: "â†º",
      circlearrowright: "â†»",
      circledast: "âŠ›",
      circledcirc: "âŠš",
      circleddash: "âŠ",
      CircleDot: "âŠ™",
      circledR: "Â®",
      circledS: "â“ˆ",
      CircleMinus: "âŠ–",
      CirclePlus: "âŠ•",
      CircleTimes: "âŠ—",
      cirE: "â§ƒ",
      cire: "â‰—",
      cirfnint: "â¨",
      cirmid: "â«¯",
      cirscir: "â§‚",
      ClockwiseContourIntegral: "âˆ²",
      CloseCurlyDoubleQuote: "â€",
      CloseCurlyQuote: "â€™",
      clubs: "â™£",
      clubsuit: "â™£",
      Colon: "âˆ·",
      colon: ":",
      Colone: "â©´",
      colone: "â‰”",
      coloneq: "â‰”",
      comma: ",",
      commat: "@",
      comp: "âˆ",
      compfn: "âˆ˜",
      complement: "âˆ",
      complexes: "â„‚",
      cong: "â‰…",
      congdot: "â©­",
      Congruent: "â‰¡",
      Conint: "âˆ¯",
      conint: "âˆ®",
      ContourIntegral: "âˆ®",
      Copf: "â„‚",
      copf: "ð•”",
      coprod: "âˆ",
      Coproduct: "âˆ",
      COPY: "Â©",
      copy: "Â©",
      copysr: "â„—",
      CounterClockwiseContourIntegral: "âˆ³",
      crarr: "â†µ",
      Cross: "â¨¯",
      cross: "âœ—",
      Cscr: "ð’ž",
      cscr: "ð’¸",
      csub: "â«",
      csube: "â«‘",
      csup: "â«",
      csupe: "â«’",
      ctdot: "â‹¯",
      cudarrl: "â¤¸",
      cudarrr: "â¤µ",
      cuepr: "â‹ž",
      cuesc: "â‹Ÿ",
      cularr: "â†¶",
      cularrp: "â¤½",
      Cup: "â‹“",
      cup: "âˆª",
      cupbrcap: "â©ˆ",
      CupCap: "â‰",
      cupcap: "â©†",
      cupcup: "â©Š",
      cupdot: "âŠ",
      cupor: "â©…",
      cups: "âˆªï¸€",
      curarr: "â†·",
      curarrm: "â¤¼",
      curlyeqprec: "â‹ž",
      curlyeqsucc: "â‹Ÿ",
      curlyvee: "â‹Ž",
      curlywedge: "â‹",
      curren: "Â¤",
      curvearrowleft: "â†¶",
      curvearrowright: "â†·",
      cuvee: "â‹Ž",
      cuwed: "â‹",
      cwconint: "âˆ²",
      cwint: "âˆ±",
      cylcty: "âŒ­",
      Dagger: "â€¡",
      dagger: "â€ ",
      daleth: "â„¸",
      Darr: "â†¡",
      dArr: "â‡“",
      darr: "â†“",
      dash: "â€",
      Dashv: "â«¤",
      dashv: "âŠ£",
      dbkarow: "â¤",
      dblac: "Ë",
      Dcaron: "ÄŽ",
      dcaron: "Ä",
      Dcy: "Ð”",
      dcy: "Ð´",
      DD: "â……",
      dd: "â…†",
      ddagger: "â€¡",
      ddarr: "â‡Š",
      DDotrahd: "â¤‘",
      ddotseq: "â©·",
      deg: "Â°",
      Del: "âˆ‡",
      Delta: "Î”",
      delta: "Î´",
      demptyv: "â¦±",
      dfisht: "â¥¿",
      Dfr: "ð”‡",
      dfr: "ð”¡",
      dHar: "â¥¥",
      dharl: "â‡ƒ",
      dharr: "â‡‚",
      DiacriticalAcute: "Â´",
      DiacriticalDot: "Ë™",
      DiacriticalDoubleAcute: "Ë",
      DiacriticalGrave: "`",
      DiacriticalTilde: "Ëœ",
      diam: "â‹„",
      Diamond: "â‹„",
      diamond: "â‹„",
      diamondsuit: "â™¦",
      diams: "â™¦",
      die: "Â¨",
      DifferentialD: "â…†",
      digamma: "Ï",
      disin: "â‹²",
      div: "Ã·",
      divide: "Ã·",
      divideontimes: "â‹‡",
      divonx: "â‹‡",
      DJcy: "Ð‚",
      djcy: "Ñ’",
      dlcorn: "âŒž",
      dlcrop: "âŒ",
      dollar: "$",
      Dopf: "ð”»",
      dopf: "ð••",
      Dot: "Â¨",
      dot: "Ë™",
      DotDot: "âƒœ",
      doteq: "â‰",
      doteqdot: "â‰‘",
      DotEqual: "â‰",
      dotminus: "âˆ¸",
      dotplus: "âˆ”",
      dotsquare: "âŠ¡",
      doublebarwedge: "âŒ†",
      DoubleContourIntegral: "âˆ¯",
      DoubleDot: "Â¨",
      DoubleDownArrow: "â‡“",
      DoubleLeftArrow: "â‡",
      DoubleLeftRightArrow: "â‡”",
      DoubleLeftTee: "â«¤",
      DoubleLongLeftArrow: "âŸ¸",
      DoubleLongLeftRightArrow: "âŸº",
      DoubleLongRightArrow: "âŸ¹",
      DoubleRightArrow: "â‡’",
      DoubleRightTee: "âŠ¨",
      DoubleUpArrow: "â‡‘",
      DoubleUpDownArrow: "â‡•",
      DoubleVerticalBar: "âˆ¥",
      DownArrow: "â†“",
      Downarrow: "â‡“",
      downarrow: "â†“",
      DownArrowBar: "â¤“",
      DownArrowUpArrow: "â‡µ",
      DownBreve: "Ì‘",
      downdownarrows: "â‡Š",
      downharpoonleft: "â‡ƒ",
      downharpoonright: "â‡‚",
      DownLeftRightVector: "â¥",
      DownLeftTeeVector: "â¥ž",
      DownLeftVector: "â†½",
      DownLeftVectorBar: "â¥–",
      DownRightTeeVector: "â¥Ÿ",
      DownRightVector: "â‡",
      DownRightVectorBar: "â¥—",
      DownTee: "âŠ¤",
      DownTeeArrow: "â†§",
      drbkarow: "â¤",
      drcorn: "âŒŸ",
      drcrop: "âŒŒ",
      Dscr: "ð’Ÿ",
      dscr: "ð’¹",
      DScy: "Ð…",
      dscy: "Ñ•",
      dsol: "â§¶",
      Dstrok: "Ä",
      dstrok: "Ä‘",
      dtdot: "â‹±",
      dtri: "â–¿",
      dtrif: "â–¾",
      duarr: "â‡µ",
      duhar: "â¥¯",
      dwangle: "â¦¦",
      DZcy: "Ð",
      dzcy: "ÑŸ",
      dzigrarr: "âŸ¿",
      Eacute: "Ã‰",
      eacute: "Ã©",
      easter: "â©®",
      Ecaron: "Äš",
      ecaron: "Ä›",
      ecir: "â‰–",
      Ecirc: "ÃŠ",
      ecirc: "Ãª",
      ecolon: "â‰•",
      Ecy: "Ð­",
      ecy: "Ñ",
      eDDot: "â©·",
      Edot: "Ä–",
      eDot: "â‰‘",
      edot: "Ä—",
      ee: "â…‡",
      efDot: "â‰’",
      Efr: "ð”ˆ",
      efr: "ð”¢",
      eg: "âªš",
      Egrave: "Ãˆ",
      egrave: "Ã¨",
      egs: "âª–",
      egsdot: "âª˜",
      el: "âª™",
      Element: "âˆˆ",
      elinters: "â§",
      ell: "â„“",
      els: "âª•",
      elsdot: "âª—",
      Emacr: "Ä’",
      emacr: "Ä“",
      empty: "âˆ…",
      emptyset: "âˆ…",
      EmptySmallSquare: "â—»",
      emptyv: "âˆ…",
      EmptyVerySmallSquare: "â–«",
      emsp: "â€ƒ",
      emsp13: "â€„",
      emsp14: "â€…",
      ENG: "ÅŠ",
      eng: "Å‹",
      ensp: "â€‚",
      Eogon: "Ä˜",
      eogon: "Ä™",
      Eopf: "ð”¼",
      eopf: "ð•–",
      epar: "â‹•",
      eparsl: "â§£",
      eplus: "â©±",
      epsi: "Îµ",
      Epsilon: "Î•",
      epsilon: "Îµ",
      epsiv: "Ïµ",
      eqcirc: "â‰–",
      eqcolon: "â‰•",
      eqsim: "â‰‚",
      eqslantgtr: "âª–",
      eqslantless: "âª•",
      Equal: "â©µ",
      equals: "=",
      EqualTilde: "â‰‚",
      equest: "â‰Ÿ",
      Equilibrium: "â‡Œ",
      equiv: "â‰¡",
      equivDD: "â©¸",
      eqvparsl: "â§¥",
      erarr: "â¥±",
      erDot: "â‰“",
      Escr: "â„°",
      escr: "â„¯",
      esdot: "â‰",
      Esim: "â©³",
      esim: "â‰‚",
      Eta: "Î—",
      eta: "Î·",
      ETH: "Ã",
      eth: "Ã°",
      Euml: "Ã‹",
      euml: "Ã«",
      euro: "â‚¬",
      excl: "!",
      exist: "âˆƒ",
      Exists: "âˆƒ",
      expectation: "â„°",
      ExponentialE: "â…‡",
      exponentiale: "â…‡",
      fallingdotseq: "â‰’",
      Fcy: "Ð¤",
      fcy: "Ñ„",
      female: "â™€",
      ffilig: "ï¬ƒ",
      fflig: "ï¬€",
      ffllig: "ï¬„",
      Ffr: "ð”‰",
      ffr: "ð”£",
      filig: "ï¬",
      FilledSmallSquare: "â—¼",
      FilledVerySmallSquare: "â–ª",
      fjlig: "fj",
      flat: "â™­",
      fllig: "ï¬‚",
      fltns: "â–±",
      fnof: "Æ’",
      Fopf: "ð”½",
      fopf: "ð•—",
      ForAll: "âˆ€",
      forall: "âˆ€",
      fork: "â‹”",
      forkv: "â«™",
      Fouriertrf: "â„±",
      fpartint: "â¨",
      frac12: "Â½",
      frac13: "â…“",
      frac14: "Â¼",
      frac15: "â…•",
      frac16: "â…™",
      frac18: "â…›",
      frac23: "â…”",
      frac25: "â…–",
      frac34: "Â¾",
      frac35: "â…—",
      frac38: "â…œ",
      frac45: "â…˜",
      frac56: "â…š",
      frac58: "â…",
      frac78: "â…ž",
      frasl: "â„",
      frown: "âŒ¢",
      Fscr: "â„±",
      fscr: "ð’»",
      gacute: "Çµ",
      Gamma: "Î“",
      gamma: "Î³",
      Gammad: "Ïœ",
      gammad: "Ï",
      gap: "âª†",
      Gbreve: "Äž",
      gbreve: "ÄŸ",
      Gcedil: "Ä¢",
      Gcirc: "Äœ",
      gcirc: "Ä",
      Gcy: "Ð“",
      gcy: "Ð³",
      Gdot: "Ä ",
      gdot: "Ä¡",
      gE: "â‰§",
      ge: "â‰¥",
      gEl: "âªŒ",
      gel: "â‹›",
      geq: "â‰¥",
      geqq: "â‰§",
      geqslant: "â©¾",
      ges: "â©¾",
      gescc: "âª©",
      gesdot: "âª€",
      gesdoto: "âª‚",
      gesdotol: "âª„",
      gesl: "â‹›ï¸€",
      gesles: "âª”",
      Gfr: "ð”Š",
      gfr: "ð”¤",
      Gg: "â‹™",
      gg: "â‰«",
      ggg: "â‹™",
      gimel: "â„·",
      GJcy: "Ðƒ",
      gjcy: "Ñ“",
      gl: "â‰·",
      gla: "âª¥",
      glE: "âª’",
      glj: "âª¤",
      gnap: "âªŠ",
      gnapprox: "âªŠ",
      gnE: "â‰©",
      gne: "âªˆ",
      gneq: "âªˆ",
      gneqq: "â‰©",
      gnsim: "â‹§",
      Gopf: "ð”¾",
      gopf: "ð•˜",
      grave: "`",
      GreaterEqual: "â‰¥",
      GreaterEqualLess: "â‹›",
      GreaterFullEqual: "â‰§",
      GreaterGreater: "âª¢",
      GreaterLess: "â‰·",
      GreaterSlantEqual: "â©¾",
      GreaterTilde: "â‰³",
      Gscr: "ð’¢",
      gscr: "â„Š",
      gsim: "â‰³",
      gsime: "âªŽ",
      gsiml: "âª",
      Gt: "â‰«",
      GT: ">",
      gt: ">",
      gtcc: "âª§",
      gtcir: "â©º",
      gtdot: "â‹—",
      gtlPar: "â¦•",
      gtquest: "â©¼",
      gtrapprox: "âª†",
      gtrarr: "â¥¸",
      gtrdot: "â‹—",
      gtreqless: "â‹›",
      gtreqqless: "âªŒ",
      gtrless: "â‰·",
      gtrsim: "â‰³",
      gvertneqq: "â‰©ï¸€",
      gvnE: "â‰©ï¸€",
      Hacek: "Ë‡",
      hairsp: "â€Š",
      half: "Â½",
      hamilt: "â„‹",
      HARDcy: "Ðª",
      hardcy: "ÑŠ",
      hArr: "â‡”",
      harr: "â†”",
      harrcir: "â¥ˆ",
      harrw: "â†­",
      Hat: "^",
      hbar: "â„",
      Hcirc: "Ä¤",
      hcirc: "Ä¥",
      hearts: "â™¥",
      heartsuit: "â™¥",
      hellip: "â€¦",
      hercon: "âŠ¹",
      Hfr: "â„Œ",
      hfr: "ð”¥",
      HilbertSpace: "â„‹",
      hksearow: "â¤¥",
      hkswarow: "â¤¦",
      hoarr: "â‡¿",
      homtht: "âˆ»",
      hookleftarrow: "â†©",
      hookrightarrow: "â†ª",
      Hopf: "â„",
      hopf: "ð•™",
      horbar: "â€•",
      HorizontalLine: "â”€",
      Hscr: "â„‹",
      hscr: "ð’½",
      hslash: "â„",
      Hstrok: "Ä¦",
      hstrok: "Ä§",
      HumpDownHump: "â‰Ž",
      HumpEqual: "â‰",
      hybull: "âƒ",
      hyphen: "â€",
      Iacute: "Ã",
      iacute: "Ã­",
      ic: "â£",
      Icirc: "ÃŽ",
      icirc: "Ã®",
      Icy: "Ð˜",
      icy: "Ð¸",
      Idot: "Ä°",
      IEcy: "Ð•",
      iecy: "Ðµ",
      iexcl: "Â¡",
      iff: "â‡”",
      Ifr: "â„‘",
      ifr: "ð”¦",
      Igrave: "ÃŒ",
      igrave: "Ã¬",
      ii: "â…ˆ",
      iiiint: "â¨Œ",
      iiint: "âˆ­",
      iinfin: "â§œ",
      iiota: "â„©",
      IJlig: "Ä²",
      ijlig: "Ä³",
      Im: "â„‘",
      Imacr: "Äª",
      imacr: "Ä«",
      image: "â„‘",
      ImaginaryI: "â…ˆ",
      imagline: "â„",
      imagpart: "â„‘",
      imath: "Ä±",
      imof: "âŠ·",
      imped: "Æµ",
      Implies: "â‡’",
      in: "âˆˆ",
      incare: "â„…",
      infin: "âˆž",
      infintie: "â§",
      inodot: "Ä±",
      Int: "âˆ¬",
      int: "âˆ«",
      intcal: "âŠº",
      integers: "â„¤",
      Integral: "âˆ«",
      intercal: "âŠº",
      Intersection: "â‹‚",
      intlarhk: "â¨—",
      intprod: "â¨¼",
      InvisibleComma: "â£",
      InvisibleTimes: "â¢",
      IOcy: "Ð",
      iocy: "Ñ‘",
      Iogon: "Ä®",
      iogon: "Ä¯",
      Iopf: "ð•€",
      iopf: "ð•š",
      Iota: "Î™",
      iota: "Î¹",
      iprod: "â¨¼",
      iquest: "Â¿",
      Iscr: "â„",
      iscr: "ð’¾",
      isin: "âˆˆ",
      isindot: "â‹µ",
      isinE: "â‹¹",
      isins: "â‹´",
      isinsv: "â‹³",
      isinv: "âˆˆ",
      it: "â¢",
      Itilde: "Ä¨",
      itilde: "Ä©",
      Iukcy: "Ð†",
      iukcy: "Ñ–",
      Iuml: "Ã",
      iuml: "Ã¯",
      Jcirc: "Ä´",
      jcirc: "Äµ",
      Jcy: "Ð™",
      jcy: "Ð¹",
      Jfr: "ð”",
      jfr: "ð”§",
      jmath: "È·",
      Jopf: "ð•",
      jopf: "ð•›",
      Jscr: "ð’¥",
      jscr: "ð’¿",
      Jsercy: "Ðˆ",
      jsercy: "Ñ˜",
      Jukcy: "Ð„",
      jukcy: "Ñ”",
      Kappa: "Îš",
      kappa: "Îº",
      kappav: "Ï°",
      Kcedil: "Ä¶",
      kcedil: "Ä·",
      Kcy: "Ðš",
      kcy: "Ðº",
      Kfr: "ð”Ž",
      kfr: "ð”¨",
      kgreen: "Ä¸",
      KHcy: "Ð¥",
      khcy: "Ñ…",
      KJcy: "ÐŒ",
      kjcy: "Ñœ",
      Kopf: "ð•‚",
      kopf: "ð•œ",
      Kscr: "ð’¦",
      kscr: "ð“€",
      lAarr: "â‡š",
      Lacute: "Ä¹",
      lacute: "Äº",
      laemptyv: "â¦´",
      lagran: "â„’",
      Lambda: "Î›",
      lambda: "Î»",
      Lang: "âŸª",
      lang: "âŸ¨",
      langd: "â¦‘",
      langle: "âŸ¨",
      lap: "âª…",
      Laplacetrf: "â„’",
      laquo: "Â«",
      Larr: "â†ž",
      lArr: "â‡",
      larr: "â†",
      larrb: "â‡¤",
      larrbfs: "â¤Ÿ",
      larrfs: "â¤",
      larrhk: "â†©",
      larrlp: "â†«",
      larrpl: "â¤¹",
      larrsim: "â¥³",
      larrtl: "â†¢",
      lat: "âª«",
      lAtail: "â¤›",
      latail: "â¤™",
      late: "âª­",
      lates: "âª­ï¸€",
      lBarr: "â¤Ž",
      lbarr: "â¤Œ",
      lbbrk: "â²",
      lbrace: "{",
      lbrack: "[",
      lbrke: "â¦‹",
      lbrksld: "â¦",
      lbrkslu: "â¦",
      Lcaron: "Ä½",
      lcaron: "Ä¾",
      Lcedil: "Ä»",
      lcedil: "Ä¼",
      lceil: "âŒˆ",
      lcub: "{",
      Lcy: "Ð›",
      lcy: "Ð»",
      ldca: "â¤¶",
      ldquo: "â€œ",
      ldquor: "â€ž",
      ldrdhar: "â¥§",
      ldrushar: "â¥‹",
      ldsh: "â†²",
      lE: "â‰¦",
      le: "â‰¤",
      LeftAngleBracket: "âŸ¨",
      LeftArrow: "â†",
      Leftarrow: "â‡",
      leftarrow: "â†",
      LeftArrowBar: "â‡¤",
      LeftArrowRightArrow: "â‡†",
      leftarrowtail: "â†¢",
      LeftCeiling: "âŒˆ",
      LeftDoubleBracket: "âŸ¦",
      LeftDownTeeVector: "â¥¡",
      LeftDownVector: "â‡ƒ",
      LeftDownVectorBar: "â¥™",
      LeftFloor: "âŒŠ",
      leftharpoondown: "â†½",
      leftharpoonup: "â†¼",
      leftleftarrows: "â‡‡",
      LeftRightArrow: "â†”",
      Leftrightarrow: "â‡”",
      leftrightarrow: "â†”",
      leftrightarrows: "â‡†",
      leftrightharpoons: "â‡‹",
      leftrightsquigarrow: "â†­",
      LeftRightVector: "â¥Ž",
      LeftTee: "âŠ£",
      LeftTeeArrow: "â†¤",
      LeftTeeVector: "â¥š",
      leftthreetimes: "â‹‹",
      LeftTriangle: "âŠ²",
      LeftTriangleBar: "â§",
      LeftTriangleEqual: "âŠ´",
      LeftUpDownVector: "â¥‘",
      LeftUpTeeVector: "â¥ ",
      LeftUpVector: "â†¿",
      LeftUpVectorBar: "â¥˜",
      LeftVector: "â†¼",
      LeftVectorBar: "â¥’",
      lEg: "âª‹",
      leg: "â‹š",
      leq: "â‰¤",
      leqq: "â‰¦",
      leqslant: "â©½",
      les: "â©½",
      lescc: "âª¨",
      lesdot: "â©¿",
      lesdoto: "âª",
      lesdotor: "âªƒ",
      lesg: "â‹šï¸€",
      lesges: "âª“",
      lessapprox: "âª…",
      lessdot: "â‹–",
      lesseqgtr: "â‹š",
      lesseqqgtr: "âª‹",
      LessEqualGreater: "â‹š",
      LessFullEqual: "â‰¦",
      LessGreater: "â‰¶",
      lessgtr: "â‰¶",
      LessLess: "âª¡",
      lesssim: "â‰²",
      LessSlantEqual: "â©½",
      LessTilde: "â‰²",
      lfisht: "â¥¼",
      lfloor: "âŒŠ",
      Lfr: "ð”",
      lfr: "ð”©",
      lg: "â‰¶",
      lgE: "âª‘",
      lHar: "â¥¢",
      lhard: "â†½",
      lharu: "â†¼",
      lharul: "â¥ª",
      lhblk: "â–„",
      LJcy: "Ð‰",
      ljcy: "Ñ™",
      Ll: "â‹˜",
      ll: "â‰ª",
      llarr: "â‡‡",
      llcorner: "âŒž",
      Lleftarrow: "â‡š",
      llhard: "â¥«",
      lltri: "â—º",
      Lmidot: "Ä¿",
      lmidot: "Å€",
      lmoust: "âŽ°",
      lmoustache: "âŽ°",
      lnap: "âª‰",
      lnapprox: "âª‰",
      lnE: "â‰¨",
      lne: "âª‡",
      lneq: "âª‡",
      lneqq: "â‰¨",
      lnsim: "â‹¦",
      loang: "âŸ¬",
      loarr: "â‡½",
      lobrk: "âŸ¦",
      LongLeftArrow: "âŸµ",
      Longleftarrow: "âŸ¸",
      longleftarrow: "âŸµ",
      LongLeftRightArrow: "âŸ·",
      Longleftrightarrow: "âŸº",
      longleftrightarrow: "âŸ·",
      longmapsto: "âŸ¼",
      LongRightArrow: "âŸ¶",
      Longrightarrow: "âŸ¹",
      longrightarrow: "âŸ¶",
      looparrowleft: "â†«",
      looparrowright: "â†¬",
      lopar: "â¦…",
      Lopf: "ð•ƒ",
      lopf: "ð•",
      loplus: "â¨­",
      lotimes: "â¨´",
      lowast: "âˆ—",
      lowbar: "_",
      LowerLeftArrow: "â†™",
      LowerRightArrow: "â†˜",
      loz: "â—Š",
      lozenge: "â—Š",
      lozf: "â§«",
      lpar: "(",
      lparlt: "â¦“",
      lrarr: "â‡†",
      lrcorner: "âŒŸ",
      lrhar: "â‡‹",
      lrhard: "â¥­",
      lrm: "â€Ž",
      lrtri: "âŠ¿",
      lsaquo: "â€¹",
      Lscr: "â„’",
      lscr: "ð“",
      Lsh: "â†°",
      lsh: "â†°",
      lsim: "â‰²",
      lsime: "âª",
      lsimg: "âª",
      lsqb: "[",
      lsquo: "â€˜",
      lsquor: "â€š",
      Lstrok: "Å",
      lstrok: "Å‚",
      Lt: "â‰ª",
      LT: "<",
      lt: "<",
      ltcc: "âª¦",
      ltcir: "â©¹",
      ltdot: "â‹–",
      lthree: "â‹‹",
      ltimes: "â‹‰",
      ltlarr: "â¥¶",
      ltquest: "â©»",
      ltri: "â—ƒ",
      ltrie: "âŠ´",
      ltrif: "â—‚",
      ltrPar: "â¦–",
      lurdshar: "â¥Š",
      luruhar: "â¥¦",
      lvertneqq: "â‰¨ï¸€",
      lvnE: "â‰¨ï¸€",
      macr: "Â¯",
      male: "â™‚",
      malt: "âœ ",
      maltese: "âœ ",
      Map: "â¤…",
      map: "â†¦",
      mapsto: "â†¦",
      mapstodown: "â†§",
      mapstoleft: "â†¤",
      mapstoup: "â†¥",
      marker: "â–®",
      mcomma: "â¨©",
      Mcy: "Ðœ",
      mcy: "Ð¼",
      mdash: "â€”",
      mDDot: "âˆº",
      measuredangle: "âˆ¡",
      MediumSpace: "âŸ",
      Mellintrf: "â„³",
      Mfr: "ð”",
      mfr: "ð”ª",
      mho: "â„§",
      micro: "Âµ",
      mid: "âˆ£",
      midast: "*",
      midcir: "â«°",
      middot: "Â·",
      minus: "âˆ’",
      minusb: "âŠŸ",
      minusd: "âˆ¸",
      minusdu: "â¨ª",
      MinusPlus: "âˆ“",
      mlcp: "â«›",
      mldr: "â€¦",
      mnplus: "âˆ“",
      models: "âŠ§",
      Mopf: "ð•„",
      mopf: "ð•ž",
      mp: "âˆ“",
      Mscr: "â„³",
      mscr: "ð“‚",
      mstpos: "âˆ¾",
      Mu: "Îœ",
      mu: "Î¼",
      multimap: "âŠ¸",
      mumap: "âŠ¸",
      nabla: "âˆ‡",
      Nacute: "Åƒ",
      nacute: "Å„",
      nang: "âˆ âƒ’",
      nap: "â‰‰",
      napE: "â©°Ì¸",
      napid: "â‰‹Ì¸",
      napos: "Å‰",
      napprox: "â‰‰",
      natur: "â™®",
      natural: "â™®",
      naturals: "â„•",
      nbsp: "Â ",
      nbump: "â‰ŽÌ¸",
      nbumpe: "â‰Ì¸",
      ncap: "â©ƒ",
      Ncaron: "Å‡",
      ncaron: "Åˆ",
      Ncedil: "Å…",
      ncedil: "Å†",
      ncong: "â‰‡",
      ncongdot: "â©­Ì¸",
      ncup: "â©‚",
      Ncy: "Ð",
      ncy: "Ð½",
      ndash: "â€“",
      ne: "â‰ ",
      nearhk: "â¤¤",
      neArr: "â‡—",
      nearr: "â†—",
      nearrow: "â†—",
      nedot: "â‰Ì¸",
      NegativeMediumSpace: "â€‹",
      NegativeThickSpace: "â€‹",
      NegativeThinSpace: "â€‹",
      NegativeVeryThinSpace: "â€‹",
      nequiv: "â‰¢",
      nesear: "â¤¨",
      nesim: "â‰‚Ì¸",
      NestedGreaterGreater: "â‰«",
      NestedLessLess: "â‰ª",
      NewLine: `
`,
      nexist: "âˆ„",
      nexists: "âˆ„",
      Nfr: "ð”‘",
      nfr: "ð”«",
      ngE: "â‰§Ì¸",
      nge: "â‰±",
      ngeq: "â‰±",
      ngeqq: "â‰§Ì¸",
      ngeqslant: "â©¾Ì¸",
      nges: "â©¾Ì¸",
      nGg: "â‹™Ì¸",
      ngsim: "â‰µ",
      nGt: "â‰«âƒ’",
      ngt: "â‰¯",
      ngtr: "â‰¯",
      nGtv: "â‰«Ì¸",
      nhArr: "â‡Ž",
      nharr: "â†®",
      nhpar: "â«²",
      ni: "âˆ‹",
      nis: "â‹¼",
      nisd: "â‹º",
      niv: "âˆ‹",
      NJcy: "ÐŠ",
      njcy: "Ñš",
      nlArr: "â‡",
      nlarr: "â†š",
      nldr: "â€¥",
      nlE: "â‰¦Ì¸",
      nle: "â‰°",
      nLeftarrow: "â‡",
      nleftarrow: "â†š",
      nLeftrightarrow: "â‡Ž",
      nleftrightarrow: "â†®",
      nleq: "â‰°",
      nleqq: "â‰¦Ì¸",
      nleqslant: "â©½Ì¸",
      nles: "â©½Ì¸",
      nless: "â‰®",
      nLl: "â‹˜Ì¸",
      nlsim: "â‰´",
      nLt: "â‰ªâƒ’",
      nlt: "â‰®",
      nltri: "â‹ª",
      nltrie: "â‹¬",
      nLtv: "â‰ªÌ¸",
      nmid: "âˆ¤",
      NoBreak: "â ",
      NonBreakingSpace: "Â ",
      Nopf: "â„•",
      nopf: "ð•Ÿ",
      Not: "â«¬",
      not: "Â¬",
      NotCongruent: "â‰¢",
      NotCupCap: "â‰­",
      NotDoubleVerticalBar: "âˆ¦",
      NotElement: "âˆ‰",
      NotEqual: "â‰ ",
      NotEqualTilde: "â‰‚Ì¸",
      NotExists: "âˆ„",
      NotGreater: "â‰¯",
      NotGreaterEqual: "â‰±",
      NotGreaterFullEqual: "â‰§Ì¸",
      NotGreaterGreater: "â‰«Ì¸",
      NotGreaterLess: "â‰¹",
      NotGreaterSlantEqual: "â©¾Ì¸",
      NotGreaterTilde: "â‰µ",
      NotHumpDownHump: "â‰ŽÌ¸",
      NotHumpEqual: "â‰Ì¸",
      notin: "âˆ‰",
      notindot: "â‹µÌ¸",
      notinE: "â‹¹Ì¸",
      notinva: "âˆ‰",
      notinvb: "â‹·",
      notinvc: "â‹¶",
      NotLeftTriangle: "â‹ª",
      NotLeftTriangleBar: "â§Ì¸",
      NotLeftTriangleEqual: "â‹¬",
      NotLess: "â‰®",
      NotLessEqual: "â‰°",
      NotLessGreater: "â‰¸",
      NotLessLess: "â‰ªÌ¸",
      NotLessSlantEqual: "â©½Ì¸",
      NotLessTilde: "â‰´",
      NotNestedGreaterGreater: "âª¢Ì¸",
      NotNestedLessLess: "âª¡Ì¸",
      notni: "âˆŒ",
      notniva: "âˆŒ",
      notnivb: "â‹¾",
      notnivc: "â‹½",
      NotPrecedes: "âŠ€",
      NotPrecedesEqual: "âª¯Ì¸",
      NotPrecedesSlantEqual: "â‹ ",
      NotReverseElement: "âˆŒ",
      NotRightTriangle: "â‹«",
      NotRightTriangleBar: "â§Ì¸",
      NotRightTriangleEqual: "â‹­",
      NotSquareSubset: "âŠÌ¸",
      NotSquareSubsetEqual: "â‹¢",
      NotSquareSuperset: "âŠÌ¸",
      NotSquareSupersetEqual: "â‹£",
      NotSubset: "âŠ‚âƒ’",
      NotSubsetEqual: "âŠˆ",
      NotSucceeds: "âŠ",
      NotSucceedsEqual: "âª°Ì¸",
      NotSucceedsSlantEqual: "â‹¡",
      NotSucceedsTilde: "â‰¿Ì¸",
      NotSuperset: "âŠƒâƒ’",
      NotSupersetEqual: "âŠ‰",
      NotTilde: "â‰",
      NotTildeEqual: "â‰„",
      NotTildeFullEqual: "â‰‡",
      NotTildeTilde: "â‰‰",
      NotVerticalBar: "âˆ¤",
      npar: "âˆ¦",
      nparallel: "âˆ¦",
      nparsl: "â«½âƒ¥",
      npart: "âˆ‚Ì¸",
      npolint: "â¨”",
      npr: "âŠ€",
      nprcue: "â‹ ",
      npre: "âª¯Ì¸",
      nprec: "âŠ€",
      npreceq: "âª¯Ì¸",
      nrArr: "â‡",
      nrarr: "â†›",
      nrarrc: "â¤³Ì¸",
      nrarrw: "â†Ì¸",
      nRightarrow: "â‡",
      nrightarrow: "â†›",
      nrtri: "â‹«",
      nrtrie: "â‹­",
      nsc: "âŠ",
      nsccue: "â‹¡",
      nsce: "âª°Ì¸",
      Nscr: "ð’©",
      nscr: "ð“ƒ",
      nshortmid: "âˆ¤",
      nshortparallel: "âˆ¦",
      nsim: "â‰",
      nsime: "â‰„",
      nsimeq: "â‰„",
      nsmid: "âˆ¤",
      nspar: "âˆ¦",
      nsqsube: "â‹¢",
      nsqsupe: "â‹£",
      nsub: "âŠ„",
      nsubE: "â«…Ì¸",
      nsube: "âŠˆ",
      nsubset: "âŠ‚âƒ’",
      nsubseteq: "âŠˆ",
      nsubseteqq: "â«…Ì¸",
      nsucc: "âŠ",
      nsucceq: "âª°Ì¸",
      nsup: "âŠ…",
      nsupE: "â«†Ì¸",
      nsupe: "âŠ‰",
      nsupset: "âŠƒâƒ’",
      nsupseteq: "âŠ‰",
      nsupseteqq: "â«†Ì¸",
      ntgl: "â‰¹",
      Ntilde: "Ã‘",
      ntilde: "Ã±",
      ntlg: "â‰¸",
      ntriangleleft: "â‹ª",
      ntrianglelefteq: "â‹¬",
      ntriangleright: "â‹«",
      ntrianglerighteq: "â‹­",
      Nu: "Î",
      nu: "Î½",
      num: "#",
      numero: "â„–",
      numsp: "â€‡",
      nvap: "â‰âƒ’",
      nVDash: "âŠ¯",
      nVdash: "âŠ®",
      nvDash: "âŠ­",
      nvdash: "âŠ¬",
      nvge: "â‰¥âƒ’",
      nvgt: ">âƒ’",
      nvHarr: "â¤„",
      nvinfin: "â§ž",
      nvlArr: "â¤‚",
      nvle: "â‰¤âƒ’",
      nvlt: "<âƒ’",
      nvltrie: "âŠ´âƒ’",
      nvrArr: "â¤ƒ",
      nvrtrie: "âŠµâƒ’",
      nvsim: "âˆ¼âƒ’",
      nwarhk: "â¤£",
      nwArr: "â‡–",
      nwarr: "â†–",
      nwarrow: "â†–",
      nwnear: "â¤§",
      Oacute: "Ã“",
      oacute: "Ã³",
      oast: "âŠ›",
      ocir: "âŠš",
      Ocirc: "Ã”",
      ocirc: "Ã´",
      Ocy: "Ðž",
      ocy: "Ð¾",
      odash: "âŠ",
      Odblac: "Å",
      odblac: "Å‘",
      odiv: "â¨¸",
      odot: "âŠ™",
      odsold: "â¦¼",
      OElig: "Å’",
      oelig: "Å“",
      ofcir: "â¦¿",
      Ofr: "ð”’",
      ofr: "ð”¬",
      ogon: "Ë›",
      Ograve: "Ã’",
      ograve: "Ã²",
      ogt: "â§",
      ohbar: "â¦µ",
      ohm: "Î©",
      oint: "âˆ®",
      olarr: "â†º",
      olcir: "â¦¾",
      olcross: "â¦»",
      oline: "â€¾",
      olt: "â§€",
      Omacr: "ÅŒ",
      omacr: "Å",
      Omega: "Î©",
      omega: "Ï‰",
      Omicron: "ÎŸ",
      omicron: "Î¿",
      omid: "â¦¶",
      ominus: "âŠ–",
      Oopf: "ð•†",
      oopf: "ð• ",
      opar: "â¦·",
      OpenCurlyDoubleQuote: "â€œ",
      OpenCurlyQuote: "â€˜",
      operp: "â¦¹",
      oplus: "âŠ•",
      Or: "â©”",
      or: "âˆ¨",
      orarr: "â†»",
      ord: "â©",
      order: "â„´",
      orderof: "â„´",
      ordf: "Âª",
      ordm: "Âº",
      origof: "âŠ¶",
      oror: "â©–",
      orslope: "â©—",
      orv: "â©›",
      oS: "â“ˆ",
      Oscr: "ð’ª",
      oscr: "â„´",
      Oslash: "Ã˜",
      oslash: "Ã¸",
      osol: "âŠ˜",
      Otilde: "Ã•",
      otilde: "Ãµ",
      Otimes: "â¨·",
      otimes: "âŠ—",
      otimesas: "â¨¶",
      Ouml: "Ã–",
      ouml: "Ã¶",
      ovbar: "âŒ½",
      OverBar: "â€¾",
      OverBrace: "âž",
      OverBracket: "âŽ´",
      OverParenthesis: "âœ",
      par: "âˆ¥",
      para: "Â¶",
      parallel: "âˆ¥",
      parsim: "â«³",
      parsl: "â«½",
      part: "âˆ‚",
      PartialD: "âˆ‚",
      Pcy: "ÐŸ",
      pcy: "Ð¿",
      percnt: "%",
      period: ".",
      permil: "â€°",
      perp: "âŠ¥",
      pertenk: "â€±",
      Pfr: "ð”“",
      pfr: "ð”­",
      Phi: "Î¦",
      phi: "Ï†",
      phiv: "Ï•",
      phmmat: "â„³",
      phone: "â˜Ž",
      Pi: "Î ",
      pi: "Ï€",
      pitchfork: "â‹”",
      piv: "Ï–",
      planck: "â„",
      planckh: "â„Ž",
      plankv: "â„",
      plus: "+",
      plusacir: "â¨£",
      plusb: "âŠž",
      pluscir: "â¨¢",
      plusdo: "âˆ”",
      plusdu: "â¨¥",
      pluse: "â©²",
      PlusMinus: "Â±",
      plusmn: "Â±",
      plussim: "â¨¦",
      plustwo: "â¨§",
      pm: "Â±",
      Poincareplane: "â„Œ",
      pointint: "â¨•",
      Popf: "â„™",
      popf: "ð•¡",
      pound: "Â£",
      Pr: "âª»",
      pr: "â‰º",
      prap: "âª·",
      prcue: "â‰¼",
      prE: "âª³",
      pre: "âª¯",
      prec: "â‰º",
      precapprox: "âª·",
      preccurlyeq: "â‰¼",
      Precedes: "â‰º",
      PrecedesEqual: "âª¯",
      PrecedesSlantEqual: "â‰¼",
      PrecedesTilde: "â‰¾",
      preceq: "âª¯",
      precnapprox: "âª¹",
      precneqq: "âªµ",
      precnsim: "â‹¨",
      precsim: "â‰¾",
      Prime: "â€³",
      prime: "â€²",
      primes: "â„™",
      prnap: "âª¹",
      prnE: "âªµ",
      prnsim: "â‹¨",
      prod: "âˆ",
      Product: "âˆ",
      profalar: "âŒ®",
      profline: "âŒ’",
      profsurf: "âŒ“",
      prop: "âˆ",
      Proportion: "âˆ·",
      Proportional: "âˆ",
      propto: "âˆ",
      prsim: "â‰¾",
      prurel: "âŠ°",
      Pscr: "ð’«",
      pscr: "ð“…",
      Psi: "Î¨",
      psi: "Ïˆ",
      puncsp: "â€ˆ",
      Qfr: "ð””",
      qfr: "ð”®",
      qint: "â¨Œ",
      Qopf: "â„š",
      qopf: "ð•¢",
      qprime: "â—",
      Qscr: "ð’¬",
      qscr: "ð“†",
      quaternions: "â„",
      quatint: "â¨–",
      quest: "?",
      questeq: "â‰Ÿ",
      QUOT: '"',
      quot: '"',
      rAarr: "â‡›",
      race: "âˆ½Ì±",
      Racute: "Å”",
      racute: "Å•",
      radic: "âˆš",
      raemptyv: "â¦³",
      Rang: "âŸ«",
      rang: "âŸ©",
      rangd: "â¦’",
      range: "â¦¥",
      rangle: "âŸ©",
      raquo: "Â»",
      Rarr: "â† ",
      rArr: "â‡’",
      rarr: "â†’",
      rarrap: "â¥µ",
      rarrb: "â‡¥",
      rarrbfs: "â¤ ",
      rarrc: "â¤³",
      rarrfs: "â¤ž",
      rarrhk: "â†ª",
      rarrlp: "â†¬",
      rarrpl: "â¥…",
      rarrsim: "â¥´",
      Rarrtl: "â¤–",
      rarrtl: "â†£",
      rarrw: "â†",
      rAtail: "â¤œ",
      ratail: "â¤š",
      ratio: "âˆ¶",
      rationals: "â„š",
      RBarr: "â¤",
      rBarr: "â¤",
      rbarr: "â¤",
      rbbrk: "â³",
      rbrace: "}",
      rbrack: "]",
      rbrke: "â¦Œ",
      rbrksld: "â¦Ž",
      rbrkslu: "â¦",
      Rcaron: "Å˜",
      rcaron: "Å™",
      Rcedil: "Å–",
      rcedil: "Å—",
      rceil: "âŒ‰",
      rcub: "}",
      Rcy: "Ð ",
      rcy: "Ñ€",
      rdca: "â¤·",
      rdldhar: "â¥©",
      rdquo: "â€",
      rdquor: "â€",
      rdsh: "â†³",
      Re: "â„œ",
      real: "â„œ",
      realine: "â„›",
      realpart: "â„œ",
      reals: "â„",
      rect: "â–­",
      REG: "Â®",
      reg: "Â®",
      ReverseElement: "âˆ‹",
      ReverseEquilibrium: "â‡‹",
      ReverseUpEquilibrium: "â¥¯",
      rfisht: "â¥½",
      rfloor: "âŒ‹",
      Rfr: "â„œ",
      rfr: "ð”¯",
      rHar: "â¥¤",
      rhard: "â‡",
      rharu: "â‡€",
      rharul: "â¥¬",
      Rho: "Î¡",
      rho: "Ï",
      rhov: "Ï±",
      RightAngleBracket: "âŸ©",
      RightArrow: "â†’",
      Rightarrow: "â‡’",
      rightarrow: "â†’",
      RightArrowBar: "â‡¥",
      RightArrowLeftArrow: "â‡„",
      rightarrowtail: "â†£",
      RightCeiling: "âŒ‰",
      RightDoubleBracket: "âŸ§",
      RightDownTeeVector: "â¥",
      RightDownVector: "â‡‚",
      RightDownVectorBar: "â¥•",
      RightFloor: "âŒ‹",
      rightharpoondown: "â‡",
      rightharpoonup: "â‡€",
      rightleftarrows: "â‡„",
      rightleftharpoons: "â‡Œ",
      rightrightarrows: "â‡‰",
      rightsquigarrow: "â†",
      RightTee: "âŠ¢",
      RightTeeArrow: "â†¦",
      RightTeeVector: "â¥›",
      rightthreetimes: "â‹Œ",
      RightTriangle: "âŠ³",
      RightTriangleBar: "â§",
      RightTriangleEqual: "âŠµ",
      RightUpDownVector: "â¥",
      RightUpTeeVector: "â¥œ",
      RightUpVector: "â†¾",
      RightUpVectorBar: "â¥”",
      RightVector: "â‡€",
      RightVectorBar: "â¥“",
      ring: "Ëš",
      risingdotseq: "â‰“",
      rlarr: "â‡„",
      rlhar: "â‡Œ",
      rlm: "â€",
      rmoust: "âŽ±",
      rmoustache: "âŽ±",
      rnmid: "â«®",
      roang: "âŸ­",
      roarr: "â‡¾",
      robrk: "âŸ§",
      ropar: "â¦†",
      Ropf: "â„",
      ropf: "ð•£",
      roplus: "â¨®",
      rotimes: "â¨µ",
      RoundImplies: "â¥°",
      rpar: ")",
      rpargt: "â¦”",
      rppolint: "â¨’",
      rrarr: "â‡‰",
      Rrightarrow: "â‡›",
      rsaquo: "â€º",
      Rscr: "â„›",
      rscr: "ð“‡",
      Rsh: "â†±",
      rsh: "â†±",
      rsqb: "]",
      rsquo: "â€™",
      rsquor: "â€™",
      rthree: "â‹Œ",
      rtimes: "â‹Š",
      rtri: "â–¹",
      rtrie: "âŠµ",
      rtrif: "â–¸",
      rtriltri: "â§Ž",
      RuleDelayed: "â§´",
      ruluhar: "â¥¨",
      rx: "â„ž",
      Sacute: "Åš",
      sacute: "Å›",
      sbquo: "â€š",
      Sc: "âª¼",
      sc: "â‰»",
      scap: "âª¸",
      Scaron: "Å ",
      scaron: "Å¡",
      sccue: "â‰½",
      scE: "âª´",
      sce: "âª°",
      Scedil: "Åž",
      scedil: "ÅŸ",
      Scirc: "Åœ",
      scirc: "Å",
      scnap: "âªº",
      scnE: "âª¶",
      scnsim: "â‹©",
      scpolint: "â¨“",
      scsim: "â‰¿",
      Scy: "Ð¡",
      scy: "Ñ",
      sdot: "â‹…",
      sdotb: "âŠ¡",
      sdote: "â©¦",
      searhk: "â¤¥",
      seArr: "â‡˜",
      searr: "â†˜",
      searrow: "â†˜",
      sect: "Â§",
      semi: ";",
      seswar: "â¤©",
      setminus: "âˆ–",
      setmn: "âˆ–",
      sext: "âœ¶",
      Sfr: "ð”–",
      sfr: "ð”°",
      sfrown: "âŒ¢",
      sharp: "â™¯",
      SHCHcy: "Ð©",
      shchcy: "Ñ‰",
      SHcy: "Ð¨",
      shcy: "Ñˆ",
      ShortDownArrow: "â†“",
      ShortLeftArrow: "â†",
      shortmid: "âˆ£",
      shortparallel: "âˆ¥",
      ShortRightArrow: "â†’",
      ShortUpArrow: "â†‘",
      shy: "Â­",
      Sigma: "Î£",
      sigma: "Ïƒ",
      sigmaf: "Ï‚",
      sigmav: "Ï‚",
      sim: "âˆ¼",
      simdot: "â©ª",
      sime: "â‰ƒ",
      simeq: "â‰ƒ",
      simg: "âªž",
      simgE: "âª ",
      siml: "âª",
      simlE: "âªŸ",
      simne: "â‰†",
      simplus: "â¨¤",
      simrarr: "â¥²",
      slarr: "â†",
      SmallCircle: "âˆ˜",
      smallsetminus: "âˆ–",
      smashp: "â¨³",
      smeparsl: "â§¤",
      smid: "âˆ£",
      smile: "âŒ£",
      smt: "âªª",
      smte: "âª¬",
      smtes: "âª¬ï¸€",
      SOFTcy: "Ð¬",
      softcy: "ÑŒ",
      sol: "/",
      solb: "â§„",
      solbar: "âŒ¿",
      Sopf: "ð•Š",
      sopf: "ð•¤",
      spades: "â™ ",
      spadesuit: "â™ ",
      spar: "âˆ¥",
      sqcap: "âŠ“",
      sqcaps: "âŠ“ï¸€",
      sqcup: "âŠ”",
      sqcups: "âŠ”ï¸€",
      Sqrt: "âˆš",
      sqsub: "âŠ",
      sqsube: "âŠ‘",
      sqsubset: "âŠ",
      sqsubseteq: "âŠ‘",
      sqsup: "âŠ",
      sqsupe: "âŠ’",
      sqsupset: "âŠ",
      sqsupseteq: "âŠ’",
      squ: "â–¡",
      Square: "â–¡",
      square: "â–¡",
      SquareIntersection: "âŠ“",
      SquareSubset: "âŠ",
      SquareSubsetEqual: "âŠ‘",
      SquareSuperset: "âŠ",
      SquareSupersetEqual: "âŠ’",
      SquareUnion: "âŠ”",
      squarf: "â–ª",
      squf: "â–ª",
      srarr: "â†’",
      Sscr: "ð’®",
      sscr: "ð“ˆ",
      ssetmn: "âˆ–",
      ssmile: "âŒ£",
      sstarf: "â‹†",
      Star: "â‹†",
      star: "â˜†",
      starf: "â˜…",
      straightepsilon: "Ïµ",
      straightphi: "Ï•",
      strns: "Â¯",
      Sub: "â‹",
      sub: "âŠ‚",
      subdot: "âª½",
      subE: "â«…",
      sube: "âŠ†",
      subedot: "â«ƒ",
      submult: "â«",
      subnE: "â«‹",
      subne: "âŠŠ",
      subplus: "âª¿",
      subrarr: "â¥¹",
      Subset: "â‹",
      subset: "âŠ‚",
      subseteq: "âŠ†",
      subseteqq: "â«…",
      SubsetEqual: "âŠ†",
      subsetneq: "âŠŠ",
      subsetneqq: "â«‹",
      subsim: "â«‡",
      subsub: "â«•",
      subsup: "â«“",
      succ: "â‰»",
      succapprox: "âª¸",
      succcurlyeq: "â‰½",
      Succeeds: "â‰»",
      SucceedsEqual: "âª°",
      SucceedsSlantEqual: "â‰½",
      SucceedsTilde: "â‰¿",
      succeq: "âª°",
      succnapprox: "âªº",
      succneqq: "âª¶",
      succnsim: "â‹©",
      succsim: "â‰¿",
      SuchThat: "âˆ‹",
      Sum: "âˆ‘",
      sum: "âˆ‘",
      sung: "â™ª",
      Sup: "â‹‘",
      sup: "âŠƒ",
      sup1: "Â¹",
      sup2: "Â²",
      sup3: "Â³",
      supdot: "âª¾",
      supdsub: "â«˜",
      supE: "â«†",
      supe: "âŠ‡",
      supedot: "â«„",
      Superset: "âŠƒ",
      SupersetEqual: "âŠ‡",
      suphsol: "âŸ‰",
      suphsub: "â«—",
      suplarr: "â¥»",
      supmult: "â«‚",
      supnE: "â«Œ",
      supne: "âŠ‹",
      supplus: "â«€",
      Supset: "â‹‘",
      supset: "âŠƒ",
      supseteq: "âŠ‡",
      supseteqq: "â«†",
      supsetneq: "âŠ‹",
      supsetneqq: "â«Œ",
      supsim: "â«ˆ",
      supsub: "â«”",
      supsup: "â«–",
      swarhk: "â¤¦",
      swArr: "â‡™",
      swarr: "â†™",
      swarrow: "â†™",
      swnwar: "â¤ª",
      szlig: "ÃŸ",
      Tab: "	",
      target: "âŒ–",
      Tau: "Î¤",
      tau: "Ï„",
      tbrk: "âŽ´",
      Tcaron: "Å¤",
      tcaron: "Å¥",
      Tcedil: "Å¢",
      tcedil: "Å£",
      Tcy: "Ð¢",
      tcy: "Ñ‚",
      tdot: "âƒ›",
      telrec: "âŒ•",
      Tfr: "ð”—",
      tfr: "ð”±",
      there4: "âˆ´",
      Therefore: "âˆ´",
      therefore: "âˆ´",
      Theta: "Î˜",
      theta: "Î¸",
      thetasym: "Ï‘",
      thetav: "Ï‘",
      thickapprox: "â‰ˆ",
      thicksim: "âˆ¼",
      ThickSpace: "âŸâ€Š",
      thinsp: "â€‰",
      ThinSpace: "â€‰",
      thkap: "â‰ˆ",
      thksim: "âˆ¼",
      THORN: "Ãž",
      thorn: "Ã¾",
      Tilde: "âˆ¼",
      tilde: "Ëœ",
      TildeEqual: "â‰ƒ",
      TildeFullEqual: "â‰…",
      TildeTilde: "â‰ˆ",
      times: "Ã—",
      timesb: "âŠ ",
      timesbar: "â¨±",
      timesd: "â¨°",
      tint: "âˆ­",
      toea: "â¤¨",
      top: "âŠ¤",
      topbot: "âŒ¶",
      topcir: "â«±",
      Topf: "ð•‹",
      topf: "ð•¥",
      topfork: "â«š",
      tosa: "â¤©",
      tprime: "â€´",
      TRADE: "â„¢",
      trade: "â„¢",
      triangle: "â–µ",
      triangledown: "â–¿",
      triangleleft: "â—ƒ",
      trianglelefteq: "âŠ´",
      triangleq: "â‰œ",
      triangleright: "â–¹",
      trianglerighteq: "âŠµ",
      tridot: "â—¬",
      trie: "â‰œ",
      triminus: "â¨º",
      TripleDot: "âƒ›",
      triplus: "â¨¹",
      trisb: "â§",
      tritime: "â¨»",
      trpezium: "â¢",
      Tscr: "ð’¯",
      tscr: "ð“‰",
      TScy: "Ð¦",
      tscy: "Ñ†",
      TSHcy: "Ð‹",
      tshcy: "Ñ›",
      Tstrok: "Å¦",
      tstrok: "Å§",
      twixt: "â‰¬",
      twoheadleftarrow: "â†ž",
      twoheadrightarrow: "â† ",
      Uacute: "Ãš",
      uacute: "Ãº",
      Uarr: "â†Ÿ",
      uArr: "â‡‘",
      uarr: "â†‘",
      Uarrocir: "â¥‰",
      Ubrcy: "ÐŽ",
      ubrcy: "Ñž",
      Ubreve: "Å¬",
      ubreve: "Å­",
      Ucirc: "Ã›",
      ucirc: "Ã»",
      Ucy: "Ð£",
      ucy: "Ñƒ",
      udarr: "â‡…",
      Udblac: "Å°",
      udblac: "Å±",
      udhar: "â¥®",
      ufisht: "â¥¾",
      Ufr: "ð”˜",
      ufr: "ð”²",
      Ugrave: "Ã™",
      ugrave: "Ã¹",
      uHar: "â¥£",
      uharl: "â†¿",
      uharr: "â†¾",
      uhblk: "â–€",
      ulcorn: "âŒœ",
      ulcorner: "âŒœ",
      ulcrop: "âŒ",
      ultri: "â—¸",
      Umacr: "Åª",
      umacr: "Å«",
      uml: "Â¨",
      UnderBar: "_",
      UnderBrace: "âŸ",
      UnderBracket: "âŽµ",
      UnderParenthesis: "â",
      Union: "â‹ƒ",
      UnionPlus: "âŠŽ",
      Uogon: "Å²",
      uogon: "Å³",
      Uopf: "ð•Œ",
      uopf: "ð•¦",
      UpArrow: "â†‘",
      Uparrow: "â‡‘",
      uparrow: "â†‘",
      UpArrowBar: "â¤’",
      UpArrowDownArrow: "â‡…",
      UpDownArrow: "â†•",
      Updownarrow: "â‡•",
      updownarrow: "â†•",
      UpEquilibrium: "â¥®",
      upharpoonleft: "â†¿",
      upharpoonright: "â†¾",
      uplus: "âŠŽ",
      UpperLeftArrow: "â†–",
      UpperRightArrow: "â†—",
      Upsi: "Ï’",
      upsi: "Ï…",
      upsih: "Ï’",
      Upsilon: "Î¥",
      upsilon: "Ï…",
      UpTee: "âŠ¥",
      UpTeeArrow: "â†¥",
      upuparrows: "â‡ˆ",
      urcorn: "âŒ",
      urcorner: "âŒ",
      urcrop: "âŒŽ",
      Uring: "Å®",
      uring: "Å¯",
      urtri: "â—¹",
      Uscr: "ð’°",
      uscr: "ð“Š",
      utdot: "â‹°",
      Utilde: "Å¨",
      utilde: "Å©",
      utri: "â–µ",
      utrif: "â–´",
      uuarr: "â‡ˆ",
      Uuml: "Ãœ",
      uuml: "Ã¼",
      uwangle: "â¦§",
      vangrt: "â¦œ",
      varepsilon: "Ïµ",
      varkappa: "Ï°",
      varnothing: "âˆ…",
      varphi: "Ï•",
      varpi: "Ï–",
      varpropto: "âˆ",
      vArr: "â‡•",
      varr: "â†•",
      varrho: "Ï±",
      varsigma: "Ï‚",
      varsubsetneq: "âŠŠï¸€",
      varsubsetneqq: "â«‹ï¸€",
      varsupsetneq: "âŠ‹ï¸€",
      varsupsetneqq: "â«Œï¸€",
      vartheta: "Ï‘",
      vartriangleleft: "âŠ²",
      vartriangleright: "âŠ³",
      Vbar: "â««",
      vBar: "â«¨",
      vBarv: "â«©",
      Vcy: "Ð’",
      vcy: "Ð²",
      VDash: "âŠ«",
      Vdash: "âŠ©",
      vDash: "âŠ¨",
      vdash: "âŠ¢",
      Vdashl: "â«¦",
      Vee: "â‹",
      vee: "âˆ¨",
      veebar: "âŠ»",
      veeeq: "â‰š",
      vellip: "â‹®",
      Verbar: "â€–",
      verbar: "|",
      Vert: "â€–",
      vert: "|",
      VerticalBar: "âˆ£",
      VerticalLine: "|",
      VerticalSeparator: "â˜",
      VerticalTilde: "â‰€",
      VeryThinSpace: "â€Š",
      Vfr: "ð”™",
      vfr: "ð”³",
      vltri: "âŠ²",
      vnsub: "âŠ‚âƒ’",
      vnsup: "âŠƒâƒ’",
      Vopf: "ð•",
      vopf: "ð•§",
      vprop: "âˆ",
      vrtri: "âŠ³",
      Vscr: "ð’±",
      vscr: "ð“‹",
      vsubnE: "â«‹ï¸€",
      vsubne: "âŠŠï¸€",
      vsupnE: "â«Œï¸€",
      vsupne: "âŠ‹ï¸€",
      Vvdash: "âŠª",
      vzigzag: "â¦š",
      Wcirc: "Å´",
      wcirc: "Åµ",
      wedbar: "â©Ÿ",
      Wedge: "â‹€",
      wedge: "âˆ§",
      wedgeq: "â‰™",
      weierp: "â„˜",
      Wfr: "ð”š",
      wfr: "ð”´",
      Wopf: "ð•Ž",
      wopf: "ð•¨",
      wp: "â„˜",
      wr: "â‰€",
      wreath: "â‰€",
      Wscr: "ð’²",
      wscr: "ð“Œ",
      xcap: "â‹‚",
      xcirc: "â—¯",
      xcup: "â‹ƒ",
      xdtri: "â–½",
      Xfr: "ð”›",
      xfr: "ð”µ",
      xhArr: "âŸº",
      xharr: "âŸ·",
      Xi: "Îž",
      xi: "Î¾",
      xlArr: "âŸ¸",
      xlarr: "âŸµ",
      xmap: "âŸ¼",
      xnis: "â‹»",
      xodot: "â¨€",
      Xopf: "ð•",
      xopf: "ð•©",
      xoplus: "â¨",
      xotime: "â¨‚",
      xrArr: "âŸ¹",
      xrarr: "âŸ¶",
      Xscr: "ð’³",
      xscr: "ð“",
      xsqcup: "â¨†",
      xuplus: "â¨„",
      xutri: "â–³",
      xvee: "â‹",
      xwedge: "â‹€",
      Yacute: "Ã",
      yacute: "Ã½",
      YAcy: "Ð¯",
      yacy: "Ñ",
      Ycirc: "Å¶",
      ycirc: "Å·",
      Ycy: "Ð«",
      ycy: "Ñ‹",
      yen: "Â¥",
      Yfr: "ð”œ",
      yfr: "ð”¶",
      YIcy: "Ð‡",
      yicy: "Ñ—",
      Yopf: "ð•",
      yopf: "ð•ª",
      Yscr: "ð’´",
      yscr: "ð“Ž",
      YUcy: "Ð®",
      yucy: "ÑŽ",
      Yuml: "Å¸",
      yuml: "Ã¿",
      Zacute: "Å¹",
      zacute: "Åº",
      Zcaron: "Å½",
      zcaron: "Å¾",
      Zcy: "Ð—",
      zcy: "Ð·",
      Zdot: "Å»",
      zdot: "Å¼",
      zeetrf: "â„¨",
      ZeroWidthSpace: "â€‹",
      Zeta: "Î–",
      zeta: "Î¶",
      Zfr: "â„¨",
      zfr: "ð”·",
      ZHcy: "Ð–",
      zhcy: "Ð¶",
      zigrarr: "â‡",
      Zopf: "â„¤",
      zopf: "ð•«",
      Zscr: "ð’µ",
      zscr: "ð“",
      zwj: "â€",
      zwnj: "â€Œ"
    }), t.entityMap = t.HTML_ENTITIES;
  }(jd)), jd;
}
var Ma = {}, rw;
function $C() {
  if (rw) return Ma;
  rw = 1;
  var t = ca(), e = Vy(), n = ju(), r = t.isHTMLEscapableRawTextElement, i = t.isHTMLMimeType, o = t.isHTMLRawTextElement, s = t.hasOwn, a = t.NAMESPACE, l = n.ParseError, c = n.DOMException, u = 0, f = 1, d = 2, h = 3, g = 4, w = 5, b = 6, _ = 7;
  function y() {
  }
  y.prototype = {
    parse: function(T, A, q) {
      var V = this.domBuilder;
      V.startDocument(), M(A, A = /* @__PURE__ */ Object.create(null)), D(T, A, q, V, this.errorHandler), V.endDocument();
    }
  };
  var C = /&#?\w+;?/g;
  function D(T, A, q, V, J) {
    var H = i(V.mimeType);
    T.indexOf(e.UNICODE_REPLACEMENT_CHARACTER) >= 0 && J.warning("Unicode replacement character detected, source encoding issues?");
    function W(Ce) {
      if (Ce > 65535) {
        Ce -= 65536;
        var Qe = 55296 + (Ce >> 10), Mt = 56320 + (Ce & 1023);
        return String.fromCharCode(Qe, Mt);
      } else
        return String.fromCharCode(Ce);
    }
    function ne(Ce) {
      var Qe = Ce[Ce.length - 1] === ";" ? Ce : Ce + ";";
      if (!H && Qe !== Ce)
        return J.error("EntityRef: expecting ;"), Ce;
      var Mt = e.Reference.exec(Qe);
      if (!Mt || Mt[0].length !== Qe.length)
        return J.error("entity not matching Reference production: " + Ce), Ce;
      var Bt = Qe.slice(1, -1);
      return s(q, Bt) ? q[Bt] : Bt.charAt(0) === "#" ? W(parseInt(Bt.substring(1).replace("x", "0x"))) : (J.error("entity not found:" + Ce), Ce);
    }
    function re(Ce) {
      if (Ce > Ee) {
        var Qe = T.substring(Ee, Ce).replace(C, ne);
        pe && we(Ee), V.characters(Qe, 0, Ce - Ee), Ee = Ce;
      }
    }
    var te = 0, Q = 0, ce = /\r\n?|\n|$/g, pe = V.locator;
    function we(Ce, Qe) {
      for (; Ce >= Q && (Qe = ce.exec(T)); )
        te = Q, Q = Qe.index + Qe[0].length, pe.lineNumber++;
      pe.columnNumber = Ce - te + 1;
    }
    for (var ve = [{ currentNSMap: A }], _e = [], Ee = 0; ; ) {
      try {
        var fe = T.indexOf("<", Ee);
        if (fe < 0) {
          if (!H && _e.length > 0)
            return J.fatalError("unclosed xml tag(s): " + _e.join(", "));
          if (!T.substring(Ee).match(/^\s*$/)) {
            var Pe = V.doc, He = Pe.createTextNode(T.substring(Ee));
            if (Pe.documentElement)
              return J.error("Extra content at the end of the document");
            Pe.appendChild(He), V.currentElement = He;
          }
          return;
        }
        if (fe > Ee) {
          var ae = T.substring(Ee, fe);
          !H && _e.length === 0 && (ae = ae.replace(new RegExp(e.S_OPT.source, "g"), ""), ae && J.error("Unexpected content outside root element: '" + ae + "'")), re(fe);
        }
        switch (T.charAt(fe + 1)) {
          case "/":
            var ct = T.indexOf(">", fe + 2), Te = T.substring(fe + 2, ct > 0 ? ct : void 0);
            if (!Te)
              return J.fatalError("end tag name missing");
            var Be = ct > 0 && e.reg("^", e.QName_group, e.S_OPT, "$").exec(Te);
            if (!Be)
              return J.fatalError('end tag name contains invalid characters: "' + Te + '"');
            if (!V.currentElement && !V.doc.documentElement)
              return;
            var Ge = _e[_e.length - 1] || V.currentElement.tagName || V.doc.documentElement.tagName || "";
            if (Ge !== Be[1]) {
              var rt = Be[1].toLowerCase();
              if (!H || Ge.toLowerCase() !== rt)
                return J.fatalError('Opening and ending tag mismatch: "' + Ge + '" != "' + Te + '"');
            }
            var vt = ve.pop();
            _e.pop();
            var mt = vt.localNSMap;
            if (V.endElement(vt.uri, vt.localName, Ge), mt)
              for (var Et in mt)
                s(mt, Et) && V.endPrefixMapping(Et);
            ct++;
            break;
          // end element
          case "?":
            pe && we(fe), ct = N(T, fe, V, J);
            break;
          case "!":
            pe && we(fe), ct = I(T, fe, V, J, H);
            break;
          default:
            pe && we(fe);
            var $e = new R(), Dt = ve[ve.length - 1].currentNSMap, ct = S(T, fe, $e, Dt, ne, J, H), lr = $e.length;
            if ($e.closed || (H && t.isHTMLVoidElement($e.tagName) ? $e.closed = !0 : _e.push($e.tagName)), pe && lr) {
              for (var Ln = P(pe, {}), En = 0; En < lr; En++) {
                var $n = $e[En];
                we($n.offset), $n.locator = P(pe, {});
              }
              V.locator = Ln, L($e, V, Dt) && ve.push($e), V.locator = pe;
            } else
              L($e, V, Dt) && ve.push($e);
            H && !$e.closed ? ct = O(T, ct, $e.tagName, ne, V) : ct++;
        }
      } catch (Ce) {
        if (Ce instanceof l)
          throw Ce;
        if (Ce instanceof c)
          throw new l(Ce.name + ": " + Ce.message, V.locator, Ce);
        J.error("element parse error: " + Ce), ct = -1;
      }
      ct > Ee ? Ee = ct : re(Math.max(fe, Ee) + 1);
    }
  }
  function P(T, A) {
    return A.lineNumber = T.lineNumber, A.columnNumber = T.columnNumber, A;
  }
  function S(T, A, q, V, J, H, W) {
    function ne(we, ve, _e) {
      if (s(q.attributeNames, we))
        return H.fatalError("Attribute " + we + " redefined");
      if (!W && ve.indexOf("<") >= 0)
        return H.fatalError("Unescaped '<' not allowed in attributes values");
      q.addValue(
        we,
        // @see https://www.w3.org/TR/xml/#AVNormalize
        // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
        // - recursive replacement of (DTD) entity references
        // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
        ve.replace(/[\t\n\r]/g, " ").replace(C, J),
        _e
      );
    }
    for (var re, te, Q = ++A, ce = u; ; ) {
      var pe = T.charAt(Q);
      switch (pe) {
        case "=":
          if (ce === f)
            re = T.slice(A, Q), ce = h;
          else if (ce === d)
            ce = h;
          else
            throw new Error("attribute equal must after attrName");
          break;
        case "'":
        case '"':
          if (ce === h || ce === f)
            if (ce === f && (H.warning('attribute value must after "="'), re = T.slice(A, Q)), A = Q + 1, Q = T.indexOf(pe, A), Q > 0)
              te = T.slice(A, Q), ne(re, te, A - 1), ce = w;
            else
              throw new Error("attribute value no end '" + pe + "' match");
          else if (ce == g)
            te = T.slice(A, Q), ne(re, te, A), H.warning('attribute "' + re + '" missed start quot(' + pe + ")!!"), A = Q + 1, ce = w;
          else
            throw new Error('attribute value must after "="');
          break;
        case "/":
          switch (ce) {
            case u:
              q.setTagName(T.slice(A, Q));
            case w:
            case b:
            case _:
              ce = _, q.closed = !0;
            case g:
            case f:
              break;
            case d:
              q.closed = !0;
              break;
            //case S_EQ:
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          return H.error("unexpected end of input"), ce == u && q.setTagName(T.slice(A, Q)), Q;
        case ">":
          switch (ce) {
            case u:
              q.setTagName(T.slice(A, Q));
            case w:
            case b:
            case _:
              break;
            //normal
            case g:
            //Compatible state
            case f:
              te = T.slice(A, Q), te.slice(-1) === "/" && (q.closed = !0, te = te.slice(0, -1));
            case d:
              ce === d && (te = re), ce == g ? (H.warning('attribute "' + te + '" missed quot(")!'), ne(re, te, A)) : (W || H.warning('attribute "' + te + '" missed value!! "' + te + '" instead!!'), ne(te, te, A));
              break;
            case h:
              if (!W)
                return H.fatalError(`AttValue: ' or " expected`);
          }
          return Q;
        /*xml space '\x20' | #x9 | #xD | #xA; */
        case "Â€":
          pe = " ";
        default:
          if (pe <= " ")
            switch (ce) {
              case u:
                q.setTagName(T.slice(A, Q)), ce = b;
                break;
              case f:
                re = T.slice(A, Q), ce = d;
                break;
              case g:
                var te = T.slice(A, Q);
                H.warning('attribute "' + te + '" missed quot(")!!'), ne(re, te, A);
              case w:
                ce = b;
                break;
            }
          else
            switch (ce) {
              //case S_TAG:void();break;
              //case S_ATTR:void();break;
              //case S_ATTR_NOQUOT_VALUE:void();break;
              case d:
                W || H.warning('attribute "' + re + '" missed value!! "' + re + '" instead2!!'), ne(re, re, A), A = Q, ce = f;
                break;
              case w:
                H.warning('attribute space is required"' + re + '"!!');
              case b:
                ce = f, A = Q;
                break;
              case h:
                ce = g, A = Q;
                break;
              case _:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
      }
      Q++;
    }
  }
  function L(T, A, q) {
    for (var V = T.tagName, J = null, ce = T.length; ce--; ) {
      var H = T[ce], W = H.qName, ne = H.value, pe = W.indexOf(":");
      if (pe > 0)
        var re = H.prefix = W.slice(0, pe), te = W.slice(pe + 1), Q = re === "xmlns" && te;
      else
        te = W, re = null, Q = W === "xmlns" && "";
      H.localName = te, Q !== !1 && (J == null && (J = /* @__PURE__ */ Object.create(null), M(q, q = /* @__PURE__ */ Object.create(null))), q[Q] = J[Q] = ne, H.uri = a.XMLNS, A.startPrefixMapping(Q, ne));
    }
    for (var ce = T.length; ce--; )
      H = T[ce], H.prefix && (H.prefix === "xml" && (H.uri = a.XML), H.prefix !== "xmlns" && (H.uri = q[H.prefix]));
    var pe = V.indexOf(":");
    pe > 0 ? (re = T.prefix = V.slice(0, pe), te = T.localName = V.slice(pe + 1)) : (re = null, te = T.localName = V);
    var we = T.uri = q[re || ""];
    if (A.startElement(we, te, V, T), T.closed) {
      if (A.endElement(we, te, V), J)
        for (re in J)
          s(J, re) && A.endPrefixMapping(re);
    } else
      return T.currentNSMap = q, T.localNSMap = J, !0;
  }
  function O(T, A, q, V, J) {
    var H = r(q);
    if (H || o(q)) {
      var W = T.indexOf("</" + q + ">", A), ne = T.substring(A + 1, W);
      return H && (ne = ne.replace(C, V)), J.characters(ne, 0, ne.length), W;
    }
    return A + 1;
  }
  function M(T, A) {
    for (var q in T)
      s(T, q) && (A[q] = T[q]);
  }
  function F(T, A) {
    var q = A;
    function V(Q) {
      return Q = Q || 0, T.charAt(q + Q);
    }
    function J(Q) {
      Q = Q || 1, q += Q;
    }
    function H() {
      for (var Q = 0; q < T.length; ) {
        var ce = V();
        if (ce !== " " && ce !== `
` && ce !== "	" && ce !== "\r")
          return Q;
        Q++, J();
      }
      return -1;
    }
    function W() {
      return T.substring(q);
    }
    function ne(Q) {
      return T.substring(q, q + Q.length) === Q;
    }
    function re(Q) {
      return T.substring(q, q + Q.length).toUpperCase() === Q.toUpperCase();
    }
    function te(Q) {
      var ce = e.reg("^", Q), pe = ce.exec(W());
      return pe ? (J(pe[0].length), pe[0]) : null;
    }
    return {
      char: V,
      getIndex: function() {
        return q;
      },
      getMatch: te,
      getSource: function() {
        return T;
      },
      skip: J,
      skipBlanks: H,
      substringFromIndex: W,
      substringStartsWith: ne,
      substringStartsWithCaseInsensitive: re
    };
  }
  function k(T, A) {
    function q(ne, re) {
      var te = e.PI.exec(ne.substringFromIndex());
      return te ? te[1].toLowerCase() === "xml" ? re.fatalError(
        "xml declaration is only allowed at the start of the document, but found at position " + ne.getIndex()
      ) : (ne.skip(te[0].length), te[0]) : re.fatalError("processing instruction is not well-formed at position " + ne.getIndex());
    }
    var V = T.getSource();
    if (T.char() === "[") {
      T.skip(1);
      for (var J = T.getIndex(); T.getIndex() < V.length; ) {
        if (T.skipBlanks(), T.char() === "]") {
          var H = V.substring(J, T.getIndex());
          return T.skip(1), H;
        }
        var W = null;
        if (T.char() === "<" && T.char(1) === "!")
          switch (T.char(2)) {
            case "E":
              T.char(3) === "L" ? W = T.getMatch(e.elementdecl) : T.char(3) === "N" && (W = T.getMatch(e.EntityDecl));
              break;
            case "A":
              W = T.getMatch(e.AttlistDecl);
              break;
            case "N":
              W = T.getMatch(e.NotationDecl);
              break;
            case "-":
              W = T.getMatch(e.Comment);
              break;
          }
        else if (T.char() === "<" && T.char(1) === "?")
          W = q(T, A);
        else if (T.char() === "%")
          W = T.getMatch(e.PEReference);
        else
          return A.fatalError("Error detected in Markup declaration");
        if (!W)
          return A.fatalError("Error in internal subset at position " + T.getIndex());
      }
      return A.fatalError("doctype internal subset is not well-formed, missing ]");
    }
  }
  function I(T, A, q, V, J) {
    var H = F(T, A);
    switch (J ? H.char(2).toUpperCase() : H.char(2)) {
      case "-":
        var W = H.getMatch(e.Comment);
        return W ? (q.comment(W, e.COMMENT_START.length, W.length - e.COMMENT_START.length - e.COMMENT_END.length), H.getIndex()) : V.fatalError("comment is not well-formed at position " + H.getIndex());
      case "[":
        var ne = H.getMatch(e.CDSect);
        return ne ? !J && !q.currentElement ? V.fatalError("CDATA outside of element") : (q.startCDATA(), q.characters(ne, e.CDATA_START.length, ne.length - e.CDATA_START.length - e.CDATA_END.length), q.endCDATA(), H.getIndex()) : V.fatalError("Invalid CDATA starting at position " + A);
      case "D": {
        if (q.doc && q.doc.documentElement)
          return V.fatalError("Doctype not allowed inside or after documentElement at position " + H.getIndex());
        if (J ? !H.substringStartsWithCaseInsensitive(e.DOCTYPE_DECL_START) : !H.substringStartsWith(e.DOCTYPE_DECL_START))
          return V.fatalError("Expected " + e.DOCTYPE_DECL_START + " at position " + H.getIndex());
        if (H.skip(e.DOCTYPE_DECL_START.length), H.skipBlanks() < 1)
          return V.fatalError("Expected whitespace after " + e.DOCTYPE_DECL_START + " at position " + H.getIndex());
        var re = {
          name: void 0,
          publicId: void 0,
          systemId: void 0,
          internalSubset: void 0
        };
        if (re.name = H.getMatch(e.Name), !re.name)
          return V.fatalError("doctype name missing or contains unexpected characters at position " + H.getIndex());
        if (J && re.name.toLowerCase() !== "html" && V.warning("Unexpected DOCTYPE in HTML document at position " + H.getIndex()), H.skipBlanks(), H.substringStartsWith(e.PUBLIC) || H.substringStartsWith(e.SYSTEM)) {
          var te = e.ExternalID_match.exec(H.substringFromIndex());
          if (!te)
            return V.fatalError("doctype external id is not well-formed at position " + H.getIndex());
          te.groups.SystemLiteralOnly !== void 0 ? re.systemId = te.groups.SystemLiteralOnly : (re.systemId = te.groups.SystemLiteral, re.publicId = te.groups.PubidLiteral), H.skip(te[0].length);
        } else if (J && H.substringStartsWithCaseInsensitive(e.SYSTEM)) {
          if (H.skip(e.SYSTEM.length), H.skipBlanks() < 1)
            return V.fatalError("Expected whitespace after " + e.SYSTEM + " at position " + H.getIndex());
          if (re.systemId = H.getMatch(e.ABOUT_LEGACY_COMPAT_SystemLiteral), !re.systemId)
            return V.fatalError(
              "Expected " + e.ABOUT_LEGACY_COMPAT + " in single or double quotes after " + e.SYSTEM + " at position " + H.getIndex()
            );
        }
        return J && re.systemId && !e.ABOUT_LEGACY_COMPAT_SystemLiteral.test(re.systemId) && V.warning("Unexpected doctype.systemId in HTML document at position " + H.getIndex()), J || (H.skipBlanks(), re.internalSubset = k(H, V)), H.skipBlanks(), H.char() !== ">" ? V.fatalError("doctype not terminated with > at position " + H.getIndex()) : (H.skip(1), q.startDTD(re.name, re.publicId, re.systemId, re.internalSubset), q.endDTD(), H.getIndex());
      }
      default:
        return V.fatalError('Not well-formed XML starting with "<!" at position ' + A);
    }
  }
  function N(T, A, q, V) {
    var J = T.substring(A).match(e.PI);
    if (!J)
      return V.fatalError("Invalid processing instruction starting at position " + A);
    if (J[1].toLowerCase() === "xml") {
      if (A > 0)
        return V.fatalError(
          "processing instruction at position " + A + " is an xml declaration which is only at the start of the document"
        );
      if (!e.XMLDecl.test(T.substring(A)))
        return V.fatalError("xml declaration is not well-formed");
    }
    return q.processingInstruction(J[1], J[2]), A + J[0].length;
  }
  function R() {
    this.attributeNames = /* @__PURE__ */ Object.create(null);
  }
  return R.prototype = {
    setTagName: function(T) {
      if (!e.QName_exact.test(T))
        throw new Error("invalid tagName:" + T);
      this.tagName = T;
    },
    addValue: function(T, A, q) {
      if (!e.QName_exact.test(T))
        throw new Error("invalid attribute:" + T);
      this.attributeNames[T] = this.length, this[this.length++] = { qName: T, value: A, offset: q };
    },
    length: 0,
    getLocalName: function(T) {
      return this[T].localName;
    },
    getLocator: function(T) {
      return this[T].locator;
    },
    getQName: function(T) {
      return this[T].qName;
    },
    getURI: function(T) {
      return this[T].uri;
    },
    getValue: function(T) {
      return this[T].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  }, Ma.XMLReader = y, Ma.parseUtils = F, Ma.parseDoctypeCommentOrCData = I, Ma;
}
var iw;
function FC() {
  if (iw) return fo;
  iw = 1;
  var t = ca(), e = Hy(), n = ju(), r = LC(), i = $C(), o = e.DOMImplementation, s = t.hasDefaultHTMLNamespace, a = t.isHTMLMimeType, l = t.isValidMimeType, c = t.MIME_TYPE, u = t.NAMESPACE, f = n.ParseError, d = i.XMLReader;
  function h(S) {
    return S.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028\u2029]/g, `
`);
  }
  function g(S) {
    if (S = S || {}, S.locator === void 0 && (S.locator = !0), this.assign = S.assign || t.assign, this.domHandler = S.domHandler || w, this.onError = S.onError || S.errorHandler, S.errorHandler && typeof S.errorHandler != "function")
      throw new TypeError("errorHandler object is no longer supported, switch to onError!");
    S.errorHandler && S.errorHandler("warning", "The `errorHandler` option has been deprecated, use `onError` instead!", this), this.normalizeLineEndings = S.normalizeLineEndings || h, this.locator = !!S.locator, this.xmlns = this.assign(/* @__PURE__ */ Object.create(null), S.xmlns);
  }
  g.prototype.parseFromString = function(S, L) {
    if (!l(L))
      throw new TypeError('DOMParser.parseFromString: the provided mimeType "' + L + '" is not valid.');
    var O = this.assign(/* @__PURE__ */ Object.create(null), this.xmlns), M = r.XML_ENTITIES, F = O[""] || null;
    s(L) ? (M = r.HTML_ENTITIES, F = u.HTML) : L === c.XML_SVG_IMAGE && (F = u.SVG), O[""] = F, O.xml = O.xml || u.XML;
    var k = new this.domHandler({
      mimeType: L,
      defaultNamespace: F,
      onError: this.onError
    }), I = this.locator ? {} : void 0;
    this.locator && k.setDocumentLocator(I);
    var N = new d();
    N.errorHandler = k, N.domBuilder = k;
    var R = !t.isHTMLMimeType(L);
    return R && typeof S != "string" && N.errorHandler.fatalError("source is not a string"), N.parse(this.normalizeLineEndings(String(S)), O, M), k.doc.documentElement || N.errorHandler.fatalError("missing root element"), k.doc;
  };
  function w(S) {
    var L = S || {};
    this.mimeType = L.mimeType || c.XML_APPLICATION, this.defaultNamespace = L.defaultNamespace || null, this.cdata = !1, this.currentElement = void 0, this.doc = void 0, this.locator = void 0, this.onError = L.onError;
  }
  function b(S, L) {
    L.lineNumber = S.lineNumber, L.columnNumber = S.columnNumber;
  }
  w.prototype = {
    /**
     * Either creates an XML or an HTML document and stores it under `this.doc`.
     * If it is an XML document, `this.defaultNamespace` is used to create it,
     * and it will not contain any `childNodes`.
     * If it is an HTML document, it will be created without any `childNodes`.
     *
     * @see http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
     */
    startDocument: function() {
      var S = new o();
      this.doc = a(this.mimeType) ? S.createHTMLDocument(!1) : S.createDocument(this.defaultNamespace, "");
    },
    startElement: function(S, L, O, M) {
      var F = this.doc, k = F.createElementNS(S, O || L), I = M.length;
      C(this, k), this.currentElement = k, this.locator && b(this.locator, k);
      for (var N = 0; N < I; N++) {
        var S = M.getURI(N), R = M.getValue(N), O = M.getQName(N), T = F.createAttributeNS(S, O);
        this.locator && b(M.getLocator(N), T), T.value = T.nodeValue = R, k.setAttributeNode(T);
      }
    },
    endElement: function(S, L, O) {
      this.currentElement = this.currentElement.parentNode;
    },
    startPrefixMapping: function(S, L) {
    },
    endPrefixMapping: function(S) {
    },
    processingInstruction: function(S, L) {
      var O = this.doc.createProcessingInstruction(S, L);
      this.locator && b(this.locator, O), C(this, O);
    },
    ignorableWhitespace: function(S, L, O) {
    },
    characters: function(S, L, O) {
      if (S = y.apply(this, arguments), S) {
        if (this.cdata)
          var M = this.doc.createCDATASection(S);
        else
          var M = this.doc.createTextNode(S);
        this.currentElement ? this.currentElement.appendChild(M) : /^\s*$/.test(S) && this.doc.appendChild(M), this.locator && b(this.locator, M);
      }
    },
    skippedEntity: function(S) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    /**
     * Stores the locator to be able to set the `columnNumber` and `lineNumber`
     * on the created DOM nodes.
     *
     * @param {Locator} locator
     */
    setDocumentLocator: function(S) {
      S && (S.lineNumber = 0), this.locator = S;
    },
    //LexicalHandler
    comment: function(S, L, O) {
      S = y.apply(this, arguments);
      var M = this.doc.createComment(S);
      this.locator && b(this.locator, M), C(this, M);
    },
    startCDATA: function() {
      this.cdata = !0;
    },
    endCDATA: function() {
      this.cdata = !1;
    },
    startDTD: function(S, L, O, M) {
      var F = this.doc.implementation;
      if (F && F.createDocumentType) {
        var k = F.createDocumentType(S, L, O, M);
        this.locator && b(this.locator, k), C(this, k), this.doc.doctype = k;
      }
    },
    reportError: function(S, L) {
      if (typeof this.onError == "function")
        try {
          this.onError(S, L, this);
        } catch (O) {
          throw new f("Reporting " + S + ' "' + L + '" caused ' + O, this.locator);
        }
      else
        console.error("[xmldom " + S + "]	" + L, _(this.locator));
    },
    /**
     * @see http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(S) {
      this.reportError("warning", S);
    },
    error: function(S) {
      this.reportError("error", S);
    },
    /**
     * This function reports a fatal error and throws a ParseError.
     *
     * @param {string} message
     * - The message to be used for reporting and throwing the error.
     * @returns {never}
     * This function always throws an error and never returns a value.
     * @throws {ParseError}
     * Always throws a ParseError with the provided message.
     */
    fatalError: function(S) {
      throw this.reportError("fatalError", S), new f(S, this.locator);
    }
  };
  function _(S) {
    if (S)
      return `
@#[line:` + S.lineNumber + ",col:" + S.columnNumber + "]";
  }
  function y(S, L, O) {
    return typeof S == "string" ? S.substr(L, O) : S.length >= L + O || L ? new java.lang.String(S, L, O) + "" : S;
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(
    /\w+/g,
    function(S) {
      w.prototype[S] = function() {
        return null;
      };
    }
  );
  function C(S, L) {
    S.currentElement ? S.currentElement.appendChild(L) : S.doc.appendChild(L);
  }
  function D(S) {
    if (S === "error") throw "onErrorStopParsing";
  }
  function P() {
    throw "onWarningStopParsing";
  }
  return fo.__DOMHandler = w, fo.DOMParser = g, fo.normalizeLineEndings = h, fo.onErrorStopParsing = D, fo.onWarningStopParsing = P, fo;
}
var ow;
function BC() {
  if (ow) return Ue;
  ow = 1;
  var t = ca();
  Ue.assign = t.assign, Ue.hasDefaultHTMLNamespace = t.hasDefaultHTMLNamespace, Ue.isHTMLMimeType = t.isHTMLMimeType, Ue.isValidMimeType = t.isValidMimeType, Ue.MIME_TYPE = t.MIME_TYPE, Ue.NAMESPACE = t.NAMESPACE;
  var e = ju();
  Ue.DOMException = e.DOMException, Ue.DOMExceptionName = e.DOMExceptionName, Ue.ExceptionCode = e.ExceptionCode, Ue.ParseError = e.ParseError;
  var n = Hy();
  Ue.Attr = n.Attr, Ue.CDATASection = n.CDATASection, Ue.CharacterData = n.CharacterData, Ue.Comment = n.Comment, Ue.Document = n.Document, Ue.DocumentFragment = n.DocumentFragment, Ue.DocumentType = n.DocumentType, Ue.DOMImplementation = n.DOMImplementation, Ue.Element = n.Element, Ue.Entity = n.Entity, Ue.EntityReference = n.EntityReference, Ue.LiveNodeList = n.LiveNodeList, Ue.NamedNodeMap = n.NamedNodeMap, Ue.Node = n.Node, Ue.NodeList = n.NodeList, Ue.Notation = n.Notation, Ue.ProcessingInstruction = n.ProcessingInstruction, Ue.Text = n.Text, Ue.XMLSerializer = n.XMLSerializer;
  var r = FC();
  return Ue.DOMParser = r.DOMParser, Ue.normalizeLineEndings = r.normalizeLineEndings, Ue.onErrorStopParsing = r.onErrorStopParsing, Ue.onWarningStopParsing = r.onWarningStopParsing, Ue;
}
BC();
const ol = "USJ", sl = "3.1", ip = Object.freeze({ type: ol, version: sl, content: [] }), qC = [
  "type",
  "marker",
  "content",
  "sid",
  "eid",
  "number",
  "code",
  "altnumber",
  "pubnumber",
  "caller",
  "align",
  "category"
];
function jC(t) {
  return UC.includes(t);
}
const UC = [
  // Old Testament
  "GEN",
  "EXO",
  "LEV",
  "NUM",
  "DEU",
  "JOS",
  "JDG",
  "RUT",
  "1SA",
  "2SA",
  "1KI",
  "2KI",
  "1CH",
  "2CH",
  "EZR",
  "NEH",
  "EST",
  "JOB",
  "PSA",
  "PRO",
  "ECC",
  "SNG",
  "ISA",
  "JER",
  "LAM",
  "EZK",
  "DAN",
  "HOS",
  "JOL",
  "AMO",
  "OBA",
  "JON",
  "MIC",
  "NAM",
  "HAB",
  "ZEP",
  "HAG",
  "ZEC",
  "MAL",
  // New Testament
  "MAT",
  "MRK",
  "LUK",
  "JHN",
  "ACT",
  "ROM",
  "1CO",
  "2CO",
  "GAL",
  "EPH",
  "PHP",
  "COL",
  "1TH",
  "2TH",
  "1TI",
  "2TI",
  "TIT",
  "PHM",
  "HEB",
  "JAS",
  "1PE",
  "2PE",
  "1JN",
  "2JN",
  "3JN",
  "JUD",
  "REV",
  // Deuterocanon
  "TOB",
  "JDT",
  "ESG",
  "WIS",
  "SIR",
  "BAR",
  "LJE",
  "S3Y",
  "SUS",
  "BEL",
  "1MA",
  "2MA",
  "3MA",
  "4MA",
  "1ES",
  "2ES",
  "MAN",
  "PS2",
  "ODA",
  "PSS",
  "EZA",
  "5EZ",
  "6EZ",
  "DAG",
  "PS3",
  "2BA",
  "LBA",
  "JUB",
  "ENO",
  "1MQ",
  "2MQ",
  "3MQ",
  "REP",
  "4BA",
  "LAO",
  // Non scripture
  "FRT",
  "BAK",
  "OTH",
  "INT",
  "CNC",
  "GLO",
  "TDX",
  "NDX",
  "XXA",
  "XXB",
  "XXC",
  "XXD",
  "XXE",
  "XXF",
  "XXG"
], $f = "$", Ky = ".content[";
function zC(t) {
  const e = t.split(Ky);
  if (e.shift() !== $f)
    throw new Error(`indexesFromJsonPath: jsonPath didn't start with '${$f}'`);
  return e.map((n) => parseInt(n, 10));
}
function VC(t) {
  return t.reduce((e, n) => `${e}${Ky}${n}]`, $f);
}
function le(t, ...e) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", t);
  for (const i of e) r.append("v", i);
  throw n.search = r.toString(), Error(`Minified Lexical error #${t}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
const Tr = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, HC = Tr && "documentMode" in document ? document.documentMode : null, qr = Tr && /Mac|iPod|iPhone|iPad/.test(navigator.platform), Lo = Tr && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Hc = !(!Tr || !("InputEvent" in window) || HC) && "getTargetRanges" in new window.InputEvent("input"), al = Tr && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), Ps = Tr && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, KC = Tr && /Android/.test(navigator.userAgent), Wy = Tr && /^(?=.*Chrome).*/i.test(navigator.userAgent), sw = Tr && KC && Wy, Kc = Tr && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !Wy;
function Wc(...t) {
  const e = [];
  for (const n of t) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) e.push(r);
  return e;
}
const WC = 1, GC = 3, JC = 9, XC = 11, $o = 0, Gy = 1, Ls = 2, YC = 0, QC = 1, ZC = 2, Gc = 4, Jc = 8, op = 128, ek = 1792 | (112 | (3 | Gc | Jc) | op), sp = 1, ap = 2, lp = 3, cp = 4, up = 5, dp = 6, Uu = al || Ps || Kc ? "Â " : "â€‹", mi = `

`, tk = Lo ? "Â " : Uu, Jy = "Ö‘-ß¿ï¬-ï·½ï¹°-ï»¼", Xy = "A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ê¸Ì€-Öà €-á¿¿â€Žâ°€-ï¬œï¸€-ï¹¯ï»½-ï¿¿", nk = new RegExp("^[^" + Xy + "]*[" + Jy + "]"), rk = new RegExp("^[^" + Jy + "]*[" + Xy + "]"), Ui = { bold: 1, capitalize: 1024, code: 16, highlight: op, italic: 2, lowercase: 256, strikethrough: Gc, subscript: 32, superscript: 64, underline: Jc, uppercase: 512 }, ik = { directionless: 1, unmergeable: 2 }, aw = { center: ap, end: dp, justify: cp, left: sp, right: lp, start: up }, ok = { [ap]: "center", [dp]: "end", [cp]: "justify", [sp]: "left", [lp]: "right", [up]: "start" }, sk = { normal: 0, segmented: 2, token: 1 }, ak = { [YC]: "normal", [ZC]: "segmented", [QC]: "token" }, lw = "$config";
function Yy(t, e, n, r, i, o) {
  let s = t.getFirstChild();
  for (; s !== null; ) {
    const a = s.__key;
    s.__parent === e && (X(s) && Yy(s, a, n, r, i, o), n.has(a) || o.delete(a), i.push(a)), s = s.getNextSibling();
  }
}
const lk = 100;
let Ff = !1, fp = 0;
function ck(t) {
  fp = t.timeStamp;
}
function Ud(t, e, n) {
  const r = t.nodeName === "BR", i = e.__lexicalLineBreak;
  return i && (t === i || r && t.previousSibling === i) || r && Yu(t, n) !== void 0;
}
function uk(t, e, n) {
  const r = vr(or(n));
  let i = null, o = null;
  r !== null && r.anchorNode === t && (i = r.anchorOffset, o = r.focusOffset);
  const s = t.nodeValue;
  s !== null && Pp(e, s, i, o, !1);
}
function dk(t, e, n) {
  if (Z(t)) {
    const r = t.anchor.getNode();
    if (r.is(n) && t.format !== r.getFormat()) return !1;
  }
  return ki(e) && n.isAttached();
}
function fk(t, e, n, r) {
  for (let i = t; i && !uE(i); i = Bl(i)) {
    const o = Yu(i, e);
    if (o !== void 0) {
      const s = Oe(o, n);
      if (s) return Xe(s) || !it(i) ? void 0 : [i, s];
    } else if (i === r) return [r, W0(n)];
  }
}
function Qy(t, e, n) {
  Ff = !0;
  const r = performance.now() - fp > lk;
  try {
    Wn(t, () => {
      const i = oe() || function(d) {
        return d.getEditorState().read(() => {
          const h = oe();
          return h !== null ? h.clone() : null;
        });
      }(t), o = /* @__PURE__ */ new Map(), s = t.getRootElement(), a = t._editorState, l = t._blockCursorElement;
      let c = !1, u = "";
      for (let d = 0; d < e.length; d++) {
        const h = e[d], g = h.type, w = h.target, b = fk(w, t, a, s);
        if (!b) continue;
        const [_, y] = b;
        if (g === "characterData") r && ie(y) && ki(w) && dk(i, w, y) && uk(w, y, t);
        else if (g === "childList") {
          c = !0;
          const C = h.addedNodes;
          for (let S = 0; S < C.length; S++) {
            const L = C[S], O = H0(L), M = L.parentNode;
            if (M != null && L !== l && O === null && !Ud(L, M, t)) {
              if (Lo) {
                const F = (it(L) ? L.innerText : null) || L.nodeValue;
                F && (u += F);
              }
              M.removeChild(L);
            }
          }
          const D = h.removedNodes, P = D.length;
          if (P > 0) {
            let S = 0;
            for (let L = 0; L < P; L++) {
              const O = D[L];
              (Ud(O, w, t) || l === O) && (w.appendChild(O), S++);
            }
            P !== S && o.set(_, y);
          }
        }
      }
      if (o.size > 0) for (const [d, h] of o) h.reconcileObservedMutation(d, t);
      const f = n.takeRecords();
      if (f.length > 0) {
        for (let d = 0; d < f.length; d++) {
          const h = f[d], g = h.addedNodes, w = h.target;
          for (let b = 0; b < g.length; b++) {
            const _ = g[b], y = _.parentNode;
            y == null || _.nodeName !== "BR" || Ud(_, w, t) || y.removeChild(_);
          }
        }
        n.takeRecords();
      }
      i !== null && (c && sn(i), Lo && Q0(t) && i.insertRawText(u));
    });
  } finally {
    Ff = !1;
  }
}
function Zy(t) {
  const e = t._observer;
  e !== null && Qy(t, e.takeRecords(), e);
}
function e0(t) {
  (function(e) {
    fp === 0 && or(e).addEventListener("textInput", ck, !0);
  })(t), t._observer = new MutationObserver((e, n) => {
    Qy(t, e, n);
  });
}
let hk = class {
  constructor(e, n) {
    this.key = e, this.parse = n.parse.bind(n), this.unparse = (n.unparse || wk).bind(n), this.isEqual = (n.isEqual || Object.is).bind(n), this.defaultValue = this.parse(void 0);
  }
};
function t0(t, e) {
  return new hk(t, e);
}
function $s(t, e, n = "latest") {
  const r = (n === "latest" ? t.getLatest() : t).__state;
  return r ? r.getValue(e) : e.defaultValue;
}
function pi(t, e, n) {
  let r;
  if (Zt(), typeof n == "function") {
    const o = t.getLatest(), s = $s(o, e);
    if (r = n(s), e.isEqual(s, r)) return o;
  } else r = n;
  const i = t.getWritable();
  return r0(i).updateFromKnown(e, r), i;
}
function pk(t) {
  const e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set();
  for (let r = typeof t == "function" ? t : t.replace; r.prototype && r.prototype.getType !== void 0; r = Object.getPrototypeOf(r)) {
    const { ownNodeConfig: i } = Bp(r);
    if (i && i.stateConfigs) for (const o of i.stateConfigs) {
      let s;
      "stateConfig" in o ? (s = o.stateConfig, o.flat && n.add(s.key)) : s = o, e.set(s.key, s);
    }
  }
  return { flatKeys: n, sharedConfigMap: e };
}
let gk = class n0 {
  constructor(e, n, r = void 0, i = /* @__PURE__ */ new Map(), o = void 0) {
    this.node = e, this.sharedNodeState = n, this.unknownState = r, this.knownState = i;
    const { sharedConfigMap: s } = this.sharedNodeState, a = o !== void 0 ? o : function(l, c, u) {
      let f = u.size;
      if (c) for (const d in c) {
        const h = l.get(d);
        h && u.has(h) || f++;
      }
      return f;
    }(s, r, i);
    this.size = a;
  }
  getValue(e) {
    const n = this.knownState.get(e);
    if (n !== void 0) return n;
    this.sharedNodeState.sharedConfigMap.set(e.key, e);
    let r = e.defaultValue;
    if (this.unknownState && e.key in this.unknownState) {
      const i = this.unknownState[e.key];
      i !== void 0 && (r = e.parse(i)), this.updateFromKnown(e, r);
    }
    return r;
  }
  getInternalState() {
    return [this.unknownState, this.knownState];
  }
  toJSON() {
    const e = { ...this.unknownState }, n = {};
    for (const [r, i] of this.knownState) r.isEqual(i, r.defaultValue) ? delete e[r.key] : e[r.key] = r.unparse(i);
    for (const r of this.sharedNodeState.flatKeys) r in e && (n[r] = e[r], delete e[r]);
    return cw(e) && (n.$ = e), n;
  }
  getWritable(e) {
    if (this.node === e) return this;
    const { sharedNodeState: n, unknownState: r } = this, i = new Map(this.knownState);
    return new n0(e, n, function(o, s, a) {
      let l;
      if (a) for (const [c, u] of Object.entries(a)) {
        const f = o.get(c);
        f ? s.has(f) || s.set(f, f.parse(u)) : (l = l || {}, l[c] = u);
      }
      return l;
    }(n.sharedConfigMap, i, r), i, this.size);
  }
  updateFromKnown(e, n) {
    const r = e.key;
    this.sharedNodeState.sharedConfigMap.set(r, e);
    const { knownState: i, unknownState: o } = this;
    i.has(e) || o && r in o || (o && (delete o[r], this.unknownState = cw(o)), this.size++), i.set(e, n);
  }
  updateFromUnknown(e, n) {
    const r = this.sharedNodeState.sharedConfigMap.get(e);
    r ? this.updateFromKnown(r, r.parse(n)) : (this.unknownState = this.unknownState || {}, e in this.unknownState || this.size++, this.unknownState[e] = n);
  }
  updateFromJSON(e) {
    const { knownState: n } = this;
    for (const r of n.keys()) n.set(r, r.defaultValue);
    if (this.size = n.size, this.unknownState = void 0, e) for (const [r, i] of Object.entries(e)) this.updateFromUnknown(r, i);
  }
};
function r0(t) {
  const e = t.getWritable(), n = e.__state ? e.__state.getWritable(e) : new gk(e, i0(e));
  return e.__state = n, n;
}
function i0(t) {
  return t.__state ? t.__state.sharedNodeState : z0(Zu(), t.getType()).sharedNodeState;
}
function cw(t) {
  if (t) for (const e in t) return t;
}
function wk(t) {
  return t;
}
function uw(t, e, n) {
  for (const [r, i] of e.knownState) {
    if (t.has(r.key)) continue;
    t.add(r.key);
    const o = n ? n.getValue(r) : r.defaultValue;
    if (o !== i && !r.isEqual(o, i)) return !0;
  }
  return !1;
}
function dw(t, e, n) {
  const { unknownState: r } = e, i = n ? n.unknownState : void 0;
  if (r) {
    for (const [o, s] of Object.entries(r))
      if (!t.has(o) && (t.add(o), s !== (i ? i[o] : void 0)))
        return !0;
  }
  return !1;
}
function fw(t, e) {
  const n = t.__state;
  return n && n.node === t ? n.getWritable(e) : n;
}
function hw(t, e) {
  const n = t.__mode, r = t.__format, i = t.__style, o = e.__mode, s = e.__format, a = e.__style, l = t.__state, c = e.__state;
  return (n === null || n === o) && (r === null || r === s) && (i === null || i === a) && (t.__state === null || l === c || function(u, f) {
    if (u === f) return !0;
    if (u && f && u.size !== f.size) return !1;
    const d = /* @__PURE__ */ new Set();
    return !(u && uw(d, u, f) || f && uw(d, f, u) || u && dw(d, u, f) || f && dw(d, f, u));
  }(l, c));
}
function pw(t, e) {
  const n = t.mergeWithSibling(e), r = wt()._normalizedNodes;
  return r.add(t.__key), r.add(e.__key), n;
}
function gw(t) {
  let e, n, r = t;
  if (r.__text !== "" || !r.isSimpleText() || r.isUnmergeable()) {
    for (; (e = r.getPreviousSibling()) !== null && ie(e) && e.isSimpleText() && !e.isUnmergeable(); ) {
      if (e.__text !== "") {
        if (hw(e, r)) {
          r = pw(e, r);
          break;
        }
        break;
      }
      e.remove();
    }
    for (; (n = r.getNextSibling()) !== null && ie(n) && n.isSimpleText() && !n.isUnmergeable(); ) {
      if (n.__text !== "") {
        if (hw(r, n)) {
          r = pw(r, n);
          break;
        }
        break;
      }
      n.remove();
    }
  } else r.remove();
}
function ll(t) {
  return ww(t.anchor), ww(t.focus), t;
}
function ww(t) {
  for (; t.type === "element"; ) {
    const e = t.getNode(), n = t.offset;
    let r, i;
    if (n === e.getChildrenSize() ? (r = e.getChildAtIndex(n - 1), i = !0) : (r = e.getChildAtIndex(n), i = !1), ie(r)) {
      t.set(r.__key, i ? r.getTextContentSize() : 0, "text", !0);
      break;
    }
    if (!X(r)) break;
    t.set(r.__key, i ? r.getChildrenSize() : 0, "element", !0);
  }
}
let zi, vn, cl, zu, Bf, qf, Fo, wr, jf, ul, Rt = "", yn = "", $r = null, Fr = "", ci = "", o0 = !1, dl = !1, Ac = null;
function Xc(t, e) {
  const n = Fo.get(t);
  if (e !== null) {
    const r = Vf(t);
    r.parentNode === e && e.removeChild(r);
  }
  if (wr.has(t) || vn._keyToDOMMap.delete(t), X(n)) {
    const r = Qc(n, Fo);
    Uf(r, 0, r.length - 1, null);
  }
  n !== void 0 && Lp(ul, cl, zu, n, "destroyed");
}
function Uf(t, e, n, r) {
  let i = e;
  for (; i <= n; ++i) {
    const o = t[i];
    o !== void 0 && Xc(o, r);
  }
}
function ho(t, e) {
  t.setProperty("text-align", e);
}
const mk = "40px";
function s0(t, e) {
  const n = zi.theme.indent;
  if (typeof n == "string") {
    const i = t.classList.contains(n);
    e > 0 && !i ? t.classList.add(n) : e < 1 && i && t.classList.remove(n);
  }
  const r = getComputedStyle(t).getPropertyValue("--lexical-indent-base-value") || mk;
  t.style.setProperty("padding-inline-start", e === 0 ? "" : `calc(${e} * ${r})`);
}
function a0(t, e) {
  const n = t.style;
  e === 0 ? ho(n, "") : e === sp ? ho(n, "left") : e === ap ? ho(n, "center") : e === lp ? ho(n, "right") : e === cp ? ho(n, "justify") : e === up ? ho(n, "start") : e === dp && ho(n, "end");
}
function Yc(t, e) {
  const n = wr.get(t);
  n === void 0 && le(60);
  const r = n.createDOM(zi, vn);
  if (function(i, o, s) {
    const a = s._keyToDOMMap;
    (function(l, c, u) {
      const f = `__lexicalKey_${c._key}`;
      l[f] = u;
    })(o, s, i), a.set(i, o);
  }(t, r, vn), ie(n) ? r.setAttribute("data-lexical-text", "true") : Xe(n) && r.setAttribute("data-lexical-decorator", "true"), X(n)) {
    const i = n.__indent, o = n.__size;
    if (i !== 0 && s0(r, i), o !== 0) {
      const a = o - 1;
      (function(l, c, u, f) {
        const d = yn;
        yn = "", zf(l, u, 0, c, u.getDOMSlot(f)), c0(u, f), yn = d;
      })(Qc(n, wr), a, n, r);
    }
    const s = n.__format;
    s !== 0 && a0(r, s), n.isInline() || l0(null, n, r), Qu(n) && (Rt += mi, ci += mi);
  } else {
    const i = n.getTextContent();
    if (Xe(n)) {
      const o = n.decorate(vn, zi);
      o !== null && u0(t, o), r.contentEditable = "false";
    } else ie(n) && (n.isDirectionless() || (yn += i));
    Rt += i, ci += i;
  }
  return e !== null && e.insertChild(r), Lp(ul, cl, zu, n, "created"), r;
}
function zf(t, e, n, r, i) {
  const o = Rt;
  Rt = "";
  let s = n;
  for (; s <= r; ++s) {
    Yc(t[s], i);
    const a = wr.get(t[s]);
    a !== null && ie(a) && ($r === null && ($r = a.getFormat()), Fr === "" && (Fr = a.getStyle()));
  }
  Qu(e) && (Rt += mi), i.element.__lexicalTextContent = Rt, Rt = o + Rt;
}
function mw(t, e) {
  if (t) {
    const n = t.__last;
    if (n) {
      const r = e.get(n);
      if (r) return ko(r) ? "line-break" : Xe(r) && r.isInline() ? "decorator" : null;
    }
    return "empty";
  }
  return null;
}
function l0(t, e, n) {
  const r = mw(t, Fo), i = mw(e, wr);
  r !== i && e.getDOMSlot(n).setManagedLineBreak(i);
}
function c0(t, e) {
  const n = e.__lexicalDirTextContent || "", r = e.__lexicalDir || "";
  if (n !== yn || r !== Ac) {
    const i = yn === "", o = i ? Ac : function(s) {
      return nk.test(s) ? "rtl" : rk.test(s) ? "ltr" : null;
    }(yn);
    if (o !== r) {
      const s = e.classList, a = zi.theme;
      let l = r !== null ? a[r] : void 0, c = o !== null ? a[o] : void 0;
      if (l !== void 0) {
        if (typeof l == "string") {
          const u = Wc(l);
          l = a[r] = u;
        }
        s.remove(...l);
      }
      if (o === null || i && o === "ltr") e.removeAttribute("dir");
      else {
        if (c !== void 0) {
          if (typeof c == "string") {
            const u = Wc(c);
            c = a[o] = u;
          }
          c !== void 0 && s.add(...c);
        }
        e.dir = o;
      }
      dl || (t.getWritable().__dir = o);
    }
    Ac = o, e.__lexicalDirTextContent = yn, e.__lexicalDir = o;
  }
}
function bk(t, e, n) {
  const r = yn;
  var i;
  yn = "", $r = null, Fr = "", function(o, s, a) {
    const l = Rt, c = o.__size, u = s.__size;
    Rt = "";
    const f = a.element;
    if (c === 1 && u === 1) {
      const d = o.__first, h = s.__first;
      if (d === h) qa(d, f);
      else {
        const w = Vf(d), b = Yc(h, null);
        try {
          f.replaceChild(b, w);
        } catch (_) {
          if (typeof _ == "object" && _ != null) {
            const y = `${_.toString()} Parent: ${f.tagName}, new child: {tag: ${b.tagName} key: ${h}}, old child: {tag: ${w.tagName}, key: ${d}}.`;
            throw new Error(y);
          }
          throw _;
        }
        Xc(d, null);
      }
      const g = wr.get(h);
      ie(g) && ($r === null && ($r = g.getFormat()), Fr === "" && (Fr = g.getStyle()));
    } else {
      const d = Qc(o, Fo), h = Qc(s, wr);
      if (d.length !== c && le(227), h.length !== u && le(228), c === 0) u !== 0 && zf(h, s, 0, u - 1, a);
      else if (u === 0) {
        if (c !== 0) {
          const g = a.after == null && a.before == null && a.element.__lexicalLineBreak == null;
          Uf(d, 0, c - 1, g ? null : f), g && (f.textContent = "");
        }
      } else (function(g, w, b, _, y, C) {
        const D = _ - 1, P = y - 1;
        let S, L, O = C.getFirstChild(), M = 0, F = 0;
        for (; M <= D && F <= P; ) {
          const N = w[M], R = b[F];
          if (N === R) O = zd(qa(R, C.element)), M++, F++;
          else {
            S === void 0 && (S = new Set(w)), L === void 0 && (L = new Set(b));
            const A = L.has(N), q = S.has(R);
            if (A) if (q) {
              const V = Us(vn, R);
              V === O ? O = zd(qa(R, C.element)) : (C.withBefore(O).insertChild(V), qa(R, C.element)), M++, F++;
            } else Yc(R, C.withBefore(O)), F++;
            else O = zd(Vf(N)), Xc(N, C.element), M++;
          }
          const T = wr.get(R);
          T !== null && ie(T) && ($r === null && ($r = T.getFormat()), Fr === "" && (Fr = T.getStyle()));
        }
        const k = M > D, I = F > P;
        if (k && !I) {
          const N = b[P + 1], R = N === void 0 ? null : vn.getElementByKey(N);
          zf(b, g, F, P, C.withBefore(R));
        } else I && !k && Uf(w, M, D, C.element);
      })(s, d, h, c, u, a);
    }
    Qu(s) && (Rt += mi), f.__lexicalTextContent = Rt, Rt = l + Rt;
  }(t, e, e.getDOMSlot(n)), c0(e, n), i = e, $r == null || $r === i.__textFormat || dl || i.setTextFormat($r), function(o) {
    Fr === "" || Fr === o.__textStyle || dl || o.setTextStyle(Fr);
  }(e), yn = r;
}
function Qc(t, e) {
  const n = [];
  let r = t.__first;
  for (; r !== null; ) {
    const i = e.get(r);
    i === void 0 && le(101), n.push(r), r = i.__next;
  }
  return n;
}
function qa(t, e) {
  const n = Fo.get(t);
  let r = wr.get(t);
  n !== void 0 && r !== void 0 || le(61);
  const i = o0 || qf.has(t) || Bf.has(t), o = Us(vn, t);
  if (n === r && !i) {
    if (X(n)) {
      const s = o.__lexicalTextContent;
      s !== void 0 && (Rt += s, ci += s);
      const a = o.__lexicalDirTextContent;
      a !== void 0 && (yn += a);
    } else {
      const s = n.getTextContent();
      ie(n) && !n.isDirectionless() && (yn += s), ci += s, Rt += s;
    }
    return o;
  }
  if (n !== r && i && Lp(ul, cl, zu, r, "updated"), r.updateDOM(n, o, zi)) {
    const s = Yc(t, null);
    return e === null && le(62), e.replaceChild(s, o), Xc(t, null), s;
  }
  if (X(n) && X(r)) {
    const s = r.__indent;
    s !== n.__indent && s0(o, s);
    const a = r.__format;
    a !== n.__format && a0(o, a), i && (bk(n, r, o), tn(r) || r.isInline() || l0(n, r, o)), Qu(r) && (Rt += mi, ci += mi);
  } else {
    const s = r.getTextContent();
    if (Xe(r)) {
      const a = r.decorate(vn, zi);
      a !== null && u0(t, a);
    } else ie(r) && !r.isDirectionless() && (yn += s);
    Rt += s, ci += s;
  }
  if (!dl && tn(r) && r.__cachedText !== ci) {
    const s = r.getWritable();
    s.__cachedText = ci, r = s;
  }
  return o;
}
function u0(t, e) {
  let n = vn._pendingDecorators;
  const r = vn._decorators;
  if (n === null) {
    if (r[t] === e) return;
    n = K0(vn);
  }
  n[t] = e;
}
function zd(t) {
  let e = t.nextSibling;
  return e !== null && e === vn._blockCursorElement && (e = e.nextSibling), e;
}
function yk(t, e, n, r, i, o) {
  Rt = "", ci = "", yn = "", o0 = r === Ls, Ac = null, vn = n, zi = n._config, cl = n._nodes, zu = vn._listeners.mutation, Bf = i, qf = o, Fo = t._nodeMap, wr = e._nodeMap, dl = e._readOnly, jf = new Map(n._keyToDOMMap);
  const s = /* @__PURE__ */ new Map();
  return ul = s, qa("root", null), vn = void 0, cl = void 0, Bf = void 0, qf = void 0, Fo = void 0, wr = void 0, zi = void 0, jf = void 0, ul = void 0, s;
}
function Vf(t) {
  const e = jf.get(t);
  return e === void 0 && le(75, t), e;
}
function Se(t) {
  return { type: t };
}
const Yi = Se("SELECTION_CHANGE_COMMAND"), vk = Se("SELECTION_INSERT_CLIPBOARD_NODES_COMMAND"), d0 = Se("CLICK_COMMAND"), Hr = Se("DELETE_CHARACTER_COMMAND"), Fi = Se("INSERT_LINE_BREAK_COMMAND"), fl = Se("INSERT_PARAGRAPH_COMMAND"), Co = Se("CONTROLLED_TEXT_INSERTION_COMMAND"), es = Se("PASTE_COMMAND"), Zc = Se("REMOVE_TEXT_COMMAND"), Fs = Se("DELETE_WORD_COMMAND"), Bs = Se("DELETE_LINE_COMMAND"), Ri = Se("FORMAT_TEXT_COMMAND"), Ol = Se("UNDO_COMMAND"), Il = Se("REDO_COMMAND"), ua = Se("KEYDOWN_COMMAND"), hp = Se("KEY_ARROW_RIGHT_COMMAND"), _k = Se("MOVE_TO_END"), pp = Se("KEY_ARROW_LEFT_COMMAND"), xk = Se("MOVE_TO_START"), gp = Se("KEY_ARROW_UP_COMMAND"), wp = Se("KEY_ARROW_DOWN_COMMAND"), qs = Se("KEY_ENTER_COMMAND"), f0 = Se("KEY_SPACE_COMMAND"), mp = Se("KEY_BACKSPACE_COMMAND"), Vu = Se("KEY_ESCAPE_COMMAND"), bp = Se("KEY_DELETE_COMMAND"), yp = Se("KEY_TAB_COMMAND"), Ck = Se("INSERT_TAB_COMMAND"), kk = Se("INDENT_CONTENT_COMMAND"), bw = Se("OUTDENT_CONTENT_COMMAND"), Hu = Se("DROP_COMMAND"), Ek = Se("FORMAT_ELEMENT_COMMAND"), vp = Se("DRAGSTART_COMMAND"), h0 = Se("DRAGOVER_COMMAND"), Nk = Se("DRAGEND_COMMAND"), Qi = Se("COPY_COMMAND"), ts = Se("CUT_COMMAND"), eu = Se("SELECT_ALL_COMMAND"), _p = Se("CLEAR_EDITOR_COMMAND"), p0 = Se("CLEAR_HISTORY_COMMAND"), ja = Se("CAN_REDO_COMMAND"), Ua = Se("CAN_UNDO_COMMAND"), Sk = Se("FOCUS_COMMAND"), Tk = Se("BLUR_COMMAND"), Ak = Se("KEY_MODIFIER_COMMAND"), ii = Object.freeze({}), Hf = 30, Kf = [["keydown", function(t, e) {
  if (Ja = t.timeStamp, g0 = t.key, !e.isComposing() && !ge(e, ua, t) && t.key != null) {
    if (Vd && Kw(t)) return Wn(e, () => {
      cc(e, Hd);
    }), Vd = !1, void (Hd = "");
    if (function(n) {
      return et(n, "ArrowRight", { shiftKey: "any" });
    }(t)) ge(e, hp, t);
    else if (function(n) {
      return et(n, "ArrowRight", ai);
    }(t)) ge(e, _k, t);
    else if (function(n) {
      return et(n, "ArrowLeft", { shiftKey: "any" });
    }(t)) ge(e, pp, t);
    else if (function(n) {
      return et(n, "ArrowLeft", ai);
    }(t)) ge(e, xk, t);
    else if (function(n) {
      return et(n, "ArrowUp", { altKey: "any", shiftKey: "any" });
    }(t)) ge(e, gp, t);
    else if (function(n) {
      return et(n, "ArrowDown", { altKey: "any", shiftKey: "any" });
    }(t)) ge(e, wp, t);
    else if (function(n) {
      return et(n, "Enter", { altKey: "any", ctrlKey: "any", metaKey: "any", shiftKey: !0 });
    }(t)) Xa = !0, ge(e, qs, t);
    else if (function(n) {
      return n.key === " ";
    }(t)) ge(e, f0, t);
    else if (function(n) {
      return qr && et(n, "o", { ctrlKey: !0 });
    }(t)) t.preventDefault(), Xa = !0, ge(e, Fi, !0);
    else if (function(n) {
      return et(n, "Enter", { altKey: "any", ctrlKey: "any", metaKey: "any" });
    }(t)) Xa = !1, ge(e, qs, t);
    else if (function(n) {
      return et(n, "Backspace", { shiftKey: "any" }) || qr && et(n, "h", { ctrlKey: !0 });
    }(t)) Kw(t) ? ge(e, mp, t) : (t.preventDefault(), ge(e, Hr, !0));
    else if (function(n) {
      return n.key === "Escape";
    }(t)) ge(e, Vu, t);
    else if (function(n) {
      return et(n, "Delete", {}) || qr && et(n, "d", { ctrlKey: !0 });
    }(t)) (function(n) {
      return n.key === "Delete";
    })(t) ? ge(e, bp, t) : (t.preventDefault(), ge(e, Hr, !1));
    else if (function(n) {
      return et(n, "Backspace", Hw);
    }(t)) t.preventDefault(), ge(e, Fs, !0);
    else if (function(n) {
      return et(n, "Delete", Hw);
    }(t)) t.preventDefault(), ge(e, Fs, !1);
    else if (function(n) {
      return qr && et(n, "Backspace", { metaKey: !0 });
    }(t)) t.preventDefault(), ge(e, Bs, !0);
    else if (function(n) {
      return qr && (et(n, "Delete", { metaKey: !0 }) || et(n, "k", { ctrlKey: !0 }));
    }(t)) t.preventDefault(), ge(e, Bs, !1);
    else if (function(n) {
      return et(n, "b", ai);
    }(t)) t.preventDefault(), ge(e, Ri, "bold");
    else if (function(n) {
      return et(n, "u", ai);
    }(t)) t.preventDefault(), ge(e, Ri, "underline");
    else if (function(n) {
      return et(n, "i", ai);
    }(t)) t.preventDefault(), ge(e, Ri, "italic");
    else if (function(n) {
      return et(n, "Tab", { shiftKey: "any" });
    }(t)) ge(e, yp, t);
    else if (function(n) {
      return et(n, "z", ai);
    }(t)) t.preventDefault(), ge(e, Ol, void 0);
    else if (function(n) {
      return qr ? et(n, "z", { metaKey: !0, shiftKey: !0 }) : et(n, "y", { ctrlKey: !0 }) || et(n, "z", { ctrlKey: !0, shiftKey: !0 });
    }(t)) t.preventDefault(), ge(e, Il, void 0);
    else {
      const n = e._editorState._selection;
      n === null || Z(n) ? Ww(t) && (t.preventDefault(), ge(e, eu, t)) : function(r) {
        return et(r, "c", ai);
      }(t) ? (t.preventDefault(), ge(e, Qi, t)) : function(r) {
        return et(r, "x", ai);
      }(t) ? (t.preventDefault(), ge(e, ts, t)) : Ww(t) && (t.preventDefault(), ge(e, eu, t));
    }
    (function(n) {
      return n.ctrlKey || n.shiftKey || n.altKey || n.metaKey;
    })(t) && ge(e, Ak, t);
  }
}], ["pointerdown", function(t, e) {
  const n = t.target, r = t.pointerType;
  is(n) && r !== "touch" && r !== "pen" && t.button === 0 && Wn(e, () => {
    Uw(n) || (Gf = !0);
  });
}], ["compositionstart", function(t, e) {
  Wn(e, () => {
    const n = oe();
    if (Z(n) && !e.isComposing()) {
      const r = n.anchor, i = n.anchor.getNode();
      en(r.key), (t.timeStamp < Ja + Hf || r.type === "element" || !n.isCollapsed() || i.getFormat() !== n.format || ie(i) && i.getStyle() !== n.style) && ge(e, Co, tk);
    }
  });
}], ["compositionend", function(t, e) {
  Lo ? Oa = !0 : Ps || !al && !Kc ? Wn(e, () => {
    cc(e, t.data);
  }) : (Vd = !0, Hd = t.data);
}], ["input", function(t, e) {
  t.stopPropagation(), Wn(e, () => {
    if (it(t.target) && Uw(t.target)) return;
    const n = oe(), r = t.data, i = v0(t);
    if (r != null && Z(n) && b0(n, i, r, t.timeStamp, !1)) {
      Oa && (cc(e, r), Oa = !1);
      const o = n.anchor.getNode(), s = vr(or(e));
      if (s === null) return;
      const a = n.isBackward(), l = a ? n.anchor.offset : n.focus.offset, c = a ? n.focus.offset : n.anchor.offset;
      Hc && !n.isCollapsed() && ie(o) && s.anchorNode !== null && o.getTextContent().slice(0, l) + r + o.getTextContent().slice(l + c) === X0(s.anchorNode) || ge(e, Co, r);
      const u = r.length;
      Lo && u > 1 && t.inputType === "insertCompositionText" && !e.isComposing() && (n.anchor.offset -= u), al || Ps || Kc || !e.isComposing() || (Ja = 0, en(null));
    } else
      Rp(!1, e, r !== null ? r : void 0), Oa && (cc(e, r || void 0), Oa = !1);
    (function() {
      Zt();
      const o = wt();
      Zy(o);
    })();
  }, { event: t }), ws = null;
}], ["click", function(t, e) {
  Wn(e, () => {
    const n = oe(), r = vr(or(e)), i = fa();
    if (r) {
      if (Z(n)) {
        const o = n.anchor, s = o.getNode();
        if (o.type === "element" && o.offset === 0 && n.isCollapsed() && !tn(s) && Ve().getChildrenSize() === 1 && s.getTopLevelElementOrThrow().isEmpty() && i !== null && n.is(i)) r.removeAllRanges(), n.dirty = !0;
        else if (t.detail === 3 && !n.isCollapsed() && s !== n.focus.getNode()) {
          const a = function(l, c) {
            let u = l;
            for (; u !== Ve() && u != null; ) {
              if (c(u)) return u;
              u = u.getParent();
            }
            return null;
          }(s, (l) => X(l) && !l.isInline());
          X(a) && a.select(0);
        }
      } else if (t.pointerType === "touch" || t.pointerType === "pen") {
        const o = r.anchorNode;
        (it(o) || ki(o)) && sn(Cp(i, r, e, t));
      }
    }
    ge(e, d0, t);
  });
}], ["cut", ii], ["copy", ii], ["dragstart", ii], ["dragover", ii], ["dragend", ii], ["paste", ii], ["focus", ii], ["blur", ii], ["drop", ii]];
Hc && Kf.push(["beforeinput", (t, e) => function(n, r) {
  const i = n.inputType, o = v0(n);
  i === "deleteCompositionText" || Lo && Q0(r) || i !== "insertCompositionText" && Wn(r, () => {
    const s = oe();
    if (i === "deleteContentBackward") {
      if (s === null) {
        const h = fa();
        if (!Z(h)) return;
        sn(h.clone());
      }
      if (Z(s)) {
        const h = s.anchor.key === s.focus.key;
        if (a = n.timeStamp, g0 === "MediaLast" && a < Ja + Hf && r.isComposing() && h) {
          if (en(null), Ja = 0, setTimeout(() => {
            Wn(r, () => {
              en(null);
            });
          }, Hf), Z(s)) {
            const g = s.anchor.getNode();
            g.markDirty(), ie(g) || le(142), y0(s, g);
          }
        } else {
          en(null), n.preventDefault();
          const g = s.anchor.getNode(), w = g.getTextContent(), b = g.canInsertTextAfter(), _ = s.anchor.offset === 0 && s.focus.offset === w.length;
          let y = sw && h && !_ && b;
          if (y && s.isCollapsed() && (y = !Xe(eh(s.anchor, !0))), !y) {
            ge(r, Hr, !0);
            const C = oe();
            sw && Z(C) && C.isCollapsed() && (yo = C, setTimeout(() => yo = null));
          }
        }
        return;
      }
    }
    var a;
    if (!Z(s)) return;
    const l = n.data;
    ws !== null && Rp(!1, r, ws), s.dirty && ws === null || !s.isCollapsed() || tn(s.anchor.getNode()) || o === null || s.applyDOMRange(o), ws = null;
    const c = s.anchor, u = s.focus, f = c.getNode(), d = u.getNode();
    if (i !== "insertText" && i !== "insertTranspose") switch (n.preventDefault(), i) {
      case "insertFromYank":
      case "insertFromDrop":
      case "insertReplacementText":
        ge(r, Co, n);
        break;
      case "insertFromComposition":
        en(null), ge(r, Co, n);
        break;
      case "insertLineBreak":
        en(null), ge(r, Fi, !1);
        break;
      case "insertParagraph":
        en(null), Xa && !Ps ? (Xa = !1, ge(r, Fi, !1)) : ge(r, fl, void 0);
        break;
      case "insertFromPaste":
      case "insertFromPasteAsQuotation":
        ge(r, es, n);
        break;
      case "deleteByComposition":
        (function(h, g) {
          return h !== g || X(h) || X(g) || !No(h) || !No(g);
        })(f, d) && ge(r, Zc, n);
        break;
      case "deleteByDrag":
      case "deleteByCut":
        ge(r, Zc, n);
        break;
      case "deleteContent":
        ge(r, Hr, !1);
        break;
      case "deleteWordBackward":
        ge(r, Fs, !0);
        break;
      case "deleteWordForward":
        ge(r, Fs, !1);
        break;
      case "deleteHardLineBackward":
      case "deleteSoftLineBackward":
        ge(r, Bs, !0);
        break;
      case "deleteContentForward":
      case "deleteHardLineForward":
      case "deleteSoftLineForward":
        ge(r, Bs, !1);
        break;
      case "formatStrikeThrough":
        ge(r, Ri, "strikethrough");
        break;
      case "formatBold":
        ge(r, Ri, "bold");
        break;
      case "formatItalic":
        ge(r, Ri, "italic");
        break;
      case "formatUnderline":
        ge(r, Ri, "underline");
        break;
      case "historyUndo":
        ge(r, Ol, void 0);
        break;
      case "historyRedo":
        ge(r, Il, void 0);
    }
    else {
      if (l === `
`) n.preventDefault(), ge(r, Fi, !1);
      else if (l === mi) n.preventDefault(), ge(r, fl, void 0);
      else if (l == null && n.dataTransfer) {
        const h = n.dataTransfer.getData("text/plain");
        n.preventDefault(), s.insertRawText(h);
      } else l != null && b0(s, o, l, n.timeStamp, !0) ? (n.preventDefault(), ge(r, Co, l)) : ws = l;
      w0 = n.timeStamp;
    }
  });
}(t, e)]);
let Ja = 0, g0 = null, w0 = 0, ws = null;
const tu = /* @__PURE__ */ new WeakMap();
let Wf = !1, Gf = !1, Xa = !1, Oa = !1, Vd = !1, Hd = "", yo = null, m0 = [0, "", 0, "root", 0];
function b0(t, e, n, r, i) {
  const o = t.anchor, s = t.focus, a = o.getNode(), l = wt(), c = vr(or(l)), u = c !== null ? c.anchorNode : null, f = o.key, d = l.getElementByKey(f), h = n.length;
  return f !== s.key || !ie(a) || (!i && (!Hc || w0 < r + 50) || a.isDirty() && h < 2 || G0(n)) && o.offset !== s.offset && !a.isComposing() || li(a) || a.isDirty() && h > 1 || (i || !Hc) && d !== null && !a.isComposing() && u !== js(d) || c !== null && e !== null && (!e.collapsed || e.startContainer !== c.anchorNode || e.startOffset !== c.anchorOffset) || a.getFormat() !== t.format || a.getStyle() !== t.style || function(g, w) {
    if (w.isSegmented()) return !0;
    if (!g.isCollapsed()) return !1;
    const b = g.anchor.offset, _ = w.getParentOrThrow(), y = No(w);
    return b === 0 ? !w.canInsertTextBefore() || !_.canInsertTextBefore() && !w.isComposing() || y || function(C) {
      const D = C.getPreviousSibling();
      return (ie(D) || X(D) && D.isInline()) && !D.canInsertTextAfter();
    }(w) : b === w.getTextContentSize() && (!w.canInsertTextAfter() || !_.canInsertTextAfter() && !w.isComposing() || y);
  }(t, a);
}
function yw(t, e) {
  return ki(t) && t.nodeValue !== null && e !== 0 && e !== t.nodeValue.length;
}
function vw(t, e, n) {
  const { anchorNode: r, anchorOffset: i, focusNode: o, focusOffset: s } = t;
  Wf && (Wf = !1, yw(r, i) && yw(o, s) && !yo) || Wn(e, () => {
    if (!n) return void sn(null);
    if (!Fl(e, r, o)) return;
    let a = oe();
    if (yo && Z(a) && a.isCollapsed()) {
      const l = a.anchor, c = yo.anchor;
      (l.key === c.key && l.offset === c.offset + 1 || l.offset === 1 && c.getNode().is(l.getNode().getPreviousSibling())) && (a = yo.clone(), sn(a));
    }
    if (yo = null, Z(a)) {
      const l = a.anchor, c = l.getNode();
      if (a.isCollapsed()) {
        t.type === "Range" && t.anchorNode === t.focusNode && (a.dirty = !0);
        const u = or(e).event, f = u ? u.timeStamp : performance.now(), [d, h, g, w, b] = m0, _ = Ve(), y = e.isComposing() === !1 && _.getTextContent() === "";
        if (f < b + 200 && l.offset === g && l.key === w) Dc(a, d, h);
        else if (l.type === "text") ie(c) || le(141), y0(a, c);
        else if (l.type === "element" && !y) {
          X(c) || le(259);
          const C = l.getNode();
          C.isEmpty() ? function(D, P) {
            const S = P.getTextFormat(), L = P.getTextStyle();
            Dc(D, S, L);
          }(a, C) : Dc(a, 0, "");
        }
      } else {
        const u = l.key, f = a.focus.key, d = a.getNodes(), h = d.length, g = a.isBackward(), w = g ? s : i, b = g ? i : s, _ = g ? f : u, y = g ? u : f;
        let C = ek, D = !1;
        for (let P = 0; P < h; P++) {
          const S = d[P], L = S.getTextContentSize();
          if (ie(S) && L !== 0 && !(P === 0 && S.__key === _ && w === L || P === h - 1 && S.__key === y && b === 0) && (D = !0, C &= S.getFormat(), C === 0)) break;
        }
        a.format = D ? C : 0;
      }
    }
    ge(e, Yi, void 0);
  });
}
function Dc(t, e, n) {
  t.format === e && t.style === n || (t.format = e, t.style = n, t.dirty = !0);
}
function y0(t, e) {
  Dc(t, e.getFormat(), e.getStyle());
}
function v0(t) {
  if (!t.getTargetRanges) return null;
  const e = t.getTargetRanges();
  return e.length === 0 ? null : e[0];
}
function cc(t, e) {
  const n = t._compositionKey;
  if (en(null), n !== null && e != null) {
    if (e === "") {
      const r = Oe(n), i = js(t.getElementByKey(n));
      return void (i !== null && i.nodeValue !== null && ie(r) && Pp(r, i.nodeValue, null, null, !0));
    }
    if (e[e.length - 1] === `
`) {
      const r = oe();
      if (Z(r)) {
        const i = r.focus;
        return r.anchor.set(i.key, i.offset, i.type), void ge(t, qs, null);
      }
    }
  }
  Rp(!0, t, e);
}
function _0(t) {
  let e = t.__lexicalEventHandles;
  return e === void 0 && (e = [], t.__lexicalEventHandles = e), e;
}
const Cs = /* @__PURE__ */ new Map();
function x0(t) {
  const e = sE(t.target);
  if (e === null) return;
  const n = V0(e.anchorNode);
  if (n === null) return;
  Gf && (Gf = !1, Wn(n, () => {
    const l = fa(), c = e.anchorNode;
    (it(c) || ki(c)) && sn(Cp(l, e, n, t));
  }));
  const r = Ip(n), i = r[r.length - 1], o = i._key, s = Cs.get(o), a = s || i;
  a !== n && vw(e, a, !1), vw(e, n, !0), n !== i ? Cs.set(o, n) : s && Cs.delete(o);
}
function _w(t) {
  t._lexicalHandled = !0;
}
function xw(t) {
  return t._lexicalHandled === !0;
}
function Dk(t) {
  const e = t.ownerDocument, n = tu.get(e);
  if (n === void 0) return;
  const r = n - 1;
  r >= 0 || le(164), tu.set(e, r), r === 0 && e.removeEventListener("selectionchange", x0);
  const i = Xu(t);
  Op(i) ? (function(s) {
    if (s._parentEditor !== null) {
      const a = Ip(s), l = a[a.length - 1]._key;
      Cs.get(l) === s && Cs.delete(l);
    } else Cs.delete(s._key);
  }(i), t.__lexicalEditor = null) : i && le(198);
  const o = _0(t);
  for (let s = 0; s < o.length; s++) o[s]();
  t.__lexicalEventHandles = [];
}
function Jf(t, e, n) {
  Zt();
  const r = t.__key, i = t.getParent();
  if (i === null) return;
  const o = function(a) {
    const l = oe();
    if (!Z(l) || !X(a)) return l;
    const { anchor: c, focus: u } = l, f = c.getNode(), d = u.getNode();
    return th(f, a) && c.set(a.__key, 0, "element"), th(d, a) && u.set(a.__key, 0, "element"), l;
  }(t);
  let s = !1;
  if (Z(o) && e) {
    const a = o.anchor, l = o.focus;
    a.key === r && (ru(a, t, i, t.getPreviousSibling(), t.getNextSibling()), s = !0), l.key === r && (ru(l, t, i, t.getPreviousSibling(), t.getNextSibling()), s = !0);
  } else bn(o) && e && t.isSelected() && t.selectPrevious();
  if (Z(o) && e && !s) {
    const a = t.getIndexWithinParent();
    So(t), nu(o, i, a, -1);
  } else So(t);
  n || Zr(i) || i.canBeEmpty() || !i.isEmpty() || Jf(i, e), e && o && tn(i) && i.isEmpty() && i.selectEnd();
}
let da = class {
  static getType() {
    const { ownNodeType: e } = Bp(this);
    return e === void 0 && le(64, this.name), e;
  }
  static clone(e) {
    le(65, this.name);
  }
  $config() {
    return {};
  }
  config(e, n) {
    const r = n.extends || Object.getPrototypeOf(this.constructor);
    return Object.assign(n, { extends: r, type: e }), { [e]: n };
  }
  afterCloneFrom(e) {
    this.__key === e.__key ? (this.__parent = e.__parent, this.__next = e.__next, this.__prev = e.__prev, this.__state = e.__state) : e.__state && (this.__state = e.__state.getWritable(this));
  }
  constructor(e) {
    this.__type = this.constructor.getType(), this.__parent = null, this.__prev = null, this.__next = null, Object.defineProperty(this, "__state", { configurable: !0, enumerable: !1, value: void 0, writable: !0 }), Zk(this, e);
  }
  getType() {
    return this.__type;
  }
  isInline() {
    le(137, this.constructor.name);
  }
  isAttached() {
    let e = this.__key;
    for (; e !== null; ) {
      if (e === "root") return !0;
      const n = Oe(e);
      if (n === null) break;
      e = n.__parent;
    }
    return !1;
  }
  isSelected(e) {
    const n = e || oe();
    if (n == null) return !1;
    const r = n.getNodes().some((i) => i.__key === this.__key);
    if (ie(this)) return r;
    if (Z(n) && n.anchor.type === "element" && n.focus.type === "element") {
      if (n.isCollapsed()) return !1;
      const i = this.getParent();
      if (Xe(this) && this.isInline() && i) {
        const o = n.isBackward() ? n.focus : n.anchor;
        if (i.is(o.getNode()) && o.offset === i.getChildrenSize() && this.is(i.getLastChild())) return !1;
      }
    }
    return r;
  }
  getKey() {
    return this.__key;
  }
  getIndexWithinParent() {
    const e = this.getParent();
    if (e === null) return -1;
    let n = e.getFirstChild(), r = 0;
    for (; n !== null; ) {
      if (this.is(n)) return r;
      r++, n = n.getNextSibling();
    }
    return -1;
  }
  getParent() {
    const e = this.getLatest().__parent;
    return e === null ? null : Oe(e);
  }
  getParentOrThrow() {
    const e = this.getParent();
    return e === null && le(66, this.__key), e;
  }
  getTopLevelElement() {
    let e = this;
    for (; e !== null; ) {
      const n = e.getParent();
      if (Zr(n)) return X(e) || e === this && Xe(e) || le(194), e;
      e = n;
    }
    return null;
  }
  getTopLevelElementOrThrow() {
    const e = this.getTopLevelElement();
    return e === null && le(67, this.__key), e;
  }
  getParents() {
    const e = [];
    let n = this.getParent();
    for (; n !== null; ) e.push(n), n = n.getParent();
    return e;
  }
  getParentKeys() {
    const e = [];
    let n = this.getParent();
    for (; n !== null; ) e.push(n.__key), n = n.getParent();
    return e;
  }
  getPreviousSibling() {
    const e = this.getLatest().__prev;
    return e === null ? null : Oe(e);
  }
  getPreviousSiblings() {
    const e = [], n = this.getParent();
    if (n === null) return e;
    let r = n.getFirstChild();
    for (; r !== null && !r.is(this); ) e.push(r), r = r.getNextSibling();
    return e;
  }
  getNextSibling() {
    const e = this.getLatest().__next;
    return e === null ? null : Oe(e);
  }
  getNextSiblings() {
    const e = [];
    let n = this.getNextSibling();
    for (; n !== null; ) e.push(n), n = n.getNextSibling();
    return e;
  }
  getCommonAncestor(e) {
    const n = X(this) ? this : this.getParent(), r = X(e) ? e : e.getParent(), i = n && r ? Qa(n, r) : null;
    return i ? i.commonAncestor : null;
  }
  is(e) {
    return e != null && this.__key === e.__key;
  }
  isBefore(e) {
    const n = Qa(this, e);
    return n !== null && (n.type === "descendant" || (n.type === "branch" ? ov(n) === -1 : (n.type !== "same" && n.type !== "ancestor" && le(279), !1)));
  }
  isParentOf(e) {
    const n = Qa(this, e);
    return n !== null && n.type === "ancestor";
  }
  getNodesBetween(e) {
    const n = this.isBefore(e), r = [], i = /* @__PURE__ */ new Set();
    let o = this;
    for (; o !== null; ) {
      const s = o.__key;
      if (i.has(s) || (i.add(s), r.push(o)), o === e) break;
      const a = X(o) ? n ? o.getFirstChild() : o.getLastChild() : null;
      if (a !== null) {
        o = a;
        continue;
      }
      const l = n ? o.getNextSibling() : o.getPreviousSibling();
      if (l !== null) {
        o = l;
        continue;
      }
      const c = o.getParentOrThrow();
      if (i.has(c.__key) || r.push(c), c === e) break;
      let u = null, f = c;
      do {
        if (f === null && le(68), u = n ? f.getNextSibling() : f.getPreviousSibling(), f = f.getParent(), f === null) break;
        u !== null || i.has(f.__key) || r.push(f);
      } while (u === null);
      o = u;
    }
    return n || r.reverse(), r;
  }
  isDirty() {
    const e = wt()._dirtyLeaves;
    return e !== null && e.has(this.__key);
  }
  getLatest() {
    const e = Oe(this.__key);
    return e === null && le(113), e;
  }
  getWritable() {
    Zt();
    const e = Zi(), n = wt(), r = e._nodeMap, i = this.__key, o = this.getLatest(), s = n._cloneNotNeeded, a = oe();
    if (a !== null && a.setCachedNodes(null), s.has(i)) return ou(o), o;
    const l = Fp(o);
    return s.add(i), ou(l), r.set(i, l), l;
  }
  getTextContent() {
    return "";
  }
  getTextContentSize() {
    return this.getTextContent().length;
  }
  createDOM(e, n) {
    le(70);
  }
  updateDOM(e, n, r) {
    le(71);
  }
  exportDOM(e) {
    return { element: this.createDOM(e._config, e) };
  }
  exportJSON() {
    const e = this.__state ? this.__state.toJSON() : void 0;
    return { type: this.__type, version: 1, ...e };
  }
  static importJSON(e) {
    le(18, this.name);
  }
  updateFromJSON(e) {
    return function(n, r) {
      const i = n.getWritable(), o = r.$;
      let s = o;
      for (const a of i0(i).flatKeys) a in r && (s !== void 0 && s !== o || (s = { ...o }), s[a] = r[a]);
      return (i.__state || s) && r0(n).updateFromJSON(s), i;
    }(this, e);
  }
  static transform() {
    return null;
  }
  remove(e) {
    Jf(this, !0, e);
  }
  replace(e, n) {
    Zt();
    let r = oe();
    r !== null && (r = r.clone()), Yd(this, e);
    const i = this.getLatest(), o = this.__key, s = e.__key, a = e.getWritable(), l = this.getParentOrThrow().getWritable(), c = l.__size;
    So(a);
    const u = i.getPreviousSibling(), f = i.getNextSibling(), d = i.__prev, h = i.__next, g = i.__parent;
    if (Jf(i, !1, !0), u === null ? l.__first = s : u.getWritable().__next = s, a.__prev = d, f === null ? l.__last = s : f.getWritable().__prev = s, a.__next = h, a.__parent = g, l.__size = c, n && (X(this) && X(a) || le(139), this.getChildren().forEach((w) => {
      a.append(w);
    })), Z(r)) {
      sn(r);
      const w = r.anchor, b = r.focus;
      w.key === o && Nw(w, a), b.key === o && Nw(b, a);
    }
    return Pi() === o && en(s), a;
  }
  insertAfter(e, n = !0) {
    Zt(), Yd(this, e);
    const r = this.getWritable(), i = e.getWritable(), o = i.getParent(), s = oe();
    let a = !1, l = !1;
    if (o !== null) {
      const h = e.getIndexWithinParent();
      if (So(i), Z(s)) {
        const g = o.__key, w = s.anchor, b = s.focus;
        a = w.type === "element" && w.key === g && w.offset === h + 1, l = b.type === "element" && b.key === g && b.offset === h + 1;
      }
    }
    const c = this.getNextSibling(), u = this.getParentOrThrow().getWritable(), f = i.__key, d = r.__next;
    if (c === null ? u.__last = f : c.getWritable().__prev = f, u.__size++, r.__next = f, i.__next = d, i.__prev = r.__key, i.__parent = r.__parent, n && Z(s)) {
      const h = this.getIndexWithinParent();
      nu(s, u, h + 1);
      const g = u.__key;
      a && s.anchor.set(g, h + 2, "element"), l && s.focus.set(g, h + 2, "element");
    }
    return e;
  }
  insertBefore(e, n = !0) {
    Zt(), Yd(this, e);
    const r = this.getWritable(), i = e.getWritable(), o = i.__key;
    So(i);
    const s = this.getPreviousSibling(), a = this.getParentOrThrow().getWritable(), l = r.__prev, c = this.getIndexWithinParent();
    s === null ? a.__first = o : s.getWritable().__next = o, a.__size++, r.__prev = o, i.__prev = l, i.__next = r.__key, i.__parent = r.__parent;
    const u = oe();
    return n && Z(u) && nu(u, this.getParentOrThrow(), c), e;
  }
  isParentRequired() {
    return !1;
  }
  createParentElementNode() {
    return Jn();
  }
  selectStart() {
    return this.selectPrevious();
  }
  selectEnd() {
    return this.selectNext(0, 0);
  }
  selectPrevious(e, n) {
    Zt();
    const r = this.getPreviousSibling(), i = this.getParentOrThrow();
    if (r === null) return i.select(0, 0);
    if (X(r)) return r.select();
    if (!ie(r)) {
      const o = r.getIndexWithinParent() + 1;
      return i.select(o, o);
    }
    return r.select(e, n);
  }
  selectNext(e, n) {
    Zt();
    const r = this.getNextSibling(), i = this.getParentOrThrow();
    if (r === null) return i.select();
    if (X(r)) return r.select(0, 0);
    if (!ie(r)) {
      const o = r.getIndexWithinParent();
      return i.select(o, o);
    }
    return r.select(e, n);
  }
  markDirty() {
    this.getWritable();
  }
  reconcileObservedMutation(e, n) {
    this.markDirty();
  }
}, Rl = class C0 extends da {
  static getType() {
    return "linebreak";
  }
  static clone(e) {
    return new C0(e.__key);
  }
  constructor(e) {
    super(e);
  }
  getTextContent() {
    return `
`;
  }
  createDOM() {
    return document.createElement("br");
  }
  updateDOM() {
    return !1;
  }
  isInline() {
    return !0;
  }
  static importDOM() {
    return { br: (e) => function(n) {
      const r = n.parentElement;
      if (r !== null && su(r)) {
        const i = r.firstChild;
        if (i === n || i.nextSibling === n && uc(i)) {
          const o = r.lastChild;
          if (o === n || o.previousSibling === n && uc(o)) return !0;
        }
      }
      return !1;
    }(e) || function(n) {
      const r = n.parentElement;
      if (r !== null && su(r)) {
        const i = r.firstChild;
        if (i === n || i.nextSibling === n && uc(i)) return !1;
        const o = r.lastChild;
        if (o === n || o.previousSibling === n && uc(o)) return !0;
      }
      return !1;
    }(e) ? null : { conversion: Mk, priority: 0 } };
  }
  static importJSON(e) {
    return Bo().updateFromJSON(e);
  }
};
function Mk(t) {
  return { node: Bo() };
}
function Bo() {
  return lt(new Rl());
}
function ko(t) {
  return t instanceof Rl;
}
function uc(t) {
  return ki(t) && /^( |\t|\r?\n)+$/.test(t.textContent || "");
}
function Kd(t, e) {
  return 16 & e ? "code" : e & op ? "mark" : 32 & e ? "sub" : 64 & e ? "sup" : null;
}
function Wd(t, e) {
  return 1 & e ? "strong" : 2 & e ? "em" : "span";
}
function k0(t, e, n, r, i) {
  const o = r.classList;
  let s = Es(i, "base");
  s !== void 0 && o.add(...s), s = Es(i, "underlineStrikethrough");
  let a = !1;
  const l = e & Jc && e & Gc;
  s !== void 0 && (n & Jc && n & Gc ? (a = !0, l || o.add(...s)) : l && o.remove(...s));
  for (const c in Ui) {
    const u = Ui[c];
    if (s = Es(i, c), s !== void 0) if (n & u) {
      if (a && (c === "underline" || c === "strikethrough")) {
        e & u && o.remove(...s);
        continue;
      }
      e & u && (!l || c !== "underline") && c !== "strikethrough" || o.add(...s);
    } else e & u && o.remove(...s);
  }
}
function E0(t, e, n) {
  const r = e.firstChild, i = n.isComposing(), o = t + (i ? Uu : "");
  if (r == null) e.textContent = o;
  else {
    const s = r.nodeValue;
    if (s !== o) if (i || Lo) {
      const [a, l, c] = function(u, f) {
        const d = u.length, h = f.length;
        let g = 0, w = 0;
        for (; g < d && g < h && u[g] === f[g]; ) g++;
        for (; w + g < d && w + g < h && u[d - w - 1] === f[h - w - 1]; ) w++;
        return [g, d - g - w, f.slice(g, h - w)];
      }(s, o);
      l !== 0 && r.deleteData(a, l), r.insertData(a, c);
    } else r.nodeValue = o;
  }
}
function Cw(t, e, n, r, i, o) {
  E0(i, t, e);
  const s = o.theme.text;
  s !== void 0 && k0(0, 0, r, t, s);
}
function dc(t, e) {
  const n = document.createElement(e);
  return n.appendChild(t), n;
}
class _n extends da {
  static getType() {
    return "text";
  }
  static clone(e) {
    return new _n(e.__text, e.__key);
  }
  afterCloneFrom(e) {
    super.afterCloneFrom(e), this.__text = e.__text, this.__format = e.__format, this.__style = e.__style, this.__mode = e.__mode, this.__detail = e.__detail;
  }
  constructor(e = "", n) {
    super(n), this.__text = e, this.__format = 0, this.__style = "", this.__mode = 0, this.__detail = 0;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getDetail() {
    return this.getLatest().__detail;
  }
  getMode() {
    const e = this.getLatest();
    return ak[e.__mode];
  }
  getStyle() {
    return this.getLatest().__style;
  }
  isToken() {
    return this.getLatest().__mode === 1;
  }
  isComposing() {
    return this.__key === Pi();
  }
  isSegmented() {
    return this.getLatest().__mode === 2;
  }
  isDirectionless() {
    return !!(1 & this.getLatest().__detail);
  }
  isUnmergeable() {
    return !!(2 & this.getLatest().__detail);
  }
  hasFormat(e) {
    const n = Ui[e];
    return !!(this.getFormat() & n);
  }
  isSimpleText() {
    return this.__type === "text" && this.__mode === 0;
  }
  getTextContent() {
    return this.getLatest().__text;
  }
  getFormatFlags(e, n) {
    return iu(this.getLatest().__format, e, n);
  }
  canHaveFormat() {
    return !0;
  }
  isInline() {
    return !0;
  }
  createDOM(e, n) {
    const r = this.__format, i = Kd(0, r), o = Wd(0, r), s = i === null ? o : i, a = document.createElement(s);
    let l = a;
    this.hasFormat("code") && a.setAttribute("spellcheck", "false"), i !== null && (l = document.createElement(o), a.appendChild(l)), Cw(l, this, 0, r, this.__text, e);
    const c = this.__style;
    return c !== "" && (a.style.cssText = c), a;
  }
  updateDOM(e, n, r) {
    const i = this.__text, o = e.__format, s = this.__format, a = Kd(0, o), l = Kd(0, s), c = Wd(0, o), u = Wd(0, s);
    if ((a === null ? c : a) !== (l === null ? u : l)) return !0;
    if (a === l && c !== u) {
      const w = n.firstChild;
      w == null && le(48);
      const b = document.createElement(u);
      return Cw(b, this, 0, s, i, r), n.replaceChild(b, w), !1;
    }
    let f = n;
    l !== null && a !== null && (f = n.firstChild, f == null && le(49)), E0(i, f, this);
    const d = r.theme.text;
    d !== void 0 && o !== s && k0(0, o, s, f, d);
    const h = e.__style, g = this.__style;
    return h !== g && (n.style.cssText = g), !1;
  }
  static importDOM() {
    return { "#text": () => ({ conversion: Pk, priority: 0 }), b: () => ({ conversion: Ik, priority: 0 }), code: () => ({ conversion: oi, priority: 0 }), em: () => ({ conversion: oi, priority: 0 }), i: () => ({ conversion: oi, priority: 0 }), mark: () => ({ conversion: oi, priority: 0 }), s: () => ({ conversion: oi, priority: 0 }), span: () => ({ conversion: Ok, priority: 0 }), strong: () => ({ conversion: oi, priority: 0 }), sub: () => ({ conversion: oi, priority: 0 }), sup: () => ({ conversion: oi, priority: 0 }), u: () => ({ conversion: oi, priority: 0 }) };
  }
  static importJSON(e) {
    return Re().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setTextContent(e.text).setFormat(e.format).setDetail(e.detail).setMode(e.mode).setStyle(e.style);
  }
  exportDOM(e) {
    let { element: n } = super.exportDOM(e);
    return it(n) || le(132), n.style.whiteSpace = "pre-wrap", this.hasFormat("lowercase") ? n.style.textTransform = "lowercase" : this.hasFormat("uppercase") ? n.style.textTransform = "uppercase" : this.hasFormat("capitalize") && (n.style.textTransform = "capitalize"), this.hasFormat("bold") && (n = dc(n, "b")), this.hasFormat("italic") && (n = dc(n, "i")), this.hasFormat("strikethrough") && (n = dc(n, "s")), this.hasFormat("underline") && (n = dc(n, "u")), { element: n };
  }
  exportJSON() {
    return { detail: this.getDetail(), format: this.getFormat(), mode: this.getMode(), style: this.getStyle(), text: this.getTextContent(), ...super.exportJSON() };
  }
  selectionTransform(e, n) {
  }
  setFormat(e) {
    const n = this.getWritable();
    return n.__format = typeof e == "string" ? Ui[e] : e, n;
  }
  setDetail(e) {
    const n = this.getWritable();
    return n.__detail = typeof e == "string" ? ik[e] : e, n;
  }
  setStyle(e) {
    const n = this.getWritable();
    return n.__style = e, n;
  }
  toggleFormat(e) {
    const n = iu(this.getFormat(), e, null);
    return this.setFormat(n);
  }
  toggleDirectionless() {
    const e = this.getWritable();
    return e.__detail ^= 1, e;
  }
  toggleUnmergeable() {
    const e = this.getWritable();
    return e.__detail ^= 2, e;
  }
  setMode(e) {
    const n = sk[e];
    if (this.__mode === n) return this;
    const r = this.getWritable();
    return r.__mode = n, r;
  }
  setTextContent(e) {
    if (this.__text === e) return this;
    const n = this.getWritable();
    return n.__text = e, n;
  }
  select(e, n) {
    Zt();
    let r = e, i = n;
    const o = oe(), s = this.getTextContent(), a = this.__key;
    if (typeof s == "string") {
      const l = s.length;
      r === void 0 && (r = l), i === void 0 && (i = l);
    } else r = 0, i = 0;
    if (!Z(o)) return M0(a, r, a, i, "text", "text");
    {
      const l = Pi();
      l !== o.anchor.key && l !== o.focus.key || en(a), o.setTextNodeRange(this, r, this, i);
    }
    return o;
  }
  selectStart() {
    return this.select(0, 0);
  }
  selectEnd() {
    const e = this.getTextContentSize();
    return this.select(e, e);
  }
  spliceText(e, n, r, i) {
    const o = this.getWritable(), s = o.__text, a = r.length;
    let l = e;
    l < 0 && (l = a + l, l < 0 && (l = 0));
    const c = oe();
    if (i && Z(c)) {
      const f = e + a;
      c.setTextNodeRange(o, f, o, f);
    }
    const u = s.slice(0, l) + r + s.slice(l + n);
    return o.__text = u, o;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  splitText(...e) {
    Zt();
    const n = this.getLatest(), r = n.getTextContent();
    if (r === "") return [];
    const i = n.__key, o = Pi(), s = r.length;
    e.sort((O, M) => O - M), e.push(s);
    const a = [], l = e.length;
    for (let O = 0, M = 0; O < s && M <= l; M++) {
      const F = e[M];
      F > O && (a.push(r.slice(O, F)), O = F);
    }
    const c = a.length;
    if (c === 1) return [n];
    const u = a[0], f = n.getParent();
    let d;
    const h = n.getFormat(), g = n.getStyle(), w = n.__detail;
    let b = !1, _ = null, y = null;
    const C = oe();
    if (Z(C)) {
      const [O, M] = C.isBackward() ? [C.focus, C.anchor] : [C.anchor, C.focus];
      O.type === "text" && O.key === i && (_ = O), M.type === "text" && M.key === i && (y = M);
    }
    n.isSegmented() ? (d = Re(u), d.__format = h, d.__style = g, d.__detail = w, d.__state = fw(n, d), b = !0) : d = n.setTextContent(u);
    const D = [d];
    for (let O = 1; O < c; O++) {
      const M = Re(a[O]);
      M.__format = h, M.__style = g, M.__detail = w, M.__state = fw(n, M);
      const F = M.__key;
      o === i && en(F), D.push(M);
    }
    const P = _ ? _.offset : null, S = y ? y.offset : null;
    let L = 0;
    for (const O of D) {
      if (!_ && !y) break;
      const M = L + O.getTextContentSize();
      if (_ !== null && P !== null && P <= M && P >= L && (_.set(O.getKey(), P - L, "text"), P < M && (_ = null)), y !== null && S !== null && S <= M && S >= L) {
        y.set(O.getKey(), S - L, "text");
        break;
      }
      L = M;
    }
    if (f !== null) {
      (function(F) {
        const k = F.getPreviousSibling(), I = F.getNextSibling();
        k !== null && ou(k), I !== null && ou(I);
      })(this);
      const O = f.getWritable(), M = this.getIndexWithinParent();
      b ? (O.splice(M, 0, D), this.remove()) : O.splice(M, 1, D), Z(C) && nu(C, f, M, c - 1);
    }
    return D;
  }
  mergeWithSibling(e) {
    const n = e === this.getPreviousSibling();
    n || e === this.getNextSibling() || le(50);
    const r = this.__key, i = e.__key, o = this.__text, s = o.length;
    Pi() === i && en(r);
    const a = oe();
    if (Z(a)) {
      const f = a.anchor, d = a.focus;
      f !== null && f.key === i && Iw(f, n, r, e, s), d !== null && d.key === i && Iw(d, n, r, e, s);
    }
    const l = e.__text, c = n ? l + o : o + l;
    this.setTextContent(c);
    const u = this.getWritable();
    return e.remove(), u;
  }
  isTextEntity() {
    return !1;
  }
}
function Ok(t) {
  return { forChild: xp(t.style), node: null };
}
function Ik(t) {
  const e = t, n = e.style.fontWeight === "normal";
  return { forChild: xp(e.style, n ? void 0 : "bold"), node: null };
}
const kw = /* @__PURE__ */ new WeakMap();
function Rk(t) {
  if (!it(t)) return !1;
  if (t.nodeName === "PRE") return !0;
  const e = t.style.whiteSpace;
  return typeof e == "string" && e.startsWith("pre");
}
function Pk(t) {
  const e = t;
  t.parentElement === null && le(129);
  let n = e.textContent || "";
  if (function(r) {
    let i, o = r.parentNode;
    const s = [r];
    for (; o !== null && (i = kw.get(o)) === void 0 && !Rk(o); ) s.push(o), o = o.parentNode;
    const a = i === void 0 ? o : i;
    for (let l = 0; l < s.length; l++) kw.set(s[l], a);
    return a;
  }(e) !== null) {
    const r = n.split(/(\r?\n|\t)/), i = [], o = r.length;
    for (let s = 0; s < o; s++) {
      const a = r[s];
      a === `
` || a === `\r
` ? i.push(Bo()) : a === "	" ? i.push(Ll()) : a !== "" && i.push(Re(a));
    }
    return { node: i };
  }
  if (n = n.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), n === "") return { node: null };
  if (n[0] === " ") {
    let r = e, i = !0;
    for (; r !== null && (r = Ew(r, !1)) !== null; ) {
      const o = r.textContent || "";
      if (o.length > 0) {
        /[ \t\n]$/.test(o) && (n = n.slice(1)), i = !1;
        break;
      }
    }
    i && (n = n.slice(1));
  }
  if (n[n.length - 1] === " ") {
    let r = e, i = !0;
    for (; r !== null && (r = Ew(r, !0)) !== null; )
      if ((r.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
        i = !1;
        break;
      }
    i && (n = n.slice(0, n.length - 1));
  }
  return n === "" ? { node: null } : { node: Re(n) };
}
function Ew(t, e) {
  let n = t;
  for (; ; ) {
    let r;
    for (; (r = e ? n.nextSibling : n.previousSibling) === null; ) {
      const o = n.parentElement;
      if (o === null) return null;
      n = o;
    }
    if (n = r, it(n)) {
      const o = n.style.display;
      if (o === "" && !ih(n) || o !== "" && !o.startsWith("inline")) return null;
    }
    let i = n;
    for (; (i = e ? n.firstChild : n.lastChild) !== null; ) n = i;
    if (ki(n)) return n;
    if (n.nodeName === "BR") return null;
  }
}
const Lk = { code: "code", em: "italic", i: "italic", mark: "highlight", s: "strikethrough", strong: "bold", sub: "subscript", sup: "superscript", u: "underline" };
function oi(t) {
  const e = Lk[t.nodeName.toLowerCase()];
  return e === void 0 ? { node: null } : { forChild: xp(t.style, e), node: null };
}
function Re(t = "") {
  return lt(new _n(t));
}
function ie(t) {
  return t instanceof _n;
}
function xp(t, e) {
  const n = t.fontWeight, r = t.textDecoration.split(" "), i = n === "700" || n === "bold", o = r.includes("line-through"), s = t.fontStyle === "italic", a = r.includes("underline"), l = t.verticalAlign;
  return (c) => (ie(c) && (i && !c.hasFormat("bold") && c.toggleFormat("bold"), o && !c.hasFormat("strikethrough") && c.toggleFormat("strikethrough"), s && !c.hasFormat("italic") && c.toggleFormat("italic"), a && !c.hasFormat("underline") && c.toggleFormat("underline"), l !== "sub" || c.hasFormat("subscript") || c.toggleFormat("subscript"), l !== "super" || c.hasFormat("superscript") || c.toggleFormat("superscript"), e && !c.hasFormat(e) && c.toggleFormat(e)), c);
}
class Pl extends _n {
  static getType() {
    return "tab";
  }
  static clone(e) {
    return new Pl(e.__key);
  }
  constructor(e) {
    super("	", e), this.__detail = 2;
  }
  static importDOM() {
    return null;
  }
  createDOM(e) {
    const n = super.createDOM(e), r = Es(e.theme, "tab");
    return r !== void 0 && n.classList.add(...r), n;
  }
  static importJSON(e) {
    return Ll().updateFromJSON(e);
  }
  setTextContent(e) {
    return e !== "	" && e !== "" && le(126), super.setTextContent("	");
  }
  spliceText(e, n, r, i) {
    return r === "" && n === 0 || r === "	" && n === 1 || le(286), this;
  }
  setDetail(e) {
    return e !== 2 && le(127), this;
  }
  setMode(e) {
    return e !== "normal" && le(128), this;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
}
function Ll() {
  return lt(new Pl());
}
function N0(t) {
  return t instanceof Pl;
}
class $k {
  constructor(e, n, r) {
    this._selection = null, this.key = e, this.offset = n, this.type = r;
  }
  is(e) {
    return this.key === e.key && this.offset === e.offset && this.type === e.type;
  }
  isBefore(e) {
    return this.key === e.key ? this.offset < e.offset : iv(Vr(bi(this, "next")), Vr(bi(e, "next"))) < 0;
  }
  getNode() {
    const e = Oe(this.key);
    return e === null && le(20), e;
  }
  set(e, n, r, i) {
    const o = this._selection, s = this.key;
    i && this.key === e && this.offset === n && this.type === r || (this.key = e, this.offset = n, this.type = r, ha() || (Pi() === s && en(e), o !== null && (o.setCachedNodes(null), o.dirty = !0)));
  }
}
function On(t, e, n) {
  return new $k(t, e, n);
}
function Gd(t, e) {
  let n = e.__key, r = t.offset, i = "element";
  if (ie(e)) {
    i = "text";
    const o = e.getTextContentSize();
    r > o && (r = o);
  } else if (!X(e)) {
    const o = e.getNextSibling();
    if (ie(o)) n = o.__key, r = 0, i = "text";
    else {
      const s = e.getParent();
      s && (n = s.__key, r = e.getIndexWithinParent() + 1);
    }
  }
  t.set(n, r, i);
}
function Nw(t, e) {
  if (X(e)) {
    const n = e.getLastDescendant();
    X(n) || ie(n) ? Gd(t, n) : Gd(t, e);
  } else Gd(t, e);
}
let S0 = class T0 {
  constructor(e) {
    this._cachedNodes = null, this._nodes = e, this.dirty = !1;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(e) {
    this._cachedNodes = e;
  }
  is(e) {
    if (!bn(e)) return !1;
    const n = this._nodes, r = e._nodes;
    return n.size === r.size && Array.from(n).every((i) => r.has(i));
  }
  isCollapsed() {
    return !1;
  }
  isBackward() {
    return !1;
  }
  getStartEndPoints() {
    return null;
  }
  add(e) {
    this.dirty = !0, this._nodes.add(e), this._cachedNodes = null;
  }
  delete(e) {
    this.dirty = !0, this._nodes.delete(e), this._cachedNodes = null;
  }
  clear() {
    this.dirty = !0, this._nodes.clear(), this._cachedNodes = null;
  }
  has(e) {
    return this._nodes.has(e);
  }
  clone() {
    return new T0(new Set(this._nodes));
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(e) {
  }
  insertText() {
  }
  insertNodes(e) {
    const n = this.getNodes(), r = n.length, i = n[r - 1];
    let o;
    if (ie(i)) o = i.select();
    else {
      const s = i.getIndexWithinParent() + 1;
      o = i.getParentOrThrow().select(s, s);
    }
    o.insertNodes(e);
    for (let s = 0; s < r; s++) n[s].remove();
  }
  getNodes() {
    const e = this._cachedNodes;
    if (e !== null) return e;
    const n = this._nodes, r = [];
    for (const i of n) {
      const o = Oe(i);
      o !== null && r.push(o);
    }
    return ha() || (this._cachedNodes = r), r;
  }
  getTextContent() {
    const e = this.getNodes();
    let n = "";
    for (let r = 0; r < e.length; r++) n += e[r].getTextContent();
    return n;
  }
  deleteNodes() {
    const e = this.getNodes();
    if ((oe() || fa()) === this && e[0]) {
      const n = $t(e[0], "next");
      vE(Hi(n, n));
    }
    for (const n of e) n.remove();
  }
};
function Z(t) {
  return t instanceof ns;
}
class ns {
  constructor(e, n, r, i) {
    this.anchor = e, this.focus = n, e._selection = this, n._selection = this, this._cachedNodes = null, this.format = r, this.style = i, this.dirty = !1;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(e) {
    this._cachedNodes = e;
  }
  is(e) {
    return !!Z(e) && this.anchor.is(e.anchor) && this.focus.is(e.focus) && this.format === e.format && this.style === e.style;
  }
  isCollapsed() {
    return this.anchor.is(this.focus);
  }
  getNodes() {
    const e = this._cachedNodes;
    if (e !== null) return e;
    const n = function(r) {
      const i = [], [o, s] = r.getTextSlices();
      o && i.push(o.caret.origin);
      const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
      for (const c of r) if (mr(c)) {
        const { origin: u } = c;
        i.length === 0 ? a.add(u) : (l.add(u), i.push(u));
      } else {
        const { origin: u } = c;
        X(u) && l.has(u) || i.push(u);
      }
      if (s && i.push(s.caret.origin), qo(r.focus) && X(r.focus.origin) && r.focus.getNodeAtCaret() === null) for (let c = _r(r.focus.origin, "previous"); mr(c) && a.has(c.origin) && !c.origin.isEmpty() && c.origin.is(i[i.length - 1]); c = hl(c)) a.delete(c.origin), i.pop();
      for (; i.length > 1; ) {
        const c = i[i.length - 1];
        if (!X(c) || l.has(c) || c.isEmpty() || a.has(c)) break;
        i.pop();
      }
      if (i.length === 0 && r.isCollapsed()) {
        const c = Vr(r.anchor), u = Vr(r.anchor.getFlipped()), f = (h) => Bi(h) ? h.origin : h.getNodeAtCaret(), d = f(c) || f(u) || (r.anchor.getNodeAtCaret() ? c.origin : u.origin);
        i.push(d);
      }
      return i;
    }(av(Zw(this), "next"));
    return ha() || (this._cachedNodes = n), n;
  }
  setTextNodeRange(e, n, r, i) {
    this.anchor.set(e.__key, n, "text"), this.focus.set(r.__key, i, "text");
  }
  getTextContent() {
    const e = this.getNodes();
    if (e.length === 0) return "";
    const n = e[0], r = e[e.length - 1], i = this.anchor, o = this.focus, s = i.isBefore(o), [a, l] = Xf(this);
    let c = "", u = !0;
    for (let f = 0; f < e.length; f++) {
      const d = e[f];
      if (X(d) && !d.isInline()) u || (c += `
`), u = !d.isEmpty();
      else if (u = !1, ie(d)) {
        let h = d.getTextContent();
        d === n ? d === r ? i.type === "element" && o.type === "element" && o.offset !== i.offset || (h = a < l ? h.slice(a, l) : h.slice(l, a)) : h = s ? h.slice(a) : h.slice(l) : d === r && (h = s ? h.slice(0, l) : h.slice(0, a)), c += h;
      } else !Xe(d) && !ko(d) || d === r && this.isCollapsed() || (c += d.getTextContent());
    }
    return c;
  }
  applyDOMRange(e) {
    const n = wt(), r = n.getEditorState()._selection, i = D0(e.startContainer, e.startOffset, e.endContainer, e.endOffset, n, r);
    if (i === null) return;
    const [o, s] = i;
    this.anchor.set(o.key, o.offset, o.type, !0), this.focus.set(s.key, s.offset, s.type, !0), ll(this);
  }
  clone() {
    const e = this.anchor, n = this.focus;
    return new ns(On(e.key, e.offset, e.type), On(n.key, n.offset, n.type), this.format, this.style);
  }
  toggleFormat(e) {
    this.format = iu(this.format, e, null), this.dirty = !0;
  }
  setFormat(e) {
    this.format = e, this.dirty = !0;
  }
  setStyle(e) {
    this.style = e, this.dirty = !0;
  }
  hasFormat(e) {
    const n = Ui[e];
    return !!(this.format & n);
  }
  insertRawText(e) {
    const n = e.split(/(\r?\n|\t)/), r = [], i = n.length;
    for (let o = 0; o < i; o++) {
      const s = n[o];
      s === `
` || s === `\r
` ? r.push(Bo()) : s === "	" ? r.push(Ll()) : r.push(Re(s));
    }
    this.insertNodes(r);
  }
  insertText(e) {
    const n = this.anchor, r = this.focus, i = this.format, o = this.style;
    let s = n, a = r;
    !this.isCollapsed() && r.isBefore(n) && (s = r, a = n), s.type === "element" && function(b, _, y, C) {
      const D = b.getNode(), P = D.getChildAtIndex(b.offset), S = Re(), L = tn(D) ? Jn().append(S) : S;
      S.setFormat(y), S.setStyle(C), P === null ? D.append(L) : P.insertBefore(L), b.is(_) && _.set(S.__key, 0, "text"), b.set(S.__key, 0, "text");
    }(s, a, i, o), a.type === "element" && pl(a, Vr(bi(a, "next")));
    const l = s.offset;
    let c = a.offset;
    const u = this.getNodes(), f = u.length;
    let d = u[0];
    ie(d) || le(26);
    const h = d.getTextContent().length, g = d.getParentOrThrow();
    let w = u[f - 1];
    if (f === 1 && a.type === "element" && (c = h, a.set(s.key, c, "text")), this.isCollapsed() && l === h && (li(d) || !d.canInsertTextAfter() || !g.canInsertTextAfter() && d.getNextSibling() === null)) {
      let b = d.getNextSibling();
      if (ie(b) && b.canInsertTextBefore() && !li(b) || (b = Re(), b.setFormat(i), b.setStyle(o), g.canInsertTextAfter() ? d.insertAfter(b) : g.insertAfter(b)), b.select(0, 0), d = b, e !== "") return void this.insertText(e);
    } else if (this.isCollapsed() && l === 0 && (li(d) || !d.canInsertTextBefore() || !g.canInsertTextBefore() && d.getPreviousSibling() === null)) {
      let b = d.getPreviousSibling();
      if (ie(b) && !li(b) || (b = Re(), b.setFormat(i), g.canInsertTextBefore() ? d.insertBefore(b) : g.insertBefore(b)), b.select(), d = b, e !== "") return void this.insertText(e);
    } else if (d.isSegmented() && l !== h) {
      const b = Re(d.getTextContent());
      b.setFormat(i), d.replace(b), d = b;
    } else if (!this.isCollapsed() && e !== "") {
      const b = w.getParent();
      if (!g.canInsertTextBefore() || !g.canInsertTextAfter() || X(b) && (!b.canInsertTextBefore() || !b.canInsertTextAfter())) return this.insertText(""), A0(this.anchor, this.focus, null), void this.insertText(e);
    }
    if (f === 1) {
      if (No(d)) {
        const C = Re(e);
        return C.select(), void d.replace(C);
      }
      const b = d.getFormat(), _ = d.getStyle();
      if (l !== c || b === i && _ === o) {
        if (N0(d)) {
          const C = Re(e);
          return C.setFormat(i), C.setStyle(o), C.select(), void d.replace(C);
        }
      } else {
        if (d.getTextContent() !== "") {
          const C = Re(e);
          if (C.setFormat(i), C.setStyle(o), C.select(), l === 0) d.insertBefore(C, !1);
          else {
            const [D] = d.splitText(l);
            D.insertAfter(C, !1);
          }
          return void (C.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= e.length));
        }
        d.setFormat(i), d.setStyle(o);
      }
      const y = c - l;
      d = d.spliceText(l, y, e, !0), d.getTextContent() === "" ? d.remove() : this.anchor.type === "text" && (d.isComposing() ? this.anchor.offset -= e.length : (this.format = b, this.style = _));
    } else {
      const b = /* @__PURE__ */ new Set([...d.getParentKeys(), ...w.getParentKeys()]), _ = X(d) ? d : d.getParentOrThrow();
      let y = X(w) ? w : w.getParentOrThrow(), C = w;
      if (!_.is(y) && y.isInline()) do
        C = y, y = y.getParentOrThrow();
      while (y.isInline());
      if (a.type === "text" && (c !== 0 || w.getTextContent() === "") || a.type === "element" && w.getIndexWithinParent() < c) if (ie(w) && !No(w) && c !== w.getTextContentSize()) {
        if (w.isSegmented()) {
          const O = Re(w.getTextContent());
          w.replace(O), w = O;
        }
        tn(a.getNode()) || a.type !== "text" || (w = w.spliceText(0, c, "")), b.add(w.__key);
      } else {
        const O = w.getParentOrThrow();
        O.canBeEmpty() || O.getChildrenSize() !== 1 ? w.remove() : O.remove();
      }
      else b.add(w.__key);
      const D = y.getChildren(), P = new Set(u), S = _.is(y), L = _.isInline() && d.getNextSibling() === null ? _ : d;
      for (let O = D.length - 1; O >= 0; O--) {
        const M = D[O];
        if (M.is(d) || X(M) && M.isParentOf(d)) break;
        M.isAttached() && (!P.has(M) || M.is(C) ? S || L.insertAfter(M, !1) : M.remove());
      }
      if (!S) {
        let O = y, M = null;
        for (; O !== null; ) {
          const F = O.getChildren(), k = F.length;
          (k === 0 || F[k - 1].is(M)) && (b.delete(O.__key), M = O), O = O.getParent();
        }
      }
      if (No(d)) if (l === h) d.select();
      else {
        const O = Re(e);
        O.select(), d.replace(O);
      }
      else d = d.spliceText(l, h - l, e, !0), d.getTextContent() === "" ? d.remove() : d.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= e.length);
      for (let O = 1; O < f; O++) {
        const M = u[O], F = M.__key;
        b.has(F) || M.remove();
      }
    }
  }
  removeText() {
    const e = oe() === this;
    Rc(this, _E(Zw(this))), e && oe() !== this && sn(this);
  }
  formatText(e, n = null) {
    if (this.isCollapsed()) return this.toggleFormat(e), void en(null);
    const r = this.getNodes(), i = [];
    for (const D of r) ie(D) && i.push(D);
    const o = (D) => {
      r.forEach((P) => {
        if (X(P)) {
          const S = P.getFormatFlags(e, D);
          P.setTextFormat(S);
        }
      });
    }, s = i.length;
    if (s === 0) return this.toggleFormat(e), en(null), void o(n);
    const a = this.anchor, l = this.focus, c = this.isBackward(), u = c ? l : a, f = c ? a : l;
    let d = 0, h = i[0], g = u.type === "element" ? 0 : u.offset;
    if (u.type === "text" && g === h.getTextContentSize() && (d = 1, h = i[1], g = 0), h == null) return;
    const w = h.getFormatFlags(e, n);
    o(w);
    const b = s - 1;
    let _ = i[b];
    const y = f.type === "text" ? f.offset : _.getTextContentSize();
    if (h.is(_)) {
      if (g === y) return;
      if (li(h) || g === 0 && y === h.getTextContentSize()) h.setFormat(w);
      else {
        const D = h.splitText(g, y), P = g === 0 ? D[0] : D[1];
        P.setFormat(w), u.type === "text" && u.set(P.__key, 0, "text"), f.type === "text" && f.set(P.__key, y - g, "text");
      }
      return void (this.format = w);
    }
    g === 0 || li(h) || ([, h] = h.splitText(g), g = 0), h.setFormat(w);
    const C = _.getFormatFlags(e, w);
    y > 0 && (y === _.getTextContentSize() || li(_) || ([_] = _.splitText(y)), _.setFormat(C));
    for (let D = d + 1; D < b; D++) {
      const P = i[D], S = P.getFormatFlags(e, C);
      P.setFormat(S);
    }
    u.type === "text" && u.set(h.__key, g, "text"), f.type === "text" && f.set(_.__key, y, "text"), this.format = w | C;
  }
  insertNodes(e) {
    if (e.length === 0) return;
    if (this.isCollapsed() || this.removeText(), this.anchor.key === "root") {
      this.insertParagraph();
      const g = oe();
      return Z(g) || le(134), g.insertNodes(e);
    }
    const n = (this.isBackward() ? this.focus : this.anchor).getNode(), r = Zd(n, nr), i = e[e.length - 1];
    if (X(r) && "__language" in r) {
      if ("__language" in e[0]) this.insertText(e[0].getTextContent());
      else {
        const g = Jd(this);
        r.splice(g, 0, e), i.selectEnd();
      }
      return;
    }
    if (!e.some((g) => (X(g) || Xe(g)) && !g.isInline())) {
      X(r) || le(211, n.constructor.name, n.getType());
      const g = Jd(this);
      return r.splice(g, 0, e), void i.selectEnd();
    }
    const o = function(g) {
      const w = Jn();
      let b = null;
      for (let _ = 0; _ < g.length; _++) {
        const y = g[_], C = ko(y);
        if (C || Xe(y) && y.isInline() || X(y) && y.isInline() || ie(y) || y.isParentRequired()) {
          if (b === null && (b = y.createParentElementNode(), w.append(b), C)) continue;
          b !== null && b.append(y);
        } else w.append(y), b = null;
      }
      return w;
    }(e), s = o.getLastDescendant(), a = o.getChildren(), l = !X(r) || !r.isEmpty() ? this.insertParagraph() : null, c = a[a.length - 1];
    let u = a[0];
    var f;
    X(f = u) && nr(f) && !f.isEmpty() && X(r) && (!r.isEmpty() || r.canMergeWhenEmpty()) && (X(r) || le(211, n.constructor.name, n.getType()), r.append(...u.getChildren()), u = a[1]), u && (r === null && le(212, n.constructor.name, n.getType()), function(g, w, b) {
      const _ = w.getParentOrThrow().getLastChild();
      let y = w;
      const C = [w];
      for (; y !== _; ) y.getNextSibling() || le(140), y = y.getNextSibling(), C.push(y);
      let D = g;
      for (const P of C) D = D.insertAfter(P);
    }(r, u));
    const d = Zd(s, nr);
    l && X(d) && (l.canMergeWhenEmpty() || nr(c)) && (d.append(...l.getChildren()), l.remove()), X(r) && r.isEmpty() && r.remove(), s.selectEnd();
    const h = X(r) ? r.getLastChild() : null;
    ko(h) && d !== r && h.remove();
  }
  insertParagraph() {
    if (this.anchor.key === "root") {
      const s = Jn();
      return Ve().splice(this.anchor.offset, 0, [s]), s.select(), s;
    }
    const e = Jd(this), n = Zd(this.anchor.getNode(), nr);
    X(n) || le(213);
    const r = n.getChildAtIndex(e), i = r ? [r, ...r.getNextSiblings()] : [], o = n.insertNewAfter(this, !1);
    return o ? (o.append(...i), o.selectStart(), o) : null;
  }
  insertLineBreak(e) {
    const n = Bo();
    if (this.insertNodes([n]), e) {
      const r = n.getParentOrThrow(), i = n.getIndexWithinParent();
      r.select(i, i);
    }
  }
  extract() {
    const e = this.getNodes(), n = e.length, r = n - 1, i = this.anchor, o = this.focus;
    let s = e[0], a = e[r];
    const [l, c] = Xf(this);
    if (n === 0) return [];
    if (n === 1) {
      if (ie(s) && !this.isCollapsed()) {
        const f = l > c ? c : l, d = l > c ? l : c, h = s.splitText(f, d), g = f === 0 ? h[0] : h[1];
        return g != null ? [g] : [];
      }
      return [s];
    }
    const u = i.isBefore(o);
    if (ie(s)) {
      const f = u ? l : c;
      f === s.getTextContentSize() ? e.shift() : f !== 0 && ([, s] = s.splitText(f), e[0] = s);
    }
    if (ie(a)) {
      const f = a.getTextContent().length, d = u ? c : l;
      d === 0 ? e.pop() : d !== f && ([a] = a.splitText(d), e[r] = a);
    }
    return e;
  }
  modify(e, n, r) {
    if (Rw(this, e, n, r)) return;
    const i = e === "move", o = wt(), s = vr(or(o));
    if (!s) return;
    const a = o._blockCursorElement, l = o._rootElement, c = this.focus.getNode();
    if (l === null || a === null || !X(c) || c.isInline() || c.canBeEmpty() || nh(a, o, l), this.dirty) {
      let u = Us(o, this.anchor.key), f = Us(o, this.focus.key);
      this.anchor.type === "text" && (u = js(u)), this.focus.type === "text" && (f = js(f)), u && f && I0(s, u, this.anchor.offset, f, this.focus.offset);
    }
    if (function(u, f, d, h) {
      u.modify(f, d, h);
    }(s, e, n ? "backward" : "forward", r), s.rangeCount > 0) {
      const u = s.getRangeAt(0), f = this.anchor.getNode(), d = tn(f) ? f : iE(f);
      if (this.applyDOMRange(u), this.dirty = !0, !i) {
        const h = this.getNodes(), g = [];
        let w = !1;
        for (let b = 0; b < h.length; b++) {
          const _ = h[b];
          th(_, d) ? g.push(_) : w = !0;
        }
        if (w && g.length > 0) if (n) {
          const b = g[0];
          X(b) ? b.selectStart() : b.getParentOrThrow().selectStart();
        } else {
          const b = g[g.length - 1];
          X(b) ? b.selectEnd() : b.getParentOrThrow().selectEnd();
        }
        s.anchorNode === u.startContainer && s.anchorOffset === u.startOffset || function(b) {
          const _ = b.focus, y = b.anchor, C = y.key, D = y.offset, P = y.type;
          y.set(_.key, _.offset, _.type, !0), _.set(C, D, P, !0);
        }(this);
      }
    }
    r === "lineboundary" && Rw(this, e, n, r, "decorators");
  }
  forwardDeletion(e, n, r) {
    if (!r && (e.type === "element" && X(n) && e.offset === n.getChildrenSize() || e.type === "text" && e.offset === n.getTextContentSize())) {
      const i = n.getParent(), o = n.getNextSibling() || (i === null ? null : i.getNextSibling());
      if (X(o) && o.isShadowRoot()) return !0;
    }
    return !1;
  }
  deleteCharacter(e) {
    const n = this.isCollapsed();
    if (this.isCollapsed()) {
      const r = this.anchor;
      let i = r.getNode();
      if (this.forwardDeletion(r, i, e)) return;
      const o = Up(bi(r, e ? "previous" : "next"));
      if (o.getTextSlices().every((a) => a === null || a.distance === 0)) {
        let a = { type: "initial" };
        for (const l of o.iterNodeCarets("shadowRoot")) if (mr(l)) {
          if (!l.origin.isInline()) {
            if (l.origin.isShadowRoot()) {
              if (a.type === "merge-block") break;
              if (X(o.anchor.origin) && o.anchor.origin.isEmpty()) {
                const c = Vr(l);
                Rc(this, Hi(c, c)), o.anchor.origin.remove();
              }
              return;
            }
            a.type !== "merge-next-block" && a.type !== "merge-block" || (a = { block: a.block, caret: l, type: "merge-block" });
          }
        } else {
          if (a.type === "merge-block") break;
          if (qo(l)) {
            if (X(l.origin)) {
              if (l.origin.isInline()) {
                if (!l.origin.isParentOf(o.anchor.origin)) break;
              } else a = { block: l.origin, type: "merge-next-block" };
              continue;
            }
            if (Xe(l.origin)) {
              if (!l.origin.isIsolated()) if (a.type === "merge-next-block" && (l.origin.isKeyboardSelectable() || !l.origin.isInline()) && X(o.anchor.origin) && o.anchor.origin.isEmpty()) {
                o.anchor.origin.remove();
                const c = O0();
                c.add(l.origin.getKey()), sn(c);
              } else l.origin.remove();
              return;
            }
            break;
          }
        }
        if (a.type === "merge-block") {
          const { caret: l, block: c } = a;
          return Rc(this, Hi(!l.origin.isEmpty() && c.isEmpty() ? td($t(c, l.direction)) : o.anchor, l)), this.removeText();
        }
      }
      const s = this.focus;
      if (this.modify("extend", e, "character"), this.isCollapsed()) {
        if (e && r.offset === 0 && Tw(this, r.getNode())) return;
      } else {
        const a = s.type === "text" ? s.getNode() : null;
        if (i = r.type === "text" ? r.getNode() : null, a !== null && a.isSegmented()) {
          const l = s.offset, c = a.getTextContentSize();
          if (a.is(i) || e && l !== c || !e && l !== 0) return void Aw(a, e, l);
        } else if (i !== null && i.isSegmented()) {
          const l = r.offset, c = i.getTextContentSize();
          if (i.is(a) || e && l !== 0 || !e && l !== c) return void Aw(i, e, l);
        }
        (function(l, c) {
          const u = l.anchor, f = l.focus, d = u.getNode(), h = f.getNode();
          if (d === h && u.type === "text" && f.type === "text") {
            const g = u.offset, w = f.offset, b = g < w, _ = b ? g : w, y = b ? w : g, C = y - 1;
            _ !== C && function(D) {
              return !(G0(D) || Fk(D));
            }(d.getTextContent().slice(_, y)) && (c ? f.set(f.key, C, f.type) : u.set(u.key, C, u.type));
          }
        })(this, e);
      }
    }
    if (this.removeText(), e && !n && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
      const r = this.anchor.getNode();
      r.isEmpty() && tn(r.getParent()) && r.getPreviousSibling() === null && Tw(this, r);
    }
  }
  deleteLine(e) {
    this.isCollapsed() && this.modify("extend", e, "lineboundary"), this.isCollapsed() ? this.deleteCharacter(e) : this.removeText();
  }
  deleteWord(e) {
    if (this.isCollapsed()) {
      const n = this.anchor, r = n.getNode();
      if (this.forwardDeletion(n, r, e)) return;
      this.modify("extend", e, "word");
    }
    this.removeText();
  }
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
}
function bn(t) {
  return t instanceof S0;
}
function Sw(t) {
  const e = t.offset;
  if (t.type === "text") return e;
  const n = t.getNode();
  return e === n.getChildrenSize() ? n.getTextContent().length : 0;
}
function Xf(t) {
  const e = t.getStartEndPoints();
  if (e === null) return [0, 0];
  const [n, r] = e;
  return n.type === "element" && r.type === "element" && n.key === r.key && n.offset === r.offset ? [0, 0] : [Sw(n), Sw(r)];
}
function Tw(t, e) {
  for (let n = e; n; n = n.getParent()) {
    if (X(n)) {
      if (n.collapseAtStart(t)) return !0;
      if (Zr(n)) break;
    }
    if (n.getPreviousSibling()) break;
  }
  return !1;
}
const Fk = (() => {
  try {
    const t = new RegExp("\\p{Emoji}", "u"), e = t.test.bind(t);
    if (e("â¤ï¸") && e("#ï¸âƒ£") && e("ðŸ‘")) return e;
  } catch {
  }
  return () => !1;
})();
function Aw(t, e, n) {
  const r = t, i = r.getTextContent().split(/(?=\s)/g), o = i.length;
  let s = 0, a = 0;
  for (let c = 0; c < o; c++) {
    const u = c === o - 1;
    if (a = s, s += i[c].length, e && s === n || s > n || u) {
      i.splice(c, 1), u && (a = void 0);
      break;
    }
  }
  const l = i.join("").trim();
  l === "" ? r.remove() : (r.setTextContent(l), r.select(a, a));
}
function Dw(t, e, n, r) {
  let i, o = e;
  if (it(t)) {
    let s = !1;
    const a = t.childNodes, l = a.length, c = r._blockCursorElement;
    o === l && (s = !0, o = l - 1);
    let u = a[o], f = !1;
    if (u === c) u = a[o + 1], f = !0;
    else if (c !== null) {
      const d = c.parentNode;
      t === d && e > Array.prototype.indexOf.call(d.children, c) && o--;
    }
    if (i = ys(u), ie(i)) o = qi(i, s ? "next" : "previous");
    else {
      let d = ys(t);
      if (d === null) return null;
      if (X(d)) {
        const h = r.getElementByKey(d.getKey());
        h === null && le(214), [d, o] = d.getDOMSlot(h).resolveChildIndex(d, h, t, e), X(d) || le(215), s && o >= d.getChildrenSize() && (o = Math.max(0, d.getChildrenSize() - 1));
        let w = d.getChildAtIndex(o);
        if (X(w) && function(b, _, y) {
          const C = b.getParent();
          return y === null || C === null || !C.canBeEmpty() || C !== y.getNode();
        }(w, 0, n)) {
          const b = s ? w.getLastDescendant() : w.getFirstDescendant();
          b === null ? d = w : (w = b, d = X(w) ? w : w.getParentOrThrow()), o = 0;
        }
        ie(w) ? (i = w, d = null, o = qi(w, s ? "next" : "previous")) : w !== d && s && !f && (X(d) || le(216), o = Math.min(d.getChildrenSize(), o + 1));
      } else {
        const h = d.getIndexWithinParent();
        o = e === 0 && Xe(d) && ys(t) === d ? h : h + 1, d = d.getParentOrThrow();
      }
      if (X(d)) return On(d.__key, o, "element");
    }
  } else i = ys(t);
  return ie(i) ? On(i.__key, qi(i, o, "clamp"), "text") : null;
}
function Mw(t, e, n) {
  const r = t.offset, i = t.getNode();
  if (r === 0) {
    const o = i.getPreviousSibling(), s = i.getParent();
    if (e) {
      if ((n || !e) && o === null && X(s) && s.isInline()) {
        const a = s.getPreviousSibling();
        ie(a) && t.set(a.__key, a.getTextContent().length, "text");
      }
    } else X(o) && !n && o.isInline() ? t.set(o.__key, o.getChildrenSize(), "element") : ie(o) && t.set(o.__key, o.getTextContent().length, "text");
  } else if (r === i.getTextContent().length) {
    const o = i.getNextSibling(), s = i.getParent();
    if (e && X(o) && o.isInline()) t.set(o.__key, 0, "element");
    else if ((n || e) && o === null && X(s) && s.isInline() && !s.canInsertTextAfter()) {
      const a = s.getNextSibling();
      ie(a) && t.set(a.__key, 0, "text");
    }
  }
}
function A0(t, e, n) {
  if (t.type === "text" && e.type === "text") {
    const r = t.isBefore(e), i = t.is(e);
    Mw(t, r, i), Mw(e, !r, i), i && e.set(t.key, t.offset, t.type);
    const o = wt();
    if (o.isComposing() && o._compositionKey !== t.key && Z(n)) {
      const s = n.anchor, a = n.focus;
      t.set(s.key, s.offset, s.type, !0), e.set(a.key, a.offset, a.type, !0);
    }
  }
}
function D0(t, e, n, r, i, o) {
  if (t === null || n === null || !Fl(i, t, n)) return null;
  const s = Dw(t, e, Z(o) ? o.anchor : null, i);
  if (s === null) return null;
  const a = Dw(n, r, Z(o) ? o.focus : null, i);
  if (a === null) return null;
  if (s.type === "element" && a.type === "element") {
    const l = ys(t), c = ys(n);
    if (Xe(l) && Xe(c)) return null;
  }
  return A0(s, a, o), [s, a];
}
function Yf(t) {
  return X(t) && !t.isInline();
}
function M0(t, e, n, r, i, o) {
  const s = Zi(), a = new ns(On(t, e, i), On(n, r, o), 0, "");
  return a.dirty = !0, s._selection = a, a;
}
function $l() {
  const t = On("root", 0, "element"), e = On("root", 0, "element");
  return new ns(t, e, 0, "");
}
function O0() {
  return new S0(/* @__PURE__ */ new Set());
}
function Cp(t, e, n, r) {
  const i = n._window;
  if (i === null) return null;
  const o = r || i.event, s = o ? o.type : void 0, a = s === "selectionchange", l = !Ff && (a || s === "beforeinput" || s === "compositionstart" || s === "compositionend" || s === "click" && o && o.detail === 3 || s === "drop" || s === void 0);
  let c, u, f, d;
  if (Z(t) && !l) return t.clone();
  if (e === null) return null;
  if (c = e.anchorNode, u = e.focusNode, f = e.anchorOffset, d = e.focusOffset, a && Z(t) && !Fl(n, c, u)) return t.clone();
  const h = D0(c, f, u, d, n, t);
  if (h === null) return null;
  const [g, w] = h;
  return new ns(g, w, Z(t) ? t.format : 0, Z(t) ? t.style : "");
}
function oe() {
  return Zi()._selection;
}
function fa() {
  return wt()._editorState._selection;
}
function nu(t, e, n, r = 1) {
  const i = t.anchor, o = t.focus, s = i.getNode(), a = o.getNode();
  if (!e.is(s) && !e.is(a)) return;
  const l = e.__key;
  if (t.isCollapsed()) {
    const c = i.offset;
    if (n <= c && r > 0 || n < c && r < 0) {
      const u = Math.max(0, c + r);
      i.set(l, u, "element"), o.set(l, u, "element"), Ow(t);
    }
  } else {
    const c = t.isBackward(), u = c ? o : i, f = u.getNode(), d = c ? i : o, h = d.getNode();
    if (e.is(f)) {
      const g = u.offset;
      (n <= g && r > 0 || n < g && r < 0) && u.set(l, Math.max(0, g + r), "element");
    }
    if (e.is(h)) {
      const g = d.offset;
      (n <= g && r > 0 || n < g && r < 0) && d.set(l, Math.max(0, g + r), "element");
    }
  }
  Ow(t);
}
function Ow(t) {
  const e = t.anchor, n = e.offset, r = t.focus, i = r.offset, o = e.getNode(), s = r.getNode();
  if (t.isCollapsed()) {
    if (!X(o)) return;
    const a = o.getChildrenSize(), l = n >= a, c = l ? o.getChildAtIndex(a - 1) : o.getChildAtIndex(n);
    if (ie(c)) {
      let u = 0;
      l && (u = c.getTextContentSize()), e.set(c.__key, u, "text"), r.set(c.__key, u, "text");
    }
  } else {
    if (X(o)) {
      const a = o.getChildrenSize(), l = n >= a, c = l ? o.getChildAtIndex(a - 1) : o.getChildAtIndex(n);
      if (ie(c)) {
        let u = 0;
        l && (u = c.getTextContentSize()), e.set(c.__key, u, "text");
      }
    }
    if (X(s)) {
      const a = s.getChildrenSize(), l = i >= a, c = l ? s.getChildAtIndex(a - 1) : s.getChildAtIndex(i);
      if (ie(c)) {
        let u = 0;
        l && (u = c.getTextContentSize()), r.set(c.__key, u, "text");
      }
    }
  }
}
function ru(t, e, n, r, i) {
  let o = null, s = 0, a = null;
  r !== null ? (o = r.__key, ie(r) ? (s = r.getTextContentSize(), a = "text") : X(r) && (s = r.getChildrenSize(), a = "element")) : i !== null && (o = i.__key, ie(i) ? a = "text" : X(i) && (a = "element")), o !== null && a !== null ? t.set(o, s, a) : (s = e.getIndexWithinParent(), s === -1 && (s = n.getChildrenSize()), t.set(n.__key, s, "element"));
}
function Iw(t, e, n, r, i) {
  t.type === "text" ? t.set(n, t.offset + (e ? 0 : i), "text") : t.offset > r.getIndexWithinParent() && t.set(t.key, t.offset - 1, "element");
}
function I0(t, e, n, r, i) {
  try {
    t.setBaseAndExtent(e, n, r, i);
  } catch {
  }
}
function Bk(t, e, n, r, i, o, s) {
  const a = r.anchorNode, l = r.focusNode, c = r.anchorOffset, u = r.focusOffset, f = document.activeElement;
  if (i.has(Hk) && f !== o || f !== null && Mp(f)) return;
  if (!Z(e)) return void (t !== null && Fl(n, a, l) && r.removeAllRanges());
  const d = e.anchor, h = e.focus, g = d.key, w = h.key, b = Us(n, g), _ = Us(n, w), y = d.offset, C = h.offset, D = e.format, P = e.style, S = e.isCollapsed();
  let L = b, O = _, M = !1;
  if (d.type === "text") {
    L = js(b);
    const T = d.getNode();
    M = T.getFormat() !== D || T.getStyle() !== P;
  } else Z(t) && t.anchor.type === "text" && (M = !0);
  var F, k, I, N, R;
  if (h.type === "text" && (O = js(_)), L !== null && O !== null && (S && (t === null || M || Z(t) && (t.format !== D || t.style !== P)) && (F = D, k = P, I = y, N = g, R = performance.now(), m0 = [F, k, I, N, R]), c !== y || u !== C || a !== L || l !== O || r.type === "Range" && S || (f !== null && o.contains(f) || o.focus({ preventScroll: !0 }), d.type === "element"))) {
    if (I0(r, L, y, O, C), !i.has(Kk) && e.isCollapsed() && o !== null && o === document.activeElement) {
      const T = Z(e) && e.anchor.type === "element" ? L.childNodes[y] || null : r.rangeCount > 0 ? r.getRangeAt(0) : null;
      if (T !== null) {
        let A;
        if (T instanceof Text) {
          const q = document.createRange();
          q.selectNode(T), A = q.getBoundingClientRect();
        } else A = T.getBoundingClientRect();
        (function(q, V, J) {
          const H = Z0(J), W = $p(H);
          if (H === null || W === null) return;
          let { top: ne, bottom: re } = V, te = 0, Q = 0, ce = J;
          for (; ce !== null; ) {
            const pe = ce === H.body;
            if (pe) te = 0, Q = or(q).innerHeight;
            else {
              const ve = ce.getBoundingClientRect();
              te = ve.top, Q = ve.bottom;
            }
            let we = 0;
            if (ne < te ? we = -(te - ne) : re > Q && (we = re - Q), we !== 0) if (pe) W.scrollBy(0, we);
            else {
              const ve = ce.scrollTop;
              ce.scrollTop += we;
              const _e = ce.scrollTop - ve;
              ne -= _e, re -= _e;
            }
            if (pe) break;
            ce = Bl(ce);
          }
        })(n, A, o);
      }
    }
    Wf = !0;
  }
}
function qk(t) {
  let e = oe() || fa();
  e === null && (e = Ve().selectEnd()), e.insertNodes(t);
}
function Jd(t) {
  let e = t;
  t.isCollapsed() || e.removeText();
  const n = oe();
  Z(n) && (e = n), Z(e) || le(161);
  const r = e.anchor;
  let i = r.getNode(), o = r.offset;
  for (; !nr(i); ) {
    const s = i;
    if ([i, o] = jk(i, o), s.is(i)) break;
  }
  return o;
}
function jk(t, e) {
  const n = t.getParent();
  if (!n) {
    const i = Jn();
    return Ve().append(i), i.select(), [Ve(), 0];
  }
  if (ie(t)) {
    const i = t.splitText(e);
    if (i.length === 0) return [n, t.getIndexWithinParent()];
    const o = e === 0 ? 0 : 1;
    return [n, i[0].getIndexWithinParent() + o];
  }
  if (!X(t) || e === 0) return [n, t.getIndexWithinParent()];
  const r = t.getChildAtIndex(e);
  if (r) {
    const i = new ns(On(t.__key, e, "element"), On(t.__key, e, "element"), 0, ""), o = t.insertNewAfter(i);
    o && o.append(r, ...r.getNextSiblings());
  }
  return [n, t.getIndexWithinParent() + 1];
}
function Rw(t, e, n, r, i = "decorators-and-blocks") {
  if (e === "move" && r === "character" && !t.isCollapsed()) {
    const [u, f] = n === t.isBackward() ? [t.focus, t.anchor] : [t.anchor, t.focus];
    return f.set(u.key, u.offset, u.type), !0;
  }
  const o = bi(t.focus, n ? "previous" : "next"), s = r === "lineboundary", a = e === "move";
  let l = o, c = i === "decorators-and-blocks";
  if (!sv(l)) {
    for (const u of l) {
      c = !1;
      const { origin: f } = u;
      if (!Xe(f) || f.isIsolated() || (l = u, !s || !f.isInline())) break;
    }
    if (c) for (const u of Up(o).iterNodeCarets(e === "extend" ? "shadowRoot" : "root")) {
      if (mr(u)) u.origin.isInline() || (l = u);
      else {
        if (X(u.origin)) continue;
        Xe(u.origin) && !u.origin.isInline() && (l = u);
      }
      break;
    }
  }
  if (l === o) return !1;
  if (a && !s && Xe(l.origin) && l.origin.isKeyboardSelectable()) {
    const u = O0();
    return u.add(l.origin.getKey()), sn(u), !0;
  }
  return l = Vr(l), a && pl(t.anchor, l), pl(t.focus, l), c || !s;
}
let Ut = null, zt = null, Mn = !1, Xd = !1, Mc = 0;
const Pw = { characterData: !0, childList: !0, subtree: !0 };
function ha() {
  return Mn || Ut !== null && Ut._readOnly;
}
function Zt() {
  Mn && le(13);
}
function R0() {
  Mc > 99 && le(14);
}
function Zi() {
  return Ut === null && le(195, P0()), Ut;
}
function wt() {
  return zt === null && le(196, P0()), zt;
}
function P0() {
  let t = 0;
  const e = /* @__PURE__ */ new Set(), n = Ju.version;
  if (typeof window < "u") for (const i of document.querySelectorAll("[contenteditable]")) {
    const o = Xu(i);
    if (Op(o)) t++;
    else if (o) {
      let s = String(o.constructor.version || "<0.17.1");
      s === n && (s += " (separately built, likely a bundler configuration issue)"), e.add(s);
    }
  }
  let r = ` Detected on the page: ${t} compatible editor(s) with version ${n}`;
  return e.size && (r += ` and incompatible editors with versions ${Array.from(e).join(", ")}`), r;
}
function Uk() {
  return zt;
}
function Lw(t, e, n) {
  const r = e.__type, i = z0(t, r);
  let o = n.get(r);
  o === void 0 && (o = Array.from(i.transforms), n.set(r, o));
  const s = o.length;
  for (let a = 0; a < s && (o[a](e), e.isAttached()); a++) ;
}
function $w(t, e) {
  return t !== void 0 && t.__key !== e && t.isAttached();
}
function L0(t, e) {
  if (!e) return;
  const n = t._updateTags;
  let r = e;
  Array.isArray(e) || (r = [e]);
  for (const i of r) n.add(i);
}
function $0(t) {
  return kp(t, wt()._nodes);
}
function kp(t, e) {
  const n = t.type, r = e.get(n);
  r === void 0 && le(17, n);
  const i = r.klass;
  t.type !== i.getType() && le(18, i.name);
  const o = i.importJSON(t), s = t.children;
  if (X(o) && Array.isArray(s)) for (let a = 0; a < s.length; a++) {
    const l = kp(s[a], e);
    o.append(l);
  }
  return o;
}
function Fw(t, e, n) {
  const r = Ut, i = Mn, o = zt;
  Ut = e, Mn = !0, zt = t;
  try {
    return n();
  } finally {
    Ut = r, Mn = i, zt = o;
  }
}
function di(t, e) {
  const n = t._pendingEditorState, r = t._rootElement, i = t._headless || r === null;
  if (n === null) return;
  const o = t._editorState, s = o._selection, a = n._selection, l = t._dirtyType !== $o, c = Ut, u = Mn, f = zt, d = t._updating, h = t._observer;
  let g = null;
  if (t._pendingEditorState = null, t._editorState = n, !i && l && h !== null) {
    zt = t, Ut = n, Mn = !1, t._updating = !0;
    try {
      const S = t._dirtyType, L = t._dirtyElements, O = t._dirtyLeaves;
      h.disconnect(), g = yk(o, n, t, S, L, O);
    } catch (S) {
      if (S instanceof Error && t._onError(S), Xd) throw S;
      return U0(t, null, r, n), e0(t), t._dirtyType = Ls, Xd = !0, di(t, o), void (Xd = !1);
    } finally {
      h.observe(r, Pw), t._updating = d, Ut = c, Mn = u, zt = f;
    }
  }
  n._readOnly || (n._readOnly = !0);
  const w = t._dirtyLeaves, b = t._dirtyElements, _ = t._normalizedNodes, y = t._updateTags, C = t._deferred;
  l && (t._dirtyType = $o, t._cloneNotNeeded.clear(), t._dirtyLeaves = /* @__PURE__ */ new Set(), t._dirtyElements = /* @__PURE__ */ new Map(), t._normalizedNodes = /* @__PURE__ */ new Set(), t._updateTags = /* @__PURE__ */ new Set()), function(S, L) {
    const O = S._decorators;
    let M = S._pendingDecorators || O;
    const F = L._nodeMap;
    let k;
    for (k in M) F.has(k) || (M === O && (M = K0(S)), delete M[k]);
  }(t, n);
  const D = i ? null : vr(or(t));
  if (t._editable && D !== null && (l || a === null || a.dirty) && r !== null && !y.has(Wk)) {
    zt = t, Ut = n;
    try {
      if (h !== null && h.disconnect(), l || a === null || a.dirty) {
        const S = t._blockCursorElement;
        S !== null && nh(S, t, r), Bk(s, a, t, D, y, r);
      }
      (function(S, L, O) {
        let M = S._blockCursorElement;
        if (Z(O) && O.isCollapsed() && O.anchor.type === "element" && L.contains(document.activeElement)) {
          const F = O.anchor, k = F.getNode(), I = F.offset;
          let N = !1, R = null;
          if (I === k.getChildrenSize())
            Qd(k.getChildAtIndex(I - 1)) && (N = !0);
          else {
            const T = k.getChildAtIndex(I);
            if (T !== null && Qd(T)) {
              const A = T.getPreviousSibling();
              (A === null || Qd(A)) && (N = !0, R = S.getElementByKey(T.__key));
            }
          }
          if (N) {
            const T = S.getElementByKey(k.__key);
            return M === null && (S._blockCursorElement = M = function(A) {
              const q = A.theme, V = document.createElement("div");
              V.contentEditable = "false", V.setAttribute("data-lexical-cursor", "true");
              let J = q.blockCursor;
              if (J !== void 0) {
                if (typeof J == "string") {
                  const H = Wc(J);
                  J = q.blockCursor = H;
                }
                J !== void 0 && V.classList.add(...J);
              }
              return V;
            }(S._config)), L.style.caretColor = "transparent", void (R === null ? T.appendChild(M) : T.insertBefore(M, R));
          }
        }
        M !== null && nh(M, S, L);
      })(t, r, a);
    } finally {
      h !== null && h.observe(r, Pw), zt = f, Ut = c;
    }
  }
  g !== null && function(S, L, O, M, F) {
    const k = Array.from(S._listeners.mutation), I = k.length;
    for (let N = 0; N < I; N++) {
      const [R, T] = k[N];
      for (const A of T) {
        const q = L.get(A);
        q !== void 0 && R(q, { dirtyLeaves: M, prevEditorState: F, updateTags: O });
      }
    }
  }(t, g, y, w, o), Z(a) || a === null || s !== null && s.is(a) || t.dispatchCommand(Yi, void 0);
  const P = t._pendingDecorators;
  P !== null && (t._decorators = P, t._pendingDecorators = null, Ya("decorator", t, !0, P)), function(S, L, O) {
    const M = zw(L), F = zw(O);
    M !== F && Ya("textcontent", S, !0, F);
  }(t, e || o, n), Ya("update", t, !0, { dirtyElements: b, dirtyLeaves: w, editorState: n, mutatedNodes: g, normalizedNodes: _, prevEditorState: e || o, tags: y }), function(S, L) {
    if (S._deferred = [], L.length !== 0) {
      const O = S._updating;
      S._updating = !0;
      try {
        for (let M = 0; M < L.length; M++) L[M]();
      } finally {
        S._updating = O;
      }
    }
  }(t, C), function(S) {
    const L = S._updates;
    if (L.length !== 0) {
      const O = L.shift();
      if (O) {
        const [M, F] = O;
        Ku(S, M, F);
      }
    }
  }(t);
}
function Ya(t, e, n, ...r) {
  const i = e._updating;
  e._updating = n;
  try {
    const o = Array.from(e._listeners[t]);
    for (let s = 0; s < o.length; s++) o[s].apply(null, r);
  } finally {
    e._updating = i;
  }
}
function Bw(t, e) {
  const n = t._updates;
  let r = e || !1;
  for (; n.length !== 0; ) {
    const i = n.shift();
    if (i) {
      const [o, s] = i, a = t._pendingEditorState;
      let l;
      s !== void 0 && (l = s.onUpdate, s.skipTransforms && (r = !0), s.discrete && (a === null && le(191), a._flushSync = !0), l && t._deferred.push(l), L0(t, s.tag)), a == null ? Ku(t, o, s) : o();
    }
  }
  return r;
}
function Ku(t, e, n) {
  const r = t._updateTags;
  let i, o = !1, s = !1;
  n !== void 0 && (i = n.onUpdate, L0(t, n.tag), o = n.skipTransforms || !1, s = n.discrete || !1), i && t._deferred.push(i);
  const a = t._editorState;
  let l = t._pendingEditorState, c = !1;
  (l === null || l._readOnly) && (l = t._pendingEditorState = B0(l || a), c = !0), l._flushSync = s;
  const u = Ut, f = Mn, d = zt, h = t._updating;
  Ut = l, Mn = !1, t._updating = !0, zt = t;
  const g = t._headless || t.getRootElement() === null;
  Ap(null);
  try {
    c && (g ? a._selection !== null && (l._selection = a._selection.clone()) : l._selection = function(y, C) {
      const D = y.getEditorState()._selection, P = vr(or(y));
      return Z(D) || D == null ? Cp(D, P, y, C) : D.clone();
    }(t, n && n.event || null));
    const b = t._compositionKey;
    e(), o = Bw(t, o), function(y, C) {
      const D = C.getEditorState()._selection, P = y._selection;
      if (Z(P)) {
        const S = P.anchor, L = P.focus;
        let O;
        if (S.type === "text" && (O = S.getNode(), O.selectionTransform(D, P)), L.type === "text") {
          const M = L.getNode();
          O !== M && M.selectionTransform(D, P);
        }
      }
    }(l, t), t._dirtyType !== $o && (o ? function(y, C) {
      const D = C._dirtyLeaves, P = y._nodeMap;
      for (const S of D) {
        const L = P.get(S);
        ie(L) && L.isAttached() && L.isSimpleText() && !L.isUnmergeable() && gw(L);
      }
    }(l, t) : function(y, C) {
      const D = C._dirtyLeaves, P = C._dirtyElements, S = y._nodeMap, L = Pi(), O = /* @__PURE__ */ new Map();
      let M = D, F = M.size, k = P, I = k.size;
      for (; F > 0 || I > 0; ) {
        if (F > 0) {
          C._dirtyLeaves = /* @__PURE__ */ new Set();
          for (const N of M) {
            const R = S.get(N);
            ie(R) && R.isAttached() && R.isSimpleText() && !R.isUnmergeable() && gw(R), R !== void 0 && $w(R, L) && Lw(C, R, O), D.add(N);
          }
          if (M = C._dirtyLeaves, F = M.size, F > 0) {
            Mc++;
            continue;
          }
        }
        C._dirtyLeaves = /* @__PURE__ */ new Set(), C._dirtyElements = /* @__PURE__ */ new Map(), k.delete("root") && k.set("root", !0);
        for (const N of k) {
          const R = N[0], T = N[1];
          if (P.set(R, T), !T) continue;
          const A = S.get(R);
          A !== void 0 && $w(A, L) && Lw(C, A, O);
        }
        M = C._dirtyLeaves, F = M.size, k = C._dirtyElements, I = k.size, Mc++;
      }
      C._dirtyLeaves = D, C._dirtyElements = P;
    }(l, t), Bw(t), function(y, C, D, P) {
      const S = y._nodeMap, L = C._nodeMap, O = [];
      for (const [M] of P) {
        const F = L.get(M);
        F !== void 0 && (F.isAttached() || (X(F) && Yy(F, M, S, L, O, P), S.has(M) || P.delete(M), O.push(M)));
      }
      for (const M of O) L.delete(M);
      for (const M of D) {
        const F = L.get(M);
        F === void 0 || F.isAttached() || (S.has(M) || D.delete(M), L.delete(M));
      }
    }(a, l, t._dirtyLeaves, t._dirtyElements)), b !== t._compositionKey && (l._flushSync = !0);
    const _ = l._selection;
    if (Z(_)) {
      const y = l._nodeMap, C = _.anchor.key, D = _.focus.key;
      y.get(C) !== void 0 && y.get(D) !== void 0 || le(19);
    } else bn(_) && _._nodes.size === 0 && (l._selection = null);
  } catch (b) {
    return b instanceof Error && t._onError(b), t._pendingEditorState = a, t._dirtyType = Ls, t._cloneNotNeeded.clear(), t._dirtyLeaves = /* @__PURE__ */ new Set(), t._dirtyElements.clear(), void di(t);
  } finally {
    Ut = u, Mn = f, zt = d, t._updating = h, Mc = 0;
  }
  t._dirtyType !== $o || t._deferred.length > 0 || function(b, _) {
    const y = _.getEditorState()._selection, C = b._selection;
    if (C !== null) {
      if (C.dirty || !C.is(y)) return !0;
    } else if (y !== null) return !0;
    return !1;
  }(l, t) ? l._flushSync ? (l._flushSync = !1, di(t)) : c && Yk(() => {
    di(t);
  }) : (l._flushSync = !1, c && (r.clear(), t._deferred = [], t._pendingEditorState = null));
}
function Wn(t, e, n) {
  zt === t && n === void 0 ? e() : Ku(t, e, n);
}
let zk = class Oc {
  constructor(e, n, r) {
    this.element = e, this.before = n || null, this.after = r || null;
  }
  withBefore(e) {
    return new Oc(this.element, e, this.after);
  }
  withAfter(e) {
    return new Oc(this.element, this.before, e);
  }
  withElement(e) {
    return this.element === e ? this : new Oc(e, this.before, this.after);
  }
  insertChild(e) {
    const n = this.before || this.getManagedLineBreak();
    return n !== null && n.parentElement !== this.element && le(222), this.element.insertBefore(e, n), this;
  }
  removeChild(e) {
    return e.parentElement !== this.element && le(223), this.element.removeChild(e), this;
  }
  replaceChild(e, n) {
    return n.parentElement !== this.element && le(224), this.element.replaceChild(e, n), this;
  }
  getFirstChild() {
    const e = this.after ? this.after.nextSibling : this.element.firstChild;
    return e === this.before || e === this.getManagedLineBreak() ? null : e;
  }
  getManagedLineBreak() {
    return this.element.__lexicalLineBreak || null;
  }
  setManagedLineBreak(e) {
    if (e === null) this.removeManagedLineBreak();
    else {
      const n = e === "decorator" && (Ps || al);
      this.insertManagedLineBreak(n);
    }
  }
  removeManagedLineBreak() {
    const e = this.getManagedLineBreak();
    if (e) {
      const n = this.element, r = e.nodeName === "IMG" ? e.nextSibling : null;
      r && n.removeChild(r), n.removeChild(e), n.__lexicalLineBreak = void 0;
    }
  }
  insertManagedLineBreak(e) {
    const n = this.getManagedLineBreak();
    if (n) {
      if (e === (n.nodeName === "IMG")) return;
      this.removeManagedLineBreak();
    }
    const r = this.element, i = this.before, o = document.createElement("br");
    if (r.insertBefore(o, i), e) {
      const s = document.createElement("img");
      s.setAttribute("data-lexical-linebreak", "true"), s.style.cssText = "display: inline !important; border: 0px !important; margin: 0px !important;", s.alt = "", r.insertBefore(s, o), r.__lexicalLineBreak = s;
    } else r.__lexicalLineBreak = o;
  }
  getFirstChildOffset() {
    let e = 0;
    for (let n = this.after; n !== null; n = n.previousSibling) e++;
    return e;
  }
  resolveChildIndex(e, n, r, i) {
    if (r === this.element) {
      const l = this.getFirstChildOffset();
      return [e, Math.min(l + e.getChildrenSize(), Math.max(l, i))];
    }
    const o = qw(n, r);
    o.push(i);
    const s = qw(n, this.element);
    let a = e.getIndexWithinParent();
    for (let l = 0; l < s.length; l++) {
      const c = o[l], u = s[l];
      if (c === void 0 || c < u) break;
      if (c > u) {
        a += 1;
        break;
      }
    }
    return [e.getParentOrThrow(), a];
  }
};
function qw(t, e) {
  const n = [];
  let r = e;
  for (; r !== t && r !== null; r = r.parentNode) {
    let i = 0;
    for (let o = r.previousSibling; o !== null; o = o.previousSibling) i++;
    n.push(i);
  }
  return r !== t && le(225), n.reverse();
}
let pn = class extends da {
  constructor(e) {
    super(e), this.__first = null, this.__last = null, this.__size = 0, this.__format = 0, this.__style = "", this.__indent = 0, this.__dir = null, this.__textFormat = 0, this.__textStyle = "";
  }
  afterCloneFrom(e) {
    super.afterCloneFrom(e), this.__key === e.__key && (this.__first = e.__first, this.__last = e.__last, this.__size = e.__size), this.__indent = e.__indent, this.__format = e.__format, this.__style = e.__style, this.__dir = e.__dir, this.__textFormat = e.__textFormat, this.__textStyle = e.__textStyle;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getFormatType() {
    const e = this.getFormat();
    return ok[e] || "";
  }
  getStyle() {
    return this.getLatest().__style;
  }
  getIndent() {
    return this.getLatest().__indent;
  }
  getChildren() {
    const e = [];
    let n = this.getFirstChild();
    for (; n !== null; ) e.push(n), n = n.getNextSibling();
    return e;
  }
  getChildrenKeys() {
    const e = [];
    let n = this.getFirstChild();
    for (; n !== null; ) e.push(n.__key), n = n.getNextSibling();
    return e;
  }
  getChildrenSize() {
    return this.getLatest().__size;
  }
  isEmpty() {
    return this.getChildrenSize() === 0;
  }
  isDirty() {
    const e = wt()._dirtyElements;
    return e !== null && e.has(this.__key);
  }
  isLastChild() {
    const e = this.getLatest(), n = this.getParentOrThrow().getLastChild();
    return n !== null && n.is(e);
  }
  getAllTextNodes() {
    const e = [];
    let n = this.getFirstChild();
    for (; n !== null; ) {
      if (ie(n) && e.push(n), X(n)) {
        const r = n.getAllTextNodes();
        e.push(...r);
      }
      n = n.getNextSibling();
    }
    return e;
  }
  getFirstDescendant() {
    let e = this.getFirstChild();
    for (; X(e); ) {
      const n = e.getFirstChild();
      if (n === null) break;
      e = n;
    }
    return e;
  }
  getLastDescendant() {
    let e = this.getLastChild();
    for (; X(e); ) {
      const n = e.getLastChild();
      if (n === null) break;
      e = n;
    }
    return e;
  }
  getDescendantByIndex(e) {
    const n = this.getChildren(), r = n.length;
    if (e >= r) {
      const o = n[r - 1];
      return X(o) && o.getLastDescendant() || o || null;
    }
    const i = n[e];
    return X(i) && i.getFirstDescendant() || i || null;
  }
  getFirstChild() {
    const e = this.getLatest().__first;
    return e === null ? null : Oe(e);
  }
  getFirstChildOrThrow() {
    const e = this.getFirstChild();
    return e === null && le(45, this.__key), e;
  }
  getLastChild() {
    const e = this.getLatest().__last;
    return e === null ? null : Oe(e);
  }
  getLastChildOrThrow() {
    const e = this.getLastChild();
    return e === null && le(96, this.__key), e;
  }
  getChildAtIndex(e) {
    const n = this.getChildrenSize();
    let r, i;
    if (e < n / 2) {
      for (r = this.getFirstChild(), i = 0; r !== null && i <= e; ) {
        if (i === e) return r;
        r = r.getNextSibling(), i++;
      }
      return null;
    }
    for (r = this.getLastChild(), i = n - 1; r !== null && i >= e; ) {
      if (i === e) return r;
      r = r.getPreviousSibling(), i--;
    }
    return null;
  }
  getTextContent() {
    let e = "";
    const n = this.getChildren(), r = n.length;
    for (let i = 0; i < r; i++) {
      const o = n[i];
      e += o.getTextContent(), X(o) && i !== r - 1 && !o.isInline() && (e += mi);
    }
    return e;
  }
  getTextContentSize() {
    let e = 0;
    const n = this.getChildren(), r = n.length;
    for (let i = 0; i < r; i++) {
      const o = n[i];
      e += o.getTextContentSize(), X(o) && i !== r - 1 && !o.isInline() && (e += mi.length);
    }
    return e;
  }
  getDirection() {
    return this.getLatest().__dir;
  }
  getTextFormat() {
    return this.getLatest().__textFormat;
  }
  hasFormat(e) {
    if (e !== "") {
      const n = aw[e];
      return !!(this.getFormat() & n);
    }
    return !1;
  }
  hasTextFormat(e) {
    const n = Ui[e];
    return !!(this.getTextFormat() & n);
  }
  getFormatFlags(e, n) {
    return iu(this.getLatest().__textFormat, e, n);
  }
  getTextStyle() {
    return this.getLatest().__textStyle;
  }
  select(e, n) {
    Zt();
    const r = oe();
    let i = e, o = n;
    const s = this.getChildrenSize();
    if (!this.canBeEmpty()) {
      if (e === 0 && n === 0) {
        const l = this.getFirstChild();
        if (ie(l) || X(l)) return l.select(0, 0);
      } else if (!(e !== void 0 && e !== s || n !== void 0 && n !== s)) {
        const l = this.getLastChild();
        if (ie(l) || X(l)) return l.select();
      }
    }
    i === void 0 && (i = s), o === void 0 && (o = s);
    const a = this.__key;
    return Z(r) ? (r.anchor.set(a, i, "element"), r.focus.set(a, o, "element"), r.dirty = !0, r) : M0(a, i, a, o, "element", "element");
  }
  selectStart() {
    const e = this.getFirstDescendant();
    return e ? e.selectStart() : this.select();
  }
  selectEnd() {
    const e = this.getLastDescendant();
    return e ? e.selectEnd() : this.select();
  }
  clear() {
    const e = this.getWritable();
    return this.getChildren().forEach((n) => n.remove()), e;
  }
  append(...e) {
    return this.splice(this.getChildrenSize(), 0, e);
  }
  setDirection(e) {
    const n = this.getWritable();
    return n.__dir = e, n;
  }
  setFormat(e) {
    return this.getWritable().__format = e !== "" ? aw[e] : 0, this;
  }
  setStyle(e) {
    return this.getWritable().__style = e || "", this;
  }
  setTextFormat(e) {
    const n = this.getWritable();
    return n.__textFormat = e, n;
  }
  setTextStyle(e) {
    const n = this.getWritable();
    return n.__textStyle = e, n;
  }
  setIndent(e) {
    return this.getWritable().__indent = e, this;
  }
  splice(e, n, r) {
    const i = r.length, o = this.getChildrenSize(), s = this.getWritable();
    e + n <= o || le(226, String(e), String(n), String(o));
    const a = s.__key, l = [], c = [], u = this.getChildAtIndex(e + n);
    let f = null, d = o - n + i;
    if (e !== 0) if (e === o) f = this.getLastChild();
    else {
      const g = this.getChildAtIndex(e);
      g !== null && (f = g.getPreviousSibling());
    }
    if (n > 0) {
      let g = f === null ? this.getFirstChild() : f.getNextSibling();
      for (let w = 0; w < n; w++) {
        g === null && le(100);
        const b = g.getNextSibling(), _ = g.__key;
        So(g.getWritable()), c.push(_), g = b;
      }
    }
    let h = f;
    for (let g = 0; g < i; g++) {
      const w = r[g];
      h !== null && w.is(h) && (f = h = h.getPreviousSibling());
      const b = w.getWritable();
      b.__parent === a && d--, So(b);
      const _ = w.__key;
      if (h === null) s.__first = _, b.__prev = null;
      else {
        const y = h.getWritable();
        y.__next = _, b.__prev = y.__key;
      }
      w.__key === a && le(76), b.__parent = a, l.push(_), h = w;
    }
    if (e + n === o)
      h !== null && (h.getWritable().__next = null, s.__last = h.__key);
    else if (u !== null) {
      const g = u.getWritable();
      if (h !== null) {
        const w = h.getWritable();
        g.__prev = h.__key, w.__next = u.__key;
      } else g.__prev = null;
    }
    if (s.__size = d, c.length) {
      const g = oe();
      if (Z(g)) {
        const w = new Set(c), b = new Set(l), { anchor: _, focus: y } = g;
        jw(_, w, b) && ru(_, _.getNode(), this, f, u), jw(y, w, b) && ru(y, y.getNode(), this, f, u), d !== 0 || this.canBeEmpty() || Zr(this) || this.remove();
      }
    }
    return s;
  }
  getDOMSlot(e) {
    return new zk(e);
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    if (it(n)) {
      const r = this.getIndent();
      r > 0 && (n.style.paddingInlineStart = 40 * r + "px");
      const i = this.getDirection();
      i && (n.dir = i);
    }
    return { element: n };
  }
  exportJSON() {
    const e = { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), ...super.exportJSON() }, n = this.getTextFormat(), r = this.getTextStyle();
    return n !== 0 && (e.textFormat = n), r !== "" && (e.textStyle = r), e;
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setFormat(e.format).setIndent(e.indent).setDirection(e.direction).setTextFormat(e.textFormat || 0).setTextStyle(e.textStyle || "");
  }
  insertNewAfter(e, n) {
    return null;
  }
  canIndent() {
    return !0;
  }
  collapseAtStart(e) {
    return !1;
  }
  excludeFromCopy(e) {
    return !1;
  }
  canReplaceWith(e) {
    return !0;
  }
  canInsertAfter(e) {
    return !0;
  }
  canBeEmpty() {
    return !0;
  }
  canInsertTextBefore() {
    return !0;
  }
  canInsertTextAfter() {
    return !0;
  }
  isInline() {
    return !1;
  }
  isShadowRoot() {
    return !1;
  }
  canMergeWith(e) {
    return !1;
  }
  extractWithChild(e, n, r) {
    return !1;
  }
  canMergeWhenEmpty() {
    return !1;
  }
  reconcileObservedMutation(e, n) {
    const r = this.getDOMSlot(e);
    let i = r.getFirstChild();
    for (let o = this.getFirstChild(); o; o = o.getNextSibling()) {
      const s = n.getElementByKey(o.getKey());
      s !== null && (i == null ? (r.insertChild(s), i = s) : i !== s && r.replaceChild(s, i), i = i.nextSibling);
    }
  }
};
function X(t) {
  return t instanceof pn;
}
function jw(t, e, n) {
  let r = t.getNode();
  for (; r; ) {
    const i = r.__key;
    if (e.has(i) && !n.has(i)) return !0;
    r = r.getParent();
  }
  return !1;
}
class eo extends da {
  decorate(e, n) {
    le(47);
  }
  isIsolated() {
    return !1;
  }
  isInline() {
    return !0;
  }
  isKeyboardSelectable() {
    return !0;
  }
}
function Xe(t) {
  return t instanceof eo;
}
let Ep = class F0 extends pn {
  static getType() {
    return "root";
  }
  static clone() {
    return new F0();
  }
  constructor() {
    super("root"), this.__cachedText = null;
  }
  getTopLevelElementOrThrow() {
    le(51);
  }
  getTextContent() {
    const e = this.__cachedText;
    return !ha() && wt()._dirtyType !== $o || e === null ? super.getTextContent() : e;
  }
  remove() {
    le(52);
  }
  replace(e) {
    le(53);
  }
  insertBefore(e) {
    le(54);
  }
  insertAfter(e) {
    le(55);
  }
  updateDOM(e, n) {
    return !1;
  }
  splice(e, n, r) {
    for (const i of r) X(i) || Xe(i) || le(282);
    return super.splice(e, n, r);
  }
  static importJSON(e) {
    return Ve().updateFromJSON(e);
  }
  collapseAtStart() {
    return !0;
  }
};
function tn(t) {
  return t instanceof Ep;
}
function B0(t) {
  return new Wu(new Map(t._nodeMap));
}
function Np() {
  return new Wu(/* @__PURE__ */ new Map([["root", new Ep()]]));
}
function q0(t) {
  const e = t.exportJSON(), n = t.constructor;
  if (e.type !== n.getType() && le(130, n.name), X(t)) {
    const r = e.children;
    Array.isArray(r) || le(59, n.name);
    const i = t.getChildren();
    for (let o = 0; o < i.length; o++) {
      const s = q0(i[o]);
      r.push(s);
    }
  }
  return e;
}
class Wu {
  constructor(e, n) {
    this._nodeMap = e, this._selection = n || null, this._flushSync = !1, this._readOnly = !1;
  }
  isEmpty() {
    return this._nodeMap.size === 1 && this._selection === null;
  }
  read(e, n) {
    return Fw(n && n.editor || null, this, e);
  }
  clone(e) {
    const n = new Wu(this._nodeMap, e === void 0 ? this._selection : e);
    return n._readOnly = !0, n;
  }
  toJSON() {
    return Fw(null, this, () => ({ root: q0(Ve()) }));
  }
}
const Qf = "historic", Vk = "history-push", Eo = "history-merge", j0 = "paste", Hk = "collaboration", Kk = "skip-scroll-into-view", Wk = "skip-dom-selection";
class Sp extends pn {
  static getType() {
    return "artificial";
  }
  createDOM(e) {
    return document.createElement("div");
  }
}
class to extends pn {
  static getType() {
    return "paragraph";
  }
  static clone(e) {
    return new to(e.__key);
  }
  createDOM(e) {
    const n = document.createElement("p"), r = Es(e.theme, "paragraph");
    return r !== void 0 && n.classList.add(...r), n;
  }
  updateDOM(e, n, r) {
    return !1;
  }
  static importDOM() {
    return { p: (e) => ({ conversion: Gk, priority: 0 }) };
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    if (it(n)) {
      this.isEmpty() && n.append(document.createElement("br"));
      const r = this.getFormatType();
      r && (n.style.textAlign = r);
    }
    return { element: n };
  }
  static importJSON(e) {
    return Jn().updateFromJSON(e);
  }
  exportJSON() {
    return { ...super.exportJSON(), textFormat: this.getTextFormat(), textStyle: this.getTextStyle() };
  }
  insertNewAfter(e, n) {
    const r = Jn();
    r.setTextFormat(e.format), r.setTextStyle(e.style);
    const i = this.getDirection();
    return r.setDirection(i), r.setFormat(this.getFormatType()), r.setStyle(this.getStyle()), this.insertAfter(r, n), r;
  }
  collapseAtStart() {
    const e = this.getChildren();
    if (e.length === 0 || ie(e[0]) && e[0].getTextContent().trim() === "") {
      if (this.getNextSibling() !== null) return this.selectNext(), this.remove(), !0;
      if (this.getPreviousSibling() !== null) return this.selectPrevious(), this.remove(), !0;
    }
    return !1;
  }
}
function Gk(t) {
  const e = Jn();
  return t.style && (e.setFormat(t.style.textAlign), lE(t, e)), { node: e };
}
function Jn() {
  return lt(new to());
}
function Tp(t) {
  return t instanceof to;
}
const ke = 0, rs = 1, Ic = 2, Gu = 3, ks = 4;
function U0(t, e, n, r) {
  const i = t._keyToDOMMap;
  i.clear(), t._editorState = Np(), t._pendingEditorState = r, t._compositionKey = null, t._dirtyType = $o, t._cloneNotNeeded.clear(), t._dirtyLeaves = /* @__PURE__ */ new Set(), t._dirtyElements.clear(), t._normalizedNodes = /* @__PURE__ */ new Set(), t._updateTags = /* @__PURE__ */ new Set(), t._updates = [], t._blockCursorElement = null;
  const o = t._observer;
  o !== null && (o.disconnect(), t._observer = null), e !== null && (e.textContent = ""), n !== null && (n.textContent = "", i.set("root", n));
}
function Jk(t) {
  const e = t || {}, n = Uk(), r = e.theme || {}, i = t === void 0 ? n : e.parentEditor || null, o = e.disableEvents || !1, s = Np(), a = e.namespace || (i !== null ? i._config.namespace : J0()), l = e.editorState, c = [Ep, _n, Rl, Pl, to, Sp, ...e.nodes || []], { onError: u, html: f } = e, d = e.editable === void 0 || e.editable;
  let h;
  if (t === void 0 && n !== null) h = n._nodes;
  else {
    h = /* @__PURE__ */ new Map();
    for (let w = 0; w < c.length; w++) {
      let b = c[w], _ = null, y = null;
      if (typeof b != "function") {
        const L = b;
        b = L.replace, _ = L.with, y = L.withKlass || null;
      }
      const { ownNodeConfig: C } = Bp(b), D = b.getType(), P = b.transform(), S = /* @__PURE__ */ new Set();
      C && C.$transform && S.add(C.$transform), P !== null && S.add(P), h.set(D, { exportDOM: f && f.export ? f.export.get(b) : void 0, klass: b, replace: _, replaceWithKlass: y, sharedNodeState: pk(c[w]), transforms: S });
    }
  }
  const g = new Ju(s, i, h, { disableEvents: o, namespace: a, theme: r }, u || console.error, function(w, b) {
    const _ = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Set(), C = (D) => {
      Object.keys(D).forEach((P) => {
        let S = _.get(P);
        S === void 0 && (S = [], _.set(P, S)), S.push(D[P]);
      });
    };
    return w.forEach((D) => {
      const P = D.klass.importDOM;
      if (P == null || y.has(P)) return;
      y.add(P);
      const S = P.call(D.klass);
      S !== null && C(S);
    }), b && C(b), _;
  }(h, f ? f.import : void 0), d, t);
  return l !== void 0 && (g._pendingEditorState = l, g._dirtyType = Ls), g;
}
class Ju {
  constructor(e, n, r, i, o, s, a, l) {
    this._createEditorArgs = l, this._parentEditor = n, this._rootElement = null, this._editorState = e, this._pendingEditorState = null, this._compositionKey = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = !1, this._listeners = { decorator: /* @__PURE__ */ new Set(), editable: /* @__PURE__ */ new Set(), mutation: /* @__PURE__ */ new Map(), root: /* @__PURE__ */ new Set(), textcontent: /* @__PURE__ */ new Set(), update: /* @__PURE__ */ new Set() }, this._commands = /* @__PURE__ */ new Map(), this._config = i, this._nodes = r, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = $o, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = J0(), this._onError = o, this._htmlConversions = s, this._editable = a, this._headless = n !== null && n._headless, this._window = null, this._blockCursorElement = null;
  }
  isComposing() {
    return this._compositionKey != null;
  }
  registerUpdateListener(e) {
    const n = this._listeners.update;
    return n.add(e), () => {
      n.delete(e);
    };
  }
  registerEditableListener(e) {
    const n = this._listeners.editable;
    return n.add(e), () => {
      n.delete(e);
    };
  }
  registerDecoratorListener(e) {
    const n = this._listeners.decorator;
    return n.add(e), () => {
      n.delete(e);
    };
  }
  registerTextContentListener(e) {
    const n = this._listeners.textcontent;
    return n.add(e), () => {
      n.delete(e);
    };
  }
  registerRootListener(e) {
    const n = this._listeners.root;
    return e(this._rootElement, null), n.add(e), () => {
      e(null, this._rootElement), n.delete(e);
    };
  }
  registerCommand(e, n, r) {
    r === void 0 && le(35);
    const i = this._commands;
    i.has(e) || i.set(e, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
    const o = i.get(e);
    o === void 0 && le(36, String(e));
    const s = o[r];
    return s.add(n), () => {
      s.delete(n), o.every((a) => a.size === 0) && i.delete(e);
    };
  }
  registerMutationListener(e, n, r) {
    const i = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(e)).klass, o = this._listeners.mutation;
    let s = o.get(n);
    s === void 0 && (s = /* @__PURE__ */ new Set(), o.set(n, s)), s.add(i);
    const a = r && r.skipInitialization;
    return a !== void 0 && a || this.initializeMutationListener(n, i), () => {
      s.delete(i), s.size === 0 && o.delete(n);
    };
  }
  getRegisteredNode(e) {
    const n = this._nodes.get(e.getType());
    return n === void 0 && le(37, e.name), n;
  }
  resolveRegisteredNodeAfterReplacements(e) {
    for (; e.replaceWithKlass; ) e = this.getRegisteredNode(e.replaceWithKlass);
    return e;
  }
  initializeMutationListener(e, n) {
    const r = this._editorState, i = Xw(r).get(n.getType());
    if (!i) return;
    const o = /* @__PURE__ */ new Map();
    for (const s of i.keys()) o.set(s, "created");
    o.size > 0 && e(o, { dirtyLeaves: /* @__PURE__ */ new Set(), prevEditorState: r, updateTags: /* @__PURE__ */ new Set(["registerMutationListener"]) });
  }
  registerNodeTransformToKlass(e, n) {
    const r = this.getRegisteredNode(e);
    return r.transforms.add(n), r;
  }
  registerNodeTransform(e, n) {
    const r = this.registerNodeTransformToKlass(e, n), i = [r], o = r.replaceWithKlass;
    if (o != null) {
      const s = this.registerNodeTransformToKlass(o, n);
      i.push(s);
    }
    return function(s, a) {
      const l = Xw(s.getEditorState()), c = [];
      for (const u of a) {
        const f = l.get(u);
        f && c.push(f);
      }
      c.length !== 0 && s.update(() => {
        for (const u of c) for (const f of u.keys()) {
          const d = Oe(f);
          d && d.markDirty();
        }
      }, s._pendingEditorState === null ? { tag: Eo } : void 0);
    }(this, i.map((s) => s.klass.getType())), () => {
      i.forEach((s) => s.transforms.delete(n));
    };
  }
  hasNode(e) {
    return this._nodes.has(e.getType());
  }
  hasNodes(e) {
    return e.every(this.hasNode.bind(this));
  }
  dispatchCommand(e, n) {
    return ge(this, e, n);
  }
  getDecorators() {
    return this._decorators;
  }
  getRootElement() {
    return this._rootElement;
  }
  getKey() {
    return this._key;
  }
  setRootElement(e) {
    const n = this._rootElement;
    if (e !== n) {
      const r = Es(this._config.theme, "root"), i = this._pendingEditorState || this._editorState;
      if (this._rootElement = e, U0(this, n, e, i), n !== null && (this._config.disableEvents || Dk(n), r != null && n.classList.remove(...r)), e !== null) {
        const o = $p(e), s = e.style;
        s.userSelect = "text", s.whiteSpace = "pre-wrap", s.wordBreak = "break-word", e.setAttribute("data-lexical-editor", "true"), this._window = o, this._dirtyType = Ls, e0(this), this._updateTags.add(Eo), di(this), this._config.disableEvents || function(a, l) {
          const c = a.ownerDocument, u = tu.get(c);
          (u === void 0 || u < 1) && c.addEventListener("selectionchange", x0), tu.set(c, (u || 0) + 1), a.__lexicalEditor = l;
          const f = _0(a);
          for (let d = 0; d < Kf.length; d++) {
            const [h, g] = Kf[d], w = typeof g == "function" ? (b) => {
              xw(b) || (_w(b), (l.isEditable() || h === "click") && g(b, l));
            } : (b) => {
              if (xw(b)) return;
              _w(b);
              const _ = l.isEditable();
              switch (h) {
                case "cut":
                  return _ && ge(l, ts, b);
                case "copy":
                  return ge(l, Qi, b);
                case "paste":
                  return _ && ge(l, es, b);
                case "dragstart":
                  return _ && ge(l, vp, b);
                case "dragover":
                  return _ && ge(l, h0, b);
                case "dragend":
                  return _ && ge(l, Nk, b);
                case "focus":
                  return _ && ge(l, Sk, b);
                case "blur":
                  return _ && ge(l, Tk, b);
                case "drop":
                  return _ && ge(l, Hu, b);
              }
            };
            a.addEventListener(h, w), f.push(() => {
              a.removeEventListener(h, w);
            });
          }
        }(e, this), r != null && e.classList.add(...r);
      } else this._window = null, this._updateTags.add(Eo), di(this);
      Ya("root", this, !1, e, n);
    }
  }
  getElementByKey(e) {
    return this._keyToDOMMap.get(e) || null;
  }
  getEditorState() {
    return this._editorState;
  }
  setEditorState(e, n) {
    e.isEmpty() && le(38);
    let r = e;
    r._readOnly && (r = B0(e), r._selection = e._selection ? e._selection.clone() : null), Zy(this);
    const i = this._pendingEditorState, o = this._updateTags, s = n !== void 0 ? n.tag : null;
    i === null || i.isEmpty() || (s != null && o.add(s), di(this)), this._pendingEditorState = r, this._dirtyType = Ls, this._dirtyElements.set("root", !1), this._compositionKey = null, s != null && o.add(s), this._updating || di(this);
  }
  parseEditorState(e, n) {
    return function(r, i, o) {
      const s = Np(), a = Ut, l = Mn, c = zt, u = i._dirtyElements, f = i._dirtyLeaves, d = i._cloneNotNeeded, h = i._dirtyType;
      i._dirtyElements = /* @__PURE__ */ new Map(), i._dirtyLeaves = /* @__PURE__ */ new Set(), i._cloneNotNeeded = /* @__PURE__ */ new Set(), i._dirtyType = 0, Ut = s, Mn = !1, zt = i, Ap(null);
      try {
        const g = i._nodes;
        kp(r.root, g), o && o(), s._readOnly = !0;
      } catch (g) {
        g instanceof Error && i._onError(g);
      } finally {
        i._dirtyElements = u, i._dirtyLeaves = f, i._cloneNotNeeded = d, i._dirtyType = h, Ut = a, Mn = l, zt = c;
      }
      return s;
    }(typeof e == "string" ? JSON.parse(e) : e, this, n);
  }
  read(e) {
    return di(this), this.getEditorState().read(e, { editor: this });
  }
  update(e, n) {
    (function(r, i, o) {
      r._updating ? r._updates.push([i, o]) : Ku(r, i, o);
    })(this, e, n);
  }
  focus(e, n = {}) {
    const r = this._rootElement;
    r !== null && (r.setAttribute("autocapitalize", "off"), Wn(this, () => {
      const i = oe(), o = Ve();
      i !== null ? i.dirty || sn(i.clone()) : o.getChildrenSize() !== 0 && (n.defaultSelection === "rootStart" ? o.selectStart() : o.selectEnd()), ev("focus"), nE(() => {
        r.removeAttribute("autocapitalize"), e && e();
      });
    }), this._pendingEditorState === null && r.removeAttribute("autocapitalize"));
  }
  blur() {
    const e = this._rootElement;
    e !== null && e.blur();
    const n = vr(this._window);
    n !== null && n.removeAllRanges();
  }
  isEditable() {
    return this._editable;
  }
  setEditable(e) {
    this._editable !== e && (this._editable = e, Ya("editable", this, !0, e));
  }
  toJSON() {
    return { editorState: this._editorState.toJSON() };
  }
}
Ju.version = "0.34.0+prod.esm";
let Zf = null;
function Ap(t) {
  Zf = t;
}
let Xk = 1;
function z0(t, e) {
  const n = Dp(t, e);
  return n === void 0 && le(30, e), n;
}
function Dp(t, e) {
  return t._nodes.get(e);
}
const Yk = typeof queueMicrotask == "function" ? queueMicrotask : (t) => {
  Promise.resolve().then(t);
};
function Uw(t) {
  return Xe(Vi(t));
}
function Mp(t) {
  const e = document.activeElement;
  if (!it(e)) return !1;
  const n = e.nodeName;
  return Xe(Vi(t)) && (n === "INPUT" || n === "TEXTAREA" || e.contentEditable === "true" && Xu(e) == null);
}
function Fl(t, e, n) {
  const r = t.getRootElement();
  try {
    return r !== null && r.contains(e) && r.contains(n) && e !== null && !Mp(e) && V0(e) === t;
  } catch {
    return !1;
  }
}
function Op(t) {
  return t instanceof Ju;
}
function V0(t) {
  let e = t;
  for (; e != null; ) {
    const n = Xu(e);
    if (Op(n)) return n;
    e = Bl(e);
  }
  return null;
}
function Xu(t) {
  return t ? t.__lexicalEditor : null;
}
function No(t) {
  return N0(t) || t.isToken();
}
function li(t) {
  return No(t) || t.isSegmented();
}
function ki(t) {
  return is(t) && t.nodeType === GC;
}
function Qk(t) {
  return is(t) && t.nodeType === JC;
}
function js(t) {
  let e = t;
  for (; e != null; ) {
    if (ki(e)) return e;
    e = e.firstChild;
  }
  return null;
}
function iu(t, e, n) {
  const r = Ui[e];
  if (n !== null && (t & r) == (n & r)) return t;
  let i = t ^ r;
  return e === "subscript" ? i &= -65 : e === "superscript" ? i &= -33 : e === "lowercase" ? (i &= -513, i &= -1025) : e === "uppercase" ? (i &= -257, i &= -1025) : e === "capitalize" && (i &= -257, i &= -513), i;
}
function Zk(t, e) {
  const n = function() {
    const s = Zf;
    return Zf = null, s;
  }();
  if ((e = e || n && n.__key) != null) return void (t.__key = e);
  Zt(), R0();
  const r = wt(), i = Zi(), o = "" + Xk++;
  i._nodeMap.set(o, t), X(t) ? r._dirtyElements.set(o, !0) : r._dirtyLeaves.add(o), r._cloneNotNeeded.add(o), r._dirtyType = Gy, t.__key = o;
}
function So(t) {
  const e = t.getParent();
  if (e !== null) {
    const n = t.getWritable(), r = e.getWritable(), i = t.getPreviousSibling(), o = t.getNextSibling(), s = o !== null ? o.__key : null, a = i !== null ? i.__key : null, l = i !== null ? i.getWritable() : null, c = o !== null ? o.getWritable() : null;
    i === null && (r.__first = s), o === null && (r.__last = a), l !== null && (l.__next = s), c !== null && (c.__prev = a), n.__prev = null, n.__next = null, n.__parent = null, r.__size--;
  }
}
function ou(t) {
  R0();
  const e = t.getLatest(), n = e.__parent, r = Zi(), i = wt(), o = r._nodeMap, s = i._dirtyElements;
  n !== null && function(l, c, u) {
    let f = l;
    for (; f !== null; ) {
      if (u.has(f)) return;
      const d = c.get(f);
      if (d === void 0) break;
      u.set(f, !1), f = d.__parent;
    }
  }(n, o, s);
  const a = e.__key;
  i._dirtyType = Gy, X(t) ? s.set(a, !0) : i._dirtyLeaves.add(a);
}
function en(t) {
  Zt();
  const e = wt(), n = e._compositionKey;
  if (t !== n) {
    if (e._compositionKey = t, n !== null) {
      const r = Oe(n);
      r !== null && r.getWritable();
    }
    if (t !== null) {
      const r = Oe(t);
      r !== null && r.getWritable();
    }
  }
}
function Pi() {
  return ha() ? null : wt()._compositionKey;
}
function Oe(t, e) {
  const n = (e || Zi())._nodeMap.get(t);
  return n === void 0 ? null : n;
}
function H0(t, e) {
  const n = Yu(t, wt());
  return n !== void 0 ? Oe(n, e) : null;
}
function Yu(t, e) {
  return t[`__lexicalKey_${e._key}`];
}
function Vi(t, e) {
  let n = t;
  for (; n != null; ) {
    const r = H0(n, e);
    if (r !== null) return r;
    n = Bl(n);
  }
  return null;
}
function K0(t) {
  const e = t._decorators, n = Object.assign({}, e);
  return t._pendingDecorators = n, n;
}
function zw(t) {
  return t.read(() => Ve().getTextContent());
}
function Ve() {
  return W0(Zi());
}
function W0(t) {
  return t._nodeMap.get("root");
}
function sn(t) {
  Zt();
  const e = Zi();
  t !== null && (t.dirty = !0, t.setCachedNodes(null)), e._selection = t;
}
function ys(t) {
  const e = wt(), n = function(r, i) {
    let o = r;
    for (; o != null; ) {
      const s = Yu(o, i);
      if (s !== void 0) return s;
      o = Bl(o);
    }
    return null;
  }(t, e);
  return n === null ? t === e.getRootElement() ? Oe("root") : null : Oe(n);
}
function G0(t) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(t);
}
function Ip(t) {
  const e = [];
  let n = t;
  for (; n !== null; ) e.push(n), n = n._parentEditor;
  return e;
}
function J0() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substring(0, 5);
}
function X0(t) {
  return ki(t) ? t.nodeValue : null;
}
function Rp(t, e, n) {
  const r = vr(or(e));
  if (r === null) return;
  const i = r.anchorNode;
  let { anchorOffset: o, focusOffset: s } = r;
  if (i !== null) {
    let a = X0(i);
    const l = Vi(i);
    if (a !== null && ie(l)) {
      if (a === Uu && n) {
        const c = n.length;
        a = n, o = c, s = c;
      }
      a !== null && Pp(l, a, o, s, t);
    }
  }
}
function Pp(t, e, n, r, i) {
  let o = t;
  if (o.isAttached() && (i || !o.isDirty())) {
    const s = o.isComposing();
    let a = e;
    (s || i) && e[e.length - 1] === Uu && (a = e.slice(0, -1));
    const l = o.getTextContent();
    if (i || a !== l) {
      if (a === "") {
        if (en(null), al || Ps || Kc) o.remove();
        else {
          const w = wt();
          setTimeout(() => {
            w.update(() => {
              o.isAttached() && o.remove();
            });
          }, 20);
        }
        return;
      }
      const c = o.getParent(), u = fa(), f = o.getTextContentSize(), d = Pi(), h = o.getKey();
      if (o.isToken() || d !== null && h === d && !s || Z(u) && (c !== null && !c.canInsertTextBefore() && u.anchor.offset === 0 || u.anchor.key === t.__key && u.anchor.offset === 0 && !o.canInsertTextBefore() && !s || u.focus.key === t.__key && u.focus.offset === f && !o.canInsertTextAfter() && !s)) return void o.markDirty();
      const g = oe();
      if (!Z(g) || n === null || r === null) return void Vw(o, a, g);
      if (g.setTextNodeRange(o, n, o, r), o.isSegmented()) {
        const w = Re(o.getTextContent());
        o.replace(w), o = w;
      }
      Vw(o, a, g);
    }
  }
}
function Vw(t, e, n) {
  if (t.setTextContent(e), Z(n)) {
    const r = t.getKey();
    for (const i of ["anchor", "focus"]) {
      const o = n[i];
      o.type === "text" && o.key === r && (o.offset = qi(t, o.offset, "clamp"));
    }
  }
}
function fc(t, e, n) {
  const r = e[n] || !1;
  return r === "any" || r === t[n];
}
function eE(t, e) {
  return fc(t, e, "altKey") && fc(t, e, "ctrlKey") && fc(t, e, "shiftKey") && fc(t, e, "metaKey");
}
function et(t, e, n) {
  return eE(t, n) && t.key.toLowerCase() === e.toLowerCase();
}
const ai = { ctrlKey: !qr, metaKey: qr }, Hw = { altKey: qr, ctrlKey: !qr };
function Kw(t) {
  return t.key === "Backspace";
}
function Ww(t) {
  return et(t, "a", ai);
}
function Y0(t) {
  const e = Ve();
  if (Z(t)) {
    const n = t.anchor, r = t.focus, i = n.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    return n.set(i.getKey(), 0, "element"), r.set(i.getKey(), i.getChildrenSize(), "element"), ll(t), t;
  }
  {
    const n = e.select(0, e.getChildrenSize());
    return sn(ll(n)), n;
  }
}
function Es(t, e) {
  t.__lexicalClassNameCache === void 0 && (t.__lexicalClassNameCache = {});
  const n = t.__lexicalClassNameCache, r = n[e];
  if (r !== void 0) return r;
  const i = t[e];
  if (typeof i == "string") {
    const o = Wc(i);
    return n[e] = o, o;
  }
  return i;
}
function Lp(t, e, n, r, i) {
  if (n.size === 0) return;
  const o = r.__type, s = r.__key, a = e.get(o);
  a === void 0 && le(33, o);
  const l = a.klass;
  let c = t.get(l);
  c === void 0 && (c = /* @__PURE__ */ new Map(), t.set(l, c));
  const u = c.get(s), f = u === "destroyed" && i === "created";
  (u === void 0 || f) && c.set(s, f ? "updated" : i);
}
function Gw(t, e, n) {
  const r = t.getParent();
  let i = n, o = t;
  return r !== null && (e && n === 0 ? (i = o.getIndexWithinParent(), o = r) : e || n !== o.getChildrenSize() || (i = o.getIndexWithinParent() + 1, o = r)), o.getChildAtIndex(e ? i - 1 : i);
}
function eh(t, e) {
  const n = t.offset;
  if (t.type === "element")
    return Gw(t.getNode(), e, n);
  {
    const r = t.getNode();
    if (e && n === 0 || !e && n === r.getTextContentSize()) {
      const i = e ? r.getPreviousSibling() : r.getNextSibling();
      return i === null ? Gw(r.getParentOrThrow(), e, r.getIndexWithinParent() + (e ? 0 : 1)) : i;
    }
  }
  return null;
}
function Q0(t) {
  const e = or(t).event, n = e && e.inputType;
  return n === "insertFromPaste" || n === "insertFromPasteAsQuotation";
}
function ge(t, e, n) {
  return function(r, i, o) {
    const s = Ip(r);
    for (let a = 4; a >= 0; a--) for (let l = 0; l < s.length; l++) {
      const c = s[l], u = c._commands.get(i);
      if (u !== void 0) {
        const f = u[a];
        if (f !== void 0) {
          const d = Array.from(f), h = d.length;
          let g = !1;
          if (Wn(c, () => {
            for (let w = 0; w < h; w++) if (d[w](o, r)) return void (g = !0);
          }), g) return g;
        }
      }
    }
    return !1;
  }(t, e, n);
}
function Qu(t) {
  return !tn(t) && !t.isLastChild() && !t.isInline();
}
function Us(t, e) {
  const n = t._keyToDOMMap.get(e);
  return n === void 0 && le(75, e), n;
}
function Bl(t) {
  const e = t.assignedSlot || t.parentElement;
  return rh(e) ? e.host : e;
}
function Z0(t) {
  return Qk(t) ? t : it(t) ? t.ownerDocument : null;
}
function tE(t) {
  return wt()._updateTags.has(t);
}
function ev(t) {
  Zt(), wt()._updateTags.add(t);
}
function nE(t) {
  Zt(), wt()._deferred.push(t);
}
function th(t, e) {
  let n = t.getParent();
  for (; n !== null; ) {
    if (n.is(e)) return !0;
    n = n.getParent();
  }
  return !1;
}
function $p(t) {
  const e = Z0(t);
  return e ? e.defaultView : null;
}
function or(t) {
  const e = t._window;
  return e === null && le(78), e;
}
function rE(t) {
  return X(t) && t.isInline() || Xe(t) && t.isInline();
}
function iE(t) {
  let e = t.getParentOrThrow();
  for (; e !== null; ) {
    if (Zr(e)) return e;
    e = e.getParentOrThrow();
  }
  return e;
}
function Zr(t) {
  return tn(t) || X(t) && t.isShadowRoot();
}
function lt(t) {
  const e = wt(), n = t.getType(), r = Dp(e, n);
  r === void 0 && le(200, t.constructor.name, n);
  const { replace: i, replaceWithKlass: o } = r;
  if (i !== null) {
    const s = i(t), a = s.constructor;
    return o !== null ? s instanceof o || le(201, o.name, o.getType(), a.name, a.getType(), t.constructor.name, n) : s instanceof t.constructor && a !== t.constructor || le(202, a.name, a.getType(), t.constructor.name, n), s.__key === t.__key && le(203, t.constructor.name, n, a.name, a.getType()), s;
  }
  return t;
}
function Yd(t, e) {
  !tn(t.getParent()) || X(e) || Xe(e) || le(99);
}
function oE(t) {
  const e = Oe(t);
  return e === null && le(63, t), e;
}
function Qd(t) {
  return (Xe(t) || X(t) && !t.canBeEmpty()) && !t.isInline();
}
function nh(t, e, n) {
  n.style.removeProperty("caret-color"), e._blockCursorElement = null;
  const r = t.parentElement;
  r !== null && r.removeChild(t);
}
function vr(t) {
  return Tr ? (t || window).getSelection() : null;
}
function sE(t) {
  const e = $p(t);
  return e ? e.getSelection() : null;
}
function tv(t) {
  return it(t) && t.tagName === "A";
}
function it(t) {
  return is(t) && t.nodeType === WC;
}
function is(t) {
  return typeof t == "object" && t !== null && "nodeType" in t && typeof t.nodeType == "number";
}
function rh(t) {
  return is(t) && t.nodeType === XC;
}
function ih(t) {
  const e = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|mark|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, "i");
  return t.nodeName.match(e) !== null;
}
function su(t) {
  const e = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, "i");
  return t.nodeName.match(e) !== null;
}
function nr(t) {
  if (Xe(t) && !t.isInline()) return !0;
  if (!X(t) || Zr(t)) return !1;
  const e = t.getFirstChild(), n = e === null || ko(e) || ie(e) || e.isInline();
  return !t.isInline() && t.canBeEmpty() !== !1 && n;
}
function Zd(t, e) {
  let n = t;
  for (; n !== null && n.getParent() !== null && !e(n); ) n = n.getParentOrThrow();
  return e(n) ? n : null;
}
function Zu() {
  return wt();
}
const Jw = /* @__PURE__ */ new WeakMap(), aE = /* @__PURE__ */ new Map();
function Xw(t) {
  if (!t._readOnly && t.isEmpty()) return aE;
  t._readOnly || le(192);
  let e = Jw.get(t);
  return e || (e = function(n) {
    const r = /* @__PURE__ */ new Map();
    for (const [i, o] of n._nodeMap) {
      const s = o.__type;
      let a = r.get(s);
      a || (a = /* @__PURE__ */ new Map(), r.set(s, a)), a.set(i, o);
    }
    return r;
  }(t), Jw.set(t, e)), e;
}
function Fp(t) {
  const e = t.constructor.clone(t);
  return e.afterCloneFrom(t), e;
}
function lE(t, e) {
  const n = parseInt(t.style.paddingInlineStart, 10) || 0, r = Math.round(n / 40);
  e.setIndent(r);
}
function cE(t) {
  t.__lexicalUnmanaged = !0;
}
function uE(t) {
  return t.__lexicalUnmanaged === !0;
}
function Ia(t, e) {
  return function(n, r) {
    return Object.prototype.hasOwnProperty.call(n, r);
  }(t, e) && t[e] !== da[e];
}
function Bp(t) {
  const e = lw in t.prototype ? t.prototype[lw]() : void 0, n = /* @__PURE__ */ function(s) {
    return s === eo || s === pn || s === da;
  }(t), r = !n && Ia(t, "getType") ? t.getType() : void 0;
  let i, o = r;
  if (e) if (r) i = e[r];
  else for (const [s, a] of Object.entries(e)) o = s, i = a;
  if (!n && o && (Ia(t, "getType") || (t.getType = () => o), Ia(t, "clone") || (t.clone = (s) => (Ap(s), new t())), Ia(t, "importJSON") || (t.importJSON = i && i.$importJSON || ((s) => new t().updateFromJSON(s))), !Ia(t, "importDOM") && i)) {
    const { importDOM: s } = i;
    s && (t.importDOM = () => s);
  }
  return { ownNodeConfig: i, ownNodeType: o };
}
const dE = { next: "previous", previous: "next" };
let qp = class {
  constructor(e) {
    this.origin = e;
  }
  [Symbol.iterator]() {
    return ed({ hasNext: qo, initial: this.getAdjacentCaret(), map: (e) => e, step: (e) => e.getAdjacentCaret() });
  }
  getAdjacentCaret() {
    return $t(this.getNodeAtCaret(), this.direction);
  }
  getSiblingCaret() {
    return $t(this.origin, this.direction);
  }
  remove() {
    const e = this.getNodeAtCaret();
    return e && e.remove(), this;
  }
  replaceOrInsert(e, n) {
    const r = this.getNodeAtCaret();
    return e.is(this.origin) || e.is(r) || (r === null ? this.insert(e) : r.replace(e, n)), this;
  }
  splice(e, n, r = "next") {
    const i = r === this.direction ? n : Array.from(n).reverse();
    let o = this;
    const s = this.getParentAtCaret(), a = /* @__PURE__ */ new Map();
    for (let l = o.getAdjacentCaret(); l !== null && a.size < e; l = l.getAdjacentCaret()) {
      const c = l.origin.getWritable();
      a.set(c.getKey(), c);
    }
    for (const l of i) {
      if (a.size > 0) {
        const c = o.getNodeAtCaret();
        if (c) {
          if (a.delete(c.getKey()), a.delete(l.getKey()), !(c.is(l) || o.origin.is(l))) {
            const u = l.getParent();
            u && u.is(s) && l.remove(), c.replace(l);
          }
        } else c === null && le(263, Array.from(a).join(" "));
      } else o.insert(l);
      o = $t(l, this.direction);
    }
    for (const l of a.values()) l.remove();
    return this;
  }
}, oh = class nv extends qp {
  constructor() {
    super(...arguments);
    Zn(this, "type", "child");
  }
  getLatest() {
    const n = this.origin.getLatest();
    return n === this.origin ? this : _r(n, this.direction);
  }
  getParentCaret(n = "root") {
    return $t(jp(this.getParentAtCaret(), n), this.direction);
  }
  getFlipped() {
    const n = pa(this.direction);
    return $t(this.getNodeAtCaret(), n) || _r(this.origin, n);
  }
  getParentAtCaret() {
    return this.origin;
  }
  getChildCaret() {
    return this;
  }
  isSameNodeCaret(n) {
    return n instanceof nv && this.direction === n.direction && this.origin.is(n.origin);
  }
  isSamePointCaret(n) {
    return this.isSameNodeCaret(n);
  }
};
const fE = { root: tn, shadowRoot: Zr };
function pa(t) {
  return dE[t];
}
function jp(t, e = "root") {
  return fE[e](t) ? null : t;
}
let au = class sh extends qp {
  constructor() {
    super(...arguments);
    Zn(this, "type", "sibling");
  }
  getLatest() {
    const n = this.origin.getLatest();
    return n === this.origin ? this : $t(n, this.direction);
  }
  getSiblingCaret() {
    return this;
  }
  getParentAtCaret() {
    return this.origin.getParent();
  }
  getChildCaret() {
    return X(this.origin) ? _r(this.origin, this.direction) : null;
  }
  getParentCaret(n = "root") {
    return $t(jp(this.getParentAtCaret(), n), this.direction);
  }
  getFlipped() {
    const n = pa(this.direction);
    return $t(this.getNodeAtCaret(), n) || _r(this.origin.getParentOrThrow(), n);
  }
  isSamePointCaret(n) {
    return n instanceof sh && this.direction === n.direction && this.origin.is(n.origin);
  }
  isSameNodeCaret(n) {
    return (n instanceof sh || n instanceof lu) && this.direction === n.direction && this.origin.is(n.origin);
  }
}, lu = class ah extends qp {
  constructor(n, r) {
    super(n);
    Zn(this, "type", "text");
    this.offset = r;
  }
  getLatest() {
    const n = this.origin.getLatest();
    return n === this.origin ? this : jo(n, this.direction, this.offset);
  }
  getParentAtCaret() {
    return this.origin.getParent();
  }
  getChildCaret() {
    return null;
  }
  getParentCaret(n = "root") {
    return $t(jp(this.getParentAtCaret(), n), this.direction);
  }
  getFlipped() {
    return jo(this.origin, pa(this.direction), this.offset);
  }
  isSamePointCaret(n) {
    return n instanceof ah && this.direction === n.direction && this.origin.is(n.origin) && this.offset === n.offset;
  }
  isSameNodeCaret(n) {
    return (n instanceof au || n instanceof ah) && this.direction === n.direction && this.origin.is(n.origin);
  }
  getSiblingCaret() {
    return $t(this.origin, this.direction);
  }
};
function Bi(t) {
  return t instanceof lu;
}
function qo(t) {
  return t instanceof au;
}
function mr(t) {
  return t instanceof oh;
}
const hE = { next: class extends lu {
  constructor() {
    super(...arguments);
    Zn(this, "direction", "next");
  }
  getNodeAtCaret() {
    return this.origin.getNextSibling();
  }
  insert(e) {
    return this.origin.insertAfter(e), this;
  }
}, previous: class extends lu {
  constructor() {
    super(...arguments);
    Zn(this, "direction", "previous");
  }
  getNodeAtCaret() {
    return this.origin.getPreviousSibling();
  }
  insert(e) {
    return this.origin.insertBefore(e), this;
  }
} }, pE = { next: class extends au {
  constructor() {
    super(...arguments);
    Zn(this, "direction", "next");
  }
  getNodeAtCaret() {
    return this.origin.getNextSibling();
  }
  insert(e) {
    return this.origin.insertAfter(e), this;
  }
}, previous: class extends au {
  constructor() {
    super(...arguments);
    Zn(this, "direction", "previous");
  }
  getNodeAtCaret() {
    return this.origin.getPreviousSibling();
  }
  insert(e) {
    return this.origin.insertBefore(e), this;
  }
} }, gE = { next: class extends oh {
  constructor() {
    super(...arguments);
    Zn(this, "direction", "next");
  }
  getNodeAtCaret() {
    return this.origin.getFirstChild();
  }
  insert(e) {
    return this.origin.splice(0, 0, [e]), this;
  }
}, previous: class extends oh {
  constructor() {
    super(...arguments);
    Zn(this, "direction", "previous");
  }
  getNodeAtCaret() {
    return this.origin.getLastChild();
  }
  insert(e) {
    return this.origin.splice(this.origin.getChildrenSize(), 0, [e]), this;
  }
} };
function $t(t, e) {
  return t ? new pE[e](t) : null;
}
function jo(t, e, n) {
  return t ? new hE[e](t, qi(t, n)) : null;
}
function qi(t, e, n = "error") {
  const r = t.getTextContentSize();
  let i = e === "next" ? r : e === "previous" ? 0 : e;
  return (i < 0 || i > r) && (n !== "clamp" && function(o, ...s) {
    const a = new URL("https://lexical.dev/docs/error"), l = new URLSearchParams();
    l.append("code", o);
    for (const c of s) l.append("v", c);
    a.search = l.toString(), console.warn(`Minified Lexical warning #${o}; visit ${a.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }(284, String(e), String(r), t.getKey()), i = i < 0 ? 0 : r), i;
}
function Yw(t, e) {
  return new bE(t, e);
}
function _r(t, e) {
  return X(t) ? new gE[e](t) : null;
}
function wE(t) {
  return t && t.getChildCaret() || t;
}
function hl(t) {
  return t && wE(t.getAdjacentCaret());
}
let mE = class rv {
  constructor(e, n, r) {
    Zn(this, "type", "node-caret-range");
    this.anchor = e, this.focus = n, this.direction = r;
  }
  getLatest() {
    const e = this.anchor.getLatest(), n = this.focus.getLatest();
    return e === this.anchor && n === this.focus ? this : new rv(e, n, this.direction);
  }
  isCollapsed() {
    return this.anchor.isSamePointCaret(this.focus);
  }
  getTextSlices() {
    const e = (i) => {
      const o = this[i].getLatest();
      return Bi(o) ? function(s, a) {
        const { direction: l, origin: c } = s, u = qi(c, a === "focus" ? pa(l) : l);
        return Yw(s, u - s.offset);
      }(o, i) : null;
    }, n = e("anchor"), r = e("focus");
    if (n && r) {
      const { caret: i } = n, { caret: o } = r;
      if (i.isSameNodeCaret(o)) return [Yw(i, o.offset - i.offset), null];
    }
    return [n, r];
  }
  iterNodeCarets(e = "root") {
    const n = Bi(this.anchor) ? this.anchor.getSiblingCaret() : this.anchor.getLatest(), r = this.focus.getLatest(), i = Bi(r), o = (s) => s.isSameNodeCaret(r) ? null : hl(s) || s.getParentCaret(e);
    return ed({ hasNext: (s) => s !== null && !(i && r.isSameNodeCaret(s)), initial: n.isSameNodeCaret(r) ? null : o(n), map: (s) => s, step: o });
  }
  [Symbol.iterator]() {
    return this.iterNodeCarets("root");
  }
}, bE = class {
  constructor(e, n) {
    Zn(this, "type", "slice");
    this.caret = e, this.distance = n;
  }
  getSliceIndices() {
    const { distance: e, caret: { offset: n } } = this, r = n + e;
    return r < n ? [r, n] : [n, r];
  }
  getTextContent() {
    const [e, n] = this.getSliceIndices();
    return this.caret.origin.getTextContent().slice(e, n);
  }
  getTextContentSize() {
    return Math.abs(this.distance);
  }
  removeTextSlice() {
    const { caret: { origin: e, direction: n } } = this, [r, i] = this.getSliceIndices(), o = e.getTextContent();
    return jo(e.setTextContent(o.slice(0, r) + o.slice(i)), n, r);
  }
};
function Up(t) {
  return Hi(t, $t(Ve(), t.direction));
}
function yE(t) {
  return Hi(t, t);
}
function Hi(t, e) {
  return t.direction !== e.direction && le(265), new mE(t, e, t.direction);
}
function ed(t) {
  const { initial: e, hasNext: n, step: r, map: i } = t;
  let o = e;
  return { [Symbol.iterator]() {
    return this;
  }, next() {
    if (!n(o)) return { done: !0, value: void 0 };
    const s = { done: !1, value: i(o) };
    return o = r(o), s;
  } };
}
function iv(t, e) {
  const n = Qa(t.origin, e.origin);
  switch (n === null && le(275, t.origin.getKey(), e.origin.getKey()), n.type) {
    case "same": {
      const r = t.type === "text", i = e.type === "text";
      return r && i ? function(o, s) {
        return Math.sign(o - s);
      }(t.offset, e.offset) : t.type === e.type ? 0 : r ? -1 : i ? 1 : t.type === "child" ? -1 : 1;
    }
    case "ancestor":
      return t.type === "child" ? -1 : 1;
    case "descendant":
      return e.type === "child" ? 1 : -1;
    case "branch":
      return ov(n);
  }
}
function ov(t) {
  const { a: e, b: n } = t, r = e.__key, i = n.__key;
  let o = e, s = n;
  for (; o && s; o = o.getNextSibling(), s = s.getNextSibling()) {
    if (o.__key === i) return -1;
    if (s.__key === r) return 1;
  }
  return o === null ? 1 : -1;
}
function hc(t, e) {
  return e.is(t);
}
function Qw(t) {
  return X(t) ? [t.getLatest(), null] : [t.getParent(), t.getLatest()];
}
function Qa(t, e) {
  if (t.is(e)) return { commonAncestor: t, type: "same" };
  const n = /* @__PURE__ */ new Map();
  for (let [r, i] = Qw(t); r; i = r, r = r.getParent()) n.set(r, i);
  for (let [r, i] = Qw(e); r; i = r, r = r.getParent()) {
    const o = n.get(r);
    if (o !== void 0) return o === null ? (hc(t, r) || le(276), { commonAncestor: r, type: "ancestor" }) : i === null ? (hc(e, r) || le(277), { commonAncestor: r, type: "descendant" }) : ((X(o) || hc(t, o)) && (X(i) || hc(e, i)) && r.is(o.getParent()) && r.is(i.getParent()) || le(278), { a: o, b: i, commonAncestor: r, type: "branch" });
  }
  return null;
}
function bi(t, e) {
  const { type: n, key: r, offset: i } = t, o = oE(t.key);
  return n === "text" ? (ie(o) || le(266, o.getType(), r), jo(o, e, i)) : (X(o) || le(267, o.getType(), r), xE(o, t.offset, e));
}
function pl(t, e) {
  const { origin: n, direction: r } = e, i = r === "next";
  Bi(e) ? t.set(n.getKey(), e.offset, "text") : qo(e) ? ie(n) ? t.set(n.getKey(), qi(n, r), "text") : t.set(n.getParentOrThrow().getKey(), n.getIndexWithinParent() + (i ? 1 : 0), "element") : (mr(e) && X(n) || le(268), t.set(n.getKey(), i ? 0 : n.getChildrenSize(), "element"));
}
function vE(t) {
  const e = oe(), n = Z(e) ? e : $l();
  return Rc(n, t), sn(n), n;
}
function Rc(t, e) {
  pl(t.anchor, e.anchor), pl(t.focus, e.focus);
}
function Zw(t) {
  const { anchor: e, focus: n } = t, r = bi(e, "next"), i = bi(n, "next"), o = iv(r, i) <= 0 ? "next" : "previous";
  return Hi(zs(r, o), zs(i, o));
}
function td(t) {
  const { direction: e, origin: n } = t, r = $t(n, pa(e)).getNodeAtCaret();
  return r ? $t(r, e) : _r(n.getParentOrThrow(), e);
}
function em(t, e = "root") {
  const n = [t];
  for (let r = mr(t) ? t.getParentCaret(e) : t.getSiblingCaret(); r !== null; r = r.getParentCaret(e)) n.push(td(r));
  return n;
}
function ef(t) {
  return !!t && t.origin.isAttached();
}
function _E(t, e = "removeEmptySlices") {
  if (t.isCollapsed()) return t;
  const n = "root", r = "next";
  let i = e;
  const o = av(t, r), s = em(o.anchor, n), a = em(o.focus.getFlipped(), n), l = /* @__PURE__ */ new Set(), c = [];
  for (const g of o.iterNodeCarets(n)) if (mr(g)) l.add(g.origin.getKey());
  else if (qo(g)) {
    const { origin: w } = g;
    X(w) && !l.has(w.getKey()) || c.push(w);
  }
  for (const g of c) g.remove();
  for (const g of o.getTextSlices()) {
    if (!g) continue;
    const { origin: w } = g.caret, b = w.getTextContentSize(), _ = td($t(w, r)), y = w.getMode();
    if (Math.abs(g.distance) === b && i === "removeEmptySlices" || y === "token" && g.distance !== 0) _.remove();
    else if (g.distance !== 0) {
      i = "removeEmptySlices";
      let C = g.removeTextSlice();
      const D = g.caret.origin;
      if (y === "segmented") {
        const P = C.origin, S = Re(P.getTextContent()).setStyle(P.getStyle()).setFormat(P.getFormat());
        _.replaceOrInsert(S), C = jo(S, r, C.offset);
      }
      D.is(s[0].origin) && (s[0] = C), D.is(a[0].origin) && (a[0] = C.getFlipped());
    }
  }
  let u, f;
  for (const g of s) if (ef(g)) {
    u = Vr(g);
    break;
  }
  for (const g of a) if (ef(g)) {
    f = Vr(g);
    break;
  }
  const d = function(g, w, b) {
    if (!g || !w) return null;
    const _ = g.getParentAtCaret(), y = w.getParentAtCaret();
    if (!_ || !y) return null;
    const C = _.getParents().reverse();
    C.push(_);
    const D = y.getParents().reverse();
    D.push(y);
    const P = Math.min(C.length, D.length);
    let S;
    for (S = 0; S < P && C[S] === D[S]; S++) ;
    const L = (F, k) => {
      let I;
      for (let N = S; N < F.length; N++) {
        const R = F[N];
        if (Zr(R)) return;
        !I && k(R) && (I = R);
      }
      return I;
    }, O = L(C, nr), M = O && L(D, (F) => b.has(F.getKey()) && nr(F));
    return O && M ? [O, M] : null;
  }(u, f, l);
  if (d) {
    const [g, w] = d;
    _r(g, "previous").splice(0, w.getChildren()), w.remove();
  }
  const h = [u, f, ...s, ...a].find(ef);
  if (h)
    return yE(zs(Vr(h), t.direction));
  le(269, JSON.stringify(s.map((g) => g.origin.__key)));
}
function Vr(t) {
  const e = function(i) {
    let o = i;
    for (; mr(o); ) {
      const s = hl(o);
      if (!mr(s)) break;
      o = s;
    }
    return o;
  }(t.getLatest()), { direction: n } = e;
  if (ie(e.origin)) return Bi(e) ? e : jo(e.origin, n, n);
  const r = e.getAdjacentCaret();
  return qo(r) && ie(r.origin) ? jo(r.origin, n, pa(n)) : e;
}
function sv(t) {
  return Bi(t) && t.offset !== qi(t.origin, t.direction);
}
function zs(t, e) {
  return t.direction === e ? t : t.getFlipped();
}
function av(t, e) {
  return t.direction === e ? t : Hi(zs(t.focus, e), zs(t.anchor, e));
}
function xE(t, e, n) {
  let r = _r(t, "next");
  for (let i = 0; i < e; i++) {
    const o = r.getAdjacentCaret();
    if (o === null) break;
    r = o;
  }
  return zs(r, n);
}
const CE = /* @__PURE__ */ new Map();
function tm(t) {
  let e = t;
  for (; e != null; ) {
    if (e.nodeType === Node.TEXT_NODE) return e;
    e = e.firstChild;
  }
  return null;
}
function nm(t) {
  const e = t.parentNode;
  if (e == null) throw new Error("Should never happen");
  return [e, Array.from(e.childNodes).indexOf(t)];
}
function kE(t, e, n, r, i) {
  const o = e.getKey(), s = r.getKey(), a = document.createRange();
  let l = t.getElementByKey(o), c = t.getElementByKey(s), u = n, f = i;
  if (ie(e) && (l = tm(l)), ie(r) && (c = tm(c)), e === void 0 || r === void 0 || l === null || c === null) return null;
  l.nodeName === "BR" && ([l, u] = nm(l)), c.nodeName === "BR" && ([c, f] = nm(c));
  const d = l.firstChild;
  l === c && d != null && d.nodeName === "BR" && u === 0 && f === 0 && (f = 1);
  try {
    a.setStart(l, u), a.setEnd(c, f);
  } catch {
    return null;
  }
  return !a.collapsed || u === f && o === s || (a.setStart(c, f), a.setEnd(l, u)), a;
}
function EE(t, e) {
  const n = t.getRootElement();
  if (n === null) return [];
  const r = n.getBoundingClientRect(), i = getComputedStyle(n), o = parseFloat(i.paddingLeft) + parseFloat(i.paddingRight), s = Array.from(e.getClientRects());
  let a, l = s.length;
  s.sort((c, u) => {
    const f = c.top - u.top;
    return Math.abs(f) <= 3 ? c.left - u.left : f;
  });
  for (let c = 0; c < l; c++) {
    const u = s[c], f = a && a.top <= u.top && a.top + a.height > u.top && a.left + a.width > u.left, d = u.width + o === r.width;
    f || d ? (s.splice(c--, 1), l--) : a = u;
  }
  return s;
}
function NE(t) {
  const e = {};
  if (!t) return e;
  const n = t.split(";");
  for (const r of n) if (r !== "") {
    const [i, o] = r.split(/:([^]+)/);
    i && o && (e[i.trim()] = o.trim());
  }
  return e;
}
function lv(t, e) {
  const n = t.getStartEndPoints();
  if (e.isSelected(t) && !li(e) && n !== null) {
    const [r, i] = n, o = t.isBackward(), s = r.getNode(), a = i.getNode(), l = e.is(s), c = e.is(a);
    if (l || c) {
      const [u, f] = Xf(t), d = s.is(a), h = e.is(o ? a : s), g = e.is(o ? s : a);
      let w, b = 0;
      d ? (b = u > f ? f : u, w = u > f ? u : f) : h ? (b = o ? f : u, w = void 0) : g && (b = 0, w = o ? u : f), e.__text = e.__text.slice(b, w);
    }
  }
  return e;
}
function SE(t) {
  const e = t.getStyle(), n = NE(e);
  CE.set(e, n);
}
function TE(t, e) {
  const n = t.getFormatType(), r = t.getIndent();
  n !== e.getFormatType() && e.setFormat(n), r !== e.getIndent() && e.setIndent(r);
}
function AE(t, e, n = TE) {
  if (t === null) return;
  const r = t.getStartEndPoints(), i = /* @__PURE__ */ new Map();
  let o = null;
  if (r) {
    const [s, a] = r;
    o = $l(), o.anchor.set(s.key, s.offset, s.type), o.focus.set(a.key, a.offset, a.type);
    const l = tf(s.getNode(), nr), c = tf(a.getNode(), nr);
    X(l) && i.set(l.getKey(), l), X(c) && i.set(c.getKey(), c);
  }
  for (const s of t.getNodes()) if (X(s) && nr(s)) i.set(s.getKey(), s);
  else if (r === null) {
    const a = tf(s, nr);
    X(a) && i.set(a.getKey(), a);
  }
  for (const [s, a] of i) {
    const l = e();
    n(a, l), a.replace(l, !0), o && (s === o.anchor.key && o.anchor.set(l.getKey(), o.anchor.offset, o.anchor.type), s === o.focus.key && o.focus.set(l.getKey(), o.focus.offset, o.focus.type));
  }
  o && t.is(oe()) && sn(o);
}
function cv(t) {
  const e = t.anchor.getNode(), n = tn(e) ? e : e.getParentOrThrow(), r = Zu().getElementByKey(n.getKey());
  if (r === null) return !1;
  const i = r.ownerDocument.defaultView;
  return i === null ? !1 : i.getComputedStyle(r).writingMode === "vertical-rl";
}
function cu(t, e) {
  let n = cv(t) ? !e : e;
  uv(t) && (n = !n);
  const r = bi(t.focus, n ? "previous" : "next");
  if (sv(r)) return !1;
  for (const i of Up(r)) {
    if (mr(i)) return !i.origin.isInline();
    if (!X(i.origin)) {
      if (Xe(i.origin)) return !0;
      break;
    }
  }
  return !1;
}
function DE(t, e, n, r) {
  t.modify(e ? "extend" : "move", n, r);
}
function uv(t) {
  const e = t.anchor.getNode();
  return (tn(e) ? e : e.getParentOrThrow()).getDirection() === "rtl";
}
function uu(t, e, n) {
  const r = uv(t);
  let i;
  i = cv(t) || r ? !n : n, DE(t, e, i, "character");
}
function tf(t, e) {
  let n = t;
  for (; n !== null && n.getParent() !== null && !e(n); ) n = n.getParentOrThrow();
  return e(n) ? n : null;
}
function ME(t, ...e) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", t);
  for (const i of e) r.append("v", i);
  throw n.search = r.toString(), Error(`Minified Lexical error #${t}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
const ql = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, OE = ql && "documentMode" in document ? document.documentMode : null, IE = ql && /Mac|iPod|iPhone|iPad/.test(navigator.platform), RE = ql && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
!(!ql || !("InputEvent" in window) || OE) && "getTargetRanges" in new window.InputEvent("input");
function dv(...t) {
  const e = [];
  for (const n of t) if (n && typeof n == "string") for (const [r] of n.matchAll(/\S+/g)) e.push(r);
  return e;
}
function Ht(...t) {
  return () => {
    for (let e = t.length - 1; e >= 0; e--) t[e]();
    t.length = 0;
  };
}
const PE = ql, lh = IE, LE = RE;
function un(t, ...e) {
  const n = dv(...e);
  n.length > 0 && t.classList.add(...n);
}
function To(t, ...e) {
  const n = dv(...e);
  n.length > 0 && t.classList.remove(...n);
}
function jl(t, e) {
  return Array.from($E(t));
}
function $E(t, e) {
  return FE("next", t);
}
function FE(t, e, n) {
  const r = Ve(), i = e || r, o = X(i) ? _r(i, t) : $t(i, t), s = BE(i), a = function(c, u) {
    const f = im($t(c, u));
    return f && f[0];
  }(i, t);
  let l = s;
  return ed({ hasNext: (c) => c !== null, initial: o, map: (c) => ({ depth: l, node: c.origin }), step: (c) => {
    if (c.isSameNodeCaret(a)) return null;
    mr(c) && l++;
    const u = im(c);
    return !u || u[0].isSameNodeCaret(a) ? null : (l += u[1], u[0]);
  } });
}
function BE(t) {
  let e = -1;
  for (let n = t; n !== null; n = n.getParent()) e++;
  return e;
}
function qE(t) {
  const e = xr(t, (n) => X(n) && !n.isInline());
  return X(e) || ME(4, t.__key), e;
}
const xr = (t, e) => {
  let n = t;
  for (; n !== Ve() && n != null; ) {
    if (e(n)) return n;
    n = n.getParent();
  }
  return null;
};
function fv(t, e, n, r) {
  const i = (o) => o instanceof e;
  return t.registerNodeTransform(e, (o) => {
    const s = ((a) => {
      const l = a.getChildren();
      for (let f = 0; f < l.length; f++) {
        const d = l[f];
        if (i(d)) return null;
      }
      let c = a, u = a;
      for (; c !== null; ) if (u = c, c = c.getParent(), i(c)) return { child: u, parent: c };
      return null;
    })(o);
    if (s !== null) {
      const { child: a, parent: l } = s;
      if (a.is(o)) {
        r(l, o);
        const c = a.getNextSiblings(), u = c.length;
        if (l.insertAfter(a), u !== 0) {
          const f = n(l);
          a.insertAfter(f);
          for (let d = 0; d < u; d++) f.append(c[d]);
        }
        l.canBeEmpty() || l.getChildrenSize() !== 0 || l.remove();
      }
    }
  });
}
function gi(t, e) {
  return t !== null && Object.getPrototypeOf(t).constructor.name === e.name;
}
let nf = !(LE || !PE) && void 0;
function jE(t) {
  let e = 1;
  if (function() {
    if (nf === void 0) {
      const n = document.createElement("div");
      n.style.cssText = "position: absolute; opacity: 0; width: 100px; left: -1000px;", document.body.appendChild(n);
      const r = n.getBoundingClientRect();
      n.style.setProperty("zoom", "2"), nf = n.getBoundingClientRect().width === r.width, document.body.removeChild(n);
    }
    return nf;
  }()) for (; t; ) e *= Number(window.getComputedStyle(t).getPropertyValue("zoom")), t = t.parentElement;
  return e;
}
function hv(t, e) {
  const n = [], r = Array.from(t).reverse();
  for (let i = r.pop(); i !== void 0; i = r.pop()) if (e(i)) n.push(i);
  else if (X(i)) for (const o of UE(i)) r.push(o);
  return n;
}
function UE(t) {
  return zE(_r(t, "previous"));
}
function zE(t) {
  return ed({ hasNext: qo, initial: t.getAdjacentCaret(), map: (e) => e.origin.getLatest(), step: (e) => e.getAdjacentCaret() });
}
function rm(t) {
  td($t(t, "next")).splice(1, t.getChildren());
}
function im(t, e = "root") {
  let n = 0, r = t, i = hl(r);
  for (; i === null; ) {
    if (n--, i = r.getParentCaret(e), !i) return null;
    r = i, i = hl(r);
  }
  return i && [i, n];
}
var pc = { exports: {} }, rf, om;
function VE() {
  if (om) return rf;
  om = 1;
  var t = -1, e = 1, n = 0;
  function r(k, I, N, R, T) {
    if (k === I)
      return k ? [[n, k]] : [];
    if (N != null) {
      var A = M(k, I, N);
      if (A)
        return A;
    }
    var q = a(k, I), V = k.substring(0, q);
    k = k.substring(q), I = I.substring(q), q = c(k, I);
    var J = k.substring(k.length - q);
    k = k.substring(0, k.length - q), I = I.substring(0, I.length - q);
    var H = i(k, I);
    return V && H.unshift([n, V]), J && H.push([n, J]), y(H, T), R && f(H), H;
  }
  function i(k, I) {
    var N;
    if (!k)
      return [[e, I]];
    if (!I)
      return [[t, k]];
    var R = k.length > I.length ? k : I, T = k.length > I.length ? I : k, A = R.indexOf(T);
    if (A !== -1)
      return N = [
        [e, R.substring(0, A)],
        [n, T],
        [e, R.substring(A + T.length)]
      ], k.length > I.length && (N[0][0] = N[2][0] = t), N;
    if (T.length === 1)
      return [
        [t, k],
        [e, I]
      ];
    var q = u(k, I);
    if (q) {
      var V = q[0], J = q[1], H = q[2], W = q[3], ne = q[4], re = r(V, H), te = r(J, W);
      return re.concat([[n, ne]], te);
    }
    return o(k, I);
  }
  function o(k, I) {
    for (var N = k.length, R = I.length, T = Math.ceil((N + R) / 2), A = T, q = 2 * T, V = new Array(q), J = new Array(q), H = 0; H < q; H++)
      V[H] = -1, J[H] = -1;
    V[A + 1] = 0, J[A + 1] = 0;
    for (var W = N - R, ne = W % 2 !== 0, re = 0, te = 0, Q = 0, ce = 0, pe = 0; pe < T; pe++) {
      for (var we = -pe + re; we <= pe - te; we += 2) {
        var ve = A + we, _e;
        we === -pe || we !== pe && V[ve - 1] < V[ve + 1] ? _e = V[ve + 1] : _e = V[ve - 1] + 1;
        for (var Ee = _e - we; _e < N && Ee < R && k.charAt(_e) === I.charAt(Ee); )
          _e++, Ee++;
        if (V[ve] = _e, _e > N)
          te += 2;
        else if (Ee > R)
          re += 2;
        else if (ne) {
          var fe = A + W - we;
          if (fe >= 0 && fe < q && J[fe] !== -1) {
            var Pe = N - J[fe];
            if (_e >= Pe)
              return s(k, I, _e, Ee);
          }
        }
      }
      for (var He = -pe + Q; He <= pe - ce; He += 2) {
        var fe = A + He, Pe;
        He === -pe || He !== pe && J[fe - 1] < J[fe + 1] ? Pe = J[fe + 1] : Pe = J[fe - 1] + 1;
        for (var ae = Pe - He; Pe < N && ae < R && k.charAt(N - Pe - 1) === I.charAt(R - ae - 1); )
          Pe++, ae++;
        if (J[fe] = Pe, Pe > N)
          ce += 2;
        else if (ae > R)
          Q += 2;
        else if (!ne) {
          var ve = A + W - He;
          if (ve >= 0 && ve < q && V[ve] !== -1) {
            var _e = V[ve], Ee = A + _e - ve;
            if (Pe = N - Pe, _e >= Pe)
              return s(k, I, _e, Ee);
          }
        }
      }
    }
    return [
      [t, k],
      [e, I]
    ];
  }
  function s(k, I, N, R) {
    var T = k.substring(0, N), A = I.substring(0, R), q = k.substring(N), V = I.substring(R), J = r(T, A), H = r(q, V);
    return J.concat(H);
  }
  function a(k, I) {
    if (!k || !I || k.charAt(0) !== I.charAt(0))
      return 0;
    for (var N = 0, R = Math.min(k.length, I.length), T = R, A = 0; N < T; )
      k.substring(A, T) == I.substring(A, T) ? (N = T, A = N) : R = T, T = Math.floor((R - N) / 2 + N);
    return C(k.charCodeAt(T - 1)) && T--, T;
  }
  function l(k, I) {
    var N = k.length, R = I.length;
    if (N == 0 || R == 0)
      return 0;
    N > R ? k = k.substring(N - R) : N < R && (I = I.substring(0, N));
    var T = Math.min(N, R);
    if (k == I)
      return T;
    for (var A = 0, q = 1; ; ) {
      var V = k.substring(T - q), J = I.indexOf(V);
      if (J == -1)
        return A;
      q += J, (J == 0 || k.substring(T - q) == I.substring(0, q)) && (A = q, q++);
    }
  }
  function c(k, I) {
    if (!k || !I || k.slice(-1) !== I.slice(-1))
      return 0;
    for (var N = 0, R = Math.min(k.length, I.length), T = R, A = 0; N < T; )
      k.substring(k.length - T, k.length - A) == I.substring(I.length - T, I.length - A) ? (N = T, A = N) : R = T, T = Math.floor((R - N) / 2 + N);
    return D(k.charCodeAt(k.length - T)) && T--, T;
  }
  function u(k, I) {
    var N = k.length > I.length ? k : I, R = k.length > I.length ? I : k;
    if (N.length < 4 || R.length * 2 < N.length)
      return null;
    function T(te, Q, ce) {
      for (var pe = te.substring(ce, ce + Math.floor(te.length / 4)), we = -1, ve = "", _e, Ee, fe, Pe; (we = Q.indexOf(pe, we + 1)) !== -1; ) {
        var He = a(
          te.substring(ce),
          Q.substring(we)
        ), ae = c(
          te.substring(0, ce),
          Q.substring(0, we)
        );
        ve.length < ae + He && (ve = Q.substring(we - ae, we) + Q.substring(we, we + He), _e = te.substring(0, ce - ae), Ee = te.substring(ce + He), fe = Q.substring(0, we - ae), Pe = Q.substring(we + He));
      }
      return ve.length * 2 >= te.length ? [
        _e,
        Ee,
        fe,
        Pe,
        ve
      ] : null;
    }
    var A = T(
      N,
      R,
      Math.ceil(N.length / 4)
    ), q = T(
      N,
      R,
      Math.ceil(N.length / 2)
    ), V;
    if (!A && !q)
      return null;
    q ? A ? V = A[4].length > q[4].length ? A : q : V = q : V = A;
    var J, H, W, ne;
    k.length > I.length ? (J = V[0], H = V[1], W = V[2], ne = V[3]) : (W = V[0], ne = V[1], J = V[2], H = V[3]);
    var re = V[4];
    return [J, H, W, ne, re];
  }
  function f(k) {
    for (var I = !1, N = [], R = 0, T = null, A = 0, q = 0, V = 0, J = 0, H = 0; A < k.length; )
      k[A][0] == n ? (N[R++] = A, q = J, V = H, J = 0, H = 0, T = k[A][1]) : (k[A][0] == e ? J += k[A][1].length : H += k[A][1].length, T && T.length <= Math.max(q, V) && T.length <= Math.max(J, H) && (k.splice(N[R - 1], 0, [
        t,
        T
      ]), k[N[R - 1] + 1][0] = e, R--, R--, A = R > 0 ? N[R - 1] : -1, q = 0, V = 0, J = 0, H = 0, T = null, I = !0)), A++;
    for (I && y(k), _(k), A = 1; A < k.length; ) {
      if (k[A - 1][0] == t && k[A][0] == e) {
        var W = k[A - 1][1], ne = k[A][1], re = l(W, ne), te = l(ne, W);
        re >= te ? (re >= W.length / 2 || re >= ne.length / 2) && (k.splice(A, 0, [
          n,
          ne.substring(0, re)
        ]), k[A - 1][1] = W.substring(
          0,
          W.length - re
        ), k[A + 1][1] = ne.substring(re), A++) : (te >= W.length / 2 || te >= ne.length / 2) && (k.splice(A, 0, [
          n,
          W.substring(0, te)
        ]), k[A - 1][0] = e, k[A - 1][1] = ne.substring(
          0,
          ne.length - te
        ), k[A + 1][0] = t, k[A + 1][1] = W.substring(te), A++), A++;
      }
      A++;
    }
  }
  var d = /[^a-zA-Z0-9]/, h = /\s/, g = /[\r\n]/, w = /\n\r?\n$/, b = /^\r?\n\r?\n/;
  function _(k) {
    function I(te, Q) {
      if (!te || !Q)
        return 6;
      var ce = te.charAt(te.length - 1), pe = Q.charAt(0), we = ce.match(d), ve = pe.match(d), _e = we && ce.match(h), Ee = ve && pe.match(h), fe = _e && ce.match(g), Pe = Ee && pe.match(g), He = fe && te.match(w), ae = Pe && Q.match(b);
      return He || ae ? 5 : fe || Pe ? 4 : we && !_e && Ee ? 3 : _e || Ee ? 2 : we || ve ? 1 : 0;
    }
    for (var N = 1; N < k.length - 1; ) {
      if (k[N - 1][0] == n && k[N + 1][0] == n) {
        var R = k[N - 1][1], T = k[N][1], A = k[N + 1][1], q = c(R, T);
        if (q) {
          var V = T.substring(T.length - q);
          R = R.substring(0, R.length - q), T = V + T.substring(0, T.length - q), A = V + A;
        }
        for (var J = R, H = T, W = A, ne = I(R, T) + I(T, A); T.charAt(0) === A.charAt(0); ) {
          R += T.charAt(0), T = T.substring(1) + A.charAt(0), A = A.substring(1);
          var re = I(R, T) + I(T, A);
          re >= ne && (ne = re, J = R, H = T, W = A);
        }
        k[N - 1][1] != J && (J ? k[N - 1][1] = J : (k.splice(N - 1, 1), N--), k[N][1] = H, W ? k[N + 1][1] = W : (k.splice(N + 1, 1), N--));
      }
      N++;
    }
  }
  function y(k, I) {
    k.push([n, ""]);
    for (var N = 0, R = 0, T = 0, A = "", q = "", V; N < k.length; ) {
      if (N < k.length - 1 && !k[N][1]) {
        k.splice(N, 1);
        continue;
      }
      switch (k[N][0]) {
        case e:
          T++, q += k[N][1], N++;
          break;
        case t:
          R++, A += k[N][1], N++;
          break;
        case n:
          var J = N - T - R - 1;
          if (I) {
            if (J >= 0 && S(k[J][1])) {
              var H = k[J][1].slice(-1);
              if (k[J][1] = k[J][1].slice(
                0,
                -1
              ), A = H + A, q = H + q, !k[J][1]) {
                k.splice(J, 1), N--;
                var W = J - 1;
                k[W] && k[W][0] === e && (T++, q = k[W][1] + q, W--), k[W] && k[W][0] === t && (R++, A = k[W][1] + A, W--), J = W;
              }
            }
            if (P(k[N][1])) {
              var H = k[N][1].charAt(0);
              k[N][1] = k[N][1].slice(1), A += H, q += H;
            }
          }
          if (N < k.length - 1 && !k[N][1]) {
            k.splice(N, 1);
            break;
          }
          if (A.length > 0 || q.length > 0) {
            A.length > 0 && q.length > 0 && (V = a(q, A), V !== 0 && (J >= 0 ? k[J][1] += q.substring(
              0,
              V
            ) : (k.splice(0, 0, [
              n,
              q.substring(0, V)
            ]), N++), q = q.substring(V), A = A.substring(V)), V = c(q, A), V !== 0 && (k[N][1] = q.substring(q.length - V) + k[N][1], q = q.substring(
              0,
              q.length - V
            ), A = A.substring(
              0,
              A.length - V
            )));
            var ne = T + R;
            A.length === 0 && q.length === 0 ? (k.splice(N - ne, ne), N = N - ne) : A.length === 0 ? (k.splice(N - ne, ne, [e, q]), N = N - ne + 1) : q.length === 0 ? (k.splice(N - ne, ne, [t, A]), N = N - ne + 1) : (k.splice(
              N - ne,
              ne,
              [t, A],
              [e, q]
            ), N = N - ne + 2);
          }
          N !== 0 && k[N - 1][0] === n ? (k[N - 1][1] += k[N][1], k.splice(N, 1)) : N++, T = 0, R = 0, A = "", q = "";
          break;
      }
    }
    k[k.length - 1][1] === "" && k.pop();
    var re = !1;
    for (N = 1; N < k.length - 1; )
      k[N - 1][0] === n && k[N + 1][0] === n && (k[N][1].substring(
        k[N][1].length - k[N - 1][1].length
      ) === k[N - 1][1] ? (k[N][1] = k[N - 1][1] + k[N][1].substring(
        0,
        k[N][1].length - k[N - 1][1].length
      ), k[N + 1][1] = k[N - 1][1] + k[N + 1][1], k.splice(N - 1, 1), re = !0) : k[N][1].substring(0, k[N + 1][1].length) == k[N + 1][1] && (k[N - 1][1] += k[N + 1][1], k[N][1] = k[N][1].substring(k[N + 1][1].length) + k[N + 1][1], k.splice(N + 1, 1), re = !0)), N++;
    re && y(k, I);
  }
  function C(k) {
    return k >= 55296 && k <= 56319;
  }
  function D(k) {
    return k >= 56320 && k <= 57343;
  }
  function P(k) {
    return D(k.charCodeAt(0));
  }
  function S(k) {
    return C(k.charCodeAt(k.length - 1));
  }
  function L(k) {
    for (var I = [], N = 0; N < k.length; N++)
      k[N][1].length > 0 && I.push(k[N]);
    return I;
  }
  function O(k, I, N, R) {
    return S(k) || P(R) ? null : L([
      [n, k],
      [t, I],
      [e, N],
      [n, R]
    ]);
  }
  function M(k, I, N) {
    var R = typeof N == "number" ? { index: N, length: 0 } : N.oldRange, T = typeof N == "number" ? null : N.newRange, A = k.length, q = I.length;
    if (R.length === 0 && (T === null || T.length === 0)) {
      var V = R.index, J = k.slice(0, V), H = k.slice(V), W = T ? T.index : null;
      e: {
        var ne = V + q - A;
        if (W !== null && W !== ne || ne < 0 || ne > q)
          break e;
        var re = I.slice(0, ne), te = I.slice(ne);
        if (te !== H)
          break e;
        var Q = Math.min(V, ne), ce = J.slice(0, Q), pe = re.slice(0, Q);
        if (ce !== pe)
          break e;
        var we = J.slice(Q), ve = re.slice(Q);
        return O(ce, we, ve, H);
      }
      e: {
        if (W !== null && W !== V)
          break e;
        var _e = V, re = I.slice(0, _e), te = I.slice(_e);
        if (re !== J)
          break e;
        var Ee = Math.min(A - _e, q - _e), fe = H.slice(H.length - Ee), Pe = te.slice(te.length - Ee);
        if (fe !== Pe)
          break e;
        var we = H.slice(0, H.length - Ee), ve = te.slice(0, te.length - Ee);
        return O(J, we, ve, fe);
      }
    }
    if (R.length > 0 && T && T.length === 0)
      e: {
        var ce = k.slice(0, R.index), fe = k.slice(R.index + R.length), Q = ce.length, Ee = fe.length;
        if (q < Q + Ee)
          break e;
        var pe = I.slice(0, Q), Pe = I.slice(q - Ee);
        if (ce !== pe || fe !== Pe)
          break e;
        var we = k.slice(Q, A - Ee), ve = I.slice(Q, q - Ee);
        return O(ce, we, ve, fe);
      }
    return null;
  }
  function F(k, I, N, R) {
    return r(k, I, N, R, !0);
  }
  return F.INSERT = e, F.DELETE = t, F.EQUAL = n, rf = F, rf;
}
var za = { exports: {} };
za.exports;
var sm;
function pv() {
  return sm || (sm = 1, function(t, e) {
    var n = 200, r = "__lodash_hash_undefined__", i = 9007199254740991, o = "[object Arguments]", s = "[object Array]", a = "[object Boolean]", l = "[object Date]", c = "[object Error]", u = "[object Function]", f = "[object GeneratorFunction]", d = "[object Map]", h = "[object Number]", g = "[object Object]", w = "[object Promise]", b = "[object RegExp]", _ = "[object Set]", y = "[object String]", C = "[object Symbol]", D = "[object WeakMap]", P = "[object ArrayBuffer]", S = "[object DataView]", L = "[object Float32Array]", O = "[object Float64Array]", M = "[object Int8Array]", F = "[object Int16Array]", k = "[object Int32Array]", I = "[object Uint8Array]", N = "[object Uint8ClampedArray]", R = "[object Uint16Array]", T = "[object Uint32Array]", A = /[\\^$.*+?()[\]{}|]/g, q = /\w*$/, V = /^\[object .+?Constructor\]$/, J = /^(?:0|[1-9]\d*)$/, H = {};
    H[o] = H[s] = H[P] = H[S] = H[a] = H[l] = H[L] = H[O] = H[M] = H[F] = H[k] = H[d] = H[h] = H[g] = H[b] = H[_] = H[y] = H[C] = H[I] = H[N] = H[R] = H[T] = !0, H[c] = H[u] = H[D] = !1;
    var W = typeof Ii == "object" && Ii && Ii.Object === Object && Ii, ne = typeof self == "object" && self && self.Object === Object && self, re = W || ne || Function("return this")(), te = e && !e.nodeType && e, Q = te && !0 && t && !t.nodeType && t, ce = Q && Q.exports === te;
    function pe(m, E) {
      return m.set(E[0], E[1]), m;
    }
    function we(m, E) {
      return m.add(E), m;
    }
    function ve(m, E) {
      for (var j = -1, ee = m ? m.length : 0; ++j < ee && E(m[j], j, m) !== !1; )
        ;
      return m;
    }
    function _e(m, E) {
      for (var j = -1, ee = E.length, De = m.length; ++j < ee; )
        m[De + j] = E[j];
      return m;
    }
    function Ee(m, E, j, ee) {
      for (var De = -1, xe = m ? m.length : 0; ++De < xe; )
        j = E(j, m[De], De, m);
      return j;
    }
    function fe(m, E) {
      for (var j = -1, ee = Array(m); ++j < m; )
        ee[j] = E(j);
      return ee;
    }
    function Pe(m, E) {
      return m == null ? void 0 : m[E];
    }
    function He(m) {
      var E = !1;
      if (m != null && typeof m.toString != "function")
        try {
          E = !!(m + "");
        } catch {
        }
      return E;
    }
    function ae(m) {
      var E = -1, j = Array(m.size);
      return m.forEach(function(ee, De) {
        j[++E] = [De, ee];
      }), j;
    }
    function Te(m, E) {
      return function(j) {
        return m(E(j));
      };
    }
    function Be(m) {
      var E = -1, j = Array(m.size);
      return m.forEach(function(ee) {
        j[++E] = ee;
      }), j;
    }
    var Ge = Array.prototype, rt = Function.prototype, vt = Object.prototype, mt = re["__core-js_shared__"], Et = function() {
      var m = /[^.]+$/.exec(mt && mt.keys && mt.keys.IE_PROTO || "");
      return m ? "Symbol(src)_1." + m : "";
    }(), $e = rt.toString, Dt = vt.hasOwnProperty, ct = vt.toString, lr = RegExp(
      "^" + $e.call(Dt).replace(A, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), Ln = ce ? re.Buffer : void 0, En = re.Symbol, $n = re.Uint8Array, Ce = Te(Object.getPrototypeOf, Object), Qe = Object.create, Mt = vt.propertyIsEnumerable, Bt = Ge.splice, Fn = Object.getOwnPropertySymbols, Bn = Ln ? Ln.isBuffer : void 0, cr = Te(Object.keys, Object), qn = hr(re, "DataView"), jn = hr(re, "Map"), Xt = hr(re, "Promise"), Un = hr(re, "Set"), zn = hr(re, "WeakMap"), Nn = hr(Object, "create"), Dr = mn(qn), Ze = mn(jn), bt = mn(Xt), gn = mn(Un), wn = mn(zn), ur = En ? En.prototype : void 0, Ti = ur ? ur.valueOf : void 0;
    function Qn(m) {
      var E = -1, j = m ? m.length : 0;
      for (this.clear(); ++E < j; ) {
        var ee = m[E];
        this.set(ee[0], ee[1]);
      }
    }
    function v() {
      this.__data__ = Nn ? Nn(null) : {};
    }
    function x(m) {
      return this.has(m) && delete this.__data__[m];
    }
    function $(m) {
      var E = this.__data__;
      if (Nn) {
        var j = E[m];
        return j === r ? void 0 : j;
      }
      return Dt.call(E, m) ? E[m] : void 0;
    }
    function K(m) {
      var E = this.__data__;
      return Nn ? E[m] !== void 0 : Dt.call(E, m);
    }
    function se(m, E) {
      var j = this.__data__;
      return j[m] = Nn && E === void 0 ? r : E, this;
    }
    Qn.prototype.clear = v, Qn.prototype.delete = x, Qn.prototype.get = $, Qn.prototype.has = K, Qn.prototype.set = se;
    function he(m) {
      var E = -1, j = m ? m.length : 0;
      for (this.clear(); ++E < j; ) {
        var ee = m[E];
        this.set(ee[0], ee[1]);
      }
    }
    function Fe() {
      this.__data__ = [];
    }
    function _t(m) {
      var E = this.__data__, j = us(E, m);
      if (j < 0)
        return !1;
      var ee = E.length - 1;
      return j == ee ? E.pop() : Bt.call(E, j, 1), !0;
    }
    function Nt(m) {
      var E = this.__data__, j = us(E, m);
      return j < 0 ? void 0 : E[j][1];
    }
    function Yt(m) {
      return us(this.__data__, m) > -1;
    }
    function Ot(m, E) {
      var j = this.__data__, ee = us(j, m);
      return ee < 0 ? j.push([m, E]) : j[ee][1] = E, this;
    }
    he.prototype.clear = Fe, he.prototype.delete = _t, he.prototype.get = Nt, he.prototype.has = Yt, he.prototype.set = Ot;
    function gt(m) {
      var E = -1, j = m ? m.length : 0;
      for (this.clear(); ++E < j; ) {
        var ee = m[E];
        this.set(ee[0], ee[1]);
      }
    }
    function Vn() {
      this.__data__ = {
        hash: new Qn(),
        map: new (jn || he)(),
        string: new Qn()
      };
    }
    function an(m) {
      return co(this, m).delete(m);
    }
    function dr(m) {
      return co(this, m).get(m);
    }
    function Sn(m) {
      return co(this, m).has(m);
    }
    function fr(m, E) {
      return co(this, m).set(m, E), this;
    }
    gt.prototype.clear = Vn, gt.prototype.delete = an, gt.prototype.get = dr, gt.prototype.has = Sn, gt.prototype.set = fr;
    function St(m) {
      this.__data__ = new he(m);
    }
    function ao() {
      this.__data__ = new he();
    }
    function Tt(m) {
      return this.__data__.delete(m);
    }
    function ls(m) {
      return this.__data__.get(m);
    }
    function Mr(m) {
      return this.__data__.has(m);
    }
    function md(m, E) {
      var j = this.__data__;
      if (j instanceof he) {
        var ee = j.__data__;
        if (!jn || ee.length < n - 1)
          return ee.push([m, E]), this;
        j = this.__data__ = new gt(ee);
      }
      return j.set(m, E), this;
    }
    St.prototype.clear = ao, St.prototype.delete = Tt, St.prototype.get = ls, St.prototype.has = Mr, St.prototype.set = md;
    function cs(m, E) {
      var j = Sa(m) || fs(m) ? fe(m.length, String) : [], ee = j.length, De = !!ee;
      for (var xe in m)
        Dt.call(m, xe) && !(De && (xe == "length" || Md(xe, ee))) && j.push(xe);
      return j;
    }
    function Yl(m, E, j) {
      var ee = m[E];
      (!(Dt.call(m, E) && nc(ee, j)) || j === void 0 && !(E in m)) && (m[E] = j);
    }
    function us(m, E) {
      for (var j = m.length; j--; )
        if (nc(m[j][0], E))
          return j;
      return -1;
    }
    function Or(m, E) {
      return m && Na(E, Aa(E), m);
    }
    function ka(m, E, j, ee, De, xe, Je) {
      var Ke;
      if (ee && (Ke = xe ? ee(m, De, xe, Je) : ee(m)), Ke !== void 0)
        return Ke;
      if (!Rr(m))
        return m;
      var At = Sa(m);
      if (At) {
        if (Ke = Ad(m), !E)
          return Nd(m, Ke);
      } else {
        var Ye = ni(m), ln = Ye == u || Ye == f;
        if (rc(m))
          return ds(m, E);
        if (Ye == g || Ye == o || ln && !xe) {
          if (He(m))
            return xe ? m : {};
          if (Ke = Ir(ln ? {} : m), !E)
            return Sd(m, Or(Ke, m));
        } else {
          if (!H[Ye])
            return xe ? m : {};
          Ke = Dd(m, Ye, ka, E);
        }
      }
      Je || (Je = new St());
      var Tn = Je.get(m);
      if (Tn)
        return Tn;
      if (Je.set(m, Ke), !At)
        var It = j ? Td(m) : Aa(m);
      return ve(It || m, function(cn, Qt) {
        It && (Qt = cn, cn = m[Qt]), Yl(Ke, Qt, ka(cn, E, j, ee, Qt, m, Je));
      }), Ke;
    }
    function bd(m) {
      return Rr(m) ? Qe(m) : {};
    }
    function yd(m, E, j) {
      var ee = E(m);
      return Sa(m) ? ee : _e(ee, j(m));
    }
    function vd(m) {
      return ct.call(m);
    }
    function _d(m) {
      if (!Rr(m) || Id(m))
        return !1;
      var E = Ta(m) || He(m) ? lr : V;
      return E.test(mn(m));
    }
    function xd(m) {
      if (!ec(m))
        return cr(m);
      var E = [];
      for (var j in Object(m))
        Dt.call(m, j) && j != "constructor" && E.push(j);
      return E;
    }
    function ds(m, E) {
      if (E)
        return m.slice();
      var j = new m.constructor(m.length);
      return m.copy(j), j;
    }
    function Ea(m) {
      var E = new m.constructor(m.byteLength);
      return new $n(E).set(new $n(m)), E;
    }
    function lo(m, E) {
      var j = E ? Ea(m.buffer) : m.buffer;
      return new m.constructor(j, m.byteOffset, m.byteLength);
    }
    function Ql(m, E, j) {
      var ee = E ? j(ae(m), !0) : ae(m);
      return Ee(ee, pe, new m.constructor());
    }
    function Zl(m) {
      var E = new m.constructor(m.source, q.exec(m));
      return E.lastIndex = m.lastIndex, E;
    }
    function Cd(m, E, j) {
      var ee = E ? j(Be(m), !0) : Be(m);
      return Ee(ee, we, new m.constructor());
    }
    function kd(m) {
      return Ti ? Object(Ti.call(m)) : {};
    }
    function Ed(m, E) {
      var j = E ? Ea(m.buffer) : m.buffer;
      return new m.constructor(j, m.byteOffset, m.length);
    }
    function Nd(m, E) {
      var j = -1, ee = m.length;
      for (E || (E = Array(ee)); ++j < ee; )
        E[j] = m[j];
      return E;
    }
    function Na(m, E, j, ee) {
      j || (j = {});
      for (var De = -1, xe = E.length; ++De < xe; ) {
        var Je = E[De], Ke = void 0;
        Yl(j, Je, Ke === void 0 ? m[Je] : Ke);
      }
      return j;
    }
    function Sd(m, E) {
      return Na(m, ti(m), E);
    }
    function Td(m) {
      return yd(m, Aa, ti);
    }
    function co(m, E) {
      var j = m.__data__;
      return Od(E) ? j[typeof E == "string" ? "string" : "hash"] : j.map;
    }
    function hr(m, E) {
      var j = Pe(m, E);
      return _d(j) ? j : void 0;
    }
    var ti = Fn ? Te(Fn, Object) : Pd, ni = vd;
    (qn && ni(new qn(new ArrayBuffer(1))) != S || jn && ni(new jn()) != d || Xt && ni(Xt.resolve()) != w || Un && ni(new Un()) != _ || zn && ni(new zn()) != D) && (ni = function(m) {
      var E = ct.call(m), j = E == g ? m.constructor : void 0, ee = j ? mn(j) : void 0;
      if (ee)
        switch (ee) {
          case Dr:
            return S;
          case Ze:
            return d;
          case bt:
            return w;
          case gn:
            return _;
          case wn:
            return D;
        }
      return E;
    });
    function Ad(m) {
      var E = m.length, j = m.constructor(E);
      return E && typeof m[0] == "string" && Dt.call(m, "index") && (j.index = m.index, j.input = m.input), j;
    }
    function Ir(m) {
      return typeof m.constructor == "function" && !ec(m) ? bd(Ce(m)) : {};
    }
    function Dd(m, E, j, ee) {
      var De = m.constructor;
      switch (E) {
        case P:
          return Ea(m);
        case a:
        case l:
          return new De(+m);
        case S:
          return lo(m, ee);
        case L:
        case O:
        case M:
        case F:
        case k:
        case I:
        case N:
        case R:
        case T:
          return Ed(m, ee);
        case d:
          return Ql(m, ee, j);
        case h:
        case y:
          return new De(m);
        case b:
          return Zl(m);
        case _:
          return Cd(m, ee, j);
        case C:
          return kd(m);
      }
    }
    function Md(m, E) {
      return E = E ?? i, !!E && (typeof m == "number" || J.test(m)) && m > -1 && m % 1 == 0 && m < E;
    }
    function Od(m) {
      var E = typeof m;
      return E == "string" || E == "number" || E == "symbol" || E == "boolean" ? m !== "__proto__" : m === null;
    }
    function Id(m) {
      return !!Et && Et in m;
    }
    function ec(m) {
      var E = m && m.constructor, j = typeof E == "function" && E.prototype || vt;
      return m === j;
    }
    function mn(m) {
      if (m != null) {
        try {
          return $e.call(m);
        } catch {
        }
        try {
          return m + "";
        } catch {
        }
      }
      return "";
    }
    function tc(m) {
      return ka(m, !0, !0);
    }
    function nc(m, E) {
      return m === E || m !== m && E !== E;
    }
    function fs(m) {
      return Rd(m) && Dt.call(m, "callee") && (!Mt.call(m, "callee") || ct.call(m) == o);
    }
    var Sa = Array.isArray;
    function hs(m) {
      return m != null && ic(m.length) && !Ta(m);
    }
    function Rd(m) {
      return oc(m) && hs(m);
    }
    var rc = Bn || Ld;
    function Ta(m) {
      var E = Rr(m) ? ct.call(m) : "";
      return E == u || E == f;
    }
    function ic(m) {
      return typeof m == "number" && m > -1 && m % 1 == 0 && m <= i;
    }
    function Rr(m) {
      var E = typeof m;
      return !!m && (E == "object" || E == "function");
    }
    function oc(m) {
      return !!m && typeof m == "object";
    }
    function Aa(m) {
      return hs(m) ? cs(m) : xd(m);
    }
    function Pd() {
      return [];
    }
    function Ld() {
      return !1;
    }
    t.exports = tc;
  }(za, za.exports)), za.exports;
}
var Va = { exports: {} };
Va.exports;
var am;
function gv() {
  return am || (am = 1, function(t, e) {
    var n = 200, r = "__lodash_hash_undefined__", i = 1, o = 2, s = 9007199254740991, a = "[object Arguments]", l = "[object Array]", c = "[object AsyncFunction]", u = "[object Boolean]", f = "[object Date]", d = "[object Error]", h = "[object Function]", g = "[object GeneratorFunction]", w = "[object Map]", b = "[object Number]", _ = "[object Null]", y = "[object Object]", C = "[object Promise]", D = "[object Proxy]", P = "[object RegExp]", S = "[object Set]", L = "[object String]", O = "[object Symbol]", M = "[object Undefined]", F = "[object WeakMap]", k = "[object ArrayBuffer]", I = "[object DataView]", N = "[object Float32Array]", R = "[object Float64Array]", T = "[object Int8Array]", A = "[object Int16Array]", q = "[object Int32Array]", V = "[object Uint8Array]", J = "[object Uint8ClampedArray]", H = "[object Uint16Array]", W = "[object Uint32Array]", ne = /[\\^$.*+?()[\]{}|]/g, re = /^\[object .+?Constructor\]$/, te = /^(?:0|[1-9]\d*)$/, Q = {};
    Q[N] = Q[R] = Q[T] = Q[A] = Q[q] = Q[V] = Q[J] = Q[H] = Q[W] = !0, Q[a] = Q[l] = Q[k] = Q[u] = Q[I] = Q[f] = Q[d] = Q[h] = Q[w] = Q[b] = Q[y] = Q[P] = Q[S] = Q[L] = Q[F] = !1;
    var ce = typeof Ii == "object" && Ii && Ii.Object === Object && Ii, pe = typeof self == "object" && self && self.Object === Object && self, we = ce || pe || Function("return this")(), ve = e && !e.nodeType && e, _e = ve && !0 && t && !t.nodeType && t, Ee = _e && _e.exports === ve, fe = Ee && ce.process, Pe = function() {
      try {
        return fe && fe.binding && fe.binding("util");
      } catch {
      }
    }(), He = Pe && Pe.isTypedArray;
    function ae(m, E) {
      for (var j = -1, ee = m == null ? 0 : m.length, De = 0, xe = []; ++j < ee; ) {
        var Je = m[j];
        E(Je, j, m) && (xe[De++] = Je);
      }
      return xe;
    }
    function Te(m, E) {
      for (var j = -1, ee = E.length, De = m.length; ++j < ee; )
        m[De + j] = E[j];
      return m;
    }
    function Be(m, E) {
      for (var j = -1, ee = m == null ? 0 : m.length; ++j < ee; )
        if (E(m[j], j, m))
          return !0;
      return !1;
    }
    function Ge(m, E) {
      for (var j = -1, ee = Array(m); ++j < m; )
        ee[j] = E(j);
      return ee;
    }
    function rt(m) {
      return function(E) {
        return m(E);
      };
    }
    function vt(m, E) {
      return m.has(E);
    }
    function mt(m, E) {
      return m == null ? void 0 : m[E];
    }
    function Et(m) {
      var E = -1, j = Array(m.size);
      return m.forEach(function(ee, De) {
        j[++E] = [De, ee];
      }), j;
    }
    function $e(m, E) {
      return function(j) {
        return m(E(j));
      };
    }
    function Dt(m) {
      var E = -1, j = Array(m.size);
      return m.forEach(function(ee) {
        j[++E] = ee;
      }), j;
    }
    var ct = Array.prototype, lr = Function.prototype, Ln = Object.prototype, En = we["__core-js_shared__"], $n = lr.toString, Ce = Ln.hasOwnProperty, Qe = function() {
      var m = /[^.]+$/.exec(En && En.keys && En.keys.IE_PROTO || "");
      return m ? "Symbol(src)_1." + m : "";
    }(), Mt = Ln.toString, Bt = RegExp(
      "^" + $n.call(Ce).replace(ne, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), Fn = Ee ? we.Buffer : void 0, Bn = we.Symbol, cr = we.Uint8Array, qn = Ln.propertyIsEnumerable, jn = ct.splice, Xt = Bn ? Bn.toStringTag : void 0, Un = Object.getOwnPropertySymbols, zn = Fn ? Fn.isBuffer : void 0, Nn = $e(Object.keys, Object), Dr = ti(we, "DataView"), Ze = ti(we, "Map"), bt = ti(we, "Promise"), gn = ti(we, "Set"), wn = ti(we, "WeakMap"), ur = ti(Object, "create"), Ti = mn(Dr), Qn = mn(Ze), v = mn(bt), x = mn(gn), $ = mn(wn), K = Bn ? Bn.prototype : void 0, se = K ? K.valueOf : void 0;
    function he(m) {
      var E = -1, j = m == null ? 0 : m.length;
      for (this.clear(); ++E < j; ) {
        var ee = m[E];
        this.set(ee[0], ee[1]);
      }
    }
    function Fe() {
      this.__data__ = ur ? ur(null) : {}, this.size = 0;
    }
    function _t(m) {
      var E = this.has(m) && delete this.__data__[m];
      return this.size -= E ? 1 : 0, E;
    }
    function Nt(m) {
      var E = this.__data__;
      if (ur) {
        var j = E[m];
        return j === r ? void 0 : j;
      }
      return Ce.call(E, m) ? E[m] : void 0;
    }
    function Yt(m) {
      var E = this.__data__;
      return ur ? E[m] !== void 0 : Ce.call(E, m);
    }
    function Ot(m, E) {
      var j = this.__data__;
      return this.size += this.has(m) ? 0 : 1, j[m] = ur && E === void 0 ? r : E, this;
    }
    he.prototype.clear = Fe, he.prototype.delete = _t, he.prototype.get = Nt, he.prototype.has = Yt, he.prototype.set = Ot;
    function gt(m) {
      var E = -1, j = m == null ? 0 : m.length;
      for (this.clear(); ++E < j; ) {
        var ee = m[E];
        this.set(ee[0], ee[1]);
      }
    }
    function Vn() {
      this.__data__ = [], this.size = 0;
    }
    function an(m) {
      var E = this.__data__, j = ds(E, m);
      if (j < 0)
        return !1;
      var ee = E.length - 1;
      return j == ee ? E.pop() : jn.call(E, j, 1), --this.size, !0;
    }
    function dr(m) {
      var E = this.__data__, j = ds(E, m);
      return j < 0 ? void 0 : E[j][1];
    }
    function Sn(m) {
      return ds(this.__data__, m) > -1;
    }
    function fr(m, E) {
      var j = this.__data__, ee = ds(j, m);
      return ee < 0 ? (++this.size, j.push([m, E])) : j[ee][1] = E, this;
    }
    gt.prototype.clear = Vn, gt.prototype.delete = an, gt.prototype.get = dr, gt.prototype.has = Sn, gt.prototype.set = fr;
    function St(m) {
      var E = -1, j = m == null ? 0 : m.length;
      for (this.clear(); ++E < j; ) {
        var ee = m[E];
        this.set(ee[0], ee[1]);
      }
    }
    function ao() {
      this.size = 0, this.__data__ = {
        hash: new he(),
        map: new (Ze || gt)(),
        string: new he()
      };
    }
    function Tt(m) {
      var E = hr(this, m).delete(m);
      return this.size -= E ? 1 : 0, E;
    }
    function ls(m) {
      return hr(this, m).get(m);
    }
    function Mr(m) {
      return hr(this, m).has(m);
    }
    function md(m, E) {
      var j = hr(this, m), ee = j.size;
      return j.set(m, E), this.size += j.size == ee ? 0 : 1, this;
    }
    St.prototype.clear = ao, St.prototype.delete = Tt, St.prototype.get = ls, St.prototype.has = Mr, St.prototype.set = md;
    function cs(m) {
      var E = -1, j = m == null ? 0 : m.length;
      for (this.__data__ = new St(); ++E < j; )
        this.add(m[E]);
    }
    function Yl(m) {
      return this.__data__.set(m, r), this;
    }
    function us(m) {
      return this.__data__.has(m);
    }
    cs.prototype.add = cs.prototype.push = Yl, cs.prototype.has = us;
    function Or(m) {
      var E = this.__data__ = new gt(m);
      this.size = E.size;
    }
    function ka() {
      this.__data__ = new gt(), this.size = 0;
    }
    function bd(m) {
      var E = this.__data__, j = E.delete(m);
      return this.size = E.size, j;
    }
    function yd(m) {
      return this.__data__.get(m);
    }
    function vd(m) {
      return this.__data__.has(m);
    }
    function _d(m, E) {
      var j = this.__data__;
      if (j instanceof gt) {
        var ee = j.__data__;
        if (!Ze || ee.length < n - 1)
          return ee.push([m, E]), this.size = ++j.size, this;
        j = this.__data__ = new St(ee);
      }
      return j.set(m, E), this.size = j.size, this;
    }
    Or.prototype.clear = ka, Or.prototype.delete = bd, Or.prototype.get = yd, Or.prototype.has = vd, Or.prototype.set = _d;
    function xd(m, E) {
      var j = fs(m), ee = !j && nc(m), De = !j && !ee && hs(m), xe = !j && !ee && !De && oc(m), Je = j || ee || De || xe, Ke = Je ? Ge(m.length, String) : [], At = Ke.length;
      for (var Ye in m)
        Ce.call(m, Ye) && !(Je && // Safari 9 has enumerable `arguments.length` in strict mode.
        (Ye == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        De && (Ye == "offset" || Ye == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        xe && (Ye == "buffer" || Ye == "byteLength" || Ye == "byteOffset") || // Skip index properties.
        Dd(Ye, At))) && Ke.push(Ye);
      return Ke;
    }
    function ds(m, E) {
      for (var j = m.length; j--; )
        if (tc(m[j][0], E))
          return j;
      return -1;
    }
    function Ea(m, E, j) {
      var ee = E(m);
      return fs(m) ? ee : Te(ee, j(m));
    }
    function lo(m) {
      return m == null ? m === void 0 ? M : _ : Xt && Xt in Object(m) ? ni(m) : ec(m);
    }
    function Ql(m) {
      return Rr(m) && lo(m) == a;
    }
    function Zl(m, E, j, ee, De) {
      return m === E ? !0 : m == null || E == null || !Rr(m) && !Rr(E) ? m !== m && E !== E : Cd(m, E, j, ee, Zl, De);
    }
    function Cd(m, E, j, ee, De, xe) {
      var Je = fs(m), Ke = fs(E), At = Je ? l : Ir(m), Ye = Ke ? l : Ir(E);
      At = At == a ? y : At, Ye = Ye == a ? y : Ye;
      var ln = At == y, Tn = Ye == y, It = At == Ye;
      if (It && hs(m)) {
        if (!hs(E))
          return !1;
        Je = !0, ln = !1;
      }
      if (It && !ln)
        return xe || (xe = new Or()), Je || oc(m) ? Na(m, E, j, ee, De, xe) : Sd(m, E, At, j, ee, De, xe);
      if (!(j & i)) {
        var cn = ln && Ce.call(m, "__wrapped__"), Qt = Tn && Ce.call(E, "__wrapped__");
        if (cn || Qt) {
          var Ai = cn ? m.value() : m, ri = Qt ? E.value() : E;
          return xe || (xe = new Or()), De(Ai, ri, j, ee, xe);
        }
      }
      return It ? (xe || (xe = new Or()), Td(m, E, j, ee, De, xe)) : !1;
    }
    function kd(m) {
      if (!ic(m) || Od(m))
        return !1;
      var E = rc(m) ? Bt : re;
      return E.test(mn(m));
    }
    function Ed(m) {
      return Rr(m) && Ta(m.length) && !!Q[lo(m)];
    }
    function Nd(m) {
      if (!Id(m))
        return Nn(m);
      var E = [];
      for (var j in Object(m))
        Ce.call(m, j) && j != "constructor" && E.push(j);
      return E;
    }
    function Na(m, E, j, ee, De, xe) {
      var Je = j & i, Ke = m.length, At = E.length;
      if (Ke != At && !(Je && At > Ke))
        return !1;
      var Ye = xe.get(m);
      if (Ye && xe.get(E))
        return Ye == E;
      var ln = -1, Tn = !0, It = j & o ? new cs() : void 0;
      for (xe.set(m, E), xe.set(E, m); ++ln < Ke; ) {
        var cn = m[ln], Qt = E[ln];
        if (ee)
          var Ai = Je ? ee(Qt, cn, ln, E, m, xe) : ee(cn, Qt, ln, m, E, xe);
        if (Ai !== void 0) {
          if (Ai)
            continue;
          Tn = !1;
          break;
        }
        if (It) {
          if (!Be(E, function(ri, uo) {
            if (!vt(It, uo) && (cn === ri || De(cn, ri, j, ee, xe)))
              return It.push(uo);
          })) {
            Tn = !1;
            break;
          }
        } else if (!(cn === Qt || De(cn, Qt, j, ee, xe))) {
          Tn = !1;
          break;
        }
      }
      return xe.delete(m), xe.delete(E), Tn;
    }
    function Sd(m, E, j, ee, De, xe, Je) {
      switch (j) {
        case I:
          if (m.byteLength != E.byteLength || m.byteOffset != E.byteOffset)
            return !1;
          m = m.buffer, E = E.buffer;
        case k:
          return !(m.byteLength != E.byteLength || !xe(new cr(m), new cr(E)));
        case u:
        case f:
        case b:
          return tc(+m, +E);
        case d:
          return m.name == E.name && m.message == E.message;
        case P:
        case L:
          return m == E + "";
        case w:
          var Ke = Et;
        case S:
          var At = ee & i;
          if (Ke || (Ke = Dt), m.size != E.size && !At)
            return !1;
          var Ye = Je.get(m);
          if (Ye)
            return Ye == E;
          ee |= o, Je.set(m, E);
          var ln = Na(Ke(m), Ke(E), ee, De, xe, Je);
          return Je.delete(m), ln;
        case O:
          if (se)
            return se.call(m) == se.call(E);
      }
      return !1;
    }
    function Td(m, E, j, ee, De, xe) {
      var Je = j & i, Ke = co(m), At = Ke.length, Ye = co(E), ln = Ye.length;
      if (At != ln && !Je)
        return !1;
      for (var Tn = At; Tn--; ) {
        var It = Ke[Tn];
        if (!(Je ? It in E : Ce.call(E, It)))
          return !1;
      }
      var cn = xe.get(m);
      if (cn && xe.get(E))
        return cn == E;
      var Qt = !0;
      xe.set(m, E), xe.set(E, m);
      for (var Ai = Je; ++Tn < At; ) {
        It = Ke[Tn];
        var ri = m[It], uo = E[It];
        if (ee)
          var jg = Je ? ee(uo, ri, It, E, m, xe) : ee(ri, uo, It, m, E, xe);
        if (!(jg === void 0 ? ri === uo || De(ri, uo, j, ee, xe) : jg)) {
          Qt = !1;
          break;
        }
        Ai || (Ai = It == "constructor");
      }
      if (Qt && !Ai) {
        var sc = m.constructor, ac = E.constructor;
        sc != ac && "constructor" in m && "constructor" in E && !(typeof sc == "function" && sc instanceof sc && typeof ac == "function" && ac instanceof ac) && (Qt = !1);
      }
      return xe.delete(m), xe.delete(E), Qt;
    }
    function co(m) {
      return Ea(m, Aa, Ad);
    }
    function hr(m, E) {
      var j = m.__data__;
      return Md(E) ? j[typeof E == "string" ? "string" : "hash"] : j.map;
    }
    function ti(m, E) {
      var j = mt(m, E);
      return kd(j) ? j : void 0;
    }
    function ni(m) {
      var E = Ce.call(m, Xt), j = m[Xt];
      try {
        m[Xt] = void 0;
        var ee = !0;
      } catch {
      }
      var De = Mt.call(m);
      return ee && (E ? m[Xt] = j : delete m[Xt]), De;
    }
    var Ad = Un ? function(m) {
      return m == null ? [] : (m = Object(m), ae(Un(m), function(E) {
        return qn.call(m, E);
      }));
    } : Pd, Ir = lo;
    (Dr && Ir(new Dr(new ArrayBuffer(1))) != I || Ze && Ir(new Ze()) != w || bt && Ir(bt.resolve()) != C || gn && Ir(new gn()) != S || wn && Ir(new wn()) != F) && (Ir = function(m) {
      var E = lo(m), j = E == y ? m.constructor : void 0, ee = j ? mn(j) : "";
      if (ee)
        switch (ee) {
          case Ti:
            return I;
          case Qn:
            return w;
          case v:
            return C;
          case x:
            return S;
          case $:
            return F;
        }
      return E;
    });
    function Dd(m, E) {
      return E = E ?? s, !!E && (typeof m == "number" || te.test(m)) && m > -1 && m % 1 == 0 && m < E;
    }
    function Md(m) {
      var E = typeof m;
      return E == "string" || E == "number" || E == "symbol" || E == "boolean" ? m !== "__proto__" : m === null;
    }
    function Od(m) {
      return !!Qe && Qe in m;
    }
    function Id(m) {
      var E = m && m.constructor, j = typeof E == "function" && E.prototype || Ln;
      return m === j;
    }
    function ec(m) {
      return Mt.call(m);
    }
    function mn(m) {
      if (m != null) {
        try {
          return $n.call(m);
        } catch {
        }
        try {
          return m + "";
        } catch {
        }
      }
      return "";
    }
    function tc(m, E) {
      return m === E || m !== m && E !== E;
    }
    var nc = Ql(/* @__PURE__ */ function() {
      return arguments;
    }()) ? Ql : function(m) {
      return Rr(m) && Ce.call(m, "callee") && !qn.call(m, "callee");
    }, fs = Array.isArray;
    function Sa(m) {
      return m != null && Ta(m.length) && !rc(m);
    }
    var hs = zn || Ld;
    function Rd(m, E) {
      return Zl(m, E);
    }
    function rc(m) {
      if (!ic(m))
        return !1;
      var E = lo(m);
      return E == h || E == g || E == c || E == D;
    }
    function Ta(m) {
      return typeof m == "number" && m > -1 && m % 1 == 0 && m <= s;
    }
    function ic(m) {
      var E = typeof m;
      return m != null && (E == "object" || E == "function");
    }
    function Rr(m) {
      return m != null && typeof m == "object";
    }
    var oc = He ? rt(He) : Ed;
    function Aa(m) {
      return Sa(m) ? xd(m) : Nd(m);
    }
    function Pd() {
      return [];
    }
    function Ld() {
      return !1;
    }
    t.exports = Rd;
  }(Va, Va.exports)), Va.exports;
}
var gc = {}, lm;
function HE() {
  if (lm) return gc;
  lm = 1, Object.defineProperty(gc, "__esModule", { value: !0 });
  const t = pv(), e = gv();
  var n;
  return function(r) {
    function i(l = {}, c = {}, u = !1) {
      typeof l != "object" && (l = {}), typeof c != "object" && (c = {});
      let f = t(c);
      u || (f = Object.keys(f).reduce((d, h) => (f[h] != null && (d[h] = f[h]), d), {}));
      for (const d in l)
        l[d] !== void 0 && c[d] === void 0 && (f[d] = l[d]);
      return Object.keys(f).length > 0 ? f : void 0;
    }
    r.compose = i;
    function o(l = {}, c = {}) {
      typeof l != "object" && (l = {}), typeof c != "object" && (c = {});
      const u = Object.keys(l).concat(Object.keys(c)).reduce((f, d) => (e(l[d], c[d]) || (f[d] = c[d] === void 0 ? null : c[d]), f), {});
      return Object.keys(u).length > 0 ? u : void 0;
    }
    r.diff = o;
    function s(l = {}, c = {}) {
      l = l || {};
      const u = Object.keys(c).reduce((f, d) => (c[d] !== l[d] && l[d] !== void 0 && (f[d] = c[d]), f), {});
      return Object.keys(l).reduce((f, d) => (l[d] !== c[d] && c[d] === void 0 && (f[d] = null), f), u);
    }
    r.invert = s;
    function a(l, c, u = !1) {
      if (typeof l != "object")
        return c;
      if (typeof c != "object")
        return;
      if (!u)
        return c;
      const f = Object.keys(c).reduce((d, h) => (l[h] === void 0 && (d[h] = c[h]), d), {});
      return Object.keys(f).length > 0 ? f : void 0;
    }
    r.transform = a;
  }(n || (n = {})), gc.default = n, gc;
}
var wc = {}, cm;
function wv() {
  if (cm) return wc;
  cm = 1, Object.defineProperty(wc, "__esModule", { value: !0 });
  var t;
  return function(e) {
    function n(r) {
      return typeof r.delete == "number" ? r.delete : typeof r.retain == "number" ? r.retain : typeof r.retain == "object" && r.retain !== null ? 1 : typeof r.insert == "string" ? r.insert.length : 1;
    }
    e.length = n;
  }(t || (t = {})), wc.default = t, wc;
}
var mc = {}, um;
function KE() {
  if (um) return mc;
  um = 1, Object.defineProperty(mc, "__esModule", { value: !0 });
  const t = wv();
  class e {
    constructor(r) {
      this.ops = r, this.index = 0, this.offset = 0;
    }
    hasNext() {
      return this.peekLength() < 1 / 0;
    }
    next(r) {
      r || (r = 1 / 0);
      const i = this.ops[this.index];
      if (i) {
        const o = this.offset, s = t.default.length(i);
        if (r >= s - o ? (r = s - o, this.index += 1, this.offset = 0) : this.offset += r, typeof i.delete == "number")
          return { delete: r };
        {
          const a = {};
          return i.attributes && (a.attributes = i.attributes), typeof i.retain == "number" ? a.retain = r : typeof i.retain == "object" && i.retain !== null ? a.retain = i.retain : typeof i.insert == "string" ? a.insert = i.insert.substr(o, r) : a.insert = i.insert, a;
        }
      } else
        return { retain: 1 / 0 };
    }
    peek() {
      return this.ops[this.index];
    }
    peekLength() {
      return this.ops[this.index] ? t.default.length(this.ops[this.index]) - this.offset : 1 / 0;
    }
    peekType() {
      const r = this.ops[this.index];
      return r ? typeof r.delete == "number" ? "delete" : typeof r.retain == "number" || typeof r.retain == "object" && r.retain !== null ? "retain" : "insert" : "retain";
    }
    rest() {
      if (this.hasNext()) {
        if (this.offset === 0)
          return this.ops.slice(this.index);
        {
          const r = this.offset, i = this.index, o = this.next(), s = this.ops.slice(this.index);
          return this.offset = r, this.index = i, [o].concat(s);
        }
      } else return [];
    }
  }
  return mc.default = e, mc;
}
var dm;
function WE() {
  return dm || (dm = 1, function(t, e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AttributeMap = e.OpIterator = e.Op = void 0;
    const n = VE(), r = pv(), i = gv(), o = HE();
    e.AttributeMap = o.default;
    const s = wv();
    e.Op = s.default;
    const a = KE();
    e.OpIterator = a.default;
    const l = "\0", c = (f, d) => {
      if (typeof f != "object" || f === null)
        throw new Error(`cannot retain a ${typeof f}`);
      if (typeof d != "object" || d === null)
        throw new Error(`cannot retain a ${typeof d}`);
      const h = Object.keys(f)[0];
      if (!h || h !== Object.keys(d)[0])
        throw new Error(`embed types not matched: ${h} != ${Object.keys(d)[0]}`);
      return [h, f[h], d[h]];
    };
    class u {
      constructor(d) {
        Array.isArray(d) ? this.ops = d : d != null && Array.isArray(d.ops) ? this.ops = d.ops : this.ops = [];
      }
      static registerEmbed(d, h) {
        this.handlers[d] = h;
      }
      static unregisterEmbed(d) {
        delete this.handlers[d];
      }
      static getHandler(d) {
        const h = this.handlers[d];
        if (!h)
          throw new Error(`no handlers for embed type "${d}"`);
        return h;
      }
      insert(d, h) {
        const g = {};
        return typeof d == "string" && d.length === 0 ? this : (g.insert = d, h != null && typeof h == "object" && Object.keys(h).length > 0 && (g.attributes = h), this.push(g));
      }
      delete(d) {
        return d <= 0 ? this : this.push({ delete: d });
      }
      retain(d, h) {
        if (typeof d == "number" && d <= 0)
          return this;
        const g = { retain: d };
        return h != null && typeof h == "object" && Object.keys(h).length > 0 && (g.attributes = h), this.push(g);
      }
      push(d) {
        let h = this.ops.length, g = this.ops[h - 1];
        if (d = r(d), typeof g == "object") {
          if (typeof d.delete == "number" && typeof g.delete == "number")
            return this.ops[h - 1] = { delete: g.delete + d.delete }, this;
          if (typeof g.delete == "number" && d.insert != null && (h -= 1, g = this.ops[h - 1], typeof g != "object"))
            return this.ops.unshift(d), this;
          if (i(d.attributes, g.attributes)) {
            if (typeof d.insert == "string" && typeof g.insert == "string")
              return this.ops[h - 1] = { insert: g.insert + d.insert }, typeof d.attributes == "object" && (this.ops[h - 1].attributes = d.attributes), this;
            if (typeof d.retain == "number" && typeof g.retain == "number")
              return this.ops[h - 1] = { retain: g.retain + d.retain }, typeof d.attributes == "object" && (this.ops[h - 1].attributes = d.attributes), this;
          }
        }
        return h === this.ops.length ? this.ops.push(d) : this.ops.splice(h, 0, d), this;
      }
      chop() {
        const d = this.ops[this.ops.length - 1];
        return d && typeof d.retain == "number" && !d.attributes && this.ops.pop(), this;
      }
      filter(d) {
        return this.ops.filter(d);
      }
      forEach(d) {
        this.ops.forEach(d);
      }
      map(d) {
        return this.ops.map(d);
      }
      partition(d) {
        const h = [], g = [];
        return this.forEach((w) => {
          (d(w) ? h : g).push(w);
        }), [h, g];
      }
      reduce(d, h) {
        return this.ops.reduce(d, h);
      }
      changeLength() {
        return this.reduce((d, h) => h.insert ? d + s.default.length(h) : h.delete ? d - h.delete : d, 0);
      }
      length() {
        return this.reduce((d, h) => d + s.default.length(h), 0);
      }
      slice(d = 0, h = 1 / 0) {
        const g = [], w = new a.default(this.ops);
        let b = 0;
        for (; b < h && w.hasNext(); ) {
          let _;
          b < d ? _ = w.next(d - b) : (_ = w.next(h - b), g.push(_)), b += s.default.length(_);
        }
        return new u(g);
      }
      compose(d) {
        const h = new a.default(this.ops), g = new a.default(d.ops), w = [], b = g.peek();
        if (b != null && typeof b.retain == "number" && b.attributes == null) {
          let y = b.retain;
          for (; h.peekType() === "insert" && h.peekLength() <= y; )
            y -= h.peekLength(), w.push(h.next());
          b.retain - y > 0 && g.next(b.retain - y);
        }
        const _ = new u(w);
        for (; h.hasNext() || g.hasNext(); )
          if (g.peekType() === "insert")
            _.push(g.next());
          else if (h.peekType() === "delete")
            _.push(h.next());
          else {
            const y = Math.min(h.peekLength(), g.peekLength()), C = h.next(y), D = g.next(y);
            if (D.retain) {
              const P = {};
              if (typeof C.retain == "number")
                P.retain = typeof D.retain == "number" ? y : D.retain;
              else if (typeof D.retain == "number")
                C.retain == null ? P.insert = C.insert : P.retain = C.retain;
              else {
                const L = C.retain == null ? "insert" : "retain", [O, M, F] = c(C[L], D.retain), k = u.getHandler(O);
                P[L] = {
                  [O]: k.compose(M, F, L === "retain")
                };
              }
              const S = o.default.compose(C.attributes, D.attributes, typeof C.retain == "number");
              if (S && (P.attributes = S), _.push(P), !g.hasNext() && i(_.ops[_.ops.length - 1], P)) {
                const L = new u(h.rest());
                return _.concat(L).chop();
              }
            } else typeof D.delete == "number" && (typeof C.retain == "number" || typeof C.retain == "object" && C.retain !== null) && _.push(D);
          }
        return _.chop();
      }
      concat(d) {
        const h = new u(this.ops.slice());
        return d.ops.length > 0 && (h.push(d.ops[0]), h.ops = h.ops.concat(d.ops.slice(1))), h;
      }
      diff(d, h) {
        if (this.ops === d.ops)
          return new u();
        const g = [this, d].map((C) => C.map((D) => {
          if (D.insert != null)
            return typeof D.insert == "string" ? D.insert : l;
          const P = C === d ? "on" : "with";
          throw new Error("diff() called " + P + " non-document");
        }).join("")), w = new u(), b = n(g[0], g[1], h, !0), _ = new a.default(this.ops), y = new a.default(d.ops);
        return b.forEach((C) => {
          let D = C[1].length;
          for (; D > 0; ) {
            let P = 0;
            switch (C[0]) {
              case n.INSERT:
                P = Math.min(y.peekLength(), D), w.push(y.next(P));
                break;
              case n.DELETE:
                P = Math.min(D, _.peekLength()), _.next(P), w.delete(P);
                break;
              case n.EQUAL:
                P = Math.min(_.peekLength(), y.peekLength(), D);
                const S = _.next(P), L = y.next(P);
                i(S.insert, L.insert) ? w.retain(P, o.default.diff(S.attributes, L.attributes)) : w.push(L).delete(P);
                break;
            }
            D -= P;
          }
        }), w.chop();
      }
      eachLine(d, h = `
`) {
        const g = new a.default(this.ops);
        let w = new u(), b = 0;
        for (; g.hasNext(); ) {
          if (g.peekType() !== "insert")
            return;
          const _ = g.peek(), y = s.default.length(_) - g.peekLength(), C = typeof _.insert == "string" ? _.insert.indexOf(h, y) - y : -1;
          if (C < 0)
            w.push(g.next());
          else if (C > 0)
            w.push(g.next(C));
          else {
            if (d(w, g.next(1).attributes || {}, b) === !1)
              return;
            b += 1, w = new u();
          }
        }
        w.length() > 0 && d(w, {}, b);
      }
      invert(d) {
        const h = new u();
        return this.reduce((g, w) => {
          if (w.insert)
            h.delete(s.default.length(w));
          else {
            if (typeof w.retain == "number" && w.attributes == null)
              return h.retain(w.retain), g + w.retain;
            if (w.delete || typeof w.retain == "number") {
              const b = w.delete || w.retain;
              return d.slice(g, g + b).forEach((y) => {
                w.delete ? h.push(y) : w.retain && w.attributes && h.retain(s.default.length(y), o.default.invert(w.attributes, y.attributes));
              }), g + b;
            } else if (typeof w.retain == "object" && w.retain !== null) {
              const b = d.slice(g, g + 1), _ = new a.default(b.ops).next(), [y, C, D] = c(w.retain, _.insert), P = u.getHandler(y);
              return h.retain({ [y]: P.invert(C, D) }, o.default.invert(w.attributes, _.attributes)), g + 1;
            }
          }
          return g;
        }, 0), h.chop();
      }
      transform(d, h = !1) {
        if (h = !!h, typeof d == "number")
          return this.transformPosition(d, h);
        const g = d, w = new a.default(this.ops), b = new a.default(g.ops), _ = new u();
        for (; w.hasNext() || b.hasNext(); )
          if (w.peekType() === "insert" && (h || b.peekType() !== "insert"))
            _.retain(s.default.length(w.next()));
          else if (b.peekType() === "insert")
            _.push(b.next());
          else {
            const y = Math.min(w.peekLength(), b.peekLength()), C = w.next(y), D = b.next(y);
            if (C.delete)
              continue;
            if (D.delete)
              _.push(D);
            else {
              const P = C.retain, S = D.retain;
              let L = typeof S == "object" && S !== null ? S : y;
              if (typeof P == "object" && P !== null && typeof S == "object" && S !== null) {
                const O = Object.keys(P)[0];
                if (O === Object.keys(S)[0]) {
                  const M = u.getHandler(O);
                  M && (L = {
                    [O]: M.transform(P[O], S[O], h)
                  });
                }
              }
              _.retain(L, o.default.transform(C.attributes, D.attributes, h));
            }
          }
        return _.chop();
      }
      transformPosition(d, h = !1) {
        h = !!h;
        const g = new a.default(this.ops);
        let w = 0;
        for (; g.hasNext() && w <= d; ) {
          const b = g.peekLength(), _ = g.peekType();
          if (g.next(), _ === "delete") {
            d -= Math.min(b, d - w);
            continue;
          } else _ === "insert" && (w < d || !h) && (d += b);
          w += b;
        }
        return d;
      }
    }
    u.Op = s.default, u.OpIterator = a.default, u.AttributeMap = o.default, u.handlers = {}, e.default = u, t.exports = u, t.exports.default = u;
  }(pc, pc.exports)), pc.exports;
}
var GE = WE();
const Ha = /* @__PURE__ */ PC(GE);
var JE = Object.getOwnPropertyNames, XE = Object.getOwnPropertySymbols, YE = Object.prototype.hasOwnProperty;
function fm(t, e) {
  return function(r, i, o) {
    return t(r, i, o) && e(r, i, o);
  };
}
function bc(t) {
  return function(n, r, i) {
    if (!n || !r || typeof n != "object" || typeof r != "object")
      return t(n, r, i);
    var o = i.cache, s = o.get(n), a = o.get(r);
    if (s && a)
      return s === r && a === n;
    o.set(n, r), o.set(r, n);
    var l = t(n, r, i);
    return o.delete(n), o.delete(r), l;
  };
}
function hm(t) {
  return JE(t).concat(XE(t));
}
var QE = Object.hasOwn || function(t, e) {
  return YE.call(t, e);
};
function os(t, e) {
  return t === e || !t && !e && t !== t && e !== e;
}
var ZE = "__v", eN = "__o", tN = "_owner", pm = Object.getOwnPropertyDescriptor, gm = Object.keys;
function nN(t, e, n) {
  var r = t.length;
  if (e.length !== r)
    return !1;
  for (; r-- > 0; )
    if (!n.equals(t[r], e[r], r, r, t, e, n))
      return !1;
  return !0;
}
function rN(t, e) {
  return os(t.getTime(), e.getTime());
}
function iN(t, e) {
  return t.name === e.name && t.message === e.message && t.cause === e.cause && t.stack === e.stack;
}
function oN(t, e) {
  return t === e;
}
function wm(t, e, n) {
  var r = t.size;
  if (r !== e.size)
    return !1;
  if (!r)
    return !0;
  for (var i = new Array(r), o = t.entries(), s, a, l = 0; (s = o.next()) && !s.done; ) {
    for (var c = e.entries(), u = !1, f = 0; (a = c.next()) && !a.done; ) {
      if (i[f]) {
        f++;
        continue;
      }
      var d = s.value, h = a.value;
      if (n.equals(d[0], h[0], l, f, t, e, n) && n.equals(d[1], h[1], d[0], h[0], t, e, n)) {
        u = i[f] = !0;
        break;
      }
      f++;
    }
    if (!u)
      return !1;
    l++;
  }
  return !0;
}
var sN = os;
function aN(t, e, n) {
  var r = gm(t), i = r.length;
  if (gm(e).length !== i)
    return !1;
  for (; i-- > 0; )
    if (!mv(t, e, n, r[i]))
      return !1;
  return !0;
}
function Ra(t, e, n) {
  var r = hm(t), i = r.length;
  if (hm(e).length !== i)
    return !1;
  for (var o, s, a; i-- > 0; )
    if (o = r[i], !mv(t, e, n, o) || (s = pm(t, o), a = pm(e, o), (s || a) && (!s || !a || s.configurable !== a.configurable || s.enumerable !== a.enumerable || s.writable !== a.writable)))
      return !1;
  return !0;
}
function lN(t, e) {
  return os(t.valueOf(), e.valueOf());
}
function cN(t, e) {
  return t.source === e.source && t.flags === e.flags;
}
function mm(t, e, n) {
  var r = t.size;
  if (r !== e.size)
    return !1;
  if (!r)
    return !0;
  for (var i = new Array(r), o = t.values(), s, a; (s = o.next()) && !s.done; ) {
    for (var l = e.values(), c = !1, u = 0; (a = l.next()) && !a.done; ) {
      if (!i[u] && n.equals(s.value, a.value, s.value, a.value, t, e, n)) {
        c = i[u] = !0;
        break;
      }
      u++;
    }
    if (!c)
      return !1;
  }
  return !0;
}
function uN(t, e) {
  var n = t.length;
  if (e.length !== n)
    return !1;
  for (; n-- > 0; )
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function dN(t, e) {
  return t.hostname === e.hostname && t.pathname === e.pathname && t.protocol === e.protocol && t.port === e.port && t.hash === e.hash && t.username === e.username && t.password === e.password;
}
function mv(t, e, n, r) {
  return (r === tN || r === eN || r === ZE) && (t.$$typeof || e.$$typeof) ? !0 : QE(e, r) && n.equals(t[r], e[r], r, r, t, e, n);
}
var fN = "[object Arguments]", hN = "[object Boolean]", pN = "[object Date]", gN = "[object Error]", wN = "[object Map]", mN = "[object Number]", bN = "[object Object]", yN = "[object RegExp]", vN = "[object Set]", _N = "[object String]", xN = "[object URL]", CN = Array.isArray, bm = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, ym = Object.assign, kN = Object.prototype.toString.call.bind(Object.prototype.toString);
function EN(t) {
  var e = t.areArraysEqual, n = t.areDatesEqual, r = t.areErrorsEqual, i = t.areFunctionsEqual, o = t.areMapsEqual, s = t.areNumbersEqual, a = t.areObjectsEqual, l = t.arePrimitiveWrappersEqual, c = t.areRegExpsEqual, u = t.areSetsEqual, f = t.areTypedArraysEqual, d = t.areUrlsEqual;
  return function(g, w, b) {
    if (g === w)
      return !0;
    if (g == null || w == null)
      return !1;
    var _ = typeof g;
    if (_ !== typeof w)
      return !1;
    if (_ !== "object")
      return _ === "number" ? s(g, w, b) : _ === "function" ? i(g, w, b) : !1;
    var y = g.constructor;
    if (y !== w.constructor)
      return !1;
    if (y === Object)
      return a(g, w, b);
    if (CN(g))
      return e(g, w, b);
    if (bm != null && bm(g))
      return f(g, w, b);
    if (y === Date)
      return n(g, w, b);
    if (y === RegExp)
      return c(g, w, b);
    if (y === Map)
      return o(g, w, b);
    if (y === Set)
      return u(g, w, b);
    var C = kN(g);
    return C === pN ? n(g, w, b) : C === yN ? c(g, w, b) : C === wN ? o(g, w, b) : C === vN ? u(g, w, b) : C === bN ? typeof g.then != "function" && typeof w.then != "function" && a(g, w, b) : C === xN ? d(g, w, b) : C === gN ? r(g, w, b) : C === fN ? a(g, w, b) : C === hN || C === mN || C === _N ? l(g, w, b) : !1;
  };
}
function NN(t) {
  var e = t.circular, n = t.createCustomConfig, r = t.strict, i = {
    areArraysEqual: r ? Ra : nN,
    areDatesEqual: rN,
    areErrorsEqual: iN,
    areFunctionsEqual: oN,
    areMapsEqual: r ? fm(wm, Ra) : wm,
    areNumbersEqual: sN,
    areObjectsEqual: r ? Ra : aN,
    arePrimitiveWrappersEqual: lN,
    areRegExpsEqual: cN,
    areSetsEqual: r ? fm(mm, Ra) : mm,
    areTypedArraysEqual: r ? Ra : uN,
    areUrlsEqual: dN
  };
  if (n && (i = ym({}, i, n(i))), e) {
    var o = bc(i.areArraysEqual), s = bc(i.areMapsEqual), a = bc(i.areObjectsEqual), l = bc(i.areSetsEqual);
    i = ym({}, i, {
      areArraysEqual: o,
      areMapsEqual: s,
      areObjectsEqual: a,
      areSetsEqual: l
    });
  }
  return i;
}
function SN(t) {
  return function(e, n, r, i, o, s, a) {
    return t(e, n, a);
  };
}
function TN(t) {
  var e = t.circular, n = t.comparator, r = t.createState, i = t.equals, o = t.strict;
  if (r)
    return function(l, c) {
      var u = r(), f = u.cache, d = f === void 0 ? e ? /* @__PURE__ */ new WeakMap() : void 0 : f, h = u.meta;
      return n(l, c, {
        cache: d,
        equals: i,
        meta: h,
        strict: o
      });
    };
  if (e)
    return function(l, c) {
      return n(l, c, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: i,
        meta: void 0,
        strict: o
      });
    };
  var s = {
    cache: void 0,
    equals: i,
    meta: void 0,
    strict: o
  };
  return function(l, c) {
    return n(l, c, s);
  };
}
var ui = no();
no({ strict: !0 });
no({ circular: !0 });
no({
  circular: !0,
  strict: !0
});
no({
  createInternalComparator: function() {
    return os;
  }
});
no({
  strict: !0,
  createInternalComparator: function() {
    return os;
  }
});
no({
  circular: !0,
  createInternalComparator: function() {
    return os;
  }
});
no({
  circular: !0,
  createInternalComparator: function() {
    return os;
  },
  strict: !0
});
function no(t) {
  t === void 0 && (t = {});
  var e = t.circular, n = e === void 0 ? !1 : e, r = t.createInternalComparator, i = t.createState, o = t.strict, s = o === void 0 ? !1 : o, a = NN(t), l = EN(a), c = r ? r(l) : SN(l);
  return TN({ circular: n, comparator: l, createState: i, equals: c, strict: s });
}
const bv = Sl(null);
function AN(t, e) {
  return { getTheme: function() {
    return e ?? null;
  } };
}
function Le() {
  const t = Tl(bv);
  return t == null && function(e, ...n) {
    const r = new URL("https://lexical.dev/docs/error"), i = new URLSearchParams();
    i.append("code", e);
    for (const o of n) i.append("v", o);
    throw r.search = i.toString(), Error(`Minified Lexical error #${e}; visit ${r.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
  }(8), t;
}
function DN(t, e) {
  const n = e.body ? e.body.childNodes : [];
  let r = [];
  const i = [];
  for (let o = 0; o < n.length; o++) {
    const s = n[o];
    if (!_v.has(s.nodeName)) {
      const a = xv(s, t, i, !1);
      a !== null && (r = r.concat(a));
    }
  }
  return function(o) {
    for (const s of o) s.getNextSibling() instanceof Sp && s.insertAfter(Bo());
    for (const s of o) {
      const a = s.getChildren();
      for (const l of a) s.insertBefore(l);
      s.remove();
    }
  }(i), r;
}
function yv(t, e) {
  if (typeof document > "u" || typeof window > "u" && global.window === void 0) throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  const n = document.createElement("div"), r = Ve().getChildren();
  for (let i = 0; i < r.length; i++)
    vv(t, r[i], n, e);
  return n.innerHTML;
}
function vv(t, e, n, r = null) {
  let i = r === null || e.isSelected(r);
  const o = X(e) && e.excludeFromCopy("html");
  let s = e;
  if (r !== null) {
    let h = Fp(e);
    h = ie(h) && r !== null ? lv(r, h) : h, s = h;
  }
  const a = X(s) ? s.getChildren() : [], l = Dp(t, s.getType());
  let c;
  c = l && l.exportDOM !== void 0 ? l.exportDOM(t, s) : s.exportDOM(t);
  const { element: u, after: f } = c;
  if (!u) return !1;
  const d = document.createDocumentFragment();
  for (let h = 0; h < a.length; h++) {
    const g = a[h], w = vv(t, g, d, r);
    !i && X(e) && w && e.extractWithChild(g, r, "html") && (i = !0);
  }
  if (i && !o) {
    if ((it(u) || rh(u)) && u.append(d), n.append(u), f) {
      const h = f.call(s, u);
      h && (rh(u) ? u.replaceChildren(h) : u.replaceWith(h));
    }
  } else n.append(d);
  return i;
}
const _v = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
function xv(t, e, n, r, i = /* @__PURE__ */ new Map(), o) {
  let s = [];
  if (_v.has(t.nodeName)) return s;
  let a = null;
  const l = function(g, w) {
    const { nodeName: b } = g, _ = w._htmlConversions.get(b.toLowerCase());
    let y = null;
    if (_ !== void 0) for (const C of _) {
      const D = C(g);
      D !== null && (y === null || (y.priority || 0) <= (D.priority || 0)) && (y = D);
    }
    return y !== null ? y.conversion : null;
  }(t, e), c = l ? l(t) : null;
  let u = null;
  if (c !== null) {
    u = c.after;
    const g = c.node;
    if (a = Array.isArray(g) ? g[g.length - 1] : g, a !== null) {
      for (const [, w] of i) if (a = w(a, o), !a) break;
      a && s.push(...Array.isArray(g) ? g : [a]);
    }
    c.forChild != null && i.set(t.nodeName, c.forChild);
  }
  const f = t.childNodes;
  let d = [];
  const h = (a == null || !Zr(a)) && (a != null && Yf(a) || r);
  for (let g = 0; g < f.length; g++) d.push(...xv(f[g], e, n, h, new Map(i), a));
  return u != null && (d = u(d)), su(t) && (d = MN(t, d, h ? () => {
    const g = new Sp();
    return n.push(g), g;
  } : Jn)), a == null ? d.length > 0 ? s = s.concat(d) : su(t) && function(g) {
    return g.nextSibling == null || g.previousSibling == null ? !1 : ih(g.nextSibling) && ih(g.previousSibling);
  }(t) && (s = s.concat(Bo())) : X(a) && a.append(...d), s;
}
function MN(t, e, n) {
  const r = t.style.textAlign, i = [];
  let o = [];
  for (let s = 0; s < e.length; s++) {
    const a = e[s];
    if (Yf(a)) r && !a.getFormat() && a.setFormat(r), i.push(a);
    else if (o.push(a), s === e.length - 1 || s < e.length - 1 && Yf(e[s + 1])) {
      const l = n();
      l.setFormat(r), l.append(...o), i.push(l), o = [];
    }
  }
  return i;
}
const ON = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
let Cv = class kv extends pn {
  static getType() {
    return "link";
  }
  static clone(e) {
    return new kv(e.__url, { rel: e.__rel, target: e.__target, title: e.__title }, e.__key);
  }
  constructor(e = "", n = {}, r) {
    super(r);
    const { target: i = null, rel: o = null, title: s = null } = n;
    this.__url = e, this.__target = i, this.__rel = o, this.__title = s;
  }
  createDOM(e) {
    const n = document.createElement("a");
    return this.updateLinkDOM(null, n, e), un(n, e.theme.link), n;
  }
  updateLinkDOM(e, n, r) {
    if (tv(n)) {
      e && e.__url === this.__url || (n.href = this.sanitizeUrl(this.__url));
      for (const i of ["target", "rel", "title"]) {
        const o = `__${i}`, s = this[o];
        e && e[o] === s || (s ? n[i] = s : n.removeAttribute(i));
      }
    }
  }
  updateDOM(e, n, r) {
    return this.updateLinkDOM(e, n, r), !1;
  }
  static importDOM() {
    return { a: (e) => ({ conversion: IN, priority: 1 }) };
  }
  static importJSON(e) {
    return ch().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setURL(e.url).setRel(e.rel || null).setTarget(e.target || null).setTitle(e.title || null);
  }
  sanitizeUrl(e) {
    e = vm(e);
    try {
      const n = new URL(vm(e));
      if (!ON.has(n.protocol)) return "about:blank";
    } catch {
      return e;
    }
    return e;
  }
  exportJSON() {
    return { ...super.exportJSON(), rel: this.getRel(), target: this.getTarget(), title: this.getTitle(), url: this.getURL() };
  }
  getURL() {
    return this.getLatest().__url;
  }
  setURL(e) {
    const n = this.getWritable();
    return n.__url = e, n;
  }
  getTarget() {
    return this.getLatest().__target;
  }
  setTarget(e) {
    const n = this.getWritable();
    return n.__target = e, n;
  }
  getRel() {
    return this.getLatest().__rel;
  }
  setRel(e) {
    const n = this.getWritable();
    return n.__rel = e, n;
  }
  getTitle() {
    return this.getLatest().__title;
  }
  setTitle(e) {
    const n = this.getWritable();
    return n.__title = e, n;
  }
  insertNewAfter(e, n = !0) {
    const r = ch(this.__url, { rel: this.__rel, target: this.__target, title: this.__title });
    return this.insertAfter(r, n), r;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
  extractWithChild(e, n, r) {
    if (!Z(n)) return !1;
    const i = n.anchor.getNode(), o = n.focus.getNode();
    return this.isParentOf(i) && this.isParentOf(o) && n.getTextContent().length > 0;
  }
  isEmailURI() {
    return this.__url.startsWith("mailto:");
  }
  isWebSiteURI() {
    return this.__url.startsWith("https://") || this.__url.startsWith("http://");
  }
};
function IN(t) {
  let e = null;
  if (tv(t)) {
    const n = t.textContent;
    (n !== null && n !== "" || t.children.length > 0) && (e = ch(t.getAttribute("href") || "", { rel: t.getAttribute("rel"), target: t.getAttribute("target"), title: t.getAttribute("title") }));
  }
  return { node: e };
}
function ch(t = "", e) {
  return lt(new Cv(t, e));
}
function RN(t) {
  return t instanceof Cv;
}
const PN = /^\+?[0-9\s()-]{5,}$/;
function vm(t) {
  return t.match(/^[a-z][a-z0-9+.-]*:/i) || t.match(/^[/#.]/) ? t : t.includes("@") ? `mailto:${t}` : PN.test(t) ? `tel:${t}` : `https://${t}`;
}
const Ev = [];
let Nv = class Sv extends pn {
  static getType() {
    return "mark";
  }
  static clone(e) {
    return new Sv(e.__ids, e.__key);
  }
  static importDOM() {
    return null;
  }
  static importJSON(e) {
    return _m().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setIDs(e.ids);
  }
  exportJSON() {
    return { ...super.exportJSON(), ids: this.getIDs() };
  }
  constructor(e = Ev, n) {
    super(n), this.__ids = e;
  }
  createDOM(e) {
    const n = document.createElement("mark");
    return un(n, e.theme.mark), this.__ids.length > 1 && un(n, e.theme.markOverlap), n;
  }
  updateDOM(e, n, r) {
    const i = e.__ids, o = this.__ids, s = i.length, a = o.length, l = r.theme.markOverlap;
    return s !== a && (s === 1 ? a === 2 && un(n, l) : a === 1 && To(n, l)), !1;
  }
  hasID(e) {
    return this.getIDs().includes(e);
  }
  getIDs() {
    return Array.from(this.getLatest().__ids);
  }
  setIDs(e) {
    const n = this.getWritable();
    return n.__ids = e, n;
  }
  addID(e) {
    const n = this.getWritable();
    return n.__ids.includes(e) ? n : n.setIDs([...n.__ids, e]);
  }
  deleteID(e) {
    const n = this.getWritable(), r = n.__ids.indexOf(e);
    if (r === -1) return n;
    const i = Array.from(n.__ids);
    return i.splice(r, 1), n.setIDs(i);
  }
  insertNewAfter(e, n = !0) {
    const r = _m(this.__ids);
    return this.insertAfter(r, n), r;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
  extractWithChild(e, n, r) {
    if (!Z(n) || r === "html") return !1;
    const i = n.anchor, o = n.focus, s = i.getNode(), a = o.getNode(), l = n.isBackward() ? i.offset - o.offset : o.offset - i.offset;
    return this.isParentOf(s) && this.isParentOf(a) && this.getTextContent().length === l;
  }
  excludeFromCopy(e) {
    return e !== "clone";
  }
};
function _m(t = Ev) {
  return lt(new Nv(t));
}
function LN(t) {
  return t instanceof Nv;
}
function du(t, ...e) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", t);
  for (const i of e) r.append("v", i);
  throw n.search = r.toString(), Error(`Minified Lexical error #${t}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
function Tv(t, e = oe()) {
  return e == null && du(166), Z(e) && e.isCollapsed() || e.getNodes().length === 0 ? "" : yv(t, e);
}
function $N(t, e = oe()) {
  return e == null && du(166), Z(e) && e.isCollapsed() || e.getNodes().length === 0 ? null : JSON.stringify(FN(t, e));
}
function xm(t, e) {
  const n = t.getData("text/plain") || t.getData("text/uri-list");
  n != null && e.insertRawText(n);
}
function Cm(t, e, n) {
  const r = t.getData("application/x-lexical-editor");
  if (r) try {
    const a = JSON.parse(r);
    if (a.namespace === n._config.namespace && Array.isArray(a.nodes))
      return km(n, BN(a.nodes), e);
  } catch {
  }
  const i = t.getData("text/html"), o = t.getData("text/plain");
  if (i && o !== i) try {
    const a = new DOMParser().parseFromString(function(l) {
      return window.trustedTypes && window.trustedTypes.createPolicy ? window.trustedTypes.createPolicy("lexical", { createHTML: (c) => c }).createHTML(l) : l;
    }(i), "text/html");
    return km(n, DN(n, a), e);
  } catch {
  }
  const s = o || t.getData("text/uri-list");
  if (s != null) if (Z(e)) {
    const a = s.split(/(\r?\n|\t)/);
    a[a.length - 1] === "" && a.pop();
    for (let l = 0; l < a.length; l++) {
      const c = oe();
      if (Z(c)) {
        const u = a[l];
        u === `
` || u === `\r
` ? c.insertParagraph() : u === "	" ? c.insertNodes([Ll()]) : c.insertText(u);
      }
    }
  } else e.insertRawText(s);
}
function km(t, e, n) {
  t.dispatchCommand(vk, { nodes: e, selection: n }) || (n.insertNodes(e), function(r) {
    if (Z(r) && r.isCollapsed()) {
      const i = r.anchor;
      let o = null;
      const s = bi(i, "previous");
      if (s) if (Bi(s)) o = s.origin;
      else {
        const a = Hi(s, _r(Ve(), "next").getFlipped());
        for (const l of a) {
          if (ie(l.origin)) {
            o = l.origin;
            break;
          }
          if (X(l.origin) && !l.origin.isInline()) break;
        }
      }
      if (o && ie(o)) {
        const a = o.getFormat(), l = o.getStyle();
        r.format === a && r.style === l || (r.format = a, r.style = l, r.dirty = !0);
      }
    }
  }(n));
}
function Av(t, e, n, r = []) {
  let i = e === null || n.isSelected(e);
  const o = X(n) && n.excludeFromCopy("html");
  let s = n;
  if (e !== null) {
    let c = Fp(n);
    c = ie(c) && e !== null ? lv(e, c) : c, s = c;
  }
  const a = X(s) ? s.getChildren() : [], l = function(c) {
    const u = c.exportJSON(), f = c.constructor;
    if (u.type !== f.getType() && du(58, f.name), X(c)) {
      const d = u.children;
      Array.isArray(d) || du(59, f.name);
    }
    return u;
  }(s);
  if (ie(s)) {
    const c = s.__text;
    c.length > 0 ? l.text = c : i = !1;
  }
  for (let c = 0; c < a.length; c++) {
    const u = a[c], f = Av(t, e, u, l.children);
    !i && X(n) && f && n.extractWithChild(u, e, "clone") && (i = !0);
  }
  if (i && !o) r.push(l);
  else if (Array.isArray(l.children)) for (let c = 0; c < l.children.length; c++) {
    const u = l.children[c];
    r.push(u);
  }
  return i;
}
function FN(t, e) {
  const n = [], r = Ve().getChildren();
  for (let i = 0; i < r.length; i++)
    Av(t, e, r[i], n);
  return { namespace: t._config.namespace, nodes: n };
}
function BN(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const r = t[n], i = $0(r);
    ie(i) && SE(i), e.push(i);
  }
  return e;
}
let gs = null;
async function Em(t, e, n) {
  if (gs !== null) return !1;
  if (e !== null) return new Promise((c, u) => {
    t.update(() => {
      c(Nm(t, e, n));
    });
  });
  const r = t.getRootElement(), i = t._window || window, o = window.document, s = vr(i);
  if (r === null || s === null) return !1;
  const a = o.createElement("span");
  a.style.cssText = "position: fixed; top: -1000px;", a.append(o.createTextNode("#")), r.append(a);
  const l = new Range();
  return l.setStart(a, 0), l.setEnd(a, 1), s.removeAllRanges(), s.addRange(l), new Promise((c, u) => {
    const f = t.registerCommand(Qi, (d) => (gi(d, ClipboardEvent) && (f(), gs !== null && (window.clearTimeout(gs), gs = null), c(Nm(t, d, n))), !0), ks);
    gs = window.setTimeout(() => {
      f(), gs = null, c(!1);
    }, 50), o.execCommand("copy"), a.remove();
  });
}
function Nm(t, e, n) {
  if (n === void 0) {
    const i = vr(t._window);
    if (!i) return !1;
    const o = i.anchorNode, s = i.focusNode;
    if (o !== null && s !== null && !Fl(t, o, s)) return !1;
    const a = oe();
    if (a === null) return !1;
    n = jN(a);
  }
  e.preventDefault();
  const r = e.clipboardData;
  return r !== null && (UN(r, n), !0);
}
const qN = [["text/html", Tv], ["application/x-lexical-editor", $N]];
function jN(t = oe()) {
  const e = { "text/plain": t ? t.getTextContent() : "" };
  if (t) {
    const n = Zu();
    for (const [r, i] of qN) {
      const o = i(n, t);
      o !== null && (e[r] = o);
    }
  }
  return e;
}
function UN(t, e) {
  for (const n in e) {
    const r = e[n];
    r !== void 0 && t.setData(n, r);
  }
}
const zp = /^(\d+(?:\.\d+)?)px$/, Ns = { BOTH: 3, NO_STATUS: 0, ROW: 1 };
let Vp = class Dv extends pn {
  static getType() {
    return "tablecell";
  }
  static clone(e) {
    return new Dv(e.__headerState, e.__colSpan, e.__width, e.__key);
  }
  afterCloneFrom(e) {
    super.afterCloneFrom(e), this.__rowSpan = e.__rowSpan, this.__backgroundColor = e.__backgroundColor, this.__verticalAlign = e.__verticalAlign;
  }
  static importDOM() {
    return { td: (e) => ({ conversion: Sm, priority: 0 }), th: (e) => ({ conversion: Sm, priority: 0 }) };
  }
  static importJSON(e) {
    return Mv().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setHeaderStyles(e.headerState).setColSpan(e.colSpan || 1).setRowSpan(e.rowSpan || 1).setWidth(e.width || void 0).setBackgroundColor(e.backgroundColor || null).setVerticalAlign(e.verticalAlign || void 0);
  }
  constructor(e = Ns.NO_STATUS, n = 1, r, i) {
    super(i), this.__colSpan = n, this.__rowSpan = 1, this.__headerState = e, this.__width = r, this.__backgroundColor = null, this.__verticalAlign = void 0;
  }
  createDOM(e) {
    const n = document.createElement(this.getTag());
    return this.__width && (n.style.width = `${this.__width}px`), this.__colSpan > 1 && (n.colSpan = this.__colSpan), this.__rowSpan > 1 && (n.rowSpan = this.__rowSpan), this.__backgroundColor !== null && (n.style.backgroundColor = this.__backgroundColor), uh(this.__verticalAlign) && (n.style.verticalAlign = this.__verticalAlign), un(n, e.theme.tableCell, this.hasHeader() && e.theme.tableCellHeader), n;
  }
  exportDOM(e) {
    const n = super.exportDOM(e);
    if (it(n.element)) {
      const r = n.element;
      r.setAttribute("data-temporary-table-cell-lexical-key", this.getKey()), r.style.border = "1px solid black", this.__colSpan > 1 && (r.colSpan = this.__colSpan), this.__rowSpan > 1 && (r.rowSpan = this.__rowSpan), r.style.width = `${this.getWidth() || 75}px`, r.style.verticalAlign = this.getVerticalAlign() || "top", r.style.textAlign = "start", this.__backgroundColor === null && this.hasHeader() && (r.style.backgroundColor = "#f2f3f5");
    }
    return n;
  }
  exportJSON() {
    return { ...super.exportJSON(), ...uh(this.__verticalAlign) && { verticalAlign: this.__verticalAlign }, backgroundColor: this.getBackgroundColor(), colSpan: this.__colSpan, headerState: this.__headerState, rowSpan: this.__rowSpan, width: this.getWidth() };
  }
  getColSpan() {
    return this.getLatest().__colSpan;
  }
  setColSpan(e) {
    const n = this.getWritable();
    return n.__colSpan = e, n;
  }
  getRowSpan() {
    return this.getLatest().__rowSpan;
  }
  setRowSpan(e) {
    const n = this.getWritable();
    return n.__rowSpan = e, n;
  }
  getTag() {
    return this.hasHeader() ? "th" : "td";
  }
  setHeaderStyles(e, n = Ns.BOTH) {
    const r = this.getWritable();
    return r.__headerState = e & n | r.__headerState & ~n, r;
  }
  getHeaderStyles() {
    return this.getLatest().__headerState;
  }
  setWidth(e) {
    const n = this.getWritable();
    return n.__width = e, n;
  }
  getWidth() {
    return this.getLatest().__width;
  }
  getBackgroundColor() {
    return this.getLatest().__backgroundColor;
  }
  setBackgroundColor(e) {
    const n = this.getWritable();
    return n.__backgroundColor = e, n;
  }
  getVerticalAlign() {
    return this.getLatest().__verticalAlign;
  }
  setVerticalAlign(e) {
    const n = this.getWritable();
    return n.__verticalAlign = e || void 0, n;
  }
  toggleHeaderStyle(e) {
    const n = this.getWritable();
    return (n.__headerState & e) === e ? n.__headerState -= e : n.__headerState += e, n;
  }
  hasHeaderState(e) {
    return (this.getHeaderStyles() & e) === e;
  }
  hasHeader() {
    return this.getLatest().__headerState !== Ns.NO_STATUS;
  }
  updateDOM(e) {
    return e.__headerState !== this.__headerState || e.__width !== this.__width || e.__colSpan !== this.__colSpan || e.__rowSpan !== this.__rowSpan || e.__backgroundColor !== this.__backgroundColor || e.__verticalAlign !== this.__verticalAlign;
  }
  isShadowRoot() {
    return !0;
  }
  collapseAtStart() {
    return !0;
  }
  canBeEmpty() {
    return !1;
  }
  canIndent() {
    return !1;
  }
};
function uh(t) {
  return t === "middle" || t === "bottom";
}
function Sm(t) {
  const e = t, n = t.nodeName.toLowerCase();
  let r;
  zp.test(e.style.width) && (r = parseFloat(e.style.width));
  const i = Mv(n === "th" ? Ns.ROW : Ns.NO_STATUS, e.colSpan, r);
  i.__rowSpan = e.rowSpan;
  const o = e.style.backgroundColor;
  o !== "" && (i.__backgroundColor = o);
  const s = e.style.verticalAlign;
  uh(s) && (i.__verticalAlign = s);
  const a = e.style, l = (a && a.textDecoration || "").split(" "), c = a.fontWeight === "700" || a.fontWeight === "bold", u = l.includes("line-through"), f = a.fontStyle === "italic", d = l.includes("underline");
  return { after: (h) => {
    const g = [];
    let w = null;
    const b = () => {
      if (w) {
        const _ = w.getFirstChild();
        ko(_) && w.getChildrenSize() === 1 && _.remove();
      }
    };
    for (const _ of h) rE(_) || ie(_) || ko(_) ? (ie(_) && (c && _.toggleFormat("bold"), u && _.toggleFormat("strikethrough"), f && _.toggleFormat("italic"), d && _.toggleFormat("underline")), w ? w.append(_) : (w = Jn().append(_), g.push(w))) : (g.push(_), b(), w = null);
    return b(), g.length === 0 && g.push(Jn()), g;
  }, node: i };
}
function Mv(t = Ns.NO_STATUS, e = 1, n) {
  return lt(new Vp(t, e, n));
}
function Gn(t) {
  return t instanceof Vp;
}
function Pt(t, ...e) {
  const n = new URL("https://lexical.dev/docs/error"), r = new URLSearchParams();
  r.append("code", t);
  for (const i of e) r.append("v", i);
  throw n.search = r.toString(), Error(`Minified Lexical error #${t}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
}
class nd extends pn {
  static getType() {
    return "tablerow";
  }
  static clone(e) {
    return new nd(e.__height, e.__key);
  }
  static importDOM() {
    return { tr: (e) => ({ conversion: zN, priority: 0 }) };
  }
  static importJSON(e) {
    return Ov().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setHeight(e.height);
  }
  constructor(e, n) {
    super(n), this.__height = e;
  }
  exportJSON() {
    const e = this.getHeight();
    return { ...super.exportJSON(), ...e === void 0 ? void 0 : { height: e } };
  }
  createDOM(e) {
    const n = document.createElement("tr");
    return this.__height && (n.style.height = `${this.__height}px`), un(n, e.theme.tableRow), n;
  }
  extractWithChild(e, n, r) {
    return r === "html";
  }
  isShadowRoot() {
    return !0;
  }
  setHeight(e) {
    const n = this.getWritable();
    return n.__height = e, n;
  }
  getHeight() {
    return this.getLatest().__height;
  }
  updateDOM(e) {
    return e.__height !== this.__height;
  }
  canBeEmpty() {
    return !1;
  }
  canIndent() {
    return !1;
  }
}
function zN(t) {
  const e = t;
  let n;
  return zp.test(e.style.height) && (n = parseFloat(e.style.height)), { after: (r) => hv(r, Gn), node: Ov(n) };
}
function Ov(t) {
  return lt(new nd(t));
}
function Ul(t) {
  return t instanceof nd;
}
const Iv = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, VN = Iv && "documentMode" in document ? document.documentMode : null;
Iv && "InputEvent" in window && !VN && new window.InputEvent("input");
function HN(t, e, n) {
  const [r, i, o] = Rv(t, e, n);
  return i === null && Pt(207), o === null && Pt(208), [r, i, o];
}
function Rv(t, e, n) {
  const r = [];
  let i = null, o = null;
  function s(l) {
    let c = r[l];
    return c === void 0 && (r[l] = c = []), c;
  }
  const a = t.getChildren();
  for (let l = 0; l < a.length; l++) {
    const c = a[l];
    Ul(c) || Pt(209);
    const u = s(l);
    for (let f = c.getFirstChild(), d = 0; f != null; f = f.getNextSibling()) {
      for (Gn(f) || Pt(147); u[d] !== void 0; ) d++;
      const h = { cell: f, startColumn: d, startRow: l }, { __rowSpan: g, __colSpan: w } = f;
      for (let b = 0; b < g && !(l + b >= a.length); b++) {
        const _ = s(l + b);
        for (let y = 0; y < w; y++) _[d + y] = h;
      }
      e !== null && i === null && e.is(f) && (i = h), n !== null && o === null && n.is(f) && (o = h);
    }
  }
  return [r, i, o];
}
function KN(t) {
  let e;
  if (t instanceof Vp) e = t;
  else if ("__type" in t) {
    const i = xr(t, Gn);
    Gn(i) || Pt(148), e = i;
  } else {
    const i = xr(t.getNode(), Gn);
    Gn(i) || Pt(148), e = i;
  }
  const n = e.getParent();
  Ul(n) || Pt(149);
  const r = n.getParent();
  return qv(r) || Pt(210), [e, n, r];
}
function WN(t, e, n) {
  let r, i = Math.min(e.startColumn, n.startColumn), o = Math.min(e.startRow, n.startRow), s = Math.max(e.startColumn + e.cell.__colSpan - 1, n.startColumn + n.cell.__colSpan - 1), a = Math.max(e.startRow + e.cell.__rowSpan - 1, n.startRow + n.cell.__rowSpan - 1);
  do {
    r = !1;
    for (let l = 0; l < t.length; l++) for (let c = 0; c < t[0].length; c++) {
      const u = t[l][c];
      if (!u) continue;
      const f = u.startColumn + u.cell.__colSpan - 1, d = u.startRow + u.cell.__rowSpan - 1, h = u.startColumn <= s && f >= i, g = u.startRow <= a && d >= o;
      if (h && g) {
        const w = Math.min(i, u.startColumn), b = Math.max(s, f), _ = Math.min(o, u.startRow), y = Math.max(a, d);
        w === i && b === s && _ === o && y === a || (i = w, s = b, o = _, a = y, r = !0);
      }
    }
  } while (r);
  return { maxColumn: s, maxRow: a, minColumn: i, minRow: o };
}
function Tm(t) {
  const [e, , n] = KN(t), r = n.getChildren(), i = r.length, o = r[0].getChildren().length, s = new Array(i);
  for (let a = 0; a < i; a++) s[a] = new Array(o);
  for (let a = 0; a < i; a++) {
    const l = r[a].getChildren();
    let c = 0;
    for (let u = 0; u < l.length; u++) {
      for (; s[a][c]; ) c++;
      const f = l[u], d = f.__rowSpan || 1, h = f.__colSpan || 1;
      for (let g = 0; g < d; g++) for (let w = 0; w < h; w++) s[a + g][c + w] = f;
      if (e === f) return { colSpan: h, columnIndex: c, rowIndex: a, rowSpan: d };
      c += h;
    }
  }
  return null;
}
function Am(t) {
  const [[e, n, r, i], [o, s, a, l]] = ["anchor", "focus"].map((c) => {
    const u = t[c].getNode(), f = xr(u, Gn);
    Gn(f) || Pt(238, c, u.getKey(), u.getType());
    const d = f.getParent();
    Ul(d) || Pt(239, c);
    const h = d.getParent();
    return qv(h) || Pt(240, c), [u, f, d, h];
  });
  return i.is(l) || Pt(241), { anchorCell: n, anchorNode: e, anchorRow: r, anchorTable: i, focusCell: s, focusNode: o, focusRow: a, focusTable: l };
}
let GN = class Pv {
  constructor(e, n, r) {
    this.anchor = n, this.focus = r, n._selection = this, r._selection = this, this._cachedNodes = null, this.dirty = !1, this.tableKey = e;
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
  isValid() {
    return this.tableKey !== "root" && this.anchor.key !== "root" && this.anchor.type === "element" && this.focus.key !== "root" && this.focus.type === "element";
  }
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(e) {
    this._cachedNodes = e;
  }
  is(e) {
    return Lv(e) && this.tableKey === e.tableKey && this.anchor.is(e.anchor) && this.focus.is(e.focus);
  }
  set(e, n, r) {
    this.dirty = this.dirty || e !== this.tableKey || n !== this.anchor.key || r !== this.focus.key, this.tableKey = e, this.anchor.key = n, this.focus.key = r, this._cachedNodes = null;
  }
  clone() {
    return new Pv(this.tableKey, On(this.anchor.key, this.anchor.offset, this.anchor.type), On(this.focus.key, this.focus.offset, this.focus.type));
  }
  isCollapsed() {
    return !1;
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(e) {
  }
  insertText() {
  }
  hasFormat(e) {
    let n = 0;
    this.getNodes().filter(Gn).forEach((i) => {
      const o = i.getFirstChild();
      Tp(o) && (n |= o.getTextFormat());
    });
    const r = Ui[e];
    return !!(n & r);
  }
  insertNodes(e) {
    const n = this.focus.getNode();
    X(n) || Pt(151), ll(n.select(0, n.getChildrenSize())).insertNodes(e);
  }
  getShape() {
    const { anchorCell: e, focusCell: n } = Am(this), r = Tm(e);
    r === null && Pt(153);
    const i = Tm(n);
    i === null && Pt(155);
    const o = Math.min(r.columnIndex, i.columnIndex), s = Math.max(r.columnIndex + r.colSpan - 1, i.columnIndex + i.colSpan - 1), a = Math.min(r.rowIndex, i.rowIndex), l = Math.max(r.rowIndex + r.rowSpan - 1, i.rowIndex + i.rowSpan - 1);
    return { fromX: Math.min(o, s), fromY: Math.min(a, l), toX: Math.max(o, s), toY: Math.max(a, l) };
  }
  getNodes() {
    if (!this.isValid()) return [];
    const e = this._cachedNodes;
    if (e !== null) return e;
    const { anchorTable: n, anchorCell: r, focusCell: i } = Am(this), o = i.getParents()[1];
    if (o !== n) {
      if (n.isParentOf(i)) {
        const b = o.getParent();
        b == null && Pt(159), this.set(this.tableKey, i.getKey(), b.getKey());
      } else {
        const b = n.getParent();
        b == null && Pt(158), this.set(this.tableKey, b.getKey(), i.getKey());
      }
      return this.getNodes();
    }
    const [s, a, l] = HN(n, r, i), { minColumn: c, maxColumn: u, minRow: f, maxRow: d } = WN(s, a, l), h = /* @__PURE__ */ new Map([[n.getKey(), n]]);
    let g = null;
    for (let b = f; b <= d; b++) for (let _ = c; _ <= u; _++) {
      const { cell: y } = s[b][_], C = y.getParent();
      Ul(C) || Pt(160), C !== g && (h.set(C.getKey(), C), g = C), h.has(y.getKey()) || JN(y, (D) => {
        h.set(D.getKey(), D);
      });
    }
    const w = Array.from(h.values());
    return ha() || (this._cachedNodes = w), w;
  }
  getTextContent() {
    const e = this.getNodes().filter((r) => Gn(r));
    let n = "";
    for (let r = 0; r < e.length; r++) {
      const i = e[r], o = i.__parent, s = (e[r + 1] || {}).__parent;
      n += i.getTextContent() + (s !== o ? `
` : "	");
    }
    return n;
  }
};
function Lv(t) {
  return t instanceof GN;
}
function JN(t, e) {
  const n = [[t]];
  for (let r = n.at(-1); r !== void 0 && n.length > 0; r = n.at(-1)) {
    const i = r.pop();
    i === void 0 ? n.pop() : e(i) !== !1 && X(i) && n.push(i.getChildren());
  }
}
function Pa(t) {
  return it(t) && t.nodeName === "TABLE";
}
function XN(t, e) {
  for (let n = e, r = null; n !== null; n = n.getParent()) {
    if (t.is(n)) return r;
    Gn(n) && (r = n);
  }
  return null;
}
function YN(t, e, n) {
  return XN(t, Vi(e, n));
}
function Dm(t, e, n) {
  if (!e.theme.tableAlignment) return;
  const r = [], i = [];
  for (const o of ["center", "right"]) {
    const s = e.theme.tableAlignment[o];
    s && (o === n ? i : r).push(s);
  }
  To(t, ...r), un(t, ...i);
}
const QN = /* @__PURE__ */ new WeakSet();
function Mm(t = Zu()) {
  return QN.has(t);
}
let $v = class Fv extends pn {
  static getType() {
    return "table";
  }
  getColWidths() {
    return this.getLatest().__colWidths;
  }
  setColWidths(e) {
    const n = this.getWritable();
    return n.__colWidths = e, n;
  }
  static clone(e) {
    return new Fv(e.__key);
  }
  afterCloneFrom(e) {
    super.afterCloneFrom(e), this.__colWidths = e.__colWidths, this.__rowStriping = e.__rowStriping, this.__frozenColumnCount = e.__frozenColumnCount, this.__frozenRowCount = e.__frozenRowCount;
  }
  static importDOM() {
    return { table: (e) => ({ conversion: ZN, priority: 1 }) };
  }
  static importJSON(e) {
    return Bv().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setRowStriping(e.rowStriping || !1).setFrozenColumns(e.frozenColumnCount || 0).setFrozenRows(e.frozenRowCount || 0).setColWidths(e.colWidths);
  }
  constructor(e) {
    super(e), this.__rowStriping = !1, this.__frozenColumnCount = 0, this.__frozenRowCount = 0;
  }
  exportJSON() {
    return { ...super.exportJSON(), colWidths: this.getColWidths(), frozenColumnCount: this.__frozenColumnCount ? this.__frozenColumnCount : void 0, frozenRowCount: this.__frozenRowCount ? this.__frozenRowCount : void 0, rowStriping: this.__rowStriping ? this.__rowStriping : void 0 };
  }
  extractWithChild(e, n, r) {
    return r === "html";
  }
  getDOMSlot(e) {
    const n = Pa(e) ? e : e.querySelector("table");
    return Pa(n) || Pt(229), super.getDOMSlot(e).withElement(n).withAfter(n.querySelector("colgroup"));
  }
  createDOM(e, n) {
    const r = document.createElement("table");
    this.__style && (r.style.cssText = this.__style);
    const i = document.createElement("colgroup");
    if (r.appendChild(i), cE(i), un(r, e.theme.table), this.updateTableElement(null, r, e), Mm(n)) {
      const o = document.createElement("div"), s = e.theme.tableScrollableWrapper;
      return s ? un(o, s) : o.style.cssText = "overflow-x: auto;", o.appendChild(r), this.updateTableWrapper(null, o, r, e), o;
    }
    return r;
  }
  updateTableWrapper(e, n, r, i) {
    this.__frozenColumnCount !== (e ? e.__frozenColumnCount : 0) && function(o, s, a, l) {
      l > 0 ? (un(o, a.theme.tableFrozenColumn), s.setAttribute("data-lexical-frozen-column", "true")) : (To(o, a.theme.tableFrozenColumn), s.removeAttribute("data-lexical-frozen-column"));
    }(n, r, i, this.__frozenColumnCount), this.__frozenRowCount !== (e ? e.__frozenRowCount : 0) && function(o, s, a, l) {
      l > 0 ? (un(o, a.theme.tableFrozenRow), s.setAttribute("data-lexical-frozen-row", "true")) : (To(o, a.theme.tableFrozenRow), s.removeAttribute("data-lexical-frozen-row"));
    }(n, r, i, this.__frozenRowCount);
  }
  updateTableElement(e, n, r) {
    this.__style !== (e ? e.__style : "") && (n.style.cssText = this.__style), this.__rowStriping !== (!!e && e.__rowStriping) && function(i, o, s) {
      s ? (un(i, o.theme.tableRowStriping), i.setAttribute("data-lexical-row-striping", "true")) : (To(i, o.theme.tableRowStriping), i.removeAttribute("data-lexical-row-striping"));
    }(n, r, this.__rowStriping), function(i, o, s, a) {
      const l = i.querySelector("colgroup");
      if (!l) return;
      const c = [];
      for (let u = 0; u < s; u++) {
        const f = document.createElement("col"), d = a && a[u];
        d && (f.style.width = `${d}px`), c.push(f);
      }
      l.replaceChildren(...c);
    }(n, 0, this.getColumnCount(), this.getColWidths()), Dm(n, r, this.getFormatType());
  }
  updateDOM(e, n, r) {
    const i = this.getDOMSlot(n).element;
    return n === i === Mm() || (it(o = n) && o.nodeName === "DIV" && this.updateTableWrapper(e, n, i, r), this.updateTableElement(e, i, r), !1);
    var o;
  }
  exportDOM(e) {
    const n = super.exportDOM(e), { element: r } = n;
    return { after: (i) => {
      if (n.after && (i = n.after(i)), !Pa(i) && it(i) && (i = i.querySelector("table")), !Pa(i)) return null;
      Dm(i, e._config, this.getFormatType());
      const [o] = Rv(this, null, null), s = /* @__PURE__ */ new Map();
      for (const u of o) for (const f of u) {
        const d = f.cell.getKey();
        s.has(d) || s.set(d, { colSpan: f.cell.getColSpan(), startColumn: f.startColumn });
      }
      const a = /* @__PURE__ */ new Set();
      for (const u of i.querySelectorAll(":scope > tr > [data-temporary-table-cell-lexical-key]")) {
        const f = u.getAttribute("data-temporary-table-cell-lexical-key");
        if (f) {
          const d = s.get(f);
          if (u.removeAttribute("data-temporary-table-cell-lexical-key"), d) {
            s.delete(f);
            for (let h = 0; h < d.colSpan; h++) a.add(h + d.startColumn);
          }
        }
      }
      const l = i.querySelector(":scope > colgroup");
      if (l) {
        const u = Array.from(i.querySelectorAll(":scope > colgroup > col")).filter((f, d) => a.has(d));
        l.replaceChildren(...u);
      }
      const c = i.querySelectorAll(":scope > tr");
      if (c.length > 0) {
        const u = document.createElement("tbody");
        for (const f of c) u.appendChild(f);
        i.append(u);
      }
      return i;
    }, element: !Pa(r) && it(r) ? r.querySelector("table") : r };
  }
  canBeEmpty() {
    return !1;
  }
  isShadowRoot() {
    return !0;
  }
  getCordsFromCellNode(e, n) {
    const { rows: r, domRows: i } = n;
    for (let o = 0; o < r; o++) {
      const s = i[o];
      if (s != null) for (let a = 0; a < s.length; a++) {
        const l = s[a];
        if (l == null) continue;
        const { elem: c } = l, u = YN(this, c);
        if (u !== null && e.is(u)) return { x: a, y: o };
      }
    }
    throw new Error("Cell not found in table.");
  }
  getDOMCellFromCords(e, n, r) {
    const { domRows: i } = r, o = i[n];
    if (o == null) return null;
    const s = o[e < o.length ? e : o.length - 1];
    return s ?? null;
  }
  getDOMCellFromCordsOrThrow(e, n, r) {
    const i = this.getDOMCellFromCords(e, n, r);
    if (!i) throw new Error("Cell not found at cords.");
    return i;
  }
  getCellNodeFromCords(e, n, r) {
    const i = this.getDOMCellFromCords(e, n, r);
    if (i == null) return null;
    const o = Vi(i.elem);
    return Gn(o) ? o : null;
  }
  getCellNodeFromCordsOrThrow(e, n, r) {
    const i = this.getCellNodeFromCords(e, n, r);
    if (!i) throw new Error("Node at cords not TableCellNode.");
    return i;
  }
  getRowStriping() {
    return !!this.getLatest().__rowStriping;
  }
  setRowStriping(e) {
    const n = this.getWritable();
    return n.__rowStriping = e, n;
  }
  setFrozenColumns(e) {
    const n = this.getWritable();
    return n.__frozenColumnCount = e, n;
  }
  getFrozenColumns() {
    return this.getLatest().__frozenColumnCount;
  }
  setFrozenRows(e) {
    const n = this.getWritable();
    return n.__frozenRowCount = e, n;
  }
  getFrozenRows() {
    return this.getLatest().__frozenRowCount;
  }
  canSelectBefore() {
    return !0;
  }
  canIndent() {
    return !1;
  }
  getColumnCount() {
    const e = this.getFirstChild();
    if (!e) return 0;
    let n = 0;
    return e.getChildren().forEach((r) => {
      Gn(r) && (n += r.getColSpan());
    }), n;
  }
};
function ZN(t) {
  const e = Bv();
  t.hasAttribute("data-lexical-row-striping") && e.setRowStriping(!0), t.hasAttribute("data-lexical-frozen-column") && e.setFrozenColumns(1), t.hasAttribute("data-lexical-frozen-row") && e.setFrozenRows(1);
  const n = t.querySelector(":scope > colgroup");
  if (n) {
    let r = [];
    for (const i of n.querySelectorAll(":scope > col")) {
      let o = i.style.width || "";
      if (!zp.test(o) && (o = i.getAttribute("width") || "", !/^\d+$/.test(o))) {
        r = void 0;
        break;
      }
      r.push(parseFloat(o));
    }
    r && e.setColWidths(r);
  }
  return { after: (r) => hv(r, Ul), node: e };
}
function Bv() {
  return lt(new $v());
}
function qv(t) {
  return t instanceof $v;
}
const jv = Object.freeze({ "	": "\\t", "\n": "\\n" }), Om = new RegExp(Object.keys(jv).join("|"), "g"), jr = Object.freeze({ ancestorHasNextSibling: "|", ancestorIsLastChild: " ", hasNextSibling: "â”œ", isLastChild: "â””", selectedChar: "^", selectedLine: ">" }), eS = [(t) => t.hasFormat("bold") && "Bold", (t) => t.hasFormat("code") && "Code", (t) => t.hasFormat("italic") && "Italic", (t) => t.hasFormat("strikethrough") && "Strikethrough", (t) => t.hasFormat("subscript") && "Subscript", (t) => t.hasFormat("superscript") && "Superscript", (t) => t.hasFormat("underline") && "Underline", (t) => t.hasFormat("highlight") && "Highlight"], tS = [(t) => t.hasTextFormat("bold") && "Bold", (t) => t.hasTextFormat("code") && "Code", (t) => t.hasTextFormat("italic") && "Italic", (t) => t.hasTextFormat("strikethrough") && "Strikethrough", (t) => t.hasTextFormat("subscript") && "Subscript", (t) => t.hasTextFormat("superscript") && "Superscript", (t) => t.hasTextFormat("underline") && "Underline", (t) => t.hasTextFormat("highlight") && "Highlight"], nS = [(t) => t.isDirectionless() && "Directionless", (t) => t.isUnmergeable() && "Unmergeable"], rS = [(t) => t.isToken() && "Token", (t) => t.isSegmented() && "Segmented"];
function iS(t, e, n, r, i = !1) {
  const o = t.getEditorState(), s = t._config, a = t._compositionKey, l = t._editable;
  if (n) {
    let d = "";
    return o.read(() => {
      d = function(h) {
        const g = document.createElement("div");
        return g.innerHTML = h.trim(), zv(g, 0).innerHTML;
      }(yv(t));
    }), d;
  }
  let c = ` root
`;
  const u = o.read(() => {
    const d = oe();
    return Uv(Ve(), (h, g) => {
      const w = `(${h.getKey()})`, b = h.getType() || "", _ = h.isSelected();
      c += `${_ ? jr.selectedLine : " "} ${g.join(" ")} ${w} ${b} ${function(y, C, D = !1) {
        const P = C ? C(y, D) : void 0;
        if (P !== void 0 && P.length > 0) return P;
        if (ie(y)) {
          const S = y.getTextContent(), L = S.length === 0 ? "(empty)" : `"${Im(S, D)}"`, O = function(M) {
            return [Rm(M), oS(M), sS(M), Pm(M)].filter(Boolean).join(", ");
          }(y);
          return [L, O.length !== 0 ? `{ ${O} }` : null].filter(Boolean).join(" ").trim();
        }
        if (RN(y)) {
          const S = y.getURL(), L = S.length === 0 ? "(empty)" : `"${Im(S, D)}"`, O = function(M) {
            return [aS(M), lS(M), cS(M), Pm(M)].filter(Boolean).join(", ");
          }(y);
          return [L, O.length !== 0 ? `{ ${O} }` : null].filter(Boolean).join(" ").trim();
        }
        if (LN(y)) return `ids: [ ${y.getIDs().join(", ")} ]`;
        if (Tp(y)) {
          const S = function(O) {
            let M = tS.map((F) => F(O)).filter(Boolean).join(", ").toLocaleLowerCase();
            return M !== "" && (M = "format: " + M), M;
          }(y);
          let L = S !== "" ? `{ ${S} }` : "";
          return L += y.__style ? `(${y.__style})` : "", L;
        }
        return "";
      }(h, r, i)}
`, c += function({ indent: y, isSelected: C, node: D, nodeKeyDisplay: P, selection: S, typeDisplay: L }) {
        if (!ie(D) || !Z(S) || !C || X(D)) return "";
        const O = S.anchor, M = S.focus;
        if (D.getTextContent() === "" || O.getNode() === S.focus.getNode() && O.offset === M.offset) return "";
        const [F, k] = function(V, J) {
          const H = J.getStartEndPoints();
          if (bn(J) || H === null) return [-1, -1];
          const [W, ne] = H, re = V.getTextContent(), te = re.length;
          let Q = -1, ce = -1;
          if (W.type === "text" && ne.type === "text") {
            const ve = W.getNode(), _e = ne.getNode();
            ve === _e && V === ve && W.offset !== ne.offset ? [Q, ce] = W.offset < ne.offset ? [W.offset, ne.offset] : [ne.offset, W.offset] : [Q, ce] = V === ve ? ve.isBefore(_e) ? [W.offset, te] : [0, W.offset] : V === _e ? _e.isBefore(ve) ? [ne.offset, te] : [0, ne.offset] : [0, te];
          }
          const pe = (re.slice(0, Q).match(Om) || []).length, we = (re.slice(Q, ce).match(Om) || []).length;
          return [Q + pe, ce + pe + we];
        }(D, S);
        if (F === k) return "";
        const I = y[y.length - 1] === jr.hasNextSibling ? jr.ancestorHasNextSibling : jr.ancestorIsLastChild, N = [...y.slice(0, y.length - 1), I], R = Array(F + 1).fill(" "), T = Array(k - F).fill(jr.selectedChar), A = L.length + 2, q = Array(P.length + A).fill(" ");
        return [jr.selectedLine, N.join(" "), [...q, ...R, ...T].join("")].join(" ") + `
`;
      }({ indent: g, isSelected: _, node: h, nodeKeyDisplay: w, selection: d, typeDisplay: b });
    }), d === null ? ": null" : Z(d) ? function(h) {
      let g = "";
      const w = Rm(h);
      g += `: range ${w !== "" ? `{ ${w} }` : ""} ${h.style !== "" ? `{ style: ${h.style} } ` : ""}`;
      const b = h.anchor, _ = h.focus, y = b.offset, C = _.offset;
      return g += `
  â”œ anchor { key: ${b.key}, offset: ${y === null ? "null" : y}, type: ${b.type} }`, g += `
  â”” focus { key: ${_.key}, offset: ${C === null ? "null" : C}, type: ${_.type} }`, g;
    }(d) : Lv(d) ? function(h) {
      return `: table
  â”” { table: ${h.tableKey}, anchorCell: ${h.anchor.key}, focusCell: ${h.focus.key} }`;
    }(d) : function(h) {
      return bn(h) ? `: node
  â”” [${Array.from(h._nodes).join(", ")}]` : "";
    }(d);
  });
  if (c += `
 selection` + u, c += `

 commands:`, e.length) for (const { index: d, type: h, payload: g } of e) c += `
  â”” ${d}. { type: ${h}, payload: ${g instanceof Event ? g.constructor.name : g} }`;
  else c += `
  â”” None dispatched.`;
  const { version: f } = t.constructor;
  return c += `

 editor${f ? ` (v${f})` : ""}:`, c += `
  â”” namespace ${s.namespace}`, a !== null && (c += `
  â”” compositionKey ${a}`), c += `
  â”” editable ${String(l)}`, c;
}
function Uv(t, e, n = []) {
  const r = t.getChildren(), i = r.length;
  r.forEach((o, s) => {
    e(o, n.concat(s === i - 1 ? jr.isLastChild : jr.hasNextSibling)), X(o) && Uv(o, e, n.concat(s === i - 1 ? jr.ancestorIsLastChild : jr.ancestorHasNextSibling));
  });
}
function Im(t, e = !1) {
  const n = Object.entries(jv).reduce((r, [i, o]) => r.replace(new RegExp(i, "g"), String(o)), t);
  return e ? n.replace(/[^\s]/g, "*") : n;
}
function oS(t) {
  let e = nS.map((n) => n(t)).filter(Boolean).join(", ").toLocaleLowerCase();
  return e !== "" && (e = "detail: " + e), e;
}
function sS(t) {
  let e = rS.map((n) => n(t)).filter(Boolean).join(", ").toLocaleLowerCase();
  return e !== "" && (e = "mode: " + e), e;
}
function Rm(t) {
  let e = eS.map((n) => n(t)).filter(Boolean).join(", ").toLocaleLowerCase();
  return e !== "" && (e = "format: " + e), e;
}
function aS(t) {
  let e = t.getTarget();
  return e != null && (e = "target: " + e), e;
}
function lS(t) {
  let e = t.getRel();
  return e != null && (e = "rel: " + e), e;
}
function cS(t) {
  let e = t.getTitle();
  return e != null && (e = "title: " + e), e;
}
function Pm(t) {
  if (!t.__state) return !1;
  const e = [];
  for (const [r, i] of t.__state.knownState.entries()) {
    if (r.isEqual(i, r.defaultValue)) continue;
    const o = JSON.stringify(r.unparse(i));
    e.push(`[${r.key}: ${o}]`);
  }
  let n = e.join(",");
  return n !== "" && (n = "state: " + n), n;
}
function zv(t, e) {
  const n = new Array(1 + e++).join("  "), r = new Array(e - 1).join("  ");
  let i;
  for (let o = 0; o < t.children.length; o++) i = document.createTextNode(`
` + n), t.insertBefore(i, t.children[o]), zv(t.children[o], e), t.lastElementChild === t.children[o] && (i = document.createTextNode(`
` + r), t.appendChild(i));
  return t;
}
const uS = Yn(function({ treeTypeButtonClassName: t, timeTravelButtonClassName: e, timeTravelPanelSliderClassName: n, timeTravelPanelButtonClassName: r, viewClassName: i, timeTravelPanelClassName: o, editorState: s, setEditorState: a, setEditorReadOnly: l, generateContent: c, commandsLog: u = [] }, f) {
  const [d, h] = ue([]), [g, w] = ue(""), [b, _] = ue(!1), [y, C] = ue(!1), D = ye(0), P = ye(null), [S, L] = ue(!1), [O, M] = ue(!1), [F, k] = ue(!1), I = ye(), N = ye([]), R = ye(0), T = be((q) => {
    const V = ++R.current;
    c(q).then((J) => {
      V === R.current && w(J);
    }).catch((J) => {
      V === R.current && w(`Error rendering tree: ${J.message}

Stack:
${J.stack}`);
    });
  }, [c]);
  de(() => {
    if (!(!F && s._nodeMap.size > 1e3 && (M(!0), !F)) && (I.current !== s || N.current !== u)) {
      const q = I.current !== s;
      I.current = s, N.current = u, T(y), !b && q && h((V) => [...V, [Date.now(), s]]);
    }
  }, [s, T, y, F, b, u]);
  const A = d.length;
  return de(() => {
    if (S) {
      let q;
      const V = () => {
        const J = D.current;
        if (J === A - 1) return void L(!1);
        const H = d[J][0], W = d[J + 1][0];
        q = setTimeout(() => {
          D.current++;
          const ne = D.current, re = P.current;
          re !== null && (re.value = String(ne)), a(d[ne][1]), V();
        }, W - H);
      };
      return V(), () => {
        clearTimeout(q);
      };
    }
  }, [d, S, A, a]), B("div", { className: i, children: [!F && O ? B("div", { style: { padding: 20 }, children: [p("span", { style: { marginRight: 20 }, children: "Detected large EditorState, this can impact debugging performance." }), p("button", { onClick: () => {
    k(!0);
  }, style: { background: "transparent", border: "1px solid white", color: "white", cursor: "pointer", padding: 5 }, children: "Show full tree" })] }) : null, F ? null : p("button", { onClick: () => (T(!y), void C(!y)), className: t, type: "button", children: y ? "Tree" : "Export DOM" }), !b && (F || !O) && A > 2 && p("button", { onClick: () => {
    l(!0), D.current = A - 1, _(!0);
  }, className: e, type: "button", children: "Time Travel" }), (F || !O) && p("pre", { ref: f, children: g }), b && (F || !O) && B("div", { className: o, children: [p("button", { className: r, onClick: () => {
    D.current === A - 1 && (D.current = 1), L(!S);
  }, type: "button", children: S ? "Pause" : "Play" }), p("input", { className: n, ref: P, onChange: (q) => {
    const V = Number(q.target.value), J = d[V];
    J && (D.current = V, a(J[1]));
  }, type: "range", min: "1", max: A - 1 }), p("button", { className: r, onClick: () => {
    l(!1);
    const q = d.length - 1, V = d[q];
    a(V[1]);
    const J = P.current;
    J !== null && (J.value = String(q)), _(!1), L(!1);
  }, type: "button", children: "Exit" })] })] });
});
function dS(t, e) {
  const n = /* @__PURE__ */ new Set();
  let r = 0;
  for (const [i] of t._commands) n.add(t.registerCommand(i, (o) => (e((s) => {
    r += 1;
    const a = [...s];
    return a.push({ index: r, payload: o, type: i.type ? i.type : "UNKNOWN" }), a.length > 10 && a.shift(), a;
  }), !1), ks));
  return () => n.forEach((i) => i());
}
function fS(t) {
  const [e, n] = ue([]);
  return de(() => dS(t, n), [t]), Ne(() => e, [e]);
}
function hS({ treeTypeButtonClassName: t, timeTravelButtonClassName: e, timeTravelPanelSliderClassName: n, timeTravelPanelButtonClassName: r, timeTravelPanelClassName: i, viewClassName: o, editor: s, customPrintNode: a }) {
  const l = vs.createRef(), [c, u] = ue(s.getEditorState()), f = fS(s);
  return de(() => Ht(s.registerUpdateListener(({ editorState: d }) => {
    u(d);
  }), s.registerEditableListener(() => {
    u(s.getEditorState());
  })), [s]), de(() => {
    const d = l.current;
    if (d !== null) return d.__lexicalEditor = s, () => {
      d.__lexicalEditor = null;
    };
  }, [s, l]), p(uS, { treeTypeButtonClassName: t, timeTravelButtonClassName: e, timeTravelPanelSliderClassName: n, timeTravelPanelButtonClassName: r, viewClassName: o, timeTravelPanelClassName: i, setEditorReadOnly: (d) => {
    const h = s.getRootElement();
    h != null && (h.contentEditable = d ? "false" : "true");
  }, editorState: c, setEditorState: (d) => s.setEditorState(d), generateContent: async function(d) {
    return iS(s, f, d, a);
  }, ref: l, commandsLog: f });
}
const Vv = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, pS = Vv ? kn : de, yc = { tag: Eo };
function Hv({ initialConfig: t, children: e }) {
  const n = Ne(() => {
    const { theme: r, namespace: i, nodes: o, onError: s, editorState: a, html: l } = t, c = AN(null, r), u = Jk({ editable: t.editable, html: l, namespace: i, nodes: o, onError: (f) => s(f, u), theme: r });
    return function(f, d) {
      if (d !== null) {
        if (d === void 0) f.update(() => {
          const h = Ve();
          if (h.isEmpty()) {
            const g = Jn();
            h.append(g);
            const w = Vv ? document.activeElement : null;
            (oe() !== null || w !== null && w === f.getRootElement()) && g.select();
          }
        }, yc);
        else if (d !== null) switch (typeof d) {
          case "string": {
            const h = f.parseEditorState(d);
            f.setEditorState(h, yc);
            break;
          }
          case "object":
            f.setEditorState(d, yc);
            break;
          case "function":
            f.update(() => {
              Ve().isEmpty() && d(f);
            }, yc);
        }
      }
    }(u, a), [u, c];
  }, []);
  return pS(() => {
    const r = t.editable, [i] = n;
    i.setEditable(r === void 0 || r);
  }, []), p(bv.Provider, { value: n, children: e });
}
function Kv() {
  return Ve().getTextContent();
}
function Wv(t, e = !0) {
  if (t) return !1;
  let n = Kv();
  return e && (n = n.trim()), n === "";
}
function gS(t) {
  if (!Wv(t, !1)) return !1;
  const e = Ve().getChildren(), n = e.length;
  if (n > 1) return !1;
  for (let r = 0; r < n; r++) {
    const i = e[r];
    if (Xe(i)) return !1;
    if (X(i)) {
      if (!Tp(i) || i.__indent !== 0) return !1;
      const o = i.getChildren(), s = o.length;
      for (let a = 0; a < s; a++) {
        const l = o[r];
        if (!ie(l)) return !1;
      }
    }
  }
  return !0;
}
function Hp(t) {
  return () => gS(t);
}
const Gv = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? kn : de;
function wS({ editor: t, ariaActiveDescendant: e, ariaAutoComplete: n, ariaControls: r, ariaDescribedBy: i, ariaErrorMessage: o, ariaExpanded: s, ariaInvalid: a, ariaLabel: l, ariaLabelledBy: c, ariaMultiline: u, ariaOwns: f, ariaRequired: d, autoCapitalize: h, className: g, id: w, role: b = "textbox", spellCheck: _ = !0, style: y, tabIndex: C, "data-testid": D, ...P }, S) {
  const [L, O] = ue(t.isEditable()), M = be((k) => {
    k && k.ownerDocument && k.ownerDocument.defaultView ? t.setRootElement(k) : t.setRootElement(null);
  }, [t]), F = Ne(() => /* @__PURE__ */ function(...k) {
    return (I) => {
      k.forEach((N) => {
        typeof N == "function" ? N(I) : N != null && (N.current = I);
      });
    };
  }(S, M), [M, S]);
  return Gv(() => (O(t.isEditable()), t.registerEditableListener((k) => {
    O(k);
  })), [t]), p("div", { "aria-activedescendant": L ? e : void 0, "aria-autocomplete": L ? n : "none", "aria-controls": L ? r : void 0, "aria-describedby": i, ...o != null ? { "aria-errormessage": o } : {}, "aria-expanded": L && b === "combobox" ? !!s : void 0, ...a != null ? { "aria-invalid": a } : {}, "aria-label": l, "aria-labelledby": c, "aria-multiline": u, "aria-owns": L ? f : void 0, "aria-readonly": !L || void 0, "aria-required": d, autoCapitalize: h, className: g, contentEditable: L, "data-testid": D, id: w, ref: F, role: b, spellCheck: _, style: y, tabIndex: C, ...P });
}
const mS = Yn(wS);
function Lm(t) {
  return t.getEditorState().read(Hp(t.isComposing()));
}
const Jv = Yn(bS);
function bS(t, e) {
  const { placeholder: n, ...r } = t, [i] = Le();
  return B(Lt, { children: [p(mS, { editor: i, ...r, ref: e }), n != null && p(yS, { editor: i, content: n })] });
}
function yS({ content: t, editor: e }) {
  const n = function(s) {
    const [a, l] = ue(() => Lm(s));
    return Gv(() => {
      function c() {
        const u = Lm(s);
        l(u);
      }
      return c(), Ht(s.registerUpdateListener(() => {
        c();
      }), s.registerEditableListener(() => {
        c();
      }));
    }, [s]), a;
  }(e), [r, i] = ue(e.isEditable());
  if (kn(() => (i(e.isEditable()), e.registerEditableListener((s) => {
    i(s);
  })), [e]), !n) return null;
  let o = null;
  return typeof t == "function" ? o = t(r) : t !== null && (o = t), o === null ? null : p("div", { "aria-hidden": !0, children: o });
}
function Xv({ editorRef: t }) {
  const [e] = Le();
  return vs.useEffect(() => {
    typeof t == "function" ? t(e) : typeof t == "object" && (t.current = e);
  }, [e]), null;
}
function dh(t, e) {
  return dh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, dh(t, e);
}
var $m = { error: null }, vS = function(t) {
  var e, n;
  function r() {
    for (var o, s = arguments.length, a = new Array(s), l = 0; l < s; l++) a[l] = arguments[l];
    return (o = t.call.apply(t, [this].concat(a)) || this).state = $m, o.resetErrorBoundary = function() {
      for (var c, u = arguments.length, f = new Array(u), d = 0; d < u; d++) f[d] = arguments[d];
      o.props.onReset == null || (c = o.props).onReset.apply(c, f), o.reset();
    }, o;
  }
  n = t, (e = r).prototype = Object.create(n.prototype), e.prototype.constructor = e, dh(e, n), r.getDerivedStateFromError = function(o) {
    return { error: o };
  };
  var i = r.prototype;
  return i.reset = function() {
    this.setState($m);
  }, i.componentDidCatch = function(o, s) {
    var a, l;
    (a = (l = this.props).onError) == null || a.call(l, o, s);
  }, i.componentDidUpdate = function(o, s) {
    var a, l, c, u, f = this.state.error, d = this.props.resetKeys;
    f !== null && s.error !== null && ((c = o.resetKeys) === void 0 && (c = []), (u = d) === void 0 && (u = []), c.length !== u.length || c.some(function(h, g) {
      return !Object.is(h, u[g]);
    })) && ((a = (l = this.props).onResetKeysChange) == null || a.call(l, o.resetKeys, d), this.reset());
  }, i.render = function() {
    var o = this.state.error, s = this.props, a = s.fallbackRender, l = s.FallbackComponent, c = s.fallback;
    if (o !== null) {
      var u = { error: o, resetErrorBoundary: this.resetErrorBoundary };
      if (vs.isValidElement(c)) return c;
      if (typeof a == "function") return a(u);
      if (l) return vs.createElement(l, u);
      throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
    }
    return this.props.children;
  }, r;
}(vs.Component);
function Yv({ children: t, onError: e }) {
  return p(vS, { fallback: p("div", { style: { border: "1px solid #f00", color: "#f00", padding: "8px" }, children: "An error was thrown." }), onError: e, children: t });
}
const vc = 0, fh = 1, hh = 2, pr = 0, _S = 1, Fm = 2, xS = 3, CS = 4;
function kS(t, e, n, r, i) {
  if (t === null || n.size === 0 && r.size === 0 && !i) return pr;
  const o = e._selection, s = t._selection;
  if (i) return _S;
  if (!(Z(o) && Z(s) && s.isCollapsed() && o.isCollapsed())) return pr;
  const a = function(_, y, C) {
    const D = _._nodeMap, P = [];
    for (const S of y) {
      const L = D.get(S);
      L !== void 0 && P.push(L);
    }
    for (const [S, L] of C) {
      if (!L) continue;
      const O = D.get(S);
      O === void 0 || tn(O) || P.push(O);
    }
    return P;
  }(e, n, r);
  if (a.length === 0) return pr;
  if (a.length > 1) {
    const _ = e._nodeMap, y = _.get(o.anchor.key), C = _.get(s.anchor.key);
    return y && C && !t._nodeMap.has(y.__key) && ie(y) && y.__text.length === 1 && o.anchor.offset === 1 ? Fm : pr;
  }
  const l = a[0], c = t._nodeMap.get(l.__key);
  if (!ie(c) || !ie(l) || c.__mode !== l.__mode) return pr;
  const u = c.__text, f = l.__text;
  if (u === f) return pr;
  const d = o.anchor, h = s.anchor;
  if (d.key !== h.key || d.type !== "text") return pr;
  const g = d.offset, w = h.offset, b = f.length - u.length;
  return b === 1 && w === g - 1 ? Fm : b === -1 && w === g + 1 ? xS : b === -1 && w === g ? CS : pr;
}
function ES(t, e) {
  let n = Date.now(), r = pr;
  return (i, o, s, a, l, c) => {
    const u = Date.now();
    if (c.has(Qf)) return r = pr, n = u, hh;
    const f = kS(i, o, a, l, t.isComposing()), d = (() => {
      const h = s === null || s.editor === t, g = c.has(Vk);
      if (!g && h && c.has(Eo)) return vc;
      if (i === null) return fh;
      const w = o._selection;
      return a.size > 0 || l.size > 0 ? g === !1 && f !== pr && f === r && u < n + e && h || a.size === 1 && function(b, _, y) {
        const C = _._nodeMap.get(b), D = y._nodeMap.get(b), P = _._selection, S = y._selection;
        return !(Z(P) && Z(S) && P.anchor.type === "element" && P.focus.type === "element" && S.anchor.type === "text" && S.focus.type === "text" || !ie(C) || !ie(D) || C.__parent !== D.__parent) && JSON.stringify(_.read(() => C.exportJSON())) === JSON.stringify(y.read(() => D.exportJSON()));
      }(Array.from(a)[0], i, o) ? vc : fh : w !== null ? vc : hh;
    })();
    return n = u, r = f, d;
  };
}
function Bm(t) {
  t.undoStack = [], t.redoStack = [], t.current = null;
}
function NS(t, e, n) {
  const r = ES(t, n);
  return Ht(t.registerCommand(Ol, () => (function(o, s) {
    const a = s.redoStack, l = s.undoStack;
    if (l.length !== 0) {
      const c = s.current, u = l.pop();
      c !== null && (a.push(c), o.dispatchCommand(ja, !0)), l.length === 0 && o.dispatchCommand(Ua, !1), s.current = u || null, u && u.editor.setEditorState(u.editorState, { tag: Qf });
    }
  }(t, e), !0), ke), t.registerCommand(Il, () => (function(o, s) {
    const a = s.redoStack, l = s.undoStack;
    if (a.length !== 0) {
      const c = s.current;
      c !== null && (l.push(c), o.dispatchCommand(Ua, !0));
      const u = a.pop();
      a.length === 0 && o.dispatchCommand(ja, !1), s.current = u || null, u && u.editor.setEditorState(u.editorState, { tag: Qf });
    }
  }(t, e), !0), ke), t.registerCommand(_p, () => (Bm(e), !1), ke), t.registerCommand(p0, () => (Bm(e), t.dispatchCommand(ja, !1), t.dispatchCommand(Ua, !1), !0), ke), t.registerUpdateListener(({ editorState: o, prevEditorState: s, dirtyLeaves: a, dirtyElements: l, tags: c }) => {
    const u = e.current, f = e.redoStack, d = e.undoStack, h = u === null ? null : u.editorState;
    if (u !== null && o === h) return;
    const g = r(s, o, u, a, l, c);
    if (g === fh) f.length !== 0 && (e.redoStack = [], t.dispatchCommand(ja, !1)), u !== null && (d.push({ ...u }), t.dispatchCommand(Ua, !0));
    else if (g === hh) return;
    e.current = { editor: t, editorState: o };
  }));
}
function SS() {
  return { current: null, redoStack: [], undoStack: [] };
}
function Qv({ delay: t, externalHistoryState: e }) {
  const [n] = Le();
  return function(r, i, o = 1e3) {
    const s = Ne(() => i || SS(), [i]);
    de(() => NS(r, s, o), [o, r, s]);
  }(n, e, t), null;
}
const TS = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? kn : de;
function AS(t) {
  return { initialValueFn: () => t.isEditable(), subscribe: (e) => t.registerEditableListener(e) };
}
function Zv() {
  return function(t) {
    const [e] = Le(), n = Ne(() => t(e), [e, t]), [r, i] = ue(() => n.initialValueFn()), o = ye(r);
    return TS(() => {
      const { initialValueFn: s, subscribe: a } = n, l = s();
      return o.current !== l && (o.current = l, i(l)), a((c) => {
        o.current = c, i(c);
      });
    }, [n, t]), r;
  }(AS);
}
function e_(t) {
  const e = window.location.origin, n = (r) => {
    if (r.origin !== e) return;
    const i = t.getRootElement();
    if (document.activeElement !== i) return;
    const o = r.data;
    if (typeof o == "string") {
      let s;
      try {
        s = JSON.parse(o);
      } catch {
        return;
      }
      if (s && s.protocol === "nuanria_messaging" && s.type === "request") {
        const a = s.payload;
        if (a && a.functionId === "makeChanges") {
          const l = a.args;
          if (l) {
            const [c, u, f, d, h, g] = l;
            t.update(() => {
              const w = oe();
              if (Z(w)) {
                const b = w.anchor;
                let _ = b.getNode(), y = 0, C = 0;
                if (ie(_) && c >= 0 && u >= 0 && (y = c, C = c + u, w.setTextNodeRange(_, y, _, C)), y === C && f === "" || (w.insertRawText(f), _ = b.getNode()), ie(_)) {
                  y = d, C = d + h;
                  const D = _.getTextContentSize();
                  y = y > D ? D : y, C = C > D ? D : C, w.setTextNodeRange(_, y, _, C);
                }
                r.stopImmediatePropagation();
              }
            });
          }
        }
      }
    }
  };
  return window.addEventListener("message", n, !0), () => {
    window.removeEventListener("message", n, !0);
  };
}
function qm(t, e) {
  if (document.caretRangeFromPoint !== void 0) {
    const n = document.caretRangeFromPoint(t, e);
    return n === null ? null : { node: n.startContainer, offset: n.startOffset };
  }
  if (document.caretPositionFromPoint !== "undefined") {
    const n = document.caretPositionFromPoint(t, e);
    return n === null ? null : { node: n.offsetNode, offset: n.offset };
  }
  return null;
}
const ga = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, DS = ga && "documentMode" in document ? document.documentMode : null, MS = !(!ga || !("InputEvent" in window) || DS) && "getTargetRanges" in new window.InputEvent("input"), OS = ga && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), jm = ga && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, IS = ga && /^(?=.*Chrome).*/i.test(navigator.userAgent), RS = ga && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS, Um = Se("DRAG_DROP_PASTE_FILE");
function _c(t) {
  let e = null;
  if (gi(t, DragEvent) ? e = t.dataTransfer : gi(t, ClipboardEvent) && (e = t.clipboardData), e === null) return [!1, [], !1];
  const n = e.types, r = n.includes("Files"), i = n.includes("text/html") || n.includes("text/plain");
  return [r, Array.from(e.files), i];
}
function zm(t) {
  const e = oe();
  if (!Z(e)) return !1;
  const n = /* @__PURE__ */ new Set(), r = e.getNodes();
  for (let i = 0; i < r.length; i++) {
    const o = r[i], s = o.getKey();
    if (n.has(s)) continue;
    const a = xr(o, (c) => X(c) && !c.isInline());
    if (a === null) continue;
    const l = a.getKey();
    a.canIndent() && !n.has(l) && (n.add(l), t(a));
  }
  return n.size > 0;
}
function Vm(t) {
  const e = Vi(t);
  return Xe(e);
}
function of(t) {
  for (const e of ["lowercase", "uppercase", "capitalize"]) t.hasFormat(e) && t.toggleFormat(e);
}
function PS(t) {
  return Ht(t.registerCommand(d0, (e) => {
    const n = oe();
    return !!bn(n) && (n.clear(), !0);
  }, ke), t.registerCommand(Hr, (e) => {
    const n = oe();
    return Z(n) ? (n.deleteCharacter(e), !0) : !!bn(n) && (n.deleteNodes(), !0);
  }, ke), t.registerCommand(Fs, (e) => {
    const n = oe();
    return !!Z(n) && (n.deleteWord(e), !0);
  }, ke), t.registerCommand(Bs, (e) => {
    const n = oe();
    return !!Z(n) && (n.deleteLine(e), !0);
  }, ke), t.registerCommand(Co, (e) => {
    const n = oe();
    if (typeof e == "string") n !== null && n.insertText(e);
    else {
      if (n === null) return !1;
      const r = e.dataTransfer;
      if (r != null) Cm(r, n, t);
      else if (Z(n)) {
        const i = e.data;
        return i && n.insertText(i), !0;
      }
    }
    return !0;
  }, ke), t.registerCommand(Zc, () => {
    const e = oe();
    return !!Z(e) && (e.removeText(), !0);
  }, ke), t.registerCommand(Ri, (e) => {
    const n = oe();
    return !!Z(n) && (n.formatText(e), !0);
  }, ke), t.registerCommand(Ek, (e) => {
    const n = oe();
    if (!Z(n) && !bn(n)) return !1;
    const r = n.getNodes();
    for (const i of r) {
      const o = xr(i, (s) => X(s) && !s.isInline());
      o !== null && o.setFormat(e);
    }
    return !0;
  }, ke), t.registerCommand(Fi, (e) => {
    const n = oe();
    return !!Z(n) && (n.insertLineBreak(e), !0);
  }, ke), t.registerCommand(fl, () => {
    const e = oe();
    return !!Z(e) && (e.insertParagraph(), !0);
  }, ke), t.registerCommand(Ck, () => (qk([Ll()]), !0), ke), t.registerCommand(kk, () => zm((e) => {
    const n = e.getIndent();
    e.setIndent(n + 1);
  }), ke), t.registerCommand(bw, () => zm((e) => {
    const n = e.getIndent();
    n > 0 && e.setIndent(Math.max(0, n - 1));
  }), ke), t.registerCommand(gp, (e) => {
    const n = oe();
    if (bn(n)) {
      const r = n.getNodes();
      if (r.length > 0) return r[0].selectPrevious(), !0;
    } else if (Z(n)) {
      const r = eh(n.focus, !0);
      if (!e.shiftKey && Xe(r) && !r.isIsolated() && !r.isInline()) return r.selectPrevious(), e.preventDefault(), !0;
    }
    return !1;
  }, ke), t.registerCommand(wp, (e) => {
    const n = oe();
    if (bn(n)) {
      const r = n.getNodes();
      if (r.length > 0) return r[0].selectNext(0, 0), !0;
    } else if (Z(n)) {
      if (function(i) {
        const o = i.focus;
        return o.key === "root" && o.offset === Ve().getChildrenSize();
      }(n)) return e.preventDefault(), !0;
      const r = eh(n.focus, !1);
      if (!e.shiftKey && Xe(r) && !r.isIsolated() && !r.isInline()) return r.selectNext(), e.preventDefault(), !0;
    }
    return !1;
  }, ke), t.registerCommand(pp, (e) => {
    const n = oe();
    if (bn(n)) {
      const r = n.getNodes();
      if (r.length > 0) return e.preventDefault(), r[0].selectPrevious(), !0;
    }
    if (!Z(n)) return !1;
    if (cu(n, !0)) {
      const r = e.shiftKey;
      return e.preventDefault(), uu(n, r, !0), !0;
    }
    return !1;
  }, ke), t.registerCommand(hp, (e) => {
    const n = oe();
    if (bn(n)) {
      const i = n.getNodes();
      if (i.length > 0) return e.preventDefault(), i[0].selectNext(0, 0), !0;
    }
    if (!Z(n)) return !1;
    const r = e.shiftKey;
    return !!cu(n, !1) && (e.preventDefault(), uu(n, r, !1), !0);
  }, ke), t.registerCommand(mp, (e) => {
    if (Vm(e.target)) return !1;
    const n = oe();
    if (Z(n)) {
      if (function(r) {
        if (!r.isCollapsed()) return !1;
        const { anchor: i } = r;
        if (i.offset !== 0) return !1;
        const o = i.getNode();
        if (tn(o)) return !1;
        const s = qE(o);
        return s.getIndent() > 0 && (s.is(o) || o.is(s.getFirstDescendant()));
      }(n)) return e.preventDefault(), t.dispatchCommand(bw, void 0);
      if (jm && navigator.language === "ko-KR") return !1;
    } else if (!bn(n)) return !1;
    return e.preventDefault(), t.dispatchCommand(Hr, !0);
  }, ke), t.registerCommand(bp, (e) => {
    if (Vm(e.target)) return !1;
    const n = oe();
    return !(!Z(n) && !bn(n)) && (e.preventDefault(), t.dispatchCommand(Hr, !1));
  }, ke), t.registerCommand(qs, (e) => {
    const n = oe();
    if (!Z(n)) return !1;
    if (of(n), e !== null) {
      if ((jm || OS || RS) && MS) return !1;
      if (e.preventDefault(), e.shiftKey) return t.dispatchCommand(Fi, !1);
    }
    return t.dispatchCommand(fl, void 0);
  }, ke), t.registerCommand(Vu, () => {
    const e = oe();
    return !!Z(e) && (t.blur(), !0);
  }, ke), t.registerCommand(Hu, (e) => {
    const [, n] = _c(e);
    if (n.length > 0) {
      const i = qm(e.clientX, e.clientY);
      if (i !== null) {
        const { offset: o, node: s } = i, a = Vi(s);
        if (a !== null) {
          const l = $l();
          if (ie(a)) l.anchor.set(a.getKey(), o, "text"), l.focus.set(a.getKey(), o, "text");
          else {
            const u = a.getParentOrThrow().getKey(), f = a.getIndexWithinParent() + 1;
            l.anchor.set(u, f, "element"), l.focus.set(u, f, "element");
          }
          const c = ll(l);
          sn(c);
        }
        t.dispatchCommand(Um, n);
      }
      return e.preventDefault(), !0;
    }
    const r = oe();
    return !!Z(r);
  }, ke), t.registerCommand(vp, (e) => {
    const [n] = _c(e), r = oe();
    return !(n && !Z(r));
  }, ke), t.registerCommand(h0, (e) => {
    const [n] = _c(e), r = oe();
    if (n && !Z(r)) return !1;
    const i = qm(e.clientX, e.clientY);
    if (i !== null) {
      const o = Vi(i.node);
      Xe(o) && e.preventDefault();
    }
    return !0;
  }, ke), t.registerCommand(eu, () => (Y0(), !0), ke), t.registerCommand(Qi, (e) => (Em(t, gi(e, ClipboardEvent) ? e : null), !0), ke), t.registerCommand(ts, (e) => (async function(n, r) {
    await Em(r, gi(n, ClipboardEvent) ? n : null), r.update(() => {
      const i = oe();
      Z(i) ? i.removeText() : bn(i) && i.getNodes().forEach((o) => o.remove());
    });
  }(e, t), !0), ke), t.registerCommand(es, (e) => {
    const [, n, r] = _c(e);
    return n.length > 0 && !r ? (t.dispatchCommand(Um, n), !0) : is(e.target) && Mp(e.target) ? !1 : oe() !== null && (function(i, o) {
      i.preventDefault(), o.update(() => {
        const s = oe(), a = gi(i, InputEvent) || gi(i, KeyboardEvent) ? null : i.clipboardData;
        a != null && s !== null && Cm(a, s, o);
      }, { tag: j0 });
    }(e, t), !0);
  }, ke), t.registerCommand(f0, (e) => {
    const n = oe();
    return Z(n) && of(n), !1;
  }, ke), t.registerCommand(yp, (e) => {
    const n = oe();
    return Z(n) && of(n), !1;
  }, ke));
}
const ph = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? kn : de;
function Hm(t) {
  return t.getEditorState().read(Hp(t.isComposing()));
}
function LS({ contentEditable: t, placeholder: e = null, ErrorBoundary: n }) {
  const [r] = Le(), i = function(o, s) {
    const [a, l] = ue(() => o.getDecorators());
    return ph(() => o.registerDecoratorListener((c) => {
      ky(() => {
        l(c);
      });
    }), [o]), de(() => {
      l(o.getDecorators());
    }, [o]), Ne(() => {
      const c = [], u = Object.keys(a);
      for (let f = 0; f < u.length; f++) {
        const d = u[f], h = p(s, { onError: (w) => o._onError(w), children: p(wy, { fallback: null, children: a[d] }) }), g = o.getElementByKey(d);
        g !== null && c.push(fi(h, g, d));
      }
      return c;
    }, [s, a, o]);
  }(r, n);
  return function(o) {
    ph(() => Ht(PS(o), e_(o)), [o]);
  }(r), B(Lt, { children: [t, p($S, { content: e }), i] });
}
function $S({ content: t }) {
  const [e] = Le(), n = function(i) {
    const [o, s] = ue(() => Hm(i));
    return ph(() => {
      function a() {
        const l = Hm(i);
        s(l);
      }
      return a(), Ht(i.registerUpdateListener(() => {
        a();
      }), i.registerEditableListener(() => {
        a();
      }));
    }, [i]), o;
  }(e), r = Zv();
  return n ? typeof t == "function" ? t(r) : t : null;
}
const fu = Math.min, Ao = Math.max, hu = Math.round, xc = Math.floor, Kr = (t) => ({
  x: t,
  y: t
}), FS = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, BS = {
  start: "end",
  end: "start"
};
function Km(t, e, n) {
  return Ao(t, fu(e, n));
}
function Kp(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Vs(t) {
  return t.split("-")[0];
}
function Wp(t) {
  return t.split("-")[1];
}
function t_(t) {
  return t === "x" ? "y" : "x";
}
function n_(t) {
  return t === "y" ? "height" : "width";
}
const qS = /* @__PURE__ */ new Set(["top", "bottom"]);
function vo(t) {
  return qS.has(Vs(t)) ? "y" : "x";
}
function r_(t) {
  return t_(vo(t));
}
function jS(t, e, n) {
  n === void 0 && (n = !1);
  const r = Wp(t), i = r_(t), o = n_(i);
  let s = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[o] > e.floating[o] && (s = pu(s)), [s, pu(s)];
}
function US(t) {
  const e = pu(t);
  return [gh(t), e, gh(e)];
}
function gh(t) {
  return t.replace(/start|end/g, (e) => BS[e]);
}
const Wm = ["left", "right"], Gm = ["right", "left"], zS = ["top", "bottom"], VS = ["bottom", "top"];
function HS(t, e, n) {
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? Gm : Wm : e ? Wm : Gm;
    case "left":
    case "right":
      return e ? zS : VS;
    default:
      return [];
  }
}
function KS(t, e, n, r) {
  const i = Wp(t);
  let o = HS(Vs(t), n === "start", r);
  return i && (o = o.map((s) => s + "-" + i), e && (o = o.concat(o.map(gh)))), o;
}
function pu(t) {
  return t.replace(/left|right|bottom|top/g, (e) => FS[e]);
}
function WS(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function GS(t) {
  return typeof t != "number" ? WS(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function gu(t) {
  const {
    x: e,
    y: n,
    width: r,
    height: i
  } = t;
  return {
    width: r,
    height: i,
    top: n,
    left: e,
    right: e + r,
    bottom: n + i,
    x: e,
    y: n
  };
}
function Jm(t, e, n) {
  let {
    reference: r,
    floating: i
  } = t;
  const o = vo(e), s = r_(e), a = n_(s), l = Vs(e), c = o === "y", u = r.x + r.width / 2 - i.width / 2, f = r.y + r.height / 2 - i.height / 2, d = r[a] / 2 - i[a] / 2;
  let h;
  switch (l) {
    case "top":
      h = {
        x: u,
        y: r.y - i.height
      };
      break;
    case "bottom":
      h = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: f
      };
      break;
    case "left":
      h = {
        x: r.x - i.width,
        y: f
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (Wp(e)) {
    case "start":
      h[s] -= d * (n && c ? -1 : 1);
      break;
    case "end":
      h[s] += d * (n && c ? -1 : 1);
      break;
  }
  return h;
}
const JS = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: s
  } = n, a = o.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let c = await s.getElementRects({
    reference: t,
    floating: e,
    strategy: i
  }), {
    x: u,
    y: f
  } = Jm(c, r, l), d = r, h = {}, g = 0;
  for (let w = 0; w < a.length; w++) {
    const {
      name: b,
      fn: _
    } = a[w], {
      x: y,
      y: C,
      data: D,
      reset: P
    } = await _({
      x: u,
      y: f,
      initialPlacement: r,
      placement: d,
      strategy: i,
      middlewareData: h,
      rects: c,
      platform: s,
      elements: {
        reference: t,
        floating: e
      }
    });
    u = y ?? u, f = C ?? f, h = {
      ...h,
      [b]: {
        ...h[b],
        ...D
      }
    }, P && g <= 50 && (g++, typeof P == "object" && (P.placement && (d = P.placement), P.rects && (c = P.rects === !0 ? await s.getElementRects({
      reference: t,
      floating: e,
      strategy: i
    }) : P.rects), {
      x: u,
      y: f
    } = Jm(c, d, l)), w = -1);
  }
  return {
    x: u,
    y: f,
    placement: d,
    strategy: i,
    middlewareData: h
  };
};
async function i_(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: o,
    rects: s,
    elements: a,
    strategy: l
  } = t, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: f = "floating",
    altBoundary: d = !1,
    padding: h = 0
  } = Kp(e, t), g = GS(h), b = a[d ? f === "floating" ? "reference" : "floating" : f], _ = gu(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(b))) == null || n ? b : b.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), y = f === "floating" ? {
    x: r,
    y: i,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, C = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), D = await (o.isElement == null ? void 0 : o.isElement(C)) ? await (o.getScale == null ? void 0 : o.getScale(C)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, P = gu(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: y,
    offsetParent: C,
    strategy: l
  }) : y);
  return {
    top: (_.top - P.top + g.top) / D.y,
    bottom: (P.bottom - _.bottom + g.bottom) / D.y,
    left: (_.left - P.left + g.left) / D.x,
    right: (P.right - _.right + g.right) / D.x
  };
}
const XS = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: i,
        middlewareData: o,
        rects: s,
        initialPlacement: a,
        platform: l,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: f = !0,
        fallbackPlacements: d,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: w = !0,
        ...b
      } = Kp(t, e);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const _ = Vs(i), y = vo(a), C = Vs(a) === a, D = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), P = d || (C || !w ? [pu(a)] : US(a)), S = g !== "none";
      !d && S && P.push(...KS(a, w, g, D));
      const L = [a, ...P], O = await i_(e, b), M = [];
      let F = ((r = o.flip) == null ? void 0 : r.overflows) || [];
      if (u && M.push(O[_]), f) {
        const R = jS(i, s, D);
        M.push(O[R[0]], O[R[1]]);
      }
      if (F = [...F, {
        placement: i,
        overflows: M
      }], !M.every((R) => R <= 0)) {
        var k, I;
        const R = (((k = o.flip) == null ? void 0 : k.index) || 0) + 1, T = L[R];
        if (T && (!(f === "alignment" ? y !== vo(T) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        F.every((V) => vo(V.placement) === y ? V.overflows[0] > 0 : !0)))
          return {
            data: {
              index: R,
              overflows: F
            },
            reset: {
              placement: T
            }
          };
        let A = (I = F.filter((q) => q.overflows[0] <= 0).sort((q, V) => q.overflows[1] - V.overflows[1])[0]) == null ? void 0 : I.placement;
        if (!A)
          switch (h) {
            case "bestFit": {
              var N;
              const q = (N = F.filter((V) => {
                if (S) {
                  const J = vo(V.placement);
                  return J === y || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  J === "y";
                }
                return !0;
              }).map((V) => [V.placement, V.overflows.filter((J) => J > 0).reduce((J, H) => J + H, 0)]).sort((V, J) => V[1] - J[1])[0]) == null ? void 0 : N[0];
              q && (A = q);
              break;
            }
            case "initialPlacement":
              A = a;
              break;
          }
        if (i !== A)
          return {
            reset: {
              placement: A
            }
          };
      }
      return {};
    }
  };
}, YS = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: i
      } = e, {
        mainAxis: o = !0,
        crossAxis: s = !1,
        limiter: a = {
          fn: (b) => {
            let {
              x: _,
              y
            } = b;
            return {
              x: _,
              y
            };
          }
        },
        ...l
      } = Kp(t, e), c = {
        x: n,
        y: r
      }, u = await i_(e, l), f = vo(Vs(i)), d = t_(f);
      let h = c[d], g = c[f];
      if (o) {
        const b = d === "y" ? "top" : "left", _ = d === "y" ? "bottom" : "right", y = h + u[b], C = h - u[_];
        h = Km(y, h, C);
      }
      if (s) {
        const b = f === "y" ? "top" : "left", _ = f === "y" ? "bottom" : "right", y = g + u[b], C = g - u[_];
        g = Km(y, g, C);
      }
      const w = a.fn({
        ...e,
        [d]: h,
        [f]: g
      });
      return {
        ...w,
        data: {
          x: w.x - n,
          y: w.y - r,
          enabled: {
            [d]: o,
            [f]: s
          }
        }
      };
    }
  };
};
function rd() {
  return typeof window < "u";
}
function wa(t) {
  return o_(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Xn(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function ei(t) {
  var e;
  return (e = (o_(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function o_(t) {
  return rd() ? t instanceof Node || t instanceof Xn(t).Node : !1;
}
function Cr(t) {
  return rd() ? t instanceof Element || t instanceof Xn(t).Element : !1;
}
function Yr(t) {
  return rd() ? t instanceof HTMLElement || t instanceof Xn(t).HTMLElement : !1;
}
function Xm(t) {
  return !rd() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Xn(t).ShadowRoot;
}
const QS = /* @__PURE__ */ new Set(["inline", "contents"]);
function zl(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: i
  } = kr(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !QS.has(i);
}
const ZS = /* @__PURE__ */ new Set(["table", "td", "th"]);
function eT(t) {
  return ZS.has(wa(t));
}
const tT = [":popover-open", ":modal"];
function id(t) {
  return tT.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const nT = ["transform", "translate", "scale", "rotate", "perspective"], rT = ["transform", "translate", "scale", "rotate", "perspective", "filter"], iT = ["paint", "layout", "strict", "content"];
function Gp(t) {
  const e = Jp(), n = Cr(t) ? kr(t) : t;
  return nT.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || rT.some((r) => (n.willChange || "").includes(r)) || iT.some((r) => (n.contain || "").includes(r));
}
function oT(t) {
  let e = Ki(t);
  for (; Yr(e) && !Hs(e); ) {
    if (Gp(e))
      return e;
    if (id(e))
      return null;
    e = Ki(e);
  }
  return null;
}
function Jp() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const sT = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Hs(t) {
  return sT.has(wa(t));
}
function kr(t) {
  return Xn(t).getComputedStyle(t);
}
function od(t) {
  return Cr(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function Ki(t) {
  if (wa(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Xm(t) && t.host || // Fallback.
    ei(t)
  );
  return Xm(e) ? e.host : e;
}
function s_(t) {
  const e = Ki(t);
  return Hs(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Yr(e) && zl(e) ? e : s_(e);
}
function gl(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const i = s_(t), o = i === ((r = t.ownerDocument) == null ? void 0 : r.body), s = Xn(i);
  if (o) {
    const a = wh(s);
    return e.concat(s, s.visualViewport || [], zl(i) ? i : [], a && n ? gl(a) : []);
  }
  return e.concat(i, gl(i, [], n));
}
function wh(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function a_(t) {
  const e = kr(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = Yr(t), o = i ? t.offsetWidth : n, s = i ? t.offsetHeight : r, a = hu(n) !== o || hu(r) !== s;
  return a && (n = o, r = s), {
    width: n,
    height: r,
    $: a
  };
}
function Xp(t) {
  return Cr(t) ? t : t.contextElement;
}
function Ss(t) {
  const e = Xp(t);
  if (!Yr(e))
    return Kr(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = a_(e);
  let s = (o ? hu(n.width) : n.width) / r, a = (o ? hu(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const aT = /* @__PURE__ */ Kr(0);
function l_(t) {
  const e = Xn(t);
  return !Jp() || !e.visualViewport ? aT : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function lT(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== Xn(t) ? !1 : e;
}
function Uo(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const i = t.getBoundingClientRect(), o = Xp(t);
  let s = Kr(1);
  e && (r ? Cr(r) && (s = Ss(r)) : s = Ss(t));
  const a = lT(o, n, r) ? l_(o) : Kr(0);
  let l = (i.left + a.x) / s.x, c = (i.top + a.y) / s.y, u = i.width / s.x, f = i.height / s.y;
  if (o) {
    const d = Xn(o), h = r && Cr(r) ? Xn(r) : r;
    let g = d, w = wh(g);
    for (; w && r && h !== g; ) {
      const b = Ss(w), _ = w.getBoundingClientRect(), y = kr(w), C = _.left + (w.clientLeft + parseFloat(y.paddingLeft)) * b.x, D = _.top + (w.clientTop + parseFloat(y.paddingTop)) * b.y;
      l *= b.x, c *= b.y, u *= b.x, f *= b.y, l += C, c += D, g = Xn(w), w = wh(g);
    }
  }
  return gu({
    width: u,
    height: f,
    x: l,
    y: c
  });
}
function sd(t, e) {
  const n = od(t).scrollLeft;
  return e ? e.left + n : Uo(ei(t)).left + n;
}
function c_(t, e) {
  const n = t.getBoundingClientRect(), r = n.left + e.scrollLeft - sd(t, n), i = n.top + e.scrollTop;
  return {
    x: r,
    y: i
  };
}
function cT(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: r,
    strategy: i
  } = t;
  const o = i === "fixed", s = ei(r), a = e ? id(e.floating) : !1;
  if (r === s || a && o)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = Kr(1);
  const u = Kr(0), f = Yr(r);
  if ((f || !f && !o) && ((wa(r) !== "body" || zl(s)) && (l = od(r)), Yr(r))) {
    const h = Uo(r);
    c = Ss(r), u.x = h.x + r.clientLeft, u.y = h.y + r.clientTop;
  }
  const d = s && !f && !o ? c_(s, l) : Kr(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x + d.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y + d.y
  };
}
function uT(t) {
  return Array.from(t.getClientRects());
}
function dT(t) {
  const e = ei(t), n = od(t), r = t.ownerDocument.body, i = Ao(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), o = Ao(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + sd(t);
  const a = -n.scrollTop;
  return kr(r).direction === "rtl" && (s += Ao(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: o,
    x: s,
    y: a
  };
}
const Ym = 25;
function fT(t, e) {
  const n = Xn(t), r = ei(t), i = n.visualViewport;
  let o = r.clientWidth, s = r.clientHeight, a = 0, l = 0;
  if (i) {
    o = i.width, s = i.height;
    const u = Jp();
    (!u || u && e === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  const c = sd(r);
  if (c <= 0) {
    const u = r.ownerDocument, f = u.body, d = getComputedStyle(f), h = u.compatMode === "CSS1Compat" && parseFloat(d.marginLeft) + parseFloat(d.marginRight) || 0, g = Math.abs(r.clientWidth - f.clientWidth - h);
    g <= Ym && (o -= g);
  } else c <= Ym && (o += c);
  return {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
const hT = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function pT(t, e) {
  const n = Uo(t, !0, e === "fixed"), r = n.top + t.clientTop, i = n.left + t.clientLeft, o = Yr(t) ? Ss(t) : Kr(1), s = t.clientWidth * o.x, a = t.clientHeight * o.y, l = i * o.x, c = r * o.y;
  return {
    width: s,
    height: a,
    x: l,
    y: c
  };
}
function Qm(t, e, n) {
  let r;
  if (e === "viewport")
    r = fT(t, n);
  else if (e === "document")
    r = dT(ei(t));
  else if (Cr(e))
    r = pT(e, n);
  else {
    const i = l_(t);
    r = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return gu(r);
}
function u_(t, e) {
  const n = Ki(t);
  return n === e || !Cr(n) || Hs(n) ? !1 : kr(n).position === "fixed" || u_(n, e);
}
function gT(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let r = gl(t, [], !1).filter((a) => Cr(a) && wa(a) !== "body"), i = null;
  const o = kr(t).position === "fixed";
  let s = o ? Ki(t) : t;
  for (; Cr(s) && !Hs(s); ) {
    const a = kr(s), l = Gp(s);
    !l && a.position === "fixed" && (i = null), (o ? !l && !i : !l && a.position === "static" && !!i && hT.has(i.position) || zl(s) && !l && u_(t, s)) ? r = r.filter((u) => u !== s) : i = a, s = Ki(s);
  }
  return e.set(t, r), r;
}
function wT(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = t;
  const s = [...n === "clippingAncestors" ? id(e) ? [] : gT(e, this._c) : [].concat(n), r], a = s[0], l = s.reduce((c, u) => {
    const f = Qm(e, u, i);
    return c.top = Ao(f.top, c.top), c.right = fu(f.right, c.right), c.bottom = fu(f.bottom, c.bottom), c.left = Ao(f.left, c.left), c;
  }, Qm(e, a, i));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function mT(t) {
  const {
    width: e,
    height: n
  } = a_(t);
  return {
    width: e,
    height: n
  };
}
function bT(t, e, n) {
  const r = Yr(e), i = ei(e), o = n === "fixed", s = Uo(t, !0, o, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Kr(0);
  function c() {
    l.x = sd(i);
  }
  if (r || !r && !o)
    if ((wa(e) !== "body" || zl(i)) && (a = od(e)), r) {
      const h = Uo(e, !0, o, e);
      l.x = h.x + e.clientLeft, l.y = h.y + e.clientTop;
    } else i && c();
  o && !r && i && c();
  const u = i && !r && !o ? c_(i, a) : Kr(0), f = s.left + a.scrollLeft - l.x - u.x, d = s.top + a.scrollTop - l.y - u.y;
  return {
    x: f,
    y: d,
    width: s.width,
    height: s.height
  };
}
function sf(t) {
  return kr(t).position === "static";
}
function Zm(t, e) {
  if (!Yr(t) || kr(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return ei(t) === n && (n = n.ownerDocument.body), n;
}
function d_(t, e) {
  const n = Xn(t);
  if (id(t))
    return n;
  if (!Yr(t)) {
    let i = Ki(t);
    for (; i && !Hs(i); ) {
      if (Cr(i) && !sf(i))
        return i;
      i = Ki(i);
    }
    return n;
  }
  let r = Zm(t, e);
  for (; r && eT(r) && sf(r); )
    r = Zm(r, e);
  return r && Hs(r) && sf(r) && !Gp(r) ? n : r || oT(t) || n;
}
const yT = async function(t) {
  const e = this.getOffsetParent || d_, n = this.getDimensions, r = await n(t.floating);
  return {
    reference: bT(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function vT(t) {
  return kr(t).direction === "rtl";
}
const _T = {
  convertOffsetParentRelativeRectToViewportRelativeRect: cT,
  getDocumentElement: ei,
  getClippingRect: wT,
  getOffsetParent: d_,
  getElementRects: yT,
  getClientRects: uT,
  getDimensions: mT,
  getScale: Ss,
  isElement: Cr,
  isRTL: vT
};
function f_(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function xT(t, e) {
  let n = null, r;
  const i = ei(t);
  function o() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
  }
  function s(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), o();
    const c = t.getBoundingClientRect(), {
      left: u,
      top: f,
      width: d,
      height: h
    } = c;
    if (a || e(), !d || !h)
      return;
    const g = xc(f), w = xc(i.clientWidth - (u + d)), b = xc(i.clientHeight - (f + h)), _ = xc(u), C = {
      rootMargin: -g + "px " + -w + "px " + -b + "px " + -_ + "px",
      threshold: Ao(0, fu(1, l)) || 1
    };
    let D = !0;
    function P(S) {
      const L = S[0].intersectionRatio;
      if (L !== l) {
        if (!D)
          return s();
        L ? s(!1, L) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      L === 1 && !f_(c, t.getBoundingClientRect()) && s(), D = !1;
    }
    try {
      n = new IntersectionObserver(P, {
        ...C,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(P, C);
    }
    n.observe(t);
  }
  return s(!0), o;
}
function CT(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, c = Xp(t), u = i || o ? [...c ? gl(c) : [], ...gl(e)] : [];
  u.forEach((_) => {
    i && _.addEventListener("scroll", n, {
      passive: !0
    }), o && _.addEventListener("resize", n);
  });
  const f = c && a ? xT(c, n) : null;
  let d = -1, h = null;
  s && (h = new ResizeObserver((_) => {
    let [y] = _;
    y && y.target === c && h && (h.unobserve(e), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      var C;
      (C = h) == null || C.observe(e);
    })), n();
  }), c && !l && h.observe(c), h.observe(e));
  let g, w = l ? Uo(t) : null;
  l && b();
  function b() {
    const _ = Uo(t);
    w && !f_(w, _) && n(), w = _, g = requestAnimationFrame(b);
  }
  return n(), () => {
    var _;
    u.forEach((y) => {
      i && y.removeEventListener("scroll", n), o && y.removeEventListener("resize", n);
    }), f == null || f(), (_ = h) == null || _.disconnect(), h = null, l && cancelAnimationFrame(g);
  };
}
const kT = YS, ET = XS, NT = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: _T,
    ...n
  }, o = {
    ...i.platform,
    _c: r
  };
  return JS(t, e, {
    ...i,
    platform: o
  });
}, mh = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, ST = mh ? kn : de;
let TT = class {
  constructor(e) {
    this.key = e, this.ref = { current: null }, this.setRefElement = this.setRefElement.bind(this);
  }
  setRefElement(e) {
    this.ref = { current: e };
  }
};
const eb = (t) => {
  const e = document.getElementById("typeahead-menu");
  if (!e) return;
  const n = e.getBoundingClientRect();
  n.top + n.height > window.innerHeight && e.scrollIntoView({ block: "center" }), n.top < 0 && e.scrollIntoView({ block: "center" }), t.scrollIntoView({ block: "nearest" });
};
function tb(t, e) {
  const n = t.getBoundingClientRect(), r = e.getBoundingClientRect();
  return n.top > r.top && n.top < r.bottom;
}
function AT(t, e, n, r) {
  const [i] = Le();
  de(() => {
    if (e != null && t != null) {
      const o = i.getRootElement(), s = o != null ? function(f, d) {
        let h = getComputedStyle(f);
        const g = h.position === "absolute", w = /(auto|scroll)/;
        if (h.position === "fixed") return document.body;
        for (let b = f; b = b.parentElement; ) if (h = getComputedStyle(b), (!g || h.position !== "static") && w.test(h.overflow + h.overflowY + h.overflowX)) return b;
        return document.body;
      }(o) : document.body;
      let a = !1, l = tb(e, s);
      const c = function() {
        a || (window.requestAnimationFrame(function() {
          n(), a = !1;
        }), a = !0);
        const f = tb(e, s);
        f !== l && (l = f, r != null && r(f));
      }, u = new ResizeObserver(n);
      return window.addEventListener("resize", n), document.addEventListener("scroll", c, { capture: !0, passive: !0 }), u.observe(e), () => {
        u.unobserve(e), window.removeEventListener("resize", n), document.removeEventListener("scroll", c, !0);
      };
    }
  }, [e, i, r, n, t]);
}
const nb = Se("SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND");
function DT({ close: t, editor: e, anchorElementRef: n, resolution: r, options: i, menuRenderFn: o, onSelectOption: s, shouldSplitNodeWithQuery: a = !1, commandPriority: l = rs, preselectFirstItem: c = !0 }) {
  const [u, f] = ue(null), d = r.match && r.match.matchingString;
  de(() => {
    c && f(0);
  }, [d, c]);
  const h = be((w) => {
    e.update(() => {
      const b = r.match != null && a ? function(_) {
        const y = oe();
        if (!Z(y) || !y.isCollapsed()) return null;
        const C = y.anchor;
        if (C.type !== "text") return null;
        const D = C.getNode();
        if (!D.isSimpleText()) return null;
        const P = C.offset, S = D.getTextContent().slice(0, P), L = _.replaceableString.length, O = P - function(F, k, I) {
          let N = I;
          for (let R = N; R <= k.length; R++) F.slice(-R) === k.substring(0, R) && (N = R);
          return N;
        }(S, _.matchingString, L);
        if (O < 0) return null;
        let M;
        return O === 0 ? [M] = D.splitText(P) : [, M] = D.splitText(O, P), M;
      }(r.match) : null;
      s(w, b, t, r.match ? r.match.matchingString : "");
    });
  }, [e, a, r.match, s, t]), g = be((w) => {
    const b = e.getRootElement();
    b !== null && (b.setAttribute("aria-activedescendant", "typeahead-item-" + w), f(w));
  }, [e]);
  return de(() => () => {
    const w = e.getRootElement();
    w !== null && w.removeAttribute("aria-activedescendant");
  }, [e]), ST(() => {
    i === null ? f(null) : u === null && c && g(0);
  }, [i, u, g, c]), de(() => Ht(e.registerCommand(nb, ({ option: w }) => !(!w.ref || w.ref.current == null) && (eb(w.ref.current), !0), l)), [e, g, l]), de(() => Ht(e.registerCommand(wp, (w) => {
    const b = w;
    if (i !== null && i.length) {
      const _ = u === null ? 0 : u !== i.length - 1 ? u + 1 : 0;
      g(_);
      const y = i[_];
      y.ref != null && y.ref.current && e.dispatchCommand(nb, { index: _, option: y }), b.preventDefault(), b.stopImmediatePropagation();
    }
    return !0;
  }, l), e.registerCommand(gp, (w) => {
    const b = w;
    if (i !== null && i.length) {
      const _ = u === null ? i.length - 1 : u !== 0 ? u - 1 : i.length - 1;
      g(_);
      const y = i[_];
      y.ref != null && y.ref.current && eb(y.ref.current), b.preventDefault(), b.stopImmediatePropagation();
    }
    return !0;
  }, l), e.registerCommand(Vu, (w) => {
    const b = w;
    return b.preventDefault(), b.stopImmediatePropagation(), t(), !0;
  }, l), e.registerCommand(yp, (w) => {
    const b = w;
    return i !== null && u !== null && i[u] != null && (b.preventDefault(), b.stopImmediatePropagation(), h(i[u]), !0);
  }, l), e.registerCommand(qs, (w) => i !== null && u !== null && i[u] != null && (w !== null && (w.preventDefault(), w.stopImmediatePropagation()), h(i[u]), !0), l)), [h, t, e, i, u, g, l]), o(n, Ne(() => ({ options: i, selectOptionAndCleanUp: h, selectedIndex: u, setHighlightedIndex: f }), [h, u, i]), r.match ? r.match.matchingString : "");
}
function rb(t, e) {
  e != null && (t.className = e), t.setAttribute("aria-label", "Typeahead menu"), t.setAttribute("role", "listbox"), t.style.display = "block", t.style.position = "absolute";
}
function MT({ options: t, onWillOpen: e, onClose: n, onOpen: r, onSelectOption: i, menuRenderFn: o, anchorClassName: s, commandPriority: a = rs, parent: l }) {
  const [c] = Le(), [u, f] = ue(null), d = vs.useRef(null), h = function(y, C, D, P = mh ? document.body : void 0, S = !0) {
    const [L] = Le(), O = mh ? document.createElement("div") : null, M = ye(O), F = be(() => {
      if (M.current === null || P === void 0) return;
      M.current.style.top = M.current.style.bottom;
      const I = L.getRootElement(), N = M.current, R = N.firstChild;
      if (I !== null && y !== null) {
        const { left: T, top: A, width: q, height: V } = y.getRect(), J = M.current.offsetHeight;
        if (N.style.top = `${A + J + 3 + (S ? window.pageYOffset : 0)}px`, N.style.left = `${T + window.pageXOffset}px`, N.style.height = `${V}px`, N.style.width = `${q}px`, R !== null) {
          R.style.top = `${A}`;
          const H = R.getBoundingClientRect(), W = H.height, ne = H.width, re = I.getBoundingClientRect();
          T + ne > re.right && (N.style.left = `${re.right - ne + window.pageXOffset}px`), (A + W > window.innerHeight || A + W > re.bottom) && A - re.top > W + V && (N.style.top = `${A - W - V + (S ? window.pageYOffset : 0)}px`);
        }
        N.isConnected || (rb(N, D), P.append(N)), N.setAttribute("id", "typeahead-menu"), I.setAttribute("aria-controls", "typeahead-menu");
      }
    }, [L, y, S, D, P]);
    de(() => {
      const I = L.getRootElement();
      return y !== null && F(), () => {
        I !== null && I.removeAttribute("aria-controls");
        const N = M.current;
        N !== null && N.isConnected && (N.remove(), N.removeAttribute("id"));
      };
    }, [L, F, y]);
    const k = be((I) => {
      y !== null && (I || C(null));
    }, [y, C]);
    return AT(y, M.current, F, k), O != null && O === M.current && (rb(O, D), P != null && P.append(O)), M;
  }(u, f, s, l), g = be(() => {
    f(null), n != null && u !== null && n();
  }, [n, u]), w = be((y) => {
    f(y), r != null && u === null && r(y);
  }, [r, u]), b = be((y) => {
    y.preventDefault(), e != null && e(y);
    const C = jE(y.target);
    w({ getRect: () => new DOMRect(y.clientX / C, y.clientY / C, 1, 1) });
  }, [w, e]), _ = be((y) => {
    u !== null && d.current != null && y.target != null && is(y.target) && !d.current.contains(y.target) && g();
  }, [g, u]);
  return de(() => {
    const y = c.getRootElement();
    if (y) return y.addEventListener("contextmenu", b), () => y.removeEventListener("contextmenu", b);
  }, [c, b]), de(() => (document.addEventListener("click", _), () => document.removeEventListener("click", _)), [c, _]), h.current === null || u === null || c === null ? null : p(DT, { close: g, resolution: u, editor: c, anchorElementRef: h, options: t, menuRenderFn: (y, C) => o(y, C, { setMenuRef: (D) => {
    d.current = D;
  } }), onSelectOption: i, commandPriority: a });
}
function OT({ defaultSelection: t }) {
  const [e] = Le();
  return de(() => {
    e.focus(() => {
      const n = document.activeElement, r = e.getRootElement();
      r === null || n !== null && r.contains(n) || r.focus({ preventScroll: !0 });
    }, { defaultSelection: t });
  }, [t, e]), null;
}
const IT = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? kn : de;
function RT({ onClear: t }) {
  const [e] = Le();
  return IT(() => e.registerCommand(_p, (n) => (e.update(() => {
    if (t == null) {
      const r = Ve(), i = oe(), o = Jn();
      r.clear(), r.append(o), i !== null && o.select(), Z(i) && (i.format = 0);
    } else t();
  }), !0), ke), [e, t]), null;
}
const ib = [["Cat", "rgb(125, 50, 0)"], ["Dog", "rgb(100, 0, 0)"], ["Rabbit", "rgb(150, 0, 0)"], ["Frog", "rgb(200, 0, 0)"], ["Fox", "rgb(200, 75, 0)"], ["Hedgehog", "rgb(0, 75, 0)"], ["Pigeon", "rgb(0, 125, 0)"], ["Squirrel", "rgb(75, 100, 0)"], ["Bear", "rgb(125, 100, 0)"], ["Tiger", "rgb(0, 0, 150)"], ["Leopard", "rgb(0, 0, 200)"], ["Zebra", "rgb(0, 0, 250)"], ["Wolf", "rgb(0, 100, 150)"], ["Owl", "rgb(0, 100, 100)"], ["Gull", "rgb(100, 0, 100)"], ["Squid", "rgb(150, 0, 150)"]], ob = ib[Math.floor(Math.random() * ib.length)], PT = Sl({ clientID: 0, color: ob[1], isCollabActive: !1, name: ob[0], yjsDocMap: /* @__PURE__ */ new Map() });
function h_(t, e) {
  return Tl(PT);
}
const LT = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? kn : de;
function $T({ ignoreHistoryMergeTagChange: t = !0, ignoreSelectionChange: e = !1, onChange: n }) {
  const [r] = Le();
  return LT(() => {
    if (n) return r.registerUpdateListener(({ editorState: i, dirtyElements: o, dirtyLeaves: s, prevEditorState: a, tags: l }) => {
      e && o.size === 0 && s.size === 0 || t && l.has(Eo) || a.isEmpty() || n(i, r, l);
    });
  }, [r, t, e, n]), null;
}
const ma = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, FT = ma && "documentMode" in document ? document.documentMode : null, BT = !(!ma || !("InputEvent" in window) || FT) && "getTargetRanges" in new window.InputEvent("input"), qT = ma && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), sb = ma && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, jT = ma && /^(?=.*Chrome).*/i.test(navigator.userAgent), UT = ma && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !jT;
function ab(t, e) {
  e.update(() => {
    if (t !== null) {
      const n = gi(t, KeyboardEvent) ? null : t.clipboardData, r = oe();
      if (r !== null && n != null) {
        t.preventDefault();
        const i = Tv(e);
        i !== null && n.setData("text/html", i), n.setData("text/plain", r.getTextContent());
      }
    }
  });
}
function zT(t) {
  return Ht(t.registerCommand(Hr, (e) => {
    const n = oe();
    return !!Z(n) && (n.deleteCharacter(e), !0);
  }, ke), t.registerCommand(Fs, (e) => {
    const n = oe();
    return !!Z(n) && (n.deleteWord(e), !0);
  }, ke), t.registerCommand(Bs, (e) => {
    const n = oe();
    return !!Z(n) && (n.deleteLine(e), !0);
  }, ke), t.registerCommand(Co, (e) => {
    const n = oe();
    if (!Z(n)) return !1;
    if (typeof e == "string") n.insertText(e);
    else {
      const r = e.dataTransfer;
      if (r != null) xm(r, n);
      else {
        const i = e.data;
        i && n.insertText(i);
      }
    }
    return !0;
  }, ke), t.registerCommand(Zc, () => {
    const e = oe();
    return !!Z(e) && (e.removeText(), !0);
  }, ke), t.registerCommand(Fi, (e) => {
    const n = oe();
    return !!Z(n) && (n.insertLineBreak(e), !0);
  }, ke), t.registerCommand(fl, () => {
    const e = oe();
    return !!Z(e) && (e.insertLineBreak(), !0);
  }, ke), t.registerCommand(pp, (e) => {
    const n = oe();
    if (!Z(n)) return !1;
    const r = e, i = r.shiftKey;
    return !!cu(n, !0) && (r.preventDefault(), uu(n, i, !0), !0);
  }, ke), t.registerCommand(hp, (e) => {
    const n = oe();
    if (!Z(n)) return !1;
    const r = e, i = r.shiftKey;
    return !!cu(n, !1) && (r.preventDefault(), uu(n, i, !1), !0);
  }, ke), t.registerCommand(mp, (e) => {
    const n = oe();
    return !!Z(n) && (!sb || navigator.language !== "ko-KR") && (e.preventDefault(), t.dispatchCommand(Hr, !0));
  }, ke), t.registerCommand(bp, (e) => {
    const n = oe();
    return !!Z(n) && (e.preventDefault(), t.dispatchCommand(Hr, !1));
  }, ke), t.registerCommand(qs, (e) => {
    const n = oe();
    if (!Z(n)) return !1;
    if (e !== null) {
      if ((sb || qT || UT) && BT) return !1;
      e.preventDefault();
    }
    return t.dispatchCommand(Fi, !1);
  }, ke), t.registerCommand(eu, () => (Y0(), !0), ke), t.registerCommand(Qi, (e) => {
    const n = oe();
    return !!Z(n) && (ab(e, t), !0);
  }, ke), t.registerCommand(ts, (e) => {
    const n = oe();
    return !!Z(n) && (function(r, i) {
      ab(r, i), i.update(() => {
        const o = oe();
        Z(o) && o.removeText();
      });
    }(e, t), !0);
  }, ke), t.registerCommand(es, (e) => {
    const n = oe();
    return !!Z(n) && (function(r, i) {
      r.preventDefault(), i.update(() => {
        const o = oe(), s = gi(r, ClipboardEvent) ? r.clipboardData : null;
        s != null && Z(o) && xm(s, o);
      }, { tag: j0 });
    }(e, t), !0);
  }, ke), t.registerCommand(Hu, (e) => {
    const n = oe();
    return !!Z(n) && (e.preventDefault(), !0);
  }, ke), t.registerCommand(vp, (e) => {
    const n = oe();
    return !!Z(n) && (e.preventDefault(), !0);
  }, ke));
}
const bh = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? kn : de;
function lb(t) {
  return t.getEditorState().read(Hp(t.isComposing()));
}
function VT({ contentEditable: t, placeholder: e = null, ErrorBoundary: n }) {
  const [r] = Le(), i = function(o, s) {
    const [a, l] = ue(() => o.getDecorators());
    return bh(() => o.registerDecoratorListener((c) => {
      ky(() => {
        l(c);
      });
    }), [o]), de(() => {
      l(o.getDecorators());
    }, [o]), Ne(() => {
      const c = [], u = Object.keys(a);
      for (let f = 0; f < u.length; f++) {
        const d = u[f], h = p(s, { onError: (w) => o._onError(w), children: p(wy, { fallback: null, children: a[d] }) }), g = o.getElementByKey(d);
        g !== null && c.push(fi(h, g, d));
      }
      return c;
    }, [s, a, o]);
  }(r, n);
  return function(o) {
    bh(() => Ht(zT(o), e_(o)), [o]);
  }(r), B(Lt, { children: [t, p(HT, { content: e }), i] });
}
function HT({ content: t }) {
  const [e] = Le(), n = function(i) {
    const [o, s] = ue(() => lb(i));
    return bh(() => {
      function a() {
        const l = lb(i);
        s(l);
      }
      return a(), Ht(i.registerUpdateListener(() => {
        a();
      }), i.registerEditableListener(() => {
        a();
      }));
    }, [i]), o;
  }(e), r = Zv();
  return n ? typeof t == "function" ? t(r) : t : null;
}
const Wr = () => /* @__PURE__ */ new Map(), yh = (t) => {
  const e = Wr();
  return t.forEach((n, r) => {
    e.set(r, n);
  }), e;
}, ba = (t, e, n) => {
  let r = t.get(e);
  return r === void 0 && t.set(e, r = n()), r;
}, KT = (t, e) => {
  const n = [];
  for (const [r, i] of t)
    n.push(e(i, r));
  return n;
}, WT = (t, e) => {
  for (const [n, r] of t)
    if (e(r, n))
      return !0;
  return !1;
}, Ks = () => /* @__PURE__ */ new Set(), af = (t) => t[t.length - 1], Ws = Array.from, GT = Array.isArray;
class JT {
  constructor() {
    this._observers = Wr();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(e, n) {
    return ba(
      this._observers,
      /** @type {string} */
      e,
      Ks
    ).add(n), n;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(e, n) {
    const r = (...i) => {
      this.off(
        e,
        /** @type {any} */
        r
      ), n(...i);
    };
    this.on(
      e,
      /** @type {any} */
      r
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(e, n) {
    const r = this._observers.get(e);
    r !== void 0 && (r.delete(n), r.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(e, n) {
    return Ws((this._observers.get(e) || Wr()).values()).forEach((r) => r(...n));
  }
  destroy() {
    this._observers = Wr();
  }
}
const zo = Math.floor, Pc = Math.abs, p_ = (t, e) => t < e ? t : e, ya = (t, e) => t > e ? t : e, XT = (t) => t !== 0 ? t < 0 : 1 / t < 0, cb = 1, ub = 2, lf = 4, cf = 8, YT = 32, g_ = 64, wu = 128, QT = 31, db = 63, Za = 127, ZT = 2147483647, eA = Number.isInteger || ((t) => typeof t == "number" && isFinite(t) && zo(t) === t), tA = (t) => t.toLowerCase(), nA = /^\s*/g, rA = (t) => t.replace(nA, ""), iA = /([A-Z])/g, fb = (t, e) => rA(t.replace(iA, (n) => `${e}${tA(n)}`)), oA = (t) => {
  const e = unescape(encodeURIComponent(t)), n = e.length, r = new Uint8Array(n);
  for (let i = 0; i < n; i++)
    r[i] = /** @type {number} */
    e.codePointAt(i);
  return r;
}, wl = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), sA = (t) => wl.encode(t), aA = wl ? sA : oA;
let uf = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
uf && uf.decode(new Uint8Array()).length === 1 && (uf = null);
class Vl {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const Yp = () => new Vl(), lA = (t) => {
  let e = t.cpos;
  for (let n = 0; n < t.bufs.length; n++)
    e += t.bufs[n].length;
  return e;
}, wi = (t) => {
  const e = new Uint8Array(lA(t));
  let n = 0;
  for (let r = 0; r < t.bufs.length; r++) {
    const i = t.bufs[r];
    e.set(i, n), n += i.length;
  }
  return e.set(new Uint8Array(t.cbuf.buffer, 0, t.cpos), n), e;
}, cA = (t, e) => {
  const n = t.cbuf.length;
  n - t.cpos < e && (t.bufs.push(new Uint8Array(t.cbuf.buffer, 0, t.cpos)), t.cbuf = new Uint8Array(ya(n, e) * 2), t.cpos = 0);
}, jt = (t, e) => {
  const n = t.cbuf.length;
  t.cpos === n && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(n * 2), t.cpos = 0), t.cbuf[t.cpos++] = e;
}, vh = jt, ot = (t, e) => {
  for (; e > Za; )
    jt(t, wu | Za & e), e = zo(e / 128);
  jt(t, Za & e);
}, Qp = (t, e) => {
  const n = XT(e);
  for (n && (e = -e), jt(t, (e > db ? wu : 0) | (n ? g_ : 0) | db & e), e = zo(e / 64); e > 0; )
    jt(t, (e > Za ? wu : 0) | Za & e), e = zo(e / 128);
}, _h = new Uint8Array(3e4), uA = _h.length / 3, dA = (t, e) => {
  if (e.length < uA) {
    const n = wl.encodeInto(e, _h).written || 0;
    ot(t, n);
    for (let r = 0; r < n; r++)
      jt(t, _h[r]);
  } else
    Kn(t, aA(e));
}, fA = (t, e) => {
  const n = unescape(encodeURIComponent(e)), r = n.length;
  ot(t, r);
  for (let i = 0; i < r; i++)
    jt(
      t,
      /** @type {number} */
      n.codePointAt(i)
    );
}, Ts = wl && /** @type {any} */
wl.encodeInto ? dA : fA, Zp = (t, e) => {
  const n = t.cbuf.length, r = t.cpos, i = p_(n - r, e.length), o = e.length - i;
  t.cbuf.set(e.subarray(0, i), r), t.cpos += i, o > 0 && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(ya(n * 2, o)), t.cbuf.set(e.subarray(i)), t.cpos = o);
}, Kn = (t, e) => {
  ot(t, e.byteLength), Zp(t, e);
}, eg = (t, e) => {
  cA(t, e);
  const n = new DataView(t.cbuf.buffer, t.cpos, e);
  return t.cpos += e, n;
}, hA = (t, e) => eg(t, 4).setFloat32(0, e, !1), pA = (t, e) => eg(t, 8).setFloat64(0, e, !1), gA = (t, e) => (
  /** @type {any} */
  eg(t, 8).setBigInt64(0, e, !1)
), hb = new DataView(new ArrayBuffer(4)), wA = (t) => (hb.setFloat32(0, t), hb.getFloat32(0) === t), ml = (t, e) => {
  switch (typeof e) {
    case "string":
      jt(t, 119), Ts(t, e);
      break;
    case "number":
      eA(e) && Pc(e) <= ZT ? (jt(t, 125), Qp(t, e)) : wA(e) ? (jt(t, 124), hA(t, e)) : (jt(t, 123), pA(t, e));
      break;
    case "bigint":
      jt(t, 122), gA(t, e);
      break;
    case "object":
      if (e === null)
        jt(t, 126);
      else if (GT(e)) {
        jt(t, 117), ot(t, e.length);
        for (let n = 0; n < e.length; n++)
          ml(t, e[n]);
      } else if (e instanceof Uint8Array)
        jt(t, 116), Kn(t, e);
      else {
        jt(t, 118);
        const n = Object.keys(e);
        ot(t, n.length);
        for (let r = 0; r < n.length; r++) {
          const i = n[r];
          Ts(t, i), ml(t, e[i]);
        }
      }
      break;
    case "boolean":
      jt(t, e ? 120 : 121);
      break;
    default:
      jt(t, 127);
  }
};
class pb extends Vl {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(e) {
    super(), this.w = e, this.s = null, this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(e) {
    this.s === e ? this.count++ : (this.count > 0 && ot(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e);
  }
}
const gb = (t) => {
  t.count > 0 && (Qp(t.encoder, t.count === 1 ? t.s : -t.s), t.count > 1 && ot(t.encoder, t.count - 2));
};
class Lc {
  constructor() {
    this.encoder = new Vl(), this.s = 0, this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.s === e ? this.count++ : (gb(this), this.count = 1, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return gb(this), wi(this.encoder);
  }
}
const wb = (t) => {
  if (t.count > 0) {
    const e = t.diff * 2 + (t.count === 1 ? 0 : 1);
    Qp(t.encoder, e), t.count > 1 && ot(t.encoder, t.count - 2);
  }
};
class df {
  constructor() {
    this.encoder = new Vl(), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.diff === e - this.s ? (this.s = e, this.count++) : (wb(this), this.count = 1, this.diff = e - this.s, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return wb(this), wi(this.encoder);
  }
}
class mA {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new Lc();
  }
  /**
   * @param {string} string
   */
  write(e) {
    this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length);
  }
  toUint8Array() {
    const e = new Vl();
    return this.sarr.push(this.s), this.s = "", Ts(e, this.sarr.join("")), Zp(e, this.lensE.toUint8Array()), wi(e);
  }
}
const Gs = (t) => new Error(t), Gr = () => {
  throw Gs("Method unimplemented");
}, Vo = () => {
  throw Gs("Unexpected case");
}, bA = crypto.getRandomValues.bind(crypto), w_ = () => bA(new Uint32Array(1))[0], yA = "10000000-1000-4000-8000" + -1e11, vA = () => yA.replace(
  /[018]/g,
  /** @param {number} c */
  (t) => (t ^ w_() & 15 >> t / 4).toString(16)
), mb = (t) => (
  /** @type {Promise<T>} */
  new Promise(t)
);
Promise.all.bind(Promise);
const bb = (t) => t === void 0 ? null : t;
class _A {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, n) {
    this.map.set(e, n);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}
let m_ = new _A(), xA = !0;
try {
  typeof localStorage < "u" && localStorage && (m_ = localStorage, xA = !1);
} catch {
}
const CA = m_, kA = Object.assign, EA = Object.keys, NA = (t, e) => {
  for (const n in t)
    e(t[n], n);
}, yb = (t) => EA(t).length, SA = (t) => {
  for (const e in t)
    return !1;
  return !0;
}, TA = (t, e) => {
  for (const n in t)
    if (!e(t[n], n))
      return !1;
  return !0;
}, AA = (t, e) => Object.prototype.hasOwnProperty.call(t, e), DA = (t, e) => t === e || yb(t) === yb(e) && TA(t, (n, r) => (n !== void 0 || AA(e, r)) && e[r] === n), MA = Object.freeze, b_ = (t) => {
  for (const e in t) {
    const n = t[e];
    (typeof n == "object" || typeof n == "function") && b_(t[e]);
  }
  return MA(t);
}, tg = (t, e, n = 0) => {
  try {
    for (; n < t.length; n++)
      t[n](...e);
  } finally {
    n < t.length && tg(t, e, n + 1);
  }
}, OA = (t, e) => e.includes(t), bl = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
let Pr;
const IA = () => {
  if (Pr === void 0)
    if (bl) {
      Pr = Wr();
      const t = process.argv;
      let e = null;
      for (let n = 0; n < t.length; n++) {
        const r = t[n];
        r[0] === "-" ? (e !== null && Pr.set(e, ""), e = r) : e !== null && (Pr.set(e, r), e = null);
      }
      e !== null && Pr.set(e, "");
    } else typeof location == "object" ? (Pr = Wr(), (location.search || "?").slice(1).split("&").forEach((t) => {
      if (t.length !== 0) {
        const [e, n] = t.split("=");
        Pr.set(`--${fb(e, "-")}`, n), Pr.set(`-${fb(e, "-")}`, n);
      }
    })) : Pr = Wr();
  return Pr;
}, xh = (t) => IA().has(t), mu = (t) => bb(bl ? process.env[t.toUpperCase().replaceAll("-", "_")] : CA.getItem(t)), y_ = (t) => xh("--" + t) || mu(t) !== null;
y_("production");
const RA = bl && OA(process.env.FORCE_COLOR, ["true", "1", "2"]), PA = RA || !xh("--no-colors") && // @todo deprecate --no-colors
!y_("no-color") && (!bl || process.stdout.isTTY) && (!bl || xh("--color") || mu("COLORTERM") !== null || (mu("TERM") || "").includes("color"));
class LA {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(e, n) {
    this.left = e, this.right = n;
  }
}
const si = (t, e) => new LA(t, e);
typeof DOMParser < "u" && new DOMParser();
const $A = (t) => KT(t, (e, n) => `${n}:${e};`).join(""), Ei = Symbol, v_ = Ei(), __ = Ei(), FA = Ei(), BA = Ei(), qA = Ei(), x_ = Ei(), jA = Ei(), ng = Ei(), UA = Ei(), zA = (t) => {
  var i;
  t.length === 1 && ((i = t[0]) == null ? void 0 : i.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [], n = [];
  let r = 0;
  for (; r < t.length; r++) {
    const o = t[r];
    if (o === void 0)
      break;
    if (o.constructor === String || o.constructor === Number)
      e.push(o);
    else if (o.constructor === Object)
      break;
  }
  for (r > 0 && n.push(e.join("")); r < t.length; r++) {
    const o = t[r];
    o instanceof Symbol || n.push(o);
  }
  return n;
}, VA = {
  [v_]: si("font-weight", "bold"),
  [__]: si("font-weight", "normal"),
  [FA]: si("color", "blue"),
  [qA]: si("color", "green"),
  [BA]: si("color", "grey"),
  [x_]: si("color", "red"),
  [jA]: si("color", "purple"),
  [ng]: si("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UA]: si("color", "black")
}, HA = (t) => {
  var s;
  t.length === 1 && ((s = t[0]) == null ? void 0 : s.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [], n = [], r = Wr();
  let i = [], o = 0;
  for (; o < t.length; o++) {
    const a = t[o], l = VA[a];
    if (l !== void 0)
      r.set(l.left, l.right);
    else {
      if (a === void 0)
        break;
      if (a.constructor === String || a.constructor === Number) {
        const c = $A(r);
        o > 0 || c.length > 0 ? (e.push("%c" + a), n.push(c)) : e.push(a);
      } else
        break;
    }
  }
  for (o > 0 && (i = n, i.unshift(e.join(""))); o < t.length; o++) {
    const a = t[o];
    a instanceof Symbol || i.push(a);
  }
  return i;
}, C_ = PA ? HA : zA, KA = (...t) => {
  console.log(...C_(t)), k_.forEach((e) => e.print(t));
}, WA = (...t) => {
  console.warn(...C_(t)), t.unshift(ng), k_.forEach((e) => e.print(t));
}, k_ = Ks(), E_ = (t) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: t
}), GA = (t, e) => E_(() => {
  let n;
  do
    n = t.next();
  while (!n.done && !e(n.value));
  return n;
}), ff = (t, e) => E_(() => {
  const { done: n, value: r } = t.next();
  return { done: n, value: n ? void 0 : e(r) };
});
class JA {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(e, n) {
    this.clock = e, this.len = n;
  }
}
class XA {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const N_ = (t, e, n) => e.clients.forEach((r, i) => {
  const o = (
    /** @type {Array<GC|Item>} */
    t.doc.store.clients.get(i)
  );
  if (o != null) {
    const s = o[o.length - 1], a = s.id.clock + s.length;
    for (let l = 0, c = r[l]; l < r.length && c.clock < a; c = r[++l])
      I_(t, o, c.clock, c.len, n);
  }
}), YA = (t, e) => {
  let n = 0, r = t.length - 1;
  for (; n <= r; ) {
    const i = zo((n + r) / 2), o = t[i], s = o.clock;
    if (s <= e) {
      if (e < s + o.len)
        return i;
      n = i + 1;
    } else
      r = i - 1;
  }
  return null;
}, S_ = (t, e) => {
  const n = t.clients.get(e.client);
  return n !== void 0 && YA(n, e.clock) !== null;
}, T_ = (t) => {
  t.clients.forEach((e) => {
    e.sort((i, o) => i.clock - o.clock);
    let n, r;
    for (n = 1, r = 1; n < e.length; n++) {
      const i = e[r - 1], o = e[n];
      i.clock + i.len >= o.clock ? i.len = ya(i.len, o.clock + o.len - i.clock) : (r < n && (e[r] = o), r++);
    }
    e.length = r;
  });
}, A_ = (t, e, n, r) => {
  ba(t.clients, e, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new JA(n, r));
}, QA = (t, e) => {
  ot(t.restEncoder, e.clients.size), Ws(e.clients.entries()).sort((n, r) => r[0] - n[0]).forEach(([n, r]) => {
    t.resetDsCurVal(), ot(t.restEncoder, n);
    const i = r.length;
    ot(t.restEncoder, i);
    for (let o = 0; o < i; o++) {
      const s = r[o];
      t.writeDsClock(s.clock), t.writeDsLen(s.len);
    }
  });
}, D_ = w_;
class Hl extends JT {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid: e = vA(), collectionid: n = null, gc: r = !0, gcFilter: i = () => !0, meta: o = null, autoLoad: s = !1, shouldLoad: a = !0 } = {}) {
    super(), this.gc = r, this.gcFilter = i, this.clientID = D_(), this.guid = e, this.collectionid = n, this.share = /* @__PURE__ */ new Map(), this.store = new lD(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = a, this.autoLoad = s, this.meta = o, this.isLoaded = !1, this.isSynced = !1, this.isDestroyed = !1, this.whenLoaded = mb((c) => {
      this.on("load", () => {
        this.isLoaded = !0, c(this);
      });
    });
    const l = () => mb((c) => {
      const u = (f) => {
        (f === void 0 || f === !0) && (this.off("sync", u), c());
      };
      this.on("sync", u);
    });
    this.on("sync", (c) => {
      c === !1 && this.isSynced && (this.whenSynced = l()), this.isSynced = c === void 0 || c === !0, this.isSynced && !this.isLoaded && this.emit("load", [this]);
    }), this.whenSynced = l();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const e = this._item;
    e !== null && !this.shouldLoad && ut(
      /** @type {any} */
      e.parent.doc,
      (n) => {
        n.subdocsLoaded.add(this);
      },
      null,
      !0
    ), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(Ws(this.subdocs).map((e) => e.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(e, n = null) {
    return ut(this, e, n);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(e, n = (
    /** @type {any} */
    rn
  )) {
    const r = ba(this.share, e, () => {
      const o = new n();
      return o._integrate(this, null), o;
    }), i = r.constructor;
    if (n !== rn && i !== n)
      if (i === rn) {
        const o = new n();
        o._map = r._map, r._map.forEach(
          /** @param {Item?} n */
          (s) => {
            for (; s !== null; s = s.left)
              s.parent = o;
          }
        ), o._start = r._start;
        for (let s = o._start; s !== null; s = s.right)
          s.parent = o;
        return o._length = r._length, this.share.set(e, o), o._integrate(this, null), /** @type {InstanceType<Type>} */
        o;
      } else
        throw new Error(`Type with the name ${e} has already been defined with a different constructor`);
    return (
      /** @type {InstanceType<Type>} */
      r
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(e = "") {
    return (
      /** @type {YArray<T>} */
      this.get(e, Do)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(e = "") {
    return this.get(e, vu);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(e = "") {
    return (
      /** @type {YMap<T>} */
      this.get(e, Js)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(e = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(e, _l)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(e = "") {
    return this.get(e, Xs);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const e = {};
    return this.share.forEach((n, r) => {
      e[r] = n.toJSON();
    }), e;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    this.isDestroyed = !0, Ws(this.subdocs).forEach((n) => n.destroy());
    const e = this._item;
    if (e !== null) {
      this._item = null;
      const n = (
        /** @type {ContentDoc} */
        e.content
      );
      n.doc = new Hl({ guid: this.guid, ...n.opts, shouldLoad: !1 }), n.doc._item = e, ut(
        /** @type {any} */
        e.parent.doc,
        (r) => {
          const i = n.doc;
          e.deleted || r.subdocsAdded.add(i), r.subdocsRemoved.add(this);
        },
        null,
        !0
      );
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
}
class ZA {
  constructor() {
    this.restEncoder = Yp();
  }
  toUint8Array() {
    return wi(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    ot(this.restEncoder, e);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    ot(this.restEncoder, e);
  }
}
class eD extends ZA {
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    ot(this.restEncoder, e.client), ot(this.restEncoder, e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    ot(this.restEncoder, e.client), ot(this.restEncoder, e.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(e) {
    ot(this.restEncoder, e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    vh(this.restEncoder, e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    Ts(this.restEncoder, e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    ot(this.restEncoder, e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    ot(this.restEncoder, e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    ot(this.restEncoder, e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    ml(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    Kn(this.restEncoder, e);
  }
  /**
   * @param {any} embed
   */
  writeJSON(e) {
    Ts(this.restEncoder, JSON.stringify(e));
  }
  /**
   * @param {string} key
   */
  writeKey(e) {
    Ts(this.restEncoder, e);
  }
}
class tD {
  constructor() {
    this.restEncoder = Yp(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return wi(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    const n = e - this.dsCurrVal;
    this.dsCurrVal = e, ot(this.restEncoder, n);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    e === 0 && Vo(), ot(this.restEncoder, e - 1), this.dsCurrVal += e;
  }
}
class nD extends tD {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new df(), this.clientEncoder = new Lc(), this.leftClockEncoder = new df(), this.rightClockEncoder = new df(), this.infoEncoder = new pb(vh), this.stringEncoder = new mA(), this.parentInfoEncoder = new pb(vh), this.typeRefEncoder = new Lc(), this.lenEncoder = new Lc();
  }
  toUint8Array() {
    const e = Yp();
    return ot(e, 0), Kn(e, this.keyClockEncoder.toUint8Array()), Kn(e, this.clientEncoder.toUint8Array()), Kn(e, this.leftClockEncoder.toUint8Array()), Kn(e, this.rightClockEncoder.toUint8Array()), Kn(e, wi(this.infoEncoder)), Kn(e, this.stringEncoder.toUint8Array()), Kn(e, wi(this.parentInfoEncoder)), Kn(e, this.typeRefEncoder.toUint8Array()), Kn(e, this.lenEncoder.toUint8Array()), Zp(e, wi(this.restEncoder)), wi(e);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(e) {
    this.clientEncoder.write(e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    this.infoEncoder.write(e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    this.stringEncoder.write(e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    this.parentInfoEncoder.write(e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    this.typeRefEncoder.write(e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    this.lenEncoder.write(e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    ml(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    Kn(this.restEncoder, e);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(e) {
    ml(this.restEncoder, e);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(e) {
    const n = this.keyMap.get(e);
    n === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(n);
  }
}
const rD = (t, e, n, r) => {
  r = ya(r, e[0].id.clock);
  const i = yi(e, r);
  ot(t.restEncoder, e.length - i), t.writeClient(n), ot(t.restEncoder, r);
  const o = e[i];
  o.write(t, r - o.id.clock);
  for (let s = i + 1; s < e.length; s++)
    e[s].write(t, 0);
}, iD = (t, e, n) => {
  const r = /* @__PURE__ */ new Map();
  n.forEach((i, o) => {
    Dn(e, o) > i && r.set(o, i);
  }), rg(e).forEach((i, o) => {
    n.has(o) || r.set(o, 0);
  }), ot(t.restEncoder, r.size), Ws(r.entries()).sort((i, o) => o[0] - i[0]).forEach(([i, o]) => {
    rD(
      t,
      /** @type {Array<GC|Item>} */
      e.clients.get(i),
      i,
      o
    );
  });
}, oD = (t, e) => iD(t, e.doc.store, e.beforeState);
class sD {
  constructor() {
    this.l = [];
  }
}
const vb = () => new sD(), _b = (t, e) => t.l.push(e), xb = (t, e) => {
  const n = t.l, r = n.length;
  t.l = n.filter((i) => e !== i), r === t.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, M_ = (t, e, n) => tg(t.l, [e, n]);
class $c {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(e, n) {
    this.client = e, this.clock = n;
  }
}
const Cc = (t, e) => t === e || t !== null && e !== null && t.client === e.client && t.clock === e.clock, Ct = (t, e) => new $c(t, e), aD = (t) => {
  for (const [e, n] of t.doc.share.entries())
    if (n === t)
      return e;
  throw Vo();
}, ms = (t, e) => e === void 0 ? !t.deleted : e.sv.has(t.id.client) && (e.sv.get(t.id.client) || 0) > t.id.clock && !S_(e.ds, t.id), Ch = (t, e) => {
  const n = ba(t.meta, Ch, Ks), r = t.doc.store;
  n.has(e) || (e.sv.forEach((i, o) => {
    i < Dn(r, o) && Wi(t, Ct(o, i));
  }), N_(t, e.ds, (i) => {
  }), n.add(e));
};
class lD {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const rg = (t) => {
  const e = /* @__PURE__ */ new Map();
  return t.clients.forEach((n, r) => {
    const i = n[n.length - 1];
    e.set(r, i.id.clock + i.length);
  }), e;
}, Dn = (t, e) => {
  const n = t.clients.get(e);
  if (n === void 0)
    return 0;
  const r = n[n.length - 1];
  return r.id.clock + r.length;
}, O_ = (t, e) => {
  let n = t.clients.get(e.id.client);
  if (n === void 0)
    n = [], t.clients.set(e.id.client, n);
  else {
    const r = n[n.length - 1];
    if (r.id.clock + r.length !== e.id.clock)
      throw Vo();
  }
  n.push(e);
}, yi = (t, e) => {
  let n = 0, r = t.length - 1, i = t[r], o = i.id.clock;
  if (o === e)
    return r;
  let s = zo(e / (o + i.length - 1) * r);
  for (; n <= r; ) {
    if (i = t[s], o = i.id.clock, o <= e) {
      if (e < o + i.length)
        return s;
      n = s + 1;
    } else
      r = s - 1;
    s = zo((n + r) / 2);
  }
  throw Vo();
}, cD = (t, e) => {
  const n = t.clients.get(e.client);
  return n[yi(n, e.clock)];
}, hf = (
  /** @type {function(StructStore,ID):Item} */
  cD
), kh = (t, e, n) => {
  const r = yi(e, n), i = e[r];
  return i.id.clock < n && i instanceof dn ? (e.splice(r + 1, 0, Q_(t, i, n - i.id.clock)), r + 1) : r;
}, Wi = (t, e) => {
  const n = (
    /** @type {Array<Item>} */
    t.doc.store.clients.get(e.client)
  );
  return n[kh(t, n, e.clock)];
}, Cb = (t, e, n) => {
  const r = e.clients.get(n.client), i = yi(r, n.clock), o = r[i];
  return n.clock !== o.id.clock + o.length - 1 && o.constructor !== Oi && r.splice(i + 1, 0, Q_(t, o, n.clock - o.id.clock + 1)), o;
}, uD = (t, e, n) => {
  const r = (
    /** @type {Array<GC|Item>} */
    t.clients.get(e.id.client)
  );
  r[yi(r, e.id.clock)] = n;
}, I_ = (t, e, n, r, i) => {
  if (r === 0)
    return;
  const o = n + r;
  let s = kh(t, e, n), a;
  do
    a = e[s++], o < a.id.clock + a.length && kh(t, e, o), i(a);
  while (s < e.length && e[s].id.clock < o);
};
class dD {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(e, n, r) {
    this.doc = e, this.deleteSet = new XA(), this.beforeState = rg(e.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = n, this.meta = /* @__PURE__ */ new Map(), this.local = r, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const kb = (t, e) => e.deleteSet.clients.size === 0 && !WT(e.afterState, (n, r) => e.beforeState.get(r) !== n) ? !1 : (T_(e.deleteSet), oD(t, e), QA(t, e.deleteSet), !0), Eb = (t, e, n) => {
  const r = e._item;
  (r === null || r.id.clock < (t.beforeState.get(r.id.client) || 0) && !r.deleted) && ba(t.changed, e, Ks).add(n);
}, Fc = (t, e) => {
  let n = t[e], r = t[e - 1], i = e;
  for (; i > 0; n = r, r = t[--i - 1]) {
    if (r.deleted === n.deleted && r.constructor === n.constructor && r.mergeWith(n)) {
      n instanceof dn && n.parentSub !== null && /** @type {AbstractType<any>} */
      n.parent._map.get(n.parentSub) === n && n.parent._map.set(
        n.parentSub,
        /** @type {Item} */
        r
      );
      continue;
    }
    break;
  }
  const o = e - i;
  return o && t.splice(e + 1 - o, o), o;
}, fD = (t, e, n) => {
  for (const [r, i] of t.clients.entries()) {
    const o = (
      /** @type {Array<GC|Item>} */
      e.clients.get(r)
    );
    for (let s = i.length - 1; s >= 0; s--) {
      const a = i[s], l = a.clock + a.len;
      for (let c = yi(o, a.clock), u = o[c]; c < o.length && u.id.clock < l; u = o[++c]) {
        const f = o[c];
        if (a.clock + a.len <= f.id.clock)
          break;
        f instanceof dn && f.deleted && !f.keep && n(f) && f.gc(e, !1);
      }
    }
  }
}, hD = (t, e) => {
  t.clients.forEach((n, r) => {
    const i = (
      /** @type {Array<GC|Item>} */
      e.clients.get(r)
    );
    for (let o = n.length - 1; o >= 0; o--) {
      const s = n[o], a = p_(i.length - 1, 1 + yi(i, s.clock + s.len - 1));
      for (let l = a, c = i[l]; l > 0 && c.id.clock >= s.clock; c = i[l])
        l -= 1 + Fc(i, l);
    }
  });
}, R_ = (t, e) => {
  if (e < t.length) {
    const n = t[e], r = n.doc, i = r.store, o = n.deleteSet, s = n._mergeStructs;
    try {
      T_(o), n.afterState = rg(n.doc.store), r.emit("beforeObserverCalls", [n, r]);
      const a = [];
      n.changed.forEach(
        (l, c) => a.push(() => {
          (c._item === null || !c._item.deleted) && c._callObserver(n, l);
        })
      ), a.push(() => {
        n.changedParentTypes.forEach((l, c) => {
          c._dEH.l.length > 0 && (c._item === null || !c._item.deleted) && (l = l.filter(
            (u) => u.target._item === null || !u.target._item.deleted
          ), l.forEach((u) => {
            u.currentTarget = c, u._path = null;
          }), l.sort((u, f) => u.path.length - f.path.length), M_(c._dEH, l, n));
        });
      }), a.push(() => r.emit("afterTransaction", [n, r])), tg(a, []), n._needFormattingCleanup && kD(n);
    } finally {
      r.gc && fD(o, i, r.gcFilter), hD(o, i), n.afterState.forEach((u, f) => {
        const d = n.beforeState.get(f) || 0;
        if (d !== u) {
          const h = (
            /** @type {Array<GC|Item>} */
            i.clients.get(f)
          ), g = ya(yi(h, d), 1);
          for (let w = h.length - 1; w >= g; )
            w -= 1 + Fc(h, w);
        }
      });
      for (let u = s.length - 1; u >= 0; u--) {
        const { client: f, clock: d } = s[u].id, h = (
          /** @type {Array<GC|Item>} */
          i.clients.get(f)
        ), g = yi(h, d);
        g + 1 < h.length && Fc(h, g + 1) > 1 || g > 0 && Fc(h, g);
      }
      if (!n.local && n.afterState.get(r.clientID) !== n.beforeState.get(r.clientID) && (KA(ng, v_, "[yjs] ", __, x_, "Changed the client-id because another client seems to be using it."), r.clientID = D_()), r.emit("afterTransactionCleanup", [n, r]), r._observers.has("update")) {
        const u = new eD();
        kb(u, n) && r.emit("update", [u.toUint8Array(), n.origin, r, n]);
      }
      if (r._observers.has("updateV2")) {
        const u = new nD();
        kb(u, n) && r.emit("updateV2", [u.toUint8Array(), n.origin, r, n]);
      }
      const { subdocsAdded: a, subdocsLoaded: l, subdocsRemoved: c } = n;
      (a.size > 0 || c.size > 0 || l.size > 0) && (a.forEach((u) => {
        u.clientID = r.clientID, u.collectionid == null && (u.collectionid = r.collectionid), r.subdocs.add(u);
      }), c.forEach((u) => r.subdocs.delete(u)), r.emit("subdocs", [{ loaded: l, added: a, removed: c }, r, n]), c.forEach((u) => u.destroy())), t.length <= e + 1 ? (r._transactionCleanups = [], r.emit("afterAllTransactions", [r, t])) : R_(t, e + 1);
    }
  }
}, ut = (t, e, n = null, r = !0) => {
  const i = t._transactionCleanups;
  let o = !1, s = null;
  t._transaction === null && (o = !0, t._transaction = new dD(t, n, r), i.push(t._transaction), i.length === 1 && t.emit("beforeAllTransactions", [t]), t.emit("beforeTransaction", [t._transaction, t]));
  try {
    s = e(t._transaction);
  } finally {
    if (o) {
      const a = t._transaction === i[0];
      t._transaction = null, a && R_(i, 0);
    }
  }
  return s;
}, Nb = "You must not compute changes after the event-handler fired.";
class ad {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(e, n) {
    this.target = e, this.currentTarget = e, this.transaction = n, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = pD(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(e) {
    return S_(this.transaction.deleteSet, e.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw Gs(Nb);
      const e = /* @__PURE__ */ new Map(), n = this.target;
      /** @type Set<string|null> */
      this.transaction.changed.get(n).forEach((i) => {
        if (i !== null) {
          const o = (
            /** @type {Item} */
            n._map.get(i)
          );
          let s, a;
          if (this.adds(o)) {
            let l = o.left;
            for (; l !== null && this.adds(l); )
              l = l.left;
            if (this.deletes(o))
              if (l !== null && this.deletes(l))
                s = "delete", a = af(l.content.getContent());
              else
                return;
            else
              l !== null && this.deletes(l) ? (s = "update", a = af(l.content.getContent())) : (s = "add", a = void 0);
          } else if (this.deletes(o))
            s = "delete", a = af(
              /** @type {Item} */
              o.content.getContent()
            );
          else
            return;
          e.set(i, { action: s, oldValue: a });
        }
      }), this._keys = e;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(e) {
    return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let e = this._changes;
    if (e === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw Gs(Nb);
      const n = this.target, r = Ks(), i = Ks(), o = [];
      if (e = {
        added: r,
        deleted: i,
        delta: o,
        keys: this.keys
      }, /** @type Set<string|null> */
      this.transaction.changed.get(n).has(null)) {
        let a = null;
        const l = () => {
          a && o.push(a);
        };
        for (let c = n._start; c !== null; c = c.right)
          c.deleted ? this.deletes(c) && !this.adds(c) && ((a === null || a.delete === void 0) && (l(), a = { delete: 0 }), a.delete += c.length, i.add(c)) : this.adds(c) ? ((a === null || a.insert === void 0) && (l(), a = { insert: [] }), a.insert = a.insert.concat(c.content.getContent()), r.add(c)) : ((a === null || a.retain === void 0) && (l(), a = { retain: 0 }), a.retain += c.length);
        a !== null && a.retain === void 0 && l();
      }
      this._changes = e;
    }
    return (
      /** @type {any} */
      e
    );
  }
}
const pD = (t, e) => {
  const n = [];
  for (; e._item !== null && e !== t; ) {
    if (e._item.parentSub !== null)
      n.unshift(e._item.parentSub);
    else {
      let r = 0, i = (
        /** @type {AbstractType<any>} */
        e._item.parent._start
      );
      for (; i !== e._item && i !== null; )
        !i.deleted && i.countable && (r += i.length), i = i.right;
      n.unshift(r);
    }
    e = /** @type {AbstractType<any>} */
    e._item.parent;
  }
  return n;
}, hn = () => {
  WA("Invalid access: Add Yjs type to a document before reading data.");
}, P_ = 80;
let ig = 0;
class gD {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(e, n) {
    e.marker = !0, this.p = e, this.index = n, this.timestamp = ig++;
  }
}
const wD = (t) => {
  t.timestamp = ig++;
}, L_ = (t, e, n) => {
  t.p.marker = !1, t.p = e, e.marker = !0, t.index = n, t.timestamp = ig++;
}, mD = (t, e, n) => {
  if (t.length >= P_) {
    const r = t.reduce((i, o) => i.timestamp < o.timestamp ? i : o);
    return L_(r, e, n), r;
  } else {
    const r = new gD(e, n);
    return t.push(r), r;
  }
}, ld = (t, e) => {
  if (t._start === null || e === 0 || t._searchMarker === null)
    return null;
  const n = t._searchMarker.length === 0 ? null : t._searchMarker.reduce((o, s) => Pc(e - o.index) < Pc(e - s.index) ? o : s);
  let r = t._start, i = 0;
  for (n !== null && (r = n.p, i = n.index, wD(n)); r.right !== null && i < e; ) {
    if (!r.deleted && r.countable) {
      if (e < i + r.length)
        break;
      i += r.length;
    }
    r = r.right;
  }
  for (; r.left !== null && i > e; )
    r = r.left, !r.deleted && r.countable && (i -= r.length);
  for (; r.left !== null && r.left.id.client === r.id.client && r.left.id.clock + r.left.length === r.id.clock; )
    r = r.left, !r.deleted && r.countable && (i -= r.length);
  return n !== null && Pc(n.index - i) < /** @type {YText|YArray<any>} */
  r.parent.length / P_ ? (L_(n, r, i), n) : mD(t._searchMarker, r, i);
}, yl = (t, e, n) => {
  for (let r = t.length - 1; r >= 0; r--) {
    const i = t[r];
    if (n > 0) {
      let o = i.p;
      for (o.marker = !1; o && (o.deleted || !o.countable); )
        o = o.left, o && !o.deleted && o.countable && (i.index -= o.length);
      if (o === null || o.marker === !0) {
        t.splice(r, 1);
        continue;
      }
      i.p = o, o.marker = !0;
    }
    (e < i.index || n > 0 && e === i.index) && (i.index = ya(e, i.index + n));
  }
}, cd = (t, e, n) => {
  const r = t, i = e.changedParentTypes;
  for (; ba(i, t, () => []).push(n), t._item !== null; )
    t = /** @type {AbstractType<any>} */
    t._item.parent;
  M_(r._eH, n, e);
};
class rn {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = vb(), this._dEH = vb(), this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(e, n) {
    this.doc = e, this._item = n;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw Gr();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw Gr();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(e) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let e = this._start;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    !e.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(e) {
    _b(this._eH, e);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(e) {
    _b(this._dEH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(e) {
    xb(this._eH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(e) {
    xb(this._dEH, e);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const $_ = (t, e, n) => {
  t.doc ?? hn(), e < 0 && (e = t._length + e), n < 0 && (n = t._length + n);
  let r = n - e;
  const i = [];
  let o = t._start;
  for (; o !== null && r > 0; ) {
    if (o.countable && !o.deleted) {
      const s = o.content.getContent();
      if (s.length <= e)
        e -= s.length;
      else {
        for (let a = e; a < s.length && r > 0; a++)
          i.push(s[a]), r--;
        e = 0;
      }
    }
    o = o.right;
  }
  return i;
}, F_ = (t) => {
  t.doc ?? hn();
  const e = [];
  let n = t._start;
  for (; n !== null; ) {
    if (n.countable && !n.deleted) {
      const r = n.content.getContent();
      for (let i = 0; i < r.length; i++)
        e.push(r[i]);
    }
    n = n.right;
  }
  return e;
}, vl = (t, e) => {
  let n = 0, r = t._start;
  for (t.doc ?? hn(); r !== null; ) {
    if (r.countable && !r.deleted) {
      const i = r.content.getContent();
      for (let o = 0; o < i.length; o++)
        e(i[o], n++, t);
    }
    r = r.right;
  }
}, B_ = (t, e) => {
  const n = [];
  return vl(t, (r, i) => {
    n.push(e(r, i, t));
  }), n;
}, bD = (t) => {
  let e = t._start, n = null, r = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (n === null) {
        for (; e !== null && e.deleted; )
          e = e.right;
        if (e === null)
          return {
            done: !0,
            value: void 0
          };
        n = e.content.getContent(), r = 0, e = e.right;
      }
      const i = n[r++];
      return n.length <= r && (n = null), {
        done: !1,
        value: i
      };
    }
  };
}, q_ = (t, e) => {
  t.doc ?? hn();
  const n = ld(t, e);
  let r = t._start;
  for (n !== null && (r = n.p, e -= n.index); r !== null; r = r.right)
    if (!r.deleted && r.countable) {
      if (e < r.length)
        return r.content.getContent()[e];
      e -= r.length;
    }
}, bu = (t, e, n, r) => {
  let i = n;
  const o = t.doc, s = o.clientID, a = o.store, l = n === null ? e._start : n.right;
  let c = [];
  const u = () => {
    c.length > 0 && (i = new dn(Ct(s, Dn(a, s)), i, i && i.lastId, l, l && l.id, e, null, new Ys(c)), i.integrate(t, 0), c = []);
  };
  r.forEach((f) => {
    if (f === null)
      c.push(f);
    else
      switch (f.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          c.push(f);
          break;
        default:
          switch (u(), f.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              i = new dn(Ct(s, Dn(a, s)), i, i && i.lastId, l, l && l.id, e, null, new ud(new Uint8Array(
                /** @type {Uint8Array} */
                f
              ))), i.integrate(t, 0);
              break;
            case Hl:
              i = new dn(Ct(s, Dn(a, s)), i, i && i.lastId, l, l && l.id, e, null, new dd(
                /** @type {Doc} */
                f
              )), i.integrate(t, 0);
              break;
            default:
              if (f instanceof rn)
                i = new dn(Ct(s, Dn(a, s)), i, i && i.lastId, l, l && l.id, e, null, new ro(f)), i.integrate(t, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), u();
}, j_ = () => Gs("Length exceeded!"), U_ = (t, e, n, r) => {
  if (n > e._length)
    throw j_();
  if (n === 0)
    return e._searchMarker && yl(e._searchMarker, n, r.length), bu(t, e, null, r);
  const i = n, o = ld(e, n);
  let s = e._start;
  for (o !== null && (s = o.p, n -= o.index, n === 0 && (s = s.prev, n += s && s.countable && !s.deleted ? s.length : 0)); s !== null; s = s.right)
    if (!s.deleted && s.countable) {
      if (n <= s.length) {
        n < s.length && Wi(t, Ct(s.id.client, s.id.clock + n));
        break;
      }
      n -= s.length;
    }
  return e._searchMarker && yl(e._searchMarker, i, r.length), bu(t, e, s, r);
}, yD = (t, e, n) => {
  let i = (e._searchMarker || []).reduce((o, s) => s.index > o.index ? s : o, { index: 0, p: e._start }).p;
  if (i)
    for (; i.right; )
      i = i.right;
  return bu(t, e, i, n);
}, z_ = (t, e, n, r) => {
  if (r === 0)
    return;
  const i = n, o = r, s = ld(e, n);
  let a = e._start;
  for (s !== null && (a = s.p, n -= s.index); a !== null && n > 0; a = a.right)
    !a.deleted && a.countable && (n < a.length && Wi(t, Ct(a.id.client, a.id.clock + n)), n -= a.length);
  for (; r > 0 && a !== null; )
    a.deleted || (r < a.length && Wi(t, Ct(a.id.client, a.id.clock + r)), a.delete(t), r -= a.length), a = a.right;
  if (r > 0)
    throw j_();
  e._searchMarker && yl(
    e._searchMarker,
    i,
    -o + r
    /* in case we remove the above exception */
  );
}, yu = (t, e, n) => {
  const r = e._map.get(n);
  r !== void 0 && r.delete(t);
}, og = (t, e, n, r) => {
  const i = e._map.get(n) || null, o = t.doc, s = o.clientID;
  let a;
  if (r == null)
    a = new Ys([r]);
  else
    switch (r.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
      case Date:
      case BigInt:
        a = new Ys([r]);
        break;
      case Uint8Array:
        a = new ud(
          /** @type {Uint8Array} */
          r
        );
        break;
      case Hl:
        a = new dd(
          /** @type {Doc} */
          r
        );
        break;
      default:
        if (r instanceof rn)
          a = new ro(r);
        else
          throw new Error("Unexpected content type");
    }
  new dn(Ct(s, Dn(o.store, s)), i, i && i.lastId, null, null, e, n, a).integrate(t, 0);
}, sg = (t, e) => {
  t.doc ?? hn();
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted ? n.content.getContent()[n.length - 1] : void 0;
}, V_ = (t) => {
  const e = {};
  return t.doc ?? hn(), t._map.forEach((n, r) => {
    n.deleted || (e[r] = n.content.getContent()[n.length - 1]);
  }), e;
}, H_ = (t, e) => {
  t.doc ?? hn();
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted;
}, vD = (t, e) => {
  const n = {};
  return t._map.forEach((r, i) => {
    let o = r;
    for (; o !== null && (!e.sv.has(o.id.client) || o.id.clock >= (e.sv.get(o.id.client) || 0)); )
      o = o.left;
    o !== null && ms(o, e) && (n[i] = o.content.getContent()[o.length - 1]);
  }), n;
}, kc = (t) => (t.doc ?? hn(), GA(
  t._map.entries(),
  /** @param {any} entry */
  (e) => !e[1].deleted
));
class K_ extends ad {
}
class Do extends rn {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(e) {
    const n = new Do();
    return n.push(e), n;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new Do();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const e = new Do();
    return e.insert(0, this.toArray().map(
      (n) => n instanceof rn ? (
        /** @type {typeof el} */
        n.clone()
      ) : n
    )), e;
  }
  get length() {
    return this.doc ?? hn(), this._length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n), cd(this, e, new K_(this, e));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? ut(this.doc, (r) => {
      U_(
        r,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(e) {
    this.doc !== null ? ut(this.doc, (n) => {
      yD(
        n,
        this,
        /** @type {any} */
        e
      );
    }) : this._prelimContent.push(...e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? ut(this.doc, (r) => {
      z_(r, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(e) {
    return q_(this, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return F_(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(e = 0, n = this.length) {
    return $_(this, e, n);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((e) => e instanceof rn ? e.toJSON() : e);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(e) {
    return B_(
      this,
      /** @type {any} */
      e
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    vl(this, e);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return bD(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(DD);
  }
}
class _D extends ad {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(e, n, r) {
    super(e, n), this.keysChanged = r;
  }
}
class Js extends rn {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(e) {
    super(), this._prelimContent = null, e === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(e);
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this._prelimContent.forEach((r, i) => {
      this.set(i, r);
    }), this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new Js();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const e = new Js();
    return this.forEach((n, r) => {
      e.set(r, n instanceof rn ? (
        /** @type {typeof value} */
        n.clone()
      ) : n);
    }), e;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    cd(this, e, new _D(this, e, n));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    this.doc ?? hn();
    const e = {};
    return this._map.forEach((n, r) => {
      if (!n.deleted) {
        const i = n.content.getContent()[n.length - 1];
        e[r] = i instanceof rn ? i.toJSON() : i;
      }
    }), e;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...kc(this)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return ff(
      kc(this),
      /** @param {any} v */
      (e) => e[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return ff(
      kc(this),
      /** @param {any} v */
      (e) => e[1].content.getContent()[e[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return ff(
      kc(this),
      /** @param {any} v */
      (e) => (
        /** @type {any} */
        [e[0], e[1].content.getContent()[e[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    this.doc ?? hn(), this._map.forEach((n, r) => {
      n.deleted || e(n.content.getContent()[n.length - 1], r, this);
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(e) {
    this.doc !== null ? ut(this.doc, (n) => {
      yu(n, this, e);
    }) : this._prelimContent.delete(e);
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(e, n) {
    return this.doc !== null ? ut(this.doc, (r) => {
      og(
        r,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.set(e, n), n;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(e) {
    return (
      /** @type {any} */
      sg(this, e)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(e) {
    return H_(this, e);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    this.doc !== null ? ut(this.doc, (e) => {
      this.forEach(function(n, r, i) {
        yu(e, i, r);
      });
    }) : this._prelimContent.clear();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(MD);
  }
}
const Li = (t, e) => t === e || typeof t == "object" && typeof e == "object" && t && e && DA(t, e);
class Eh {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(e, n, r, i) {
    this.left = e, this.right = n, this.index = r, this.currentAttributes = i;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    switch (this.right === null && Vo(), this.right.content.constructor) {
      case Kt:
        this.right.deleted || va(
          this.currentAttributes,
          /** @type {ContentFormat} */
          this.right.content
        );
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const Sb = (t, e, n) => {
  for (; e.right !== null && n > 0; ) {
    switch (e.right.content.constructor) {
      case Kt:
        e.right.deleted || va(
          e.currentAttributes,
          /** @type {ContentFormat} */
          e.right.content
        );
        break;
      default:
        e.right.deleted || (n < e.right.length && Wi(t, Ct(e.right.id.client, e.right.id.clock + n)), e.index += e.right.length, n -= e.right.length);
        break;
    }
    e.left = e.right, e.right = e.right.right;
  }
  return e;
}, Ec = (t, e, n, r) => {
  const i = /* @__PURE__ */ new Map(), o = r ? ld(e, n) : null;
  if (o) {
    const s = new Eh(o.p.left, o.p, o.index, i);
    return Sb(t, s, n - o.index);
  } else {
    const s = new Eh(null, e._start, 0, i);
    return Sb(t, s, n);
  }
}, W_ = (t, e, n, r) => {
  for (; n.right !== null && (n.right.deleted === !0 || n.right.content.constructor === Kt && Li(
    r.get(
      /** @type {ContentFormat} */
      n.right.content.key
    ),
    /** @type {ContentFormat} */
    n.right.content.value
  )); )
    n.right.deleted || r.delete(
      /** @type {ContentFormat} */
      n.right.content.key
    ), n.forward();
  const i = t.doc, o = i.clientID;
  r.forEach((s, a) => {
    const l = n.left, c = n.right, u = new dn(Ct(o, Dn(i.store, o)), l, l && l.lastId, c, c && c.id, e, null, new Kt(a, s));
    u.integrate(t, 0), n.right = u, n.forward();
  });
}, va = (t, e) => {
  const { key: n, value: r } = e;
  r === null ? t.delete(n) : t.set(n, r);
}, G_ = (t, e) => {
  for (; t.right !== null; ) {
    if (!(t.right.deleted || t.right.content.constructor === Kt && Li(
      e[
        /** @type {ContentFormat} */
        t.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      t.right.content.value
    ))) break;
    t.forward();
  }
}, J_ = (t, e, n, r) => {
  const i = t.doc, o = i.clientID, s = /* @__PURE__ */ new Map();
  for (const a in r) {
    const l = r[a], c = n.currentAttributes.get(a) ?? null;
    if (!Li(c, l)) {
      s.set(a, c);
      const { left: u, right: f } = n;
      n.right = new dn(Ct(o, Dn(i.store, o)), u, u && u.lastId, f, f && f.id, e, null, new Kt(a, l)), n.right.integrate(t, 0), n.forward();
    }
  }
  return s;
}, pf = (t, e, n, r, i) => {
  n.currentAttributes.forEach((d, h) => {
    i[h] === void 0 && (i[h] = null);
  });
  const o = t.doc, s = o.clientID;
  G_(n, i);
  const a = J_(t, e, n, i), l = r.constructor === String ? new vi(
    /** @type {string} */
    r
  ) : r instanceof rn ? new ro(r) : new _a(r);
  let { left: c, right: u, index: f } = n;
  e._searchMarker && yl(e._searchMarker, n.index, l.getLength()), u = new dn(Ct(s, Dn(o.store, s)), c, c && c.lastId, u, u && u.id, e, null, l), u.integrate(t, 0), n.right = u, n.index = f, n.forward(), W_(t, e, n, a);
}, Tb = (t, e, n, r, i) => {
  const o = t.doc, s = o.clientID;
  G_(n, i);
  const a = J_(t, e, n, i);
  e: for (; n.right !== null && (r > 0 || a.size > 0 && (n.right.deleted || n.right.content.constructor === Kt)); ) {
    if (!n.right.deleted)
      switch (n.right.content.constructor) {
        case Kt: {
          const { key: l, value: c } = (
            /** @type {ContentFormat} */
            n.right.content
          ), u = i[l];
          if (u !== void 0) {
            if (Li(u, c))
              a.delete(l);
            else {
              if (r === 0)
                break e;
              a.set(l, c);
            }
            n.right.delete(t);
          } else
            n.currentAttributes.set(l, c);
          break;
        }
        default:
          r < n.right.length && Wi(t, Ct(n.right.id.client, n.right.id.clock + r)), r -= n.right.length;
          break;
      }
    n.forward();
  }
  if (r > 0) {
    let l = "";
    for (; r > 0; r--)
      l += `
`;
    n.right = new dn(Ct(s, Dn(o.store, s)), n.left, n.left && n.left.lastId, n.right, n.right && n.right.id, e, null, new vi(l)), n.right.integrate(t, 0), n.forward();
  }
  W_(t, e, n, a);
}, X_ = (t, e, n, r, i) => {
  let o = e;
  const s = Wr();
  for (; o && (!o.countable || o.deleted); ) {
    if (!o.deleted && o.content.constructor === Kt) {
      const c = (
        /** @type {ContentFormat} */
        o.content
      );
      s.set(c.key, c);
    }
    o = o.right;
  }
  let a = 0, l = !1;
  for (; e !== o; ) {
    if (n === e && (l = !0), !e.deleted) {
      const c = e.content;
      switch (c.constructor) {
        case Kt: {
          const { key: u, value: f } = (
            /** @type {ContentFormat} */
            c
          ), d = r.get(u) ?? null;
          (s.get(u) !== c || d === f) && (e.delete(t), a++, !l && (i.get(u) ?? null) === f && d !== f && (d === null ? i.delete(u) : i.set(u, d))), !l && !e.deleted && va(
            i,
            /** @type {ContentFormat} */
            c
          );
          break;
        }
      }
    }
    e = /** @type {Item} */
    e.right;
  }
  return a;
}, xD = (t, e) => {
  for (; e && e.right && (e.right.deleted || !e.right.countable); )
    e = e.right;
  const n = /* @__PURE__ */ new Set();
  for (; e && (e.deleted || !e.countable); ) {
    if (!e.deleted && e.content.constructor === Kt) {
      const r = (
        /** @type {ContentFormat} */
        e.content.key
      );
      n.has(r) ? e.delete(t) : n.add(r);
    }
    e = e.left;
  }
}, CD = (t) => {
  let e = 0;
  return ut(
    /** @type {Doc} */
    t.doc,
    (n) => {
      let r = (
        /** @type {Item} */
        t._start
      ), i = t._start, o = Wr();
      const s = yh(o);
      for (; i; ) {
        if (i.deleted === !1)
          switch (i.content.constructor) {
            case Kt:
              va(
                s,
                /** @type {ContentFormat} */
                i.content
              );
              break;
            default:
              e += X_(n, r, i, o, s), o = yh(s), r = i;
              break;
          }
        i = i.right;
      }
    }
  ), e;
}, kD = (t) => {
  const e = /* @__PURE__ */ new Set(), n = t.doc;
  for (const [r, i] of t.afterState.entries()) {
    const o = t.beforeState.get(r) || 0;
    i !== o && I_(
      t,
      /** @type {Array<Item|GC>} */
      n.store.clients.get(r),
      o,
      i,
      (s) => {
        !s.deleted && /** @type {Item} */
        s.content.constructor === Kt && s.constructor !== Oi && e.add(
          /** @type {any} */
          s.parent
        );
      }
    );
  }
  ut(n, (r) => {
    N_(t, t.deleteSet, (i) => {
      if (i instanceof Oi || !/** @type {YText} */
      i.parent._hasFormatting || e.has(
        /** @type {YText} */
        i.parent
      ))
        return;
      const o = (
        /** @type {YText} */
        i.parent
      );
      i.content.constructor === Kt ? e.add(o) : xD(r, i);
    });
    for (const i of e)
      CD(i);
  });
}, Ab = (t, e, n) => {
  const r = n, i = yh(e.currentAttributes), o = e.right;
  for (; n > 0 && e.right !== null; ) {
    if (e.right.deleted === !1)
      switch (e.right.content.constructor) {
        case ro:
        case _a:
        case vi:
          n < e.right.length && Wi(t, Ct(e.right.id.client, e.right.id.clock + n)), n -= e.right.length, e.right.delete(t);
          break;
      }
    e.forward();
  }
  o && X_(t, o, e.right, i, e.currentAttributes);
  const s = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (e.left || e.right).parent
  );
  return s._searchMarker && yl(s._searchMarker, e.index, -r + n), e;
};
class ED extends ad {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(e, n, r) {
    super(e, n), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), r.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.keysChanged.add(i);
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const e = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = e;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const e = (
        /** @type {Doc} */
        this.target.doc
      ), n = [];
      ut(e, (r) => {
        const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
        let s = this.target._start, a = null;
        const l = {};
        let c = "", u = 0, f = 0;
        const d = () => {
          if (a !== null) {
            let h = null;
            switch (a) {
              case "delete":
                f > 0 && (h = { delete: f }), f = 0;
                break;
              case "insert":
                (typeof c == "object" || c.length > 0) && (h = { insert: c }, i.size > 0 && (h.attributes = {}, i.forEach((g, w) => {
                  g !== null && (h.attributes[w] = g);
                }))), c = "";
                break;
              case "retain":
                u > 0 && (h = { retain: u }, SA(l) || (h.attributes = kA({}, l))), u = 0;
                break;
            }
            h && n.push(h), a = null;
          }
        };
        for (; s !== null; ) {
          switch (s.content.constructor) {
            case ro:
            case _a:
              this.adds(s) ? this.deletes(s) || (d(), a = "insert", c = s.content.getContent()[0], d()) : this.deletes(s) ? (a !== "delete" && (d(), a = "delete"), f += 1) : s.deleted || (a !== "retain" && (d(), a = "retain"), u += 1);
              break;
            case vi:
              this.adds(s) ? this.deletes(s) || (a !== "insert" && (d(), a = "insert"), c += /** @type {ContentString} */
              s.content.str) : this.deletes(s) ? (a !== "delete" && (d(), a = "delete"), f += s.length) : s.deleted || (a !== "retain" && (d(), a = "retain"), u += s.length);
              break;
            case Kt: {
              const { key: h, value: g } = (
                /** @type {ContentFormat} */
                s.content
              );
              if (this.adds(s)) {
                if (!this.deletes(s)) {
                  const w = i.get(h) ?? null;
                  Li(w, g) ? g !== null && s.delete(r) : (a === "retain" && d(), Li(g, o.get(h) ?? null) ? delete l[h] : l[h] = g);
                }
              } else if (this.deletes(s)) {
                o.set(h, g);
                const w = i.get(h) ?? null;
                Li(w, g) || (a === "retain" && d(), l[h] = w);
              } else if (!s.deleted) {
                o.set(h, g);
                const w = l[h];
                w !== void 0 && (Li(w, g) ? w !== null && s.delete(r) : (a === "retain" && d(), g === null ? delete l[h] : l[h] = g));
              }
              s.deleted || (a === "insert" && d(), va(
                i,
                /** @type {ContentFormat} */
                s.content
              ));
              break;
            }
          }
          s = s.right;
        }
        for (d(); n.length > 0; ) {
          const h = n[n.length - 1];
          if (h.retain !== void 0 && h.attributes === void 0)
            n.pop();
          else
            break;
        }
      }), this._delta = n;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class vu extends rn {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(e) {
    super(), this._pending = e !== void 0 ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this.doc ?? hn(), this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n);
    try {
      this._pending.forEach((r) => r());
    } catch (r) {
      console.error(r);
    }
    this._pending = null;
  }
  _copy() {
    return new vu();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const e = new vu();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n);
    const r = new ED(this, e, n);
    cd(this, e, r), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    this.doc ?? hn();
    let e = "", n = this._start;
    for (; n !== null; )
      !n.deleted && n.countable && n.content.constructor === vi && (e += /** @type {ContentString} */
      n.content.str), n = n.right;
    return e;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {Array<any>} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(e, { sanitize: n = !0 } = {}) {
    this.doc !== null ? ut(this.doc, (r) => {
      const i = new Eh(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let o = 0; o < e.length; o++) {
        const s = e[o];
        if (s.insert !== void 0) {
          const a = !n && typeof s.insert == "string" && o === e.length - 1 && i.right === null && s.insert.slice(-1) === `
` ? s.insert.slice(0, -1) : s.insert;
          (typeof a != "string" || a.length > 0) && pf(r, this, i, a, s.attributes || {});
        } else s.retain !== void 0 ? Tb(r, this, i, s.retain, s.attributes || {}) : s.delete !== void 0 && Ab(r, i, s.delete);
      }
    }) : this._pending.push(() => this.applyDelta(e));
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(e, n, r) {
    this.doc ?? hn();
    const i = [], o = /* @__PURE__ */ new Map(), s = (
      /** @type {Doc} */
      this.doc
    );
    let a = "", l = this._start;
    function c() {
      if (a.length > 0) {
        const f = {};
        let d = !1;
        o.forEach((g, w) => {
          d = !0, f[w] = g;
        });
        const h = { insert: a };
        d && (h.attributes = f), i.push(h), a = "";
      }
    }
    const u = () => {
      for (; l !== null; ) {
        if (ms(l, e) || n !== void 0 && ms(l, n))
          switch (l.content.constructor) {
            case vi: {
              const f = o.get("ychange");
              e !== void 0 && !ms(l, e) ? (f === void 0 || f.user !== l.id.client || f.type !== "removed") && (c(), o.set("ychange", r ? r("removed", l.id) : { type: "removed" })) : n !== void 0 && !ms(l, n) ? (f === void 0 || f.user !== l.id.client || f.type !== "added") && (c(), o.set("ychange", r ? r("added", l.id) : { type: "added" })) : f !== void 0 && (c(), o.delete("ychange")), a += /** @type {ContentString} */
              l.content.str;
              break;
            }
            case ro:
            case _a: {
              c();
              const f = {
                insert: l.content.getContent()[0]
              };
              if (o.size > 0) {
                const d = (
                  /** @type {Object<string,any>} */
                  {}
                );
                f.attributes = d, o.forEach((h, g) => {
                  d[g] = h;
                });
              }
              i.push(f);
              break;
            }
            case Kt:
              ms(l, e) && (c(), va(
                o,
                /** @type {ContentFormat} */
                l.content
              ));
              break;
          }
        l = l.right;
      }
      c();
    };
    return e || n ? ut(s, (f) => {
      e && Ch(f, e), n && Ch(f, n), u();
    }, "cleanup") : u(), i;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(e, n, r) {
    if (n.length <= 0)
      return;
    const i = this.doc;
    i !== null ? ut(i, (o) => {
      const s = Ec(o, this, e, !r);
      r || (r = {}, s.currentAttributes.forEach((a, l) => {
        r[l] = a;
      })), pf(o, this, s, n, r);
    }) : this._pending.push(() => this.insert(e, n, r));
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(e, n, r) {
    const i = this.doc;
    i !== null ? ut(i, (o) => {
      const s = Ec(o, this, e, !r);
      pf(o, this, s, n, r || {});
    }) : this._pending.push(() => this.insertEmbed(e, n, r || {}));
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(e, n) {
    if (n === 0)
      return;
    const r = this.doc;
    r !== null ? ut(r, (i) => {
      Ab(i, Ec(i, this, e, !0), n);
    }) : this._pending.push(() => this.delete(e, n));
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(e, n, r) {
    if (n === 0)
      return;
    const i = this.doc;
    i !== null ? ut(i, (o) => {
      const s = Ec(o, this, e, !1);
      s.right !== null && Tb(o, this, s, n, r);
    }) : this._pending.push(() => this.format(e, n, r));
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? ut(this.doc, (n) => {
      yu(n, this, e);
    }) : this._pending.push(() => this.removeAttribute(e));
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? ut(this.doc, (r) => {
      og(r, this, e, n);
    }) : this._pending.push(() => this.setAttribute(e, n));
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      sg(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return V_(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(OD);
  }
}
class gf {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(e, n = () => !0) {
    this._filter = n, this._root = e, this._currentNode = /** @type {Item} */
    e._start, this._firstCall = !0, e.doc ?? hn();
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let e = this._currentNode, n = e && e.content && /** @type {any} */
    e.content.type;
    if (e !== null && (!this._firstCall || e.deleted || !this._filter(n)))
      do
        if (n = /** @type {any} */
        e.content.type, !e.deleted && (n.constructor === _l || n.constructor === Xs) && n._start !== null)
          e = n._start;
        else
          for (; e !== null; ) {
            const r = e.next;
            if (r !== null) {
              e = r;
              break;
            } else e.parent === this._root ? e = null : e = /** @type {AbstractType<any>} */
            e.parent._item;
          }
      while (e !== null && (e.deleted || !this._filter(
        /** @type {ContentType} */
        e.content.type
      )));
    return this._firstCall = !1, e === null ? { value: void 0, done: !0 } : (this._currentNode = e, { value: (
      /** @type {any} */
      e.content.type
    ), done: !1 });
  }
}
class Xs extends rn {
  constructor() {
    super(), this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const e = this._first;
    return e ? e.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  _copy() {
    return new Xs();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const e = new Xs();
    return e.insert(0, this.toArray().map((n) => n instanceof rn ? n.clone() : n)), e;
  }
  get length() {
    return this.doc ?? hn(), this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(e) {
    return new gf(this, e);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(e) {
    e = e.toUpperCase();
    const r = new gf(this, (i) => i.nodeName && i.nodeName.toUpperCase() === e).next();
    return r.done ? null : r.value;
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(e) {
    return e = e.toUpperCase(), Ws(new gf(this, (n) => n.nodeName && n.nodeName.toUpperCase() === e));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    cd(this, e, new ND(this, n, e));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return B_(this, (e) => e.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, r) {
    const i = e.createDocumentFragment();
    return r !== void 0 && r._createAssociation(i, this), vl(this, (o) => {
      i.insertBefore(o.toDOM(e, n, r), null);
    }), i;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? ut(this.doc, (r) => {
      U_(r, this, e, n);
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(e, n) {
    if (this.doc !== null)
      ut(this.doc, (r) => {
        const i = e && e instanceof rn ? e._item : e;
        bu(r, this, i, n);
      });
    else {
      const r = (
        /** @type {Array<any>} */
        this._prelimContent
      ), i = e === null ? 0 : r.findIndex((o) => o === e) + 1;
      if (i === 0 && e !== null)
        throw Gs("Reference item not found");
      r.splice(i, 0, ...n);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? ut(this.doc, (r) => {
      z_(r, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return F_(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(e) {
    this.insert(this.length, e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(e) {
    return q_(this, e);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(e = 0, n = this.length) {
    return $_(this, e, n);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    vl(this, e);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(RD);
  }
}
class _l extends Xs {
  constructor(e = "UNDEFINED") {
    super(), this.nodeName = e, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((r, i) => {
      this.setAttribute(i, r);
    }), this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new _l(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const e = new _l(this.nodeName), n = this.getAttributes();
    return NA(n, (r, i) => {
      typeof r == "string" && e.setAttribute(i, r);
    }), e.insert(0, this.toArray().map((r) => r instanceof rn ? r.clone() : r)), e;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const e = this.getAttributes(), n = [], r = [];
    for (const a in e)
      r.push(a);
    r.sort();
    const i = r.length;
    for (let a = 0; a < i; a++) {
      const l = r[a];
      n.push(l + '="' + e[l] + '"');
    }
    const o = this.nodeName.toLocaleLowerCase(), s = n.length > 0 ? " " + n.join(" ") : "";
    return `<${o}${s}>${super.toString()}</${o}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? ut(this.doc, (n) => {
      yu(n, this, e);
    }) : this._prelimAttrs.delete(e);
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? ut(this.doc, (r) => {
      og(r, this, e, n);
    }) : this._prelimAttrs.set(e, n);
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      sg(this, e)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(e) {
    return (
      /** @type {any} */
      H_(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(e) {
    return (
      /** @type {any} */
      e ? vD(this, e) : V_(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, r) {
    const i = e.createElement(this.nodeName), o = this.getAttributes();
    for (const s in o) {
      const a = o[s];
      typeof a == "string" && i.setAttribute(s, a);
    }
    return vl(this, (s) => {
      i.appendChild(s.toDOM(e, n, r));
    }), r !== void 0 && r._createAssociation(i, this), i;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(ID), e.writeKey(this.nodeName);
  }
}
class ND extends ad {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with which the
   *                                  change was created.
   */
  constructor(e, n, r) {
    super(e, r), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), n.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.attributesChanged.add(i);
    });
  }
}
class Y_ {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(e, n) {
    this.id = e, this.length = n;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw Gr();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} whether this merged with right
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(e, n, r) {
    throw Gr();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    throw Gr();
  }
}
const SD = 0;
class Oi extends Y_ {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    n > 0 && (this.id.clock += n, this.length -= n), O_(e.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeInfo(SD), e.writeLen(this.length - n);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    return null;
  }
}
class ud {
  /**
   * @param {Uint8Array} content
   */
  constructor(e) {
    this.content = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new ud(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(e) {
    throw Gr();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
class _u {
  /**
   * @param {number} len
   */
  constructor(e) {
    this.len = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new _u(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(e) {
    const n = new _u(this.len - e);
    return this.len = e, n;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.len += e.len, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    A_(e.deleteSet, n.id.client, n.id.clock, this.len), n.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeLen(this.len - n);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const TD = (t, e) => new Hl({ guid: t, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class dd {
  /**
   * @param {Doc} doc
   */
  constructor(e) {
    e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
    const n = {};
    this.opts = n, e.gc || (n.gc = !1), e.autoLoad && (n.autoLoad = !0), e.meta !== null && (n.meta = e.meta);
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new dd(TD(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(e) {
    throw Gr();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.doc._item = n, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(this.doc.guid), e.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
class _a {
  /**
   * @param {Object} embed
   */
  constructor(e) {
    this.embed = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new _a(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(e) {
    throw Gr();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
class Kt {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(e, n) {
    this.key = e, this.value = n;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new Kt(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(e) {
    throw Gr();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(e, n) {
    const r = (
      /** @type {YText} */
      n.parent
    );
    r._searchMarker = null, r._hasFormatting = !0;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeKey(this.key), e.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
const AD = mu("node_env") === "development";
class Ys {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e, AD && b_(e);
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new Ys(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(e) {
    const n = new Ys(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), n;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    const r = this.arr.length;
    e.writeLen(r - n);
    for (let i = n; i < r; i++) {
      const o = this.arr[i];
      e.writeAny(o);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
class vi {
  /**
   * @param {string} str
   */
  constructor(e) {
    this.str = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new vi(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(e) {
    const n = new vi(this.str.slice(e));
    this.str = this.str.slice(0, e);
    const r = this.str.charCodeAt(e - 1);
    return r >= 55296 && r <= 56319 && (this.str = this.str.slice(0, e - 1) + "ï¿½", n.str = "ï¿½" + n.str.slice(1)), n;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.str += e.str, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(n === 0 ? this.str : this.str.slice(n));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const DD = 0, MD = 1, OD = 2, ID = 3, RD = 4;
class ro {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(e) {
    this.type = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new ro(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(e) {
    throw Gr();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.type._integrate(e.doc, n);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.deleted ? n.id.clock < (e.beforeState.get(n.id.client) || 0) && e._mergeStructs.push(n) : n.delete(e), n = n.right;
    this.type._map.forEach((r) => {
      r.deleted ? r.id.clock < (e.beforeState.get(r.id.client) || 0) && e._mergeStructs.push(r) : r.delete(e);
    }), e.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.gc(e, !0), n = n.right;
    this.type._start = null, this.type._map.forEach(
      /** @param {Item | null} item */
      (r) => {
        for (; r !== null; )
          r.gc(e, !0), r = r.left;
      }
    ), this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    this.type._write(e);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const Q_ = (t, e, n) => {
  const { client: r, clock: i } = e.id, o = new dn(
    Ct(r, i + n),
    e,
    Ct(r, i + n - 1),
    e.right,
    e.rightOrigin,
    e.parent,
    e.parentSub,
    e.content.splice(n)
  );
  return e.deleted && o.markDeleted(), e.keep && (o.keep = !0), e.redone !== null && (o.redone = Ct(e.redone.client, e.redone.clock + n)), e.right = o, o.right !== null && (o.right.left = o), t._mergeStructs.push(o), o.parentSub !== null && o.right === null && o.parent._map.set(o.parentSub, o), e.length = n, o;
};
class dn extends Y_ {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(e, n, r, i, o, s, a, l) {
    super(e, l.getLength()), this.origin = r, this.left = n, this.right = i, this.rightOrigin = o, this.parent = s, this.parentSub = a, this.redone = null, this.content = l, this.info = this.content.isCountable() ? ub : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(e) {
    (this.info & cf) > 0 !== e && (this.info ^= cf);
  }
  get marker() {
    return (this.info & cf) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & cb) > 0;
  }
  set keep(e) {
    this.keep !== e && (this.info ^= cb);
  }
  get countable() {
    return (this.info & ub) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & lf) > 0;
  }
  set deleted(e) {
    this.deleted !== e && (this.info ^= lf);
  }
  markDeleted() {
    this.info |= lf;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= Dn(n, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= Dn(n, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === $c && this.id.client !== this.parent.client && this.parent.clock >= Dn(n, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = Cb(e, n, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = Wi(e, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === Oi || this.right && this.right.constructor === Oi)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === dn ? (this.parent = this.left.parent, this.parentSub = this.left.parentSub) : this.right && this.right.constructor === dn && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === $c) {
      const r = hf(n, this.parent);
      r.constructor === Oi ? this.parent = null : this.parent = /** @type {ContentType} */
      r.content.type;
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    if (n > 0 && (this.id.clock += n, this.left = Cb(e, e.doc.store, Ct(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(n), this.length -= n), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let r = this.left, i;
        if (r !== null)
          i = r.right;
        else if (this.parentSub !== null)
          for (i = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; i !== null && i.left !== null; )
            i = i.left;
        else
          i = /** @type {AbstractType<any>} */
          this.parent._start;
        const o = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
        for (; i !== null && i !== this.right; ) {
          if (s.add(i), o.add(i), Cc(this.origin, i.origin)) {
            if (i.id.client < this.id.client)
              r = i, o.clear();
            else if (Cc(this.rightOrigin, i.rightOrigin))
              break;
          } else if (i.origin !== null && s.has(hf(e.doc.store, i.origin)))
            o.has(hf(e.doc.store, i.origin)) || (r = i, o.clear());
          else
            break;
          i = i.right;
        }
        this.left = r;
      }
      if (this.left !== null) {
        const r = this.left.right;
        this.right = r, this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null)
          for (r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; r !== null && r.left !== null; )
            r = r.left;
        else
          r = /** @type {AbstractType<any>} */
          this.parent._start, this.parent._start = this;
        this.right = r;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(e)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), O_(e.doc.store, this), this.content.integrate(e, this), Eb(
        e,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      ), /** @type {AbstractType<any>} */
      (this.parent._item !== null && /** @type {AbstractType<any>} */
      this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(e);
    } else
      new Oi(this.id, this.length).integrate(e, 0);
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let e = this.right;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let e = this.left;
    for (; e !== null && e.deleted; )
      e = e.left;
    return e;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : Ct(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(e) {
    if (this.constructor === e.constructor && Cc(e.origin, this.lastId) && this.right === e && Cc(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && this.redone === null && e.redone === null && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      return n && n.forEach((r) => {
        r.p === e && (r.p = this, !this.deleted && this.countable && (r.index -= this.length));
      }), e.keep && (this.keep = !0), this.right = e.right, this.right !== null && (this.right.left = this), this.length += e.length, !0;
    }
    return !1;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(e) {
    if (!this.deleted) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      this.countable && this.parentSub === null && (n._length -= this.length), this.markDeleted(), A_(e.deleteSet, this.id.client, this.id.clock, this.length), Eb(e, n, this.parentSub), this.content.delete(e);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(e, n) {
    if (!this.deleted)
      throw Vo();
    this.content.gc(e), n ? uD(e, this, new Oi(this.id, this.length)) : this.content = new _u(this.length);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(e, n) {
    const r = n > 0 ? Ct(this.id.client, this.id.clock + n - 1) : this.origin, i = this.rightOrigin, o = this.parentSub, s = this.content.getRef() & QT | (r === null ? 0 : wu) | // origin is defined
    (i === null ? 0 : g_) | // right origin is defined
    (o === null ? 0 : YT);
    if (e.writeInfo(s), r !== null && e.writeLeftID(r), i !== null && e.writeRightID(i), r === null && i === null) {
      const a = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (a._item !== void 0) {
        const l = a._item;
        if (l === null) {
          const c = aD(a);
          e.writeParentInfo(!0), e.writeString(c);
        } else
          e.writeParentInfo(!1), e.writeLeftID(l.id);
      } else a.constructor === String ? (e.writeParentInfo(!0), e.writeString(a)) : a.constructor === $c ? (e.writeParentInfo(!1), e.writeLeftID(a)) : Vo();
      o !== null && e.writeString(o);
    }
    this.content.write(e, n);
  }
}
const Z_ = (
  /** @type {any} */
  typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}
), ex = "__ $YJS$ __";
Z_[ex] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
Z_[ex] = !0;
const PD = Se("TOGGLE_CONNECT_COMMAND");
var LD = Object.defineProperty, $D = (t, e, n) => e in t ? LD(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, me = (t, e, n) => $D(t, typeof e != "symbol" ? e + "" : e, n);
const wf = (t) => lt($0(t)), Ho = t0("cid", {
  parse: (t) => typeof t == "string" ? t : void 0
}), Ko = t0("segment", {
  parse: (t) => typeof t == "string" ? t : void 0
}), Nh = "unknown", tx = 1;
class ss extends pn {
  constructor(e = "", n, r, i) {
    super(i), me(this, "__tag"), me(this, "__marker"), me(this, "__unknownAttributes"), this.__tag = e, this.__marker = n, this.__unknownAttributes = r;
  }
  static getType() {
    return "unknown";
  }
  static clone(e) {
    const { __tag: n, __marker: r, __unknownAttributes: i, __key: o } = e;
    return new ss(n, r, i, o);
  }
  static importDOM() {
    return {
      [Nh]: (e) => BD(e) ? {
        conversion: FD,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return nx().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setTag(e.tag).setMarker(e.marker).setUnknownAttributes(e.unknownAttributes);
  }
  setTag(e) {
    if (this.__tag === e)
      return this;
    const n = this.getWritable();
    return n.__tag = e, n;
  }
  getTag() {
    return this.getLatest().__tag;
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement(Nh);
    return e.style.display = "none", e;
  }
  updateDOM() {
    return !1;
  }
  exportDOM() {
    return { element: null };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      tag: this.getTag(),
      marker: this.getMarker(),
      unknownAttributes: this.getUnknownAttributes(),
      version: tx
    };
  }
  // Mutation
  canBeEmpty() {
    return !0;
  }
  isInline() {
    return !0;
  }
  extractWithChild() {
    return !1;
  }
  excludeFromCopy(e) {
    return e !== "clone";
  }
}
function FD(t) {
  const e = t.getAttribute("data-tag") ?? "", n = t.getAttribute("data-marker") ?? "";
  return { node: nx(e, n) };
}
function nx(t, e, n) {
  return lt(new ss(t, e, n));
}
function BD(t) {
  return (t == null ? void 0 : t.tagName) === Nh;
}
function Kl(t) {
  return t instanceof ss;
}
const xl = "id", rx = 1;
class sr extends pn {
  constructor(e = "", n, r) {
    super(r), me(this, "__marker", xl), me(this, "__code"), me(this, "__unknownAttributes"), this.__code = e, this.__unknownAttributes = n;
  }
  static getType() {
    return "book";
  }
  static clone(e) {
    const { __code: n, __unknownAttributes: r, __key: i } = e;
    return new sr(n, r, i);
  }
  static importJSON(e) {
    const { code: n } = e;
    return ix(n).updateFromJSON(e);
  }
  static isValidBookCode(e) {
    return jC(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setCode(e.code).setUnknownAttributes(e.unknownAttributes);
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setCode(e) {
    if (this.__code === e)
      return this;
    const n = this.getWritable();
    return n.__code = e, n;
  }
  /**
   * Get the book code (ID).
   * @returns the book code (ID).
   */
  getCode() {
    return this.getLatest().__code;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("p");
    return e.setAttribute("data-marker", this.__marker), e.classList.add(this.__type, `usfm_${this.__marker}`), e.setAttribute("data-code", this.__code), e;
  }
  updateDOM() {
    return !1;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      marker: this.getMarker(),
      code: this.getCode(),
      unknownAttributes: this.getUnknownAttributes(),
      version: rx
    };
  }
}
function ix(t, e) {
  return lt(new sr(t, e));
}
function Jr(t) {
  return t instanceof sr;
}
function qD(t) {
  return (t == null ? void 0 : t.type) === sr.getType();
}
const st = "Â ", Sh = "â€‹", ag = `${st}|`, fd = "p", ji = "+", el = "-", xu = "chapter", Th = "verse", Db = "invalid", jD = "text-spacing", UD = "formatted-font", zD = "marker-", lg = "external-usj-mutation", ox = "selection-change", Ah = "cursor-change", Dh = "annotation-change", Mh = "delta-change", VD = [
  lg,
  ox,
  Ah,
  Dh,
  Mh
], Cu = "c", sx = 1;
class Ar extends pn {
  constructor(e = "", n, r, i, o, s) {
    super(s), me(this, "__marker"), me(this, "__number"), me(this, "__sid"), me(this, "__altnumber"), me(this, "__pubnumber"), me(this, "__unknownAttributes"), this.__marker = Cu, this.__number = e, this.__sid = n, this.__altnumber = r, this.__pubnumber = i, this.__unknownAttributes = o;
  }
  static getType() {
    return "chapter";
  }
  static clone(e) {
    const { __number: n, __sid: r, __altnumber: i, __pubnumber: o, __unknownAttributes: s, __key: a } = e;
    return new Ar(n, r, i, o, s, a);
  }
  static importJSON(e) {
    return ax().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setNumber(e.number).setSid(e.sid).setAltnumber(e.altnumber).setPubnumber(e.pubnumber).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setNumber(e) {
    if (this.__number === e)
      return this;
    const n = this.getWritable();
    return n.__number = e, n;
  }
  getNumber() {
    return this.getLatest().__number;
  }
  setSid(e) {
    if (this.__sid === e)
      return this;
    const n = this.getWritable();
    return n.__sid = e, n;
  }
  getSid() {
    return this.getLatest().__sid;
  }
  setAltnumber(e) {
    if (this.__altnumber === e)
      return this;
    const n = this.getWritable();
    return n.__altnumber = e, n;
  }
  getAltnumber() {
    return this.getLatest().__altnumber;
  }
  setPubnumber(e) {
    if (this.__pubnumber === e)
      return this;
    const n = this.getWritable();
    return n.__pubnumber = e, n;
  }
  getPubnumber() {
    return this.getLatest().__pubnumber;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("p");
    return e.setAttribute("data-marker", this.__marker), e.classList.add(xu, `usfm_${this.__marker}`), e.setAttribute("data-number", this.__number), e;
  }
  updateDOM() {
    return !1;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      marker: this.getMarker(),
      number: this.getNumber(),
      sid: this.getSid(),
      altnumber: this.getAltnumber(),
      pubnumber: this.getPubnumber(),
      unknownAttributes: this.getUnknownAttributes(),
      version: sx
    };
  }
}
function ax(t, e, n, r, i) {
  return lt(new Ar(t, e, n, r, i));
}
function cg(t) {
  return t instanceof Ar;
}
function HD(t) {
  return (t == null ? void 0 : t.type) === Ar.getType();
}
const lx = [
  "fr",
  "fq",
  "fqa",
  "fk",
  "ft",
  "fl",
  "fw",
  "fp",
  "fv",
  "fdc",
  "fm"
], cx = [
  "xo",
  "xop",
  "xk",
  "xq",
  "xt",
  "xta",
  "xot",
  "xnt",
  "xdc"
], KD = [
  // Chapter & Verse
  "ca",
  "cp",
  "va",
  "vp",
  // Text Features
  "add",
  "bk",
  "dc",
  "em",
  "jmp",
  "k",
  "nd",
  "ord",
  "pn",
  "png",
  "qt",
  "rb",
  "rq",
  // "ref", // This has its own tag and is not a Char
  "sig",
  "sls",
  "tl",
  "w",
  "wa",
  "wg",
  "wh",
  "wj",
  // Note there are 2 deprecated markers intentionally not listed here: "addpn", "pro"
  // Text Formatting
  "bd",
  "it",
  "bdit",
  "no",
  "sc",
  "sup",
  // Introductions
  "ior",
  "iqt",
  // Poetry
  "qac",
  "qs",
  // Lists
  "litl",
  "lik",
  "liv",
  "liv1",
  "liv2",
  "liv3",
  "liv4",
  "liv5",
  ...lx,
  ...cx
], ux = 1;
class yt extends pn {
  constructor(e = "", n, r) {
    super(r), me(this, "__marker"), me(this, "__unknownAttributes"), this.__marker = e, this.__unknownAttributes = n;
  }
  static getType() {
    return "char";
  }
  static clone(e) {
    const { __marker: n, __unknownAttributes: r, __key: i } = e;
    return new yt(n, r, i);
  }
  static isValidMarker(e) {
    return e !== void 0 && KD.includes(e);
  }
  static isValidFootnoteMarker(e) {
    return e !== void 0 && lx.includes(e);
  }
  static isValidCrossReferenceMarker(e) {
    return e !== void 0 && cx.includes(e);
  }
  static importDOM() {
    return {
      span: (e) => GD(e) ? {
        conversion: WD,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return Ur().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.setAttribute("data-marker", this.__marker), e.setAttribute("title", this.__marker), e.classList.add(this.__type, `usfm_${this.__marker}`), e;
  }
  updateDOM() {
    return !1;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && it(n) && (n.setAttribute("data-marker", this.getMarker()), n.classList.add(this.getType(), `usfm_${this.getMarker()}`)), { element: n };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      marker: this.getMarker(),
      unknownAttributes: this.getUnknownAttributes(),
      version: ux
    };
  }
  // Mutation
  insertNewAfter(e, n) {
    const r = Ur(this.getMarker());
    return r.setTextFormat(e.format), r.setTextStyle(e.style), r.setDirection(this.getDirection()), r.setFormat(this.getFormatType()), r.setStyle(this.getTextStyle()), this.insertAfter(r, n), r;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
}
function WD(t) {
  const e = t.getAttribute("data-marker") ?? "f";
  return { node: Ur(e) };
}
function Ur(t, e) {
  return lt(new yt(t, e));
}
function GD(t) {
  if (!t)
    return !1;
  const e = t.getAttribute("data-marker") ?? "";
  return yt.isValidMarker(e) && t.classList.contains(yt.getType());
}
function at(t) {
  return t instanceof yt;
}
function JD(t) {
  return (t == null ? void 0 : t.type) === yt.getType();
}
const dx = 1, XD = "c", fx = "span";
class Ni extends eo {
  constructor(e = "", n = !1, r, i, o, s, a) {
    super(a), me(this, "__marker"), me(this, "__number"), me(this, "__showMarker"), me(this, "__sid"), me(this, "__altnumber"), me(this, "__pubnumber"), me(this, "__unknownAttributes"), this.__marker = XD, this.__number = e, this.__showMarker = n, this.__sid = r, this.__altnumber = i, this.__pubnumber = o, this.__unknownAttributes = s;
  }
  static getType() {
    return "immutable-chapter";
  }
  static clone(e) {
    const { __number: n, __showMarker: r, __sid: i, __altnumber: o, __pubnumber: s, __unknownAttributes: a, __key: l } = e;
    return new Ni(n, r, i, o, s, a, l);
  }
  static importDOM() {
    return {
      span: (e) => hx(e) ? {
        conversion: YD,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return ug().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setNumber(e.number).setShowMarker(e.showMarker).setSid(e.sid).setAltnumber(e.altnumber).setPubnumber(e.pubnumber).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setNumber(e) {
    if (this.__number === e)
      return this;
    const n = this.getWritable();
    return n.__number = e, n;
  }
  getNumber() {
    return this.getLatest().__number;
  }
  setShowMarker(e = !1) {
    if (this.__showMarker === e)
      return this;
    const n = this.getWritable();
    return n.__showMarker = e, n;
  }
  getShowMarker() {
    return this.getLatest().__showMarker;
  }
  setSid(e) {
    if (this.__sid === e)
      return this;
    const n = this.getWritable();
    return n.__sid = e, n;
  }
  getSid() {
    return this.getLatest().__sid;
  }
  setAltnumber(e) {
    if (this.__altnumber === e)
      return this;
    const n = this.getWritable();
    return n.__altnumber = e, n;
  }
  getAltnumber() {
    return this.getLatest().__altnumber;
  }
  setPubnumber(e) {
    if (this.__pubnumber === e)
      return this;
    const n = this.getWritable();
    return n.__pubnumber = e, n;
  }
  getPubnumber() {
    return this.getLatest().__pubnumber;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement(fx);
    return e.setAttribute("data-marker", this.__marker), e.classList.add(xu, `usfm_${this.__marker}`), this.__showMarker && e.classList.add("marker"), e.setAttribute("data-number", this.__number), e;
  }
  updateDOM() {
    return !1;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && it(n) && (n.setAttribute("data-marker", this.getMarker()), n.classList.add(xu, `usfm_${this.getMarker()}`), n.setAttribute("data-number", this.getNumber())), { element: n };
  }
  decorate() {
    return this.getShowMarker() ? Gl(this.getMarker(), this.getNumber()) : this.getNumber();
  }
  exportJSON() {
    return {
      type: this.getType(),
      marker: this.getMarker(),
      number: this.getNumber(),
      showMarker: this.getShowMarker(),
      sid: this.getSid(),
      altnumber: this.getAltnumber(),
      pubnumber: this.getPubnumber(),
      unknownAttributes: this.getUnknownAttributes(),
      version: dx
    };
  }
  // Mutation
  isInline() {
    return !1;
  }
  isKeyboardSelectable() {
    return !1;
  }
}
function YD(t) {
  const e = t.getAttribute("data-number") ?? "0";
  return { node: ug(e) };
}
function ug(t, e, n, r, i, o) {
  return lt(new Ni(t, e, n, r, i, o));
}
function hx(t) {
  return t ? t.classList.contains(xu) && t.tagName.toLowerCase() === fx : !1;
}
function Wl(t) {
  return t instanceof Ni;
}
function QD(t) {
  return (t == null ? void 0 : t.type) === Ni.getType();
}
const px = 1;
class Gi extends to {
  static getType() {
    return "implied-para";
  }
  static clone(e) {
    return new Gi(e.__key);
  }
  static importJSON(e) {
    return br().updateFromJSON(e);
  }
  getMarker() {
    return fd;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      version: px
    };
  }
  // Mutation
  insertNewAfter(e, n) {
    const r = br();
    return r.setTextFormat(e.format), r.setTextStyle(e.style), r.setDirection(this.getDirection()), r.setFormat(this.getFormatType()), r.setStyle(this.getTextStyle()), this.insertAfter(r, n), r;
  }
}
function br() {
  return lt(new Gi());
}
function _i(t) {
  return t instanceof Gi;
}
function dg(t) {
  return (t == null ? void 0 : t.type) === Gi.getType();
}
const Wo = "zmsc-s", As = "zmsc-e", ZD = [Wo, As], eM = [
  "ts-s",
  "ts-e",
  "t-s",
  "t-e",
  "ts",
  "qt1-s",
  "qt1-e",
  "qt2-s",
  "qt2-e",
  "qt3-s",
  "qt3-e",
  "qt4-s",
  "qt4-e",
  "qt5-s",
  "qt5-e",
  "qt-s",
  "qt-e",
  // custom markers used for annotations
  Wo,
  As
], gx = 1;
class Qr extends eo {
  constructor(e = "", n, r, i, o) {
    super(o), me(this, "__marker"), me(this, "__sid"), me(this, "__eid"), me(this, "__unknownAttributes"), this.__marker = e, this.__sid = n, this.__eid = r, this.__unknownAttributes = i;
  }
  static getType() {
    return "ms";
  }
  static clone(e) {
    const { __marker: n, __sid: r, __eid: i, __unknownAttributes: o, __key: s } = e;
    return new Qr(n, r, i, o, s);
  }
  static importJSON(e) {
    return wx().updateFromJSON(e);
  }
  static isValidMarker(e) {
    return e !== void 0 && (eM.includes(e) || e.startsWith("z"));
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setSid(e.sid).setEid(e.eid).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setSid(e) {
    if (this.__sid === e)
      return this;
    const n = this.getWritable();
    return n.__sid = e, n;
  }
  getSid() {
    return this.getLatest().__sid;
  }
  setEid(e) {
    if (this.__eid === e)
      return this;
    const n = this.getWritable();
    return n.__eid = e, n;
  }
  getEid() {
    return this.getLatest().__eid;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.setAttribute("data-marker", this.__marker), e.classList.add(this.__type, `usfm_${this.__marker}`), e;
  }
  updateDOM() {
    return !1;
  }
  decorate() {
    return "";
  }
  exportJSON() {
    return {
      type: this.getType(),
      marker: this.getMarker(),
      sid: this.getSid(),
      eid: this.getEid(),
      unknownAttributes: this.getUnknownAttributes(),
      version: gx
    };
  }
  // Mutation
  isKeyboardSelectable() {
    return !1;
  }
}
function tM(t) {
  return ZD.includes(t);
}
function wx(t, e, n, r) {
  return lt(new Qr(t, e, n, r));
}
function hd(t) {
  return t instanceof Qr;
}
const fg = "f", nM = [
  // Footnote
  fg,
  "fe",
  "ef",
  "efe",
  // Cross Reference
  "x",
  "ex"
], mx = 1;
class Wt extends pn {
  constructor(e = fg, n, r = !0, i, o, s) {
    super(s), me(this, "__marker"), me(this, "__caller"), me(this, "__isCollapsed"), me(this, "__category"), me(this, "__unknownAttributes"), this.__marker = e, this.__caller = n ?? (e === "x" || e === "ex" ? el : ji), this.__isCollapsed = r, this.__category = i, this.__unknownAttributes = o;
  }
  static getType() {
    return "note";
  }
  static clone(e) {
    const { __marker: n, __caller: r, __isCollapsed: i, __category: o, __unknownAttributes: s, __key: a } = e;
    return new Wt(n, r, i, o, s, a);
  }
  static importDOM() {
    return {
      span: (e) => iM(e) ? {
        conversion: rM,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return hg().updateFromJSON(e);
  }
  static isValidMarker(e) {
    return e !== void 0 && nM.includes(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setCaller(e.caller).setIsCollapsed(e.isCollapsed).setCategory(e.category).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setCaller(e) {
    if (this.__caller === e)
      return this;
    const n = this.getWritable();
    return n.__caller = e, n;
  }
  getCaller() {
    return this.getLatest().__caller;
  }
  setIsCollapsed(e) {
    if (this.__isCollapsed === e)
      return this;
    const n = this.getWritable();
    return n.__isCollapsed = e, n;
  }
  toggleIsCollapsed() {
    const e = this.getWritable();
    return e.__isCollapsed = !e.__isCollapsed, e;
  }
  getIsCollapsed() {
    return this.getLatest().__isCollapsed;
  }
  setCategory(e) {
    if (this.__category === e)
      return this;
    const n = this.getWritable();
    return n.__category = e, n;
  }
  getCategory() {
    return this.getLatest().__category;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.setAttribute("data-marker", this.__marker), e.classList.add(this.__type, `usfm_${this.__marker}`, this.__isCollapsed ? "collapsed" : "expanded"), e.setAttribute("data-caller", this.__caller), e;
  }
  updateDOM(e) {
    return e.__isCollapsed !== this.__isCollapsed;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && it(n) && (n.setAttribute("data-marker", this.getMarker()), n.classList.add(this.getType(), `usfm_${this.getMarker()}`, this.getIsCollapsed() ? "collapsed" : "expanded"), n.setAttribute("data-caller", this.getCaller())), { element: n };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      marker: this.getMarker(),
      caller: this.getCaller(),
      isCollapsed: this.getIsCollapsed(),
      category: this.getCategory(),
      unknownAttributes: this.getUnknownAttributes(),
      version: mx
    };
  }
  // Mutation
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
}
function rM(t) {
  const e = t.getAttribute("data-marker") ?? "f", n = t.getAttribute("data-caller") ?? "", r = t.classList.contains("collapsed");
  return { node: hg(e, n, r) };
}
function hg(t, e, n, r, i) {
  return lt(new Wt(t, e, n, r, i));
}
function iM(t) {
  if (!t)
    return !1;
  const e = t.getAttribute("data-marker") ?? "";
  return Wt.isValidMarker(e) && t.classList.contains(Wt.getType());
}
function je(t) {
  return t instanceof Wt;
}
const oM = [
  // Identification
  "ide",
  "sts",
  "rem",
  "h",
  "toc1",
  "toc2",
  "toc3",
  "toca1",
  "toca2",
  "toca3",
  // Introductions
  "imt",
  "imt1",
  "imt2",
  "imt3",
  "imt4",
  "is",
  "is1",
  "is2",
  "ip",
  "ipi",
  "im",
  "imi",
  "ipq",
  "imq",
  "ipr",
  "iq",
  "iq1",
  "iq2",
  "iq3",
  "ili",
  "ili1",
  "ili2",
  "ib",
  "iot",
  "io",
  "io1",
  "io2",
  "io3",
  "io4",
  "iex",
  "imte",
  "imte1",
  "imte2",
  "ie",
  // Titles and Headings
  "mt",
  "mt1",
  "mt2",
  "mt3",
  "mt4",
  "mte",
  "mte1",
  "mte2",
  "cl",
  "cd",
  "ms",
  "ms1",
  "ms2",
  "ms3",
  "mr",
  "s",
  "s1",
  "s2",
  "s3",
  "s4",
  "sr",
  "r",
  "d",
  "sp",
  "sd",
  "sd1",
  "sd2",
  "sd3",
  "sd4",
  // Body Paragraphs
  fd,
  "m",
  "po",
  "cls",
  "pr",
  "pc",
  "pm",
  "pmo",
  "pmc",
  "pmr",
  "pi",
  "pi1",
  "pi2",
  "pi3",
  "mi",
  "lit",
  "nb",
  // Note there is 1 deprecated marker not listed here: "ph#"
  // Poetry
  "q",
  "q1",
  "q2",
  "q3",
  "q4",
  "qr",
  "qc",
  "qa",
  "qm",
  "qm1",
  "qm2",
  "qm3",
  "qd",
  "b",
  // Lists
  "lh",
  "li",
  "li1",
  "li2",
  "li3",
  "li4",
  "lf",
  "lim",
  "lim1",
  "lim2",
  "lim3",
  "lim4",
  // Breaks - see https://docs.usfm.bible/usfm/3.1/char/breaks/pb.html
  "pb"
], bx = 1;
class In extends to {
  constructor(e = fd, n, r) {
    super(r), me(this, "__marker"), me(this, "__unknownAttributes"), this.__marker = e, this.__unknownAttributes = n;
  }
  static getType() {
    return "para";
  }
  static clone(e) {
    const { __marker: n, __unknownAttributes: r, __key: i } = e;
    return new In(n, r, i);
  }
  static isValidMarker(e) {
    return e !== void 0 && oM.includes(e);
  }
  static importDOM() {
    return {
      p: () => ({
        conversion: sM,
        priority: 1
      })
    };
  }
  static importJSON(e) {
    return Cl().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("p");
    return e.setAttribute("data-marker", this.__marker), e.classList.add(this.__type, `usfm_${this.__marker}`), e;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && it(n) && (n.setAttribute("data-marker", this.getMarker()), n.classList.add(this.getType(), `usfm_${this.getMarker()}`)), { element: n };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      marker: this.getMarker(),
      unknownAttributes: this.getUnknownAttributes(),
      version: bx
    };
  }
  // Mutation
  insertNewAfter(e, n) {
    const r = Cl(this.getMarker());
    return r.setTextFormat(e.format), r.setTextStyle(e.style), r.setDirection(this.getDirection()), r.setFormat(this.getFormatType()), r.setStyle(this.getTextStyle()), this.insertAfter(r, n), r;
  }
}
function sM(t) {
  const e = t.getAttribute("data-marker") ?? void 0, n = Cl(e);
  if (t.style) {
    n.setFormat(t.style.textAlign);
    const r = parseInt(t.style.textIndent, 10) / 20;
    r > 0 && n.setIndent(r);
  }
  return { node: n };
}
function Cl(t, e) {
  return lt(new In(t, e));
}
function fn(t) {
  return t instanceof In;
}
function aM(t) {
  return (t == null ? void 0 : t.type) === In.getType();
}
const ku = "v", yx = 1;
class xn extends _n {
  constructor(e = "", n, r, i, o, s, a) {
    super(n ?? e, a), me(this, "__marker"), me(this, "__number"), me(this, "__sid"), me(this, "__altnumber"), me(this, "__pubnumber"), me(this, "__unknownAttributes"), this.__marker = ku, this.__number = e, this.__sid = r, this.__altnumber = i, this.__pubnumber = o, this.__unknownAttributes = s;
  }
  static getType() {
    return "verse";
  }
  static clone(e) {
    const { __number: n, __text: r, __sid: i, __altnumber: o, __pubnumber: s, __unknownAttributes: a, __key: l } = e;
    return new xn(n, r, i, o, s, a, l);
  }
  static importJSON(e) {
    return vx().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setNumber(e.number).setSid(e.sid).setAltnumber(e.altnumber).setPubnumber(e.pubnumber).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setNumber(e) {
    if (this.__number === e)
      return this;
    const n = this.getWritable();
    return n.__number = e, n;
  }
  getNumber() {
    return this.getLatest().__number;
  }
  setSid(e) {
    if (this.__sid === e)
      return this;
    const n = this.getWritable();
    return n.__sid = e, n;
  }
  getSid() {
    return this.getLatest().__sid;
  }
  setAltnumber(e) {
    if (this.__altnumber === e)
      return this;
    const n = this.getWritable();
    return n.__altnumber = e, n;
  }
  getAltnumber() {
    return this.getLatest().__altnumber;
  }
  setPubnumber(e) {
    if (this.__pubnumber === e)
      return this;
    const n = this.getWritable();
    return n.__pubnumber = e, n;
  }
  getPubnumber() {
    return this.getLatest().__pubnumber;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM(e) {
    const n = super.createDOM(e);
    return n.setAttribute("data-marker", this.__marker), n.classList.add(Th, `usfm_${this.__marker}`), n.setAttribute("data-number", this.__number), n;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      marker: this.getMarker(),
      number: this.getNumber(),
      sid: this.getSid(),
      altnumber: this.getAltnumber(),
      pubnumber: this.getPubnumber(),
      unknownAttributes: this.getUnknownAttributes(),
      version: yx
    };
  }
}
function vx(t, e, n, r, i, o) {
  return lt(new xn(t, e, n, r, i, o));
}
function pg(t) {
  return t instanceof xn;
}
function lM(t) {
  return (t == null ? void 0 : t.type) === xn.getType();
}
function cM(t) {
  return HD(t) || QD(t);
}
function rr(t) {
  return cg(t) || Wl(t);
}
function uM(t, e) {
  return t.find((n) => rr(n) && n.getNumber() === e.toString());
}
function dM(t, e = !1) {
  return t.find((n, r) => (!e || r > 0) && rr(n));
}
function gg(t) {
  var e;
  if (!t)
    return;
  if (rr(t))
    return t;
  let n = (e = t.getTopLevelElement()) == null ? void 0 : e.getPreviousSibling();
  for (; n && !rr(n); )
    n = n.getPreviousSibling();
  if (n && rr(n))
    return n;
}
function _x(t) {
  let e = t;
  for (; e !== null; ) {
    if (je(e))
      return e;
    e = e.getParent();
  }
}
function fM(t) {
  return Jr(t) || cg(t) || at(t) || Wl(t) || _i(t) || hd(t) || fn(t) || je(t) || pg(t) || Kl(t);
}
function hM(t) {
  var e;
  if (t.anchor.type === "element") {
    const r = t.anchor.getNode(), i = t.anchor.offset;
    if (i < r.getChildrenSize())
      return r.getChildAtIndex(i);
  }
  const n = t.anchor.getNode();
  return n.getNextSibling() ?? ((e = n.getParent()) == null ? void 0 : e.getNextSibling()) ?? null;
}
function pM(t) {
  var e;
  const n = t.anchor.offset;
  if (t.anchor.type === "element" && n > 0)
    return t.anchor.getNode().getChildAtIndex(n - 1);
  const r = t.anchor.getNode();
  return r.getPreviousSibling() ?? ((e = r.getParent()) == null ? void 0 : e.getPreviousSibling()) ?? null;
}
function gr(t) {
  return fn(t) || _i(t);
}
function gM(t, e) {
  let n = t.getParent();
  for (; n; ) {
    if (n.getKey() === e)
      return !0;
    n = n.getParent();
  }
  return !1;
}
function Go(t, e) {
  const n = $s(e, Ho), r = !!(t.cid && n), i = !t.cid && !n;
  return t.style === e.getMarker() && (i || r && t.cid === n);
}
function wM(t, e) {
  const n = X(t) ? t : t.getParent(), r = X(e) ? e : e.getParent(), i = n && r ? Qa(n, r) : void 0;
  return i ? i.commonAncestor : void 0;
}
function mM(t) {
  const e = t.getStartEndPoints();
  if (!e)
    return;
  const [n, r] = e, i = t.isBackward() ? n : r;
  t.focus.set(i.key, i.offset, i.type), t.anchor.set(i.key, i.offset, i.type);
}
function wg(t) {
  return (t == null ? void 0 : t.type) === _n.getType();
}
function bM(t, e) {
  if (!e)
    return;
  const n = t.findIndex((r) => r === e);
  n && (t.length = n);
}
function yM(t, e) {
  if (!e)
    return t;
  const n = e.getIndexWithinParent();
  return t.splice(n + 1, t.length - n - 1);
}
function Si(t) {
  return `\\${t}`;
}
function Qs(t) {
  return `\\${t}*`;
}
function xx(t, e, n) {
  const r = Si(t);
  if (e != null && e.startsWith(r)) {
    const i = parseInt(e.slice(r.length), 10);
    isNaN(i) || (n = i.toString());
  }
  return n;
}
function Gl(t, e) {
  let n = Si(t);
  return e && (n += `${st}${e}`), n += " ", n;
}
function Cx(t) {
  return wg(t) ? t.text : JD(t) ? t.children.map((e) => Cx(e)).join("") : "";
}
function vM(t) {
  return t.map((e) => Cx(e)).join(" ").trim();
}
function mg(t) {
  return st + t + " ";
}
function bg(t) {
  return t.reduce((e, n) => e + (at(n) ? ` ${n.getTextContent()}` : ""), "").trim();
}
function Gt(t, e = qC) {
  const n = { ...t };
  return e.forEach((r) => {
    Reflect.deleteProperty(n, r);
  }), Object.keys(n).length === 0 ? void 0 : n;
}
function _M(t, e) {
  const n = e.getElementByKey(t.getKey());
  return n ? n.tagName.toLowerCase() : void 0;
}
function Ft(t) {
  return Object.fromEntries(Object.entries(t).filter(([, e]) => e !== void 0));
}
function kx(t) {
  if (!t)
    return;
  const e = t.getNodes();
  if (e.length > 0)
    return t.isBackward() ? e[e.length - 1] : e[0];
}
function Oh(t, e) {
  if (!e)
    return (t + 1).toString();
  const n = e.split("-");
  if (n.length === 2)
    return parseInt(n[1]) ? `${parseInt(n[1]) + 1}` : `${parseInt(n[0]) + 1}`;
  const r = RegExp(/^(\d+)([a-yA-Y]{1,3})$/).exec(e);
  if (!r)
    return (parseInt(e) + 1).toString();
  const i = String.fromCharCode(r[2].charCodeAt(0) + 1);
  return `${r[1]}${i}`;
}
function yg(t, e) {
  if (!e)
    return !1;
  const n = e.split("-").map((r) => parseInt(r));
  if (n.length < 1 || n.length > 2 || n[0] > n[1])
    throw new Error("isVerseInRange: invalid range");
  return n.length === 1 ? t === n[0] : n.length === 2 && isNaN(n[1]) ? t >= n[0] : (n.length === 2 && isNaN(n[0]) || t >= n[0]) && t <= n[1];
}
function xM(t) {
  return !!t && t.includes("-");
}
const CM = 1;
class as extends _n {
  constructor(e = "", n = "opening", r) {
    super(mf(e, n), r), me(this, "__marker"), me(this, "__markerSyntax"), this.__marker = e, this.__markerSyntax = n;
  }
  static getType() {
    return "marker";
  }
  static clone(e) {
    return new as(e.__marker, e.__markerSyntax, e.__key);
  }
  static importJSON(e) {
    return Zs().updateFromJSON(e);
  }
  updateFromJSON(e) {
    const { marker: n, markerSyntax: r = "opening" } = e;
    return super.updateFromJSON(e).setMarker(n).setMarkerSyntax(r);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n.__text = mf(e, n.__markerSyntax), n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setMarkerSyntax(e) {
    if (this.__markerSyntax === e)
      return this;
    const n = this.getWritable();
    return n.__markerSyntax = e, n.__text = mf(n.__marker, e), n;
  }
  getMarkerSyntax() {
    return this.getLatest().__markerSyntax;
  }
  createDOM(e) {
    const n = super.createDOM(e);
    return n.setAttribute("data-marker", this.__marker), n.classList.add(this.__markerSyntax), n;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      text: this.getTextContent(),
      marker: this.getMarker(),
      markerSyntax: this.getMarkerSyntax(),
      version: CM
    };
  }
}
function Zs(t, e) {
  return lt(new as(t, e));
}
function Jl(t) {
  return t instanceof as;
}
function mf(t, e) {
  return e === "closing" ? Qs(t) : e === "selfClosing" ? Qs("") : Si(t);
}
const $i = "internal-comment", kM = [$i], EM = {}, NM = 1;
class nn extends pn {
  constructor(e = EM, n) {
    super(n), me(this, "__typedIDs"), this.__typedIDs = e;
  }
  static getType() {
    return "typed-mark";
  }
  static clone(e) {
    const n = JSON.parse(JSON.stringify(e.__typedIDs));
    return new nn(n, e.__key);
  }
  static isReservedType(e) {
    return kM.includes(e);
  }
  static importDOM() {
    return null;
  }
  static importJSON(e) {
    return kl().updateFromJSON(e);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: this.getType(),
      typedIDs: this.getTypedIDs(),
      version: NM
    };
  }
  createDOM(e) {
    const n = document.createElement("mark");
    for (const [r, i] of Object.entries(this.__typedIDs))
      un(n, Nc(e.theme.typedMark, r)), i.length > 1 && un(n, Nc(e.theme.typedMarkOverlap, r));
    return n;
  }
  updateDOM(e, n, r) {
    for (const [i, o] of Object.entries(this.__typedIDs)) {
      const s = e.__typedIDs[i].length, a = o.length, l = Nc(r.theme.typedMark, i), c = Nc(r.theme.typedMarkOverlap, i);
      s !== a && (s === 0 ? a === 1 && un(n, l) : a === 0 && To(n, l), s === 1 ? a === 2 && un(n, c) : a === 1 && To(n, c));
    }
    return !1;
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setTypedIDs(e.typedIDs);
  }
  hasID(e, n) {
    const r = this.getTypedIDs()[e];
    if (!r)
      return !1;
    for (const i of r)
      if (n === i)
        return !0;
    return !1;
  }
  getTypedIDs() {
    const e = this.getLatest();
    return on(e) ? e.__typedIDs : {};
  }
  setTypedIDs(e) {
    const n = this.getWritable();
    return n.__typedIDs = e, n;
  }
  addID(e, n) {
    const r = this.getWritable();
    if (!on(r))
      return;
    const i = r.__typedIDs[e] ?? [];
    r.__typedIDs[e] = i;
    for (const o of i)
      if (n === o)
        return;
    i.push(n);
  }
  deleteID(e, n) {
    const r = this.getWritable();
    if (!on(r))
      return;
    const i = r.__typedIDs[e];
    for (let o = 0; o < i.length; o++)
      if (n === i[o]) {
        i.splice(o, 1);
        return;
      }
  }
  hasNoIDsForEveryType() {
    return Object.values(this.getTypedIDs()).every((e) => e === void 0 || e.length === 0);
  }
  insertNewAfter(e, n = !0) {
    const r = kl(this.__typedIDs);
    return this.insertAfter(r, n), r;
  }
  canInsertTextBefore() {
    return !1;
  }
  canInsertTextAfter() {
    return !1;
  }
  canBeEmpty() {
    return !1;
  }
  isInline() {
    return !0;
  }
  extractWithChild(e, n, r) {
    if (!Z(n) || r === "html")
      return !1;
    const i = n.anchor, o = n.focus, s = i.getNode(), a = o.getNode(), l = n.isBackward() ? i.offset - o.offset : o.offset - i.offset;
    return this.isParentOf(s) && this.isParentOf(a) && this.getTextContent().length === l;
  }
  excludeFromCopy(e) {
    return e !== "clone";
  }
}
function Nc(t, e) {
  return `${t}-${e}`;
}
function kl(t) {
  return lt(new nn(t));
}
function on(t) {
  return t instanceof nn;
}
function SM(t) {
  return (t == null ? void 0 : t.type) === nn.getType();
}
function Ex(t) {
  const e = t.getChildren();
  let n = null;
  for (const r of e)
    n === null ? t.insertBefore(r) : n.insertAfter(r), n = r;
  t.remove();
}
function Nx(t, e, n, r) {
  const i = t.getNodes(), o = t.anchor.offset, s = t.focus.offset, a = i.length, l = t.isBackward(), c = l ? s : o, u = l ? o : s;
  let f, d;
  for (let h = 0; h < a; h++) {
    const g = i[h];
    if (X(d) && d.isParentOf(g))
      continue;
    const w = h === 0, b = h === a - 1;
    let _ = null;
    if (ie(g)) {
      const y = g.getTextContentSize(), C = w ? c : 0, D = b ? u : y;
      if (C === 0 && D === 0)
        continue;
      const P = g.splitText(C, D);
      _ = P.length > 1 && (P.length === 3 || w && !b || D === y) ? P[1] : P[0];
    } else {
      if (on(g))
        continue;
      X(g) && g.isInline() && (_ = g);
    }
    if (_ !== null) {
      if (_ && _.is(f))
        continue;
      const y = _.getParent();
      (y == null || !y.is(f)) && (d = void 0), f = y, d === void 0 && (d = kl({ [e]: [n] }), _.insertBefore(d)), d.append(_);
    } else
      f = void 0, d = void 0;
  }
  e === $i && X(d) && (l ? d.selectStart() : d.selectEnd());
}
function TM(t, e, n) {
  let r = t;
  for (; r !== null; ) {
    if (on(r))
      return r.getTypedIDs()[e];
    if (ie(r) && n === r.getTextContentSize()) {
      const i = r.getNextSibling();
      if (on(i))
        return i.getTypedIDs()[e];
    }
    r = r.getParent();
  }
}
function Mb(t) {
  return `external-${t}`;
}
const Sx = 1;
class io extends eo {
  constructor(e = "", n = "", r) {
    super(r), me(this, "__textType"), me(this, "__text"), this.__textType = e, this.__text = n;
  }
  static getType() {
    return "immutable-typed-text";
  }
  static clone(e) {
    const { __textType: n, __text: r, __key: i } = e;
    return new io(n, r, i);
  }
  static importDOM() {
    return {
      span: (e) => DM(e) ? {
        conversion: AM,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return ea().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setTextType(e.textType).setTextContent(e.text);
  }
  setTextType(e) {
    if (this.__textType === e)
      return this;
    const n = this.getWritable();
    return n.__textType = e, n;
  }
  getTextType() {
    return this.getLatest().__textType;
  }
  setTextContent(e) {
    if (this.__text === e)
      return this;
    const n = this.getWritable();
    return n.__text = e, n;
  }
  getTextContent() {
    return this.getLatest().__text;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.setAttribute("data-text-type", this.__textType), e.classList.add(this.__textType), e;
  }
  updateDOM() {
    return !1;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && it(n) && n.setAttribute("data-text-type", this.getTextType()), { element: n };
  }
  decorate() {
    return this.getTextContent();
  }
  exportJSON() {
    return {
      type: this.getType(),
      textType: this.getTextType(),
      text: this.getTextContent(),
      version: Sx
    };
  }
  // Mutation
  isKeyboardSelectable() {
    return !1;
  }
}
function AM(t) {
  const e = t.getAttribute("data-text-type") ?? "", n = t.textContent ?? "";
  return { node: ea(e, n) };
}
function ea(t, e) {
  return lt(new io(t, e));
}
function DM(t) {
  return (t == null ? void 0 : t.tagName) === "span";
}
function Eu(t) {
  return t instanceof io;
}
function MM(t) {
  return (t == null ? void 0 : t.type) === io.getType();
}
const Nu = "unmatched", Tx = 1;
class oo extends eo {
  constructor(e = "", n) {
    super(n), me(this, "__marker"), this.__marker = e;
  }
  static getType() {
    return "unmatched";
  }
  static clone(e) {
    const { __marker: n, __key: r } = e;
    return new oo(n, r);
  }
  static importDOM() {
    return {
      [Nu]: (e) => IM(e) ? {
        conversion: OM,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return vg().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  createDOM() {
    const e = document.createElement(Nu);
    e.setAttribute("data-marker", this.__marker), e.classList.add(Db);
    const n = this.__marker.endsWith("*");
    return e.title = n ? "This closing marker has no matching opening marker!" : "This opening marker has no matching closing marker!", e;
  }
  updateDOM() {
    return !1;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && it(n) && (n.setAttribute("data-marker", this.getMarker()), n.classList.add(Db)), { element: n };
  }
  decorate() {
    return `\\${this.getMarker()}${Sh}`;
  }
  exportJSON() {
    return {
      type: this.getType(),
      marker: this.getMarker(),
      version: Tx
    };
  }
  // Mutation
  isKeyboardSelectable() {
    return !1;
  }
}
function OM(t) {
  const e = t.getAttribute("data-marker") ?? "";
  return { node: vg(e) };
}
function vg(t) {
  return lt(new oo(t));
}
function IM(t) {
  return (t == null ? void 0 : t.tagName) === Nu;
}
function Ax(t) {
  return t instanceof oo;
}
const RM = [
  sr,
  Ni,
  Ar,
  xn,
  yt,
  Wt,
  Qr,
  as,
  ss,
  io,
  oo,
  In,
  Gi,
  {
    replace: to,
    with: () => br(),
    withKlass: Gi
  }
];
var z;
(function(t) {
  t.FileIdentification = "FileIdentification", t.Headers = "Headers", t.Remarks = "Remarks", t.Introduction = "Introduction", t.DivisionMarks = "DivisionMarks", t.Paragraphs = "Paragraphs", t.Poetry = "Poetry", t.TitlesHeadings = "TitlesHeadings", t.Tables = "Tables", t.CenterTables = "CenterTables", t.RightTables = "RightTables", t.Lists = "Lists", t.Footnotes = "Footnotes", t.CrossReferences = "CrossReferences", t.SpecialText = "SpecialText", t.CharacterStyling = "CharacterStyling", t.Breaks = "Breaks", t.SpecialFeatures = "SpecialFeatures", t.PeripheralReferences = "PeripheralReferences", t.PeripheralMaterials = "PeripheralMaterials", t.Uncategorized = "Uncategorized";
})(z || (z = {}));
var U;
(function(t) {
  t.Paragraph = "Paragraph", t.Character = "Character", t.Note = "Note", t.Unknown = "Unknown";
})(U || (U = {}));
const PM = {
  id: {
    category: z.FileIdentification,
    type: U.Paragraph,
    description: "File identification information (BOOKID, FILENAME, EDITOR, MODIFICATION DATE)",
    hasEndMarker: !1,
    children: {
      FileIdentification: ["usfm", "ide"],
      Headers: ["h", "h1", "h2", "h3", "toc1", "toc2", "toc3"],
      Remarks: ["rem", "sts", "restore"],
      Introduction: [
        "imt",
        "imt1",
        "imt2",
        "imt3",
        "imt4",
        "imte",
        "imte1",
        "imte2",
        "is",
        "is1",
        "is2",
        "iot",
        "io",
        "io1",
        "io2",
        "io3",
        "io4",
        "ior",
        "ip",
        "im",
        "ipi",
        "imi",
        "ili",
        "ili1",
        "ili2",
        "ipq",
        "imq",
        "ipr",
        "ib",
        "iq",
        "iq1",
        "iq2",
        "iq3",
        "iex",
        "ie"
      ],
      DivisionMarks: ["c", "cl"],
      TitlesHeadings: ["mt", "mt1", "mt2", "mt3", "mt4"]
    }
  },
  usfm: {
    category: z.FileIdentification,
    type: U.Paragraph,
    description: "File markup version information",
    hasEndMarker: !1,
    children: void 0
  },
  ide: {
    category: z.FileIdentification,
    type: U.Paragraph,
    description: "File encoding information",
    hasEndMarker: !1,
    children: {
      Remarks: ["rem", "sts"]
    }
  },
  h: {
    category: z.Headers,
    type: U.Paragraph,
    description: "Running header text for a book (basic)",
    hasEndMarker: !1,
    children: {
      Headers: ["toc1", "toc2", "toc3", "toca1", "toca2", "toca3"]
    }
  },
  h1: {
    category: z.Headers,
    type: U.Paragraph,
    description: "Running header text",
    hasEndMarker: !1,
    children: {
      Headers: ["toc1", "toc2", "toc3", "toca1", "toca2", "toca3"]
    }
  },
  h2: {
    category: z.Headers,
    type: U.Paragraph,
    description: "Running header text, left side of page",
    hasEndMarker: !1,
    children: {
      Headers: ["toc1", "toc2", "toc3", "toca1", "toca2", "toca3"]
    }
  },
  h3: {
    category: z.Headers,
    type: U.Paragraph,
    description: "Running header text, right side of page",
    hasEndMarker: !1,
    children: {
      Headers: ["toc1", "toc2", "toc3", "toca1", "toca2", "toca3"]
    }
  },
  toc1: {
    category: z.Headers,
    type: U.Paragraph,
    description: "Long table of contents text",
    hasEndMarker: !1,
    children: void 0
  },
  toc2: {
    category: z.Headers,
    type: U.Paragraph,
    description: "Short table of contents text",
    hasEndMarker: !1,
    children: void 0
  },
  toc3: {
    category: z.Headers,
    type: U.Paragraph,
    description: "Book Abbreviation",
    hasEndMarker: !1,
    children: void 0
  },
  toca1: {
    category: z.Headers,
    type: U.Paragraph,
    description: "Alternative language long table of contents text",
    hasEndMarker: !1,
    children: void 0
  },
  toca2: {
    category: z.Headers,
    type: U.Paragraph,
    description: "Alternative language short table of contents text",
    hasEndMarker: !1,
    children: void 0
  },
  toca3: {
    category: z.Headers,
    type: U.Paragraph,
    description: "Alternative language book Abbreviation",
    hasEndMarker: !1,
    children: void 0
  },
  rem: {
    category: z.Remarks,
    type: U.Paragraph,
    description: "Comments and remarks",
    hasEndMarker: !1,
    children: void 0
  },
  sts: {
    category: z.Remarks,
    type: U.Paragraph,
    description: "Status of this file",
    hasEndMarker: !1,
    children: void 0
  },
  restore: {
    category: z.Remarks,
    type: U.Paragraph,
    description: "Project restore information",
    hasEndMarker: !1,
    children: void 0
  },
  imt: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction major title, level 1 (if single level) (basic)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imt1: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction major title, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imt2: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction major title, level 2",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imt3: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction major title, level 3",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imt4: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction major title, level 4 (usually within parenthesis)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imte: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction major title at introduction end, level 1 (if single level)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imte1: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction major title at introduction end, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  imte2: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction major title at introduction end, level 2",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  is: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction section heading, level 1 (if single level) (basic)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"],
      CharacterStyling: ["no"]
    }
  },
  is1: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction section heading, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  is2: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction section heading, level 2",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      SpecialText: ["bk"]
    }
  },
  iot: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction outline title (basic)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CharacterStyling: ["no"]
    }
  },
  io: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction outline text, level 1 (if single level)",
    hasEndMarker: !1,
    children: {
      Introduction: ["ior", "iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  io1: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction outline text, level 1 (if multiple levels) (basic)",
    hasEndMarker: !1,
    children: {
      Introduction: ["ior", "iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  io2: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction outline text, level 2",
    hasEndMarker: !1,
    children: {
      Introduction: ["ior", "iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  io3: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction outline text, level 3",
    hasEndMarker: !1,
    children: {
      Introduction: ["ior", "iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  io4: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction outline text, level 4",
    hasEndMarker: !1,
    children: {
      Introduction: ["ior", "iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ior: {
    category: z.Introduction,
    type: U.Character,
    description: "Introduction references range for outline entry; for marking references separately",
    hasEndMarker: !0,
    children: void 0
  },
  ip: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction prose paragraph (basic)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  im: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction prose paragraph, with no first line indent (may occur after poetry)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ipi: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction prose paragraph, indented, with first line indent",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  imi: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction prose paragraph text, indented, with no first line indent",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ili: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "A list entry, level 1 (if single level)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ili1: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "A list entry, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ili2: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "A list entry, level 2",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ipq: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction prose paragraph, quote from the body text",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  imq: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction prose paragraph, quote from the body text, with no first line indent",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ipr: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction prose paragraph, right aligned",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ib: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction blank line",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"]
    }
  },
  iq: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction poetry text, level 1 (if single level)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  iq1: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction poetry text, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  iq2: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction poetry text, level 2",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  iq3: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction poetry text, level 3",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  iex: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction explanatory or bridge text (e.g. explanation of missing book in Short Old Testament)",
    hasEndMarker: !1,
    children: {
      Introduction: ["iqt"],
      CharacterStyling: ["no"]
    }
  },
  iqt: {
    category: z.Introduction,
    type: U.Character,
    description: "For quoted scripture text appearing in the introduction",
    hasEndMarker: !0,
    children: void 0
  },
  ie: {
    category: z.Introduction,
    type: U.Paragraph,
    description: "Introduction ending marker",
    hasEndMarker: !1,
    children: void 0
  },
  c: {
    category: z.DivisionMarks,
    type: U.Paragraph,
    description: "Chapter number",
    hasEndMarker: !1,
    children: {
      DivisionMarks: ["ca", "cp", "cl", "cd"],
      Paragraphs: ["p", "m", "po", "pr", "cls", "pi", "pi1", "pi2", "pi3", "pc", "mi", "nb"],
      Poetry: ["q", "q1", "q2", "q3", "q4", "qc", "qr", "qa", "qd", "b"],
      TitlesHeadings: [
        "mte",
        "ms",
        "ms1",
        "ms2",
        "ms3",
        "s",
        "s1",
        "s2",
        "s3",
        "s4",
        "r",
        "sp",
        "d",
        "sd",
        "sd1",
        "sd2",
        "sd3",
        "sd4"
      ],
      Lists: ["lh", "li", "li1", "li2", "li3", "li4", "lf", "lim", "lim1", "lim2", "lim3", "lim4"],
      Footnotes: ["f", "fe"],
      SpecialText: ["lit"],
      Breaks: ["pb"]
    }
  },
  ca: {
    category: z.DivisionMarks,
    type: U.Character,
    description: "Second (alternate) chapter number (for coding dual versification; useful for places where different traditions of chapter breaks need to be supported in the same translation)",
    hasEndMarker: !0,
    children: void 0
  },
  cp: {
    category: z.DivisionMarks,
    type: U.Paragraph,
    description: "Published chapter number (chapter string that should appear in the published text)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f"]
    }
  },
  cl: {
    category: z.DivisionMarks,
    type: U.Paragraph,
    description: "Chapter label used for translations that add a word such as 'Chapter' before chapter numbers (e.g. Psalms). The subsequent text is the chapter label.",
    hasEndMarker: !1,
    children: void 0
  },
  cd: {
    category: z.DivisionMarks,
    type: U.Paragraph,
    description: "Chapter Description (Publishing option D, e.g. in Russian Bibles)",
    hasEndMarker: !1,
    children: {
      DivisionMarks: ["vp"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  v: {
    category: z.DivisionMarks,
    type: U.Character,
    description: "A verse number",
    hasEndMarker: !1,
    children: void 0
  },
  va: {
    category: z.DivisionMarks,
    type: U.Character,
    description: "Second (alternate) verse number (for coding dual numeration in Psalms; see also NRSV Exo 22.1-4)",
    hasEndMarker: !0,
    children: void 0
  },
  vp: {
    category: z.DivisionMarks,
    type: U.Character,
    description: "Published verse marker (verse string that should appear in the published text)",
    hasEndMarker: !0,
    children: void 0
  },
  p: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Paragraph text, with first line indent (basic)",
    hasEndMarker: !1,
    children: {
      Paragraphs: ["pmo", "pm", "pmc", "pmr"],
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  m: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Paragraph text, with no first line indent (may occur after poetry) (basic)",
    hasEndMarker: !1,
    children: {
      Paragraphs: ["pmo", "pm", "pmc", "pmr"],
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  po: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Letter opening",
    hasEndMarker: !1,
    children: {
      Paragraphs: ["pmo", "pm", "pmc", "pmr"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pr: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Text refrain (paragraph text, right aligned)",
    hasEndMarker: !1,
    children: {
      Paragraphs: ["pmo", "pm", "pmc", "pmr"],
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  cls: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Letter Closing",
    hasEndMarker: !1,
    children: {
      SpecialText: ["tl", "sig", "pn", "png", "addpn", "add"]
    }
  },
  pmo: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Embedded text opening",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pm: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Embedded text paragraph",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pmc: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Embedded text closing",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pmr: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Embedded text refrain (e.g. Then all the people shall say, 'Amen!')",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pi: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Paragraph text, level 1 indent (if single level), with first line indent; often used for discourse (basic)",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pi1: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Paragraph text, level 1 indent (if multiple levels), with first line indent; often used for discourse",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pi2: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Paragraph text, level 2 indent, with first line indent; often used for discourse",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pi3: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Paragraph text, level 3 indent, with first line indent; often used for discourse",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  pc: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Paragraph text, centered (for Inscription)",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  mi: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Paragraph text, indented, with no first line indent; often used for discourse",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  nb: {
    category: z.Paragraphs,
    type: U.Paragraph,
    description: "Paragraph text, with no break from previous paragraph text (at chapter boundary) (basic)",
    hasEndMarker: !1,
    children: {
      Poetry: ["qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  q: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text, level 1 indent (if single level)",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  q1: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text, level 1 indent (if multiple levels) (basic)",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  q2: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text, level 2 indent (basic)",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  q3: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text, level 3 indent",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  q4: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text, level 4 indent",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qc: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text, centered",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qr: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text, Right Aligned",
    hasEndMarker: !1,
    children: {
      Poetry: ["qs", "qac", "qm", "qm1", "qm2", "qm3"],
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qs: {
    category: z.Poetry,
    type: U.Character,
    description: "Poetry text, Selah",
    hasEndMarker: !0,
    children: {
      Footnotes: ["f"],
      CrossReferences: ["x"]
    }
  },
  qa: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text, Acrostic marker/heading",
    hasEndMarker: !1,
    children: void 0
  },
  qac: {
    category: z.Poetry,
    type: U.Character,
    description: "Poetry text, Acrostic markup of the first character of a line of acrostic poetry",
    hasEndMarker: !0,
    children: void 0
  },
  qm: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text, embedded, level 1 indent (if single level)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qm1: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text, embedded, level 1 indent (if multiple levels)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qm2: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text, embedded, level 2 indent",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qm3: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text, embedded, level 3 indent",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  qd: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "A Hebrew musical performance annotation, similar in content to Hebrew descriptive title.",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte1"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  b: {
    category: z.Poetry,
    type: U.Paragraph,
    description: "Poetry text stanza break (e.g. stanza break) (basic)",
    hasEndMarker: !1,
    children: void 0
  },
  mt: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "The main title of the book (if single level)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f"],
      CrossReferences: ["x"]
    }
  },
  mt1: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "The main title of the book (if multiple levels) (basic)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f"],
      CrossReferences: ["x"]
    }
  },
  mt2: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A secondary title usually occurring before the main title (basic)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f"],
      CrossReferences: ["x"]
    }
  },
  mt3: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A secondary title occurring after the main title",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f"],
      CrossReferences: ["x"]
    }
  },
  mt4: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A small secondary title sometimes occurring within parentheses",
    hasEndMarker: !1,
    children: void 0
  },
  mte: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "The main title of the book repeated at the end of the book, level 1 (if single level)",
    hasEndMarker: !1,
    children: void 0
  },
  mte1: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "The main title of the book repeated at the end of the book, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mte2"]
    }
  },
  mte2: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A secondary title occurring before or after the 'ending' main title",
    hasEndMarker: !1,
    children: void 0
  },
  ms: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A major section division heading, level 1 (if single level) (basic)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mr"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ms1: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A major section division heading, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mr"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ms2: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A major section division heading, level 2",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mr"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  ms3: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A major section division heading, level 3",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["mr"],
      Footnotes: ["f", "fe"]
    }
  },
  mr: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A major section division references range heading (basic)",
    hasEndMarker: !1,
    children: void 0
  },
  s: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A section heading, level 1 (if single level) (basic)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["sr", "r"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  s1: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A section heading, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["sr", "r"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  s2: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A section heading, level 2 (e.g. Proverbs 22-24)",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["sr", "r"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  s3: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A section heading, level 3 (e.g. Genesis 'The First Day')",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["sr", "r"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["no", "it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  s4: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A section heading, level 4",
    hasEndMarker: !1,
    children: {
      TitlesHeadings: ["sr", "r"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  sr: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A section division references range heading",
    hasEndMarker: !1,
    children: void 0
  },
  r: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "Parallel reference(s) (basic)",
    hasEndMarker: !1,
    children: void 0
  },
  sp: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A heading, to identify the speaker (e.g. Job)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  d: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "A Hebrew text heading, to provide description (e.g. Psalms)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  sd: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "Vertical space used to divide the text into sections, level 1 (if single level)",
    hasEndMarker: !1,
    children: void 0
  },
  sd1: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "Vertical space used to divide the text into sections, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: void 0
  },
  sd2: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "Vertical space used to divide the text into sections, level 2",
    hasEndMarker: !1,
    children: void 0
  },
  sd3: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "Vertical space used to divide the text into sections, level 3",
    hasEndMarker: !1,
    children: void 0
  },
  sd4: {
    category: z.TitlesHeadings,
    type: U.Paragraph,
    description: "Vertical space used to divide the text into sections, level 4",
    hasEndMarker: !1,
    children: void 0
  },
  lh: {
    category: z.Lists,
    type: U.Paragraph,
    description: "List header (introductory remark)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  li: {
    category: z.Lists,
    type: U.Paragraph,
    description: "A list entry, level 1 (if single level)",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  li1: {
    category: z.Lists,
    type: U.Paragraph,
    description: "A list entry, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  li2: {
    category: z.Lists,
    type: U.Paragraph,
    description: "A list entry, level 2",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  li3: {
    category: z.Lists,
    type: U.Paragraph,
    description: "A list entry, level 3",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  li4: {
    category: z.Lists,
    type: U.Paragraph,
    description: "A list entry, level 4",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  lf: {
    category: z.Lists,
    type: U.Paragraph,
    description: "List footer (concluding remark)",
    hasEndMarker: !1,
    children: {
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  lim: {
    category: z.Lists,
    type: U.Paragraph,
    description: "An embedded list entry, level 1 (if single level)",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  lim1: {
    category: z.Lists,
    type: U.Paragraph,
    description: "An embedded list entry, level 1 (if multiple levels)",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  lim2: {
    category: z.Lists,
    type: U.Paragraph,
    description: "An embedded list entry, level 2",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  lim3: {
    category: z.Lists,
    type: U.Paragraph,
    description: "An embedded list item, level 3",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  lim4: {
    category: z.Lists,
    type: U.Paragraph,
    description: "An embedded list entry, level 4",
    hasEndMarker: !1,
    children: {
      Lists: ["litl", "lik", "liv", "liv1", "liv2", "liv3", "liv4", "liv5"],
      Footnotes: ["f", "fe", "fm"],
      CrossReferences: ["x", "xt", "rq"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  litl: {
    category: z.Lists,
    type: U.Character,
    description: "List entry total text",
    hasEndMarker: !0,
    children: void 0
  },
  lik: {
    category: z.Lists,
    type: U.Character,
    description: "Structured list entry key text",
    hasEndMarker: !0,
    children: void 0
  },
  liv: {
    category: z.Lists,
    type: U.Character,
    description: "Structured list entry value 1 content (if single value)",
    hasEndMarker: !0,
    children: void 0
  },
  liv1: {
    category: z.Lists,
    type: U.Character,
    description: "Structured list entry value 1 content (if multiple values)",
    hasEndMarker: !0,
    children: void 0
  },
  liv2: {
    category: z.Lists,
    type: U.Character,
    description: "Structured list entry value 2 content",
    hasEndMarker: !0,
    children: void 0
  },
  liv3: {
    category: z.Lists,
    type: U.Character,
    description: "Structured list entry value 3 content",
    hasEndMarker: !0,
    children: void 0
  },
  liv4: {
    category: z.Lists,
    type: U.Character,
    description: "Structured list entry value 4 content",
    hasEndMarker: !0,
    children: void 0
  },
  liv5: {
    category: z.Lists,
    type: U.Character,
    description: "Structured list entry value 5 content",
    hasEndMarker: !0,
    children: void 0
  },
  f: {
    category: z.Footnotes,
    type: U.Note,
    description: "A Footnote text item (basic)",
    hasEndMarker: !0,
    children: {
      Footnotes: ["fr", "ft", "fk", "fq", "fqa", "fl", "fw", "fp", "fv", "fdc"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  fe: {
    category: z.Footnotes,
    type: U.Note,
    description: "An Endnote text item",
    hasEndMarker: !0,
    children: {
      Footnotes: ["fr", "ft", "fk", "fq", "fqa", "fl", "fw", "fp", "fv", "fdc"],
      CrossReferences: ["xt"],
      SpecialText: [
        "qt",
        "nd",
        "tl",
        "dc",
        "bk",
        "sig",
        "pn",
        "png",
        "addpn",
        "wj",
        "k",
        "sls",
        "ord",
        "add"
      ],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  fr: {
    category: z.Footnotes,
    type: U.Character,
    description: "The origin reference for the footnote (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  ft: {
    category: z.Footnotes,
    type: U.Character,
    description: "Footnote text, Protocanon (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  fk: {
    category: z.Footnotes,
    type: U.Character,
    description: "A footnote keyword (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  fq: {
    category: z.Footnotes,
    type: U.Character,
    description: "A footnote scripture quote or alternate rendering (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  fqa: {
    category: z.Footnotes,
    type: U.Character,
    description: "A footnote alternate rendering for a portion of scripture text",
    hasEndMarker: !0,
    children: void 0
  },
  fl: {
    category: z.Footnotes,
    type: U.Character,
    description: "A footnote label text item, for marking or 'labelling' the type or alternate translation being provided in the note.",
    hasEndMarker: !0,
    children: void 0
  },
  fw: {
    category: z.Footnotes,
    type: U.Character,
    description: "A footnote witness list, for distinguishing a list of sigla representing witnesses in critical editions.",
    hasEndMarker: !0,
    children: void 0
  },
  fp: {
    category: z.Footnotes,
    type: U.Character,
    description: "A Footnote additional paragraph marker",
    hasEndMarker: !0,
    children: void 0
  },
  fv: {
    category: z.Footnotes,
    type: U.Character,
    description: "A verse number within the footnote text",
    hasEndMarker: !0,
    children: void 0
  },
  fdc: {
    category: z.Footnotes,
    type: U.Character,
    description: "Footnote text, applies to Deuterocanon only",
    hasEndMarker: !0,
    children: void 0
  },
  fm: {
    category: z.Footnotes,
    type: U.Character,
    description: "An additional footnote marker location for a previous footnote",
    hasEndMarker: !0,
    children: void 0
  },
  x: {
    category: z.CrossReferences,
    type: U.Note,
    description: "A list of cross references (basic)",
    hasEndMarker: !0,
    children: {
      CrossReferences: ["xo", "xop", "xt", "xta", "xk", "xq", "xot", "xnt", "xdc"],
      CharacterStyling: ["it", "bd", "bdit", "em", "sc", "sup"]
    }
  },
  xo: {
    category: z.CrossReferences,
    type: U.Character,
    description: "The cross reference origin reference (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  xop: {
    category: z.CrossReferences,
    type: U.Character,
    description: "Published cross reference origin reference (origin reference that should appear in the published text)",
    hasEndMarker: !0,
    children: void 0
  },
  xt: {
    category: z.CrossReferences,
    type: U.Character,
    description: "The cross reference target reference(s), protocanon only (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  xta: {
    category: z.CrossReferences,
    type: U.Character,
    description: "Cross reference target references added text",
    hasEndMarker: !0,
    children: void 0
  },
  xk: {
    category: z.CrossReferences,
    type: U.Character,
    description: "A cross reference keyword",
    hasEndMarker: !0,
    children: void 0
  },
  xq: {
    category: z.CrossReferences,
    type: U.Character,
    description: "A cross-reference quotation from the scripture text",
    hasEndMarker: !0,
    children: void 0
  },
  xot: {
    category: z.CrossReferences,
    type: U.Character,
    description: "Cross-reference target reference(s), Old Testament only",
    hasEndMarker: !0,
    children: void 0
  },
  xnt: {
    category: z.CrossReferences,
    type: U.Character,
    description: "Cross-reference target reference(s), New Testament only",
    hasEndMarker: !0,
    children: void 0
  },
  xdc: {
    category: z.CrossReferences,
    type: U.Character,
    description: "Cross-reference target reference(s), Deuterocanon only",
    hasEndMarker: !0,
    children: void 0
  },
  rq: {
    category: z.CrossReferences,
    type: U.Character,
    description: "A cross-reference indicating the source text for the preceding quotation.",
    hasEndMarker: !0,
    children: void 0
  },
  qt: {
    category: z.SpecialText,
    type: U.Character,
    description: "For Old Testament quoted text appearing in the New Testament (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  nd: {
    category: z.SpecialText,
    type: U.Character,
    description: "For name of deity (basic)",
    hasEndMarker: !0,
    children: void 0
  },
  tl: {
    category: z.SpecialText,
    type: U.Character,
    description: "For transliterated words",
    hasEndMarker: !0,
    children: void 0
  },
  dc: {
    category: z.SpecialText,
    type: U.Character,
    description: "Deuterocanonical/LXX additions or insertions in the Protocanonical text",
    hasEndMarker: !0,
    children: void 0
  },
  bk: {
    category: z.SpecialText,
    type: U.Character,
    description: "For the quoted name of a book",
    hasEndMarker: !0,
    children: void 0
  },
  sig: {
    category: z.SpecialText,
    type: U.Character,
    description: "For the signature of the author of an Epistle",
    hasEndMarker: !0,
    children: void 0
  },
  pn: {
    category: z.SpecialText,
    type: U.Character,
    description: "For a proper name",
    hasEndMarker: !0,
    children: void 0
  },
  png: {
    category: z.SpecialText,
    type: U.Character,
    description: "For a geographic proper name",
    hasEndMarker: !0,
    children: void 0
  },
  addpn: {
    category: z.SpecialText,
    type: U.Character,
    description: "For chinese words to be dot underline & underline",
    hasEndMarker: !0,
    children: void 0
  },
  wj: {
    category: z.SpecialText,
    type: U.Character,
    description: "For marking the words of Jesus",
    hasEndMarker: !0,
    children: void 0
  },
  k: {
    category: z.SpecialText,
    type: U.Character,
    description: "For a keyword",
    hasEndMarker: !0,
    children: void 0
  },
  sls: {
    category: z.SpecialText,
    type: U.Character,
    description: "To represent where the original text is in a secondary language or from an alternate text source",
    hasEndMarker: !0,
    children: void 0
  },
  ord: {
    category: z.SpecialText,
    type: U.Character,
    description: "For the text portion of an ordinal number",
    hasEndMarker: !0,
    children: void 0
  },
  add: {
    category: z.SpecialText,
    type: U.Character,
    description: "For a translational addition to the text",
    hasEndMarker: !0,
    children: void 0
  },
  lit: {
    category: z.SpecialText,
    type: U.Paragraph,
    description: "For a comment or note inserted for liturgical use",
    hasEndMarker: !1,
    children: void 0
  },
  no: {
    category: z.CharacterStyling,
    type: U.Character,
    description: "A character style, use normal text",
    hasEndMarker: !0,
    children: void 0
  },
  it: {
    category: z.CharacterStyling,
    type: U.Character,
    description: "A character style, use italic text",
    hasEndMarker: !0,
    children: void 0
  },
  bd: {
    category: z.CharacterStyling,
    type: U.Character,
    description: "A character style, use bold text",
    hasEndMarker: !0,
    children: void 0
  },
  bdit: {
    category: z.CharacterStyling,
    type: U.Character,
    description: "A character style, use bold + italic text",
    hasEndMarker: !0,
    children: void 0
  },
  em: {
    category: z.CharacterStyling,
    type: U.Character,
    description: "A character style, use emphasized text style",
    hasEndMarker: !0,
    children: void 0
  },
  sc: {
    category: z.CharacterStyling,
    type: U.Character,
    description: "A character style, for small capitalization text",
    hasEndMarker: !0,
    children: void 0
  },
  sup: {
    category: z.CharacterStyling,
    type: U.Character,
    description: "A character style, for superscript text. Typically for use in critical edition footnotes.",
    hasEndMarker: !0,
    children: void 0
  },
  pb: {
    category: z.Breaks,
    type: U.Paragraph,
    description: "Page Break used for new reader portions and children's bibles where content is controlled by the page",
    hasEndMarker: !1,
    children: void 0
  }
}, po = {
  DivisionMarks: { add: ["v", "c"], remove: [] },
  Paragraphs: { add: ["p"], remove: [] },
  Poetry: { add: ["q", "q1", "q2", "q3", "q4", "b"], remove: [] },
  TitlesHeadings: {
    add: [
      "mte",
      "ms",
      "ms1",
      "ms2",
      "ms3",
      "s",
      "s1",
      "s2",
      "s3",
      "s4",
      "r",
      "sp",
      "d",
      "sd",
      "sd1",
      "sd2",
      "sd3",
      "sd4"
    ],
    remove: []
  }
}, LM = {
  p: { children: po },
  q: { children: po },
  q1: { children: po },
  q2: { children: po },
  q3: { children: po },
  q4: { children: po },
  b: { children: po },
  qm: {
    children: {
      Paragraphs: { add: ["p"], remove: [] }
    }
  },
  c: {
    type: U.Paragraph,
    children: null
  },
  v: {
    children: null
  }
};
function Ob(t) {
  const e = PM[t], n = LM[t];
  if (!e)
    return;
  if (!n)
    return e;
  let r = e.children ? { ...e.children } : void 0;
  if (n.children === null && (r = void 0), n.children) {
    r = r || {};
    for (const [i, o] of Object.entries(n.children)) {
      const s = i;
      if (o === null)
        Reflect.deleteProperty(r, s);
      else {
        let a = r[s] || [];
        o.remove && (a = a.filter((l) => !o.remove.includes(l))), o.add && (a = [.../* @__PURE__ */ new Set([...a, ...o.add])]), a.length > 0 ? r[s] = a : Reflect.deleteProperty(r, s);
      }
    }
    Object.keys(r).length === 0 && (r = void 0);
  }
  return {
    ...e,
    ...n,
    children: r
  };
}
function Ib(t, e, n) {
  const r = {
    type: ol,
    version: sl,
    content: t
  }, i = e.serializeEditorState(r, n);
  return dg(i.root.children[0]) ? i.root.children[0].children[0] : i.root.children[0];
}
function Ih(t, e) {
  if (!t || !ie(t))
    return [void 0, void 0];
  const n = t.getTextContent();
  if (e >= 0 && e < n.length)
    return [t, e];
  let r = t.getNextSibling();
  if (!r) {
    const o = t.getParent();
    on(o) && (r = o.getNextSibling());
  }
  if (!r || !on(r) && !ie(r))
    return [void 0, void 0];
  const i = e - n.length;
  return r && ie(r) ? Ih(r, i) : Ih(r.getFirstChild() ?? void 0, i);
}
function Rb(t) {
  const e = zC(t.jsonPath);
  let n = Ve();
  for (const r of e) {
    if (!n || !X(n))
      return [void 0, void 0];
    n = n.getChildAtIndex(r) ?? void 0;
  }
  return Ih(n, t.offset);
}
function Pb(t) {
  return X(t) ? "element" : "text";
}
function _g(t) {
  const { start: e } = t;
  let { end: n } = t;
  n === void 0 && (n = e);
  const [r, i] = Rb(e), [o, s] = Rb(n);
  if (!r || !o || i === void 0 || s === void 0)
    return;
  const a = $l();
  return a.anchor = On(r.getKey(), i, Pb(r)), a.focus = On(o.getKey(), s, Pb(o)), a;
}
function Lb(t, e) {
  const n = [];
  let r = t;
  for (; r != null && r.getParent(); ) {
    const i = r.getParent();
    if (i) {
      const o = i == null ? void 0 : i.getChildren().indexOf(r);
      o >= 0 && n.unshift(o);
    }
    r = i;
  }
  return { jsonPath: VC(n), offset: e };
}
function Dx() {
  const t = oe();
  if (!t || !Z(t))
    return;
  const e = t.isBackward() ? t.focus.getNode() : t.anchor.getNode(), n = t.isBackward() ? t.focus.offset : t.anchor.offset, r = Lb(e, n);
  if (t.isCollapsed())
    return { start: r };
  const i = t.isBackward() ? t.anchor.getNode() : t.focus.getNode(), o = t.isBackward() ? t.anchor.offset : t.focus.offset, s = Lb(i, o);
  return { start: r, end: s };
}
const Mx = "v", Ox = 1;
class Cn extends eo {
  constructor(e = "", n = !1, r, i, o, s, a) {
    super(a), me(this, "__marker"), me(this, "__number"), me(this, "__showMarker"), me(this, "__sid"), me(this, "__altnumber"), me(this, "__pubnumber"), me(this, "__unknownAttributes"), this.__marker = Mx, this.__number = e, this.__showMarker = n, this.__sid = r, this.__altnumber = i, this.__pubnumber = o, this.__unknownAttributes = s;
  }
  static getType() {
    return "immutable-verse";
  }
  static clone(e) {
    const { __number: n, __showMarker: r, __sid: i, __altnumber: o, __pubnumber: s, __unknownAttributes: a, __key: l } = e;
    return new Cn(n, r, i, o, s, a, l);
  }
  static importDOM() {
    return {
      span: (e) => FM(e) ? {
        conversion: $M,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return xg().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setMarker(e.marker).setNumber(e.number).setShowMarker(e.showMarker).setSid(e.sid).setAltnumber(e.altnumber).setPubnumber(e.pubnumber).setUnknownAttributes(e.unknownAttributes);
  }
  setMarker(e) {
    if (this.__marker === e)
      return this;
    const n = this.getWritable();
    return n.__marker = e, n;
  }
  getMarker() {
    return this.getLatest().__marker;
  }
  setNumber(e) {
    if (this.__number === e)
      return this;
    const n = this.getWritable();
    return n.__number = e, n;
  }
  getNumber() {
    return this.getLatest().__number;
  }
  setShowMarker(e = !1) {
    if (this.__showMarker === e)
      return this;
    const n = this.getWritable();
    return n.__showMarker = e, n;
  }
  getShowMarker() {
    return this.getLatest().__showMarker;
  }
  setSid(e) {
    if (this.__sid === e)
      return this;
    const n = this.getWritable();
    return n.__sid = e, n;
  }
  getSid() {
    return this.getLatest().__sid;
  }
  setAltnumber(e) {
    if (this.__altnumber === e)
      return this;
    const n = this.getWritable();
    return n.__altnumber = e, n;
  }
  getAltnumber() {
    return this.getLatest().__altnumber;
  }
  setPubnumber(e) {
    if (this.__pubnumber === e)
      return this;
    const n = this.getWritable();
    return n.__pubnumber = e, n;
  }
  getPubnumber() {
    return this.getLatest().__pubnumber;
  }
  setUnknownAttributes(e) {
    const n = this.getWritable();
    return n.__unknownAttributes = e, n;
  }
  getUnknownAttributes() {
    return this.getLatest().__unknownAttributes;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.setAttribute("data-marker", this.__marker), e.classList.add(Th, `usfm_${this.__marker}`), this.__showMarker && e.classList.add("marker"), e.setAttribute("data-number", this.__number), e;
  }
  updateDOM() {
    return !1;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && it(n) && (n.setAttribute("data-marker", this.getMarker()), n.classList.add(Th, `usfm_${this.getMarker()}`), n.setAttribute("data-number", this.getNumber())), { element: n };
  }
  decorate() {
    return p("span", { children: this.getShowMarker() ? Gl(this.getMarker(), this.getNumber()) : (
      // ZWSP added so double click word selection works without including this number.
      Sh + this.getNumber() + Sh
    ) });
  }
  exportJSON() {
    return {
      type: this.getType(),
      marker: this.getMarker(),
      number: this.getNumber(),
      showMarker: this.getShowMarker(),
      sid: this.getSid(),
      altnumber: this.getAltnumber(),
      pubnumber: this.getPubnumber(),
      unknownAttributes: this.getUnknownAttributes(),
      version: Ox
    };
  }
  // Mutation
  isKeyboardSelectable() {
    return !1;
  }
}
function $M(t) {
  const e = t.getAttribute("data-number") ?? "0";
  return { node: xg(e) };
}
function xg(t, e, n, r, i, o) {
  return lt(new Cn(t, e, n, r, i, o));
}
function FM(t) {
  return ((t == null ? void 0 : t.getAttribute("data-marker")) ?? void 0) === Mx;
}
function xa(t) {
  return t instanceof Cn;
}
function BM(t) {
  return (t == null ? void 0 : t.type) === Cn.getType();
}
function ir(t) {
  return pg(t) || xa(t);
}
function qM(t) {
  return lM(t) || BM(t);
}
function jM(t, e, n, r, i, o, s) {
  if (!Wt.isValidMarker(t))
    throw new Error(`$insertNote: Invalid note marker '${t}'`);
  const a = n ? _g(n) : oe();
  if (!Z(a))
    return;
  const l = UM(a, t, r, s);
  if (l === void 0)
    return;
  const c = Rx(t, e, l, i, o);
  return Ix(c, a, i), c;
}
function Ix(t, e, n) {
  const r = (n == null ? void 0 : n.noteMode) === "collapsed";
  if (t.setIsCollapsed(r), e.isCollapsed() || mM(e), e.insertNodes([t]), !r) {
    const i = t.getChildren().reverse().find(at);
    i == null || i.selectEnd();
  }
}
function UM(t, e, n, r) {
  const i = [], { chapterNum: o, verseNum: s } = n ?? {};
  switch (e) {
    case "f":
    case "fe":
    case "ef":
    case "efe":
      if (o !== void 0 && s !== void 0 && i.push(Ur("fr").append(Re(`${o}:${s}`))), !t.isCollapsed()) {
        const a = t.getTextContent().trim();
        if (a.length > 0) {
          const l = Ur("fq");
          l.append(Re(a)), i.push(l);
        }
      }
      i.push(Ur("ft").append(Re("-")));
      break;
    case "x":
    case "ex":
      o !== void 0 && s !== void 0 && i.push(Ur("xo").append(Re(`${o}:${s}`))), i.push(Ur("xt").append(Re("-")));
      break;
    default:
      r == null || r.warn(`$createNoteChildren: Unsupported note marker '${e}'`);
      return;
  }
  return i;
}
function Rx(t, e, n, r, i, o) {
  const s = (r == null ? void 0 : r.noteMode) !== "expanded", a = hg(t, e, s);
  o && pi(a, Ko, () => o);
  let l, c;
  (r == null ? void 0 : r.markerMode) === "editable" ? (l = Zs(t), c = Zs(t, "closing")) : (r == null ? void 0 : r.markerMode) === "visible" && (l = ea("marker", Si(t) + st), c = ea("marker", Qs(t) + st));
  let u;
  if (l && a.append(l), (r == null ? void 0 : r.markerMode) === "editable")
    e === "" ? a.append(...n) : (u = Re(mg(a.__caller)), a.append(u, ...n));
  else {
    const f = () => Re(st), d = n.flatMap(VM(f));
    if (e === "")
      a.append(...d);
    else {
      const h = bg(n);
      let g = () => {
      };
      i != null && i.noteCallerOnClick && (g = i.noteCallerOnClick), u = Ng(a.__caller, h, g), a.append(u, f(), ...d);
    }
  }
  return c && a.append(c), a;
}
function $b(t) {
  var e;
  if (typeof t == "string") {
    const i = Oe(t);
    return je(i) ? i : void 0;
  }
  const n = jl();
  if (n.length <= 0)
    return;
  const r = (e = n.filter((i) => je(i.node))[t]) == null ? void 0 : e.node;
  if (je(r))
    return r;
}
function zM(t, e) {
  const n = (e == null ? void 0 : e.noteMode) === "collapsed";
  if (t.setIsCollapsed(n), n) {
    const r = t.getPreviousSibling();
    if (xa(r) || !r) {
      const i = t.getParent();
      if (i) {
        const o = t.getIndexWithinParent();
        i.select(o, o);
      }
    } else
      r.selectEnd();
  } else {
    const r = t.getChildren().reverse().find(at);
    r == null || r.selectEnd();
  }
}
function VM(t) {
  return (e) => Eu(e) ? [e] : [e, t()];
}
function HM(t) {
  return t.find((e) => fn(e));
}
function KM(t, e) {
  return X(t) ? t.getChildren().find((n) => ir(n) && yg(e, n.getNumber())) : void 0;
}
function WM(t, e) {
  return e === 0 ? HM(t) : t.map((n) => KM(n, e)).filter((n) => n)[0];
}
function Fb(t) {
  return !t || !X(t) ? void 0 : t.getChildren().findLast((e) => ir(e));
}
function Px(t) {
  var e, n;
  if (!t || rr(t))
    return;
  if (ir(t))
    return t;
  let r = on(t.getParent()) ? (e = t.getParent()) == null ? void 0 : e.getPreviousSibling() : t.getPreviousSibling();
  for (; r && !ir(r) && !rr(r); )
    r = r.getPreviousSibling();
  if (r && ir(r))
    return r;
  let i = (n = t.getTopLevelElement()) == null ? void 0 : n.getPreviousSibling(), o = Fb(i), s = o;
  for (; i && !o && !rr(i); )
    o = s, i = i.getPreviousSibling(), s = Fb(i);
  if (!(!o && rr(i)))
    return o;
}
function GM(t) {
  return fM(t) || xa(t);
}
function Cg(t) {
  if (ie(t)) {
    const e = t.getTextContent();
    !e.endsWith(" ") && !e.endsWith(st) && t.setTextContent(`${e} `);
  }
}
function Lx(t) {
  if (ie(t)) {
    const e = t.getTextContent();
    e.startsWith(" ") && t.setTextContent(e.trimStart());
  }
}
function kg(t, e) {
  return t.getEditorState().read(() => !Oe(e));
}
const JM = ["style"], XM = ["style", "code"], Su = ["style", "cid"], YM = [
  "style",
  "number",
  "sid",
  "altnumber",
  "pubnumber"
], QM = [
  "style",
  "number",
  "sid",
  "altnumber",
  "pubnumber"
], ZM = ["style", "sid", "eid"], eO = ["style", "caller", "category", "contents"], tO = [
  "chapter",
  "immutable-chapter",
  "verse",
  "immutable-verse",
  "ms",
  "note",
  "unmatched"
], El = `
`;
function nO(t, e) {
  const n = Oe(t);
  if (!Er(n))
    return;
  const r = $x(n);
  return r === void 0 ? void 0 : [{ retain: r }, ...e, { delete: 1 }];
}
function $x(t) {
  if (!t)
    return;
  const e = jl();
  let n = 0;
  const r = [];
  let i, o;
  const s = t.getKey();
  let a;
  for (const l of e) {
    const c = l.node;
    for (let u = r.length - 1; u >= 0; u--)
      if (Nl(r[u], l)) {
        const f = r[u];
        if (r.splice(u, 1), n += 1, a && f.getKey() === a.getKey())
          return n - 1;
      }
    if (i && Nl(i, l) && (i = void 0, o = void 0), i) {
      if (c.getKey() === s)
        return o;
      continue;
    }
    if (c.getKey() === s) {
      if (ie(c) || Er(c))
        return n;
      ar(c) && (a = c);
    }
    if (ar(c) && (r.includes(c) || r.push(c)), je(c)) {
      i = c, o = n, n += 1;
      continue;
    }
    n += Fx(c);
  }
  if (a)
    return n;
}
function Bb(t, e) {
  if (t.length < 2 || !oO(t[0]) || !iO(t[1]))
    return;
  const n = t[0].retain;
  return e.read(() => {
    const r = rO(n);
    return r == null ? void 0 : r.getKey();
  });
}
function rO(t) {
  const e = jl();
  let n = 0;
  const r = [];
  let i, o;
  for (const s of e) {
    const a = s.node;
    for (let c = r.length - 1; c >= 0; c--)
      if (Nl(r[c], s)) {
        const u = r[c];
        if (r.splice(c, 1), n === t)
          return u;
        n += 1;
      }
    if (i && Nl(i, s) && (i = void 0, o = void 0), i) {
      if (o === t)
        return i;
      continue;
    }
    if (ar(a) && (r.includes(a) || r.push(a)), je(a)) {
      if (i = a, o = n, n === t)
        return a;
      n += 1;
      continue;
    }
    const l = Fx(a);
    if (ie(a) && l > 0 && t >= n && t < n + l || Er(a) && n === t)
      return a;
    n += l;
  }
  for (const s of r) {
    if (n === t)
      return s;
    n += 1;
  }
}
function Nl(t, e) {
  return t ? e ? !gM(e.node, t.getKey()) : !0 : !1;
}
function Er(t) {
  return rr(t) || ir(t) || hd(t) || je(t) || Ax(t);
}
function ar(t) {
  return gr(t) || Jr(t);
}
function La(t, e) {
  return e.insert != null && typeof e.insert == "object" && t in e.insert;
}
function iO(t) {
  if (t.insert == null || typeof t.insert != "object")
    return !1;
  const e = Object.keys(t.insert)[0];
  return t.insert != null && typeof t.insert == "object" && e in t.insert && tO.includes(e);
}
function oO(t) {
  return t.retain != null && typeof t.retain == "number";
}
function Fx(t) {
  return ie(t) ? t.getTextContentSize() : Er(t) ? 1 : 0;
}
function Rh(t, e) {
  const n = { insert: t.__text }, r = $s(t, Ko);
  if (r && (n.attributes = { segment: r }), e && e.length > 0) {
    let i = e.map((o) => {
      const s = { style: o.__marker }, a = $s(o, Ho);
      a && (s.cid = a);
      const l = o.getUnknownAttributes();
      return l && Object.keys(l).length > 0 && Object.assign(s, l), s;
    });
    i.length === 1 && (i = i[0]), n.attributes = {
      ...n.attributes,
      char: i
    };
  }
  return n;
}
function qb(t) {
  const e = new Ha();
  return t.isEmpty() || t.read(() => {
    const n = Ve();
    if (!n || n.isEmpty())
      return;
    const r = n.getChildren();
    if (r.length === 1 && _i(r[0]) && (!r[0].getChildren() || r[0].getChildrenSize() === 0))
      return;
    const i = sO();
    for (const o of i)
      e.push(o);
  }), e;
}
function Eg(t, e) {
  const n = [], r = jl(t), i = [], o = [], s = { children: [], contentsOps: [] };
  for (let a = 0; a < r.length; a++) {
    const l = r[a].node;
    n.push(...jb(l, a, r, i, o, s));
  }
  for (const a of i)
    n.push(...jb(a, r.length, r, i, o, s));
  return n;
}
function sO() {
  return Eg();
}
function jb(t, e, n, r, i, o) {
  if (!t)
    return [];
  const s = [];
  return aO(t, s, r), lO(t, s, i, o), cO(t, e, n, i), rr(t) && s.push(fO(t)), ir(t) && s.push(pO(t)), hd(t) && s.push(gO(t)), Ax(t) && s.push(wO(t)), uO(t, s, o), s;
}
function aO(t, e, n) {
  if (!t.isInline()) {
    const r = n.pop();
    Jr(r) ? e.push(dO(r)) : fn(r) ? e.push(hO(r)) : _i(r) && e.push({ insert: El });
  }
  ar(t) && (n.includes(t) || n.push(t));
}
function lO(t, e, n, r) {
  var i;
  if (!ie(t))
    return;
  const o = t.getParent();
  if (je(o) && o.getFirstChild() === t)
    return;
  const s = Rh(t, n);
  if (r.children.includes(t)) {
    const a = t.getTextContent();
    if (!a || a === st || a.startsWith(ag))
      return;
    (i = r.contentsOps) == null || i.push(s);
  } else
    e.push(s);
}
function cO(t, e, n, r) {
  at(t) && !r.includes(t) && r.push(t);
  const i = n[e + 1];
  for (const o of r.toReversed())
    Nl(o, i) && r.pop();
}
function uO(t, e, n) {
  var r, i;
  if (!je(t))
    return;
  jl(t).forEach((s) => n.children.push(s.node));
  const o = mO(t);
  n.contentsOps = (i = (r = o.insert.note) == null ? void 0 : r.contents) == null ? void 0 : i.ops, e.push(o);
}
function dO(t) {
  const e = { style: xl, code: t.__code };
  return { insert: El, attributes: { book: e } };
}
function fO(t) {
  const e = { style: Cu, number: t.__number };
  return t.__sid && (e.sid = t.__sid), t.__altnumber && (e.altnumber = t.__altnumber), t.__pubnumber && (e.pubnumber = t.__pubnumber), { insert: { chapter: e } };
}
function hO(t) {
  const e = { style: t.__marker };
  return { insert: El, attributes: { para: e } };
}
function pO(t) {
  const e = { style: ku, number: t.__number };
  return t.__sid && (e.sid = t.__sid), t.__altnumber && (e.altnumber = t.__altnumber), t.__pubnumber && (e.pubnumber = t.__pubnumber), { insert: { verse: e } };
}
function gO(t) {
  const e = { style: t.__marker };
  return t.__sid && (e.sid = t.__sid), t.__eid && (e.eid = t.__eid), { insert: { milestone: e } };
}
function wO(t) {
  return { insert: { unmatched: { marker: t.__marker } } };
}
function mO(t) {
  const e = {
    style: t.__marker,
    caller: t.__caller
  };
  t.__category && (e.category = t.__category), t.getChildrenSize() > 1 && (e.contents = { ops: [] });
  const n = { insert: { note: e } }, r = $s(t, Ko);
  return r && (n.attributes = { segment: r }), n;
}
const Bx = 1;
class yr extends eo {
  constructor(e = ji, n = "", r, i) {
    super(i), me(this, "__caller"), me(this, "__previewText"), me(this, "__onClick"), this.__caller = e, this.__previewText = n, this.__onClick = r ?? (() => {
    });
  }
  static getType() {
    return "immutable-note-caller";
  }
  static clone(e) {
    const { __caller: n, __previewText: r, __onClick: i, __key: o } = e;
    return new yr(n, r, i, o);
  }
  static importDOM() {
    return {
      span: (e) => yO(e) ? {
        conversion: bO,
        priority: 1
      } : null
    };
  }
  static importJSON(e) {
    return Ng().updateFromJSON(e);
  }
  updateFromJSON(e) {
    return super.updateFromJSON(e).setCaller(e.caller).setPreviewText(e.previewText).setOnClick(e.onClick);
  }
  setCaller(e) {
    if (this.__caller === e)
      return this;
    const n = this.getWritable();
    return n.__caller = e, n;
  }
  getCaller() {
    return this.getLatest().__caller;
  }
  setPreviewText(e) {
    if (this.__previewText === e)
      return this;
    const n = this.getWritable();
    return n.__previewText = e, n;
  }
  getPreviewText() {
    return this.getLatest().__previewText;
  }
  setOnClick(e) {
    if (this.__onClick === e)
      return this;
    const n = this.getWritable();
    return n.__onClick = e, n;
  }
  getOnClick() {
    return this.getLatest().__onClick;
  }
  createDOM() {
    const e = document.createElement("span");
    return e.classList.add(this.__type), e.setAttribute("data-caller", this.__caller), e.setAttribute("data-preview-text", this.__previewText), e;
  }
  updateDOM(e) {
    return e.__caller !== this.__caller;
  }
  exportDOM(e) {
    const { element: n } = super.exportDOM(e);
    return n && it(n) && (n.classList.add(this.getType()), n.setAttribute("data-caller", this.getCaller()), n.setAttribute("data-preview-text", this.getPreviewText())), { element: n };
  }
  decorate(e) {
    const n = this.getParent();
    if (!n)
      return null;
    const r = n.getKey(), i = n.getIsCollapsed(), o = this.__key, s = (l) => {
      var c;
      return (c = this.__onClick) == null ? void 0 : c.call(this, l, r, i, () => vO(e, r), (u) => _O(e, r, o, u), () => xO(e, r));
    }, a = `${this.__caller}_${this.__previewText}}`.replace(/\s+/g, "").substring(0, 25);
    return p("button", { onClick: s, title: this.__previewText, "data-caller-id": a, children: this.__caller === ji && i ? (
      // Caller is generated by CSS
      ""
    ) : this.__caller });
  }
  exportJSON() {
    return {
      type: this.getType(),
      caller: this.getCaller(),
      previewText: this.getPreviewText(),
      onClick: this.getOnClick(),
      version: Bx
    };
  }
  // Mutation
  isKeyboardSelectable() {
    return !1;
  }
}
function bO(t) {
  const e = t.getAttribute("data-caller") ?? "", n = t.getAttribute("data-preview-text") ?? "";
  return { node: Ng(e, n) };
}
function Ng(t, e, n) {
  return lt(new yr(t, e, n));
}
function yO(t) {
  return t ? t.classList.contains(yr.getType()) : !1;
}
function so(t) {
  return t instanceof yr;
}
function vO(t, e) {
  return t.read(() => {
    const n = Oe(e);
    if (!je(n))
      throw new Error(`getNoteCaller: Note node not found: ${e}`);
    return n.getCaller();
  });
}
function _O(t, e, n, r) {
  t.update(() => {
    const i = Oe(e);
    if (!je(i))
      throw new Error(`setNoteCaller: Note node not found: ${e}`);
    i.setCaller(r);
    const o = Oe(n);
    if (!so(o))
      throw new Error(`setNoteCaller: Caller node not found: ${n}`);
    o.setCaller(r);
  });
}
function xO(t, e) {
  return t.read(() => {
    const n = Oe(e);
    if (!je(n))
      throw new Error(`getNoteOps: Note node not found: ${e}`);
    return Eg(n);
  });
}
const CO = [
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z"
], kO = [
  yr,
  Cn,
  ...RM
], EO = Yn((t, e) => {
  const { coords: n, children: r, style: i, ...o } = t, s = n !== void 0;
  return p("div", { ref: e, className: "floating-box", "aria-hidden": !s, style: {
    ...i,
    position: "absolute",
    zIndex: 1e3,
    top: n == null ? void 0 : n.y,
    left: n == null ? void 0 : n.x,
    visibility: s ? "visible" : "hidden",
    opacity: s ? 1 : 0
  }, ...o, children: r });
});
function NO() {
  const [t, e] = ue(void 0), [n, r] = ue(), i = ye(null), o = be((a, l) => {
    i.current && i.current();
    const c = a.commonAncestorContainer.nodeType === a.commonAncestorContainer.TEXT_NODE ? a : a.commonAncestorContainer;
    i.current = CT(c, l, () => {
      NT(c, l, {
        placement: "bottom-start",
        middleware: [kT(), ET()]
      }).then((u) => {
        r(u.placement), e((f) => (f == null ? void 0 : f.x) === u.x && (f == null ? void 0 : f.y) === u.y ? f : { x: u.x, y: u.y });
      }).catch(() => {
        e(void 0);
      });
    });
  }, []), s = be(() => {
    i.current && (e(void 0), i.current(), i.current = null);
  }, []);
  return de(() => s, [s]), { coords: t, placement: n, updatePosition: o, cleanup: s };
}
function SO({ isOpen: t, floatingBoxRef: e }) {
  const { coords: n, updatePosition: r, cleanup: i, placement: o } = NO();
  return de(() => {
    var s;
    if (!t || !e.current) {
      i();
      return;
    }
    const a = (s = window.getSelection()) == null ? void 0 : s.getRangeAt(0);
    if (!a) {
      i();
      return;
    }
    return r(a, e.current), i;
  }, [i, t, e, r]), { coords: n, placement: o };
}
const TO = document.body, AO = B2(EO);
function DO({ isOpen: t = !1, children: e }) {
  const n = ye(null), { coords: r, placement: i } = SO({ isOpen: t, floatingBoxRef: n }), o = Ne(() => r ? typeof e == "function" ? e : () => e : () => null, [e, r]);
  return fi(p(AO, { ref: n, coords: r, style: r ? void 0 : { display: "none" }, children: o({ isOpen: t, placement: i }) }), TO);
}
const qx = Sl(void 0);
function Sg() {
  const t = Tl(qx);
  if (!t)
    throw new Error("useMenuContext must be used within a MenuProvider");
  return t;
}
function MO(t, e) {
  const [n, r] = ue(0), [i, o] = ue(-1), s = Ne(() => t ?? [], [t]), a = {
    menuItems: s,
    activeIndex: n,
    selectedIndex: i,
    onSelectOption: e ?? (() => {
    })
  }, l = be(() => {
    r((f) => {
      const d = s.length;
      return d ? (f - 1 + d) % d : 0;
    });
  }, [s.length]), c = be(() => {
    r((f) => {
      const d = s.length;
      return d ? (f + 1) % d : 0;
    });
  }, [s.length]), u = be(() => {
    const f = s.length;
    if (n >= 0 && n < f) {
      const d = s[n];
      e == null || e(d), o(n);
    }
  }, [n, s, e]);
  return {
    state: a,
    moveUp: l,
    moveDown: c,
    select: u,
    setActiveIndex: r,
    setSelectedIndex: o
  };
}
function OO({ children: t, menuItems: e, onSelectOption: n, ...r }) {
  const i = MO(e, n);
  return p(qx.Provider, { value: i, children: p("div", { ...r, children: t }) });
}
const jx = Yn(({ index: t, children: e, onMouseEnter: n, onClick: r, ...i }, o) => {
  const { state: { activeIndex: s }, setActiveIndex: a, setSelectedIndex: l, select: c } = Sg(), u = be((d) => {
    c(), l(-1), r == null || r(d);
  }, [r, c, l]), f = be((d) => {
    a(t), n == null || n(d);
  }, [t, a, n]);
  return p("button", { ref: o, role: "menuitem", ...i, onClick: u, onMouseEnter: f, "aria-selected": t !== void 0 && s === t ? "true" : void 0, tabIndex: -1, children: e });
});
function IO({ children: t, autoIndex: e = !0, ...n }) {
  const r = ye(null), { state: { activeIndex: i, menuItems: o } } = Sg(), s = Ne(() => o ? typeof t == "function" ? t : () => t : () => null, [t, o]), a = Ne(() => {
    const l = s(o);
    return e ? q2.map(l, (c, u) => U2(c) && c.type === jx && c.props.index === void 0 ? j2(c, { index: u }) : c) : l;
  }, [s, e, o]);
  return de(() => {
    if (r.current) {
      const l = r.current, c = l.children[i];
      if (c) {
        const u = l.getBoundingClientRect(), f = c.getBoundingClientRect();
        f.bottom > u.bottom ? l.scrollTop += f.bottom - u.bottom : f.top < u.top && (l.scrollTop -= u.top - f.top);
      }
    }
  }, [i]), p("div", { ref: r, role: "menu", ...n, children: a });
}
const bf = {
  Root: OO,
  Options: IO,
  Option: jx
}, RO = (t, e, n) => Bc(t, n).toLowerCase().includes(e.toLowerCase()), Ub = (t) => Object.keys(t).find((e) => typeof t[e] == "string") || "", Bc = (t, e) => {
  const n = t[e];
  return typeof n == "string" ? n : String(n);
};
function PO(t) {
  const { query: e, items: n, filterBy: r, filter: i, sortBy: o, sortingOptions: s } = t, { caseSensitive: a = !1, priorityOrder: l = ["exact", "startsWith", "contains"] } = s || {}, c = a ? e : e.toLowerCase();
  let u, f;
  i ? (f = i, u = n.length > 0 ? Ub(n[0]) : "") : (u = r || (n.length > 0 ? Ub(n[0]) : ""), f = (g, w) => RO(g, w, u));
  const d = o || u, h = /* @__PURE__ */ new Map();
  return n.filter((g) => {
    try {
      return f(g, e);
    } catch (w) {
      return console.warn("Error filtering item:", g, w), !1;
    }
  }).sort((g, w) => {
    const b = (C) => (h.has(C) || h.set(C, Bc(C, d).toLowerCase()), h.get(C) ?? ""), _ = a ? Bc(g, d) : b(g), y = a ? Bc(w, d) : b(w);
    for (const C of l)
      switch (C) {
        case "exact":
          if (_ === c && y !== c)
            return -1;
          if (y === c && _ !== c)
            return 1;
          break;
        case "startsWith":
          if (_.startsWith(c) && !y.startsWith(c))
            return -1;
          if (y.startsWith(c) && !_.startsWith(c))
            return 1;
          break;
        case "contains": {
          const D = _.indexOf(c), P = y.indexOf(c);
          if (D !== -1 && P === -1)
            return -1;
          if (P !== -1 && D === -1)
            return 1;
          if (D !== -1 && P !== -1)
            return D - P;
          break;
        }
      }
    return _.localeCompare(y);
  });
}
function LO(t) {
  const { query: e, items: n, filterBy: r, filter: i, sortBy: o, sortingOptions: s } = t;
  return Ne(() => PO({
    query: e,
    items: n,
    filterBy: r,
    filter: i,
    sortBy: o,
    sortingOptions: s
  }), [e, n, r, i, o, s]);
}
function $O() {
  const { moveUp: t, moveDown: e, select: n } = Sg();
  return Ne(() => ({
    moveUp: t,
    moveDown: e,
    select: n
  }), [t, e, n]);
}
const FO = () => {
  const t = $O(), [e] = Le();
  de(() => {
    const n = (r) => {
      const i = {
        ArrowDown: () => t == null ? void 0 : t.moveDown(),
        ArrowUp: () => t == null ? void 0 : t.moveUp(),
        Enter: () => t == null ? void 0 : t.select(),
        Tab: () => t == null ? void 0 : t.select()
      }[r.key];
      return i ? (i(), r.preventDefault(), r.stopPropagation(), !0) : !1;
    };
    return e.registerCommand(ua, n, Gu);
  }, [e, t]);
};
function BO() {
  return FO(), null;
}
function qO(t) {
  const { options: e, onSelectOption: n, onClose: r, inverse: i, query: o, menuOpenKey: s } = t, [a] = Le(), l = o !== void 0, [c, u] = ue(""), f = l ? o ?? "" : c, d = LO({ query: f, items: e, filterBy: "name" }), h = (g) => {
    r == null || r(), n ? n(g) : g.action(a);
  };
  return de(() => a.registerCommand(ua, (g) => {
    if (l)
      return !1;
    const w = {
      Escape: () => r == null ? void 0 : r(),
      Backspace: () => {
        f.length === 0 ? r == null || r() : u((b) => b.slice(0, -1));
      }
    }[g.key];
    return w ? (g.stopPropagation(), g.preventDefault(), w(), !0) : g.key.length === 1 ? (g.stopPropagation(), g.preventDefault(), g.key !== s && u((b) => b + g.key), !0) : !1;
  }, Gu), [a, l, f, s, r]), B(bf.Root, { className: `autocomplete-menu-container ${i ? "inverse" : ""}`, menuItems: d, onSelectOption: (g) => h(g), children: [!l && p("input", { value: f, type: "text", disabled: !0 }), p(BO, {}), p(bf.Options, { className: "autocomplete-menu-options", autoIndex: !1, children: (g) => g.map((w, b) => B(bf.Option, { index: b, children: [p("span", { className: "label", children: w.label ?? w.name }), p("span", { className: "description", children: w.description })] }, w.name)) })] });
}
function jO({ trigger: t, items: e }) {
  const [n] = Le(), [r, i] = ue(!1), o = be((s) => {
    s.key === "Escape" && r ? (i(!1), n.focus()) : s.key === t && !r && (s.preventDefault(), i(!0));
  }, [n, t, r]);
  return de(() => n.registerRootListener((s) => {
    if (s)
      return s.addEventListener("keydown", o), () => {
        s.removeEventListener("keydown", o);
      };
  }), [n, o]), de(() => n.registerUpdateListener(({ prevEditorState: s, editorState: a }) => {
    const l = s.read(() => {
      const c = oe();
      if (Z(c))
        return c;
    });
    a.read(() => {
      const c = oe();
      !Z(c) || l != null && l.is(c) || i(!1);
    });
  }), [n]), e && p(DO, { isOpen: r, children: ({ placement: s }) => p(qO, { options: e, onClose: () => i(!1), inverse: s === "top-start", menuOpenKey: t }) });
}
function UO({ scriptureReference: t, contextMarker: e, getMarkerAction: n }) {
  return { markersMenuItems: Ne(() => {
    if (!e || !t)
      return;
    const r = Ob(e);
    if (r != null && r.children)
      return Object.values(r.children).flatMap((i) => i.map((o) => {
        const s = Ob(o), { action: a } = n(o, s);
        return {
          name: o,
          label: o,
          description: (s == null ? void 0 : s.description) ?? "",
          action: (l) => {
            a({ editor: l, reference: t });
          }
        };
      }));
  }, [e, n, t]) };
}
function qc(t, e) {
  return `${t}:${e}`;
}
function zO(t, e) {
  de(() => {
    if (!t.hasNodes([nn]))
      throw new Error("AnnotationPlugin: TypedMarkNode not registered on editor!");
    const n = /* @__PURE__ */ new Map();
    return Ht(fv(t, nn, (r) => kl(r.getTypedIDs()), (r, i) => {
      for (const [o, s] of Object.entries(r.getTypedIDs()))
        s.forEach((a) => {
          i.addID(o, a);
        });
    }), t.registerMutationListener(nn, (r) => {
      t.getEditorState().read(() => {
        for (const [i, o] of r) {
          const s = Oe(i);
          let a = {};
          o === "destroyed" ? a = n.get(i) ?? {} : on(s) && (a = s.getTypedIDs());
          for (const [l, c] of Object.entries(a))
            if (!nn.isReservedType(l))
              for (const u of c) {
                let f = e.get(qc(l, u));
                a[l] = c, n.set(i, a), o === "destroyed" ? f !== void 0 && (f.delete(i), f.size === 0 && e.delete(qc(l, u))) : (f === void 0 && (f = /* @__PURE__ */ new Set(), e.set(qc(l, u), f)), f.has(i) || f.add(i));
              }
        }
      });
    }, { skipInitialization: !0 }));
  }, [t, e]);
}
const VO = Yn(function({ logger: t }, e) {
  const [n] = Le(), r = Ne(() => /* @__PURE__ */ new Map(), []);
  return zO(n, r), Kh(e, () => ({
    addAnnotation(i, o, s) {
      if (nn.isReservedType(o))
        throw new Error(`addAnnotation: Can't directly add this reserved annotation type '${o}'. Use the appropriate plugin instead.`);
      n.update(() => {
        const a = _g(i);
        if (a === void 0) {
          t == null || t.error("Failed to find start or end node of the annotation.");
          return;
        }
        Nx(a, o, s);
      }, { tag: Dh });
    },
    removeAnnotation(i, o) {
      if (nn.isReservedType(i))
        throw new Error(`removeAnnotation: Can't directly remove this reserved annotation type '${i}'. Use the appropriate plugin instead.`);
      const s = r.get(qc(i, o));
      s !== void 0 && setTimeout(() => {
        n.update(() => {
          for (const a of s) {
            const l = Oe(a);
            on(l) && (l.deleteID(i, o), l.hasNoIDsForEveryType() && Ex(l));
          }
        }, { tag: Dh });
      });
    }
  })), null;
});
function HO({ ignoreHistoryMergeTagChange: t = !0, ignoreSelectionChange: e = !1, onChange: n }) {
  const [r] = Le();
  return kn(() => {
    if (n)
      return r.registerUpdateListener((i) => {
        const { editorState: o, dirtyElements: s, dirtyLeaves: a, prevEditorState: l, tags: c } = i;
        if (e && s.size === 0 && a.size === 0 || t && c.has(Eo) || l.isEmpty())
          return;
        const u = KO(r, i);
        u.length !== 0 && n(o, r, c, u);
      });
  }, [r, t, e, n]), null;
}
function KO(t, { dirtyLeaves: e, prevEditorState: n }) {
  let r = new Ha();
  return t.getEditorState().read(() => {
    const i = e.values().next().value ?? "";
    if (e.size === 1 && ie(Oe(i))) {
      const o = Oe(i), s = $x(o);
      if (ie(o) && s !== void 0) {
        const a = n.read(() => {
          const u = Oe(i);
          return new Ha([ie(u) ? Rh(u) : { insert: "" }]);
        }), l = new Ha([Rh(o)]), c = new Ha(s > 0 ? [{ retain: s }] : []);
        r = r.concat(c).concat(a.diff(l));
      }
    } else {
      const o = qb(n), s = qb(t.getEditorState());
      r = o.diff(s);
    }
  }), r.ops;
}
function WO(t, e, n, r) {
  let i = 0;
  t.forEach((o) => {
    if ("retain" in o)
      i += GO(o, i, e, r);
    else if ("delete" in o) {
      if (typeof o.delete != "number" || o.delete <= 0) {
        r == null || r.error(`Invalid delete operation: ${JSON.stringify(o)}`);
        return;
      }
      r == null || r.debug(`Delete: ${o.delete}`), XO(i, o.delete, r);
    } else "insert" in o ? typeof o.insert == "string" ? (r == null || r.debug(`Insert: '${o.insert}'`), i += YO(i, o.insert, o.attributes, e, r)) : typeof o.insert == "object" && o.insert !== null ? (r == null || r.debug(`Insert embed: ${JSON.stringify(o.insert)}`), ZO(i, o, e, n, r) ? i += 1 : r == null || r.error(`Failed to process insert embed operation: ${JSON.stringify(o.insert)} at index ${i}. Document may be inconsistent.`)) : r == null || r.error(`Insert of unknown type: ${JSON.stringify(o.insert)}`) : r == null || r.error(`Unknown operation: ${JSON.stringify(o)}`);
  });
}
function GO(t, e, n, r) {
  return typeof t.retain != "number" || t.retain < 0 ? (r == null || r.error(`Invalid retain operation: ${JSON.stringify(t)}`), 0) : (r == null || r.debug(`Retain: ${t.retain}`), t.attributes && (r == null || r.debug(`Retain attributes: ${JSON.stringify(t.attributes)}`), JO(e, t.retain, t.attributes, n, r)), t.retain);
}
function JO(t, e, n, r, i) {
  i == null || i.debug(`Applying attributes for range [${t}, ${t + e - 1}] with attributes: ${JSON.stringify(n)}`);
  let o = e, s = 0, a = -1;
  const l = Ve();
  function c(u) {
    if (o <= 0)
      return !0;
    if (ie(u)) {
      const f = u.getTextContentSize();
      if (t < s + f && s < t + e) {
        const d = Math.max(0, t - s), h = f - d, g = Math.min(o, h);
        if (g > 0) {
          let w = u;
          const b = d > 0, _ = g < f - d;
          if (b && _) {
            const [, y] = u.splitText(d);
            [w] = y.splitText(g);
          } else b ? [, w] = u.splitText(d) : _ && ([w] = u.splitText(g));
          if (Jo(n)) {
            const y = w.getParent();
            if (at(y)) {
              const C = n.char;
              let D;
              Array.isArray(C) ? a >= 0 && a <= C.length - 1 && (D = C[a]) : a === 0 && (D = C);
              const P = D ? Go(D, y) : !1;
              if (P && Array.isArray(C) && C.length > 1) {
                const S = Re("");
                w.replace(S);
                const L = typeof n.segment == "string" ? n.segment : void 0, O = Xl(C.slice(1), r, w, L);
                let M = S;
                for (const F of O)
                  M.insertAfter(F), M = F;
                S.remove(), tr(n, w);
              } else if (P)
                tr(n, w);
              else {
                w.remove();
                const S = zb(w, n, r, i);
                if (S && S.length > 0) {
                  let L = y;
                  for (const O of S)
                    L.insertAfter(O), L = O;
                }
              }
            } else {
              const C = Re("");
              w.replace(C);
              const D = zb(w, n, r, i);
              if (D && D.length > 0) {
                let P = C;
                for (const S of D)
                  P.insertAfter(S), P = S;
                C.remove();
              } else
                C.replace(w);
            }
          } else
            tr(n, w);
          o -= g;
        }
      }
      s += f;
    } else if (Er(u))
      t <= s && s < t + e && o > 0 && (Vb(u, n), o -= 1), s += 1;
    else if (at(u)) {
      a += 1;
      let f = !1;
      if (t <= s && s < t + e && o > 0)
        if (Jo(n)) {
          const d = n.char;
          let h;
          if (Array.isArray(d) ? a >= 0 && a <= d.length - 1 && (h = d[a]) : a === 0 && (h = d), h) {
            u.setMarker(h.style), typeof h.cid == "string" && pi(u, Ho, () => h.cid);
            const g = Gt(h, Su);
            g && Object.keys(g).length > 0 ? u.setUnknownAttributes({
              ...u.getUnknownAttributes() ?? {},
              ...g
            }) : u.setUnknownAttributes(void 0);
          }
        } else (n.char === !1 || n.char === null || a5(n.char)) && (f = !0);
      if (o > 0) {
        const d = u.getChildren();
        for (const h of d) {
          if (o <= 0)
            break;
          if (c(h) && o <= 0)
            return f && rm(u), !0;
        }
      }
      f && rm(u), a -= 1;
    } else if (ar(u)) {
      const f = u.getChildren();
      for (const h of f) {
        if (o <= 0)
          break;
        if (c(h) && o <= 0)
          return !0;
      }
      const d = 1;
      if (t <= s && s < t + o && o > 0) {
        if (!_i(u))
          Vb(u, n);
        else if (Tg(n)) {
          const h = zx(n.para);
          h && u.replace(h, !0);
        }
        o -= d;
      }
      s += d;
    } else if (X(u)) {
      const f = u.getChildren();
      for (const d of f) {
        if (o <= 0)
          break;
        if (c(d) && o <= 0)
          return !0;
      }
    }
    return o <= 0;
  }
  c(l), o > 0 && (i == null || i.warn(`$applyAttributes: Not all characters in the retain operation (length ${e}) could be processed. Remaining: ${o}. targetIndex: ${t}, final currentIndex: ${s}`));
}
function zb(t, e, n, r) {
  var i;
  const o = typeof e.segment == "string" ? e.segment : void 0, s = Xl(e.char, n, t, o), a = s.find(at);
  if (!a) {
    r == null || r.error(`Failed to create CharNode for text transformation. Style: ${Array.isArray(e.char) ? e.char[0].style : (i = e.char) == null ? void 0 : i.style}. Falling back to standard text attributes.`), tr(e, t);
    return;
  }
  const l = {};
  Vx.forEach((f) => {
    t.hasFormat(f) && (l[f] = "true");
  });
  const c = {};
  Object.entries(e).forEach(([f, d]) => {
    f === "segment" || f === "char" || (typeof d == "string" ? c[f] = d : d === !0 ? c[f] = "true" : d === !1 && (c[f] = "false"));
  });
  const u = {
    ...a.getUnknownAttributes() ?? {},
    ...l,
    ...c
  };
  return Object.keys(u).length > 0 && a.setUnknownAttributes(u), tr(e, t), s;
}
function Vb(t, e) {
  for (const n of Object.keys(e)) {
    const r = e[n];
    if (n === "char" && at(t) && Jo(e)) {
      const i = r;
      if (t.setMarker(i.style), typeof i.cid == "string") {
        const s = i.cid;
        pi(t, Ho, () => s);
      }
      const o = Gt(i, Su);
      o && Object.keys(o).length > 0 && t.setUnknownAttributes({
        ...t.getUnknownAttributes() ?? {},
        ...o
      });
      continue;
    }
    typeof r == "string" && (rr(t) || ir(t) || hd(t) || je(t) || Kl(t) ? t.setUnknownAttributes({
      ...t.getUnknownAttributes() ?? {},
      [n]: r
    }) : (Jr(t) || fn(t) || at(t)) && (n === "style" && !Jr(t) ? t.setMarker(r) : n === "code" && Jr(t) ? t.setCode(r) : t.setUnknownAttributes({
      ...t.getUnknownAttributes() ?? {},
      [n]: r
    })), n === "segment" && pi(t, Ko, () => r));
  }
}
function XO(t, e, n) {
  if (e <= 0)
    return;
  const r = Ve();
  let i = 0, o = e;
  function s(a) {
    if (o <= 0)
      return !0;
    if (ie(a)) {
      let l = a.getTextContentSize();
      if (t < i + l && i < t + o) {
        const c = Math.max(0, t - i), u = l - c, f = Math.min(o, u);
        f > 0 && (a.spliceText(c, f, ""), a.getTextContentSize() === 0 && a.remove(), n == null || n.debug(`Deleted ${f} length from TextNode (key: ${a.getKey()}) at nodeOffset ${c}. Original targetIndex: ${t}, current currentIndex: ${i}.`), o -= f, l -= f);
      }
      i += l;
    } else if (Er(a))
      t <= i && i < t + o ? (a.remove(), n == null || n.debug(`Deleted embed node (key: ${a.getKey()}) at currentIndex: ${i}. Original targetIndex: ${t}, remainingToDelete: ${o}.`), o -= 1) : i += 1;
    else if (ar(a)) {
      const l = a.getChildren().slice(), c = a.getChildren();
      for (const u of c) {
        if (o <= 0)
          break;
        if (s(u) && o <= 0)
          return !0;
      }
      if (t <= i && i < t + o && ar(a)) {
        o -= 1;
        const u = a.getChildren().length;
        if (l.length > 0 && u === 0) {
          const f = a.getParent();
          ((f == null ? void 0 : f.getChildren()) ?? []).length > 1 ? (a.remove(), n == null || n.debug(`Removed entire ParaNode that had all its content deleted at currentIndex: ${i}. Original targetIndex: ${t}, remainingToDelete: ${o}.`)) : (a.replace(br(), !0), n == null || n.debug(`Replaced last ParaNode with ImpliedParaNode at currentIndex: ${i}. Original targetIndex: ${t}, remainingToDelete: ${o}.`));
        } else if (o > 0) {
          const f = a.getNextSibling();
          if (f && gr(f)) {
            let d = i + 1;
            const h = f.getChildren();
            for (const w of h) {
              if (o <= 0)
                break;
              const b = i;
              if (i = d, s(w)) {
                i = b;
                break;
              }
              ie(w) ? d += w.getTextContentSize() : Er(w) && (d += 1), i = b;
            }
            const g = f.getChildren();
            for (const w of g)
              w.remove(), a.append(w);
            f.remove(), n == null || n.debug(`Merged next paragraph into current one after deleting symbolic close at currentIndex: ${i}. Original targetIndex: ${t}, remainingToDelete: ${o}.`);
          } else
            a.replace(br(), !0);
        } else fn(a) ? a.replace(br(), !0) : a.remove();
      }
      i += 1;
    } else if (X(a)) {
      const l = a.getChildren();
      for (const c of l) {
        if (o <= 0)
          break;
        if (s(c) && o <= 0)
          return !0;
      }
    }
    return o <= 0;
  }
  s(r), o > 0 && (n == null || n.warn(`Delete operation could not remove all requested characters. Remaining to delete: ${o}. Original targetIndex: ${t}, OT length: ${e}. Final currentIndex: ${i}`));
}
function YO(t, e, n, r, i) {
  if (e === El)
    return Hb(t, n, i);
  if (e.endsWith(El) && !Tg(n)) {
    const o = e.slice(0, -1);
    let s = 0;
    if (o.length > 0) {
      if (Jo(n))
        throw new Error("Text + LF should not have char attributes");
      s += Tu(t, o, n, i);
    }
    return s += Hb(t + s, n, i), s;
  } else return Jo(n) ? QO(t, e, n, r, i) : Tu(t, e, n, i);
}
function QO(t, e, n, r, i) {
  i == null || i.debug(`Attempting to insert CharNode with text "${e}" and attributes ${JSON.stringify(n.char)} at index ${t}`);
  const o = Re(e);
  tr(n, o);
  let s;
  {
    let h = function(b) {
      if (ie(b)) {
        const _ = b.getTextContentSize();
        if (t >= w && t < w + _) {
          const y = b.getParent();
          return at(y) && (s = y), !0;
        }
        w += _;
      } else if (Er(b))
        w += 1;
      else if (at(b)) {
        const _ = b.getChildren();
        for (const y of _)
          if (h(y))
            return !0;
      } else if (X(b)) {
        const _ = b.getChildren();
        for (const y of _)
          if (h(y))
            return !0;
        ar(b) && (w += 1);
      }
      return !1;
    };
    const g = Ve();
    let w = 0;
    h(g);
  }
  let a = n.char;
  if (Array.isArray(a)) {
    if (s) {
      const h = a[0];
      h && Go(h, s) ? (a = a.slice(1), a.length === 1 && (a = a[0])) : s = void 0;
    }
  } else s && (Go(a, s) || (s = void 0));
  const l = typeof n.segment == "string" ? n.segment : void 0, c = Xl(a, r, o, l, s ? [s] : void 0);
  if (c.length === 0)
    return e.length;
  const u = c.find(at);
  if (!u)
    return i == null || i.error(`CharNode style is missing for text "${e}". Attributes: ${JSON.stringify(n.char)}. Falling back to rich text insertion.`), Tu(t, e, void 0, i);
  const f = {};
  for (const [h, g] of Object.entries(n))
    h !== "char" && h !== "segment" && typeof g == "string" && (f[h] = g);
  Object.keys(f).length > 0 && u.setUnknownAttributes(f);
  let d = !0;
  for (const h of c)
    if (!Ux(t, h, i)) {
      d = !1;
      break;
    }
  return d ? e.length : (i == null || i.error(`Failed to insert CharNode with text "${e}" at index ${t}. Falling back to rich text.`), Tu(t, e, void 0, i));
}
function Tu(t, e, n, r) {
  if (e.length <= 0)
    return r == null || r.debug("Attempted to insert empty string. No action taken."), 0;
  const i = Ve();
  let o = 0, s = !1;
  function a(l) {
    if (s)
      return !0;
    if (ie(l)) {
      const c = l.getTextContentSize();
      if (t >= o && t <= o + c) {
        const u = t - o, f = Re(e);
        if (tr(n, f), u === 0)
          l.insertBefore(f);
        else if (u === c) {
          const d = l.getParent();
          at(d) && !Jo(n) ? d.insertAfter(f) : l.insertAfter(f);
        } else {
          const [, d] = l.splitText(u);
          d.insertBefore(f);
        }
        return r == null || r.debug(`Inserted text "${e}" in/around TextNode (key: ${l.getKey()}) at nodeOffset ${u}. Original targetIndex: ${t}, currentIndex at node start: ${o}.`), s = !0, !0;
      }
      o += c;
    } else if (Er(l))
      o += 1;
    else if (at(l)) {
      if (!s && t === o) {
        const u = Re(e);
        tr(n, u);
        const f = l.getFirstChild();
        return f ? f.insertBefore(u) : l.append(u), r == null || r.debug(`Inserted text "${e}" at beginning of CharNode ${l.getType()} (key: ${l.getKey()}).`), s = !0, !0;
      }
      const c = l.getChildren();
      for (const u of c) {
        if (a(u))
          return !0;
        if (s)
          break;
      }
      if (!s && t === o) {
        const u = Re(e);
        return tr(n, u), l.append(u), r == null || r.debug(`Appended text "${e}" to end of CharNode ${l.getType()} (key: ${l.getKey()}).`), s = !0, !0;
      }
    } else if (ar(l)) {
      if (!s && t === o) {
        const u = Re(e);
        tr(n, u);
        const f = l.getFirstChild();
        return f ? f.insertBefore(u) : l.append(u), r == null || r.debug(`Inserted text "${e}" at beginning of container ${l.getType()} (key: ${l.getKey()}).`), s = !0, !0;
      }
      const c = l.getChildren();
      for (const u of c) {
        if (a(u))
          return !0;
        if (s)
          break;
      }
      if (!s && t === o) {
        const u = Re(e);
        return tr(n, u), l.append(u), r == null || r.debug(`Appended text "${e}" to end of container ${l.getType()} (key: ${l.getKey()}).`), s = !0, !0;
      }
      o += 1;
    } else if (X(l)) {
      const c = l.getChildren();
      for (const u of c) {
        if (a(u))
          return !0;
        if (s)
          break;
      }
    }
    return s;
  }
  if (a(i), !s && t === o) {
    r == null || r.debug(`Insertion point matches end of document (targetIndex: ${t}, final currentIndex: ${o}). Appending text to new ParaNode.`);
    const l = Re(e);
    tr(n, l);
    const c = br().append(l);
    i.append(c), s = !0;
  }
  return s ? e.length : (r == null || r.warn(`$insertRichText: Could not find insertion point for text "${e}" at targetIndex ${t}. Final currentIndex: ${o}. Text not inserted.`), 0);
}
function Ux(t, e, n) {
  const r = Ve();
  let i = 0, o = !1;
  function s(a) {
    if (o)
      return !0;
    if (a === r && t === 0 && !r.getFirstChild())
      return e.isInline() ? (n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting inline node ${e.getType()} into empty root, wrapped in ImpliedParaNode. targetIndex: ${t}`), r.append(br().append(e))) : (n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting block node ${e.getType()} directly into empty root. targetIndex: ${t}`), r.append(e)), o = !0, !0;
    if (!X(a))
      return !1;
    const l = a.getChildren();
    for (const c of l) {
      if (t === i && !o) {
        if (a === r && e.isInline())
          if (gr(c)) {
            n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting inline node ${e.getType()} into existing ${c.getType()} at beginning. targetIndex: ${t}`);
            const u = c.getFirstChild();
            u ? u.insertBefore(e) : c.append(e);
          } else
            n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting inline node ${e.getType()} into root before ${c.getType()}, wrapping in ImpliedParaNode. targetIndex: ${t}`), c.insertBefore(br().append(e));
        else
          c.insertBefore(e), n == null || n.debug(`$insertNodeAtCharacterOffset: Inserted node ${e.getType()} (key: ${e.getKey()}) before child ${c.getType()} (key: ${c.getKey()}) in ${a.getType()} (key: ${a.getKey()}). targetIndex: ${t}, currentIndex: ${i}`);
        return o = !0, !0;
      }
      if (ie(c)) {
        const u = c.getTextContentSize();
        if (!o && t > i && t < i + u) {
          const f = t - i, [d] = c.splitText(f);
          return d.insertAfter(e), n == null || n.debug(`$insertNodeAtCharacterOffset: Inserted node ${e.getType()} (key: ${e.getKey()}) by splitting TextNode (key: ${c.getKey()}) at offset ${f}. targetIndex: ${t}, currentIndex at node start: ${i}`), o = !0, !0;
        }
        i += u;
      } else if (Er(c))
        i += 1;
      else if (at(c)) {
        if (s(c))
          return !0;
      } else if (ar(c)) {
        const u = c;
        if (s(u))
          return !0;
        const f = i;
        if (_i(u) && ar(e) && // Target is at the ImpliedPara's implicit newline
        t === f && !o)
          return n == null || n.debug(`$insertNodeAtCharacterOffset: Replacing ImpliedParaNode (key: ${u.getKey()}) with block node '${e.getType()}' (key: ${e.getKey()}) at OT index ${t}.`), c.replace(e, !0), i = f + 1, o = !0, !0;
        i += 1;
      } else if (X(c) && s(c))
        return !0;
      if (o)
        return !0;
    }
    return X(a) && !o && (t === i || a === r && t > i) ? a === r ? (e.isInline() ? (n == null || n.debug(`$insertNodeAtCharacterOffset: Appending inline node ${e.getType()} to root. Wrapping in new ImpliedParaNode. targetIndex: ${t}, current document OT length: ${i}.`), r.append(br().append(e))) : (n == null || n.debug(`$insertNodeAtCharacterOffset: Appending block node ${e.getType()} to root. targetIndex: ${t}, current document OT length: ${i}.`), r.append(e)), o = !0, !0) : (
      // Appending to an existing container (ParaNode, ImpliedParaNode)
      // currentNode here is the container itself. currentIndex is at the point of currentNode's
      // closing marker. targetIndex === currentIndex means we are inserting at the conceptual end
      // of this container.
      gr(a) ? _i(a) && fn(e) && t === i ? (n == null || n.debug(`$insertNodeAtCharacterOffset: Replacing ImpliedParaNode container (key: ${a.getKey()}) with ParaNode ${e.getType()} (key: ${e.getKey()}) via append logic. targetIndex: ${t}`), a.replace(e, !0), o = !0, !0) : e.isInline() || !gr(e) ? (n == null || n.debug(`$insertNodeAtCharacterOffset: Appending node ${e.getType()} to existing container ${a.getType()} (key: ${a.getKey()}). targetIndex: ${t}, container end OT index: ${i}.`), a.append(e), o = !0, !0) : (n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting block node ${e.getType()} after container ${a.getType()} (key: ${a.getKey()}). targetIndex: ${t}, container end OT index: ${i}.`), a.insertAfter(e), o = !0, !0) : (at(a) ? (n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting node ${e.getType()} after CharNode (key: ${a.getKey()}). targetIndex: ${t}, element end OT index: ${i}.`), a.insertAfter(e)) : e.isInline() || !gr(e) ? (n == null || n.debug(`$insertNodeAtCharacterOffset: Appending node ${e.getType()} to generic element ${a.getType()} (key: ${a.getKey()}). targetIndex: ${t}, element end OT index: ${i}.`), a.append(e)) : (n == null || n.debug(`$insertNodeAtCharacterOffset: Inserting block node ${e.getType()} after generic element ${a.getType()} (key: ${a.getKey()}). targetIndex: ${t}, element end OT index: ${i}.`), a.insertAfter(e)), o = !0, !0)
    ) : o;
  }
  return s(r), o || n == null || n.warn(`$insertNodeAtCharacterOffset: Could not find insertion point for node ${e.getType()} (key: ${e.getKey()}) at targetIndex ${t}. Final currentIndex: ${i}. Node not inserted.`), o;
}
function ZO(t, e, n, r, i) {
  let o;
  return La("chapter", e) ? o = e5(e.insert.chapter, n) : La("verse", e) ? o = t5(e.insert.verse, n) : La("ms", e) ? o = n5(e.insert.ms) : La("unmatched", e) ? o = r5(e.insert.unmatched) : La("note", e) && (o = i5(e, n, r, i)), o ? Ux(t, o, i) : (i == null || i.error(`$insertEmbedAtCurrentIndex: Cannot create LexicalNode for embed object: ${JSON.stringify(e.insert)}`), !1);
}
function Hb(t, e, n) {
  let r;
  Tg(e) ? r = zx(e.para) : s5(e) && (r = o5(e.book)), r ?? (r = br());
  const i = r, o = fn(i), s = _i(i);
  let a = 0, l = !1;
  function c(u) {
    if (l)
      return !0;
    if (ie(u)) {
      const f = u.getTextContentSize();
      if (t >= a && t <= a + f) {
        const d = u.getParent();
        if (fn(d) && (o || s)) {
          n == null || n.debug(`Splitting ParaNode (marker: ${d.getMarker()}) with LF attributes at targetIndex ${t}`);
          const h = t - a, [g] = h > 0 ? u.splitText(h) : [void 0];
          let w = g == null ? void 0 : g.getPreviousSibling();
          for (; w; ) {
            const b = w;
            w = w.getPreviousSibling();
            const _ = i.getFirstChild();
            _ ? _.insertBefore(b) : i.append(b);
          }
          return g && i.append(g), d.insertBefore(i), l = !0, !0;
        }
      }
      a += f;
    } else if (Er(u))
      a += 1;
    else if (ar(u)) {
      const f = u.getChildren();
      for (const d of f) {
        if (c(d))
          return !0;
        if (l)
          break;
      }
      if (t === a) {
        if (_i(u) && i)
          return n == null || n.debug(`Replacing ImpliedParaNode (key: ${u.getKey()}) with ParaNode at targetIndex ${t}`), u.replace(i, !0), l = !0, !0;
        if (fn(u) && i) {
          const d = u;
          return n == null || n.debug(`Creating new block node with LF attributes after existing ParaNode (marker: ${d.getMarker()}) at targetIndex ${t}`), d.insertAfter(i), l = !0, !0;
        }
      }
      if (a += 1, t === a && fn(u) && i)
        return n == null || n.debug(`Creating new block node after existing ParaNode (marker: ${u.getMarker()}) at targetIndex ${t}`), u.insertAfter(i), l = !0, !0;
    } else if (X(u)) {
      const f = u.getChildren();
      for (const d of f) {
        if (c(d))
          return !0;
        if (l)
          break;
      }
    }
    return l;
  }
  return c(Ve()), l || n == null || n.warn(`Could not find location to handle newline with para attributes at targetIndex ${t}. Final currentIndex: ${a}.`), 1;
}
function e5(t, e) {
  if (!t)
    return;
  const { number: n, sid: r, altnumber: i, pubnumber: o } = t;
  if (!n)
    return;
  const s = Gt(t, YM);
  let a;
  if (e.markerMode === "editable")
    a = ax(n, r, i, o, s);
  else {
    const l = e.markerMode === "visible";
    a = ug(n, l, r, i, o, s);
  }
  return a;
}
function t5(t, e) {
  if (!t)
    return;
  const { style: n, number: r, sid: i, altnumber: o, pubnumber: s } = t;
  if (!r)
    return;
  const a = Gt(t, QM);
  let l;
  if (e.markerMode === "editable") {
    if (!n)
      return;
    const c = Gl(n, r);
    l = vx(r, c, i, o, s, a);
  } else {
    const c = e.markerMode === "visible";
    l = xg(r, c, i, o, s, a);
  }
  return l;
}
function n5(t) {
  if (!t)
    return;
  const { style: e, sid: n, eid: r } = t;
  if (!e)
    return;
  const i = Gt(t, ZM);
  return wx(e, n, r, i);
}
function r5(t) {
  if (!t)
    return;
  const { marker: e } = t;
  if (e)
    return vg(e);
}
function i5(t, e, n, r) {
  var i;
  const o = t.insert;
  if (!o.note)
    return;
  const { style: s, caller: a, category: l, contents: c } = o.note;
  if (!s || a == null)
    return;
  a === "" && (r == null || r.warn("Note has empty caller. Only use for note editing."));
  const u = Gt(o.note, eO), f = (i = t.attributes) == null ? void 0 : i.segment;
  let d;
  f && typeof f == "string" && (d = f);
  const h = [];
  for (const g of (c == null ? void 0 : c.ops) ?? [])
    if (typeof g.insert == "string")
      if (Jo(g.attributes)) {
        const w = Xl(g.attributes.char, e, Re(g.insert), void 0, h);
        h.push(...w);
      } else
        h.push(Re(g.insert));
  return Rx(s, a, h, e, n, d).setCategory(l).setUnknownAttributes(u);
}
function o5(t) {
  const { style: e, code: n } = t;
  if (!e || e !== xl || !n || !sr.isValidBookCode(n))
    return;
  const r = Gt(t, XM);
  return ix(n, r);
}
function zx(t) {
  const { style: e } = t;
  if (!e)
    return;
  const n = Gt(t, JM);
  return Cl(e, n);
}
function Xl(t, e, n, r, i) {
  if (Array.isArray(t)) {
    if (t.length === 0)
      throw new Error("Empty charAttr array");
    const o = t[0], s = i == null ? void 0 : i[i.length - 1];
    if (at(s) && Go(o, s))
      return t.length > 1 ? Xl(t.slice(1), e, n).forEach((u) => s.append(u)) : n && s.append(n), [];
    const a = t.reduceRight((u, f, d) => {
      const h = Ur(f.style, Gt(f, Su));
      if (typeof f.cid == "string" && pi(h, Ho, () => f.cid), r && d === t.length - 1 && pi(h, Ko, () => r), u)
        if (at(u)) {
          const g = u.getMarker(), w = [];
          yf(g, w, e), w.forEach((_) => h.append(_)), h.append(u);
          const b = [];
          vf(g, b, e), b.forEach((_) => h.append(_));
        } else
          h.append(u);
      return h;
    }, n), l = [], c = t[0];
    return yf(c.style, l, e), l.push(a), vf(c.style, l, e), l;
  } else {
    const o = i == null ? void 0 : i[i.length - 1];
    if (at(o) && Go(t, o))
      return n && o.append(n), [];
    const s = [];
    yf(t.style, s, e);
    const a = Ur(t.style, Gt(t, Su));
    return typeof t.cid == "string" && pi(a, Ho, () => t.cid), r && pi(a, Ko, () => r), n && a.append(n), s.push(a), vf(t.style, s, e), s;
  }
}
function yf(t, e, n) {
  (n == null ? void 0 : n.markerMode) === "editable" ? e.push(Zs(t)) : (n == null ? void 0 : n.markerMode) === "visible" && e.push(ea("marker", Si(t)));
}
function vf(t, e, n, r = !1) {
  yt.isValidFootnoteMarker(t) || yt.isValidCrossReferenceMarker(t) || ((n == null ? void 0 : n.markerMode) === "editable" ? r ? e.push(Zs("", "selfClosing")) : e.push(Zs(t, "closing")) : (n == null ? void 0 : n.markerMode) === "visible" && e.push(ea("marker", Qs(r ? "" : t))));
}
function s5(t) {
  return !!t && !!t.book && typeof t.book == "object" && t.book !== null && "style" in t.book && typeof t.book.style == "string" && "code" in t.book && typeof t.book.code == "string";
}
function Tg(t) {
  return !!t && !!t.para && typeof t.para == "object" && t.para !== null && "style" in t.para && typeof t.para.style == "string";
}
function Jo(t) {
  return !!t && !!t.char && typeof t.char == "object" && t.char !== null && (!Array.isArray(t.char) && "style" in t.char && typeof t.char.style == "string" || Array.isArray(t.char) && t.char.length > 0 && "style" in t.char[0] && typeof t.char[0].style == "string");
}
function a5(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t) && Object.keys(t).length === 0;
}
function tr(t, e) {
  if (t)
    for (const n of Object.keys(t)) {
      if (n === "segment" && typeof t[n] == "string") {
        const r = t[n];
        pi(e, Ko, () => r);
        continue;
      }
      if (l5(n)) {
        const r = !!t[n], i = n, o = e.hasFormat(i);
        (r && !o || !r && o) && e.toggleFormat(i);
      }
    }
}
const Vx = [
  "bold",
  "underline",
  "strikethrough",
  "italic",
  "highlight",
  "code",
  "subscript",
  "superscript",
  "lowercase",
  "uppercase",
  "capitalize"
];
function l5(t) {
  return Vx.includes(t);
}
function c5({ viewOptions: t }) {
  const [e] = Le();
  return u5(e, t), null;
}
function u5(t, e) {
  de(() => {
    if (!t.hasNodes([Ni, Cn, Wt]))
      throw new Error("ArrowNavigationPlugin: ImmutableChapterNode, ImmutableVerseNode or NoteNode not registered on editor!");
    const n = (r) => {
      if (r.key !== "ArrowLeft" && r.key !== "ArrowRight")
        return !1;
      const i = oe();
      if (!Z(i) || !i.isCollapsed())
        return !1;
      const o = t.getRootElement();
      if (!o)
        return !1;
      const s = o.dir || "ltr";
      let a = !1;
      return d5(s, r.key) ? a = h5(i) : f5(s, r.key) && (a = p5(i, e)), a && r.preventDefault(), a;
    };
    return t.registerCommand(ua, n, Gu);
  }, [t, e]);
}
function d5(t, e) {
  return t === "ltr" && e === "ArrowRight" || t === "rtl" && e === "ArrowLeft";
}
function f5(t, e) {
  return t === "ltr" && e === "ArrowLeft" || t === "rtl" && e === "ArrowRight";
}
function h5(t) {
  var e, n, r;
  const i = t.anchor.getNode(), o = hM(t);
  if (je(o) && !Jl(o.getFirstChild())) {
    if (gr(i)) {
      if (t.anchor.offset === i.getChildrenSize())
        return !1;
    } else if (t.anchor.offset !== i.getTextContentSize())
      return !1;
    if (o.getIsCollapsed()) {
      if (o.is((e = o.getParent()) == null ? void 0 : e.getLastChild()))
        return (r = (n = o.getParent()) == null ? void 0 : n.getNextSibling()) == null || r.selectStart(), !0;
    } else return Eu(o.getFirstChild()) ? o.select(2, 2) : o.select(1, 1), !0;
  }
  if (gr(i) && je(o) && o.getIsCollapsed()) {
    const a = o.getNextSibling();
    return a ? a.selectStart() : o.selectEnd(), !0;
  }
  const s = o == null ? void 0 : o.getParent();
  if (Eu(o) && je(s) && o.is(s == null ? void 0 : s.getLastChild())) {
    const a = s.getNextSibling();
    return a ? a.selectStart() : s.selectEnd(), !0;
  }
  return !1;
}
function p5(t, e) {
  const n = pM(t);
  if (Wl(n) && !n.getPreviousSibling())
    return !0;
  if (t.anchor.offset !== 0)
    return !1;
  const r = t.anchor.getNode();
  if (Jr(r.getParent()))
    return !0;
  if (je(n) && n.getIsCollapsed()) {
    const o = n.getPreviousSibling();
    if (!xa(o))
      return !1;
    const s = n.getParent();
    if (!s)
      return !1;
    const a = n.getIndexWithinParent();
    return s.select(a, a), !0;
  }
  if (gr(n) && (e == null ? void 0 : e.noteMode) === "collapsed") {
    const o = n.getLastChild();
    if (!o)
      return !1;
    const s = xr(o, (a) => je(a));
    if (je(s) && s.getIsCollapsed()) {
      const a = s.getParent();
      if (!a)
        return !1;
      const l = s.getIndexWithinParent();
      return a.select(l, l), !0;
    }
  }
  const i = _x(r);
  if (!i || i.getIsCollapsed())
    return !1;
  if (so(n)) {
    const o = i.getParent();
    if (!o)
      return !1;
    const s = i.getIndexWithinParent();
    return o.select(s, s), !0;
  }
  return !1;
}
function g5() {
  const [t] = Le();
  return w5(t), null;
}
function w5(t) {
  de(() => {
    if (!t.hasNodes([yt]))
      throw new Error("CharNodePlugin: CharNode not registered on editor!");
    return t.registerNodeTransform(yt, m5);
  }, [t]);
}
function m5(t) {
  if (!at(t))
    return;
  if (t.isEmpty()) {
    t.remove();
    return;
  }
  const e = t.getMarker(), n = $s(t, Ho), r = t.getUnknownAttributes(), i = t.getNextSibling();
  at(i) && Go({ style: e, cid: n }, i) && ui(r, i.getUnknownAttributes()) && (t.append(...i.getChildren()), i.remove());
  const o = t.getPreviousSibling();
  at(o) && Go({ style: e, cid: n }, o) && ui(r, o.getUnknownAttributes()) && (o.append(...t.getChildren()), t.remove());
}
function Hx(t) {
  return t.replaceAll("	", " ");
}
const Ag = (t) => {
  navigator.clipboard.read().then(async (e) => {
    if ((await navigator.permissions.query({
      // @ts-expect-error These types are incorrect.
      name: "clipboard-read"
    })).state === "denied") {
      alert("Not allowed to paste from clipboard.");
      return;
    }
    const n = new DataTransfer(), r = e[0];
    for (const o of r.types) {
      const s = await (await r.getType(o)).text();
      n.setData(o, Hx(s));
    }
    const i = new ClipboardEvent("paste", {
      clipboardData: n
    });
    t.dispatchCommand(es, i);
  });
}, Dg = (t) => {
  navigator.clipboard.read().then(async () => {
    if ((await navigator.permissions.query({
      // @ts-expect-error These types are incorrect.
      name: "clipboard-read"
    })).state === "denied") {
      alert("Not allowed to paste from clipboard.");
      return;
    }
    const e = new DataTransfer(), n = await navigator.clipboard.readText();
    e.setData("text/plain", Hx(n));
    const r = new ClipboardEvent("paste", {
      clipboardData: e
    });
    t.dispatchCommand(es, r);
  });
};
function b5() {
  const [t] = Le();
  return de(() => {
    const e = (n) => {
      const { key: r, shiftKey: i, metaKey: o, ctrlKey: s, altKey: a } = n;
      !(lh ? o : s) || a || (!i && r.toLowerCase() === "c" ? (n.preventDefault(), t.dispatchCommand(Qi, null)) : !i && r.toLowerCase() === "x" ? (n.preventDefault(), t.dispatchCommand(ts, null)) : r.toLowerCase() === "v" && (n.preventDefault(), i ? Dg(t) : Ag(t)));
    };
    return t.registerRootListener((n, r) => {
      r !== null && r.removeEventListener("keydown", e), n !== null && n.addEventListener("keydown", e);
    });
  }, [t]), null;
}
function y5({ logger: t }) {
  const [e] = Le();
  return de(() => Ht(
    // When the backslash or forward slash key is typed.
    e.registerCommand(ua, (n) => n.key !== "\\" && n.key !== "/" ? !1 : (n.preventDefault(), !0), Ic),
    // When the backslash or forward slash character is pasted into the editor.
    e.registerCommand(es, (n) => {
      var r;
      const i = (r = n.clipboardData) == null ? void 0 : r.getData("text/plain");
      return !i || !i.includes("\\") && !i.includes("/") ? !1 : (t == null || t.info("CommandMenuPlugin: paste containing backslash or forward slash ignored."), n.preventDefault(), !0);
    }, Ic),
    // When the backslash or forward slash character is dragged into the editor.
    e.registerCommand(Hu, (n) => {
      var r;
      const i = (r = n.dataTransfer) == null ? void 0 : r.getData("text/plain");
      return !i || !i.includes("\\") && !i.includes("/") ? !1 : (t == null || t.info("CommandMenuPlugin: drag containing backslash or forward slash ignored."), n.preventDefault(), !0);
    }, Ic)
  ), [e, t]), null;
}
function v5({ index: t, isSelected: e, onClick: n, onMouseEnter: r, option: i }) {
  let o = "item";
  return e && (o += " selected"), i.isDisabled && (o += " disabled"), p("li", { tabIndex: -1, className: o, ref: i.setRefElement, role: "option", "aria-selected": e, "aria-disabled": i.isDisabled, id: "typeahead-item-" + t, onMouseEnter: r, onClick: i.isDisabled ? void 0 : n, children: p("span", { className: "text", children: i.title }) }, i.key);
}
function _5({ options: t, selectedItemIndex: e, onOptionClick: n, onOptionMouseEnter: r }) {
  return p("div", { className: "typeahead-popover", children: p("ul", { children: t.map((i, o) => p(v5, { index: o, isSelected: e === o, onClick: () => n(i, o), onMouseEnter: () => r(o), option: i }, i.key)) }) });
}
class Sc extends TT {
  constructor(e, n) {
    super(e), me(this, "title"), me(this, "onSelect"), me(this, "isDisabled"), this.title = e, this.onSelect = n.onSelect.bind(this), this.isDisabled = n.isDisabled || !1;
  }
}
function x5(t, e = "editor-input") {
  return t ? t.classList.contains(e) : !1;
}
function C5() {
  const [t] = Le(), [e, n] = ue(() => !t.isEditable()), r = ye(void 0), i = ye(void 0), o = ye(void 0), s = Ne(() => [
    new Sc("Cut", {
      onSelect: () => {
        t.dispatchCommand(ts, null);
      },
      isDisabled: e
    }),
    new Sc("Copy", {
      onSelect: () => {
        t.dispatchCommand(Qi, null);
      }
    }),
    new Sc("Paste", {
      onSelect: () => {
        Ag(t);
      },
      isDisabled: e
    }),
    new Sc("Paste as Plain Text", {
      onSelect: () => {
        Dg(t);
      },
      isDisabled: e
    })
  ], [t, e]), a = be((l, c, u) => {
    t.update(() => {
      l == null || l.onSelect(c), u();
    });
  }, [t]);
  return de(() => {
    var l;
    i.current = ((l = t.getRootElement()) == null ? void 0 : l.className) ?? "";
  }, [t]), de(() => {
    const l = () => {
      var c;
      (c = o.current) == null || c.call(o);
    };
    return window.addEventListener("scroll", l, !0), () => {
      window.removeEventListener("scroll", l, !0);
    };
  }, []), de(() => t.registerEditableListener((l) => {
    n(!l);
  }), [t]), p(MT, { options: s, onSelectOption: a, onWillOpen: (l) => {
    r.current = l.target;
  }, menuRenderFn: (l, { selectedIndex: c, options: u, selectOptionAndCleanUp: f, setHighlightedIndex: d }, { setMenuRef: h }) => (o.current = () => f(void 0), l.current && !x5(r.current, i.current) && !hx(r.current) ? L1.createPortal(p("div", { className: "typeahead-popover auto-embed-menu", style: {
    marginLeft: l.current.style.width,
    userSelect: "none",
    width: 200
  }, ref: h, children: p(_5, { options: s, selectedItemIndex: c, onOptionClick: (g, w) => {
    g.isDisabled || (d(w), f(g));
  }, onOptionMouseEnter: (g) => {
    d(g);
  } }) }), l.current) : null) });
}
function k5({ isEditable: t }) {
  const [e] = Le();
  return kn(() => {
    e.setEditable(t);
  }, [e, t]), null;
}
function E5({ scripture: t, nodeOptions: e, editorAdaptor: n, viewOptions: r, logger: i }) {
  const [o] = Le();
  return de(() => {
    var s;
    (s = n.initialize) == null || s.call(n, e, i);
  }, [n, i, e]), de(() => {
    var s;
    (s = n.reset) == null || s.call(n);
    const a = n.serializeEditorState(t, r);
    if (a == null) {
      i == null || i.warn("LoadStatePlugin: serializedEditorState was null or undefined. Skipping editor update.");
      return;
    }
    try {
      const l = o.parseEditorState(a);
      queueMicrotask(() => {
        o.update(() => {
          o.setEditorState(l), o.dispatchCommand(p0, void 0);
        }, { tag: lg });
      });
    } catch {
      i == null || i.error("LoadStatePlugin: error parsing or setting editor state.");
    }
  }, [o, n, i, t, r]), null;
}
function N5({ expandedNoteKeyRef: t, nodeOptions: e, viewOptions: n, logger: r }) {
  const [i] = Le();
  return S5(e, r), T5(i, t, n, r), null;
}
function S5(t, e) {
  const n = ye(void 0), r = t.noteCallers;
  de(() => {
    let i = r;
    (!i || i.length <= 0) && (i = CO), n.current !== i && (n.current = i, L5("note-callers", i, e));
  }, [e, r]);
}
function T5(t, e, n, r) {
  de(() => {
    if (!t.hasNodes([yt, Wt, yr]))
      throw new Error("NoteNodePlugin: CharNode, NoteNode or ImmutableNoteCallerNode not registered on editor!");
    const i = (o) => t.update(() => P5(o));
    return Ht(
      // Remove NoteNode if it doesn't contain a caller node and ensure typed text goes before it.
      t.registerNodeTransform(Wt, (o) => A5(o, n)),
      // Update NoteNodeCaller preview text when NoteNode children text is changed.
      t.registerNodeTransform(yt, D5),
      t.registerNodeTransform(_n, M5),
      // Ensure NBSP after caller.
      t.registerNodeTransform(yr, O5),
      // Re-generate all note callers when a note is removed.
      t.registerMutationListener(yr, (o, { prevEditorState: s }) => I5(o, s)),
      // Handle the cursor moving next to a NoteNode. NoteNode arrow key navigation when note is
      // after a verse node is handled in the ArrowNavigationPlugin.
      t.registerCommand(Yi, () => R5(t, e, n, r), rs),
      // Handle double-click of a word immediately following a NoteNode (no space between).
      t.registerRootListener((o, s) => {
        s !== null && s.removeEventListener("dblclick", i), o !== null && o.addEventListener("dblclick", i);
      })
    );
  }, [t, e, r, n]);
}
function A5(t, e) {
  const n = t.getChildren();
  if (!n.some((r) => so(r)) && (e == null ? void 0 : e.markerMode) !== "editable" && t.getCaller() !== "" && t.remove(), n.length > 0) {
    const r = n[0];
    ie(r) && !Jl(r) && t.insertBefore(r);
  }
}
function D5(t) {
  const e = t.getParentOrThrow(), n = e.getChildren(), r = n.find((s) => so(s));
  if (!at(t) || !je(e) || !r)
    return;
  const i = bg(n);
  r.getPreviewText() !== i && r.setPreviewText(i);
  const o = t.getNextSibling();
  ie(o) ? o.getTextContent() !== st && o.setTextContent(st) : t.insertAfter(Re(st));
}
function M5(t) {
  const e = _x(t), n = e == null ? void 0 : e.getChildren(), r = n == null ? void 0 : n.find((o) => so(o));
  if (!ie(t) || !je(e) || !r || !n)
    return;
  const i = bg(n);
  r.getPreviewText() !== i && r.setPreviewText(i), !(Jl(t) || !je(t.getParent())) && t.getTextContent() !== st && (t.setTextContent(st), t.selectEnd());
}
function O5(t) {
  if (!so(t))
    return;
  const e = t.getNextSibling();
  !ie(e) || Jl(e) ? t.insertAfter(Re(st)) : e.getTextContent() !== st && e.setTextContent(st);
}
function I5(t, e) {
  for (const [n, r] of t) {
    if (r !== "destroyed")
      continue;
    const i = e.read(() => {
      const s = Oe(n), a = s == null ? void 0 : s.getParent();
      return so(s) && je(a) && a.getCaller() === ji;
    }), o = document.querySelector(".editor-input");
    !i || !o || (o.classList.add("reset-counters"), o.offsetHeight, o.classList.remove("reset-counters"));
  }
}
function R5(t, e, n, r) {
  var i;
  if ((n == null ? void 0 : n.noteMode) !== "expandInline")
    return !1;
  const o = oe();
  if (!Z(o) || !o.isCollapsed())
    return !1;
  const s = o.anchor, a = s.getNode();
  if (e.current) {
    const l = xr(a, (c) => je(c));
    if (l)
      e.current !== l.getKey() && (e.current = l.getKey());
    else {
      const c = Oe(e.current);
      c && !c.getIsCollapsed() && (r == null || r.debug("Cursor moved away from NoteNode, collapsing it"), $a(t, e.current, r)), e.current = void 0;
    }
  }
  if (s.offset === 0) {
    const l = a.getPreviousSibling();
    if (je(l)) {
      r == null || r.debug("Cursor is just after a NoteNode");
      const c = l.getKey();
      l.getIsCollapsed() ? e.current = c : e.current = void 0, $a(t, c, r);
    }
  }
  if (s.offset === a.getTextContentSize()) {
    const l = a.getNextSibling();
    if (je(l)) {
      r == null || r.debug("Cursor is just before a NoteNode");
      const c = l.getKey();
      l.getIsCollapsed() ? e.current = c : e.current = void 0, $a(t, c, r);
    } else if (!l) {
      const c = xr(a, (u) => je(u));
      if (c && c.getIsCollapsed() && gr(c.getParent()) && c.is((i = c.getParent()) == null ? void 0 : i.getLastChild())) {
        r == null || r.debug("Cursor is at end of note at end of para");
        const u = c.getKey();
        e.current = u, $a(t, u, r);
      }
    }
  }
  if (gr(a)) {
    const l = a.getChildAtIndex(s.offset), c = l == null ? void 0 : l.getPreviousSibling();
    if (xa(c) && je(l)) {
      r == null || r.debug("Cursor is between verse and NoteNode");
      const u = l.getKey();
      l.getIsCollapsed() ? e.current = u : e.current = void 0, $a(t, u, r);
    }
  }
  return !1;
}
function $a(t, e, n) {
  const r = Oe(e);
  try {
    r == null || r.toggleIsCollapsed();
  } catch (i) {
    if (i instanceof Error && i.message.includes("read only"))
      n == null || n.warn("Fallback triggered after stabilization - edge case"), setTimeout(() => {
        t.update(() => {
          r == null || r.toggleIsCollapsed();
        });
      }, 0);
    else
      throw i;
  }
}
function P5(t) {
  const e = oe();
  if (!Z(e))
    return;
  const n = e.anchor, r = e.focus, i = n.getNode(), o = r.getNode();
  if (je(i) && ie(o)) {
    t.preventDefault();
    const s = $l();
    s.anchor.set(o.getKey(), 0, "text"), s.focus.set(o.getKey(), r.offset, "text"), sn(s);
  }
}
function L5(t, e, n) {
  for (const r of document.styleSheets)
    try {
      const i = r.cssRules || r.rules;
      for (const o of i)
        if ($5(o, t)) {
          const s = e.map((a) => `"${a}"`).join(" ");
          o.symbols = s;
          return;
        }
    } catch {
      continue;
    }
  n == null || n.warn(`Editor: counter style "${t}" not found.`);
}
function $5(t, e) {
  return (
    // This check could be simpler but as is also works for test mocks.
    typeof t == "object" && t !== null && "name" in t && t.name === e && "symbols" in t && typeof t.symbols == "string"
  );
}
function F5({ onChange: t }) {
  const [e] = Le();
  return de(() => e.registerCommand(Yi, () => {
    const n = e.read(() => Dx());
    return t == null || t(n), !1;
  }, rs), [e, t]), null;
}
function B5() {
  const [t] = Le();
  return q5(t), null;
}
function q5(t) {
  de(() => {
    if (!t.hasNodes([In]))
      throw new Error("ParaNodePlugin: ParaNode not registered on editor!");
    return t.registerNodeTransform(In, (e) => j5(e, t));
  }, [t]);
}
function j5(t, e) {
  kg(e, t.getKey()) && Lx(t.getFirstChild()), !(!fn(t) || t.getMarker() !== "b" || t.isEmpty() || !e.getEditorState().read(() => {
    const n = Oe(t.getKey());
    return fn(n) && ((n == null ? void 0 : n.isEmpty()) ?? !1);
  })) && t.clear();
}
function Kx({ onStateChange: t }) {
  const [e] = Le(), [n, r] = ue(e), i = ye(!1), o = ye(!1), s = ye(), a = be(() => {
    const l = oe();
    if (Z(l)) {
      const c = l.anchor.getNode();
      let u = c.getKey() === "root" ? c : xr(c, (d) => {
        const h = d.getParent();
        return h !== null && Zr(h);
      });
      u === null && (u = c.getTopLevelElementOrThrow());
      const f = u.getKey();
      n.getElementByKey(f) !== null && (fn(u) || Jr(u) || Wl(u)) && (s.current = u.getMarker(), t == null || t(i.current, o.current, s.current));
    }
  }, [n, t]);
  return de(() => e.registerCommand(Yi, (l, c) => (a(), r(c), !1), ks), [e, a]), de(() => Ht(n.registerUpdateListener(({ editorState: l }) => {
    l.read(() => {
      a();
    });
  }), n.registerCommand(Ua, (l) => (i.current = l, t == null || t(i.current, o.current, s.current), !1), ks), n.registerCommand(ja, (l) => (o.current = l, t == null || t(i.current, o.current, s.current), !1), ks)), [a, n, t]), null;
}
function U5({ textDirection: t }) {
  const [e] = Le();
  return z5(e, t), V5(e), null;
}
function z5(t, e) {
  de(() => {
    function n() {
      const r = t.getRootElement();
      if (!r || e === "auto")
        return;
      r.dir = e;
      const i = t._config.theme.placeholder, o = document.getElementsByClassName(i)[0];
      o && (o.dir = e);
    }
    return n(), t.registerUpdateListener(({ dirtyElements: r }) => {
      r.size > 0 && n();
    });
  }, [t, e]);
}
function V5(t) {
  de(() => {
    const e = (n) => {
      if (n.key !== "ArrowLeft" && n.key !== "ArrowRight")
        return !1;
      const r = oe();
      if (!Z(r))
        return !1;
      const i = r.anchor.getNode(), o = xr(i, (f) => _M(f, t) === "p");
      if (!o)
        return !1;
      const s = t.getElementByKey(o.getKey());
      if (!s)
        return !1;
      const a = s.parentElement, l = s.dir || "ltr", c = ((a == null ? void 0 : a.dir) ?? "") || "ltr";
      if (!a || l === c)
        return !1;
      const u = a.dir === "rtl" && n.key === "ArrowLeft" || a.dir === "ltr" && n.key === "ArrowRight";
      return r.modify("move", u, "character"), n.preventDefault(), !0;
    };
    return t.registerCommand(ua, e, Gu);
  }, [t]);
}
function H5() {
  const [t] = Le();
  return K5(t), null;
}
function K5(t) {
  de(() => {
    if (!t.hasNodes([yt, Cn, Wt, _n, xn]))
      throw new Error("TextSpacingPlugin: CharNode, ImmutableVerseNode, NoteNode, TextNode or VerseNode not registered on editor!");
    return Ht(t.registerNodeTransform(_n, W5), t.registerNodeTransform(_n, (e) => G5(e, t)), t.registerNodeTransform(xn, Kb), t.registerNodeTransform(Cn, Kb));
  }, [t]);
}
function W5(t) {
  if (!t.isAttached())
    return;
  const e = t.getTextContent(), n = t.getNextSibling(), r = t.getParent();
  t.getMode() !== "normal" || e.endsWith(" ") && e.length > 1 || je(n) || at(r) || on(r) || Kl(r) || (e === " " && !ir(n) ? t.setTextContent("") : Cg(t));
}
function G5(t, e) {
  const n = t.getParent();
  !Kl(n) || !t.isAttached() || kg(e, t.getKey()) && n.insertAfter(t);
}
function Kb(t) {
  if (!t.isAttached())
    return;
  const e = t.getPreviousSibling();
  e && !ir(e) && !ie(e) && !Kl(e) && t.insertBefore(Re(" "));
}
function J5({ trigger: t, scriptureReference: e, contextMarker: n, getMarkerAction: r }) {
  const { markersMenuItems: i } = UO({
    scriptureReference: e,
    contextMarker: n,
    getMarkerAction: r
  });
  return p(jO, { trigger: t, items: i });
}
function X5({ trigger: t, scrRef: e, getMarkerAction: n }) {
  const { book: r, chapterNum: i, verseNum: o, verse: s } = e, a = Ne(() => e, [r, i, o, s]), [l] = Le(), [c] = Y5(l);
  return Q5(l), p(J5, { trigger: t, scriptureReference: a, contextMarker: c, getMarkerAction: n });
}
function Y5(t) {
  const [e, n] = ue();
  return de(() => t.registerCommand(Yi, () => (t.read(() => {
    const r = oe();
    if (!Z(r)) {
      e && n(void 0);
      return;
    }
    const i = Oe(r.anchor.key), o = Oe(r.focus.key);
    if (!i || !o) {
      e && n(void 0);
      return;
    }
    const s = wM(i, o);
    if (!s || !GM(s)) {
      e && n(void 0);
      return;
    }
    const a = s.getMarker();
    e !== a && n(a);
  }), !1), rs), [e, t]), [e];
}
function Q5(t) {
  de(() => {
    if (!t.hasNodes([xn, Cn]))
      throw new Error("UsjNodesMenuPlugin: VerseNode or ImmutableVerseNode not registered on editor!");
    const e = {}, n = {};
    return Ht(t.registerNodeTransform(Cn, (r) => Wb(r, t, e)), t.registerNodeTransform(xn, (r) => Wb(r, t, e)), t.registerMutationListener(Cn, (r) => Yb(r, t, e, n)), t.registerMutationListener(xn, (r) => Yb(r, t, e, n)));
  }, [t]);
}
function Wb(t, e, n) {
  tE(lg) || kg(e, t.getKey()) && tI(t, n);
}
function Gb(t) {
  return RegExp(/(\d+)([a-zA-Z]+)?(-(\d+)([a-zA-Z]+)?)?/).exec(t);
}
const Jb = 2, Z5 = 3, Xb = 4, eI = 5;
function tI(t, e) {
  var n;
  const r = gg(t), i = r == null ? void 0 : r.getNumber();
  if (!i)
    return;
  const o = e[i];
  if (!o)
    return;
  let s = parseInt(t.getNumber()), a = ((n = Gb(t.getNumber())) == null ? void 0 : n[Jb]) ?? "";
  o.forEach((l) => {
    const c = Oe(l);
    if (!c)
      return;
    const u = c.getNumber(), f = parseInt(u), d = Gb(u), h = !!(d != null && d[Z5]), g = h ? parseInt(d[Xb]) : f;
    if (g < s || // e.g. insert 3b before 4 => 4
    f > s || // e.g. insert 3 before 3a => 4a
    g === s && a)
      return;
    const w = (d == null ? void 0 : d[Jb]) ?? "", b = (d == null ? void 0 : d[eI]) ?? "", _ = h ? Oh(parseInt(d[Xb]), void 0) : "";
    let y = `${w}`;
    y += h ? `-${_}${b}` : "";
    const C = Oh(f, void 0);
    c.setNumber(`${C}${y}`), s = parseInt(h ? _ : C), a = h ? b : w;
  });
}
function Yb(t, e, n, r) {
  e.getEditorState().read(() => {
    for (const [i, o] of t) {
      const s = Oe(i);
      if (ir(s)) {
        if (o === "created") {
          const a = gg(s);
          if (!a)
            continue;
          const l = a.getNumber();
          n[l] || (n[l] = []), n[l].push(i), r[i] = l;
        } else if (o === "destroyed") {
          const a = r[i], l = n[a];
          if (!l)
            continue;
          const c = l.findIndex((u) => u === i);
          if (c === -1)
            continue;
          l.splice(c, 1), Reflect.deleteProperty(r, i);
        }
      }
    }
  });
}
const Wx = "formatted", nI = "unformatted";
let Mg;
function rI(t) {
  const e = iI(t);
  if (!e)
    throw new Error(`Invalid view mode: ${t}`);
  Mg = e;
}
rI(Wx);
const Og = () => Mg;
function iI(t) {
  let e;
  switch (t) {
    case Wx:
      e = {
        markerMode: "hidden",
        noteMode: "collapsed",
        hasSpacing: !0,
        isFormattedFont: !0
      };
      break;
    case nI:
      e = {
        markerMode: "editable",
        noteMode: "expanded",
        hasSpacing: !1,
        isFormattedFont: !1
      };
      break;
  }
  return e;
}
function oI(t) {
  if (t)
    return t.markerMode === "editable" ? xn : Cn;
}
function sI(t) {
  const e = [], n = t ?? Mg;
  return n && (e.push(`${zD}${n.markerMode}`), n.hasSpacing && e.push(jD), n.isFormattedFont && e.push(UD)), e;
}
let Ph;
function aI(t) {
  t && (Ph = t);
}
function lI(t) {
  return t.isEmpty() ? ip : cI(t.toJSON());
}
function cI(t) {
  if (!t.root || !t.root.children) return;
  const e = t.root.children;
  if (e.length === 1 && dg(e[0]) && (!e[0].children || e[0].children.length === 0))
    return ip;
  const n = Gx(e), r = Di(n);
  return r ? { type: ol, version: sl, content: r } : void 0;
}
function uI(t, e) {
  const { type: n, marker: r, unknownAttributes: i } = t;
  let o;
  return t.code !== "" && (o = t.code), Ft({
    type: n,
    marker: r,
    code: o,
    ...i,
    content: e
  });
}
function dI(t) {
  const { marker: e, number: n, sid: r, altnumber: i, pubnumber: o, unknownAttributes: s } = t;
  return Ft({
    type: Ar.getType(),
    marker: e,
    number: n,
    sid: r,
    altnumber: i,
    pubnumber: o,
    ...s
  });
}
function fI(t, e) {
  const { marker: n, sid: r, altnumber: i, pubnumber: o, unknownAttributes: s } = t, a = e && typeof e[0] == "string" ? e[0] : void 0;
  let { number: l } = t;
  return l = xx(n, a, l), Ft({
    type: Ar.getType(),
    marker: n,
    number: l,
    sid: r,
    altnumber: i,
    pubnumber: o,
    ...s
  });
}
function hI(t) {
  const { marker: e, sid: n, altnumber: r, pubnumber: i, unknownAttributes: o } = t, { text: s } = t;
  let { number: a } = t;
  return a = xx(e, s, a), Ft({
    type: xn.getType(),
    marker: e,
    number: a,
    sid: n,
    altnumber: r,
    pubnumber: i,
    ...o
  });
}
function pI(t, e) {
  const { type: n, marker: r, unknownAttributes: i } = t, o = r === "" ? void 0 : r;
  return e == null || e.forEach((s, a) => {
    typeof s == "string" && s.startsWith(st) && (e[a] = s.slice(1));
  }), Ft({
    type: n,
    marker: o,
    ...i,
    content: e
  });
}
function gI(t, e) {
  const { type: n, marker: r, unknownAttributes: i } = t;
  return Ft({
    type: n,
    marker: r,
    ...i,
    content: e
  });
}
function wI(t, e) {
  const { type: n, marker: r, caller: i, category: o, unknownAttributes: s } = t;
  return Ft({
    type: n,
    marker: r,
    caller: i,
    category: o,
    ...s,
    content: e
  });
}
function bs(t) {
  const { type: e, marker: n, sid: r, eid: i, unknownAttributes: o } = t;
  return Ft({
    type: e,
    marker: n === "" ? void 0 : n,
    sid: r,
    eid: i,
    ...o
  });
}
function mI(t) {
  return t.text;
}
function bI(t, e) {
  const { tag: n, marker: r, unknownAttributes: i } = t;
  return Ft({
    type: n,
    marker: r,
    ...i,
    content: e
  });
}
function yI(t) {
  const { marker: e } = t;
  return {
    type: Nu,
    marker: e === "" ? void 0 : e
  };
}
function Qb(t, e) {
  const n = t[t.length - 1];
  n && typeof n == "string" ? t[t.length - 1] = n + e : t.push(e);
}
function vI(t, e, n, r, i) {
  const o = Qr.getType(), s = e.filter((a) => !n.includes(a));
  if (n.filter((a) => !e.includes(a)).forEach((a) => {
    const l = bs({
      type: o,
      marker: As,
      eid: a
    });
    i.push(l);
  }), s.forEach((a) => {
    const l = bs({
      type: o,
      marker: Wo,
      sid: a
    });
    i.push(l);
  }), e.length === 0) {
    const a = bs({
      type: o,
      marker: Wo
    });
    i.push(a);
  }
  if (i.push(...t), e.length === 0) {
    const a = bs({
      type: o,
      marker: As
    });
    i.push(a);
  }
  (!r || !SM(r)) && e.forEach((a) => {
    const l = bs({
      type: o,
      marker: As,
      eid: a
    });
    i.push(l);
  });
}
function Di(t, e) {
  const n = [];
  let r, i = [];
  return t.forEach((o, s) => {
    const a = o, l = o, c = o, u = o, f = o, d = o, h = o, g = o;
    switch (o.type) {
      case sr.getType():
        n.push(
          uI(a, Di(a.children))
        );
        break;
      case Ni.getType():
        n.push(dI(o));
        break;
      case Ar.getType():
        n.push(
          fI(l, Di(l.children))
        );
        break;
      case Cn.getType():
      case xn.getType():
        n.push(hI(o));
        break;
      case yt.getType():
        n.push(
          pI(c, Di(c.children))
        );
        break;
      case In.getType():
        n.push(
          gI(u, Di(u.children))
        );
        break;
      case Wt.getType():
        n.push(
          wI(
            f,
            Di(f.children, f.caller)
          )
        );
        break;
      case io.getType():
      case yr.getType():
      case Rl.getType():
      case as.getType():
        break;
      case nn.getType():
        if (r = Di(h.children), r) {
          const w = h.typedIDs[$i];
          if (w)
            vI(r, w, i, t[s + 1], n), i = w;
          else {
            const b = r.shift();
            b && (typeof b == "string" ? Qb(n, b) : n.push(b)), r.length > 0 && n.push(...r);
          }
        }
        break;
      case Qr.getType():
        n.push(bs(o));
        break;
      case _n.getType():
        d.text && d.text !== st && !d.text.startsWith(ag) && (!e || d.text !== mg(e)) && Qb(n, mI(d));
        break;
      case ss.getType():
        n.push(
          bI(g, Di(g.children))
        );
        break;
      case oo.getType():
        n.push(yI(o));
        break;
      default:
        Ph == null || Ph.error(`Unexpected node type '${o.type}'!`);
    }
  }), n && n.length > 0 ? n : void 0;
}
function Gx(t) {
  const e = t.findIndex((n) => dg(n));
  if (e >= 0) {
    const n = t.slice(0, e), r = t[e].children, i = Gx(t.slice(e + 1));
    t = [...n, ...r, ...i];
  }
  return t;
}
const _f = {
  initialize: aI,
  deserializeEditorState: lI
}, Zb = Jx([]), _I = {
  type: Rl.getType(),
  version: 1
};
let Au = [], Ae, jc, Lh, dt;
function xI(t, e) {
  Au = [], EI(t), NI(e);
}
function CI(t = 0) {
}
function kI(t, e) {
  Ae = e ?? Og();
  let n;
  return t ? (t.type !== ol && (dt == null || dt.warn(`This USJ type '${t.type}' didn't match the expected type '${ol}'.`)), t.version !== sl && (dt == null || dt.warn(
    `This USJ version '${t.version}' didn't match the expected version '${sl}'.`
  )), t.content.length > 0 ? n = Fh(Ka(t.content)) : n = [Zb]) : n = [Zb], Lh == null || Lh(Au), {
    root: {
      children: n,
      direction: null,
      format: "",
      indent: 0,
      type: "root",
      version: 1
    }
  };
}
function EI(t) {
  t && (jc = t), t != null && t.addMissingComments && (Lh = t.addMissingComments);
}
function NI(t) {
  t && (dt = t);
}
function SI(t) {
  return !t || t.length !== 1 || typeof t[0] != "string" ? "" : t[0];
}
function TI(t) {
  let { marker: e } = t;
  e !== xl && (dt == null || dt.warn(`Unexpected book marker '${e}'!`)), e = e ?? xl;
  const { code: n } = t;
  (!n || !sr.isValidBookCode(n)) && (dt == null || dt.warn(`Unexpected book code '${n}'!`));
  const r = [];
  ((Ae == null ? void 0 : Ae.markerMode) === "editable" || (Ae == null ? void 0 : Ae.markerMode) === "visible") && r.push(
    Yo("marker", Si(e) + " " + n + st)
  );
  const i = SI(t.content);
  i && r.push(Xo(i));
  const o = Gt(t);
  return Ft({
    type: sr.getType(),
    marker: e,
    code: n ?? "",
    unknownAttributes: o,
    children: r,
    direction: null,
    format: "",
    indent: 0,
    version: rx
  });
}
function AI(t) {
  let { marker: e } = t;
  e !== Cu && (dt == null || dt.warn(`Unexpected chapter marker '${e}'!`)), e = e ?? Cu;
  const { number: n, sid: r, altnumber: i, pubnumber: o } = t, s = Gt(t);
  let a;
  return (Ae == null ? void 0 : Ae.markerMode) === "visible" && (a = !0), (Ae == null ? void 0 : Ae.markerMode) === "editable" ? Ft({
    type: Ar.getType(),
    marker: e,
    number: n ?? "",
    sid: r,
    altnumber: i,
    pubnumber: o,
    unknownAttributes: s,
    children: [Xo(Gl(e, n) ?? "")],
    direction: null,
    format: "",
    indent: 0,
    version: sx
  }) : Ft({
    type: Ni.getType(),
    marker: e,
    number: n ?? "",
    showMarker: a,
    sid: r,
    altnumber: i,
    pubnumber: o,
    unknownAttributes: s,
    version: dx
  });
}
function DI(t) {
  let { marker: e } = t;
  e !== ku && (dt == null || dt.warn(`Unexpected verse marker '${e}'!`)), e = e ?? ku;
  const { number: n, sid: r, altnumber: i, pubnumber: o } = t, s = (oI(Ae) ?? Cn).getType(), a = (Ae == null ? void 0 : Ae.markerMode) === "editable" ? yx : Ox;
  let l, c;
  (Ae == null ? void 0 : Ae.markerMode) === "editable" ? l = Gl(e, n) : (Ae == null ? void 0 : Ae.markerMode) === "visible" && (c = !0);
  const u = Gt(t);
  return Ft({
    type: s,
    text: l,
    marker: e,
    number: n ?? "",
    sid: r,
    altnumber: i,
    pubnumber: o,
    showMarker: c,
    unknownAttributes: u,
    version: a
  });
}
function MI(t, e = []) {
  let { marker: n } = t;
  yt.isValidMarker(n) || dt == null || dt.warn(`Unexpected char marker '${n}'!`), n = n ?? "", (Ae == null ? void 0 : Ae.markerMode) === "editable" && e.forEach((i) => {
    wg(i) && (i.text = st + i.text);
  });
  const r = Gt(t);
  return Ft({
    type: yt.getType(),
    marker: n,
    unknownAttributes: r,
    children: [...e],
    direction: null,
    format: "",
    indent: 0,
    textFormat: 0,
    textStyle: "",
    version: ux
  });
}
function Jx(t) {
  return {
    type: Gi.getType(),
    children: t,
    direction: null,
    format: "",
    indent: 0,
    textFormat: 0,
    textStyle: "",
    version: px
  };
}
function OI(t, e = []) {
  let { marker: n } = t;
  In.isValidMarker(n) || dt == null || dt.warn(`Unexpected para marker '${n}'!`), n = n ?? fd;
  const r = [];
  (Ae == null ? void 0 : Ae.markerMode) === "editable" ? r.push(ta(n), Xo(st)) : (Ae == null ? void 0 : Ae.markerMode) === "visible" && r.push(Yo("marker", Si(n) + st)), r.push(...e);
  const i = Gt(t);
  return Ft({
    type: In.getType(),
    marker: n,
    unknownAttributes: i,
    children: r,
    direction: null,
    format: "",
    indent: 0,
    textFormat: 0,
    textStyle: "",
    version: bx
  });
}
function II(t, e) {
  const n = vM(e);
  let r = () => {
  };
  return jc != null && jc.noteCallerOnClick && (r = jc.noteCallerOnClick), Ft({
    type: yr.getType(),
    caller: t,
    previewText: n,
    onClick: r,
    version: Bx
  });
}
function RI(t, e) {
  let { marker: n } = t;
  Wt.isValidMarker(n) || dt == null || dt.warn(`Unexpected note marker '${n}'!`), n = n ?? fg;
  const { category: r } = t, i = t.caller ?? "*", o = (Ae == null ? void 0 : Ae.noteMode) !== "expanded", s = Gt(t);
  let a, l;
  (Ae == null ? void 0 : Ae.markerMode) === "editable" ? (a = ta(n), l = ta(n, "closing")) : (Ae == null ? void 0 : Ae.markerMode) === "visible" && (a = Yo("marker", Si(n) + st), l = Yo("marker", Qs(n) + st));
  const c = [];
  let u;
  if (a && c.push(a), (Ae == null ? void 0 : Ae.markerMode) === "editable")
    u = Xo(mg(i)), c.push(u, ...e);
  else {
    const f = Xo(st);
    u = II(i, e), c.push(u, f, ...e.flatMap(PI(f)));
  }
  return l && c.push(l), Ft({
    type: Wt.getType(),
    marker: n,
    caller: i,
    isCollapsed: o,
    category: r,
    unknownAttributes: s,
    children: c,
    direction: null,
    format: "",
    indent: 0,
    version: mx
  });
}
function PI(t) {
  return (e) => MM(e) ? [e] : [e, t];
}
function LI(t) {
  let { marker: e } = t;
  (!e || !Qr.isValidMarker(e)) && (dt == null || dt.warn(`Unexpected milestone marker '${e}'!`)), e = e ?? "";
  const { sid: n, eid: r } = t, i = Gt(t);
  return Ft({
    type: Qr.getType(),
    marker: e,
    sid: n,
    eid: r,
    unknownAttributes: i,
    version: gx
  });
}
function ey(t, e = []) {
  return {
    type: nn.getType(),
    typedIDs: { [$i]: e },
    children: t,
    direction: null,
    format: "",
    indent: 0,
    version: 1
  };
}
function $I(t, e) {
  const { marker: n } = t, r = t.type, i = Gt(t), o = [...e];
  return o.forEach((s) => {
    wg(s) && (s.mode = "token");
  }), Ft({
    type: ss.getType(),
    tag: r,
    marker: n,
    unknownAttributes: i,
    children: o,
    direction: null,
    format: "",
    indent: 0,
    version: tx
  });
}
function FI(t) {
  return {
    type: oo.getType(),
    marker: t,
    version: Tx
  };
}
function ta(t, e = "opening") {
  return {
    type: as.getType(),
    marker: t,
    markerSyntax: e,
    text: "",
    detail: 0,
    format: 0,
    mode: "normal",
    style: "",
    version: 1
  };
}
function Xo(t, e = "normal") {
  return {
    type: _n.getType(),
    text: t,
    detail: 0,
    format: 0,
    mode: e,
    style: "",
    version: 1
  };
}
function Yo(t, e) {
  return {
    type: io.getType(),
    text: e,
    textType: t,
    version: Sx
  };
}
function ty(t, e) {
  (Ae == null ? void 0 : Ae.markerMode) === "editable" ? e.push(ta(t)) : (Ae == null ? void 0 : Ae.markerMode) === "visible" && e.push(Yo("marker", Si(t)));
}
function ny(t, e, n = !1) {
  yt.isValidFootnoteMarker(t) || yt.isValidCrossReferenceMarker(t) || ((Ae == null ? void 0 : Ae.markerMode) === "editable" ? n ? e.push(ta("", "selfClosing")) : e.push(ta(t, "closing")) : (Ae == null ? void 0 : Ae.markerMode) === "visible" && e.push(Yo("marker", Qs(n ? "" : t))));
}
function BI(t, e) {
  if (t.type !== "ms") return;
  const n = [];
  if (t.sid && n.push(`sid="${t.sid}"`), t.eid && n.push(`eid="${t.eid}"`), n.length <= 0) return;
  const r = ag + n.join(" ");
  (Ae == null ? void 0 : Ae.markerMode) === "editable" ? e.push(Xo(r)) : (Ae == null ? void 0 : Ae.markerMode) === "visible" && e.push(Yo("attribute", r));
}
function ry(t, e) {
  return t.length <= 0 || e === 0 ? t : t.map((n) => n - e);
}
function qI(t, e) {
  const n = t.indexOf(e, 0);
  n > -1 && t.splice(n, 1);
}
function iy(t, e) {
  e.marker === Wo && e.sid !== void 0 && t.push(e.sid), e.marker === As && e.eid !== void 0 && qI(t, e.eid);
}
function $h(t, e, n = !1, r = []) {
  if (e.length <= 0 || e[0] >= t.length) return t;
  const i = e.shift(), o = e.length > 0 ? e.shift() : t.length - 1;
  if (i === void 0 || o === void 0 || o >= t.length || t.length <= 0)
    return t;
  const s = t.slice(0, i), a = n ? [ey(s, [...r])] : s, l = t[i];
  iy(r, l);
  const c = $h(
    t.slice(i + 1, o),
    ry(e, i + 1),
    l.marker === Wo,
    r
  ), u = ey(c, [...r]), f = t[o];
  iy(r, f);
  const d = $h(
    t.slice(o + 1),
    ry(e, o + 1),
    f.marker === Wo,
    r
  );
  return [...a, u, ...d];
}
function Ka(t) {
  const e = [], n = [];
  return t == null || t.forEach((r) => {
    if (typeof r == "string")
      r && n.push(Xo(r));
    else if (!r.type)
      dt == null || dt.error("Marker type is missing!");
    else
      switch (r.type) {
        case sr.getType():
          n.push(TI(r));
          break;
        case Ar.getType():
          n.push(AI(r));
          break;
        case xn.getType():
          Ae != null && Ae.hasSpacing || n.push(_I), n.push(DI(r));
          break;
        case yt.getType():
          ty(r.marker ?? "", n), n.push(MI(r, Ka(r.content))), ny(r.marker ?? "", n);
          break;
        case In.getType():
          n.push(OI(r, Ka(r.content)));
          break;
        case Wt.getType():
          n.push(RI(r, Ka(r.content)));
          break;
        case Qr.getType():
          tM(r.marker ?? "") && (e.push(n.length), r.sid !== void 0 && (Au == null || Au.push(r.sid))), n.push(LI(r)), ty(r.marker ?? "", n), BI(r, n), ny(r.marker ?? "", n, !0);
          break;
        case oo.getType():
          n.push(FI(r.marker ?? ""));
          break;
        default:
          dt == null || dt.warn(`Unknown type-marker '${r.type}-${r.marker}'!`), n.push($I(r, Ka(r.content)));
      }
  }), $h(n, e);
}
function Fh(t) {
  const e = t.findIndex(
    (n) => qD(n) || cM(n) || aM(n)
  );
  if (e >= 0) {
    const n = Fh(t.slice(0, e)), r = t[e], i = Fh(t.slice(e + 1));
    return [...n, r, ...i];
  } else if (t.some((n) => "text" in n && "mode" in n || qM(n)))
    return [Jx(t)];
  return t;
}
const Bh = {
  initialize: xI,
  reset: CI,
  serializeEditorState: kI
}, Tc = (t) => {
  if (!Wt.isValidMarker(t) || !t.includes("f"))
    throw new Error(`Invalid footnote marker '${t}'`);
  return {
    action: (e) => {
      const { chapterNum: n, verseNum: r } = e.reference, i = [];
      return n !== void 0 && r !== void 0 && i.push({
        type: "char",
        marker: "fr",
        content: [`${n}:${r}`]
      }), e.noteText && i.push({
        type: "char",
        marker: "fq",
        content: [e.noteText]
      }), i.push({ type: "char", marker: "ft", content: ["-"] }), [{
        type: "note",
        marker: t,
        caller: ji,
        content: i
      }];
    }
  };
}, oy = (t) => {
  if (!Wt.isValidMarker(t) || !t.includes("x"))
    throw new Error(`Invalid cross-reference marker '${t}'`);
  return {
    action: (e) => {
      const { chapterNum: n, verseNum: r } = e.reference, i = [];
      return n !== void 0 && r !== void 0 && i.push({
        type: "char",
        marker: "xo",
        content: [`${n}:${r}`]
      }), i.push({ type: "char", marker: "xt", content: ["-"] }), [{
        type: "note",
        marker: t,
        caller: el,
        content: i
      }];
    }
  };
}, jI = {
  c: {
    action: (t) => {
      const { chapterNum: e } = t.reference;
      return [{
        type: "chapter",
        marker: "c",
        number: `${e + 1}`
      }];
    }
  },
  v: {
    action: (t) => {
      const { verseNum: e, verse: n } = t.reference;
      return [{
        type: "verse",
        marker: "v",
        number: `${Oh(e, n)}`
      }];
    }
  },
  f: Tc("f"),
  fe: Tc("fe"),
  ef: Tc("ef"),
  efe: Tc("efe"),
  x: oy("x"),
  ex: oy("ex")
};
function UI(t, e, n, r, i) {
  const o = zI(t);
  return { action: (s) => {
    s.editor.update(() => {
      var a;
      const l = oe();
      Z(l) && (s.noteText = l.getTextContent());
      const c = (a = o == null ? void 0 : o.action) == null ? void 0 : a.call(o, s);
      if (!c) return;
      const u = Ib(c, Bh, r), f = wf(u);
      if (Z(l)) {
        const d = l.anchor.getNode();
        if (je(f))
          Ix(f, l, r), f.getIsCollapsed() || (e.current = f.getKey());
        else if (l.getTextContent().length > 0)
          VI(
            l,
            () => wf(u)
          );
        else if (X(f) && !f.isInline()) {
          const h = l.insertParagraph();
          if (h) {
            const g = h.getChildren();
            f.append(...g), h.replace(f), f.selectStart();
          }
        } else if (ie(d) && !Jl(d) && je(d.getParent()) && l.isCollapsed()) {
          let h = d.insertAfter(f);
          if (Eu(f)) {
            const g = {
              ...r || Og(),
              markerMode: "hidden"
            }, w = Ib(
              c,
              Bh,
              g
            ), b = wf(w);
            h = h.insertAfter(b);
          }
          h.insertAfter(Re(st));
        } else {
          l.insertNodes([f]), JI(f);
          const h = f.getNextSibling();
          h ? h.selectStart() : f.selectStart();
        }
      } else
        l == null || l.insertNodes([f]);
    }, i);
  }, label: o == null ? void 0 : o.label };
}
function zI(t) {
  let e = jI[t];
  return e || (In.isValidMarker(t) ? e = {
    action: () => [{
      type: In.getType(),
      marker: t,
      content: []
    }]
  } : yt.isValidMarker(t) && (e = {
    action: () => [{
      type: yt.getType(),
      marker: t,
      content: ["-"]
    }]
  })), e;
}
function VI(t, e) {
  const n = t.getNodes(), [r, i] = HI(t);
  let o;
  n.forEach((s, a) => {
    if (X(o) && o.isParentOf(s))
      return;
    const l = KI(
      s,
      a === 0,
      a === n.length - 1,
      r,
      i
    );
    if (!l) {
      o = void 0;
      return;
    }
    o || (o = e(), l.insertBefore(o)), GI(l, o);
  }), (ie(o) || X(o)) && o.selectEnd();
}
function HI(t) {
  const e = t.anchor.offset, n = t.focus.offset;
  return t.isBackward() ? [n, e] : [e, n];
}
function KI(t, e, n, r, i) {
  if (!(on(t) || je(t) || je(t.getParent()))) {
    if (ie(t))
      return WI(t, e, n, r, i);
    if (X(t) && t.isInline())
      return t;
  }
}
function WI(t, e, n, r, i) {
  const o = t.getTextContentSize(), s = e ? r : 0, a = n ? i : o;
  if (s === 0 && a === 0) return;
  const l = t.splitText(s, a);
  return l.length === 1 ? l[0] : l.length === 3 || a === o ? l[1] : l[0];
}
function GI(t, e) {
  var n;
  if (ie(e)) {
    const r = sy(t, e);
    e.setTextContent(r), t.remove();
  } else if (X(e)) {
    const r = e.getChildrenSize();
    e.append(t);
    for (let i = 0; i < r; i++) (n = e.getFirstChild()) == null || n.remove();
    sy(t, e);
  }
}
function sy(t, e) {
  let n = t.getTextContent();
  if (ie(t) && e.isInline() && n.startsWith(" ")) {
    n = n.trimStart(), t.setTextContent(n);
    const r = e.getPreviousSibling();
    Cg(r), ie(r) || e.insertBefore(Re(" "));
  }
  return n;
}
function JI(t) {
  ir(t) && (Cg(t.getPreviousSibling()), Lx(t.getNextSibling()));
}
const Xx = {
  chapter: "chapter",
  verse: "verse",
  char: "char",
  para: "para",
  typedMark: "editor-typed-mark",
  typedMarkOverlap: "editor-typed-markOverlap",
  mark: "editor-mark",
  markOverlap: "editor-markOverlap",
  placeholder: "editor-placeholder",
  paragraph: "editor-paragraph",
  quote: "editor-quote",
  heading: {
    h1: "editor-heading-h1",
    h2: "editor-heading-h2",
    h3: "editor-heading-h3",
    h4: "editor-heading-h4",
    h5: "editor-heading-h5"
  },
  list: {
    nested: {
      listitem: "editor-nested-listitem"
    },
    ol: "editor-list-ol",
    ul: "editor-list-ul",
    listitem: "editor-listitem"
  },
  image: "editor-image",
  link: "editor-link",
  text: {
    bold: "editor-text-bold",
    italic: "editor-text-italic",
    overflowed: "editor-text-overflowed",
    hashtag: "editor-text-hashtag",
    underline: "editor-text-underline",
    strikethrough: "editor-text-strikethrough",
    underlineStrikethrough: "editor-text-underlineStrikethrough"
  }
};
function XI({
  options: t,
  editedUsjRef: e,
  usj: n,
  setUsj: r
}) {
  const { view: i, nodes: o } = t || {}, { hasSpacing: s, isFormattedFont: a, markerMode: l } = i || {};
  return de(() => {
    e.current && !ui(e.current, n) && r(e.current);
  }, [e, s, a, l, o, r, n]), null;
}
function YI({
  scrRef: t,
  onScrRefChange: e
}) {
  const [n] = Le(), r = ye(!1), i = ye(!1), { book: o, chapterNum: s, verseNum: a } = t;
  return de(
    () => n.registerMutationListener(
      sr,
      (l) => {
        n.update(
          () => {
            for (const [c, u] of l) {
              const f = Oe(c);
              f && Jr(f) && u === "created" && ay(s, a, i);
            }
          },
          { tag: Ah }
        );
      },
      { skipInitialization: !0 }
    ),
    [n, s, a]
  ), de(() => {
    r.current ? r.current = !1 : n.update(() => ay(s, a, i), {
      tag: Ah
    });
  }, [n, s, a]), de(
    () => n.registerCommand(
      Yi,
      () => (i.current ? i.current = !1 : QI(
        o,
        s,
        a,
        e,
        r
      ), !1),
      rs
    ),
    [n, o, s, a, e]
  ), null;
}
function ay(t, e, n) {
  var r;
  const i = kx(oe()), o = (r = Px(i)) == null ? void 0 : r.getNumber();
  if (xM(o) && yg(e, o)) return;
  const s = Ve().getChildren(), a = uM(s, t), l = yM(s, a), c = dM(l, !!a);
  if (c && !a || !a) return;
  bM(l, c);
  const u = WM(l, e);
  if (u) {
    if (fn(u)) {
      const f = u.getFirstChild();
      ie(f) ? f.select(0, 0) : u.select(0, 0);
    } else u.selectNext(0, 0);
    n.current = !0;
  }
}
function QI(t, e, n, r, i) {
  const o = kx(oe());
  if (!o) return;
  const s = gg(o), a = parseInt((s == null ? void 0 : s.getNumber()) ?? "1", 10), l = Px(o), c = l == null ? void 0 : l.getNumber(), u = parseInt(c ?? "0", 10), f = c ? yg(n, c) : n === u;
  if (i.current = !!(s && a !== e || !f), i.current) {
    const d = {
      book: t,
      chapterNum: a,
      verseNum: u
    };
    c != null && u.toString() !== c && (d.verse = c), r(d);
  }
}
function ZI(t) {
  return Jr(t) ? `${t.__code}` : cg(t) ? `${t.__marker} "${t.__number}"` : at(t) ? `${t.__marker}` : Wl(t) ? `${t.__marker} "${t.__number}"` : so(t) ? `${t.__caller}` : xa(t) ? `${t.__marker} "${t.__number}"` : je(t) ? `${t.__marker} "${t.__caller}"` + (t.__isCollapsed ? " (collapsed)" : " (expanded)") : fn(t) ? `${t.__marker}` : on(t) ? `ids: [ ${JSON.stringify(t.getTypedIDs())} ]` : pg(t) ? `${t.__marker} "${t.__number}"` : "";
}
function eR() {
  const [t] = Le();
  return /* @__PURE__ */ p(
    hS,
    {
      viewClassName: "tree-view-output",
      treeTypeButtonClassName: "debug-treetype-button",
      timeTravelPanelClassName: "debug-timetravel-panel",
      timeTravelButtonClassName: "debug-timetravel-button",
      timeTravelPanelSliderClassName: "debug-timetravel-panel-slider",
      timeTravelPanelButtonClassName: "debug-timetravel-panel-button",
      customPrintNode: ZI,
      editor: t
    }
  );
}
const Yx = Sl(null), ly = 4;
function tR({
  children: t,
  className: e,
  onClick: n,
  title: r
}) {
  const i = ye(null), o = Tl(Yx);
  if (o === null)
    throw new Error("DropDownItem must be used within a DropDown");
  const { registerItem: s } = o;
  return de(() => {
    i && i.current && s(i);
  }, [i, s]), /* @__PURE__ */ p("button", { className: e, onClick: n, ref: i, title: r, type: "button", children: t });
}
function nR({
  children: t,
  dropDownRef: e,
  onClose: n
}) {
  const [r, i] = ue(), [o, s] = ue(), a = be(
    (u) => {
      i((f) => f ? [...f, u] : [u]);
    },
    [i]
  ), l = (u) => {
    if (!r) return;
    const f = u.key;
    ["Escape", "ArrowUp", "ArrowDown", "Tab"].includes(f) && u.preventDefault(), f === "Escape" || f === "Tab" ? n() : f === "ArrowUp" ? s((d) => {
      if (!d) return r[0];
      const h = r.indexOf(d) - 1;
      return r[h === -1 ? r.length - 1 : h];
    }) : f === "ArrowDown" && s((d) => d ? r[r.indexOf(d) + 1] : r[0]);
  }, c = Ne(
    () => ({
      registerItem: a
    }),
    [a]
  );
  return de(() => {
    r && !o && s(r[0]), o && o.current && o.current.focus();
  }, [r, o]), /* @__PURE__ */ p(Yx.Provider, { value: c, children: /* @__PURE__ */ p("div", { className: "dropdown", ref: e, onKeyDown: l, children: t }) });
}
function rR({
  disabled: t = !1,
  buttonLabel: e,
  buttonAriaLabel: n,
  buttonClassName: r,
  buttonIconClassName: i,
  children: o,
  stopCloseOnClickSelf: s
}) {
  const a = ye(null), l = ye(null), [c, u] = ue(!1), f = () => {
    u(!1), l && l.current && l.current.focus();
  };
  return de(() => {
    const d = l.current, h = a.current;
    if (c && d !== null && h !== null) {
      const { top: g, left: w } = d.getBoundingClientRect();
      h.style.top = `${g + d.offsetHeight + ly}px`, h.style.left = `${Math.min(w, window.innerWidth - h.offsetWidth - 20)}px`;
    }
  }, [a, l, c]), de(() => {
    const d = l.current;
    if (d !== null && c) {
      const h = (g) => {
        const w = g.target;
        s && a.current && a.current.contains(w) || d.contains(w) || u(!1);
      };
      return document.addEventListener("click", h), () => {
        document.removeEventListener("click", h);
      };
    }
    return () => {
    };
  }, [a, l, c, s]), de(() => {
    const d = () => {
      if (c) {
        const h = l.current, g = a.current;
        if (h !== null && g !== null) {
          const { top: w } = h.getBoundingClientRect(), b = w + h.offsetHeight + ly;
          b !== g.getBoundingClientRect().top && (g.style.top = `${b}px`);
        }
      }
    };
    return document.addEventListener("scroll", d), () => {
      document.removeEventListener("scroll", d);
    };
  }, [l, a, c]), /* @__PURE__ */ B(Lt, { children: [
    /* @__PURE__ */ B(
      "button",
      {
        type: "button",
        disabled: t,
        "aria-label": n || e,
        className: r,
        onClick: () => u(!c),
        ref: l,
        children: [
          i && /* @__PURE__ */ p("span", { className: i }),
          e && /* @__PURE__ */ p("span", { className: "text dropdown-button-text", children: e }),
          /* @__PURE__ */ p("i", { className: "chevron-down" })
        ]
      }
    ),
    c && fi(
      /* @__PURE__ */ p(nR, { dropDownRef: a, onClose: f, children: o }),
      document.body
    )
  ] });
}
const qh = {
  m: "m - Paragraph - Margin - No First Line Indent",
  ms: "ms - Heading - Major Section Level 1",
  nb: "nb - Paragraph - No Break with Previous Paragraph",
  p: "p - Paragraph - Normal - First Line Indent",
  pi: "pi - Paragraph - Indented - Level 1 - First Line Indent",
  q1: "q1 - Poetry - Indent Level 1",
  q2: "q2 - Poetry - Indent Level 2",
  r: "r - Heading - Parallel References",
  s: "s - Heading - Section Level 1"
  // do not allow `b - Poetry - Stanza Break (Blank Line)` here to avoid a USFM validity issue.
}, jh = {
  ...qh,
  ide: "ide - File - Encoding",
  h: "h - File - Header",
  h1: "h1 - File - Header",
  h2: "h2 - File - Left Header",
  h3: "h3 - File - Right Header",
  toc1: "toc1 - File - Long Table of Contents Text",
  toc2: "toc2 - File - Short Table of Contents Text",
  toc3: "toc3 - File - Book Abbreviation",
  cl: "cl - Chapter - Publishing Label",
  mt: "mt - Title - Major Title Level 1",
  mt1: "mt1 - Title - Major Title Level 1",
  mt2: "mt2 - Title - Major Title Level 2",
  mt3: "mt3 - Title - Major Title Level 3",
  mt4: "mt4 - Title - Major Title Level 4",
  ms1: "ms1 - Heading - Major Section Level 1",
  ms2: "ms2 - Heading - Major Section Level 2",
  ms3: "ms3 - Heading - Major Section Level 3",
  b: "b - Poetry - Stanza Break (Blank Line)"
};
function iR({
  editorRef: t,
  blockMarker: e,
  disabled: n = !1
}) {
  return /* @__PURE__ */ p(
    rR,
    {
      disabled: n,
      buttonClassName: "toolbar-item block-controls",
      buttonIconClassName: "icon block-marker " + oR(e),
      buttonLabel: sR(e),
      buttonAriaLabel: "Formatting options for block type",
      children: Object.keys(qh).map((r) => /* @__PURE__ */ B(
        tR,
        {
          className: "item block-marker " + aR(e === r),
          onClick: () => {
            var i;
            return (i = t.current) == null ? void 0 : i.formatPara(r);
          },
          children: [
            /* @__PURE__ */ p("i", { className: "icon block-marker " + r }),
            /* @__PURE__ */ p("span", { className: "text usfm_" + r, children: qh[r] })
          ]
        },
        r
      ))
    }
  );
}
function oR(t) {
  return t && t in jh ? t : "ban";
}
function sR(t) {
  return t && t in jh ? jh[t] : "No Style";
}
function aR(t) {
  return t ? "active dropdown-item-active" : "";
}
function cy() {
  return /* @__PURE__ */ p("div", { className: "divider" });
}
const lR = Yn(function({ editorRef: t, isReadonly: e = !1, onStateChange: n }, r) {
  const [i] = Le(), [o, s] = ue(i), [a, l] = ue(), [c, u] = ue(!1), [f, d] = ue(!1), h = be(
    (g, w, b) => {
      u(g), d(w), l(b), n == null || n(g, w, b);
    },
    [n]
  );
  return de(() => i.registerCommand(
    Yi,
    (g, w) => (s(w), !1),
    ks
  ), [i]), /* @__PURE__ */ B(Lt, { children: [
    /* @__PURE__ */ p(Kx, { onStateChange: h }),
    /* @__PURE__ */ B("div", { className: "toolbar", children: [
      /* @__PURE__ */ p(
        "button",
        {
          disabled: !c || e,
          onClick: () => {
            o.dispatchCommand(Ol, void 0);
          },
          title: lh ? "Undo (âŒ˜Z)" : "Undo (Ctrl+Z)",
          type: "button",
          className: "toolbar-item spaced",
          "aria-label": "Undo",
          children: /* @__PURE__ */ p("i", { className: "format undo" })
        }
      ),
      /* @__PURE__ */ p(
        "button",
        {
          disabled: !f || e,
          onClick: () => {
            o.dispatchCommand(Il, void 0);
          },
          title: lh ? "Redo (âŒ˜Y)" : "Redo (Ctrl+Y)",
          type: "button",
          className: "toolbar-item",
          "aria-label": "Redo",
          children: /* @__PURE__ */ p("i", { className: "format redo" })
        }
      ),
      /* @__PURE__ */ p(cy, {}),
      o === i && /* @__PURE__ */ B(Lt, { children: [
        /* @__PURE__ */ p(
          iR,
          {
            editorRef: t,
            blockMarker: a,
            disabled: e
          }
        ),
        /* @__PURE__ */ p(cy, {})
      ] }),
      /* @__PURE__ */ p("div", { ref: r, className: "end-container" })
    ] })
  ] });
}), uy = {
  namespace: "platformEditor",
  theme: Xx,
  editable: !0,
  editorState: void 0,
  // Handling of errors during update
  onError(t) {
    throw t;
  },
  nodes: [nn, ...kO]
}, cR = Og(), uR = {}, dR = {};
function fR() {
  return /* @__PURE__ */ p("div", { className: "editor-placeholder", children: "Enter some Scripture..." });
}
const Qx = Yn(function({
  defaultUsj: t,
  scrRef: e,
  onScrRefChange: n,
  onSelectionChange: r,
  onUsjChange: i,
  onStateChange: o,
  options: s,
  logger: a,
  children: l
}, c) {
  const u = ye(null), f = ye(null), d = ye(null), h = ye(t), g = ye(), [w, b] = ue(t), [_, y] = ue(0), {
    isReadonly: C = !1,
    hasExternalUI: D = !1,
    hasSpellCheck: P = !1,
    textDirection: S = "ltr",
    markerMenuTrigger: L = "\\",
    view: O = cR,
    nodes: M = uR,
    debug: F = !1
  } = s ?? dR;
  uy.editable = !C, _f.initialize(a), Kh(c, () => ({
    focus() {
      var I;
      (I = u.current) == null || I.focus();
    },
    undo() {
      var I;
      (I = u.current) == null || I.dispatchCommand(Ol, void 0);
    },
    redo() {
      var I;
      (I = u.current) == null || I.dispatchCommand(Il, void 0);
    },
    cut() {
      var I;
      (I = u.current) == null || I.dispatchCommand(ts, null);
    },
    copy() {
      var I;
      (I = u.current) == null || I.dispatchCommand(Qi, null);
    },
    paste() {
      u.current && Ag(u.current);
    },
    pastePlainText() {
      u.current && Dg(u.current);
    },
    getUsj() {
      return h.current;
    },
    setUsj(I) {
      if (!ui(h.current, I)) {
        h.current = I;
        const N = ui(w, I);
        b(I), N && y((R) => R + 1);
      }
    },
    applyUpdate(I, N = "remote") {
      var R, T;
      (R = u.current) == null || R.update(
        () => {
          N === "remote" && ev(Mh), WO(I, O, M, a);
        },
        { discrete: !0 }
      );
      const A = (T = u.current) == null ? void 0 : T.getEditorState();
      if (!A) return;
      const q = _f.deserializeEditorState(A);
      if (q) {
        const V = !ui(h.current, q);
        if (V && (h.current = q), V || !ui(w, q)) {
          const J = Bb(I, A);
          i == null || i(q, I, N, J);
        }
      }
    },
    replaceEmbedUpdate(I, N) {
      var R;
      const T = (R = u.current) == null ? void 0 : R.read(() => nO(I, N));
      T && this.applyUpdate(T);
    },
    getSelection() {
      var I;
      return (I = u.current) == null ? void 0 : I.read(Dx);
    },
    setSelection(I) {
      var N;
      (N = u.current) == null || N.update(
        () => {
          const R = _g(I);
          R !== void 0 && sn(R);
        },
        { tag: ox }
      );
    },
    addAnnotation(I, N, R) {
      var T;
      (T = f.current) == null || T.addAnnotation(I, Mb(N), R);
    },
    removeAnnotation(I, N) {
      var R;
      (R = f.current) == null || R.removeAnnotation(Mb(I), N);
    },
    formatPara(I) {
      var N;
      (N = u.current) == null || N.update(() => {
        const R = oe();
        Z(R) && AE(R, () => Cl(I));
      });
    },
    getElementByKey(I) {
      var N;
      return (N = u.current) == null ? void 0 : N.read(
        () => {
          var R;
          return ((R = u.current) == null ? void 0 : R.getElementByKey(I)) ?? void 0;
        }
      );
    },
    insertNote(I, N, R) {
      var T;
      (T = u.current) == null || T.update(() => {
        const A = jM(
          I,
          N,
          R,
          e,
          O,
          M,
          a
        );
        A && !A.getIsCollapsed() && (g.current = A.getKey());
      });
    },
    selectNote(I) {
      var N;
      (N = u.current) == null || N.update(() => {
        const R = $b(I);
        R && (zM(R, O), R.getIsCollapsed() || (g.current = R.getKey()));
      });
    },
    getNoteOps(I) {
      var N;
      return (N = u.current) == null ? void 0 : N.read(() => {
        const R = $b(I);
        if (R)
          return Eg(R);
      });
    },
    get toolbarEndRef() {
      return d;
    }
  }));
  const k = be(
    (I, N, R, T) => {
      if (VD.some((q) => R.has(q))) return;
      const A = _f.deserializeEditorState(I);
      if (A) {
        const q = !ui(h.current, A);
        if (q && (h.current = A), q || !ui(w, A)) {
          const V = R.has(Mh) ? "remote" : "local", J = Bb(T, I);
          i == null || i(A, T, V, J);
        }
      }
    },
    [w, i]
  );
  return /* @__PURE__ */ B(Hv, { initialConfig: uy, children: [
    /* @__PURE__ */ p(k5, { isEditable: !C }),
    /* @__PURE__ */ B("div", { className: "editor-container", children: [
      D ? /* @__PURE__ */ p(Kx, { onStateChange: o }) : /* @__PURE__ */ p("div", { className: "editor-toolbar-container" + (C ? "-readonly" : "-editable"), children: /* @__PURE__ */ p(
        lR,
        {
          ref: d,
          editorRef: c,
          isReadonly: C,
          onStateChange: o
        }
      ) }),
      /* @__PURE__ */ B("div", { className: "editor-inner", children: [
        /* @__PURE__ */ p(Xv, { editorRef: u }),
        /* @__PURE__ */ p(
          LS,
          {
            contentEditable: /* @__PURE__ */ p(
              Jv,
              {
                className: `editor-input usfm ${sI(O).join(" ")}`,
                spellCheck: P
              }
            ),
            placeholder: /* @__PURE__ */ p(fR, {}),
            ErrorBoundary: Yv
          }
        ),
        /* @__PURE__ */ p(Qv, {}),
        e && n && /* @__PURE__ */ p(YI, { scrRef: e, onScrRefChange: n }),
        e && /* @__PURE__ */ p(
          X5,
          {
            trigger: L,
            scrRef: e,
            getMarkerAction: (I, N) => UI(I, g, N, O)
          }
        ),
        /* @__PURE__ */ p(
          XI,
          {
            options: { view: O, nodes: M },
            editedUsjRef: h,
            usj: w,
            setUsj: b
          }
        ),
        /* @__PURE__ */ p(
          E5,
          {
            scripture: w,
            nodeOptions: M,
            editorAdaptor: Bh,
            viewOptions: O,
            logger: a
          },
          _
        ),
        /* @__PURE__ */ p(F5, { onChange: r }),
        /* @__PURE__ */ p(
          HO,
          {
            onChange: k,
            ignoreSelectionChange: !0,
            ignoreHistoryMergeTagChange: !0
          }
        ),
        /* @__PURE__ */ p(VO, { ref: f, logger: a }),
        /* @__PURE__ */ p(c5, { viewOptions: O }),
        /* @__PURE__ */ p(g5, {}),
        /* @__PURE__ */ p(b5, {}),
        /* @__PURE__ */ p(y5, { logger: a }),
        /* @__PURE__ */ p(C5, {}),
        /* @__PURE__ */ p(
          N5,
          {
            expandedNoteKeyRef: g,
            nodeOptions: M,
            viewOptions: O,
            logger: a
          }
        ),
        /* @__PURE__ */ p(B5, {}),
        /* @__PURE__ */ p(U5, { textDirection: S }),
        /* @__PURE__ */ p(H5, {}),
        l
      ] }),
      F && /* @__PURE__ */ p(eR, {})
    ] })
  ] });
}), hR = Yn(function(t, e) {
  const { children: n, ...r } = t;
  return /* @__PURE__ */ p(Qx, { ref: e, ...r });
});
function Zx() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function Du(t, e, n, r, i) {
  return {
    author: e,
    content: t,
    deleted: i === void 0 ? !1 : i,
    id: n === void 0 ? Zx() : n,
    timeStamp: r === void 0 ? performance.timeOrigin + performance.now() : r,
    type: "comment"
  };
}
function e2(t, e, n) {
  return {
    comments: e,
    id: n === void 0 ? Zx() : n,
    quote: t,
    type: "thread"
  };
}
function dy(t) {
  return {
    comments: Array.from(t.comments),
    id: t.id,
    quote: t.quote,
    type: "thread"
  };
}
function pR(t) {
  return {
    author: t.author,
    content: "[Deleted Comment]",
    deleted: !0,
    id: t.id,
    timeStamp: t.timeStamp,
    type: "comment"
  };
}
function xf(t) {
  const e = t._changeListeners;
  for (const n of e)
    n();
}
class gR {
  /**
   * Creates a new CommentStore instance.
   *
   * @param editor - The LexicalEditor instance.
   * @param logger - Optional logger instance.
   */
  constructor(e, n) {
    me(this, "_editor"), me(this, "_comments"), me(this, "_changeListeners"), me(this, "_collabProvider"), me(this, "logger"), this._comments = [], this._editor = e, this.logger = n, this._collabProvider = null, this._changeListeners = /* @__PURE__ */ new Set();
  }
  /**
   * Checks if collaborative editing is enabled.
   *
   * @returns True if collaborative editing is enabled, false otherwise.
   */
  isCollaborative() {
    return this._collabProvider !== null;
  }
  /**
   * Gets the current list of comments and threads.
   *
   * @returns The Comments array.
   */
  getComments() {
    return this._comments;
  }
  /**
   * Sets the list of comments and threads.
   *
   * @param comments - The new Comments array.
   */
  setComments(e) {
    this._comments = e, xf(this);
  }
  /**
   * Adds a comment or thread to the store.
   *
   * @param commentOrThread - The comment or thread to add.
   * @param thread - Optional parent thread to add the comment to.
   * @param offset - Optional offset for insertion.
   */
  addComment(e, n, r) {
    const i = Array.from(this._comments), o = this._getCollabComments();
    if (n !== void 0 && e.type === "comment")
      for (let s = 0; s < i.length; s++) {
        const a = i[s];
        if (a.type === "thread" && a.id === n.id) {
          const l = dy(a);
          i.splice(s, 1, l);
          const c = r !== void 0 ? r : l.comments.length;
          if (this.isCollaborative() && o !== null) {
            const u = o.get(s).get("comments");
            this._withRemoteTransaction(() => {
              const f = this._createCollabSharedMap(e);
              u.insert(c, [f]);
            });
          }
          l.comments.splice(c, 0, e);
          break;
        }
      }
    else {
      const s = r !== void 0 ? r : i.length;
      this.isCollaborative() && o !== null && this._withRemoteTransaction(() => {
        const a = this._createCollabSharedMap(e);
        o.insert(s, [a]);
      }), i.splice(s, 0, e);
    }
    this._comments = i, xf(this);
  }
  /**
   * Deletes a comment or thread from the store.
   *
   * @param commentOrThread - The comment or thread to delete.
   * @param thread - Optional parent thread if deleting a comment within a thread.
   * @returns An object containing the marked comment and its index, or null.
   */
  deleteCommentOrThread(e, n) {
    const r = Array.from(this._comments), i = this._getCollabComments();
    let o = null;
    if (n !== void 0)
      for (let s = 0; s < r.length; s++) {
        const a = r[s];
        if (a.type === "thread" && a.id === n.id) {
          const l = dy(a);
          r.splice(s, 1, l);
          const c = l.comments;
          if (o = c.indexOf(e), this.isCollaborative() && i !== null) {
            const u = i.get(s).get("comments"), f = o;
            this._withRemoteTransaction(() => {
              u.delete(f);
            });
          }
          c.splice(o, 1);
          break;
        }
      }
    else
      o = r.indexOf(e), this.isCollaborative() && i !== null && this._withRemoteTransaction(() => {
        i.delete(o);
      }), r.splice(o, 1);
    return this._comments = r, xf(this), e.type === "comment" ? {
      index: o,
      markedComment: pR(e)
    } : null;
  }
  /**
   * Registers a callback to be called when the comments change.
   *
   * @param onChange - The callback function.
   * @returns A function to unregister the callback.
   */
  registerOnChange(e) {
    const n = this._changeListeners;
    return n.add(e), () => {
      n.delete(e);
    };
  }
  _withRemoteTransaction(e) {
    const n = this._collabProvider;
    n !== null && n.doc.transact(e, this);
  }
  _withLocalTransaction(e) {
    const n = this._collabProvider;
    try {
      this._collabProvider = null, e();
    } finally {
      this._collabProvider = n;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _getCollabComments() {
    const e = this._collabProvider;
    return e !== null ? e.doc.get("comments", Do) : null;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _createCollabSharedMap(e) {
    const n = new Js(), r = e.type, i = e.id;
    if (n.set("type", r), n.set("id", i), r === "comment")
      n.set("author", e.author), n.set("content", e.content), n.set("deleted", e.deleted), n.set("timeStamp", e.timeStamp);
    else {
      n.set("quote", e.quote);
      const o = new Do();
      e.comments.forEach((s, a) => {
        const l = this._createCollabSharedMap(s);
        o.insert(a, [l]);
      }), n.set("comments", o);
    }
    return n;
  }
  /**
   * Registers collaborative editing support using a Yjs provider.
   *
   * @param provider - The Yjs Provider instance.
   * @returns A function to unregister collaboration and cleanup.
   */
  registerCollaboration(e) {
    this._collabProvider = e;
    const n = this._getCollabComments(), r = () => {
      e.connect();
    }, i = () => {
      try {
        e.disconnect();
      } catch {
      }
    }, o = this._editor.registerCommand(
      PD,
      (a) => {
        var l, c;
        return r !== void 0 && i !== void 0 && (a ? ((l = this.logger) == null || l.info("Comments connected!"), r()) : ((c = this.logger) == null || c.info("Comments disconnected!"), i())), !1;
      },
      rs
    ), s = (a, l) => {
      if (l.origin !== this) {
        for (const c of a)
          if (c instanceof K_) {
            const u = c.target, f = c.delta;
            let d = 0;
            for (const h of f) {
              const g = h.insert, w = h.retain, b = h.delete, _ = u.parent, y = u === n ? void 0 : _ instanceof Js && this._comments.find((C) => C.id === _.get("id"));
              if (Array.isArray(g)) {
                const C = d;
                g.slice().reverse().forEach((D) => {
                  const P = D.get("id"), S = D.get("type") === "thread" ? e2(
                    D.get("quote"),
                    D.get("comments").toArray().map(
                      (L) => Du(
                        L.get("content"),
                        L.get("author"),
                        L.get("id"),
                        L.get("timeStamp"),
                        L.get("deleted")
                      )
                    ),
                    P
                  ) : Du(
                    D.get("content"),
                    D.get("author"),
                    P,
                    D.get("timeStamp"),
                    D.get("deleted")
                  );
                  this._withLocalTransaction(() => {
                    this.addComment(S, y, C);
                  });
                });
              } else if (typeof w == "number")
                d += w;
              else if (typeof b == "number")
                for (let C = 0; C < b; C++) {
                  const D = y === void 0 || y === !1 ? this._comments[d] : y.comments[d];
                  this._withLocalTransaction(() => {
                    this.deleteCommentOrThread(D, y);
                  }), d++;
                }
            }
          }
      }
    };
    return n === null ? () => null : (n.observeDeep(s), r(), () => {
      n.unobserveDeep(s), o(), this._collabProvider = null;
    });
  }
}
function wR(t) {
  const [e, n] = ue(t.getComments());
  return de(() => t.registerOnChange(() => {
    n(t.getComments());
  }), [t]), e;
}
function mR({
  onClose: t,
  children: e,
  title: n,
  closeOnClickOutside: r
}) {
  const i = ye(null);
  return de(() => {
    i.current !== null && i.current.focus();
  }, []), de(() => {
    let o = null;
    const s = (c) => {
      c.key === "Escape" && t();
    }, a = (c) => {
      const u = c.target;
      i.current !== null && !i.current.contains(u) && r && t();
    }, l = i.current;
    return l !== null && (o = l.parentElement, o !== null && o.addEventListener("click", a)), window.addEventListener("keydown", s), () => {
      window.removeEventListener("keydown", s), o !== null && (o == null || o.removeEventListener("click", a));
    };
  }, [r, t]), /* @__PURE__ */ p("div", { className: "Modal__overlay", role: "dialog", children: /* @__PURE__ */ B("div", { className: "Modal__modal", tabIndex: -1, ref: i, children: [
    /* @__PURE__ */ p("h2", { className: "Modal__title", children: n }),
    /* @__PURE__ */ p(
      "button",
      {
        className: "Modal__closeButton",
        "aria-label": "Close modal",
        type: "button",
        onClick: t,
        children: "X"
      }
    ),
    /* @__PURE__ */ p("div", { className: "Modal__content", children: e })
  ] }) });
}
function bR({
  onClose: t,
  children: e,
  title: n,
  closeOnClickOutside: r = !1
}) {
  return fi(
    /* @__PURE__ */ p(mR, { onClose: t, title: n, closeOnClickOutside: r, children: e }),
    document.body
  );
}
function t2() {
  const [t, e] = ue(null), n = be(() => {
    e(null);
  }, []), r = Ne(() => {
    if (t === null)
      return null;
    const { title: o, content: s, closeOnClickOutside: a } = t;
    return /* @__PURE__ */ p(bR, { onClose: n, title: o, closeOnClickOutside: a, children: s });
  }, [t, n]), i = be(
    (o, s, a = !1) => {
      e({
        closeOnClickOutside: a,
        content: s(n),
        title: o
      });
    },
    [n]
  );
  return [r, i];
}
const yR = {
  ...Xx,
  paragraph: "CommentEditorTheme__paragraph"
};
function vR(...t) {
  return t.filter(Boolean).join(" ");
}
function Ji({
  "data-test-id": t,
  children: e,
  className: n,
  onClick: r,
  disabled: i,
  small: o,
  title: s
}) {
  return /* @__PURE__ */ p(
    "button",
    {
      disabled: i,
      className: vR(
        "Button__root",
        i && "Button__disabled",
        o && "Button__small",
        n
      ),
      onClick: r,
      title: s,
      "aria-label": s,
      ...t && { "data-test-id": t },
      children: e
    }
  );
}
function _R({
  className: t
}) {
  return /* @__PURE__ */ p(Jv, { className: t || "ContentEditable__root" });
}
function xR({
  children: t,
  className: e
}) {
  return /* @__PURE__ */ p("div", { className: e || "Placeholder__root", children: t });
}
const fy = Se("INSERT_INLINE_COMMAND");
function CR({
  anchorKey: t,
  editor: e,
  showComments: n,
  onAddComment: r
}) {
  const i = ye(null), o = be(() => {
    const s = i.current, a = e.getRootElement(), l = e.getElementByKey(t);
    if (s !== null && a !== null && l !== null) {
      const { right: c } = a.getBoundingClientRect(), { top: u } = l.getBoundingClientRect();
      s.style.left = `${c - 20}px`, s.style.top = `${u - 30}px`;
    }
  }, [t, e]);
  return de(() => (window.addEventListener("resize", o), () => {
    window.removeEventListener("resize", o);
  }), [e, o]), kn(() => {
    o();
  }, [t, e, n, o]), /* @__PURE__ */ p("div", { className: "CommentPlugin_AddCommentBox", ref: i, children: /* @__PURE__ */ p("button", { className: "CommentPlugin_AddCommentBox_button", onClick: r, children: /* @__PURE__ */ p("i", { className: "icon add-comment" }) }) });
}
function kR({ onEscape: t }) {
  const [e] = Le();
  return de(() => e.registerCommand(
    Vu,
    (n) => t(n),
    Ic
  ), [e, t]), null;
}
function n2({
  className: t,
  autoFocus: e,
  onEscape: n,
  onChange: r,
  editorRef: i,
  placeholder: o = "Type a comment..."
}) {
  return /* @__PURE__ */ p(Hv, { initialConfig: {
    namespace: "Commenting",
    nodes: [],
    onError: (s) => {
      throw s;
    },
    theme: yR
  }, children: /* @__PURE__ */ B("div", { className: "CommentPlugin_CommentInputBox_EditorContainer", children: [
    /* @__PURE__ */ p(
      VT,
      {
        contentEditable: /* @__PURE__ */ p(_R, { className: t }),
        placeholder: /* @__PURE__ */ p(xR, { children: o }),
        ErrorBoundary: Yv
      }
    ),
    /* @__PURE__ */ p($T, { onChange: r }),
    /* @__PURE__ */ p(Qv, {}),
    e !== !1 && /* @__PURE__ */ p(OT, {}),
    /* @__PURE__ */ p(kR, { onEscape: n }),
    /* @__PURE__ */ p(RT, {}),
    i !== void 0 && /* @__PURE__ */ p(Xv, { editorRef: i })
  ] }) });
}
function r2(t, e) {
  return be(
    (n, r) => {
      n.read(() => {
        t(Kv()), e(!Wv(r.isComposing(), !0));
      });
    },
    [e, t]
  );
}
function ER({
  editor: t,
  cancelAddComment: e,
  submitAddComment: n
}) {
  const [r, i] = ue(""), [o, s] = ue(!1), a = ye(null), l = Ne(
    () => ({
      container: document.createElement("div"),
      elements: []
    }),
    []
  ), c = ye(null), u = o2(), f = be(() => {
    t.getEditorState().read(() => {
      const w = oe();
      if (Z(w)) {
        c.current = w.clone();
        const b = w.anchor, _ = w.focus, y = kE(
          t,
          b.getNode(),
          b.offset,
          _.getNode(),
          _.offset
        ), C = a.current;
        if (y !== null && C !== null) {
          const { left: D, bottom: P, width: S } = y.getBoundingClientRect(), L = EE(t, y);
          let O = L.length === 1 ? D + S / 2 - 125 : D - 125;
          O < 10 && (O = 10), C.style.left = `${O}px`, C.style.top = `${P + 20 + (window.pageYOffset || document.documentElement.scrollTop)}px`;
          const M = L.length, { container: F } = l, k = l.elements, I = k.length;
          for (let N = 0; N < M; N++) {
            const R = L[N];
            let T = k[N];
            T === void 0 && (T = document.createElement("span"), k[N] = T, F.appendChild(T));
            const A = `position:absolute;top:${R.top + (window.pageYOffset || document.documentElement.scrollTop)}px;left:${R.left}px;height:${R.height}px;width:${R.width}px;background-color:rgba(255, 212, 0, 0.3);pointer-events:none;z-index:5;`;
            T.style.cssText = A;
          }
          for (let N = I - 1; N >= M; N--) {
            const R = k[N];
            F.removeChild(R), k.pop();
          }
        }
      }
    });
  }, [t, l]);
  kn(() => {
    f();
    const w = l.container, b = document.body;
    return b !== null ? (b.appendChild(w), () => {
      b.removeChild(w);
    }) : () => {
    };
  }, [l.container, f]), de(() => (window.addEventListener("resize", f), () => {
    window.removeEventListener("resize", f);
  }), [f]);
  const d = (w) => (w.preventDefault(), e(), !0), h = () => {
    if (o) {
      let w = t.getEditorState().read(() => {
        const b = c.current;
        return b ? b.getTextContent() : "";
      });
      w.length > 100 && (w = w.slice(0, 99) + "â€¦"), n(
        e2(w, [Du(r, u)]),
        !0,
        void 0,
        c.current
      ), c.current = null;
    }
  }, g = r2(i, s);
  return /* @__PURE__ */ B("div", { className: "CommentPlugin_CommentInputBox", ref: a, children: [
    /* @__PURE__ */ p(
      n2,
      {
        className: "CommentPlugin_CommentInputBox_Editor",
        onEscape: d,
        onChange: g
      }
    ),
    /* @__PURE__ */ B("div", { className: "CommentPlugin_CommentInputBox_Buttons", children: [
      /* @__PURE__ */ p(Ji, { onClick: e, className: "CommentPlugin_CommentInputBox_Button", children: "Cancel" }),
      /* @__PURE__ */ p(
        Ji,
        {
          onClick: h,
          disabled: !o,
          className: "CommentPlugin_CommentInputBox_Button primary",
          children: "Comment"
        }
      )
    ] })
  ] });
}
function NR({
  submitAddComment: t,
  thread: e,
  placeholder: n
}) {
  const [r, i] = ue(""), [o, s] = ue(!1), a = ye(null), l = o2(), c = r2(i, s);
  return /* @__PURE__ */ B(Lt, { children: [
    /* @__PURE__ */ p(
      n2,
      {
        className: "CommentPlugin_CommentsPanel_Editor",
        autoFocus: !1,
        onEscape: () => !0,
        onChange: c,
        editorRef: a,
        placeholder: n
      }
    ),
    /* @__PURE__ */ p(
      Ji,
      {
        className: "CommentPlugin_CommentsPanel_SendButton",
        onClick: () => {
          if (o) {
            t(Du(r, l), !1, e);
            const u = a.current;
            u !== null && u.dispatchCommand(_p, void 0);
          }
        },
        disabled: !o,
        children: /* @__PURE__ */ p("i", { className: "send" })
      }
    )
  ] });
}
function i2({
  commentOrThread: t,
  deleteCommentOrThread: e,
  onClose: n,
  thread: r = void 0
}) {
  return /* @__PURE__ */ B(Lt, { children: [
    "Are you sure you want to delete this ",
    t.type,
    "?",
    /* @__PURE__ */ B("div", { className: "Modal__content", children: [
      /* @__PURE__ */ p(
        Ji,
        {
          onClick: () => {
            e(t, r), n();
          },
          children: "Delete"
        }
      ),
      " ",
      /* @__PURE__ */ p(
        Ji,
        {
          onClick: () => {
            n();
          },
          children: "Cancel"
        }
      )
    ] })
  ] });
}
function hy({
  comment: t,
  deleteComment: e,
  thread: n,
  rtf: r
}) {
  const i = Math.round(
    (t.timeStamp - (performance.timeOrigin + performance.now())) / 1e3
  ), o = Math.round(i / 60), [s, a] = t2();
  return /* @__PURE__ */ B("li", { className: "CommentPlugin_CommentsPanel_List_Comment", children: [
    /* @__PURE__ */ B("div", { className: "CommentPlugin_CommentsPanel_List_Details", children: [
      /* @__PURE__ */ p("span", { className: "CommentPlugin_CommentsPanel_List_Comment_Author", children: t.author }),
      /* @__PURE__ */ B("span", { className: "CommentPlugin_CommentsPanel_List_Comment_Time", children: [
        "Â· ",
        i > -10 ? "Just now" : r.format(o, "minute")
      ] })
    ] }),
    /* @__PURE__ */ p("p", { className: t.deleted ? "CommentPlugin_CommentsPanel_DeletedComment" : "", children: t.content }),
    !t.deleted && /* @__PURE__ */ B(Lt, { children: [
      /* @__PURE__ */ p(
        Ji,
        {
          onClick: () => {
            a("Delete Comment", (l) => /* @__PURE__ */ p(
              i2,
              {
                commentOrThread: t,
                deleteCommentOrThread: e,
                thread: n,
                onClose: l
              }
            ));
          },
          className: "CommentPlugin_CommentsPanel_List_DeleteButton",
          children: /* @__PURE__ */ p("i", { className: "delete" })
        }
      ),
      s
    ] })
  ] });
}
function SR({
  activeIDs: t,
  comments: e,
  deleteCommentOrThread: n,
  listRef: r,
  submitAddComment: i,
  markNodeMap: o
}) {
  const [s] = Le(), [a, l] = ue(0), [c, u] = t2(), f = Ne(
    () => new Intl.RelativeTimeFormat("en", {
      localeMatcher: "best fit",
      numeric: "auto",
      style: "short"
    }),
    []
  );
  return de(() => {
    const d = setTimeout(() => {
      l(a + 1);
    }, 1e4);
    return () => {
      clearTimeout(d);
    };
  }, [a]), /* @__PURE__ */ p("ul", { className: "CommentPlugin_CommentsPanel_List", ref: r, children: e.map((d) => {
    const h = d.id;
    return d.type === "thread" ? /* @__PURE__ */ B(
      "li",
      {
        onClick: () => {
          const g = o.get(h);
          if (g !== void 0 && (t === null || t.indexOf(h) === -1)) {
            const w = document.activeElement;
            s.update(
              () => {
                const b = Array.from(g)[0], _ = Oe(b);
                on(_) && _.selectStart();
              },
              {
                onUpdate() {
                  w !== null && w.focus();
                }
              }
            );
          }
        },
        className: `CommentPlugin_CommentsPanel_List_Thread ${o.has(h) ? "interactive" : ""} ${t.indexOf(h) === -1 ? "" : "active"}`,
        children: [
          /* @__PURE__ */ B("div", { className: "CommentPlugin_CommentsPanel_List_Thread_QuoteBox", children: [
            /* @__PURE__ */ B("blockquote", { className: "CommentPlugin_CommentsPanel_List_Thread_Quote", children: [
              "> ",
              /* @__PURE__ */ p("span", { children: d.quote })
            ] }),
            /* @__PURE__ */ p(
              Ji,
              {
                onClick: () => {
                  u("Delete Thread", (g) => /* @__PURE__ */ p(
                    i2,
                    {
                      commentOrThread: d,
                      deleteCommentOrThread: n,
                      onClose: g
                    }
                  ));
                },
                className: "CommentPlugin_CommentsPanel_List_DeleteButton",
                children: /* @__PURE__ */ p("i", { className: "delete" })
              }
            ),
            c
          ] }),
          /* @__PURE__ */ p("ul", { className: "CommentPlugin_CommentsPanel_List_Thread_Comments", children: d.comments.map((g) => /* @__PURE__ */ p(
            hy,
            {
              comment: g,
              deleteComment: n,
              thread: d,
              rtf: f
            },
            g.id
          )) }),
          /* @__PURE__ */ p("div", { className: "CommentPlugin_CommentsPanel_List_Thread_Editor", children: /* @__PURE__ */ p(
            NR,
            {
              submitAddComment: i,
              thread: d,
              placeholder: "Reply to comment..."
            }
          ) })
        ]
      },
      h
    ) : /* @__PURE__ */ p(
      hy,
      {
        comment: d,
        deleteComment: n,
        rtf: f
      },
      h
    );
  }) });
}
function TR({
  activeIDs: t,
  deleteCommentOrThread: e,
  comments: n,
  submitAddComment: r,
  markNodeMap: i
}) {
  const o = ye(null), s = n.length === 0;
  return /* @__PURE__ */ B("div", { className: "CommentPlugin_CommentsPanel", children: [
    /* @__PURE__ */ p("h2", { className: "CommentPlugin_CommentsPanel_Heading", children: "Comments" }),
    s ? /* @__PURE__ */ p("div", { className: "CommentPlugin_CommentsPanel_Empty", children: "No Comments" }) : /* @__PURE__ */ p(
      SR,
      {
        activeIDs: t,
        comments: n,
        deleteCommentOrThread: e,
        listRef: o,
        submitAddComment: r,
        markNodeMap: i
      }
    )
  ] });
}
function o2() {
  const t = h_(), { yjsDocMap: e, name: n } = t;
  return e.has("comments") ? n : "Scripture User";
}
function AR({
  providerFactory: t,
  setCommentStore: e,
  onChange: n,
  showCommentsContainerRef: r,
  commentContainerRef: i,
  logger: o
}) {
  const s = h_(), [a] = Le(), l = Ne(() => {
    const O = new gR(a, o);
    return n && O.registerOnChange(n), e == null || e(O), O;
  }, [a, o, n, e]), c = wR(l), u = Ne(() => /* @__PURE__ */ new Map(), []), [f, d] = ue(), [h, g] = ue([]), [w, b] = ue(!1), [_, y] = ue(!1), { yjsDocMap: C } = s;
  de(() => {
    if (t) {
      const O = t("comments", C);
      return l.registerCollaboration(O);
    }
    return () => {
    };
  }, [l, t, C]);
  const D = be(() => {
    a.update(() => {
      const O = oe();
      O !== null && (O.dirty = !0);
    }), b(!1);
  }, [a]), P = be(
    (O, M) => {
      if (O.type === "comment") {
        const F = l.deleteCommentOrThread(O, M);
        if (!F)
          return;
        const { markedComment: k, index: I } = F;
        l.addComment(k, M, I);
      } else {
        l.deleteCommentOrThread(O);
        const F = M !== void 0 ? M.id : O.id, k = u.get(F);
        k !== void 0 && setTimeout(() => {
          a.update(() => {
            for (const I of k) {
              const N = Oe(I);
              on(N) && (N.deleteID($i, F), N.hasNoIDsForEveryType() && Ex(N));
            }
          });
        });
      }
    },
    [l, a, u]
  ), S = be(
    (O, M, F, k) => {
      l.addComment(O, F), M && (a.update(() => {
        Z(k) && Nx(k, $i, O.id);
      }), b(!1));
    },
    [l, a]
  );
  de(() => {
    const O = [];
    for (const M of h) {
      const F = u.get(M);
      if (F !== void 0)
        for (const k of F) {
          const I = a.getElementByKey(k);
          I !== null && (I.classList.add("selected"), O.push(I), y(!0));
        }
    }
    return () => {
      for (const M of O)
        M.classList.remove("selected");
    };
  }, [h, a, u]), de(() => {
    if (!a.hasNodes([nn]))
      throw new Error("CommentPlugin: TypedMarkNode not registered on editor!");
    const O = /* @__PURE__ */ new Map();
    return Ht(
      fv(
        a,
        nn,
        (M) => kl(M.getTypedIDs()),
        (M, F) => {
          for (const [k, I] of Object.entries(M.getTypedIDs()))
            I.forEach((N) => {
              F.addID(k, N);
            });
        }
      ),
      a.registerMutationListener(
        nn,
        (M) => {
          a.getEditorState().read(() => {
            for (const [F, k] of M) {
              const I = Oe(F);
              let N = [];
              k === "destroyed" ? N = O.get(F) ?? [] : on(I) && (N = I.getTypedIDs()[$i] ?? []);
              for (const R of N) {
                let T = u.get(R);
                O.set(F, N), k === "destroyed" ? T !== void 0 && (T.delete(F), T.size === 0 && u.delete(R)) : (T === void 0 && (T = /* @__PURE__ */ new Set(), u.set(R, T)), T.has(F) || T.add(F));
              }
            }
          });
        },
        { skipInitialization: !1 }
      ),
      a.registerUpdateListener(({ editorState: M, tags: F }) => {
        M.read(() => {
          const k = oe();
          let I = !1, N = !1;
          if (Z(k)) {
            const R = k.anchor.getNode();
            if (ie(R)) {
              const T = TM(R, $i, k.anchor.offset) ?? [];
              T !== null && (g(T), I = !0), k.isCollapsed() || (d(R.getKey()), N = !0);
            }
          }
          I || g((R) => R.length === 0 ? R : []), N || d(null), !F.has("collaboration") && Z(k) && b(!1);
        });
      }),
      a.registerCommand(
        fy,
        () => {
          const M = window.getSelection();
          return M !== null && M.removeAllRanges(), b(!0), !0;
        },
        ke
      )
    );
  }, [a, u]);
  const L = () => {
    a.dispatchCommand(fy, void 0);
  };
  return /* @__PURE__ */ B(Lt, { children: [
    w && fi(
      /* @__PURE__ */ p(
        ER,
        {
          editor: a,
          cancelAddComment: D,
          submitAddComment: S
        }
      ),
      document.body
    ),
    f != null && !w && fi(
      /* @__PURE__ */ p(
        CR,
        {
          anchorKey: f,
          editor: a,
          showComments: _,
          onAddComment: L
        }
      ),
      document.body
    ),
    r !== null && fi(
      /* @__PURE__ */ p(
        Ji,
        {
          className: `CommentPlugin_ShowCommentsButton ${_ ? "active" : ""}`,
          onClick: () => y(!_),
          title: _ ? "Hide Comments" : "Show Comments",
          children: /* @__PURE__ */ p("i", { className: "comments" })
        }
      ),
      (r == null ? void 0 : r.current) ?? document.body
    ),
    _ && fi(
      /* @__PURE__ */ p(
        TR,
        {
          comments: c,
          submitAddComment: S,
          deleteCommentOrThread: P,
          activeIDs: h,
          markNodeMap: u
        }
      ),
      (i == null ? void 0 : i.current) ?? document.body
    )
  ] });
}
function DR() {
  const t = ye(void 0), e = be((n) => {
    t.current = n;
  }, []);
  return [t, e];
}
function MR(t, e) {
  var n, r;
  const i = ((n = e.current) == null ? void 0 : n.getComments()) ?? [], o = i == null ? void 0 : i.map((a) => a.id), s = t.map((a) => {
    const l = o.findIndex((c) => c === a);
    return l !== void 0 && l >= 0 ? i[l] : {
      comments: [
        {
          author: "unknown",
          content: "Comment not found",
          deleted: !1,
          id: "",
          timeStamp: 0,
          type: "comment"
        }
      ],
      id: a,
      quote: "",
      type: "thread"
    };
  });
  i.forEach((a) => {
    t.includes(a.id) || s.push(a);
  }), s && ((r = e.current) == null || r.setComments(s));
}
function OR(t, e) {
  de(() => {
    var n;
    t.options ?? (t.options = {}), (n = t.options).nodes ?? (n.nodes = {}), t.options.nodes.addMissingComments = (r) => {
      MR(r, e);
    };
  }, [e, t]);
}
Yn(function(t, e) {
  const n = ye(null), r = ye(!0), i = ye(null), [o, s] = ue(null), { children: a, onCommentChange: l, onUsjChange: c, showCommentsContainerRef: u, ...f } = t, { options: { isReadonly: d } = {} } = t, [h, g] = DR();
  OR(f, h), Kh(e, () => ({
    focus() {
      var _;
      (_ = n.current) == null || _.focus();
    },
    undo() {
      var _;
      (_ = n.current) == null || _.undo();
    },
    redo() {
      var _;
      (_ = n.current) == null || _.redo();
    },
    cut() {
      var _;
      (_ = n.current) == null || _.cut();
    },
    copy() {
      var _;
      (_ = n.current) == null || _.copy();
    },
    paste() {
      var _;
      (_ = n.current) == null || _.paste();
    },
    pastePlainText() {
      var _;
      (_ = n.current) == null || _.pastePlainText();
    },
    getUsj() {
      var _;
      return (_ = n.current) == null ? void 0 : _.getUsj();
    },
    setUsj(_) {
      var y;
      (y = n.current) == null || y.setUsj(_);
    },
    applyUpdate(_, y) {
      var C;
      (C = n.current) == null || C.applyUpdate(_, y);
    },
    replaceEmbedUpdate(_, y) {
      var C;
      return (C = n.current) == null ? void 0 : C.replaceEmbedUpdate(_, y);
    },
    getSelection() {
      var _;
      return (_ = n.current) == null ? void 0 : _.getSelection();
    },
    setSelection(_) {
      var y;
      (y = n.current) == null || y.setSelection(_);
    },
    addAnnotation(_, y, C) {
      var D;
      (D = n.current) == null || D.addAnnotation(_, y, C);
    },
    removeAnnotation(_, y) {
      var C;
      (C = n.current) == null || C.removeAnnotation(_, y);
    },
    formatPara(_) {
      var y;
      (y = n.current) == null || y.formatPara(_);
    },
    getElementByKey(_) {
      var y;
      return (y = n.current) == null ? void 0 : y.getElementByKey(_);
    },
    insertNote(_, y, C) {
      var D;
      (D = n.current) == null || D.insertNote(_, y, C);
    },
    selectNote(_) {
      var y;
      (y = n.current) == null || y.selectNote(_);
    },
    getNoteOps(_) {
      var y;
      return (y = n.current) == null ? void 0 : y.getNoteOps(_);
    },
    setComments(_) {
      var y;
      (y = h.current) == null || y.setComments(_), r.current = !0;
    },
    get toolbarEndRef() {
      return o;
    }
  }));
  const w = be(
    (_, y, C, D) => {
      var P;
      if (!c) return;
      const S = (P = h.current) == null ? void 0 : P.getComments();
      c(_, S, y, C, D);
    },
    [h, c]
  ), b = be(() => {
    var _;
    if (!l || r.current) {
      r.current = !1;
      return;
    }
    const y = (_ = h.current) == null ? void 0 : _.getComments();
    l(y);
  }, [h, r, l]);
  return de(() => {
    var _;
    return s(((_ = n.current) == null ? void 0 : _.toolbarEndRef) ?? null), () => s(null);
  }, []), /* @__PURE__ */ B(Qx, { ref: n, onUsjChange: w, ...f, children: [
    /* @__PURE__ */ p(
      AR,
      {
        setCommentStore: g,
        onChange: b,
        showCommentsContainerRef: d ? null : u ?? o,
        commentContainerRef: i,
        logger: f.logger
      }
    ),
    /* @__PURE__ */ p("div", { ref: i, className: "comment-container" })
  ] });
});
const Ca = Y.forwardRef(
  ({ className: t, type: e, ...n }, r) => /* @__PURE__ */ p(
    "input",
    {
      type: e,
      className: G(
        "pr-twp tw-flex tw-h-10 tw-rounded-md tw-border tw-border-input tw-bg-background tw-px-3 tw-py-2 tw-text-sm tw-ring-offset-background file:tw-border-0 file:tw-bg-transparent file:tw-text-sm file:tw-font-medium file:tw-text-foreground placeholder:tw-text-muted-foreground focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-cursor-not-allowed disabled:tw-opacity-50",
        t
      ),
      ref: r,
      ...n
    }
  )
);
Ca.displayName = "Input";
const WL = Object.freeze([
  "%footnoteEditor_callerDropdown_label%",
  "%footnoteEditor_callerDropdown_item_generated%",
  "%footnoteEditor_callerDropdown_item_hidden%",
  "%footnoteEditor_callerDropdown_item_custom%",
  "%footnoteEditor_noteType_crossReference_label%",
  "%footnoteEditor_noteType_endNote_label%",
  "%footnoteEditor_noteType_footnote_label%"
]);
function GL({
  noteOps: t,
  onSave: e,
  onClose: n,
  scrRef: r,
  noteKey: i,
  viewOptions: o,
  localizedStrings: s
}) {
  const a = ye(null), l = z2(), c = ye(), [u, f] = ue("generated"), [d, h] = ue("generated"), [g, w] = ue("*"), [b, _] = ue(), y = Ne(
    () => ({
      isReadonly: !1,
      hasSpellCheck: !1,
      hasExternalUI: !0,
      // Might need to change this later
      textDirection: "auto",
      view: { ...o, noteMode: "expanded" }
    }),
    [o]
  );
  de(() => {
    var k, I;
    let F;
    return t && !((I = (k = a.current) == null ? void 0 : k.getUsj()) != null && I.content) && (F = setTimeout(() => {
      var A, q;
      (A = a.current) == null || A.setUsj(ip);
      const N = t, R = N[0].insert.note.caller;
      let T = "custom";
      R === ji ? T = "generated" : R === el ? T = "hidden" : w(R), f(T), h(T), _(N[0].insert.note.style), N[0].insert.note.caller = "", (q = a.current) == null || q.applyUpdate(N);
    }, 0)), () => {
      F && clearTimeout(F);
    };
  }, [t, i]);
  const C = () => {
    var k;
    const F = (k = a.current) == null ? void 0 : k.getNoteOps(0);
    if (F) {
      const I = F;
      u === "custom" ? I[0].insert.note.caller = g : I[0].insert.note.caller = u === "generated" ? ji : el, e(F);
    }
  }, D = (F, k) => {
    k && (c.current = k);
  }, P = () => {
    var k;
    const F = (k = l.current) == null ? void 0 : k.getElementsByClassName("editor-input")[0];
    F != null && F.textContent && navigator.clipboard.writeText(F.textContent);
  }, S = (F) => {
    F || (d !== "custom" || g ? f(d) : h(u));
  }, L = () => b === "f" ? /* @__PURE__ */ p(o1, {}) : b === "fe" ? /* @__PURE__ */ p(Hg, {}) : /* @__PURE__ */ p(s1, {}), O = (F) => {
    var k, I;
    if (_(F), c.current) {
      const N = c.current;
      (k = a.current) == null || k.applyUpdate([{ delete: 1 }]), N[0].insert.note.style = F, (I = a.current) == null || I.applyUpdate(N);
    }
  };
  return /* @__PURE__ */ B("div", { className: "footnote-editor tw-grid tw-gap-[12px]", children: [
    /* @__PURE__ */ B("div", { className: "tw-flex", children: [
      /* @__PURE__ */ B("div", { className: "tw-flex tw-gap-4", children: [
        /* @__PURE__ */ B(Os, { children: [
          /* @__PURE__ */ p(nl, { asChild: !0, children: /* @__PURE__ */ p(
            Me,
            {
              size: "icon",
              variant: "outline",
              className: "tw-h-6 tw-w-6 disabled:tw-pointer-events-auto",
              disabled: b === "x",
              title: b === "f" ? s["%footnoteEditor_noteType_footnote_label%"] : b === "fe" ? s["%footnoteEditor_noteType_endNote_label%"] : s["%footnoteEditor_noteType_crossReference_label%"],
              children: L()
            }
          ) }),
          b !== "x" && /* @__PURE__ */ p(Io, { className: "tw-z-[300]", children: /* @__PURE__ */ B(Pf, { value: b, onValueChange: O, children: [
            /* @__PURE__ */ B(bo, { value: "fe", className: "tw-gap-2", children: [
              /* @__PURE__ */ p(Me, { size: "icon", variant: "outline", className: "tw-h-6 tw-w-6", children: /* @__PURE__ */ p(Hg, {}) }),
              /* @__PURE__ */ p("span", { children: s["%footnoteEditor_noteType_footnote_label%"] })
            ] }),
            /* @__PURE__ */ B(bo, { value: "f", className: "tw-gap-2", children: [
              /* @__PURE__ */ p(Me, { size: "icon", variant: "outline", className: "tw-h-6 tw-w-6", children: /* @__PURE__ */ p(r1, {}) }),
              /* @__PURE__ */ p("span", { children: s["%footnoteEditor_noteType_endNote_label%"] })
            ] })
          ] }) })
        ] }),
        /* @__PURE__ */ B(Os, { onOpenChange: S, children: [
          /* @__PURE__ */ p(nl, { asChild: !0, children: /* @__PURE__ */ p(Me, { size: "icon", variant: "outline", className: "tw-h-6 tw-w-6", children: /* @__PURE__ */ p(i1, {}) }) }),
          /* @__PURE__ */ B(Io, { className: "tw-z-[300]", children: [
            /* @__PURE__ */ p($u, { children: s["%footnoteEditor_callerDropdown_label%"] }),
            /* @__PURE__ */ p(Ml, {}),
            /* @__PURE__ */ B(
              Pf,
              {
                value: d,
                onValueChange: (F) => h(F),
                children: [
                  /* @__PURE__ */ p(bo, { value: "generated", children: /* @__PURE__ */ B("div", { className: "tw-flex tw-w-full tw-justify-between", children: [
                    /* @__PURE__ */ p("span", { children: s["%footnoteEditor_callerDropdown_item_generated%"] }),
                    /* @__PURE__ */ p("span", { className: "tw-w-10 tw-text-center", children: ji })
                  ] }) }),
                  /* @__PURE__ */ p(bo, { value: "hidden", children: /* @__PURE__ */ B("div", { className: "tw-flex tw-w-full tw-justify-between", children: [
                    /* @__PURE__ */ p("span", { children: s["%footnoteEditor_callerDropdown_item_hidden%"] }),
                    /* @__PURE__ */ p("span", { className: "tw-w-10 tw-text-center", children: el })
                  ] }) }),
                  /* @__PURE__ */ p(bo, { onSelect: (F) => F.preventDefault(), value: "custom", children: /* @__PURE__ */ B("div", { className: "tw-flex tw-w-full tw-justify-between", children: [
                    /* @__PURE__ */ p("span", { children: s["%footnoteEditor_callerDropdown_item_custom%"] }),
                    /* @__PURE__ */ p(
                      Ca,
                      {
                        className: "tw-h-auto tw-w-10 tw-p-0 tw-text-center",
                        value: g,
                        maxLength: 1,
                        onChange: (F) => w(F.target.value)
                      }
                    )
                  ] }) })
                ]
              }
            )
          ] })
        ] })
      ] }),
      /* @__PURE__ */ B("div", { className: "tw-flex tw-w-full tw-justify-end tw-gap-4", children: [
        /* @__PURE__ */ p(Me, { onClick: n, className: "tw-h-6 tw-w-6", size: "icon", variant: "secondary", children: /* @__PURE__ */ p(Ou, {}) }),
        /* @__PURE__ */ p(Me, { onClick: C, className: "tw-h-6 tw-w-6", size: "icon", variant: "default", children: /* @__PURE__ */ p(xi, {}) })
      ] })
    ] }),
    /* @__PURE__ */ B(
      "div",
      {
        ref: l,
        className: "tw-relative tw-rounded-[6px] tw-border-2 tw-border-ring",
        children: [
          /* @__PURE__ */ p(
            hR,
            {
              options: y,
              onUsjChange: D,
              onScrRefChange: () => {
              },
              scrRef: r,
              ref: a
            }
          ),
          /* @__PURE__ */ p("div", { className: "tw-absolute tw-bottom-0 tw-right-0", children: /* @__PURE__ */ p(Me, { onClick: P, className: "tw-h-6 tw-w-6", variant: "ghost", size: "icon", children: /* @__PURE__ */ p(yy, {}) }) })
        ]
      }
    )
  ] });
}
function s2(t, e) {
  if (!e || e.length === 0) return t ?? "empty";
  const n = e.find((i) => typeof i == "string");
  if (n)
    return `key-${t ?? "unknown"}-${n.slice(0, 10)}`;
  const r = typeof e[0] == "string" ? "impossible" : e[0].marker ?? "unknown";
  return `key-${t ?? "unknown"}-${r}`;
}
function IR(t, e, n = !0, r = void 0) {
  if (!e || e.length === 0) return;
  const i = [], o = [];
  let s = [];
  return e.forEach((a) => {
    typeof a != "string" && a.marker === "fp" ? (s.length > 0 && o.push(s), s = [a]) : s.push(a);
  }), s.length > 0 && o.push(s), o.map((a, l) => {
    const c = l === o.length - 1;
    return /* @__PURE__ */ B("p", { className: "tw-mb-2", children: [
      Ig(t, a, n, !0, i),
      c && r
    ] }, s2(t, a));
  });
}
function Ig(t, e, n = !0, r = !0, i = []) {
  if (!(!e || e.length === 0))
    return e.map((o) => {
      if (typeof o == "string") {
        const s = `${t}-text-${o.slice(0, 10)}`;
        if (r) {
          const a = G(`usfm_${t}`);
          return /* @__PURE__ */ p("span", { className: a, children: o }, s);
        }
        return /* @__PURE__ */ B(
          "span",
          {
            className: "tw-inline-flex tw-items-center tw-gap-1 tw-underline tw-decoration-destructive",
            children: [
              /* @__PURE__ */ p(Tf, { className: "tw-h-4 tw-w-4 tw-fill-destructive" }),
              /* @__PURE__ */ p("span", { children: o }),
              /* @__PURE__ */ p(Tf, { className: "tw-h-4 tw-w-4 tw-fill-destructive" })
            ]
          },
          s
        );
      }
      return RR(
        o,
        s2(`${t}\\${o.marker}`, [o]),
        n,
        [...i, t ?? "unknown"]
      );
    });
}
function RR(t, e, n, r = []) {
  const { marker: i } = t;
  return /* @__PURE__ */ B("span", { children: [
    i ? n && /* @__PURE__ */ p("span", { className: "marker", children: `\\${i} ` }) : /* @__PURE__ */ p(
      Tf,
      {
        className: "tw-text-error tw-mr-1 tw-inline-block tw-h-4 tw-w-4",
        "aria-label": "Missing marker"
      }
    ),
    Ig(i, t.content, n, !0, [
      ...r,
      i ?? "unknown"
    ])
  ] }, e);
}
function PR({
  footnote: t,
  layout: e = "horizontal",
  formatCaller: n,
  showMarkers: r = !0
}) {
  const i = n ? n(t.caller) : t.caller, o = i !== t.caller;
  let s, a = t.content;
  Array.isArray(t.content) && t.content.length > 0 && typeof t.content[0] != "string" && (t.content[0].marker === "fr" || t.content[0].marker === "xo") && ([s, ...a] = t.content);
  const l = r ? /* @__PURE__ */ p("span", { className: "marker", children: `\\${t.marker} ` }) : void 0, c = r ? /* @__PURE__ */ p("span", { className: "marker", children: ` \\${t.marker}*` }) : void 0, u = /* @__PURE__ */ B(Lt, { children: [
    i && // USFM does not specify a marker for caller, so instead of a usfm_* class, we use a
    // specific class name in case styling is needed.
    /* @__PURE__ */ B("span", { className: G("note-caller", { formatted: o }), children: [
      i,
      " "
    ] }),
    s && /* @__PURE__ */ B(Lt, { children: [
      Ig(t.marker, [s], r, !1),
      " "
    ] })
  ] }), h = G(e === "horizontal" ? "horizontal tw-table-cell" : "vertical", r ? "marker-visible" : "");
  return /* @__PURE__ */ B(Lt, { children: [
    /* @__PURE__ */ B("div", { className: G("textual-note-header tw-text-nowrap tw-pr-2", h), children: [
      l,
      u
    ] }),
    /* @__PURE__ */ p("div", { className: G("textual-note-body", h), children: a && a.length > 0 && /* @__PURE__ */ p(Lt, { children: IR(t.marker, a, r, c) }) })
  ] });
}
const a2 = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "div",
    {
      ref: n,
      className: G(
        "pr-twp tw-rounded-lg tw-border tw-bg-card tw-text-card-foreground tw-shadow-sm",
        t
      ),
      ...e
    }
  )
);
a2.displayName = "Card";
const LR = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "div",
    {
      ref: n,
      className: G("pr-twp tw-flex tw-flex-col tw-space-y-1.5 tw-p-6", t),
      ...e
    }
  )
);
LR.displayName = "CardHeader";
const $R = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "h3",
    {
      ref: n,
      className: G(
        "pr-twp tw-text-2xl tw-font-semibold tw-leading-none tw-tracking-tight",
        t
      ),
      ...e,
      children: e.children
    }
  )
);
$R.displayName = "CardTitle";
const FR = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p("p", { ref: n, className: G("pr-twp tw-text-sm tw-text-muted-foreground", t), ...e }));
FR.displayName = "CardDescription";
const BR = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p("div", { ref: n, className: G("pr-twp tw-p-6 tw-pt-0", t), ...e })
);
BR.displayName = "CardContent";
const qR = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "div",
    {
      ref: n,
      className: G("pr-twp tw-flex tw-items-center tw-p-6 tw-pt-0", t),
      ...e
    }
  )
);
qR.displayName = "CardFooter";
const jR = (t, e) => t[e] ?? e;
function JL({
  className: t,
  footnotes: e,
  layout: n = "horizontal",
  listId: r,
  selectedFootnote: i,
  showMarkers: o = !0,
  suppressFormatting: s = !1,
  formatCaller: a,
  onFootnoteSelected: l,
  localizedStrings: c
}) {
  const u = c ? jR(c, "%webView_footnoteList_header%") : "Footnotes", f = a ?? T1(e, void 0), d = (y, C) => {
    l == null || l(y, C, r);
  }, h = i ? e.findIndex((y) => y === i) : 0, [g, w] = ue(h), b = (y) => {
    if (e.length)
      switch (y.key) {
        case "ArrowDown":
          y.preventDefault(), w((C) => Math.min(C + 1, e.length - 1));
          break;
        case "ArrowUp":
          y.preventDefault(), w((C) => Math.max(C - 1, 0));
          break;
        case "Enter":
        case " ":
          y.preventDefault(), l == null || l(e[g], g, r);
          break;
      }
  }, _ = ye([]);
  return de(() => {
    var y;
    g >= 0 && g < _.current.length && ((y = _.current[g]) == null || y.focus());
  }, [g]), /* @__PURE__ */ B(Lt, { children: [
    n === "vertical" && /* @__PURE__ */ p("h2", { className: "tw-mb-1 tw-font-semibold", children: u }),
    /* @__PURE__ */ p(
      "div",
      {
        role: "listbox",
        "aria-label": "Footnotes",
        tabIndex: 0,
        className: G("tw-h-full tw-overflow-y-auto", t),
        onKeyDown: b,
        children: /* @__PURE__ */ p(
          "div",
          {
            className: G(
              "tw-p-0.5",
              n === "horizontal" ? "tw-table" : "tw-flex tw-flex-col tw-gap-1",
              !s && "formatted-font"
            ),
            children: e.map((y, C) => {
              const D = y === i, P = `${r}-${C}`;
              return /* @__PURE__ */ p(
                a2,
                {
                  ref: (S) => {
                    _.current[C] = S;
                  },
                  role: "option",
                  "aria-selected": D,
                  "data-marker": y.marker,
                  "data-state": D ? "selected" : void 0,
                  tabIndex: -1,
                  className: G(
                    "data-[state=selected]:tw-bg-muted",
                    l && "tw-cursor-pointer hover:tw-bg-muted/50",
                    "tw-w-full tw-rounded-sm tw-border-0 tw-bg-transparent tw-py-0 tw-shadow-none",
                    n === "horizontal" ? "horizontal tw-table-row" : "vertical tw-block tw-text-sm"
                  ),
                  onClick: () => d(y, C),
                  children: /* @__PURE__ */ p(
                    PR,
                    {
                      footnote: y,
                      layout: n,
                      formatCaller: () => f(y.caller, C),
                      showMarkers: o
                    }
                  )
                },
                P
              );
            })
          }
        )
      }
    )
  ] });
}
function UR({
  occurrenceData: t,
  setScriptureReference: e,
  localizedStrings: n
}) {
  const r = n["%webView_inventory_occurrences_table_header_reference%"], i = n["%webView_inventory_occurrences_table_header_occurrence%"], o = Ne(() => {
    const s = [];
    return t.forEach((a) => {
      s.some((l) => Gh(l, a)) || s.push(a);
    }), s;
  }, [t]);
  return /* @__PURE__ */ B(Fu, { stickyHeader: !0, children: [
    /* @__PURE__ */ p(Bu, { stickyHeader: !0, children: /* @__PURE__ */ B(hi, { children: [
      /* @__PURE__ */ p(il, { children: r }),
      /* @__PURE__ */ p(il, { children: i })
    ] }) }),
    /* @__PURE__ */ p(qu, { children: o.length > 0 && o.map((s) => /* @__PURE__ */ B(
      hi,
      {
        onClick: () => {
          e(s.reference);
        },
        children: [
          /* @__PURE__ */ p(xo, { children: `${nt.bookIdToEnglishName(s.reference.book)} ${s.reference.chapterNum}:${s.reference.verseNum}` }),
          /* @__PURE__ */ p(xo, { children: s.text })
        ]
      },
      `${s.reference.book} ${s.reference.chapterNum}:${s.reference.verseNum}-${s.text}`
    )) })
  ] });
}
const Rg = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Df.Root,
  {
    ref: n,
    className: G(
      "tw-peer pr-twp tw-h-4 tw-w-4 tw-shrink-0 tw-rounded-sm tw-border tw-border-primary tw-ring-offset-background focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-cursor-not-allowed disabled:tw-opacity-50 data-[state=checked]:tw-bg-primary data-[state=checked]:tw-text-primary-foreground",
      t
    ),
    ...e,
    children: /* @__PURE__ */ p(
      Df.Indicator,
      {
        className: G("tw-flex tw-items-center tw-justify-center tw-text-current"),
        children: /* @__PURE__ */ p(xi, { className: "tw-h-4 tw-w-4" })
      }
    )
  }
));
Rg.displayName = Df.Root.displayName;
const l2 = Xi(
  "pr-twp tw-inline-flex tw-items-center tw-justify-center tw-rounded-md tw-text-sm tw-font-medium tw-ring-offset-background tw-transition-colors hover:tw-bg-muted hover:tw-text-muted-foreground focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-pointer-events-none disabled:tw-opacity-50 data-[state=on]:tw-bg-accent data-[state=on]:tw-text-accent-foreground",
  {
    variants: {
      variant: {
        default: "tw-bg-transparent",
        outline: "tw-border tw-border-input tw-bg-transparent hover:tw-bg-accent hover:tw-text-accent-foreground"
      },
      size: {
        default: "tw-h-10 tw-px-3",
        sm: "tw-h-9 tw-px-2.5",
        lg: "tw-h-11 tw-px-5"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), zR = Y.forwardRef(({ className: t, variant: e, size: n, ...r }, i) => /* @__PURE__ */ p(
  Ey.Root,
  {
    ref: i,
    className: G(l2({ variant: e, size: n, className: t })),
    ...r
  }
));
zR.displayName = Ey.Root.displayName;
const c2 = Y.createContext({
  size: "default",
  variant: "default"
}), u2 = Y.forwardRef(({ className: t, variant: e, size: n, children: r, ...i }, o) => {
  const s = Jt();
  return /* @__PURE__ */ p(
    Pu.Root,
    {
      ref: o,
      className: G("pr-twp tw-flex tw-items-center tw-justify-center tw-gap-1", t),
      ...i,
      dir: s,
      children: /* @__PURE__ */ p(
        c2.Provider,
        {
          value: { variant: e, size: n },
          children: r
        }
      )
    }
  );
});
u2.displayName = Pu.Root.displayName;
const Uc = Y.forwardRef(({ className: t, children: e, variant: n, size: r, ...i }, o) => {
  const s = Y.useContext(c2);
  return /* @__PURE__ */ p(
    Pu.Item,
    {
      ref: o,
      className: G(
        l2({
          variant: s.variant || n,
          size: s.size || r
        }),
        t
      ),
      ...i,
      children: e
    }
  );
});
Uc.displayName = Pu.Item.displayName;
const pd = (t) => t === "asc" ? /* @__PURE__ */ p(u1, { className: "tw-ms-2 tw-h-4 tw-w-4" }) : t === "desc" ? /* @__PURE__ */ p(d1, { className: "tw-ms-2 tw-h-4 tw-w-4" }) : /* @__PURE__ */ p(f1, { className: "tw-ms-2 tw-h-4 tw-w-4" }), XL = (t) => ({
  accessorKey: "item",
  accessorFn: (e) => e.items[0],
  header: ({ column: e }) => /* @__PURE__ */ B(Me, { variant: "ghost", onClick: () => e.toggleSorting(void 0), children: [
    t,
    pd(e.getIsSorted())
  ] })
}), VR = (t, e) => ({
  accessorKey: `item${e}`,
  accessorFn: (n) => n.items[e],
  header: ({ column: n }) => /* @__PURE__ */ B(Me, { variant: "ghost", onClick: () => n.toggleSorting(void 0), children: [
    t,
    pd(n.getIsSorted())
  ] })
}), YL = (t) => ({
  accessorKey: "count",
  header: ({ column: e }) => /* @__PURE__ */ p("div", { className: "tw-flex tw-justify-end tw-tabular-nums", children: /* @__PURE__ */ B(Me, { variant: "ghost", onClick: () => e.toggleSorting(void 0), children: [
    t,
    pd(e.getIsSorted())
  ] }) }),
  cell: ({ row: e }) => /* @__PURE__ */ p("div", { className: "tw-flex tw-justify-end", children: e.getValue("count") })
}), Cf = (t, e, n, r, i, o) => {
  let s = [...n];
  t.forEach((l) => {
    e === "approved" ? s.includes(l) || s.push(l) : s = s.filter((c) => c !== l);
  }), r(s);
  let a = [...i];
  t.forEach((l) => {
    e === "unapproved" ? a.includes(l) || a.push(l) : a = a.filter((c) => c !== l);
  }), o(a);
}, QL = (t, e, n, r, i) => ({
  accessorKey: "status",
  header: ({ column: o }) => /* @__PURE__ */ p("div", { className: "tw-flex tw-justify-center", children: /* @__PURE__ */ B(Me, { variant: "ghost", onClick: () => o.toggleSorting(void 0), children: [
    t,
    pd(o.getIsSorted())
  ] }) }),
  cell: ({ row: o }) => {
    const s = o.getValue("status"), a = o.getValue("item");
    return /* @__PURE__ */ B(u2, { value: s, variant: "outline", type: "single", children: [
      /* @__PURE__ */ p(
        Uc,
        {
          onClick: (l) => {
            l.stopPropagation(), Cf(
              [a],
              "approved",
              e,
              n,
              r,
              i
            );
          },
          value: "approved",
          children: /* @__PURE__ */ p(a1, {})
        }
      ),
      /* @__PURE__ */ p(
        Uc,
        {
          onClick: (l) => {
            l.stopPropagation(), Cf(
              [a],
              "unapproved",
              e,
              n,
              r,
              i
            );
          },
          value: "unapproved",
          children: /* @__PURE__ */ p(l1, {})
        }
      ),
      /* @__PURE__ */ p(
        Uc,
        {
          onClick: (l) => {
            l.stopPropagation(), Cf(
              [a],
              "unknown",
              e,
              n,
              r,
              i
            );
          },
          value: "unknown",
          children: /* @__PURE__ */ p(c1, {})
        }
      )
    ] });
  }
}), ZL = (t) => t.split(/(?:\r?\n|\r)|(?=(?:\\(?:v|c|id)))/g), e3 = (t) => {
  const e = /^\\[vc]\s+(\d+)/, n = t.match(e);
  if (n)
    return +n[1];
}, t3 = (t) => {
  const e = t.match(/^\\id\s+([A-Za-z]+)/);
  return e ? e[1] : "";
}, HR = (t, e, n) => n.includes(t) ? "unapproved" : e.includes(t) ? "approved" : "unknown", n3 = Object.freeze([
  "%webView_inventory_all%",
  "%webView_inventory_approved%",
  "%webView_inventory_unapproved%",
  "%webView_inventory_unknown%",
  "%webView_inventory_scope_currentBook%",
  "%webView_inventory_scope_chapter%",
  "%webView_inventory_scope_verse%",
  "%webView_inventory_filter_text%",
  "%webView_inventory_show_additional_items%",
  "%webView_inventory_occurrences_table_header_reference%",
  "%webView_inventory_occurrences_table_header_occurrence%",
  "%webView_inventory_no_results%"
]), KR = (t, e, n) => {
  let r = t;
  return e !== "all" && (r = r.filter(
    (i) => e === "approved" && i.status === "approved" || e === "unapproved" && i.status === "unapproved" || e === "unknown" && i.status === "unknown"
  )), n !== "" && (r = r.filter((i) => i.items[0].includes(n))), r;
}, WR = (t, e, n) => {
  const r = [];
  return t.forEach((i) => {
    const o = r.find(
      (s) => Gh(
        s.items,
        $d(i.inventoryText) ? [i.inventoryText] : i.inventoryText
      )
    );
    if (o)
      o.count += 1, o.occurrences.push({
        reference: i.verseRef,
        text: i.verse
      });
    else {
      const s = {
        items: $d(i.inventoryText) ? [i.inventoryText] : i.inventoryText,
        count: 1,
        status: HR(
          $d(i.inventoryText) ? i.inventoryText : i.inventoryText[0],
          e,
          n
        ),
        occurrences: [
          {
            reference: i.verseRef,
            text: i.verse
          }
        ]
      };
      r.push(s);
    }
  }), r;
}, Lr = (t, e) => t[e] ?? e;
function r3({
  inventoryItems: t,
  setVerseRef: e,
  localizedStrings: n,
  additionalItemsLabels: r,
  approvedItems: i,
  unapprovedItems: o,
  scope: s,
  onScopeChange: a,
  columns: l,
  id: c,
  areInventoryItemsLoading: u = !1
}) {
  const f = Lr(n, "%webView_inventory_all%"), d = Lr(n, "%webView_inventory_approved%"), h = Lr(n, "%webView_inventory_unapproved%"), g = Lr(n, "%webView_inventory_unknown%"), w = Lr(n, "%webView_inventory_scope_currentBook%"), b = Lr(n, "%webView_inventory_scope_chapter%"), _ = Lr(n, "%webView_inventory_scope_verse%"), y = Lr(n, "%webView_inventory_filter_text%"), C = Lr(
    n,
    "%webView_inventory_show_additional_items%"
  ), D = Lr(n, "%webView_inventory_no_results%"), [P, S] = ue(!1), [L, O] = ue("all"), [M, F] = ue(""), [k, I] = ue([]), N = Ne(() => {
    const W = t ?? [];
    return W.length === 0 ? [] : WR(W, i, o);
  }, [t, i, o]), R = Ne(() => {
    if (P) return N;
    const W = [];
    return N.forEach((ne) => {
      const re = ne.items[0], te = W.find(
        (Q) => Q.items[0] === re
      );
      te ? (te.count += ne.count, te.occurrences = te.occurrences.concat(ne.occurrences)) : W.push({
        items: [re],
        count: ne.count,
        occurrences: ne.occurrences,
        status: ne.status
      });
    }), W;
  }, [P, N]), T = Ne(() => R.length === 0 ? [] : KR(R, L, M), [R, L, M]), A = Ne(() => {
    var re, te;
    if (!P) return l;
    const W = (re = r == null ? void 0 : r.tableHeaders) == null ? void 0 : re.length;
    if (!W) return l;
    const ne = [];
    for (let Q = 0; Q < W; Q++)
      ne.push(
        VR(
          ((te = r == null ? void 0 : r.tableHeaders) == null ? void 0 : te[Q]) || "Additional Item",
          Q + 1
        )
      );
    return [...ne, ...l];
  }, [r == null ? void 0 : r.tableHeaders, l, P]);
  de(() => {
    T.length === 0 ? I([]) : T.length === 1 && I(T[0].items);
  }, [T]);
  const q = (W, ne) => {
    ne.setRowSelection(() => {
      const re = {};
      return re[W.index] = !0, re;
    }), I(W.original.items);
  }, V = (W) => {
    if (W === "book" || W === "chapter" || W === "verse")
      a(W);
    else
      throw new Error(`Invalid scope value: ${W}`);
  }, J = (W) => {
    if (W === "all" || W === "approved" || W === "unapproved" || W === "unknown")
      O(W);
    else
      throw new Error(`Invalid status filter value: ${W}`);
  }, H = Ne(() => {
    if (R.length === 0 || k.length === 0) return [];
    const W = R.filter((ne) => Gh(
      P ? ne.items : [ne.items[0]],
      k
    ));
    if (W.length > 1) throw new Error("Selected item is not unique");
    return W.length === 0 ? [] : W[0].occurrences;
  }, [k, P, R]);
  return /* @__PURE__ */ B("div", { id: c, className: "pr-twp tw-flex tw-h-full tw-flex-col", children: [
    /* @__PURE__ */ B("div", { className: "tw-flex tw-items-stretch", children: [
      /* @__PURE__ */ B(
        Is,
        {
          onValueChange: (W) => J(W),
          defaultValue: L,
          children: [
            /* @__PURE__ */ p(Ro, { className: "tw-m-1", children: /* @__PURE__ */ p(Rs, { placeholder: "Select filter" }) }),
            /* @__PURE__ */ B(Po, { children: [
              /* @__PURE__ */ p(er, { value: "all", children: f }),
              /* @__PURE__ */ p(er, { value: "approved", children: d }),
              /* @__PURE__ */ p(er, { value: "unapproved", children: h }),
              /* @__PURE__ */ p(er, { value: "unknown", children: g })
            ] })
          ]
        }
      ),
      /* @__PURE__ */ B(Is, { onValueChange: (W) => V(W), defaultValue: s, children: [
        /* @__PURE__ */ p(Ro, { className: "tw-m-1", children: /* @__PURE__ */ p(Rs, { placeholder: "Select scope" }) }),
        /* @__PURE__ */ B(Po, { children: [
          /* @__PURE__ */ p(er, { value: "book", children: w }),
          /* @__PURE__ */ p(er, { value: "chapter", children: b }),
          /* @__PURE__ */ p(er, { value: "verse", children: _ })
        ] })
      ] }),
      /* @__PURE__ */ p(
        Ca,
        {
          className: "tw-m-1 tw-rounded-md tw-border",
          placeholder: y,
          value: M,
          onChange: (W) => {
            F(W.target.value);
          }
        }
      ),
      r && /* @__PURE__ */ B("div", { className: "tw-m-1 tw-flex tw-items-center tw-rounded-md tw-border", children: [
        /* @__PURE__ */ p(
          Rg,
          {
            className: "tw-m-1",
            checked: P,
            onCheckedChange: (W) => {
              S(W);
            }
          }
        ),
        /* @__PURE__ */ p(Vt, { className: "tw-m-1 tw-flex-shrink-0 tw-whitespace-nowrap", children: (r == null ? void 0 : r.checkboxText) ?? C })
      ] })
    ] }),
    /* @__PURE__ */ p("div", { className: "tw-m-1 tw-flex-1 tw-overflow-auto tw-rounded-md tw-border", children: /* @__PURE__ */ p(
      TC,
      {
        columns: A,
        data: T,
        onRowClickHandler: q,
        stickyHeader: !0,
        isLoading: u,
        noResultsMessage: D
      }
    ) }),
    H.length > 0 && /* @__PURE__ */ p("div", { className: "tw-m-1 tw-flex-1 tw-overflow-auto tw-rounded-md tw-border", children: /* @__PURE__ */ p(
      UR,
      {
        occurrenceData: H,
        setScriptureReference: e,
        localizedStrings: n
      }
    ) })
  ] });
}
const Pg = Y.forwardRef(({ className: t, orientation: e = "horizontal", decorative: n = !0, ...r }, i) => /* @__PURE__ */ p(
  Ny.Root,
  {
    ref: i,
    decorative: n,
    orientation: e,
    className: G(
      "pr-twp tw-shrink-0 tw-bg-border",
      e === "horizontal" ? "tw-h-[1px] tw-w-full" : "tw-h-full tw-w-[1px]",
      t
    ),
    ...r
  }
));
Pg.displayName = Ny.Root.displayName;
const Lg = Al.Provider, $g = Al.Root, Fg = Al.Trigger, gd = Y.forwardRef(({ className: t, sideOffset: e = 4, ...n }, r) => /* @__PURE__ */ p(
  Al.Content,
  {
    ref: r,
    sideOffset: e,
    className: G(
      "pr-twp tw-z-50 tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-px-3 tw-py-1.5 tw-text-sm tw-text-popover-foreground tw-shadow-md tw-animate-in tw-fade-in-0 tw-zoom-in-95 data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=closed]:tw-zoom-out-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
      t
    ),
    ...n
  }
));
gd.displayName = Al.Content.displayName;
const GR = "16rem", JR = "3rem", d2 = Y.createContext(void 0);
function wd() {
  const t = Y.useContext(d2);
  if (!t)
    throw new Error("useSidebar must be used within a SidebarProvider.");
  return t;
}
const f2 = Y.forwardRef(
  ({
    defaultOpen: t = !0,
    open: e,
    onOpenChange: n,
    className: r,
    style: i,
    children: o,
    side: s = "primary",
    ...a
  }, l) => {
    const [c, u] = Y.useState(t), f = e ?? c, d = Y.useCallback(
      (C) => {
        const D = typeof C == "function" ? C(f) : C;
        n ? n(D) : u(D);
      },
      [n, f]
    ), h = Y.useCallback(() => d((C) => !C), [d]), g = f ? "expanded" : "collapsed", _ = Jt() === "ltr" ? s : s === "primary" ? "secondary" : "primary", y = Y.useMemo(
      () => ({
        state: g,
        open: f,
        setOpen: d,
        toggleSidebar: h,
        side: _
      }),
      [g, f, d, h, _]
    );
    return /* @__PURE__ */ p(d2.Provider, { value: y, children: /* @__PURE__ */ p(Lg, { delayDuration: 0, children: /* @__PURE__ */ p(
      "div",
      {
        style: (
          // eslint-disable-next-line no-type-assertion/no-type-assertion
          {
            "--sidebar-width": GR,
            "--sidebar-width-icon": JR,
            ...i
          }
        ),
        className: G(
          // Removed tw-min-h-svh
          "tw-group/sidebar-wrapper pr-twp tw-flex tw-w-full has-[[data-variant=inset]]:tw-bg-sidebar",
          r
        ),
        ref: l,
        ...a,
        children: o
      }
    ) }) });
  }
);
f2.displayName = "SidebarProvider";
const h2 = Y.forwardRef(({ variant: t = "sidebar", collapsible: e = "offcanvas", className: n, children: r, ...i }, o) => {
  const s = wd();
  return e === "none" ? /* @__PURE__ */ p(
    "div",
    {
      className: G(
        "tw-flex tw-h-full tw-w-[--sidebar-width] tw-flex-col tw-bg-sidebar tw-text-sidebar-foreground",
        n
      ),
      ref: o,
      ...i,
      children: r
    }
  ) : /* @__PURE__ */ B(
    "div",
    {
      ref: o,
      className: "tw-group tw-peer tw-hidden tw-text-sidebar-foreground md:tw-block",
      "data-state": s.state,
      "data-collapsible": s.state === "collapsed" ? e : "",
      "data-variant": t,
      "data-side": s.side,
      children: [
        /* @__PURE__ */ p(
          "div",
          {
            className: G(
              "tw-relative tw-h-svh tw-w-[--sidebar-width] tw-bg-transparent tw-transition-[width] tw-duration-200 tw-ease-linear",
              "group-data-[collapsible=offcanvas]:tw-w-0",
              "group-data-[side=secondary]:tw-rotate-180",
              t === "floating" || t === "inset" ? "group-data-[collapsible=icon]:tw-w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]" : "group-data-[collapsible=icon]:tw-w-[--sidebar-width-icon]"
            )
          }
        ),
        /* @__PURE__ */ p(
          "div",
          {
            className: G(
              // CUSTOM: Switched tw-fixed to tw-absolute here to scope the sidebar inside of it's container
              "tw-absolute tw-inset-y-0 tw-z-10 tw-hidden tw-h-svh tw-w-[--sidebar-width] tw-transition-[left,right,width] tw-duration-200 tw-ease-linear md:tw-flex",
              s.side === "primary" ? "tw-left-0 group-data-[collapsible=offcanvas]:tw-left-[calc(var(--sidebar-width)*-1)]" : "tw-right-0 group-data-[collapsible=offcanvas]:tw-right-[calc(var(--sidebar-width)*-1)]",
              // Adjust the padding for floating and inset variants.
              t === "floating" || t === "inset" ? "tw-p-2 group-data-[collapsible=icon]:tw-w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]" : "group-data-[collapsible=icon]:tw-w-[--sidebar-width-icon] group-data-[side=primary]:tw-border-r group-data-[side=secondary]:tw-border-l",
              n
            ),
            ...i,
            children: /* @__PURE__ */ p(
              "div",
              {
                "data-sidebar": "sidebar",
                className: "tw-flex tw-h-full tw-w-full tw-flex-col tw-bg-sidebar group-data-[variant=floating]:tw-rounded-lg group-data-[variant=floating]:tw-border group-data-[variant=floating]:tw-border-sidebar-border group-data-[variant=floating]:tw-shadow",
                children: r
              }
            )
          }
        )
      ]
    }
  );
});
h2.displayName = "Sidebar";
const XR = Y.forwardRef(({ className: t, onClick: e, ...n }, r) => {
  const i = wd();
  return /* @__PURE__ */ B(
    Me,
    {
      ref: r,
      "data-sidebar": "trigger",
      variant: "ghost",
      size: "icon",
      className: G("tw-h-7 tw-w-7", t),
      onClick: (o) => {
        e == null || e(o), i.toggleSidebar();
      },
      ...n,
      children: [
        i.side === "primary" ? /* @__PURE__ */ p(h1, {}) : /* @__PURE__ */ p(p1, {}),
        /* @__PURE__ */ p("span", { className: "tw-sr-only", children: "Toggle Sidebar" })
      ]
    }
  );
});
XR.displayName = "SidebarTrigger";
const YR = Y.forwardRef(
  ({ className: t, ...e }, n) => {
    const { toggleSidebar: r } = wd();
    return /* @__PURE__ */ p(
      "button",
      {
        type: "button",
        ref: n,
        "data-sidebar": "rail",
        "aria-label": "Toggle Sidebar",
        tabIndex: -1,
        onClick: r,
        title: "Toggle Sidebar",
        className: G(
          "tw-absolute tw-inset-y-0 tw-z-20 tw-hidden tw-w-4 tw--translate-x-1/2 tw-transition-all tw-ease-linear after:tw-absolute after:tw-inset-y-0 after:tw-left-1/2 after:tw-w-[2px] hover:after:tw-bg-sidebar-border group-data-[side=primary]:tw--right-4 group-data-[side=secondary]:tw-left-0 sm:tw-flex",
          "[[data-side=secondary]_&]:tw-cursor-e-resize [[data-side=secondary]_&]:tw-cursor-w-resize",
          "[[data-side=primary][data-state=collapsed]_&]:tw-cursor-e-resize [[data-side=secondary][data-state=collapsed]_&]:tw-cursor-w-resize",
          "group-data-[collapsible=offcanvas]:tw-translate-x-0 group-data-[collapsible=offcanvas]:after:tw-left-full group-data-[collapsible=offcanvas]:hover:tw-bg-sidebar",
          "[[data-side=primary][data-collapsible=offcanvas]_&]:tw--right-2",
          "[[data-side=secondary][data-collapsible=offcanvas]_&]:tw--left-2",
          t
        ),
        ...e
      }
    );
  }
);
YR.displayName = "SidebarRail";
const p2 = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "main",
    {
      ref: n,
      className: G(
        // CUSTOM: Removed tw-min-h-svh
        "tw-relative tw-flex tw-flex-1 tw-flex-col tw-bg-background",
        "peer-data-[variant=inset]:tw-min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:tw-m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:tw-ml-2 md:peer-data-[variant=inset]:tw-ml-0 md:peer-data-[variant=inset]:tw-rounded-xl md:peer-data-[variant=inset]:tw-shadow",
        t
      ),
      ...e
    }
  )
);
p2.displayName = "SidebarInset";
const QR = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Ca,
  {
    ref: n,
    "data-sidebar": "input",
    className: G(
      "tw-h-8 tw-w-full tw-bg-background tw-shadow-none focus-visible:tw-ring-2 focus-visible:tw-ring-sidebar-ring",
      t
    ),
    ...e
  }
));
QR.displayName = "SidebarInput";
const ZR = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "div",
    {
      ref: n,
      "data-sidebar": "header",
      className: G("tw-flex tw-flex-col tw-gap-2 tw-p-2", t),
      ...e
    }
  )
);
ZR.displayName = "SidebarHeader";
const eP = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "div",
    {
      ref: n,
      "data-sidebar": "footer",
      className: G("tw-flex tw-flex-col tw-gap-2 tw-p-2", t),
      ...e
    }
  )
);
eP.displayName = "SidebarFooter";
const tP = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Pg,
  {
    ref: n,
    "data-sidebar": "separator",
    className: G("tw-mx-2 tw-w-auto tw-bg-sidebar-border", t),
    ...e
  }
));
tP.displayName = "SidebarSeparator";
const g2 = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "div",
    {
      ref: n,
      "data-sidebar": "content",
      className: G(
        "tw-flex tw-min-h-0 tw-flex-1 tw-flex-col tw-gap-2 tw-overflow-auto group-data-[collapsible=icon]:tw-overflow-hidden",
        t
      ),
      ...e
    }
  )
);
g2.displayName = "SidebarContent";
const Uh = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "div",
    {
      ref: n,
      "data-sidebar": "group",
      className: G("tw-relative tw-flex tw-w-full tw-min-w-0 tw-flex-col tw-p-2", t),
      ...e
    }
  )
);
Uh.displayName = "SidebarGroup";
const zh = Y.forwardRef(({ className: t, asChild: e = !1, ...n }, r) => /* @__PURE__ */ p(
  e ? na : "div",
  {
    ref: r,
    "data-sidebar": "group-label",
    className: G(
      "tw-flex tw-h-8 tw-shrink-0 tw-items-center tw-rounded-md tw-px-2 tw-text-xs tw-font-medium tw-text-sidebar-foreground/70 tw-outline-none tw-ring-sidebar-ring tw-transition-[margin,opa] tw-duration-200 tw-ease-linear focus-visible:tw-ring-2 [&>svg]:tw-size-4 [&>svg]:tw-shrink-0",
      "group-data-[collapsible=icon]:tw--mt-8 group-data-[collapsible=icon]:tw-opacity-0",
      t
    ),
    ...n
  }
));
zh.displayName = "SidebarGroupLabel";
const nP = Y.forwardRef(({ className: t, asChild: e = !1, ...n }, r) => /* @__PURE__ */ p(
  e ? na : "button",
  {
    ref: r,
    "data-sidebar": "group-action",
    className: G(
      "tw-absolute tw-right-3 tw-top-3.5 tw-flex tw-aspect-square tw-w-5 tw-items-center tw-justify-center tw-rounded-md tw-p-0 tw-text-sidebar-foreground tw-outline-none tw-ring-sidebar-ring tw-transition-transform hover:tw-bg-sidebar-accent hover:tw-text-sidebar-accent-foreground focus-visible:tw-ring-2 [&>svg]:tw-size-4 [&>svg]:tw-shrink-0",
      // Increases the hit area of the button on mobile.
      "after:tw-absolute after:tw--inset-2 after:md:tw-hidden",
      "group-data-[collapsible=icon]:tw-hidden",
      t
    ),
    ...n
  }
));
nP.displayName = "SidebarGroupAction";
const Vh = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "div",
    {
      ref: n,
      "data-sidebar": "group-content",
      className: G("tw-w-full tw-text-sm", t),
      ...e
    }
  )
);
Vh.displayName = "SidebarGroupContent";
const w2 = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "ul",
    {
      ref: n,
      "data-sidebar": "menu",
      className: G("tw-flex tw-w-full tw-min-w-0 tw-flex-col tw-gap-1", t),
      ...e
    }
  )
);
w2.displayName = "SidebarMenu";
const m2 = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "li",
    {
      ref: n,
      "data-sidebar": "menu-item",
      className: G("tw-group/menu-item tw-relative", t),
      ...e
    }
  )
);
m2.displayName = "SidebarMenuItem";
const rP = Xi(
  "tw-peer/menu-button tw-flex tw-w-full tw-items-center tw-gap-2 tw-overflow-hidden tw-rounded-md tw-p-2 tw-text-left tw-text-sm tw-outline-none tw-ring-sidebar-ring tw-transition-[width,height,padding] hover:tw-bg-sidebar-accent hover:tw-text-sidebar-accent-foreground focus-visible:tw-ring-2 active:tw-bg-sidebar-accent active:tw-text-sidebar-accent-foreground disabled:tw-pointer-events-none disabled:tw-opacity-50 tw-group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:tw-pointer-events-none aria-disabled:tw-opacity-50 data-[active=true]:tw-font-medium data-[active=true]:tw-text-sidebar-accent-foreground data-[active=true]:tw-bg-sidebar-accent data-[state=open]:hover:tw-bg-sidebar-accent data-[state=open]:hover:tw-text-sidebar-accent-foreground group-data-[collapsible=icon]:tw-!size-8 group-data-[collapsible=icon]:tw-!p-2 [&>span:last-child]:tw-truncate [&>svg]:tw-size-4 [&>svg]:tw-shrink-0",
  {
    variants: {
      variant: {
        default: "hover:tw-bg-sidebar-accent hover:tw-text-sidebar-accent-foreground",
        outline: "tw-bg-background tw-shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:tw-bg-sidebar-accent hover:tw-text-sidebar-accent-foreground hover:tw-shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
      },
      size: {
        default: "tw-h-8 tw-text-sm",
        sm: "tw-h-7 tw-text-xs",
        lg: "tw-h-12 tw-text-sm group-data-[collapsible=icon]:tw-!p-0"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), b2 = Y.forwardRef(
  ({
    asChild: t = !1,
    isActive: e = !1,
    variant: n = "default",
    size: r = "default",
    tooltip: i,
    className: o,
    ...s
  }, a) => {
    const l = t ? na : "button", { state: c } = wd(), u = /* @__PURE__ */ p(
      l,
      {
        ref: a,
        "data-sidebar": "menu-button",
        "data-size": r,
        "data-active": e,
        className: G(rP({ variant: n, size: r }), o),
        ...s
      }
    );
    return i ? (typeof i == "string" && (i = {
      children: i
    }), /* @__PURE__ */ B($g, { children: [
      /* @__PURE__ */ p(Fg, { asChild: !0, children: u }),
      /* @__PURE__ */ p(gd, { side: "right", align: "center", hidden: c !== "collapsed", ...i })
    ] })) : u;
  }
);
b2.displayName = "SidebarMenuButton";
const iP = Y.forwardRef(({ className: t, asChild: e = !1, showOnHover: n = !1, ...r }, i) => /* @__PURE__ */ p(
  e ? na : "button",
  {
    ref: i,
    "data-sidebar": "menu-action",
    className: G(
      "tw-peer-hover/menu-button:text-sidebar-accent-foreground tw-absolute tw-right-1 tw-top-1.5 tw-flex tw-aspect-square tw-w-5 tw-items-center tw-justify-center tw-rounded-md tw-p-0 tw-text-sidebar-foreground tw-outline-none tw-ring-sidebar-ring tw-transition-transform hover:tw-bg-sidebar-accent hover:tw-text-sidebar-accent-foreground focus-visible:tw-ring-2 [&>svg]:tw-size-4 [&>svg]:tw-shrink-0",
      // Increases the hit area of the button on mobile.
      "after:tw-absolute after:tw--inset-2 after:md:tw-hidden",
      "tw-peer-data-[size=sm]/menu-button:top-1",
      "tw-peer-data-[size=default]/menu-button:top-1.5",
      "tw-peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:tw-hidden",
      n && "tw-group-focus-within/menu-item:opacity-100 tw-group-hover/menu-item:opacity-100 tw-peer-data-[active=true]/menu-button:text-sidebar-accent-foreground data-[state=open]:tw-opacity-100 md:tw-opacity-0",
      t
    ),
    ...r
  }
));
iP.displayName = "SidebarMenuAction";
const oP = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "div",
    {
      ref: n,
      "data-sidebar": "menu-badge",
      className: G(
        "tw-pointer-events-none tw-absolute tw-right-1 tw-flex tw-h-5 tw-min-w-5 tw-select-none tw-items-center tw-justify-center tw-rounded-md tw-px-1 tw-text-xs tw-font-medium tw-tabular-nums tw-text-sidebar-foreground",
        "tw-peer-hover/menu-button:text-sidebar-accent-foreground tw-peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "tw-peer-data-[size=sm]/menu-button:top-1",
        "tw-peer-data-[size=default]/menu-button:top-1.5",
        "tw-peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:tw-hidden",
        t
      ),
      ...e
    }
  )
);
oP.displayName = "SidebarMenuBadge";
const sP = Y.forwardRef(({ className: t, showIcon: e = !1, ...n }, r) => {
  const i = Y.useMemo(() => `${Math.floor(Math.random() * 40) + 50}%`, []);
  return /* @__PURE__ */ B(
    "div",
    {
      ref: r,
      "data-sidebar": "menu-skeleton",
      className: G("tw-flex tw-h-8 tw-items-center tw-gap-2 tw-rounded-md tw-px-2", t),
      ...n,
      children: [
        e && /* @__PURE__ */ p(Lf, { className: "tw-size-4 tw-rounded-md", "data-sidebar": "menu-skeleton-icon" }),
        /* @__PURE__ */ p(
          Lf,
          {
            className: "tw-h-4 tw-max-w-[--skeleton-width] tw-flex-1",
            "data-sidebar": "menu-skeleton-text",
            style: (
              // eslint-disable-next-line no-type-assertion/no-type-assertion
              {
                "--skeleton-width": i
              }
            )
          }
        )
      ]
    }
  );
});
sP.displayName = "SidebarMenuSkeleton";
const aP = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "ul",
    {
      ref: n,
      "data-sidebar": "menu-sub",
      className: G(
        "tw-mx-3.5 tw-flex tw-min-w-0 tw-translate-x-px tw-flex-col tw-gap-1 tw-border-l tw-border-sidebar-border tw-px-2.5 tw-py-0.5",
        "group-data-[collapsible=icon]:tw-hidden",
        t
      ),
      ...e
    }
  )
);
aP.displayName = "SidebarMenuSub";
const lP = Y.forwardRef(
  ({ ...t }, e) => /* @__PURE__ */ p("li", { ref: e, ...t })
);
lP.displayName = "SidebarMenuSubItem";
const cP = Y.forwardRef(({ asChild: t = !1, size: e = "md", isActive: n, className: r, ...i }, o) => /* @__PURE__ */ p(
  t ? na : "a",
  {
    ref: o,
    "data-sidebar": "menu-sub-button",
    "data-size": e,
    "data-active": n,
    className: G(
      "tw-flex tw-h-7 tw-min-w-0 tw--translate-x-px tw-items-center tw-gap-2 tw-overflow-hidden tw-rounded-md tw-px-2 tw-text-sidebar-foreground tw-outline-none tw-ring-sidebar-ring hover:tw-bg-sidebar-accent hover:tw-text-sidebar-accent-foreground focus-visible:tw-ring-2 active:tw-bg-sidebar-accent active:tw-text-sidebar-accent-foreground disabled:tw-pointer-events-none disabled:tw-opacity-50 aria-disabled:tw-pointer-events-none aria-disabled:tw-opacity-50 [&>span:last-child]:tw-truncate [&>svg]:tw-size-4 [&>svg]:tw-shrink-0 [&>svg]:tw-text-sidebar-accent-foreground",
      "data-[active=true]:tw-bg-sidebar-accent data-[active=true]:tw-text-sidebar-accent-foreground",
      e === "sm" && "tw-text-xs",
      e === "md" && "tw-text-sm",
      "group-data-[collapsible=icon]:tw-hidden",
      r
    ),
    ...i
  }
));
cP.displayName = "SidebarMenuSubButton";
function uP({
  id: t,
  extensionLabels: e,
  projectInfo: n,
  handleSelectSidebarItem: r,
  selectedSidebarItem: i,
  extensionsSidebarGroupLabel: o,
  projectsSidebarGroupLabel: s,
  buttonPlaceholderText: a,
  className: l
}) {
  const c = be(
    (d, h) => {
      r(d, h);
    },
    [r]
  ), u = be(
    (d) => {
      const h = n.find((g) => g.projectId === d);
      return h ? h.projectName : d;
    },
    [n]
  ), f = be(
    (d) => !i.projectId && d === i.label,
    [i]
  );
  return /* @__PURE__ */ p(
    h2,
    {
      id: t,
      collapsible: "none",
      variant: "inset",
      className: G("tw-w-96 tw-gap-2 tw-overflow-y-auto", l),
      children: /* @__PURE__ */ B(g2, { children: [
        /* @__PURE__ */ B(Uh, { children: [
          /* @__PURE__ */ p(zh, { className: "tw-text-sm", children: o }),
          /* @__PURE__ */ p(Vh, { children: /* @__PURE__ */ p(w2, { children: Object.entries(e).map(([d, h]) => /* @__PURE__ */ p(m2, { children: /* @__PURE__ */ p(
            b2,
            {
              onClick: () => c(d),
              isActive: f(d),
              children: /* @__PURE__ */ p("span", { className: "tw-pl-3", children: h })
            }
          ) }, d)) }) })
        ] }),
        /* @__PURE__ */ B(Uh, { children: [
          /* @__PURE__ */ p(zh, { className: "tw-text-sm", children: s }),
          /* @__PURE__ */ p(Vh, { className: "tw-pl-3", children: /* @__PURE__ */ p(
            Rf,
            {
              buttonVariant: "ghost",
              buttonClassName: G("tw-w-full", {
                "tw-bg-sidebar-accent tw-text-sidebar-accent-foreground": i == null ? void 0 : i.projectId
              }),
              popoverContentClassName: "tw-z-[1000]",
              options: n.flatMap((d) => d.projectId),
              getOptionLabel: u,
              buttonPlaceholder: a,
              onChange: (d) => {
                const h = u(d);
                c(h, d);
              },
              value: (i == null ? void 0 : i.projectId) ?? void 0,
              icon: /* @__PURE__ */ p(g1, {})
            }
          ) })
        ] })
      ] })
    }
  );
}
const Bg = Yn(
  ({ value: t, onSearch: e, placeholder: n, isFullWidth: r, className: i, isDisabled: o = !1, id: s }, a) => {
    const l = Jt();
    return /* @__PURE__ */ B("div", { id: s, className: G("tw-relative", { "tw-w-full": r }, i), children: [
      /* @__PURE__ */ p(
        by,
        {
          className: G(
            "tw-absolute tw-top-1/2 tw-h-4 tw-w-4 tw--translate-y-1/2 tw-transform tw-opacity-50",
            { "tw-right-3": l === "rtl" },
            { "tw-left-3": l === "ltr" }
          )
        }
      ),
      /* @__PURE__ */ p(
        Ca,
        {
          ref: a,
          className: "tw-w-full tw-text-ellipsis tw-pe-9 tw-ps-9",
          placeholder: n,
          value: t,
          onChange: (c) => e(c.target.value),
          disabled: o
        }
      ),
      t && /* @__PURE__ */ B(
        Me,
        {
          variant: "ghost",
          size: "icon",
          className: G(
            "tw-absolute tw-top-1/2 tw-h-7 tw--translate-y-1/2 tw-transform hover:tw-bg-transparent",
            { "tw-left-0": l === "rtl" },
            { "tw-right-0": l === "ltr" }
          ),
          onClick: () => {
            e("");
          },
          children: [
            /* @__PURE__ */ p(Ou, { className: "tw-h-4 tw-w-4" }),
            /* @__PURE__ */ p("span", { className: "tw-sr-only", children: "Clear" })
          ]
        }
      )
    ] });
  }
);
Bg.displayName = "SearchBar";
function i3({
  id: t,
  extensionLabels: e,
  projectInfo: n,
  children: r,
  handleSelectSidebarItem: i,
  selectedSidebarItem: o,
  searchValue: s,
  onSearch: a,
  extensionsSidebarGroupLabel: l,
  projectsSidebarGroupLabel: c,
  buttonPlaceholderText: u
}) {
  return /* @__PURE__ */ B("div", { className: "tw-box-border tw-flex tw-h-full tw-flex-col", children: [
    /* @__PURE__ */ p("div", { className: "tw-box-border tw-flex tw-items-center tw-justify-center tw-py-4", children: /* @__PURE__ */ p(
      Bg,
      {
        className: "tw-w-9/12",
        value: s,
        onSearch: a,
        placeholder: "Search app settings, extension settings, and project settings"
      }
    ) }),
    /* @__PURE__ */ B(
      f2,
      {
        id: t,
        className: "tw-h-full tw-flex-1 tw-gap-4 tw-overflow-auto tw-border-t",
        children: [
          /* @__PURE__ */ p(
            uP,
            {
              className: "tw-w-1/2 tw-min-w-[140px] tw-max-w-[220px] tw-border-e",
              extensionLabels: e,
              projectInfo: n,
              handleSelectSidebarItem: i,
              selectedSidebarItem: o,
              extensionsSidebarGroupLabel: l,
              projectsSidebarGroupLabel: c,
              buttonPlaceholderText: u
            }
          ),
          /* @__PURE__ */ p(p2, { className: "tw-min-w-[215px]", children: r })
        ]
      }
    )
  ] });
}
const Mi = "scrBook", dP = "scrRef", mo = "source", fP = "details", hP = "Scripture Reference", pP = "Scripture Book", y2 = "Type", gP = "Details";
function wP(t, e) {
  const n = e ?? !1;
  return [
    {
      accessorFn: (r) => `${r.start.book} ${r.start.chapterNum}:${r.start.verseNum}`,
      id: Mi,
      header: (t == null ? void 0 : t.scriptureReferenceColumnName) ?? hP,
      cell: (r) => {
        const i = r.row.original;
        return r.row.getIsGrouped() ? nt.bookIdToEnglishName(i.start.book) : r.row.groupingColumnId === Mi ? _s(i.start) : void 0;
      },
      getGroupingValue: (r) => nt.bookIdToNumber(r.start.book),
      sortingFn: (r, i) => Af(r.original.start, i.original.start),
      enableGrouping: !0
    },
    {
      accessorFn: (r) => _s(r.start),
      id: dP,
      header: void 0,
      cell: (r) => {
        const i = r.row.original;
        return r.row.getIsGrouped() ? void 0 : _s(i.start);
      },
      sortingFn: (r, i) => Af(r.original.start, i.original.start),
      enableGrouping: !1
    },
    {
      accessorFn: (r) => r.source.displayName,
      id: mo,
      header: n ? (t == null ? void 0 : t.typeColumnName) ?? y2 : void 0,
      cell: (r) => n || r.row.getIsGrouped() ? r.getValue() : void 0,
      getGroupingValue: (r) => r.source.id,
      sortingFn: (r, i) => r.original.source.displayName.localeCompare(i.original.source.displayName),
      enableGrouping: !0
    },
    {
      accessorFn: (r) => r.detail,
      id: fP,
      header: (t == null ? void 0 : t.detailsColumnName) ?? gP,
      cell: (r) => r.getValue(),
      enableGrouping: !1
    }
  ];
}
const mP = (t) => {
  if (!("offset" in t.start))
    throw new Error("No offset available in range start");
  if (t.end && !("offset" in t.end))
    throw new Error("No offset available in range end");
  const { offset: e } = t.start;
  let n = 0;
  return t.end && ({ offset: n } = t.end), !t.end || Af(t.start, t.end) === 0 ? `${Fd(t.start)}+${e}` : `${Fd(t.start)}+${e}-${Fd(t.end)}+${n}`;
}, py = (t) => `${mP({ start: t.start, end: t.end })} ${t.source.displayName} ${t.detail}`;
function o3({
  sources: t,
  showColumnHeaders: e = !1,
  showSourceColumn: n = !1,
  scriptureReferenceColumnName: r,
  scriptureBookGroupName: i,
  typeColumnName: o,
  detailsColumnName: s,
  onRowSelected: a,
  id: l
}) {
  const [c, u] = ue([]), [f, d] = ue([{ id: Mi, desc: !1 }]), [h, g] = ue({}), w = Ne(
    () => t.flatMap((M) => M.data.map((F) => ({
      ...F,
      source: M.source
    }))),
    [t]
  ), b = Ne(
    () => wP(
      {
        scriptureReferenceColumnName: r,
        typeColumnName: o,
        detailsColumnName: s
      },
      n
    ),
    [r, o, s, n]
  );
  de(() => {
    c.includes(mo) ? d([
      { id: mo, desc: !1 },
      { id: Mi, desc: !1 }
    ]) : d([{ id: Mi, desc: !1 }]);
  }, [c]);
  const _ = _y({
    data: w,
    columns: b,
    state: {
      grouping: c,
      sorting: f,
      rowSelection: h
    },
    onGroupingChange: u,
    onSortingChange: d,
    onRowSelectionChange: g,
    getExpandedRowModel: I1(),
    getGroupedRowModel: O1(),
    getCoreRowModel: Cy(),
    getSortedRowModel: xy(),
    getRowId: py,
    autoResetExpanded: !1,
    enableMultiRowSelection: !1,
    enableSubRowSelection: !1
  });
  de(() => {
    if (a) {
      const M = _.getSelectedRowModel().rowsById, F = Object.keys(M);
      if (F.length === 1) {
        const k = w.find((I) => py(I) === F[0]) || void 0;
        k && a(k);
      }
    }
  }, [h, w, a, _]);
  const y = i ?? pP, C = o ?? y2, D = [
    { label: "No Grouping", value: [] },
    { label: `Group by ${y}`, value: [Mi] },
    { label: `Group by ${C}`, value: [mo] },
    {
      label: `Group by ${y} and ${C}`,
      value: [Mi, mo]
    },
    {
      label: `Group by ${C} and ${y}`,
      value: [mo, Mi]
    }
  ], P = (M) => {
    u(JSON.parse(M));
  }, S = (M, F) => {
    !M.getIsGrouped() && !M.getIsSelected() && M.getToggleSelectedHandler()(F);
  }, L = (M, F) => M.getIsGrouped() ? "" : G("banded-row", F % 2 === 0 ? "even" : "odd"), O = (M, F, k) => {
    if (!((M == null ? void 0 : M.length) === 0 || F.depth < k.column.getGroupedIndex())) {
      if (F.getIsGrouped())
        switch (F.depth) {
          case 1:
            return "tw-ps-4";
          default:
            return;
        }
      switch (F.depth) {
        case 1:
          return "tw-ps-8";
        case 2:
          return "tw-ps-12";
        default:
          return;
      }
    }
  };
  return /* @__PURE__ */ B("div", { id: l, className: "pr-twp tw-flex tw-h-full tw-w-full tw-flex-col", children: [
    !e && /* @__PURE__ */ B(
      Is,
      {
        value: JSON.stringify(c),
        onValueChange: (M) => {
          P(M);
        },
        children: [
          /* @__PURE__ */ p(Ro, { className: "tw-mb-1 tw-mt-2", children: /* @__PURE__ */ p(Rs, {}) }),
          /* @__PURE__ */ p(Po, { position: "item-aligned", children: /* @__PURE__ */ p(mC, { children: D.map((M) => /* @__PURE__ */ p(er, { value: JSON.stringify(M.value), children: M.label }, M.label)) }) })
        ]
      }
    ),
    /* @__PURE__ */ B(Fu, { className: "tw-relative tw-flex tw-flex-col tw-overflow-y-auto tw-p-0", children: [
      e && /* @__PURE__ */ p(Bu, { children: _.getHeaderGroups().map((M) => /* @__PURE__ */ p(hi, { children: M.headers.filter((F) => F.column.columnDef.header).map((F) => (
        /* For sticky column headers to work, we probably need to change the default definition of the shadcn Table component. See https://github.com/shadcn-ui/ui/issues/1151 */
        /* @__PURE__ */ p(il, { colSpan: F.colSpan, className: "top-0 tw-sticky", children: F.isPlaceholder ? void 0 : /* @__PURE__ */ B("div", { children: [
          F.column.getCanGroup() ? /* @__PURE__ */ p(
            Me,
            {
              variant: "ghost",
              title: `Toggle grouping by ${F.column.columnDef.header}`,
              onClick: F.column.getToggleGroupingHandler(),
              type: "button",
              children: F.column.getIsGrouped() ? "ðŸ›‘" : "ðŸ‘Š "
            }
          ) : void 0,
          " ",
          Ga(F.column.columnDef.header, F.getContext())
        ] }) }, F.id)
      )) }, M.id)) }),
      /* @__PURE__ */ p(qu, { children: _.getRowModel().rows.map((M, F) => {
        const k = Jt();
        return /* @__PURE__ */ p(
          hi,
          {
            "data-state": M.getIsSelected() ? "selected" : "",
            className: G(L(M, F)),
            onClick: (I) => S(M, I),
            children: M.getVisibleCells().map((I) => {
              if (!(I.getIsPlaceholder() || I.column.columnDef.enableGrouping && !I.getIsGrouped() && (I.column.columnDef.id !== mo || !n)))
                return /* @__PURE__ */ p(
                  xo,
                  {
                    className: G(
                      I.column.columnDef.id,
                      "tw-p-[1px]",
                      O(c, M, I)
                    ),
                    children: I.getIsGrouped() ? /* @__PURE__ */ B(
                      Me,
                      {
                        variant: "link",
                        onClick: M.getToggleExpandedHandler(),
                        type: "button",
                        children: [
                          M.getIsExpanded() && /* @__PURE__ */ p(Ru, {}),
                          !M.getIsExpanded() && (k === "ltr" ? /* @__PURE__ */ p(Ds, {}) : /* @__PURE__ */ p(Sf, {})),
                          " ",
                          Ga(I.column.columnDef.cell, I.getContext()),
                          " (",
                          M.subRows.length,
                          ")"
                        ]
                      }
                    ) : Ga(I.column.columnDef.cell, I.getContext())
                  },
                  I.id
                );
            })
          },
          M.id
        );
      }) })
    ] })
  ] });
}
const qg = (t, e) => t.filter((n) => {
  try {
    return Wa(n) === e;
  } catch {
    return !1;
  }
}), v2 = (t, e, n) => qg(t, e).every((r) => n.includes(r));
function bP({
  section: t,
  availableBookIds: e,
  selectedBookIds: n,
  onToggle: r,
  localizedStrings: i
}) {
  const o = qg(e, t).length === 0, s = i["%scripture_section_ot_short%"], a = i["%scripture_section_nt_short%"], l = i["%scripture_section_dc_short%"], c = i["%scripture_section_extra_short%"];
  return /* @__PURE__ */ p(
    Me,
    {
      variant: "outline",
      size: "sm",
      onClick: () => r(t),
      className: G(
        v2(e, t, n) && !o && "tw-bg-primary tw-text-primary-foreground hover:tw-bg-primary/70 hover:tw-text-primary-foreground"
      ),
      disabled: o,
      children: rC(
        t,
        s,
        a,
        l,
        c
      )
    }
  );
}
const gy = 5, kf = 6;
function yP({
  availableBookInfo: t,
  selectedBookIds: e,
  onChangeSelectedBookIds: n,
  localizedStrings: r,
  localizedBookNames: i
}) {
  const o = r["%webView_book_selector_books_selected%"], s = r["%webView_book_selector_select_books%"], a = r["%webView_book_selector_search_books%"], l = r["%webView_book_selector_select_all%"], c = r["%webView_book_selector_clear_all%"], u = r["%webView_book_selector_no_book_found%"], f = r["%webView_book_selector_more%"], { otLong: d, ntLong: h, dcLong: g, extraLong: w } = {
    otLong: r == null ? void 0 : r["%scripture_section_ot_long%"],
    ntLong: r == null ? void 0 : r["%scripture_section_nt_long%"],
    dcLong: r == null ? void 0 : r["%scripture_section_dc_long%"],
    extraLong: r == null ? void 0 : r["%scripture_section_extra_long%"]
  }, [b, _] = ue(!1), [y, C] = ue(""), D = ye(void 0), P = ye(!1);
  if (t.length !== nt.allBookIds.length)
    throw new Error("availableBookInfo length must match Canon.allBookIds length");
  const S = Ne(() => nt.allBookIds.filter(
    (R, T) => t[T] === "1" && !nt.isObsolete(nt.bookIdToNumber(R))
  ), [t]), L = Ne(() => {
    if (!y.trim()) {
      const A = {
        [ze.OT]: [],
        [ze.NT]: [],
        [ze.DC]: [],
        [ze.Extra]: []
      };
      return S.forEach((q) => {
        const V = Wa(q);
        A[V].push(q);
      }), A;
    }
    const R = S.filter(
      (A) => ep(A, y, i)
    ), T = {
      [ze.OT]: [],
      [ze.NT]: [],
      [ze.DC]: [],
      [ze.Extra]: []
    };
    return R.forEach((A) => {
      const q = Wa(A);
      T[q].push(A);
    }), T;
  }, [S, y, i]), O = be(
    (R, T = !1) => {
      if (!T || !D.current) {
        n(
          e.includes(R) ? e.filter((W) => W !== R) : [...e, R]
        ), D.current = R;
        return;
      }
      const A = S.findIndex((W) => W === D.current), q = S.findIndex((W) => W === R);
      if (A === -1 || q === -1) return;
      const [V, J] = [
        Math.min(A, q),
        Math.max(A, q)
      ], H = S.slice(V, J + 1).map((W) => W);
      n(
        e.includes(R) ? e.filter((W) => !H.includes(W)) : [.../* @__PURE__ */ new Set([...e, ...H])]
      );
    },
    [e, n, S]
  ), M = (R) => {
    O(R, P.current), P.current = !1;
  }, F = (R, T) => {
    R.preventDefault(), O(T, R.shiftKey);
  }, k = be(
    (R) => {
      const T = qg(S, R).map((A) => A);
      n(
        v2(S, R, e) ? e.filter((A) => !T.includes(A)) : [.../* @__PURE__ */ new Set([...e, ...T])]
      );
    },
    [e, n, S]
  ), I = () => {
    n(S.map((R) => R));
  }, N = () => {
    n([]);
  };
  return /* @__PURE__ */ B("div", { className: "tw-space-y-2", children: [
    /* @__PURE__ */ p("div", { className: "tw-flex tw-flex-wrap tw-gap-2", children: Object.values(ze).map((R) => /* @__PURE__ */ p(
      bP,
      {
        section: R,
        availableBookIds: S,
        selectedBookIds: e,
        onToggle: k,
        localizedStrings: r
      },
      R
    )) }),
    /* @__PURE__ */ B(
      aa,
      {
        open: b,
        onOpenChange: (R) => {
          _(R), R || C("");
        },
        children: [
          /* @__PURE__ */ p(la, { asChild: !0, children: /* @__PURE__ */ B(
            Me,
            {
              variant: "outline",
              role: "combobox",
              "aria-expanded": b,
              className: "tw-max-w-64 tw-justify-between",
              children: [
                e.length > 0 ? `${o}: ${e.length}` : s,
                /* @__PURE__ */ p(Wh, { className: "tw-ml-2 tw-h-4 tw-w-4 tw-shrink-0 tw-opacity-50" })
              ]
            }
          ) }),
          /* @__PURE__ */ p(Zo, { className: "tw-w-full tw-p-0", align: "start", children: /* @__PURE__ */ B(
            ia,
            {
              shouldFilter: !1,
              onKeyDown: (R) => {
                R.key === "Enter" && (P.current = R.shiftKey);
              },
              children: [
                /* @__PURE__ */ p(
                  Dl,
                  {
                    placeholder: a,
                    value: y,
                    onValueChange: C
                  }
                ),
                /* @__PURE__ */ B("div", { className: "tw-flex tw-justify-between tw-border-b tw-p-2", children: [
                  /* @__PURE__ */ p(Me, { variant: "ghost", size: "sm", onClick: I, children: l }),
                  /* @__PURE__ */ p(Me, { variant: "ghost", size: "sm", onClick: N, children: c })
                ] }),
                /* @__PURE__ */ B(oa, { children: [
                  /* @__PURE__ */ p(Lu, { children: u }),
                  Object.values(ze).map((R, T) => {
                    const A = L[R];
                    if (A.length !== 0)
                      return /* @__PURE__ */ B(my, { children: [
                        /* @__PURE__ */ p(
                          Mo,
                          {
                            heading: Py(R, d, h, g, w),
                            children: A.map((q) => /* @__PURE__ */ p(
                              $y,
                              {
                                bookId: q,
                                isSelected: e.includes(q),
                                onSelect: () => M(q),
                                onMouseDown: (V) => F(V, q),
                                section: Wa(q),
                                showCheck: !0,
                                localizedBookNames: i,
                                commandValue: If(q, i),
                                className: "tw-flex tw-items-center"
                              },
                              q
                            ))
                          }
                        ),
                        T < Object.values(ze).length - 1 && /* @__PURE__ */ p(Ty, {})
                      ] }, R);
                  })
                ] })
              ]
            }
          ) })
        ]
      }
    ),
    e.length > 0 && /* @__PURE__ */ B("div", { className: "tw-mt-2 tw-flex tw-flex-wrap tw-gap-1", children: [
      e.slice(
        0,
        e.length === kf ? kf : gy
      ).map((R) => /* @__PURE__ */ p(Vc, { className: "hover:tw-bg-secondary", variant: "secondary", children: xs(R, i) }, R)),
      e.length > kf && /* @__PURE__ */ p(
        Vc,
        {
          className: "hover:tw-bg-secondary",
          variant: "secondary",
          children: `+${e.length - gy} ${f}`
        }
      )
    ] })
  ] });
}
const s3 = Object.freeze([
  "%webView_scope_selector_selected_text%",
  "%webView_scope_selector_current_verse%",
  "%webView_scope_selector_current_chapter%",
  "%webView_scope_selector_current_book%",
  "%webView_scope_selector_choose_books%",
  "%webView_scope_selector_scope%",
  "%webView_scope_selector_select_books%",
  "%webView_book_selector_books_selected%",
  "%webView_book_selector_select_books%",
  "%webView_book_selector_search_books%",
  "%webView_book_selector_select_all%",
  "%webView_book_selector_clear_all%",
  "%webView_book_selector_no_book_found%",
  "%webView_book_selector_more%",
  "%scripture_section_ot_long%",
  "%scripture_section_ot_short%",
  "%scripture_section_nt_long%",
  "%scripture_section_nt_short%",
  "%scripture_section_dc_long%",
  "%scripture_section_dc_short%",
  "%scripture_section_extra_long%",
  "%scripture_section_extra_short%"
]), go = (t, e) => t[e] ?? e;
function a3({
  scope: t,
  availableScopes: e,
  onScopeChange: n,
  availableBookInfo: r,
  selectedBookIds: i,
  onSelectedBookIdsChange: o,
  localizedStrings: s,
  localizedBookNames: a,
  id: l
}) {
  const c = go(
    s,
    "%webView_scope_selector_selected_text%"
  ), u = go(
    s,
    "%webView_scope_selector_current_verse%"
  ), f = go(
    s,
    "%webView_scope_selector_current_chapter%"
  ), d = go(s, "%webView_scope_selector_current_book%"), h = go(s, "%webView_scope_selector_choose_books%"), g = go(s, "%webView_scope_selector_scope%"), w = go(s, "%webView_scope_selector_select_books%"), b = [
    { value: "selectedText", label: c, id: "scope-selected-text" },
    { value: "verse", label: u, id: "scope-verse" },
    { value: "chapter", label: f, id: "scope-chapter" },
    { value: "book", label: d, id: "scope-book" },
    { value: "selectedBooks", label: h, id: "scope-selected" }
  ], _ = e ? b.filter((y) => e.includes(y.value)) : b;
  return /* @__PURE__ */ B("div", { id: l, className: "tw-grid tw-gap-4", children: [
    /* @__PURE__ */ B("div", { className: "tw-grid tw-gap-2", children: [
      /* @__PURE__ */ p(Vt, { children: g }),
      /* @__PURE__ */ p(
        tp,
        {
          value: t,
          onValueChange: n,
          className: "tw-flex tw-flex-col tw-space-y-1",
          children: _.map(({ value: y, label: C, id: D }) => /* @__PURE__ */ B("div", { className: "tw-flex tw-items-center", children: [
            /* @__PURE__ */ p(zc, { className: "tw-me-2", value: y, id: D }),
            /* @__PURE__ */ p(Vt, { htmlFor: D, children: C })
          ] }, D))
        }
      )
    ] }),
    t === "selectedBooks" && /* @__PURE__ */ B("div", { className: "tw-grid tw-gap-2", children: [
      /* @__PURE__ */ p(Vt, { children: w }),
      /* @__PURE__ */ p(
        yP,
        {
          availableBookInfo: r,
          selectedBookIds: i,
          onChangeSelectedBookIds: o,
          localizedStrings: s,
          localizedBookNames: a
        }
      )
    ] })
  ] });
}
const Ef = {
  [tt("undefined")]: "Ã˜",
  [tt(0)]: "A",
  [tt(1)]: "B",
  [tt(2)]: "C",
  [tt(3)]: "D",
  [tt(4)]: "E",
  [tt(5)]: "F",
  [tt(6)]: "G",
  [tt(7)]: "H",
  [tt(8)]: "I",
  [tt(9)]: "J",
  [tt(10)]: "K",
  [tt(11)]: "L",
  [tt(12)]: "M",
  [tt(13)]: "N",
  [tt(14)]: "O",
  [tt(15)]: "P",
  [tt(16)]: "Q",
  [tt(17)]: "R",
  [tt(18)]: "S",
  [tt(19)]: "T",
  [tt(20)]: "U",
  [tt(21)]: "V",
  [tt(22)]: "W",
  [tt(23)]: "X",
  [tt(24)]: "Y",
  [tt(25)]: "Z"
};
function l3({
  availableScrollGroupIds: t,
  scrollGroupId: e,
  onChangeScrollGroupId: n,
  localizedStrings: r = {},
  size: i = "sm",
  className: o,
  id: s
}) {
  const a = {
    ...Ef,
    ...Object.fromEntries(
      Object.entries(r).map(
        ([c, u]) => [
          c,
          c === u && c in Ef ? Ef[c] : u
        ]
      )
    )
  }, l = Jt();
  return /* @__PURE__ */ B(
    Is,
    {
      value: `${e}`,
      onValueChange: (c) => n(
        c === "undefined" ? void 0 : parseInt(c, 10)
      ),
      children: [
        /* @__PURE__ */ p(Ro, { size: i, className: G("pr-twp tw-w-auto", o), children: /* @__PURE__ */ p(
          Rs,
          {
            placeholder: a[tt(e)] ?? e
          }
        ) }),
        /* @__PURE__ */ p(
          Po,
          {
            id: s,
            align: l === "rtl" ? "end" : "start",
            style: { zIndex: 250 },
            children: t.map((c) => /* @__PURE__ */ p(er, { value: `${c}`, children: a[tt(c)] }, `${c}`))
          }
        )
      ]
    }
  );
}
function c3({ children: t }) {
  return /* @__PURE__ */ p("div", { className: "pr-twp tw-grid", children: t });
}
function u3({
  primary: t,
  secondary: e,
  children: n,
  isLoading: r = !1,
  loadingMessage: i
}) {
  return /* @__PURE__ */ B("div", { className: "tw-flex tw-items-center tw-justify-between tw-space-x-4 tw-py-2", children: [
    /* @__PURE__ */ B("div", { children: [
      /* @__PURE__ */ p("p", { className: "tw-text-sm tw-font-medium tw-leading-none", children: t }),
      /* @__PURE__ */ p("p", { className: "tw-whitespace-normal tw-break-words tw-text-sm tw-text-muted-foreground", children: e })
    ] }),
    r ? /* @__PURE__ */ p("p", { className: "tw-text-sm tw-text-muted-foreground", children: i }) : /* @__PURE__ */ p("div", { children: n })
  ] });
}
function d3({
  primary: t,
  secondary: e,
  includeSeparator: n = !1
}) {
  return /* @__PURE__ */ B("div", { className: "tw-space-y-4 tw-py-2", children: [
    /* @__PURE__ */ B("div", { children: [
      /* @__PURE__ */ p("h3", { className: "tw-text-lg tw-font-medium", children: t }),
      /* @__PURE__ */ p("p", { className: "tw-text-sm tw-text-muted-foreground", children: e })
    ] }),
    n ? /* @__PURE__ */ p(Pg, {}) : ""
  ] });
}
function _2(t, e) {
  var n;
  return (n = Object.entries(t).find(
    ([, r]) => "menuItem" in r && r.menuItem === e
  )) == null ? void 0 : n[0];
}
function Mu({ icon: t, menuLabel: e, leading: n }) {
  return t ? /* @__PURE__ */ p(
    "img",
    {
      className: G("tw-max-h-5 tw-max-w-5", n ? "tw-me-2" : "tw-ms-2"),
      src: t,
      alt: `${n ? "Leading" : "Trailing"} icon for ${e}`
    }
  ) : void 0;
}
const x2 = (t, e, n, r) => n ? Object.entries(t).filter(
  ([o, s]) => "column" in s && s.column === n || o === n
).sort(([, o], [, s]) => o.order - s.order).flatMap(([o]) => e.filter((a) => a.group === o).sort((a, l) => a.order - l.order).map((a) => /* @__PURE__ */ B($g, { children: [
  /* @__PURE__ */ p(Fg, { asChild: !0, children: "command" in a ? /* @__PURE__ */ B(
    jy,
    {
      onClick: () => {
        r(a);
      },
      children: [
        a.iconPathBefore && /* @__PURE__ */ p(Mu, { icon: a.iconPathBefore, menuLabel: a.label, leading: !0 }),
        a.label,
        a.iconPathAfter && /* @__PURE__ */ p(Mu, { icon: a.iconPathAfter, menuLabel: a.label })
      ]
    },
    `dropdown-menu-item-${a.label}-${a.command}`
  ) : /* @__PURE__ */ B(pC, { children: [
    /* @__PURE__ */ p(By, { children: a.label }),
    /* @__PURE__ */ p(hC, { children: /* @__PURE__ */ p(qy, { children: x2(
      t,
      e,
      _2(t, a.id),
      r
    ) }) })
  ] }, `dropdown-menu-sub-${a.label}-${a.id}`) }),
  a.tooltip && /* @__PURE__ */ p(gd, { children: a.tooltip })
] }, `tooltip-${a.label}-${"command" in a ? a.command : a.id}`))) : void 0;
function Hh({
  onSelectMenuItem: t,
  menuData: e,
  tabLabel: n,
  icon: r,
  className: i,
  variant: o,
  buttonVariant: s = "ghost",
  id: a
}) {
  return /* @__PURE__ */ B(Os, { variant: o, children: [
    /* @__PURE__ */ p(nl, { "aria-label": n, className: i, asChild: !0, id: a, children: /* @__PURE__ */ p(Me, { variant: s, size: "icon", children: r ?? /* @__PURE__ */ p(w1, {}) }) }),
    /* @__PURE__ */ p(Io, { align: "start", className: "tw-z-[250]", children: Object.entries(e.columns).filter(([, l]) => typeof l == "object").sort(([, l], [, c]) => typeof l == "boolean" || typeof c == "boolean" ? 0 : l.order - c.order).map(([l], c, u) => /* @__PURE__ */ B(my, { children: [
      /* @__PURE__ */ p(Fy, { children: /* @__PURE__ */ p(Lg, { children: x2(e.groups, e.items, l, t) }) }),
      c < u.length - 1 && /* @__PURE__ */ p(Ml, {})
    ] }, l)) })
  ] });
}
const C2 = Y.forwardRef(
  ({ id: t, className: e, children: n }, r) => /* @__PURE__ */ p(
    "div",
    {
      ref: r,
      className: `tw-sticky tw-top-0 tw-box-border tw-flex tw-h-14 tw-flex-row tw-items-center tw-justify-between tw-gap-2 tw-overflow-clip tw-px-4 tw-py-2 tw-text-foreground tw-@container/toolbar ${e}`,
      id: t,
      children: n
    }
  )
);
function f3({
  onSelectProjectMenuItem: t,
  onSelectViewInfoMenuItem: e,
  projectMenuData: n,
  tabViewMenuData: r,
  id: i,
  className: o,
  startAreaChildren: s,
  centerAreaChildren: a,
  endAreaChildren: l,
  menuButtonIcon: c
}) {
  return /* @__PURE__ */ B(C2, { className: `tw-w-full tw-border ${o}`, id: i, children: [
    n && /* @__PURE__ */ p(
      Hh,
      {
        onSelectMenuItem: t,
        menuData: n,
        tabLabel: "Project",
        icon: c ?? /* @__PURE__ */ p(m1, {}),
        buttonVariant: "ghost"
      }
    ),
    s && /* @__PURE__ */ p("div", { className: "tw-flex tw-h-full tw-shrink tw-grow-[2] tw-flex-row tw-flex-wrap tw-items-start tw-gap-2 tw-overflow-clip tw-@container/tab-toolbar-start", children: s }),
    a && /* @__PURE__ */ p("div", { className: "tw-flex tw-h-full tw-shrink tw-basis-0 tw-flex-row tw-flex-wrap tw-items-start tw-justify-center tw-gap-2 tw-overflow-clip tw-@container/tab-toolbar-center @sm:tw-grow @sm:tw-basis-auto", children: a }),
    /* @__PURE__ */ B("div", { className: "tw-flex tw-h-full tw-shrink tw-grow-[2] tw-flex-row-reverse tw-flex-wrap tw-items-start tw-gap-2 tw-overflow-clip tw-@container/tab-toolbar-end", children: [
      r && /* @__PURE__ */ p(
        Hh,
        {
          onSelectMenuItem: e,
          menuData: r,
          tabLabel: "View Info",
          icon: /* @__PURE__ */ p(b1, {}),
          className: "tw-h-full"
        }
      ),
      l
    ] })
  ] });
}
function h3({
  onSelectProjectMenuItem: t,
  projectMenuData: e,
  id: n,
  className: r,
  menuButtonIcon: i
}) {
  return /* @__PURE__ */ p(C2, { className: "tw-pointer-events-none", id: n, children: e && /* @__PURE__ */ p(
    Hh,
    {
      onSelectMenuItem: t,
      menuData: e,
      tabLabel: "Project",
      icon: i,
      className: `tw-pointer-events-auto tw-shadow-lg ${r}`,
      buttonVariant: "outline"
    }
  ) });
}
const k2 = Y.forwardRef(({ className: t, ...e }, n) => {
  const r = Jt();
  return /* @__PURE__ */ p(
    Pn.Root,
    {
      orientation: "vertical",
      ref: n,
      className: G("tw-flex tw-gap-1 tw-rounded-md tw-text-muted-foreground", t),
      ...e,
      dir: r
    }
  );
});
k2.displayName = Pn.List.displayName;
const E2 = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Pn.List,
  {
    ref: n,
    className: G(
      "tw-flex-fit tw-mlk-items-center tw-w-[124px] tw-justify-center tw-rounded-md tw-bg-muted tw-p-1 tw-text-muted-foreground",
      t
    ),
    ...e
  }
));
E2.displayName = Pn.List.displayName;
const vP = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Pn.Trigger,
  {
    ref: n,
    ...e,
    className: G(
      "overflow-clip tw-inline-flex tw-w-[116px] tw-cursor-pointer tw-items-center tw-justify-center tw-break-words tw-rounded-sm tw-border-0 tw-bg-muted tw-px-3 tw-py-1.5 tw-text-sm tw-font-medium tw-text-inherit tw-ring-offset-background tw-transition-all hover:tw-text-foreground focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-pointer-events-none disabled:tw-opacity-50 data-[state=active]:tw-bg-background data-[state=active]:tw-text-foreground data-[state=active]:tw-shadow-sm",
      t
    )
  }
)), N2 = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Pn.Content,
  {
    ref: n,
    className: G(
      // Removed tw-mt-2 because Sebastian said so
      "tw-ms-5 tw-flex-grow tw-text-foreground tw-ring-offset-background focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2",
      t
    ),
    ...e
  }
));
N2.displayName = Pn.Content.displayName;
function p3({
  tabList: t,
  searchValue: e,
  onSearch: n,
  searchPlaceholder: r,
  headerTitle: i,
  searchClassName: o,
  id: s
}) {
  return /* @__PURE__ */ B("div", { id: s, className: "pr-twp", children: [
    /* @__PURE__ */ B("div", { className: "tw-sticky tw-top-0 tw-space-y-2 tw-pb-2", children: [
      i ? /* @__PURE__ */ p("h1", { children: i }) : "",
      /* @__PURE__ */ p(
        Bg,
        {
          className: o,
          value: e,
          onSearch: n,
          placeholder: r
        }
      )
    ] }),
    /* @__PURE__ */ B(k2, { children: [
      /* @__PURE__ */ p(E2, { children: t.map((a) => /* @__PURE__ */ p(vP, { value: a.value, children: a.value }, a.key)) }),
      t.map((a) => /* @__PURE__ */ p(N2, { value: a.value, children: a.content }, a.key))
    ] })
  ] });
}
function _P({ ...t }) {
  return /* @__PURE__ */ p(ht.Menu, { ...t });
}
function xP({ ...t }) {
  return /* @__PURE__ */ p(ht.Sub, { "data-slot": "menubar-sub", ...t });
}
const S2 = Y.forwardRef(({ className: t, variant: e = "default", ...n }, r) => {
  const i = Y.useMemo(
    () => ({
      variant: e
    }),
    [e]
  );
  return /* @__PURE__ */ p(np.Provider, { value: i, children: /* @__PURE__ */ p(
    ht.Root,
    {
      ref: r,
      className: G(
        "tw-flex tw-h-10 tw-items-center tw-space-x-1 tw-rounded-md tw-border tw-bg-background tw-p-1",
        t
      ),
      ...n
    }
  ) });
});
S2.displayName = ht.Root.displayName;
const T2 = Y.forwardRef(({ className: t, ...e }, n) => {
  const r = Sr();
  return /* @__PURE__ */ p(
    ht.Trigger,
    {
      ref: n,
      className: G(
        "tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-3 tw-py-1.5 tw-text-sm tw-font-medium tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[state=open]:tw-bg-accent data-[state=open]:tw-text-accent-foreground",
        // CUSTOM
        "pr-twp",
        Ci({ variant: r.variant, className: t })
        // CUSTOM use context to add variants
      ),
      ...e
    }
  );
});
T2.displayName = ht.Trigger.displayName;
const A2 = Y.forwardRef(({ className: t, inset: e, children: n, ...r }, i) => {
  const o = Sr();
  return /* @__PURE__ */ B(
    ht.SubTrigger,
    {
      ref: i,
      className: G(
        "tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[state=open]:tw-bg-accent data-[state=open]:tw-text-accent-foreground",
        e && "tw-pl-8",
        Ci({ variant: o.variant, className: t }),
        // CUSTOM use context to add variants
        t
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ p(Ds, { className: "tw-ml-auto tw-h-4 tw-w-4" })
      ]
    }
  );
});
A2.displayName = ht.SubTrigger.displayName;
const D2 = Y.forwardRef(({ className: t, ...e }, n) => {
  const r = Sr();
  return /* @__PURE__ */ p(
    ht.SubContent,
    {
      ref: n,
      className: G(
        "tw-z-50 tw-min-w-[8rem] tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-p-1 tw-text-popover-foreground data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
        // CUSTOM use context to add variants
        {
          "tw-bg-popover": r.variant === "muted"
        },
        t
      ),
      ...e
    }
  );
});
D2.displayName = ht.SubContent.displayName;
const M2 = Y.forwardRef(({ className: t, align: e = "start", alignOffset: n = -4, sideOffset: r = 8, ...i }, o) => {
  const s = Sr();
  return /* @__PURE__ */ p(ht.Portal, { children: /* @__PURE__ */ p(
    ht.Content,
    {
      ref: o,
      align: e,
      alignOffset: n,
      sideOffset: r,
      className: G(
        "tw-z-50 tw-min-w-[12rem] tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-p-1 tw-text-popover-foreground tw-shadow-md data-[state=open]:tw-animate-in data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
        // CUSTOM reset styles so that only shadcn styles are applied
        "pr-twp",
        // CUSTOM use context to add variants
        {
          "tw-bg-popover": s.variant === "muted"
        },
        t
      ),
      ...i
    }
  ) });
});
M2.displayName = ht.Content.displayName;
const O2 = Y.forwardRef(({ className: t, inset: e, ...n }, r) => {
  const i = Sr();
  return /* @__PURE__ */ p(
    ht.Item,
    {
      ref: r,
      className: G(
        "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
        e && "tw-pl-8",
        Ci({ variant: i.variant, className: t }),
        // CUSTOM use context to add variants
        t
      ),
      ...n
    }
  );
});
O2.displayName = ht.Item.displayName;
const CP = Y.forwardRef(({ className: t, children: e, checked: n, ...r }, i) => {
  const o = Sr();
  return /* @__PURE__ */ B(
    ht.CheckboxItem,
    {
      ref: i,
      className: G(
        "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pl-8 tw-pr-2 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
        Ci({ variant: o.variant, className: t }),
        // CUSTOM use context to add variants
        t
      ),
      checked: n,
      ...r,
      children: [
        /* @__PURE__ */ p("span", { className: "tw-absolute tw-left-2 tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center", children: /* @__PURE__ */ p(ht.ItemIndicator, { children: /* @__PURE__ */ p(xi, { className: "tw-h-4 tw-w-4" }) }) }),
        e
      ]
    }
  );
});
CP.displayName = ht.CheckboxItem.displayName;
const kP = Y.forwardRef(({ className: t, children: e, ...n }, r) => {
  const i = Sr();
  return /* @__PURE__ */ B(
    ht.RadioItem,
    {
      ref: r,
      className: G(
        "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pl-8 tw-pr-2 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
        Ci({ variant: i.variant, className: t }),
        // CUSTOM use context to add variants
        t
      ),
      ...n,
      children: [
        /* @__PURE__ */ p("span", { className: "tw-absolute tw-left-2 tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center", children: /* @__PURE__ */ p(ht.ItemIndicator, { children: /* @__PURE__ */ p(Iu, { className: "tw-h-2 tw-w-2 tw-fill-current" }) }) }),
        e
      ]
    }
  );
});
kP.displayName = ht.RadioItem.displayName;
const EP = Y.forwardRef(({ className: t, inset: e, ...n }, r) => /* @__PURE__ */ p(
  ht.Label,
  {
    ref: r,
    className: G("tw-px-2 tw-py-1.5 tw-text-sm tw-font-semibold", e && "tw-pl-8", t),
    ...n
  }
));
EP.displayName = ht.Label.displayName;
const I2 = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  ht.Separator,
  {
    ref: n,
    className: G("tw--mx-1 tw-my-1 tw-h-px tw-bg-muted", t),
    ...e
  }
));
I2.displayName = ht.Separator.displayName;
const Fa = (t, e) => {
  setTimeout(() => {
    e.forEach((n) => {
      var r;
      (r = t.current) == null || r.dispatchEvent(new KeyboardEvent("keydown", n));
    });
  }, 0);
}, R2 = (t, e, n, r) => {
  if (!n) return;
  const i = Object.entries(t).filter(
    ([o, s]) => "column" in s && s.column === n || o === n
  ).sort(([, o], [, s]) => o.order - s.order);
  return i.flatMap(([o], s) => {
    const a = e.filter((c) => c.group === o).sort((c, u) => c.order - u.order).map((c) => /* @__PURE__ */ B($g, { children: [
      /* @__PURE__ */ p(Fg, { asChild: !0, children: "command" in c ? /* @__PURE__ */ B(
        O2,
        {
          onClick: () => {
            r(c);
          },
          children: [
            c.iconPathBefore && /* @__PURE__ */ p(Mu, { icon: c.iconPathBefore, menuLabel: c.label, leading: !0 }),
            c.label,
            c.iconPathAfter && /* @__PURE__ */ p(Mu, { icon: c.iconPathAfter, menuLabel: c.label })
          ]
        },
        `menubar-item-${c.label}-${c.command}`
      ) : /* @__PURE__ */ B(xP, { children: [
        /* @__PURE__ */ p(A2, { children: c.label }),
        /* @__PURE__ */ p(D2, { children: R2(
          t,
          e,
          _2(t, c.id),
          r
        ) })
      ] }, `menubar-sub-${c.label}-${c.id}`) }),
      c.tooltip && /* @__PURE__ */ p(gd, { children: c.tooltip })
    ] }, `tooltip-${c.label}-${"command" in c ? c.command : c.id}`)), l = [...a];
    return a.length > 0 && s < i.length - 1 && l.push(/* @__PURE__ */ p(I2, {}, `separator-${o}`)), l;
  });
};
function NP({
  menuData: t,
  onSelectMenuItem: e,
  onOpenChange: n,
  variant: r
}) {
  const i = ye(void 0), o = ye(void 0), s = ye(void 0), a = ye(void 0), l = ye(void 0), c = (u) => {
    switch (u) {
      case "platform.app":
        return o;
      case "platform.window":
        return s;
      case "platform.layout":
        return a;
      case "platform.help":
        return l;
      default:
        return;
    }
  };
  if ($1(["alt", "alt+p", "alt+l", "alt+n", "alt+h"], (u, f) => {
    var g, w, b, _;
    u.preventDefault();
    const d = { key: "Escape", code: "Escape", keyCode: 27, bubbles: !0 }, h = { key: " ", code: "Space", keyCode: 32, bubbles: !0 };
    switch (f.hotkey) {
      case "alt":
        Fa(o, [d]);
        break;
      case "alt+p":
        (g = o.current) == null || g.focus(), Fa(o, [d, h]);
        break;
      case "alt+l":
        (w = s.current) == null || w.focus(), Fa(s, [d, h]);
        break;
      case "alt+n":
        (b = a.current) == null || b.focus(), Fa(a, [d, h]);
        break;
      case "alt+h":
        (_ = l.current) == null || _.focus(), Fa(l, [d, h]);
        break;
    }
  }), de(() => {
    if (!n || !i.current) return;
    const u = new MutationObserver((h) => {
      h.forEach((g) => {
        if (g.attributeName === "data-state" && g.target instanceof HTMLElement) {
          const w = g.target.getAttribute("data-state");
          n(w === "open");
        }
      });
    });
    return i.current.querySelectorAll("[data-state]").forEach((h) => {
      u.observe(h, { attributes: !0 });
    }), () => u.disconnect();
  }, [n]), !!t)
    return /* @__PURE__ */ p(S2, { ref: i, className: "pr-twp tw-border-0 tw-bg-transparent", variant: r, children: Object.entries(t.columns).filter(([, u]) => typeof u == "object").sort(([, u], [, f]) => typeof u == "boolean" || typeof f == "boolean" ? 0 : u.order - f.order).map(([u, f]) => /* @__PURE__ */ B(_P, { children: [
      /* @__PURE__ */ p(T2, { ref: c(u), children: typeof f == "object" && "label" in f && f.label }),
      /* @__PURE__ */ p(
        M2,
        {
          className: "tw-z-[250]",
          children: /* @__PURE__ */ p(Lg, { children: R2(t.groups, t.items, u, e) })
        }
      )
    ] }, u)) });
}
function g3(t) {
  switch (t) {
    case void 0:
      return;
    case "darwin":
      return "tw-ps-[85px]";
    default:
      return "tw-pe-[calc(138px+1rem)]";
  }
}
function w3({
  menuData: t,
  onOpenChange: e,
  onSelectMenuItem: n,
  className: r,
  id: i,
  children: o,
  appMenuAreaChildren: s,
  configAreaChildren: a,
  shouldUseAsAppDragArea: l,
  menubarVariant: c = "default"
}) {
  const u = ye(void 0);
  return /* @__PURE__ */ p(
    "div",
    {
      className: G("tw-border tw-px-4 tw-text-foreground", r),
      ref: u,
      style: { position: "relative" },
      id: i,
      children: /* @__PURE__ */ B(
        "div",
        {
          className: "tw-flex tw-h-full tw-w-full tw-justify-between tw-overflow-hidden",
          style: l ? { WebkitAppRegion: "drag" } : void 0,
          children: [
            /* @__PURE__ */ p("div", { className: "tw-flex tw-grow tw-basis-0", children: /* @__PURE__ */ B(
              "div",
              {
                className: "tw-flex tw-items-center tw-gap-2",
                style: l ? { WebkitAppRegion: "no-drag" } : void 0,
                children: [
                  s,
                  t && /* @__PURE__ */ p(
                    NP,
                    {
                      menuData: t,
                      onOpenChange: e,
                      onSelectMenuItem: n,
                      variant: c
                    }
                  )
                ]
              }
            ) }),
            /* @__PURE__ */ p(
              "div",
              {
                className: "tw-flex tw-items-center tw-gap-2 tw-px-2",
                style: l ? { WebkitAppRegion: "no-drag" } : void 0,
                children: o
              }
            ),
            /* @__PURE__ */ p("div", { className: "tw-flex tw-min-w-0 tw-grow tw-basis-0 tw-justify-end", children: /* @__PURE__ */ p(
              "div",
              {
                className: "tw-flex tw-min-w-0 tw-items-center tw-gap-2 tw-pe-1",
                style: l ? { WebkitAppRegion: "no-drag" } : void 0,
                children: a
              }
            ) })
          ]
        }
      )
    }
  );
}
const SP = (t, e) => t[e] ?? e;
function m3({
  knownUiLanguages: t,
  primaryLanguage: e = "en",
  fallbackLanguages: n = [],
  onLanguagesChange: r,
  onPrimaryLanguageChange: i,
  onFallbackLanguagesChange: o,
  localizedStrings: s,
  className: a,
  id: l
}) {
  const c = SP(
    s,
    "%settings_uiLanguageSelector_fallbackLanguages%"
  ), [u, f] = ue(!1), d = (g) => {
    i && i(g), r && r([g, ...n.filter((w) => w !== g)]), o && n.find((w) => w === g) && o([...n.filter((w) => w !== g)]), f(!1);
  }, h = (g, w) => {
    var _, y, C, D, P, S;
    const b = w !== g ? ((y = (_ = t[g]) == null ? void 0 : _.uiNames) == null ? void 0 : y[w]) ?? ((D = (C = t[g]) == null ? void 0 : C.uiNames) == null ? void 0 : D.en) : void 0;
    return b ? `${(P = t[g]) == null ? void 0 : P.autonym} (${b})` : (S = t[g]) == null ? void 0 : S.autonym;
  };
  return /* @__PURE__ */ B("div", { id: l, className: G("pr-twp tw-max-w-sm", a), children: [
    /* @__PURE__ */ B(
      Is,
      {
        name: "uiLanguage",
        value: e,
        onValueChange: d,
        open: u,
        onOpenChange: (g) => f(g),
        children: [
          /* @__PURE__ */ p(Ro, { children: /* @__PURE__ */ p(Rs, {}) }),
          /* @__PURE__ */ p(
            Po,
            {
              className: "tw-z-[250]",
              children: Object.keys(t).map((g) => /* @__PURE__ */ p(er, { value: g, children: h(g, e) }, g))
            }
          )
        ]
      }
    ),
    e !== "en" && /* @__PURE__ */ p("div", { className: "tw-pt-3", children: /* @__PURE__ */ p(Vt, { className: "tw-font-normal tw-text-muted-foreground", children: A1(c, {
      fallbackLanguages: (n == null ? void 0 : n.length) > 0 ? n.map((g) => h(g, e)).join(", ") : t.en.autonym
    }) }) })
  ] });
}
function TP({ item: t, createLabel: e, createComplexLabel: n }) {
  return e ? /* @__PURE__ */ p(Vt, { children: e(t) }) : n ? /* @__PURE__ */ p(Vt, { children: n(t) }) : /* @__PURE__ */ p(Vt, { children: t });
}
function b3({
  id: t,
  className: e,
  listItems: n,
  selectedListItems: r,
  handleSelectListItem: i,
  createLabel: o,
  createComplexLabel: s
}) {
  return /* @__PURE__ */ p("div", { id: t, className: e, children: n.map((a) => /* @__PURE__ */ B("div", { className: "tw-m-2 tw-flex tw-items-center", children: [
    /* @__PURE__ */ p(
      Rg,
      {
        className: "tw-me-2 tw-align-middle",
        checked: r.includes(a),
        onCheckedChange: (l) => i(a, l)
      }
    ),
    /* @__PURE__ */ p(
      TP,
      {
        item: a,
        createLabel: o,
        createComplexLabel: s
      }
    )
  ] }, a)) });
}
function y3({
  cardKey: t,
  isSelected: e,
  onSelect: n,
  isDenied: r,
  isHidden: i = !1,
  className: o,
  children: s,
  dropdownContent: a,
  additionalSelectedContent: l,
  accentColor: c
}) {
  return /* @__PURE__ */ B(
    "div",
    {
      hidden: i,
      onClick: n,
      onKeyDown: (f) => {
        (f.key === "Enter" || f.key === " ") && (f.preventDefault(), n());
      },
      role: "button",
      tabIndex: 0,
      "aria-pressed": e,
      className: G(
        "tw-relative tw-min-w-36 tw-rounded-xl tw-border tw-shadow-none hover:tw-bg-muted/50",
        { "tw-opacity-50 hover:tw-opacity-100": r && !e },
        { "tw-bg-accent": e },
        { "tw-bg-transparent": !e },
        o
      ),
      children: [
        /* @__PURE__ */ B("div", { className: "tw-flex tw-flex-col tw-gap-2 tw-p-4", children: [
          /* @__PURE__ */ B("div", { className: "tw-flex tw-justify-between tw-overflow-hidden", children: [
            /* @__PURE__ */ p("div", { className: "tw-min-w-0 tw-flex-1", children: s }),
            e && a && /* @__PURE__ */ B(Os, { children: [
              /* @__PURE__ */ p(nl, { className: G(c && "tw-me-1"), asChild: !0, children: /* @__PURE__ */ p(Me, { className: "tw-m-1 tw-h-6 tw-w-6", variant: "ghost", size: "icon", children: /* @__PURE__ */ p(y1, {}) }) }),
              /* @__PURE__ */ p(Io, { align: "end", children: a })
            ] })
          ] }),
          e && l && /* @__PURE__ */ p("div", { className: "tw-w-fit tw-min-w-0 tw-max-w-full tw-overflow-hidden", children: l })
        ] }),
        c && /* @__PURE__ */ p(
          "div",
          {
            className: `tw-absolute tw-right-0 tw-top-0 tw-h-full tw-w-2 tw-rounded-r-xl ${c}`
          }
        )
      ]
    },
    t
  );
}
const AP = Yn(({ className: t, ...e }, n) => /* @__PURE__ */ p(v1, { size: 35, className: G("tw-animate-spin", t), ...e, ref: n }));
AP.displayName = "Spinner";
function v3({
  id: t,
  isDisabled: e = !1,
  hasError: n = !1,
  isFullWidth: r = !1,
  helperText: i,
  label: o,
  placeholder: s,
  isRequired: a = !1,
  className: l,
  defaultValue: c,
  value: u,
  onChange: f,
  onFocus: d,
  onBlur: h
}) {
  return /* @__PURE__ */ B("div", { className: G("tw-inline-grid tw-items-center tw-gap-1.5", { "tw-w-full": r }), children: [
    /* @__PURE__ */ p(
      Vt,
      {
        htmlFor: t,
        className: G({
          "tw-text-red-600": n,
          "tw-hidden": !o
        }),
        children: `${o}${a ? "*" : ""}`
      }
    ),
    /* @__PURE__ */ p(
      Ca,
      {
        id: t,
        disabled: e,
        placeholder: s,
        required: a,
        className: G(l, { "tw-border-red-600": n }),
        defaultValue: c,
        value: u,
        onChange: f,
        onFocus: d,
        onBlur: h
      }
    ),
    /* @__PURE__ */ p("p", { className: G({ "tw-hidden": !i }), children: i })
  ] });
}
const DP = Xi(
  // CUSTOM: Copied all `svg` arbitrary selector variant classes as `img` variants so we can use
  // images (or svgs from file) as icons
  // Implemented by TJ Couch
  // Approved by Alex Mercado
  // 20 February 2025
  "tw-relative tw-w-full tw-rounded-lg tw-border tw-p-4 [&>svg~*]:tw-pl-7 [&>svg+div]:tw-translate-y-[-3px] [&>svg]:tw-absolute [&>svg]:tw-left-4 [&>svg]:tw-top-4 [&>svg]:tw-text-foreground [&>img~*]:tw-pl-7 [&>img+div]:tw-translate-y-[-3px] [&>img]:tw-absolute [&>img]:tw-left-4 [&>img]:tw-top-4 [&>img]:tw-text-foreground",
  {
    variants: {
      variant: {
        default: "tw-bg-background tw-text-foreground",
        destructive: (
          // CUSTOM: Copied all `svg` arbitrary selector variant classes as `img` variants so we can
          // use images (or svgs from file) as icons
          // Implemented by TJ Couch
          // Approved by Alex Mercado
          // 20 February 2025
          "tw-border-destructive/50 tw-text-destructive dark:tw-border-destructive [&>svg]:tw-text-destructive [&>img]:tw-text-destructive"
        )
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), MP = Y.forwardRef(({ className: t, variant: e, ...n }, r) => /* @__PURE__ */ p(
  "div",
  {
    ref: r,
    role: "alert",
    className: G(
      // CUSTOM
      "pr-twp",
      DP({ variant: e }),
      t
    ),
    ...n
  }
));
MP.displayName = "Alert";
const OP = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ B(
    "h5",
    {
      ref: n,
      className: G("tw-mb-1 tw-font-medium tw-leading-none tw-tracking-tight", t),
      ...e,
      children: [
        e.children,
        " "
      ]
    }
  )
);
OP.displayName = "AlertTitle";
const IP = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p("div", { ref: n, className: G("tw-text-sm [&_p]:tw-leading-relaxed", t), ...e }));
IP.displayName = "AlertDescription";
const RP = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  ra.Root,
  {
    ref: n,
    className: G(
      "pr-twp tw-relative tw-flex tw-h-10 tw-w-10 tw-shrink-0 tw-overflow-hidden tw-rounded-full",
      t
    ),
    ...e
  }
));
RP.displayName = ra.Root.displayName;
const PP = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  ra.Image,
  {
    ref: n,
    className: G("pr-twp tw-aspect-square tw-h-full tw-w-full", t),
    ...e
  }
));
PP.displayName = ra.Image.displayName;
const LP = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  ra.Fallback,
  {
    ref: n,
    className: G(
      "pr-twp tw-flex tw-h-full tw-w-full tw-items-center tw-justify-center tw-rounded-full tw-bg-muted",
      t
    ),
    ...e
  }
));
LP.displayName = ra.Fallback.displayName;
const _3 = pt.Root, x3 = pt.Trigger, C3 = pt.Group, k3 = pt.Portal, E3 = pt.Sub, N3 = pt.RadioGroup, $P = Y.forwardRef(({ className: t, inset: e, children: n, ...r }, i) => /* @__PURE__ */ B(
  pt.SubTrigger,
  {
    ref: i,
    className: G(
      "pr-twp tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[state=open]:tw-bg-accent data-[state=open]:tw-text-accent-foreground",
      e && "tw-pl-8",
      t
    ),
    ...r,
    children: [
      n,
      /* @__PURE__ */ p(Ds, { className: "tw-ml-auto tw-h-4 tw-w-4" })
    ]
  }
));
$P.displayName = pt.SubTrigger.displayName;
const FP = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  pt.SubContent,
  {
    ref: n,
    className: G(
      "pr-twp tw-z-50 tw-min-w-[8rem] tw-origin-[--radix-context-menu-content-transform-origin] tw-overflow-hidden tw-rounded-md tw-border tw-bg-popover tw-p-1 tw-text-popover-foreground tw-shadow-md data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
      t
    ),
    ...e
  }
));
FP.displayName = pt.SubContent.displayName;
const BP = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(pt.Portal, { children: /* @__PURE__ */ p(
  pt.Content,
  {
    ref: n,
    className: G(
      "pr-twp tw-z-50 tw-max-h-[--radix-context-menu-content-available-height] tw-min-w-[8rem] tw-origin-[--radix-context-menu-content-transform-origin] tw-overflow-y-auto tw-overflow-x-hidden tw-rounded-md tw-border tw-bg-popover tw-p-1 tw-text-popover-foreground tw-shadow-md tw-animate-in tw-fade-in-80 data-[state=open]:tw-animate-in data-[state=closed]:tw-animate-out data-[state=closed]:tw-fade-out-0 data-[state=open]:tw-fade-in-0 data-[state=closed]:tw-zoom-out-95 data-[state=open]:tw-zoom-in-95 data-[side=bottom]:tw-slide-in-from-top-2 data-[side=left]:tw-slide-in-from-right-2 data-[side=right]:tw-slide-in-from-left-2 data-[side=top]:tw-slide-in-from-bottom-2",
      t
    ),
    ...e
  }
) }));
BP.displayName = pt.Content.displayName;
const qP = Y.forwardRef(({ className: t, inset: e, ...n }, r) => /* @__PURE__ */ p(
  pt.Item,
  {
    ref: r,
    className: G(
      "pr-twp tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-px-2 tw-py-1.5 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
      e && "tw-pl-8",
      t
    ),
    ...n
  }
));
qP.displayName = pt.Item.displayName;
const jP = Y.forwardRef(({ className: t, children: e, checked: n, ...r }, i) => /* @__PURE__ */ B(
  pt.CheckboxItem,
  {
    ref: i,
    className: G(
      "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pl-8 tw-pr-2 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
      t
    ),
    checked: n,
    ...r,
    children: [
      /* @__PURE__ */ p("span", { className: "tw-absolute tw-left-2 tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center", children: /* @__PURE__ */ p(pt.ItemIndicator, { children: /* @__PURE__ */ p(xi, { className: "tw-h-4 tw-w-4" }) }) }),
      e
    ]
  }
));
jP.displayName = pt.CheckboxItem.displayName;
const UP = Y.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ B(
  pt.RadioItem,
  {
    ref: r,
    className: G(
      "tw-relative tw-flex tw-cursor-default tw-select-none tw-items-center tw-rounded-sm tw-py-1.5 tw-pl-8 tw-pr-2 tw-text-sm tw-outline-none focus:tw-bg-accent focus:tw-text-accent-foreground data-[disabled]:tw-pointer-events-none data-[disabled]:tw-opacity-50",
      t
    ),
    ...n,
    children: [
      /* @__PURE__ */ p("span", { className: "tw-absolute tw-left-2 tw-flex tw-h-3.5 tw-w-3.5 tw-items-center tw-justify-center", children: /* @__PURE__ */ p(pt.ItemIndicator, { children: /* @__PURE__ */ p(Iu, { className: "tw-h-2 tw-w-2 tw-fill-current" }) }) }),
      e
    ]
  }
));
UP.displayName = pt.RadioItem.displayName;
const zP = Y.forwardRef(({ className: t, inset: e, ...n }, r) => /* @__PURE__ */ p(
  pt.Label,
  {
    ref: r,
    className: G(
      "tw-px-2 tw-py-1.5 tw-text-sm tw-font-semibold tw-text-foreground",
      e && "tw-pl-8",
      t
    ),
    ...n
  }
));
zP.displayName = pt.Label.displayName;
const VP = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  pt.Separator,
  {
    ref: n,
    className: G("tw--mx-1 tw-my-1 tw-h-px tw-bg-border", t),
    ...e
  }
));
VP.displayName = pt.Separator.displayName;
function HP({ className: t, ...e }) {
  return /* @__PURE__ */ p(
    "span",
    {
      className: G("tw-ml-auto tw-text-xs tw-tracking-widest tw-text-muted-foreground", t),
      ...e
    }
  );
}
HP.displayName = "ContextMenuShortcut";
const P2 = Y.createContext({
  direction: "bottom"
});
function KP({
  shouldScaleBackground: t = !0,
  direction: e = "bottom",
  ...n
}) {
  const r = Y.useMemo(() => ({ direction: e }), [e]);
  return /* @__PURE__ */ p(P2.Provider, { value: r, children: /* @__PURE__ */ p(
    Nr.Root,
    {
      shouldScaleBackground: t,
      direction: e,
      ...n
    }
  ) });
}
KP.displayName = "Drawer";
const S3 = Nr.Trigger, WP = Nr.Portal, T3 = Nr.Close, L2 = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Nr.Overlay,
  {
    ref: n,
    className: G("tw-fixed tw-inset-0 tw-z-50 tw-bg-black/80", t),
    ...e
  }
));
L2.displayName = Nr.Overlay.displayName;
const GP = Y.forwardRef(({ className: t, children: e, hideDrawerHandle: n = !1, ...r }, i) => {
  const { direction: o = "bottom" } = Y.useContext(P2), s = {
    bottom: "tw-inset-x-0 tw-bottom-0 tw-mt-24 tw-rounded-t-[10px]",
    top: "tw-inset-x-0 tw-top-0 tw-mb-24 tw-rounded-b-[10px]",
    left: "tw-inset-y-0 tw-left-0 tw-mr-24 tw-rounded-r-[10px] tw-w-auto tw-max-w-sm",
    right: "tw-inset-y-0 tw-right-0 tw-ml-24 tw-rounded-l-[10px] tw-w-auto tw-max-w-sm"
  }, a = {
    bottom: "tw-mx-auto tw-mt-4 tw-h-2 tw-w-[100px] tw-rounded-full tw-bg-muted",
    top: "tw-mx-auto tw-mb-4 tw-h-2 tw-w-[100px] tw-rounded-full tw-bg-muted",
    left: "tw-my-auto tw-mr-4 tw-w-2 tw-h-[100px] tw-rounded-full tw-bg-muted",
    right: "tw-my-auto tw-ml-4 tw-w-2 tw-h-[100px] tw-rounded-full tw-bg-muted"
  };
  return /* @__PURE__ */ B(WP, { children: [
    /* @__PURE__ */ p(L2, {}),
    /* @__PURE__ */ B(
      Nr.Content,
      {
        ref: i,
        className: G(
          // CUSTOM: Change Tailwind CSS classes for styling
          // Removed tw-inset-x-0 tw-bottom-0 tw-mt-24 tw-rounded-t-[10px] tw-flex-col
          "pr-twp tw-fixed tw-z-50 tw-flex tw-h-auto tw-border tw-bg-background",
          o === "bottom" || o === "top" ? "tw-flex-col" : "tw-flex-row",
          s[o],
          t
        ),
        ...r,
        children: [
          !n && (o === "bottom" || o === "right") && /* @__PURE__ */ p("div", { className: a[o] }),
          /* @__PURE__ */ p("div", { className: "tw-flex tw-flex-col", children: e }),
          !n && (o === "top" || o === "left") && /* @__PURE__ */ p("div", { className: a[o] })
        ]
      }
    )
  ] });
});
GP.displayName = "DrawerContent";
function JP({ className: t, ...e }) {
  return /* @__PURE__ */ p(
    "div",
    {
      className: G("tw-grid tw-gap-1.5 tw-p-4 tw-text-center sm:tw-text-left", t),
      ...e
    }
  );
}
JP.displayName = "DrawerHeader";
function XP({ className: t, ...e }) {
  return /* @__PURE__ */ p("div", { className: G("tw-mt-auto tw-flex tw-flex-col tw-gap-2 tw-p-4", t), ...e });
}
XP.displayName = "DrawerFooter";
const YP = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Nr.Title,
  {
    ref: n,
    className: G("tw-text-lg tw-font-semibold tw-leading-none tw-tracking-tight", t),
    ...e
  }
));
YP.displayName = Nr.Title.displayName;
const QP = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Nr.Description,
  {
    ref: n,
    className: G("tw-text-sm tw-text-muted-foreground", t),
    ...e
  }
));
QP.displayName = Nr.Description.displayName;
const ZP = Y.forwardRef(({ className: t, value: e, ...n }, r) => /* @__PURE__ */ p(
  Mf.Root,
  {
    ref: r,
    className: G(
      "pr-twp tw-relative tw-h-4 tw-w-full tw-overflow-hidden tw-rounded-full tw-bg-secondary",
      t
    ),
    ...n,
    children: /* @__PURE__ */ p(
      Mf.Indicator,
      {
        className: "tw-h-full tw-w-full tw-flex-1 tw-bg-primary tw-transition-all",
        style: { transform: `translateX(-${100 - (e || 0)}%)` }
      }
    )
  }
));
ZP.displayName = Mf.Root.displayName;
function A3({
  className: t,
  ...e
}) {
  return /* @__PURE__ */ p(
    Jh.PanelGroup,
    {
      className: G(
        "tw-flex tw-h-full tw-w-full data-[panel-group-direction=vertical]:tw-flex-col",
        t
      ),
      ...e
    }
  );
}
const D3 = Jh.Panel;
function M3({
  withHandle: t,
  className: e,
  ...n
}) {
  return /* @__PURE__ */ p(
    Jh.PanelResizeHandle,
    {
      className: G(
        "tw-relative tw-flex tw-w-px tw-items-center tw-justify-center tw-bg-border after:tw-absolute after:tw-inset-y-0 after:tw-left-1/2 after:tw-w-1 after:tw--translate-x-1/2 focus-visible:tw-outline-none focus-visible:tw-ring-1 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-1 data-[panel-group-direction=vertical]:tw-h-px data-[panel-group-direction=vertical]:tw-w-full data-[panel-group-direction=vertical]:after:tw-left-0 data-[panel-group-direction=vertical]:after:tw-h-1 data-[panel-group-direction=vertical]:after:tw-w-full data-[panel-group-direction=vertical]:after:tw--translate-y-1/2 data-[panel-group-direction=vertical]:after:tw-translate-x-0 [&[data-panel-group-direction=vertical]>div]:tw-rotate-90",
        e
      ),
      ...n,
      children: t && /* @__PURE__ */ p("div", { className: "tw-z-10 tw-flex tw-h-4 tw-w-3 tw-items-center tw-justify-center tw-rounded-sm tw-border tw-bg-border", children: /* @__PURE__ */ p(_1, { className: "tw-h-2.5 tw-w-2.5" }) })
    }
  );
}
function O3({ ...t }) {
  return /* @__PURE__ */ p(
    F1,
    {
      className: "tw-toaster tw-group",
      toastOptions: {
        classNames: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      },
      ...t
    }
  );
}
const eL = Y.forwardRef(({ className: t, ...e }, n) => {
  const r = Jt();
  return /* @__PURE__ */ B(
    Ba.Root,
    {
      ref: n,
      className: G(
        "pr-twp tw-relative tw-flex tw-w-full tw-touch-none tw-select-none tw-items-center",
        t
      ),
      ...e,
      dir: r,
      children: [
        /* @__PURE__ */ p(Ba.Track, { className: "tw-relative tw-h-2 tw-w-full tw-grow tw-overflow-hidden tw-rounded-full tw-bg-secondary", children: /* @__PURE__ */ p(Ba.Range, { className: "tw-absolute tw-h-full tw-bg-primary" }) }),
        /* @__PURE__ */ p(Ba.Thumb, { className: "tw-block tw-h-5 tw-w-5 tw-rounded-full tw-border-2 tw-border-primary tw-bg-background tw-ring-offset-background tw-transition-colors focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-pointer-events-none disabled:tw-opacity-50" })
      ]
    }
  );
});
eL.displayName = Ba.Root.displayName;
const tL = Y.forwardRef(({ className: t, ...e }, n) => {
  const r = Jt();
  return /* @__PURE__ */ p(
    Of.Root,
    {
      className: G(
        "tw-peer pr-twp tw-inline-flex tw-h-6 tw-w-11 tw-shrink-0 tw-cursor-pointer tw-items-center tw-rounded-full tw-border-2 tw-border-transparent tw-transition-colors focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 focus-visible:tw-ring-offset-background disabled:tw-cursor-not-allowed disabled:tw-opacity-50 data-[state=checked]:tw-bg-primary data-[state=unchecked]:tw-bg-input",
        t
      ),
      ...e,
      ref: n,
      children: /* @__PURE__ */ p(
        Of.Thumb,
        {
          className: G(
            "pr-twp tw-pointer-events-none tw-block tw-h-5 tw-w-5 tw-rounded-full tw-bg-background tw-shadow-lg tw-ring-0 tw-transition-transform",
            {
              "data-[state=checked]:tw-translate-x-5 data-[state=unchecked]:tw-translate-x-0": r === "ltr"
            },
            {
              "data-[state=checked]:tw-translate-x-[-20px] data-[state=unchecked]:tw-translate-x-0": r === "rtl"
            }
          )
        }
      )
    }
  );
});
tL.displayName = Of.Root.displayName;
const I3 = Pn.Root, nL = Y.forwardRef(({ className: t, ...e }, n) => {
  const r = Jt();
  return /* @__PURE__ */ p(
    Pn.List,
    {
      ref: n,
      className: G(
        "pr-twp tw-inline-flex tw-h-10 tw-items-center tw-justify-center tw-rounded-md tw-bg-muted tw-p-1 tw-text-muted-foreground",
        t
      ),
      ...e,
      dir: r
    }
  );
});
nL.displayName = Pn.List.displayName;
const rL = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Pn.Trigger,
  {
    ref: n,
    className: G(
      "pr-twp tw-inline-flex tw-items-center tw-justify-center tw-whitespace-nowrap tw-rounded-sm tw-px-3 tw-py-1.5 tw-text-sm tw-font-medium tw-ring-offset-background tw-transition-all hover:tw-text-foreground focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-pointer-events-none disabled:tw-opacity-50 data-[state=active]:tw-bg-background data-[state=active]:tw-text-foreground data-[state=active]:tw-shadow-sm",
      t
    ),
    ...e
  }
));
rL.displayName = Pn.Trigger.displayName;
const iL = Y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ p(
  Pn.Content,
  {
    ref: n,
    className: G(
      "pr-twp tw-mt-2 tw-ring-offset-background focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2",
      t
    ),
    ...e
  }
));
iL.displayName = Pn.Content.displayName;
const oL = Y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ p(
    "textarea",
    {
      className: G(
        "pr-twp tw-flex tw-min-h-[80px] tw-w-full tw-rounded-md tw-border tw-border-input tw-bg-background tw-px-3 tw-py-2 tw-text-base tw-ring-offset-background placeholder:tw-text-muted-foreground focus-visible:tw-outline-none focus-visible:tw-ring-2 focus-visible:tw-ring-ring focus-visible:tw-ring-offset-2 disabled:tw-cursor-not-allowed disabled:tw-opacity-50 md:tw-text-sm",
        t
      ),
      ref: n,
      ...e
    }
  )
);
oL.displayName = "Textarea";
const R3 = (t, e) => {
  de(() => {
    if (!t) return () => {
    };
    const n = t(e);
    return () => {
      n();
    };
  }, [t, e]);
};
function sL(t) {
  return {
    preserveValue: !0,
    ...t
  };
}
const aL = (t, e, n = {}) => {
  const r = ye(e);
  r.current = e;
  const i = ye(n);
  i.current = sL(i.current);
  const [o, s] = ue(() => r.current), [a, l] = ue(!0);
  return de(() => {
    let c = !0;
    return l(!!t), (async () => {
      if (t) {
        const u = await t();
        c && (s(() => u), l(!1));
      }
    })(), () => {
      c = !1, i.current.preserveValue || s(() => r.current);
    };
  }, [t]), [o, a];
}, Nf = () => !1, P3 = (t, e) => {
  const [n] = aL(
    be(async () => {
      if (!t) return Nf;
      const r = await Promise.resolve(t(e));
      return async () => r();
    }, [e, t]),
    Nf,
    // We want the unsubscriber to return to default value immediately upon changing subscription
    // So the useEffect below will unsubscribe asap
    { preserveValue: !1 }
  );
  de(() => () => {
    n !== Nf && n();
  }, [n]);
}, L3 = ({
  options: t,
  onFocusChange: e,
  onOptionSelect: n,
  onCharacterPress: r
}) => {
  const i = ye(null), [o, s] = ue(void 0), [a, l] = ue(void 0), c = be(
    (d) => {
      s(d);
      const h = t.find((w) => w.id === d);
      h && (e == null || e(h));
      const g = document.getElementById(d);
      g && (g.scrollIntoView({ block: "center" }), g.focus()), i.current && i.current.setAttribute("aria-activedescendant", d);
    },
    [e, t]
  ), u = be(
    (d) => {
      const h = t.find((g) => g.id === d);
      h && (l((g) => g === d ? void 0 : d), n == null || n(h));
    },
    [n, t]
  ), f = be(
    (d) => {
      const h = t.findIndex((b) => b.id === o);
      let g = h;
      switch (d.key) {
        case "ArrowDown":
          g = Math.min(h + 1, t.length - 1), d.preventDefault();
          break;
        case "ArrowUp":
          g = Math.max(h - 1, 0), d.preventDefault();
          break;
        case "Home":
          g = 0, d.preventDefault();
          break;
        case "End":
          g = t.length - 1, d.preventDefault();
          break;
        case " ":
        case "Enter":
          o && u(o), d.preventDefault(), d.stopPropagation();
          return;
        default:
          d.key.length === 1 && !d.metaKey && !d.ctrlKey && !d.altKey && (r == null || r(d.key), d.preventDefault());
          return;
      }
      const w = t[g];
      w && c(w.id);
    },
    [t, c, o, u, r]
  );
  return {
    listboxRef: i,
    activeId: o,
    selectedId: a,
    handleKeyDown: f,
    focusOption: c
  };
};
function lL(t, e = "top") {
  if (!t || typeof document > "u") return;
  const n = document.head || document.querySelector("head"), r = n.querySelector(":first-child"), i = document.createElement("style");
  i.appendChild(document.createTextNode(t)), e === "top" && r ? n.insertBefore(i, r) : n.appendChild(i);
}
lL(`*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}/*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*:where(.pr-twp,.pr-twp *),
::before:where(.pr-twp,.pr-twp *),
::after:where(.pr-twp,.pr-twp *) {
  box-sizing: border-box; /* 1 */
  border-width: 0; /* 2 */
  border-style: solid; /* 2 */
  border-color: #e5e7eb; /* 2 */
}

::before:where(.pr-twp,.pr-twp *),
::after:where(.pr-twp,.pr-twp *) {
  --tw-content: '';
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured \`sans\` font-family by default.
5. Use the user's configured \`sans\` font-feature-settings by default.
6. Use the user's configured \`sans\` font-variation-settings by default.
7. Disable tap highlights on iOS
*/

html:where(.pr-twp,.pr-twp *),
:host:where(.pr-twp,.pr-twp *) {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */ /* 3 */
  tab-size: 4; /* 3 */
  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
  font-feature-settings: normal; /* 5 */
  font-variation-settings: normal; /* 6 */
  -webkit-tap-highlight-color: transparent; /* 7 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from \`html\` so users can set them as a class directly on the \`html\` element.
*/

body:where(.pr-twp,.pr-twp *) {
  margin: 0; /* 1 */
  line-height: inherit; /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr:where(.pr-twp,.pr-twp *) {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]):where(.pr-twp,.pr-twp *) {
  text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1:where(.pr-twp,.pr-twp *),
h2:where(.pr-twp,.pr-twp *),
h3:where(.pr-twp,.pr-twp *),
h4:where(.pr-twp,.pr-twp *),
h5:where(.pr-twp,.pr-twp *),
h6:where(.pr-twp,.pr-twp *) {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a:where(.pr-twp,.pr-twp *) {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b:where(.pr-twp,.pr-twp *),
strong:where(.pr-twp,.pr-twp *) {
  font-weight: bolder;
}

/*
1. Use the user's configured \`mono\` font-family by default.
2. Use the user's configured \`mono\` font-feature-settings by default.
3. Use the user's configured \`mono\` font-variation-settings by default.
4. Correct the odd \`em\` font sizing in all browsers.
*/

code:where(.pr-twp,.pr-twp *),
kbd:where(.pr-twp,.pr-twp *),
samp:where(.pr-twp,.pr-twp *),
pre:where(.pr-twp,.pr-twp *) {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
  font-feature-settings: normal; /* 2 */
  font-variation-settings: normal; /* 3 */
  font-size: 1em; /* 4 */
}

/*
Add the correct font size in all browsers.
*/

small:where(.pr-twp,.pr-twp *) {
  font-size: 80%;
}

/*
Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/

sub:where(.pr-twp,.pr-twp *),
sup:where(.pr-twp,.pr-twp *) {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub:where(.pr-twp,.pr-twp *) {
  bottom: -0.25em;
}

sup:where(.pr-twp,.pr-twp *) {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table:where(.pr-twp,.pr-twp *) {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button:where(.pr-twp,.pr-twp *),
input:where(.pr-twp,.pr-twp *),
optgroup:where(.pr-twp,.pr-twp *),
select:where(.pr-twp,.pr-twp *),
textarea:where(.pr-twp,.pr-twp *) {
  font-family: inherit; /* 1 */
  font-feature-settings: inherit; /* 1 */
  font-variation-settings: inherit; /* 1 */
  font-size: 100%; /* 1 */
  font-weight: inherit; /* 1 */
  line-height: inherit; /* 1 */
  letter-spacing: inherit; /* 1 */
  color: inherit; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button:where(.pr-twp,.pr-twp *),
select:where(.pr-twp,.pr-twp *) {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button:where(.pr-twp,.pr-twp *),
input:where([type='button']):where(.pr-twp,.pr-twp *),
input:where([type='reset']):where(.pr-twp,.pr-twp *),
input:where([type='submit']):where(.pr-twp,.pr-twp *) {
  -webkit-appearance: button; /* 1 */
  background-color: transparent; /* 2 */
  background-image: none; /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring:where(.pr-twp,.pr-twp *) {
  outline: auto;
}

/*
Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid:where(.pr-twp,.pr-twp *) {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress:where(.pr-twp,.pr-twp *) {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button:where(.pr-twp,.pr-twp *),
::-webkit-outer-spin-button:where(.pr-twp,.pr-twp *) {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search']:where(.pr-twp,.pr-twp *) {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration:where(.pr-twp,.pr-twp *) {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to \`inherit\` in Safari.
*/

::-webkit-file-upload-button:where(.pr-twp,.pr-twp *) {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary:where(.pr-twp,.pr-twp *) {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote:where(.pr-twp,.pr-twp *),
dl:where(.pr-twp,.pr-twp *),
dd:where(.pr-twp,.pr-twp *),
h1:where(.pr-twp,.pr-twp *),
h2:where(.pr-twp,.pr-twp *),
h3:where(.pr-twp,.pr-twp *),
h4:where(.pr-twp,.pr-twp *),
h5:where(.pr-twp,.pr-twp *),
h6:where(.pr-twp,.pr-twp *),
hr:where(.pr-twp,.pr-twp *),
figure:where(.pr-twp,.pr-twp *),
p:where(.pr-twp,.pr-twp *),
pre:where(.pr-twp,.pr-twp *) {
  margin: 0;
}

fieldset:where(.pr-twp,.pr-twp *) {
  margin: 0;
  padding: 0;
}

legend:where(.pr-twp,.pr-twp *) {
  padding: 0;
}

ol:where(.pr-twp,.pr-twp *),
ul:where(.pr-twp,.pr-twp *),
menu:where(.pr-twp,.pr-twp *) {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Reset default styling for dialogs.
*/
dialog:where(.pr-twp,.pr-twp *) {
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea:where(.pr-twp,.pr-twp *) {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

input::placeholder:where(.pr-twp,.pr-twp *),
textarea::placeholder:where(.pr-twp,.pr-twp *) {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

/*
Set the default cursor for buttons.
*/

button:where(.pr-twp,.pr-twp *),
[role="button"]:where(.pr-twp,.pr-twp *) {
  cursor: pointer;
}

/*
Make sure disabled buttons don't get the pointer cursor.
*/
:disabled:where(.pr-twp,.pr-twp *) {
  cursor: default;
}

/*
1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img:where(.pr-twp,.pr-twp *),
svg:where(.pr-twp,.pr-twp *),
video:where(.pr-twp,.pr-twp *),
canvas:where(.pr-twp,.pr-twp *),
audio:where(.pr-twp,.pr-twp *),
iframe:where(.pr-twp,.pr-twp *),
embed:where(.pr-twp,.pr-twp *),
object:where(.pr-twp,.pr-twp *) {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img:where(.pr-twp,.pr-twp *),
video:where(.pr-twp,.pr-twp *) {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */
[hidden]:where(:not([hidden="until-found"])):where(.pr-twp,.pr-twp *) {
  display: none;
}
  /* Adding the preflight selector (pr-twp) to components was not changing the font as desired.
  So this piece of code adds tw-font-sans everywhere we include preflight. */
  .pr-twp {
  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
  @font-face {
    font-family: 'Inter';
    font-display: 'swap';
    src: url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
  }

  /**
   * Theme colors and other CSS variable properties in Platform.Bible. These are applied in CSS
   * properties using \`hsl(var(--variableName))\` or Tailwind classes like \`tw-bg-primary\`
   *
   * See the wiki's [Matching Application
   * Theme](https://github.com/paranext/paranext-extension-template/wiki/Extension-Anatomy#matching-application-theme)
   * section for more information
   */
  /* ["Slate" base theme by shadcn/ui](https://ui.shadcn.com/docs/theming#slate) */
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%; /* black */
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%; /* black */
    --popover: 210 20% 98%; /* popover platform */
    --popover-foreground: 222.2 84% 4.9%; /* black */
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 50% 95%;
    --secondary-foreground: 222.2 47.4% 11.2%; /* slate-900 */
    --muted: 210 50% 95%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 50% 95%;
    --accent-foreground: 222.2 47.4% 11.2%; /* slate-900 */
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%; /* slate-50 */
    --border: 214.3 31.8% 91.4%; /* slate-200 */
    --input: 214.3 31.8% 91.4%; /* slate-200 */
    --ring: 222.2 84% 4.9%; /* black */

    --sidebar-background: 210 20% 98%; /* popover platform */
    --sidebar-foreground: 222.2 84% 4.9%; /* black */
    --sidebar-primary: 222.2 47.4% 11.2%;
    --sidebar-primary-foreground: 210 40% 98%;
    --sidebar-accent: 210 50% 95%;
    --sidebar-accent-foreground: 222.2 47.4% 11.2%; /* slate-900 */
    --sidebar-border: 214.3 31.8% 91.4%; /* slate-200 */
    --sidebar-ring: 222.2 84% 4.9%; /* black */

    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%; /* black */
    --foreground: 210 40% 98%; /* slate-50 */
    --card: 222.2 84% 4.9%; /* black */
    --card-foreground: 210 40% 98%; /* slate-50 */
    --popover: 222.2 84% 4.9%; /* black */
    --popover-foreground: 210 40% 98%; /* slate-50 */
    --primary: 210 40% 98%; /* slate-50 */
    --primary-foreground: 222.2 47.4% 11.2%; /* slate-900 */
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%; /* slate-50 */
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%; /* slate-50 */
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%; /* slate-50 */
    --border: 215.3 19.3% 34.5%; /* slate-600 */
    --input: 215.3 19.3% 34.5%; /* slate-600 */
    --ring: 212.7 26.8% 83.9%;

    --sidebar-background: 222.2 84% 4.9%; /* black */
    --sidebar-foreground: 215 20.2% 65.1%;
    --sidebar-primary: 210 40% 98%; /* slate-50 */
    --sidebar-primary-foreground: 222.2 47.4% 11.2%; /* slate-900 */
    --sidebar-accent: 217.2 32.6% 17.5%;
    --sidebar-accent-foreground: 215 20.2% 65.1%;
    --sidebar-border: 217.2 32.6% 17.5%;
    --sidebar-ring: 212.7 26.8% 83.9%;
  }

  /* Palette built in https://tweakcn.com/themes/cmeukcpoj000204l45lxw5a74 based on "Caffeine" theme*/
  .pr-twp,
  .pr-twp * {
  border-color: hsl(var(--border));
  outline-color: hsl(var(--ring) / 0.5);
}

  /**
    * disabled because tslint does not like it, but it is the selector that's needed
    */
  /* stylelint-disable-next-line selector-no-qualifying-type */
  body.pr-twp {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
}
.tw-prose {
  color: var(--tw-prose-body);
  max-width: 65ch;
}
.tw-prose :where(p):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.25em;
  margin-bottom: 1.25em;
}
.tw-prose :where([class~="lead"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-lead);
  font-size: 1.25em;
  line-height: 1.6;
  margin-top: 1.2em;
  margin-bottom: 1.2em;
}
.tw-prose :where(a):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-links);
  text-decoration: underline;
  font-weight: 500;
}
.tw-prose :where(strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-bold);
  font-weight: 600;
}
.tw-prose :where(a strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(blockquote strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(thead th strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(ol):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: decimal;
  margin-top: 1.25em;
  margin-bottom: 1.25em;
  padding-inline-start: 1.625em;
}
.tw-prose :where(ol[type="A"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: upper-alpha;
}
.tw-prose :where(ol[type="a"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: lower-alpha;
}
.tw-prose :where(ol[type="A" s]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: upper-alpha;
}
.tw-prose :where(ol[type="a" s]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: lower-alpha;
}
.tw-prose :where(ol[type="I"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: upper-roman;
}
.tw-prose :where(ol[type="i"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: lower-roman;
}
.tw-prose :where(ol[type="I" s]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: upper-roman;
}
.tw-prose :where(ol[type="i" s]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: lower-roman;
}
.tw-prose :where(ol[type="1"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: decimal;
}
.tw-prose :where(ul):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  list-style-type: disc;
  margin-top: 1.25em;
  margin-bottom: 1.25em;
  padding-inline-start: 1.625em;
}
.tw-prose :where(ol > li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::marker {
  font-weight: 400;
  color: var(--tw-prose-counters);
}
.tw-prose :where(ul > li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::marker {
  color: var(--tw-prose-bullets);
}
.tw-prose :where(dt):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  margin-top: 1.25em;
}
.tw-prose :where(hr):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  border-color: var(--tw-prose-hr);
  border-top-width: 1px;
  margin-top: 3em;
  margin-bottom: 3em;
}
.tw-prose :where(blockquote):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-weight: 500;
  font-style: italic;
  color: var(--tw-prose-quotes);
  border-inline-start-width: 0.25rem;
  border-inline-start-color: var(--tw-prose-quote-borders);
  quotes: "0o201C""0o201D""0o2018""0o2019";
  margin-top: 1.6em;
  margin-bottom: 1.6em;
  padding-inline-start: 1em;
}
.tw-prose :where(blockquote p:first-of-type):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::before {
  content: open-quote;
}
.tw-prose :where(blockquote p:last-of-type):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::after {
  content: close-quote;
}
.tw-prose :where(h1):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 800;
  font-size: 2.25em;
  margin-top: 0;
  margin-bottom: 0.8888889em;
  line-height: 1.1111111;
}
.tw-prose :where(h1 strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-weight: 900;
  color: inherit;
}
.tw-prose :where(h2):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 700;
  font-size: 1.5em;
  margin-top: 2em;
  margin-bottom: 1em;
  line-height: 1.3333333;
}
.tw-prose :where(h2 strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-weight: 800;
  color: inherit;
}
.tw-prose :where(h3):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  font-size: 1.25em;
  margin-top: 1.6em;
  margin-bottom: 0.6em;
  line-height: 1.6;
}
.tw-prose :where(h3 strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-weight: 700;
  color: inherit;
}
.tw-prose :where(h4):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  margin-top: 1.5em;
  margin-bottom: 0.5em;
  line-height: 1.5;
}
.tw-prose :where(h4 strong):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-weight: 700;
  color: inherit;
}
.tw-prose :where(img):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 2em;
  margin-bottom: 2em;
}
.tw-prose :where(picture):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  display: block;
  margin-top: 2em;
  margin-bottom: 2em;
}
.tw-prose :where(video):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 2em;
  margin-bottom: 2em;
}
.tw-prose :where(kbd):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-weight: 500;
  font-family: inherit;
  color: var(--tw-prose-kbd);
  box-shadow: 0 0 0 1px rgb(var(--tw-prose-kbd-shadows) / 10%), 0 3px 0 rgb(var(--tw-prose-kbd-shadows) / 10%);
  font-size: 0.875em;
  border-radius: 0.3125rem;
  padding-top: 0.1875em;
  padding-inline-end: 0.375em;
  padding-bottom: 0.1875em;
  padding-inline-start: 0.375em;
}
.tw-prose :where(code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-code);
  font-weight: 600;
  font-size: 0.875em;
}
.tw-prose :where(code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::before {
  content: "\`";
}
.tw-prose :where(code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::after {
  content: "\`";
}
.tw-prose :where(a code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(h1 code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(h2 code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
  font-size: 0.875em;
}
.tw-prose :where(h3 code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
  font-size: 0.9em;
}
.tw-prose :where(h4 code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(blockquote code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(thead th code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: inherit;
}
.tw-prose :where(pre):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-pre-code);
  background-color: var(--tw-prose-pre-bg);
  overflow-x: auto;
  font-weight: 400;
  font-size: 0.875em;
  line-height: 1.7142857;
  margin-top: 1.7142857em;
  margin-bottom: 1.7142857em;
  border-radius: 0.375rem;
  padding-top: 0.8571429em;
  padding-inline-end: 1.1428571em;
  padding-bottom: 0.8571429em;
  padding-inline-start: 1.1428571em;
}
.tw-prose :where(pre code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  background-color: transparent;
  border-width: 0;
  border-radius: 0;
  padding: 0;
  font-weight: inherit;
  color: inherit;
  font-size: inherit;
  font-family: inherit;
  line-height: inherit;
}
.tw-prose :where(pre code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::before {
  content: none;
}
.tw-prose :where(pre code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *))::after {
  content: none;
}
.tw-prose :where(table):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  width: 100%;
  table-layout: auto;
  margin-top: 2em;
  margin-bottom: 2em;
  font-size: 0.875em;
  line-height: 1.7142857;
}
.tw-prose :where(thead):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  border-bottom-width: 1px;
  border-bottom-color: var(--tw-prose-th-borders);
}
.tw-prose :where(thead th):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  vertical-align: bottom;
  padding-inline-end: 0.5714286em;
  padding-bottom: 0.5714286em;
  padding-inline-start: 0.5714286em;
}
.tw-prose :where(tbody tr):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  border-bottom-width: 1px;
  border-bottom-color: var(--tw-prose-td-borders);
}
.tw-prose :where(tbody tr:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  border-bottom-width: 0;
}
.tw-prose :where(tbody td):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  vertical-align: baseline;
}
.tw-prose :where(tfoot):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  border-top-width: 1px;
  border-top-color: var(--tw-prose-th-borders);
}
.tw-prose :where(tfoot td):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  vertical-align: top;
}
.tw-prose :where(th, td):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  text-align: start;
}
.tw-prose :where(figure > *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
  margin-bottom: 0;
}
.tw-prose :where(figcaption):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  color: var(--tw-prose-captions);
  font-size: 0.875em;
  line-height: 1.4285714;
  margin-top: 0.8571429em;
}
.tw-prose {
  --tw-prose-body: hsl(var(--foreground));
  --tw-prose-headings: hsl(var(--foreground));
  --tw-prose-lead: hsl(var(--muted-foreground));
  --tw-prose-links: hsl(var(--primary));
  --tw-prose-bold: hsl(var(--foreground));
  --tw-prose-counters: hsl(var(--muted-foreground));
  --tw-prose-bullets: hsl(var(--muted-foreground));
  --tw-prose-hr: hsl(var(--border));
  --tw-prose-quotes: hsl(var(--foreground));
  --tw-prose-quote-borders: hsl(var(--border));
  --tw-prose-captions: hsl(var(--muted-foreground));
  --tw-prose-kbd: #111827;
  --tw-prose-kbd-shadows: 17 24 39;
  --tw-prose-code: hsl(var(--foreground));
  --tw-prose-pre-code: hsl(var(--muted-foreground));
  --tw-prose-pre-bg: hsl(var(--muted));
  --tw-prose-th-borders: hsl(var(--border));
  --tw-prose-td-borders: hsl(var(--border));
  --tw-prose-invert-body: #d1d5db;
  --tw-prose-invert-headings: #fff;
  --tw-prose-invert-lead: #9ca3af;
  --tw-prose-invert-links: #fff;
  --tw-prose-invert-bold: #fff;
  --tw-prose-invert-counters: #9ca3af;
  --tw-prose-invert-bullets: #4b5563;
  --tw-prose-invert-hr: #374151;
  --tw-prose-invert-quotes: #f3f4f6;
  --tw-prose-invert-quote-borders: #374151;
  --tw-prose-invert-captions: #9ca3af;
  --tw-prose-invert-kbd: #fff;
  --tw-prose-invert-kbd-shadows: 255 255 255;
  --tw-prose-invert-code: #fff;
  --tw-prose-invert-pre-code: #d1d5db;
  --tw-prose-invert-pre-bg: rgb(0 0 0 / 50%);
  --tw-prose-invert-th-borders: #4b5563;
  --tw-prose-invert-td-borders: #374151;
  font-size: 1rem;
  line-height: 1.75;
}
.tw-prose :where(picture > img):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
  margin-bottom: 0;
}
.tw-prose :where(li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}
.tw-prose :where(ol > li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0.375em;
}
.tw-prose :where(ul > li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0.375em;
}
.tw-prose :where(.tw-prose > ul > li p):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.75em;
  margin-bottom: 0.75em;
}
.tw-prose :where(.tw-prose > ul > li > p:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.25em;
}
.tw-prose :where(.tw-prose > ul > li > p:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-bottom: 1.25em;
}
.tw-prose :where(.tw-prose > ol > li > p:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.25em;
}
.tw-prose :where(.tw-prose > ol > li > p:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-bottom: 1.25em;
}
.tw-prose :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.75em;
  margin-bottom: 0.75em;
}
.tw-prose :where(dl):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.25em;
  margin-bottom: 1.25em;
}
.tw-prose :where(dd):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.5em;
  padding-inline-start: 1.625em;
}
.tw-prose :where(hr + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose :where(h2 + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose :where(h3 + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose :where(h4 + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose :where(thead th:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0;
}
.tw-prose :where(thead th:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-end: 0;
}
.tw-prose :where(tbody td, tfoot td):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-top: 0.5714286em;
  padding-inline-end: 0.5714286em;
  padding-bottom: 0.5714286em;
  padding-inline-start: 0.5714286em;
}
.tw-prose :where(tbody td:first-child, tfoot td:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0;
}
.tw-prose :where(tbody td:last-child, tfoot td:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-end: 0;
}
.tw-prose :where(figure):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 2em;
  margin-bottom: 2em;
}
.tw-prose :where(.tw-prose > :first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose :where(.tw-prose > :last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-bottom: 0;
}
.tw-prose-sm {
  font-size: 0.875rem;
  line-height: 1.7142857;
}
.tw-prose-sm :where(p):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
  margin-bottom: 1.1428571em;
}
.tw-prose-sm :where([class~="lead"]):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 1.2857143em;
  line-height: 1.5555556;
  margin-top: 0.8888889em;
  margin-bottom: 0.8888889em;
}
.tw-prose-sm :where(blockquote):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.3333333em;
  margin-bottom: 1.3333333em;
  padding-inline-start: 1.1111111em;
}
.tw-prose-sm :where(h1):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 2.1428571em;
  margin-top: 0;
  margin-bottom: 0.8em;
  line-height: 1.2;
}
.tw-prose-sm :where(h2):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 1.4285714em;
  margin-top: 1.6em;
  margin-bottom: 0.8em;
  line-height: 1.4;
}
.tw-prose-sm :where(h3):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 1.2857143em;
  margin-top: 1.5555556em;
  margin-bottom: 0.4444444em;
  line-height: 1.5555556;
}
.tw-prose-sm :where(h4):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.4285714em;
  margin-bottom: 0.5714286em;
  line-height: 1.4285714;
}
.tw-prose-sm :where(img):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.7142857em;
  margin-bottom: 1.7142857em;
}
.tw-prose-sm :where(picture):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.7142857em;
  margin-bottom: 1.7142857em;
}
.tw-prose-sm :where(picture > img):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
  margin-bottom: 0;
}
.tw-prose-sm :where(video):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.7142857em;
  margin-bottom: 1.7142857em;
}
.tw-prose-sm :where(kbd):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.8571429em;
  border-radius: 0.3125rem;
  padding-top: 0.1428571em;
  padding-inline-end: 0.3571429em;
  padding-bottom: 0.1428571em;
  padding-inline-start: 0.3571429em;
}
.tw-prose-sm :where(code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.8571429em;
}
.tw-prose-sm :where(h2 code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.9em;
}
.tw-prose-sm :where(h3 code):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.8888889em;
}
.tw-prose-sm :where(pre):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.8571429em;
  line-height: 1.6666667;
  margin-top: 1.6666667em;
  margin-bottom: 1.6666667em;
  border-radius: 0.25rem;
  padding-top: 0.6666667em;
  padding-inline-end: 1em;
  padding-bottom: 0.6666667em;
  padding-inline-start: 1em;
}
.tw-prose-sm :where(ol):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
  margin-bottom: 1.1428571em;
  padding-inline-start: 1.5714286em;
}
.tw-prose-sm :where(ul):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
  margin-bottom: 1.1428571em;
  padding-inline-start: 1.5714286em;
}
.tw-prose-sm :where(li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.2857143em;
  margin-bottom: 0.2857143em;
}
.tw-prose-sm :where(ol > li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0.4285714em;
}
.tw-prose-sm :where(ul > li):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0.4285714em;
}
.tw-prose-sm :where(.tw-prose-sm > ul > li p):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.5714286em;
  margin-bottom: 0.5714286em;
}
.tw-prose-sm :where(.tw-prose-sm > ul > li > p:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
}
.tw-prose-sm :where(.tw-prose-sm > ul > li > p:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-bottom: 1.1428571em;
}
.tw-prose-sm :where(.tw-prose-sm > ol > li > p:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
}
.tw-prose-sm :where(.tw-prose-sm > ol > li > p:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-bottom: 1.1428571em;
}
.tw-prose-sm :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.5714286em;
  margin-bottom: 0.5714286em;
}
.tw-prose-sm :where(dl):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
  margin-bottom: 1.1428571em;
}
.tw-prose-sm :where(dt):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.1428571em;
}
.tw-prose-sm :where(dd):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0.2857143em;
  padding-inline-start: 1.5714286em;
}
.tw-prose-sm :where(hr):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 2.8571429em;
  margin-bottom: 2.8571429em;
}
.tw-prose-sm :where(hr + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose-sm :where(h2 + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose-sm :where(h3 + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose-sm :where(h4 + *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose-sm :where(table):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.8571429em;
  line-height: 1.5;
}
.tw-prose-sm :where(thead th):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-end: 1em;
  padding-bottom: 0.6666667em;
  padding-inline-start: 1em;
}
.tw-prose-sm :where(thead th:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0;
}
.tw-prose-sm :where(thead th:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-end: 0;
}
.tw-prose-sm :where(tbody td, tfoot td):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-top: 0.6666667em;
  padding-inline-end: 1em;
  padding-bottom: 0.6666667em;
  padding-inline-start: 1em;
}
.tw-prose-sm :where(tbody td:first-child, tfoot td:first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-start: 0;
}
.tw-prose-sm :where(tbody td:last-child, tfoot td:last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  padding-inline-end: 0;
}
.tw-prose-sm :where(figure):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 1.7142857em;
  margin-bottom: 1.7142857em;
}
.tw-prose-sm :where(figure > *):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
  margin-bottom: 0;
}
.tw-prose-sm :where(figcaption):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  font-size: 0.8571429em;
  line-height: 1.3333333;
  margin-top: 0.6666667em;
}
.tw-prose-sm :where(.tw-prose-sm > :first-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-top: 0;
}
.tw-prose-sm :where(.tw-prose-sm > :last-child):not(:where([class~="tw-not-prose"],[class~="tw-not-prose"] *)) {
  margin-bottom: 0;
}
.tw-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
.tw-pointer-events-none {
  pointer-events: none;
}
.tw-pointer-events-auto {
  pointer-events: auto;
}
.tw-fixed {
  position: fixed;
}
.tw-absolute {
  position: absolute;
}
.tw-relative {
  position: relative;
}
.tw-sticky {
  position: sticky;
}
.tw-inset-0 {
  inset: 0px;
}
.tw-inset-x-0 {
  left: 0px;
  right: 0px;
}
.tw-inset-y-0 {
  top: 0px;
  bottom: 0px;
}
.tw-bottom-0 {
  bottom: 0px;
}
.tw-left-0 {
  left: 0px;
}
.tw-left-2 {
  left: 0.5rem;
}
.tw-left-3 {
  left: 0.75rem;
}
.tw-left-4 {
  left: 1rem;
}
.tw-left-\\[50\\%\\] {
  left: 50%;
}
.tw-right-0 {
  right: 0px;
}
.tw-right-1 {
  right: 0.25rem;
}
.tw-right-3 {
  right: 0.75rem;
}
.tw-right-4 {
  right: 1rem;
}
.tw-start-2 {
  inset-inline-start: 0.5rem;
}
.tw-top-0 {
  top: 0px;
}
.tw-top-1\\.5 {
  top: 0.375rem;
}
.tw-top-1\\/2 {
  top: 50%;
}
.tw-top-2\\.5 {
  top: 0.625rem;
}
.tw-top-3\\.5 {
  top: 0.875rem;
}
.tw-top-4 {
  top: 1rem;
}
.tw-top-\\[-1px\\] {
  top: -1px;
}
.tw-top-\\[50\\%\\] {
  top: 50%;
}
.tw-z-10 {
  z-index: 10;
}
.tw-z-20 {
  z-index: 20;
}
.tw-z-50 {
  z-index: 50;
}
.tw-z-\\[1000\\] {
  z-index: 1000;
}
.tw-z-\\[250\\] {
  z-index: 250;
}
.tw-z-\\[300\\] {
  z-index: 300;
}
.tw-col-span-2 {
  grid-column: span 2 / span 2;
}
.tw-col-span-3 {
  grid-column: span 3 / span 3;
}
.tw-m-1 {
  margin: 0.25rem;
}
.tw-m-2 {
  margin: 0.5rem;
}
.tw--mx-1 {
  margin-left: -0.25rem;
  margin-right: -0.25rem;
}
.tw-mx-1 {
  margin-left: 0.25rem;
  margin-right: 0.25rem;
}
.tw-mx-2 {
  margin-left: 0.5rem;
  margin-right: 0.5rem;
}
.tw-mx-3\\.5 {
  margin-left: 0.875rem;
  margin-right: 0.875rem;
}
.tw-mx-auto {
  margin-left: auto;
  margin-right: auto;
}
.tw-my-1 {
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
}
.tw-my-auto {
  margin-top: auto;
  margin-bottom: auto;
}
.tw-mb-1 {
  margin-bottom: 0.25rem;
}
.tw-mb-2 {
  margin-bottom: 0.5rem;
}
.tw-mb-24 {
  margin-bottom: 6rem;
}
.tw-mb-4 {
  margin-bottom: 1rem;
}
.tw-me-1 {
  margin-inline-end: 0.25rem;
}
.tw-me-2 {
  margin-inline-end: 0.5rem;
}
.tw-ml-2 {
  margin-left: 0.5rem;
}
.tw-ml-24 {
  margin-left: 6rem;
}
.tw-ml-4 {
  margin-left: 1rem;
}
.tw-ml-auto {
  margin-left: auto;
}
.tw-mr-1 {
  margin-right: 0.25rem;
}
.tw-mr-2 {
  margin-right: 0.5rem;
}
.tw-mr-24 {
  margin-right: 6rem;
}
.tw-mr-4 {
  margin-right: 1rem;
}
.tw-ms-1 {
  margin-inline-start: 0.25rem;
}
.tw-ms-2 {
  margin-inline-start: 0.5rem;
}
.tw-ms-5 {
  margin-inline-start: 1.25rem;
}
.tw-ms-auto {
  margin-inline-start: auto;
}
.tw-mt-1 {
  margin-top: 0.25rem;
}
.tw-mt-2 {
  margin-top: 0.5rem;
}
.tw-mt-24 {
  margin-top: 6rem;
}
.tw-mt-3 {
  margin-top: 0.75rem;
}
.tw-mt-4 {
  margin-top: 1rem;
}
.tw-mt-6 {
  margin-top: 1.5rem;
}
.tw-mt-auto {
  margin-top: auto;
}
.tw-box-border {
  box-sizing: border-box;
}
.tw-block {
  display: block;
}
.tw-inline-block {
  display: inline-block;
}
.tw-flex {
  display: flex;
}
.tw-inline-flex {
  display: inline-flex;
}
.tw-table {
  display: table;
}
.tw-table-cell {
  display: table-cell;
}
.tw-table-row {
  display: table-row;
}
.tw-grid {
  display: grid;
}
.tw-inline-grid {
  display: inline-grid;
}
.tw-hidden {
  display: none;
}
.tw-aspect-square {
  aspect-ratio: 1 / 1;
}
.tw-size-4 {
  width: 1rem;
  height: 1rem;
}
.tw-h-10 {
  height: 2.5rem;
}
.tw-h-11 {
  height: 2.75rem;
}
.tw-h-12 {
  height: 3rem;
}
.tw-h-14 {
  height: 3.5rem;
}
.tw-h-2 {
  height: 0.5rem;
}
.tw-h-2\\.5 {
  height: 0.625rem;
}
.tw-h-20 {
  height: 5rem;
}
.tw-h-24 {
  height: 6rem;
}
.tw-h-3 {
  height: 0.75rem;
}
.tw-h-3\\.5 {
  height: 0.875rem;
}
.tw-h-32 {
  height: 8rem;
}
.tw-h-4 {
  height: 1rem;
}
.tw-h-40 {
  height: 10rem;
}
.tw-h-5 {
  height: 1.25rem;
}
.tw-h-6 {
  height: 1.5rem;
}
.tw-h-64 {
  height: 16rem;
}
.tw-h-7 {
  height: 1.75rem;
}
.tw-h-8 {
  height: 2rem;
}
.tw-h-9 {
  height: 2.25rem;
}
.tw-h-96 {
  height: 24rem;
}
.tw-h-\\[1\\.2rem\\] {
  height: 1.2rem;
}
.tw-h-\\[100px\\] {
  height: 100px;
}
.tw-h-\\[1px\\] {
  height: 1px;
}
.tw-h-\\[300px\\] {
  height: 300px;
}
.tw-h-\\[5px\\] {
  height: 5px;
}
.tw-h-\\[var\\(--radix-select-trigger-height\\)\\] {
  height: var(--radix-select-trigger-height);
}
.tw-h-auto {
  height: auto;
}
.tw-h-full {
  height: 100%;
}
.tw-h-px {
  height: 1px;
}
.tw-h-svh {
  height: 100svh;
}
.tw-max-h-5 {
  max-height: 1.25rem;
}
.tw-max-h-80 {
  max-height: 20rem;
}
.tw-max-h-96 {
  max-height: 24rem;
}
.tw-max-h-\\[--radix-context-menu-content-available-height\\] {
  max-height: var(--radix-context-menu-content-available-height);
}
.tw-max-h-\\[300px\\] {
  max-height: 300px;
}
.tw-max-h-\\[96\\%\\] {
  max-height: 96%;
}
.tw-min-h-0 {
  min-height: 0px;
}
.tw-min-h-\\[80px\\] {
  min-height: 80px;
}
.tw-min-h-svh {
  min-height: 100svh;
}
.tw-w-1\\/2 {
  width: 50%;
}
.tw-w-10 {
  width: 2.5rem;
}
.tw-w-11 {
  width: 2.75rem;
}
.tw-w-12 {
  width: 3rem;
}
.tw-w-2 {
  width: 0.5rem;
}
.tw-w-2\\.5 {
  width: 0.625rem;
}
.tw-w-20 {
  width: 5rem;
}
.tw-w-24 {
  width: 6rem;
}
.tw-w-3 {
  width: 0.75rem;
}
.tw-w-3\\.5 {
  width: 0.875rem;
}
.tw-w-3\\/4 {
  width: 75%;
}
.tw-w-32 {
  width: 8rem;
}
.tw-w-4 {
  width: 1rem;
}
.tw-w-4\\/5 {
  width: 80%;
}
.tw-w-4\\/6 {
  width: 66.666667%;
}
.tw-w-48 {
  width: 12rem;
}
.tw-w-5 {
  width: 1.25rem;
}
.tw-w-5\\/6 {
  width: 83.333333%;
}
.tw-w-56 {
  width: 14rem;
}
.tw-w-6 {
  width: 1.5rem;
}
.tw-w-60 {
  width: 15rem;
}
.tw-w-64 {
  width: 16rem;
}
.tw-w-7 {
  width: 1.75rem;
}
.tw-w-72 {
  width: 18rem;
}
.tw-w-8 {
  width: 2rem;
}
.tw-w-80 {
  width: 20rem;
}
.tw-w-9\\/12 {
  width: 75%;
}
.tw-w-96 {
  width: 24rem;
}
.tw-w-\\[--sidebar-width\\] {
  width: var(--sidebar-width);
}
.tw-w-\\[1\\.2rem\\] {
  width: 1.2rem;
}
.tw-w-\\[100px\\] {
  width: 100px;
}
.tw-w-\\[116px\\] {
  width: 116px;
}
.tw-w-\\[124px\\] {
  width: 124px;
}
.tw-w-\\[150px\\] {
  width: 150px;
}
.tw-w-\\[180px\\] {
  width: 180px;
}
.tw-w-\\[1px\\] {
  width: 1px;
}
.tw-w-\\[200px\\] {
  width: 200px;
}
.tw-w-\\[250px\\] {
  width: 250px;
}
.tw-w-\\[280px\\] {
  width: 280px;
}
.tw-w-\\[300px\\] {
  width: 300px;
}
.tw-w-\\[350px\\] {
  width: 350px;
}
.tw-w-\\[400px\\] {
  width: 400px;
}
.tw-w-\\[500px\\] {
  width: 500px;
}
.tw-w-\\[5px\\] {
  width: 5px;
}
.tw-w-\\[600px\\] {
  width: 600px;
}
.tw-w-\\[70px\\] {
  width: 70px;
}
.tw-w-auto {
  width: auto;
}
.tw-w-fit {
  width: fit-content;
}
.tw-w-full {
  width: 100%;
}
.tw-w-px {
  width: 1px;
}
.tw-min-w-0 {
  min-width: 0px;
}
.tw-min-w-16 {
  min-width: 4rem;
}
.tw-min-w-36 {
  min-width: 9rem;
}
.tw-min-w-5 {
  min-width: 1.25rem;
}
.tw-min-w-80 {
  min-width: 20rem;
}
.tw-min-w-\\[12rem\\] {
  min-width: 12rem;
}
.tw-min-w-\\[140px\\] {
  min-width: 140px;
}
.tw-min-w-\\[215px\\] {
  min-width: 215px;
}
.tw-min-w-\\[8rem\\] {
  min-width: 8rem;
}
.tw-min-w-\\[var\\(--radix-select-trigger-width\\)\\] {
  min-width: var(--radix-select-trigger-width);
}
.tw-max-w-2xl {
  max-width: 42rem;
}
.tw-max-w-3xl {
  max-width: 48rem;
}
.tw-max-w-48 {
  max-width: 12rem;
}
.tw-max-w-4xl {
  max-width: 56rem;
}
.tw-max-w-5 {
  max-width: 1.25rem;
}
.tw-max-w-64 {
  max-width: 16rem;
}
.tw-max-w-6xl {
  max-width: 72rem;
}
.tw-max-w-96 {
  max-width: 24rem;
}
.tw-max-w-\\[--skeleton-width\\] {
  max-width: var(--skeleton-width);
}
.tw-max-w-\\[220px\\] {
  max-width: 220px;
}
.tw-max-w-full {
  max-width: 100%;
}
.tw-max-w-lg {
  max-width: 32rem;
}
.tw-max-w-md {
  max-width: 28rem;
}
.tw-max-w-none {
  max-width: none;
}
.tw-max-w-sm {
  max-width: 24rem;
}
.tw-flex-1 {
  flex: 1 1 0%;
}
.tw-flex-shrink-0 {
  flex-shrink: 0;
}
.tw-shrink {
  flex-shrink: 1;
}
.tw-shrink-0 {
  flex-shrink: 0;
}
.tw-flex-grow {
  flex-grow: 1;
}
.tw-grow {
  flex-grow: 1;
}
.tw-grow-\\[2\\] {
  flex-grow: 2;
}
.tw-basis-0 {
  flex-basis: 0px;
}
.tw-caption-bottom {
  caption-side: bottom;
}
.tw-origin-\\[--radix-context-menu-content-transform-origin\\] {
  transform-origin: var(--radix-context-menu-content-transform-origin);
}
.tw--translate-x-1\\/2 {
  --tw-translate-x: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw--translate-x-px {
  --tw-translate-x: -1px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw--translate-y-1\\/2 {
  --tw-translate-y: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-translate-x-0 {
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-translate-x-\\[-50\\%\\] {
  --tw-translate-x: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-translate-x-px {
  --tw-translate-x: 1px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-translate-y-\\[-50\\%\\] {
  --tw-translate-y: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
@keyframes tw-pulse {

  50% {
    opacity: .5;
  }
}
.tw-animate-pulse {
  animation: tw-pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}
@keyframes tw-spin {

  to {
    transform: rotate(360deg);
  }
}
.tw-animate-spin {
  animation: tw-spin 1s linear infinite;
}
.tw-cursor-default {
  cursor: default;
}
.tw-cursor-pointer {
  cursor: pointer;
}
.tw-touch-none {
  touch-action: none;
}
.tw-select-none {
  user-select: none;
}
.tw-list-inside {
  list-style-position: inside;
}
.tw-list-disc {
  list-style-type: disc;
}
.tw-grid-cols-1 {
  grid-template-columns: repeat(1, minmax(0, 1fr));
}
.tw-grid-cols-2 {
  grid-template-columns: repeat(2, minmax(0, 1fr));
}
.tw-grid-cols-3 {
  grid-template-columns: repeat(3, minmax(0, 1fr));
}
.tw-grid-cols-4 {
  grid-template-columns: repeat(4, minmax(0, 1fr));
}
.tw-grid-cols-6 {
  grid-template-columns: repeat(6, minmax(0, 1fr));
}
.tw-grid-cols-\\[25\\%\\,25\\%\\,50\\%\\] {
  grid-template-columns: 25% 25% 50%;
}
.tw-grid-cols-\\[25\\%\\,50\\%\\,25\\%\\] {
  grid-template-columns: 25% 50% 25%;
}
.tw-flex-row {
  flex-direction: row;
}
.tw-flex-row-reverse {
  flex-direction: row-reverse;
}
.tw-flex-col {
  flex-direction: column;
}
.tw-flex-col-reverse {
  flex-direction: column-reverse;
}
.tw-flex-wrap {
  flex-wrap: wrap;
}
.tw-items-start {
  align-items: flex-start;
}
.tw-items-end {
  align-items: flex-end;
}
.tw-items-center {
  align-items: center;
}
.tw-items-stretch {
  align-items: stretch;
}
.tw-justify-start {
  justify-content: flex-start;
}
.tw-justify-end {
  justify-content: flex-end;
}
.tw-justify-center {
  justify-content: center;
}
.tw-justify-between {
  justify-content: space-between;
}
.tw-gap-1 {
  gap: 0.25rem;
}
.tw-gap-1\\.5 {
  gap: 0.375rem;
}
.tw-gap-2 {
  gap: 0.5rem;
}
.tw-gap-2\\.5 {
  gap: 0.625rem;
}
.tw-gap-4 {
  gap: 1rem;
}
.tw-gap-6 {
  gap: 1.5rem;
}
.tw-gap-\\[12px\\] {
  gap: 12px;
}
.tw-gap-x-2 {
  column-gap: 0.5rem;
}
.tw-gap-x-4 {
  column-gap: 1rem;
}
.tw-space-x-1 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(0.25rem * var(--tw-space-x-reverse));
  margin-left: calc(0.25rem * calc(1 - var(--tw-space-x-reverse)));
}
.tw-space-x-2 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(0.5rem * var(--tw-space-x-reverse));
  margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
}
.tw-space-x-3 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(0.75rem * var(--tw-space-x-reverse));
  margin-left: calc(0.75rem * calc(1 - var(--tw-space-x-reverse)));
}
.tw-space-x-4 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(1rem * var(--tw-space-x-reverse));
  margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
}
.tw-space-x-6 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(1.5rem * var(--tw-space-x-reverse));
  margin-left: calc(1.5rem * calc(1 - var(--tw-space-x-reverse)));
}
.tw-space-y-1 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(0.25rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(0.25rem * var(--tw-space-y-reverse));
}
.tw-space-y-1\\.5 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(0.375rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(0.375rem * var(--tw-space-y-reverse));
}
.tw-space-y-2 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(0.5rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(0.5rem * var(--tw-space-y-reverse));
}
.tw-space-y-3 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(0.75rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(0.75rem * var(--tw-space-y-reverse));
}
.tw-space-y-4 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(1rem * var(--tw-space-y-reverse));
}
.tw-space-y-6 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(1.5rem * var(--tw-space-y-reverse));
}
.tw-space-y-8 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(2rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(2rem * var(--tw-space-y-reverse));
}
.tw-divide-x > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-x-reverse: 0;
  border-right-width: calc(1px * var(--tw-divide-x-reverse));
  border-left-width: calc(1px * calc(1 - var(--tw-divide-x-reverse)));
}
.tw-divide-y > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-y-reverse: 0;
  border-top-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));
  border-bottom-width: calc(1px * var(--tw-divide-y-reverse));
}
.tw-self-stretch {
  align-self: stretch;
}
.tw-overflow-auto {
  overflow: auto;
}
.tw-overflow-hidden {
  overflow: hidden;
}
.tw-overflow-clip {
  overflow: clip;
}
.tw-overflow-y-auto {
  overflow-y: auto;
}
.tw-overflow-x-hidden {
  overflow-x: hidden;
}
.tw-overflow-y-hidden {
  overflow-y: hidden;
}
.tw-truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.tw-text-ellipsis {
  text-overflow: ellipsis;
}
.tw-whitespace-normal {
  white-space: normal;
}
.tw-whitespace-nowrap {
  white-space: nowrap;
}
.tw-text-nowrap {
  text-wrap: nowrap;
}
.tw-text-balance {
  text-wrap: balance;
}
.tw-break-words {
  overflow-wrap: break-word;
}
.tw-rounded {
  border-radius: 0.25rem;
}
.tw-rounded-\\[6px\\] {
  border-radius: 6px;
}
.tw-rounded-full {
  border-radius: 9999px;
}
.tw-rounded-lg {
  border-radius: var(--radius);
}
.tw-rounded-md {
  border-radius: calc(var(--radius) - 2px);
}
.tw-rounded-sm {
  border-radius: calc(var(--radius) - 4px);
}
.tw-rounded-xl {
  border-radius: 0.75rem;
}
.tw-rounded-b-\\[10px\\] {
  border-bottom-right-radius: 10px;
  border-bottom-left-radius: 10px;
}
.tw-rounded-l-\\[10px\\] {
  border-top-left-radius: 10px;
  border-bottom-left-radius: 10px;
}
.tw-rounded-r-\\[10px\\] {
  border-top-right-radius: 10px;
  border-bottom-right-radius: 10px;
}
.tw-rounded-r-xl {
  border-top-right-radius: 0.75rem;
  border-bottom-right-radius: 0.75rem;
}
.tw-rounded-t-\\[10px\\] {
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
}
.tw-border {
  border-width: 1px;
}
.tw-border-0 {
  border-width: 0px;
}
.tw-border-2 {
  border-width: 2px;
}
.tw-border-b {
  border-bottom-width: 1px;
}
.tw-border-b-0 {
  border-bottom-width: 0px;
}
.tw-border-e {
  border-inline-end-width: 1px;
}
.tw-border-e-0 {
  border-inline-end-width: 0px;
}
.tw-border-l {
  border-left-width: 1px;
}
.tw-border-l-4 {
  border-left-width: 4px;
}
.tw-border-s-2 {
  border-inline-start-width: 2px;
}
.tw-border-t {
  border-top-width: 1px;
}
.tw-border-t-0 {
  border-top-width: 0px;
}
.tw-border-solid {
  border-style: solid;
}
.tw-border-dashed {
  border-style: dashed;
}
.tw-border-black {
  --tw-border-opacity: 1;
  border-color: rgb(0 0 0 / var(--tw-border-opacity, 1));
}
.tw-border-blue-400 {
  --tw-border-opacity: 1;
  border-color: rgb(96 165 250 / var(--tw-border-opacity, 1));
}
.tw-border-blue-500 {
  --tw-border-opacity: 1;
  border-color: rgb(59 130 246 / var(--tw-border-opacity, 1));
}
.tw-border-destructive\\/50 {
  border-color: hsl(var(--destructive) / 0.5);
}
.tw-border-gray-300 {
  --tw-border-opacity: 1;
  border-color: rgb(209 213 219 / var(--tw-border-opacity, 1));
}
.tw-border-input {
  border-color: hsl(var(--input));
}
.tw-border-primary {
  border-color: hsl(var(--primary));
}
.tw-border-red-300 {
  --tw-border-opacity: 1;
  border-color: rgb(252 165 165 / var(--tw-border-opacity, 1));
}
.tw-border-red-400 {
  --tw-border-opacity: 1;
  border-color: rgb(248 113 113 / var(--tw-border-opacity, 1));
}
.tw-border-red-500 {
  --tw-border-opacity: 1;
  border-color: rgb(239 68 68 / var(--tw-border-opacity, 1));
}
.tw-border-red-600 {
  --tw-border-opacity: 1;
  border-color: rgb(220 38 38 / var(--tw-border-opacity, 1));
}
.tw-border-ring {
  border-color: hsl(var(--ring));
}
.tw-border-sidebar-border {
  border-color: hsl(var(--sidebar-border));
}
.tw-border-slate-300 {
  --tw-border-opacity: 1;
  border-color: rgb(203 213 225 / var(--tw-border-opacity, 1));
}
.tw-border-transparent {
  border-color: transparent;
}
.tw-border-yellow-400 {
  --tw-border-opacity: 1;
  border-color: rgb(250 204 21 / var(--tw-border-opacity, 1));
}
.tw-border-yellow-500 {
  --tw-border-opacity: 1;
  border-color: rgb(234 179 8 / var(--tw-border-opacity, 1));
}
.tw-border-s-amber-200 {
  --tw-border-opacity: 1;
  border-inline-start-color: rgb(253 230 138 / var(--tw-border-opacity, 1));
}
.tw-border-s-indigo-200 {
  --tw-border-opacity: 1;
  border-inline-start-color: rgb(199 210 254 / var(--tw-border-opacity, 1));
}
.tw-border-s-purple-200 {
  --tw-border-opacity: 1;
  border-inline-start-color: rgb(233 213 255 / var(--tw-border-opacity, 1));
}
.tw-border-s-red-200 {
  --tw-border-opacity: 1;
  border-inline-start-color: rgb(254 202 202 / var(--tw-border-opacity, 1));
}
.tw-bg-accent {
  background-color: hsl(var(--accent));
}
.tw-bg-background {
  background-color: hsl(var(--background));
}
.tw-bg-black\\/80 {
  background-color: rgb(0 0 0 / 0.8);
}
.tw-bg-blue-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(219 234 254 / var(--tw-bg-opacity, 1));
}
.tw-bg-blue-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(96 165 250 / var(--tw-bg-opacity, 1));
}
.tw-bg-blue-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(239 246 255 / var(--tw-bg-opacity, 1));
}
.tw-bg-blue-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(59 130 246 / var(--tw-bg-opacity, 1));
}
.tw-bg-border {
  background-color: hsl(var(--border));
}
.tw-bg-card {
  background-color: hsl(var(--card));
}
.tw-bg-destructive {
  background-color: hsl(var(--destructive));
}
.tw-bg-gray-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(243 244 246 / var(--tw-bg-opacity, 1));
}
.tw-bg-gray-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1));
}
.tw-bg-gray-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(107 114 128 / var(--tw-bg-opacity, 1));
}
.tw-bg-green-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(220 252 231 / var(--tw-bg-opacity, 1));
}
.tw-bg-green-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(240 253 244 / var(--tw-bg-opacity, 1));
}
.tw-bg-green-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(34 197 94 / var(--tw-bg-opacity, 1));
}
.tw-bg-muted {
  background-color: hsl(var(--muted));
}
.tw-bg-muted\\/50 {
  background-color: hsl(var(--muted) / 0.5);
}
.tw-bg-neutral-300 {
  --tw-bg-opacity: 1;
  background-color: rgb(212 212 212 / var(--tw-bg-opacity, 1));
}
.tw-bg-orange-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(255 237 213 / var(--tw-bg-opacity, 1));
}
.tw-bg-popover {
  background-color: hsl(var(--popover));
}
.tw-bg-primary {
  background-color: hsl(var(--primary));
}
.tw-bg-purple-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(250 245 255 / var(--tw-bg-opacity, 1));
}
.tw-bg-red-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(254 226 226 / var(--tw-bg-opacity, 1));
}
.tw-bg-red-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(239 68 68 / var(--tw-bg-opacity, 1));
}
.tw-bg-secondary {
  background-color: hsl(var(--secondary));
}
.tw-bg-sidebar {
  background-color: hsl(var(--sidebar-background));
}
.tw-bg-sidebar-accent {
  background-color: hsl(var(--sidebar-accent));
}
.tw-bg-sidebar-border {
  background-color: hsl(var(--sidebar-border));
}
.tw-bg-transparent {
  background-color: transparent;
}
.tw-bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1));
}
.tw-bg-yellow-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(254 249 195 / var(--tw-bg-opacity, 1));
}
.tw-bg-yellow-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(254 252 232 / var(--tw-bg-opacity, 1));
}
.tw-bg-yellow-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(234 179 8 / var(--tw-bg-opacity, 1));
}
.tw-bg-zinc-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(161 161 170 / var(--tw-bg-opacity, 1));
}
.tw-fill-current {
  fill: currentColor;
}
.tw-fill-destructive {
  fill: hsl(var(--destructive));
}
.tw-fill-yellow-400 {
  fill: #facc15;
}
.tw-fill-yellow-400\\/50 {
  fill: rgb(250 204 21 / 0.5);
}
.tw-p-0 {
  padding: 0px;
}
.tw-p-0\\.5 {
  padding: 0.125rem;
}
.tw-p-1 {
  padding: 0.25rem;
}
.tw-p-2 {
  padding: 0.5rem;
}
.tw-p-3 {
  padding: 0.75rem;
}
.tw-p-4 {
  padding: 1rem;
}
.tw-p-6 {
  padding: 1.5rem;
}
.tw-p-8 {
  padding: 2rem;
}
.tw-p-\\[10px\\] {
  padding: 10px;
}
.tw-p-\\[1px\\] {
  padding: 1px;
}
.tw-px-0 {
  padding-left: 0px;
  padding-right: 0px;
}
.tw-px-1 {
  padding-left: 0.25rem;
  padding-right: 0.25rem;
}
.tw-px-2 {
  padding-left: 0.5rem;
  padding-right: 0.5rem;
}
.tw-px-2\\.5 {
  padding-left: 0.625rem;
  padding-right: 0.625rem;
}
.tw-px-3 {
  padding-left: 0.75rem;
  padding-right: 0.75rem;
}
.tw-px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}
.tw-px-5 {
  padding-left: 1.25rem;
  padding-right: 1.25rem;
}
.tw-px-8 {
  padding-left: 2rem;
  padding-right: 2rem;
}
.tw-py-0 {
  padding-top: 0px;
  padding-bottom: 0px;
}
.tw-py-0\\.5 {
  padding-top: 0.125rem;
  padding-bottom: 0.125rem;
}
.tw-py-1 {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}
.tw-py-1\\.5 {
  padding-top: 0.375rem;
  padding-bottom: 0.375rem;
}
.tw-py-2 {
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}
.tw-py-3 {
  padding-top: 0.75rem;
  padding-bottom: 0.75rem;
}
.tw-py-4 {
  padding-top: 1rem;
  padding-bottom: 1rem;
}
.tw-py-6 {
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
}
.tw-py-8 {
  padding-top: 2rem;
  padding-bottom: 2rem;
}
.\\!tw-pr-10 {
  padding-right: 2.5rem !important;
}
.tw-pb-2 {
  padding-bottom: 0.5rem;
}
.tw-pb-3 {
  padding-bottom: 0.75rem;
}
.tw-pb-4 {
  padding-bottom: 1rem;
}
.tw-pe-1 {
  padding-inline-end: 0.25rem;
}
.tw-pe-2 {
  padding-inline-end: 0.5rem;
}
.tw-pe-9 {
  padding-inline-end: 2.25rem;
}
.tw-pe-\\[calc\\(138px\\+1rem\\)\\] {
  padding-inline-end: calc(138px + 1rem);
}
.tw-pl-3 {
  padding-left: 0.75rem;
}
.tw-pl-4 {
  padding-left: 1rem;
}
.tw-pl-5 {
  padding-left: 1.25rem;
}
.tw-pl-8 {
  padding-left: 2rem;
}
.tw-pr-2 {
  padding-right: 0.5rem;
}
.tw-pr-3 {
  padding-right: 0.75rem;
}
.tw-pr-4 {
  padding-right: 1rem;
}
.tw-ps-12 {
  padding-inline-start: 3rem;
}
.tw-ps-4 {
  padding-inline-start: 1rem;
}
.tw-ps-8 {
  padding-inline-start: 2rem;
}
.tw-ps-9 {
  padding-inline-start: 2.25rem;
}
.tw-ps-\\[85px\\] {
  padding-inline-start: 85px;
}
.tw-pt-0 {
  padding-top: 0px;
}
.tw-pt-2 {
  padding-top: 0.5rem;
}
.tw-pt-3 {
  padding-top: 0.75rem;
}
.tw-pt-6 {
  padding-top: 1.5rem;
}
.tw-text-left {
  text-align: left;
}
.tw-text-center {
  text-align: center;
}
.tw-text-right {
  text-align: right;
}
.tw-text-start {
  text-align: start;
}
.tw-text-end {
  text-align: end;
}
.tw-align-middle {
  vertical-align: middle;
}
.tw-text-2xl {
  font-size: 1.5rem;
  line-height: 2rem;
}
.tw-text-base {
  font-size: 1rem;
  line-height: 1.5rem;
}
.tw-text-lg {
  font-size: 1.125rem;
  line-height: 1.75rem;
}
.tw-text-sm {
  font-size: 0.875rem;
  line-height: 1.25rem;
}
.tw-text-xl {
  font-size: 1.25rem;
  line-height: 1.75rem;
}
.tw-text-xs {
  font-size: 0.75rem;
  line-height: 1rem;
}
.tw-font-bold {
  font-weight: 700;
}
.tw-font-medium {
  font-weight: 500;
}
.tw-font-normal {
  font-weight: 400;
}
.tw-font-semibold {
  font-weight: 600;
}
.tw-capitalize {
  text-transform: capitalize;
}
.tw-italic {
  font-style: italic;
}
.tw-tabular-nums {
  --tw-numeric-spacing: tabular-nums;
  font-variant-numeric: var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction);
}
.tw-leading-loose {
  line-height: 2;
}
.tw-leading-none {
  line-height: 1;
}
.tw-leading-relaxed {
  line-height: 1.625;
}
.tw-leading-tight {
  line-height: 1.25;
}
.tw-tracking-tight {
  letter-spacing: -0.025em;
}
.tw-tracking-widest {
  letter-spacing: 0.1em;
}
.tw-text-blue-500 {
  --tw-text-opacity: 1;
  color: rgb(59 130 246 / var(--tw-text-opacity, 1));
}
.tw-text-blue-600 {
  --tw-text-opacity: 1;
  color: rgb(37 99 235 / var(--tw-text-opacity, 1));
}
.tw-text-blue-800 {
  --tw-text-opacity: 1;
  color: rgb(30 64 175 / var(--tw-text-opacity, 1));
}
.tw-text-card-foreground {
  color: hsl(var(--card-foreground));
}
.tw-text-current {
  color: currentColor;
}
.tw-text-destructive {
  color: hsl(var(--destructive));
}
.tw-text-destructive-foreground {
  color: hsl(var(--destructive-foreground));
}
.tw-text-foreground {
  color: hsl(var(--foreground));
}
.tw-text-gray-300 {
  --tw-text-opacity: 1;
  color: rgb(209 213 219 / var(--tw-text-opacity, 1));
}
.tw-text-gray-500 {
  --tw-text-opacity: 1;
  color: rgb(107 114 128 / var(--tw-text-opacity, 1));
}
.tw-text-gray-600 {
  --tw-text-opacity: 1;
  color: rgb(75 85 99 / var(--tw-text-opacity, 1));
}
.tw-text-gray-700 {
  --tw-text-opacity: 1;
  color: rgb(55 65 81 / var(--tw-text-opacity, 1));
}
.tw-text-gray-800 {
  --tw-text-opacity: 1;
  color: rgb(31 41 55 / var(--tw-text-opacity, 1));
}
.tw-text-green-600 {
  --tw-text-opacity: 1;
  color: rgb(22 163 74 / var(--tw-text-opacity, 1));
}
.tw-text-green-700 {
  --tw-text-opacity: 1;
  color: rgb(21 128 61 / var(--tw-text-opacity, 1));
}
.tw-text-green-800 {
  --tw-text-opacity: 1;
  color: rgb(22 101 52 / var(--tw-text-opacity, 1));
}
.tw-text-inherit {
  color: inherit;
}
.tw-text-muted-foreground {
  color: hsl(var(--muted-foreground));
}
.tw-text-muted-foreground\\/50 {
  color: hsl(var(--muted-foreground) / 0.5);
}
.tw-text-orange-800 {
  --tw-text-opacity: 1;
  color: rgb(154 52 18 / var(--tw-text-opacity, 1));
}
.tw-text-popover-foreground {
  color: hsl(var(--popover-foreground));
}
.tw-text-primary {
  color: hsl(var(--primary));
}
.tw-text-primary-foreground {
  color: hsl(var(--primary-foreground));
}
.tw-text-red-500 {
  --tw-text-opacity: 1;
  color: rgb(239 68 68 / var(--tw-text-opacity, 1));
}
.tw-text-red-600 {
  --tw-text-opacity: 1;
  color: rgb(220 38 38 / var(--tw-text-opacity, 1));
}
.tw-text-red-700 {
  --tw-text-opacity: 1;
  color: rgb(185 28 28 / var(--tw-text-opacity, 1));
}
.tw-text-red-800 {
  --tw-text-opacity: 1;
  color: rgb(153 27 27 / var(--tw-text-opacity, 1));
}
.tw-text-secondary-foreground {
  color: hsl(var(--secondary-foreground));
}
.tw-text-sidebar-accent-foreground {
  color: hsl(var(--sidebar-accent-foreground));
}
.tw-text-sidebar-foreground {
  color: hsl(var(--sidebar-foreground));
}
.tw-text-sidebar-foreground\\/70 {
  color: hsl(var(--sidebar-foreground) / 0.7);
}
.tw-text-slate-900 {
  --tw-text-opacity: 1;
  color: rgb(15 23 42 / var(--tw-text-opacity, 1));
}
.tw-text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity, 1));
}
.tw-text-yellow-400 {
  --tw-text-opacity: 1;
  color: rgb(250 204 21 / var(--tw-text-opacity, 1));
}
.tw-text-yellow-600 {
  --tw-text-opacity: 1;
  color: rgb(202 138 4 / var(--tw-text-opacity, 1));
}
.tw-text-yellow-700 {
  --tw-text-opacity: 1;
  color: rgb(161 98 7 / var(--tw-text-opacity, 1));
}
.tw-underline {
  text-decoration-line: underline;
}
.tw-decoration-destructive {
  text-decoration-color: hsl(var(--destructive));
}
.tw-underline-offset-4 {
  text-underline-offset: 4px;
}
.tw-opacity-0 {
  opacity: 0;
}
.tw-opacity-100 {
  opacity: 1;
}
.tw-opacity-50 {
  opacity: 0.5;
}
.tw-opacity-60 {
  opacity: 0.6;
}
.tw-opacity-70 {
  opacity: 0.7;
}
.tw-shadow-\\[0_0_0_1px_hsl\\(var\\(--sidebar-border\\)\\)\\] {
  --tw-shadow: 0 0 0 1px hsl(var(--sidebar-border));
  --tw-shadow-colored: 0 0 0 1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-shadow-lg {
  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-shadow-md {
  --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-shadow-none {
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-shadow-sm {
  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-outline-none {
  outline: 2px solid transparent;
  outline-offset: 2px;
}
.tw-ring-0 {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.tw-ring-sidebar-ring {
  --tw-ring-color: hsl(var(--sidebar-ring));
}
.tw-ring-offset-background {
  --tw-ring-offset-color: hsl(var(--background));
}
.tw-drop-shadow-sm {
  --tw-drop-shadow: drop-shadow(0 1px 1px rgb(0 0 0 / 0.05));
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.tw-transition-\\[left\\,right\\,width\\] {
  transition-property: left,right,width;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-\\[margin\\,opa\\] {
  transition-property: margin,opa;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-\\[width\\,height\\,padding\\] {
  transition-property: width,height,padding;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-\\[width\\] {
  transition-property: width;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-colors {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-opacity {
  transition-property: opacity;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-transition-transform {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tw-duration-200 {
  transition-duration: 200ms;
}
.tw-ease-linear {
  transition-timing-function: linear;
}
@keyframes enter {

  from {
    opacity: var(--tw-enter-opacity, 1);
    transform: translate3d(var(--tw-enter-translate-x, 0), var(--tw-enter-translate-y, 0), 0) scale3d(var(--tw-enter-scale, 1), var(--tw-enter-scale, 1), var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0));
  }
}
@keyframes exit {

  to {
    opacity: var(--tw-exit-opacity, 1);
    transform: translate3d(var(--tw-exit-translate-x, 0), var(--tw-exit-translate-y, 0), 0) scale3d(var(--tw-exit-scale, 1), var(--tw-exit-scale, 1), var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0));
  }
}
.tw-animate-in {
  animation-name: enter;
  animation-duration: 150ms;
  --tw-enter-opacity: initial;
  --tw-enter-scale: initial;
  --tw-enter-rotate: initial;
  --tw-enter-translate-x: initial;
  --tw-enter-translate-y: initial;
}
.tw-fade-in-0 {
  --tw-enter-opacity: 0;
}
.tw-fade-in-80 {
  --tw-enter-opacity: 0.8;
}
.tw-zoom-in-95 {
  --tw-enter-scale: .95;
}
.tw-duration-200 {
  animation-duration: 200ms;
}
.tw-ease-linear {
  animation-timing-function: linear;
}
.tw-\\@container\\/tab-toolbar-center {
  container-type: inline-size;
  container-name: tab-toolbar-center;
}
.tw-\\@container\\/tab-toolbar-end {
  container-type: inline-size;
  container-name: tab-toolbar-end;
}
.tw-\\@container\\/tab-toolbar-start {
  container-type: inline-size;
  container-name: tab-toolbar-start;
}
.tw-\\@container\\/toolbar {
  container-type: inline-size;
  container-name: toolbar;
}

/*
 * WARNING: These themes are also represented in paranext-core/src/shared/data/themes.data.json!
 * Please update in both locations
*/
/* #region shared with https://github.com/paranext/paranext-extension-template/blob/main/src/tailwind.css */
/* #endregion */

/* Note that the following region is from shadcn/ui's styles
 * https://ui.shadcn.com/docs/installation/manual#configure-styles but is scoped down to .pr-twp
 * because this is just a component library and should not apply its styles to the entire page.
 *
 * There is now a section in this library's README.md that explains how to apply these styles to the
 * entire page if desired.
 *
 * The template has the original shadcn/ui styles because it intentionally applies the styles to the
 * entire page. The same is true for Platform.Bible - see \`app.component.scss\`
 */
/* #region shared with https://github.com/paranext/paranext-extension-template/blob/main/src/tailwind.css but with the difference of being scoped to .pr-twp here */
.file\\:tw-border-0::file-selector-button {
  border-width: 0px;
}
.file\\:tw-bg-transparent::file-selector-button {
  background-color: transparent;
}
.file\\:tw-text-sm::file-selector-button {
  font-size: 0.875rem;
  line-height: 1.25rem;
}
.file\\:tw-font-medium::file-selector-button {
  font-weight: 500;
}
.file\\:tw-text-foreground::file-selector-button {
  color: hsl(var(--foreground));
}
.placeholder\\:tw-text-muted-foreground::placeholder {
  color: hsl(var(--muted-foreground));
}
.after\\:tw-absolute::after {
  content: var(--tw-content);
  position: absolute;
}
.after\\:tw--inset-2::after {
  content: var(--tw-content);
  inset: -0.5rem;
}
.after\\:tw-inset-y-0::after {
  content: var(--tw-content);
  top: 0px;
  bottom: 0px;
}
.after\\:tw-left-1\\/2::after {
  content: var(--tw-content);
  left: 50%;
}
.after\\:tw-w-1::after {
  content: var(--tw-content);
  width: 0.25rem;
}
.after\\:tw-w-\\[2px\\]::after {
  content: var(--tw-content);
  width: 2px;
}
.after\\:tw--translate-x-1\\/2::after {
  content: var(--tw-content);
  --tw-translate-x: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.hover\\:tw-bg-accent:hover {
  background-color: hsl(var(--accent));
}
.hover\\:tw-bg-blue-600:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(37 99 235 / var(--tw-bg-opacity, 1));
}
.hover\\:tw-bg-destructive\\/80:hover {
  background-color: hsl(var(--destructive) / 0.8);
}
.hover\\:tw-bg-destructive\\/90:hover {
  background-color: hsl(var(--destructive) / 0.9);
}
.hover\\:tw-bg-muted:hover {
  background-color: hsl(var(--muted));
}
.hover\\:tw-bg-muted\\/50:hover {
  background-color: hsl(var(--muted) / 0.5);
}
.hover\\:tw-bg-muted\\/80:hover {
  background-color: hsl(var(--muted) / 0.8);
}
.hover\\:tw-bg-primary\\/70:hover {
  background-color: hsl(var(--primary) / 0.7);
}
.hover\\:tw-bg-primary\\/80:hover {
  background-color: hsl(var(--primary) / 0.8);
}
.hover\\:tw-bg-primary\\/90:hover {
  background-color: hsl(var(--primary) / 0.9);
}
.hover\\:tw-bg-secondary:hover {
  background-color: hsl(var(--secondary));
}
.hover\\:tw-bg-secondary\\/80:hover {
  background-color: hsl(var(--secondary) / 0.8);
}
.hover\\:tw-bg-sidebar-accent:hover {
  background-color: hsl(var(--sidebar-accent));
}
.hover\\:tw-bg-transparent:hover {
  background-color: transparent;
}
.hover\\:tw-text-accent-foreground:hover {
  color: hsl(var(--accent-foreground));
}
.hover\\:tw-text-foreground:hover {
  color: hsl(var(--foreground));
}
.hover\\:tw-text-muted-foreground:hover {
  color: hsl(var(--muted-foreground));
}
.hover\\:tw-text-primary-foreground:hover {
  color: hsl(var(--primary-foreground));
}
.hover\\:tw-text-sidebar-accent-foreground:hover {
  color: hsl(var(--sidebar-accent-foreground));
}
.hover\\:tw-underline:hover {
  text-decoration-line: underline;
}
.hover\\:tw-opacity-100:hover {
  opacity: 1;
}
.hover\\:tw-opacity-80:hover {
  opacity: 0.8;
}
.hover\\:tw-shadow-\\[0_0_0_1px_hsl\\(var\\(--sidebar-accent\\)\\)\\]:hover {
  --tw-shadow: 0 0 0 1px hsl(var(--sidebar-accent));
  --tw-shadow-colored: 0 0 0 1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.hover\\:after\\:tw-bg-sidebar-border:hover::after {
  content: var(--tw-content);
  background-color: hsl(var(--sidebar-border));
}
.focus\\:tw-relative:focus {
  position: relative;
}
.focus\\:tw-z-10:focus {
  z-index: 10;
}
.focus\\:tw-bg-accent:focus {
  background-color: hsl(var(--accent));
}
.focus\\:tw-bg-muted:focus {
  background-color: hsl(var(--muted));
}
.focus\\:tw-text-accent-foreground:focus {
  color: hsl(var(--accent-foreground));
}
.focus\\:tw-text-foreground:focus {
  color: hsl(var(--foreground));
}
.focus\\:tw-outline-none:focus {
  outline: 2px solid transparent;
  outline-offset: 2px;
}
.focus\\:tw-ring-2:focus {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus\\:tw-ring-ring:focus {
  --tw-ring-color: hsl(var(--ring));
}
.focus\\:tw-ring-offset-1:focus {
  --tw-ring-offset-width: 1px;
}
.focus\\:tw-ring-offset-2:focus {
  --tw-ring-offset-width: 2px;
}
.focus\\:tw-ring-offset-background:focus {
  --tw-ring-offset-color: hsl(var(--background));
}
.focus-visible\\:tw-outline-none:focus-visible {
  outline: 2px solid transparent;
  outline-offset: 2px;
}
.focus-visible\\:tw-ring-1:focus-visible {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus-visible\\:tw-ring-2:focus-visible {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus-visible\\:tw-ring-\\[color\\:hsl\\(2400o2c 5\\%0o2c 64\\.9\\%\\)\\]:focus-visible {
  --tw-ring-opacity: 1;
  --tw-ring-color: hsl(240 5% 64.9% / var(--tw-ring-opacity, 1));
}
.focus-visible\\:tw-ring-ring:focus-visible {
  --tw-ring-color: hsl(var(--ring));
}
.focus-visible\\:tw-ring-sidebar-ring:focus-visible {
  --tw-ring-color: hsl(var(--sidebar-ring));
}
.focus-visible\\:tw-ring-offset-1:focus-visible {
  --tw-ring-offset-width: 1px;
}
.focus-visible\\:tw-ring-offset-2:focus-visible {
  --tw-ring-offset-width: 2px;
}
.focus-visible\\:tw-ring-offset-background:focus-visible {
  --tw-ring-offset-color: hsl(var(--background));
}
.active\\:tw-bg-sidebar-accent:active {
  background-color: hsl(var(--sidebar-accent));
}
.active\\:tw-text-sidebar-accent-foreground:active {
  color: hsl(var(--sidebar-accent-foreground));
}
.disabled\\:tw-pointer-events-none:disabled {
  pointer-events: none;
}
.disabled\\:tw-pointer-events-auto:disabled {
  pointer-events: auto;
}
.disabled\\:tw-cursor-not-allowed:disabled {
  cursor: not-allowed;
}
.disabled\\:tw-opacity-50:disabled {
  opacity: 0.5;
}
.tw-peer:disabled ~ .peer-disabled\\:tw-cursor-not-allowed {
  cursor: not-allowed;
}
.tw-peer:disabled ~ .peer-disabled\\:tw-opacity-70 {
  opacity: 0.7;
}
.has-\\[\\[data-variant\\=inset\\]\\]\\:tw-bg-sidebar:has([data-variant=inset]) {
  background-color: hsl(var(--sidebar-background));
}
.aria-disabled\\:tw-pointer-events-none[aria-disabled="true"] {
  pointer-events: none;
}
.aria-disabled\\:tw-opacity-50[aria-disabled="true"] {
  opacity: 0.5;
}
.data-\\[disabled\\=true\\]\\:tw-pointer-events-none[data-disabled="true"] {
  pointer-events: none;
}
.data-\\[disabled\\]\\:tw-pointer-events-none[data-disabled] {
  pointer-events: none;
}
.data-\\[panel-group-direction\\=vertical\\]\\:tw-h-px[data-panel-group-direction="vertical"] {
  height: 1px;
}
.data-\\[panel-group-direction\\=vertical\\]\\:tw-w-full[data-panel-group-direction="vertical"] {
  width: 100%;
}
.data-\\[side\\=bottom\\]\\:tw-translate-y-1[data-side="bottom"] {
  --tw-translate-y: 0.25rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[side\\=left\\]\\:tw--translate-x-1[data-side="left"] {
  --tw-translate-x: -0.25rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[side\\=right\\]\\:tw-translate-x-1[data-side="right"] {
  --tw-translate-x: 0.25rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[side\\=top\\]\\:tw--translate-y-1[data-side="top"] {
  --tw-translate-y: -0.25rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[state\\=checked\\]\\:tw-translate-x-5[data-state="checked"] {
  --tw-translate-x: 1.25rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[state\\=checked\\]\\:tw-translate-x-\\[-20px\\][data-state="checked"] {
  --tw-translate-x: -20px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[state\\=unchecked\\]\\:tw-translate-x-0[data-state="unchecked"] {
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[panel-group-direction\\=vertical\\]\\:tw-flex-col[data-panel-group-direction="vertical"] {
  flex-direction: column;
}
.data-\\[active\\=true\\]\\:tw-bg-sidebar-accent[data-active="true"] {
  background-color: hsl(var(--sidebar-accent));
}
.data-\\[selected\\=true\\]\\:tw-bg-accent[data-selected="true"] {
  background-color: hsl(var(--accent));
}
.data-\\[state\\=active\\]\\:tw-bg-background[data-state="active"] {
  background-color: hsl(var(--background));
}
.data-\\[state\\=checked\\]\\:tw-bg-primary[data-state="checked"] {
  background-color: hsl(var(--primary));
}
.data-\\[state\\=on\\]\\:tw-bg-accent[data-state="on"] {
  background-color: hsl(var(--accent));
}
.data-\\[state\\=open\\]\\:tw-bg-accent[data-state="open"] {
  background-color: hsl(var(--accent));
}
.data-\\[state\\=open\\]\\:tw-bg-muted[data-state="open"] {
  background-color: hsl(var(--muted));
}
.data-\\[state\\=selected\\]\\:tw-bg-muted[data-state="selected"] {
  background-color: hsl(var(--muted));
}
.data-\\[state\\=unchecked\\]\\:tw-bg-input[data-state="unchecked"] {
  background-color: hsl(var(--input));
}
.data-\\[active\\=true\\]\\:tw-font-medium[data-active="true"] {
  font-weight: 500;
}
.data-\\[active\\=true\\]\\:tw-text-sidebar-accent-foreground[data-active="true"] {
  color: hsl(var(--sidebar-accent-foreground));
}
.data-\\[selected\\=true\\]\\:tw-text-accent-foreground[data-selected="true"] {
  color: hsl(var(--accent-foreground));
}
.data-\\[state\\=active\\]\\:tw-text-foreground[data-state="active"] {
  color: hsl(var(--foreground));
}
.data-\\[state\\=checked\\]\\:tw-text-primary-foreground[data-state="checked"] {
  color: hsl(var(--primary-foreground));
}
.data-\\[state\\=on\\]\\:tw-text-accent-foreground[data-state="on"] {
  color: hsl(var(--accent-foreground));
}
.data-\\[state\\=open\\]\\:tw-text-accent-foreground[data-state="open"] {
  color: hsl(var(--accent-foreground));
}
.data-\\[state\\=open\\]\\:tw-text-foreground[data-state="open"] {
  color: hsl(var(--foreground));
}
.data-\\[state\\=open\\]\\:tw-text-muted-foreground[data-state="open"] {
  color: hsl(var(--muted-foreground));
}
.data-\\[disabled\\=true\\]\\:tw-opacity-50[data-disabled="true"] {
  opacity: 0.5;
}
.data-\\[disabled\\]\\:tw-opacity-50[data-disabled] {
  opacity: 0.5;
}
.data-\\[state\\=open\\]\\:tw-opacity-100[data-state="open"] {
  opacity: 1;
}
.data-\\[state\\=active\\]\\:tw-shadow-sm[data-state="active"] {
  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.data-\\[state\\=open\\]\\:tw-animate-in[data-state="open"] {
  animation-name: enter;
  animation-duration: 150ms;
  --tw-enter-opacity: initial;
  --tw-enter-scale: initial;
  --tw-enter-rotate: initial;
  --tw-enter-translate-x: initial;
  --tw-enter-translate-y: initial;
}
.data-\\[state\\=closed\\]\\:tw-animate-out[data-state="closed"] {
  animation-name: exit;
  animation-duration: 150ms;
  --tw-exit-opacity: initial;
  --tw-exit-scale: initial;
  --tw-exit-rotate: initial;
  --tw-exit-translate-x: initial;
  --tw-exit-translate-y: initial;
}
.data-\\[state\\=closed\\]\\:tw-fade-out-0[data-state="closed"] {
  --tw-exit-opacity: 0;
}
.data-\\[state\\=open\\]\\:tw-fade-in-0[data-state="open"] {
  --tw-enter-opacity: 0;
}
.data-\\[state\\=closed\\]\\:tw-zoom-out-95[data-state="closed"] {
  --tw-exit-scale: .95;
}
.data-\\[state\\=open\\]\\:tw-zoom-in-95[data-state="open"] {
  --tw-enter-scale: .95;
}
.data-\\[side\\=bottom\\]\\:tw-slide-in-from-top-2[data-side="bottom"] {
  --tw-enter-translate-y: -0.5rem;
}
.data-\\[side\\=left\\]\\:tw-slide-in-from-right-2[data-side="left"] {
  --tw-enter-translate-x: 0.5rem;
}
.data-\\[side\\=right\\]\\:tw-slide-in-from-left-2[data-side="right"] {
  --tw-enter-translate-x: -0.5rem;
}
.data-\\[side\\=top\\]\\:tw-slide-in-from-bottom-2[data-side="top"] {
  --tw-enter-translate-y: 0.5rem;
}
.data-\\[state\\=closed\\]\\:tw-slide-out-to-left-1\\/2[data-state="closed"] {
  --tw-exit-translate-x: -50%;
}
.data-\\[state\\=closed\\]\\:tw-slide-out-to-top-\\[48\\%\\][data-state="closed"] {
  --tw-exit-translate-y: -48%;
}
.data-\\[state\\=open\\]\\:tw-slide-in-from-left-1\\/2[data-state="open"] {
  --tw-enter-translate-x: -50%;
}
.data-\\[state\\=open\\]\\:tw-slide-in-from-top-\\[48\\%\\][data-state="open"] {
  --tw-enter-translate-y: -48%;
}
.data-\\[panel-group-direction\\=vertical\\]\\:after\\:tw-left-0[data-panel-group-direction="vertical"]::after {
  content: var(--tw-content);
  left: 0px;
}
.data-\\[panel-group-direction\\=vertical\\]\\:after\\:tw-h-1[data-panel-group-direction="vertical"]::after {
  content: var(--tw-content);
  height: 0.25rem;
}
.data-\\[panel-group-direction\\=vertical\\]\\:after\\:tw-w-full[data-panel-group-direction="vertical"]::after {
  content: var(--tw-content);
  width: 100%;
}
.data-\\[panel-group-direction\\=vertical\\]\\:after\\:tw--translate-y-1\\/2[data-panel-group-direction="vertical"]::after {
  content: var(--tw-content);
  --tw-translate-y: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[panel-group-direction\\=vertical\\]\\:after\\:tw-translate-x-0[data-panel-group-direction="vertical"]::after {
  content: var(--tw-content);
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.data-\\[state\\=open\\]\\:hover\\:tw-bg-sidebar-accent:hover[data-state="open"] {
  background-color: hsl(var(--sidebar-accent));
}
.data-\\[state\\=open\\]\\:hover\\:tw-text-sidebar-accent-foreground:hover[data-state="open"] {
  color: hsl(var(--sidebar-accent-foreground));
}
.tw-group[data-collapsible="offcanvas"] .group-data-\\[collapsible\\=offcanvas\\]\\:tw-left-\\[calc\\(var\\(--sidebar-width\\)\\*-1\\)\\] {
  left: calc(var(--sidebar-width) * -1);
}
.tw-group[data-collapsible="offcanvas"] .group-data-\\[collapsible\\=offcanvas\\]\\:tw-right-\\[calc\\(var\\(--sidebar-width\\)\\*-1\\)\\] {
  right: calc(var(--sidebar-width) * -1);
}
.tw-group[data-side="primary"] .group-data-\\[side\\=primary\\]\\:tw--right-4 {
  right: -1rem;
}
.tw-group[data-side="secondary"] .group-data-\\[side\\=secondary\\]\\:tw-left-0 {
  left: 0px;
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw--mt-8 {
  margin-top: -2rem;
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw-hidden {
  display: none;
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw-w-\\[--sidebar-width-icon\\] {
  width: var(--sidebar-width-icon);
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw-w-\\[calc\\(var\\(--sidebar-width-icon\\)_\\+_theme\\(spacing\\.4\\)\\)\\] {
  width: calc(var(--sidebar-width-icon) + 1rem);
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw-w-\\[calc\\(var\\(--sidebar-width-icon\\)_\\+_theme\\(spacing\\.4\\)_\\+2px\\)\\] {
  width: calc(var(--sidebar-width-icon) + 1rem + 2px);
}
.tw-group[data-collapsible="offcanvas"] .group-data-\\[collapsible\\=offcanvas\\]\\:tw-w-0 {
  width: 0px;
}
.tw-group[data-collapsible="offcanvas"] .group-data-\\[collapsible\\=offcanvas\\]\\:tw-translate-x-0 {
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-group[data-side="secondary"] .group-data-\\[side\\=secondary\\]\\:tw-rotate-180 {
  --tw-rotate: 180deg;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw-overflow-hidden {
  overflow: hidden;
}
.tw-group[data-variant="floating"] .group-data-\\[variant\\=floating\\]\\:tw-rounded-lg {
  border-radius: var(--radius);
}
.tw-group[data-variant="floating"] .group-data-\\[variant\\=floating\\]\\:tw-border {
  border-width: 1px;
}
.tw-group[data-side="primary"] .group-data-\\[side\\=primary\\]\\:tw-border-r {
  border-right-width: 1px;
}
.tw-group[data-side="secondary"] .group-data-\\[side\\=secondary\\]\\:tw-border-l {
  border-left-width: 1px;
}
.tw-group[data-variant="floating"] .group-data-\\[variant\\=floating\\]\\:tw-border-sidebar-border {
  border-color: hsl(var(--sidebar-border));
}
.tw-group[data-collapsible="icon"] .group-data-\\[collapsible\\=icon\\]\\:tw-opacity-0 {
  opacity: 0;
}
.tw-group[data-variant="floating"] .group-data-\\[variant\\=floating\\]\\:tw-shadow {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tw-group[data-collapsible="offcanvas"] .group-data-\\[collapsible\\=offcanvas\\]\\:after\\:tw-left-full::after {
  content: var(--tw-content);
  left: 100%;
}
.tw-group[data-collapsible="offcanvas"] .group-data-\\[collapsible\\=offcanvas\\]\\:hover\\:tw-bg-sidebar:hover {
  background-color: hsl(var(--sidebar-background));
}
.tw-peer[data-variant="inset"] ~ .peer-data-\\[variant\\=inset\\]\\:tw-min-h-\\[calc\\(100svh-theme\\(spacing\\.4\\)\\)\\] {
  min-height: calc(100svh - 1rem);
}
@container (min-width: 24rem) {

  .\\@sm\\:tw-grow {
    flex-grow: 1;
  }

  .\\@sm\\:tw-basis-auto {
    flex-basis: auto;
  }
}
@media (min-width: 640px) {

  .sm\\:tw-flex {
    display: flex;
  }

  .sm\\:tw-flex-row {
    flex-direction: row;
  }

  .sm\\:tw-justify-end {
    justify-content: flex-end;
  }

  .sm\\:tw-space-x-2 > :not([hidden]) ~ :not([hidden]) {
    --tw-space-x-reverse: 0;
    margin-right: calc(0.5rem * var(--tw-space-x-reverse));
    margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
  }

  .sm\\:tw-rounded-lg {
    border-radius: var(--radius);
  }

  .sm\\:tw-text-left {
    text-align: left;
  }

  .sm\\:tw-text-start {
    text-align: start;
  }
}
@media (min-width: 768px) {

  .md\\:tw-block {
    display: block;
  }

  .md\\:tw-flex {
    display: flex;
  }

  .md\\:tw-grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .md\\:tw-text-sm {
    font-size: 0.875rem;
    line-height: 1.25rem;
  }

  .md\\:tw-opacity-0 {
    opacity: 0;
  }

  .after\\:md\\:tw-hidden::after {
    content: var(--tw-content);
    display: none;
  }

  .tw-peer[data-variant="inset"] ~ .md\\:peer-data-\\[variant\\=inset\\]\\:tw-m-2 {
    margin: 0.5rem;
  }

  .tw-peer[data-state="collapsed"][data-variant="inset"] ~ .md\\:peer-data-\\[state\\=collapsed\\]\\:peer-data-\\[variant\\=inset\\]\\:tw-ml-2 {
    margin-left: 0.5rem;
  }

  .tw-peer[data-variant="inset"] ~ .md\\:peer-data-\\[variant\\=inset\\]\\:tw-ml-0 {
    margin-left: 0px;
  }

  .tw-peer[data-variant="inset"] ~ .md\\:peer-data-\\[variant\\=inset\\]\\:tw-rounded-xl {
    border-radius: 0.75rem;
  }

  .tw-peer[data-variant="inset"] ~ .md\\:peer-data-\\[variant\\=inset\\]\\:tw-shadow {
    --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
    --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
  }
}
@media (min-width: 1024px) {

  .lg\\:tw-flex {
    display: flex;
  }

  .lg\\:tw-grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .lg\\:tw-space-x-8 > :not([hidden]) ~ :not([hidden]) {
    --tw-space-x-reverse: 0;
    margin-right: calc(2rem * var(--tw-space-x-reverse));
    margin-left: calc(2rem * calc(1 - var(--tw-space-x-reverse)));
  }
}
.ltr\\:tw-left-2:where([dir="ltr"], [dir="ltr"] *) {
  left: 0.5rem;
}
.rtl\\:tw-right-2:where([dir="rtl"], [dir="rtl"] *) {
  right: 0.5rem;
}
@media (prefers-color-scheme: dark) {

  .dark\\:tw-border-destructive {
    border-color: hsl(var(--destructive));
  }
}
.\\[\\&\\:has\\(\\[role\\=checkbox\\]\\)\\]\\:tw-pe-0:has([role=checkbox]) {
  padding-inline-end: 0px;
}
.\\[\\&\\>img\\+div\\]\\:tw-translate-y-\\[-3px\\]>img+div {
  --tw-translate-y: -3px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.\\[\\&\\>img\\]\\:tw-absolute>img {
  position: absolute;
}
.\\[\\&\\>img\\]\\:tw-left-4>img {
  left: 1rem;
}
.\\[\\&\\>img\\]\\:tw-top-4>img {
  top: 1rem;
}
.\\[\\&\\>img\\]\\:tw-text-destructive>img {
  color: hsl(var(--destructive));
}
.\\[\\&\\>img\\]\\:tw-text-foreground>img {
  color: hsl(var(--foreground));
}
.\\[\\&\\>img\\~\\*\\]\\:tw-pl-7>img~* {
  padding-left: 1.75rem;
}
.\\[\\&\\>span\\:last-child\\]\\:tw-truncate>span:last-child {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.\\[\\&\\>span\\]\\:tw-line-clamp-1>span {
  overflow: hidden;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 1;
}
.\\[\\&\\>svg\\+div\\]\\:tw-translate-y-\\[-3px\\]>svg+div {
  --tw-translate-y: -3px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.\\[\\&\\>svg\\]\\:tw-absolute>svg {
  position: absolute;
}
.\\[\\&\\>svg\\]\\:tw-left-4>svg {
  left: 1rem;
}
.\\[\\&\\>svg\\]\\:tw-top-4>svg {
  top: 1rem;
}
.\\[\\&\\>svg\\]\\:tw-size-4>svg {
  width: 1rem;
  height: 1rem;
}
.\\[\\&\\>svg\\]\\:tw-shrink-0>svg {
  flex-shrink: 0;
}
.\\[\\&\\>svg\\]\\:tw-text-destructive>svg {
  color: hsl(var(--destructive));
}
.\\[\\&\\>svg\\]\\:tw-text-foreground>svg {
  color: hsl(var(--foreground));
}
.\\[\\&\\>svg\\]\\:tw-text-sidebar-accent-foreground>svg {
  color: hsl(var(--sidebar-accent-foreground));
}
.\\[\\&\\>svg\\~\\*\\]\\:tw-pl-7>svg~* {
  padding-left: 1.75rem;
}
.\\[\\&\\>tr\\]\\:last\\:tw-border-b-0:last-child>tr {
  border-bottom-width: 0px;
}
.\\[\\&\\[data-panel-group-direction\\=vertical\\]\\>div\\]\\:tw-rotate-90[data-panel-group-direction=vertical]>div {
  --tw-rotate: 90deg;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.\\[\\&_\\[cmdk-group-heading\\]\\]\\:tw-px-2 [cmdk-group-heading] {
  padding-left: 0.5rem;
  padding-right: 0.5rem;
}
.\\[\\&_\\[cmdk-group-heading\\]\\]\\:tw-py-1\\.5 [cmdk-group-heading] {
  padding-top: 0.375rem;
  padding-bottom: 0.375rem;
}
.\\[\\&_\\[cmdk-group-heading\\]\\]\\:tw-text-xs [cmdk-group-heading] {
  font-size: 0.75rem;
  line-height: 1rem;
}
.\\[\\&_\\[cmdk-group-heading\\]\\]\\:tw-font-medium [cmdk-group-heading] {
  font-weight: 500;
}
.\\[\\&_\\[cmdk-group-heading\\]\\]\\:tw-text-muted-foreground [cmdk-group-heading] {
  color: hsl(var(--muted-foreground));
}
.\\[\\&_\\[cmdk-group\\]\\:not\\(\\[hidden\\]\\)_\\~\\[cmdk-group\\]\\]\\:tw-pt-0 [cmdk-group]:not([hidden]) ~[cmdk-group] {
  padding-top: 0px;
}
.\\[\\&_\\[cmdk-group\\]\\]\\:tw-px-2 [cmdk-group] {
  padding-left: 0.5rem;
  padding-right: 0.5rem;
}
.\\[\\&_\\[cmdk-input-wrapper\\]_svg\\]\\:tw-h-5 [cmdk-input-wrapper] svg {
  height: 1.25rem;
}
.\\[\\&_\\[cmdk-input-wrapper\\]_svg\\]\\:tw-w-5 [cmdk-input-wrapper] svg {
  width: 1.25rem;
}
.\\[\\&_\\[cmdk-input\\]\\]\\:tw-h-12 [cmdk-input] {
  height: 3rem;
}
.\\[\\&_\\[cmdk-item\\]\\]\\:tw-px-2 [cmdk-item] {
  padding-left: 0.5rem;
  padding-right: 0.5rem;
}
.\\[\\&_\\[cmdk-item\\]\\]\\:tw-py-3 [cmdk-item] {
  padding-top: 0.75rem;
  padding-bottom: 0.75rem;
}
.\\[\\&_\\[cmdk-item\\]_svg\\]\\:tw-h-5 [cmdk-item] svg {
  height: 1.25rem;
}
.\\[\\&_\\[cmdk-item\\]_svg\\]\\:tw-w-5 [cmdk-item] svg {
  width: 1.25rem;
}
.\\[\\&_p\\]\\:tw-leading-relaxed p {
  line-height: 1.625;
}
.\\[\\&_svg\\]\\:tw-pointer-events-none svg {
  pointer-events: none;
}
.\\[\\&_svg\\]\\:tw-size-4 svg {
  width: 1rem;
  height: 1rem;
}
.\\[\\&_svg\\]\\:tw-shrink-0 svg {
  flex-shrink: 0;
}
.\\[\\&_tr\\:last-child\\]\\:tw-border-0 tr:last-child {
  border-width: 0px;
}
.\\[\\&_tr\\]\\:tw-border-b tr {
  border-bottom-width: 1px;
}
[data-side=primary][data-collapsible=offcanvas] .\\[\\[data-side\\=primary\\]\\[data-collapsible\\=offcanvas\\]_\\&\\]\\:tw--right-2 {
  right: -0.5rem;
}
[data-side=primary][data-state=collapsed] .\\[\\[data-side\\=primary\\]\\[data-state\\=collapsed\\]_\\&\\]\\:tw-cursor-e-resize {
  cursor: e-resize;
}
[data-side=secondary][data-collapsible=offcanvas] .\\[\\[data-side\\=secondary\\]\\[data-collapsible\\=offcanvas\\]_\\&\\]\\:tw--left-2 {
  left: -0.5rem;
}
[data-side=secondary][data-state=collapsed] .\\[\\[data-side\\=secondary\\]\\[data-state\\=collapsed\\]_\\&\\]\\:tw-cursor-w-resize {
  cursor: w-resize;
}
[data-side=secondary] .\\[\\[data-side\\=secondary\\]_\\&\\]\\:tw-cursor-e-resize {
  cursor: e-resize;
}
[data-side=secondary] .\\[\\[data-side\\=secondary\\]_\\&\\]\\:tw-cursor-w-resize {
  cursor: w-resize;
}
/* By default the editor is too tall for the footnote editor, even while empty, so this makes it 
   shorter. */
.footnote-editor .editor-input {
  min-height: 75px;
}
.banded-row:hover {
  cursor: pointer;
}

.banded-row[data-state='selected']:hover {
  cursor: default;
}
`, "after-all");
export {
  MP as Alert,
  IP as AlertDescription,
  OP as AlertTitle,
  RP as Avatar,
  LP as AvatarFallback,
  PP as AvatarImage,
  ML as BOOK_CHAPTER_CONTROL_STRING_KEYS,
  OL as BOOK_SELECTOR_STRING_KEYS,
  Vc as Badge,
  DL as BookChapterControl,
  fC as BookSelectionMode,
  IL as BookSelector,
  Me as Button,
  a2 as Card,
  BR as CardContent,
  FR as CardDescription,
  qR as CardFooter,
  LR as CardHeader,
  $R as CardTitle,
  dC as ChapterRangeSelector,
  Rg as Checkbox,
  b3 as Checklist,
  Rf as ComboBox,
  ia as Command,
  Lu as CommandEmpty,
  Mo as CommandGroup,
  Dl as CommandInput,
  Qo as CommandItem,
  oa as CommandList,
  _3 as ContextMenu,
  jP as ContextMenuCheckboxItem,
  BP as ContextMenuContent,
  C3 as ContextMenuGroup,
  qP as ContextMenuItem,
  zP as ContextMenuLabel,
  k3 as ContextMenuPortal,
  N3 as ContextMenuRadioGroup,
  UP as ContextMenuRadioItem,
  VP as ContextMenuSeparator,
  HP as ContextMenuShortcut,
  E3 as ContextMenuSub,
  FP as ContextMenuSubContent,
  $P as ContextMenuSubTrigger,
  x3 as ContextMenuTrigger,
  TC as DataTable,
  KP as Drawer,
  T3 as DrawerClose,
  GP as DrawerContent,
  QP as DrawerDescription,
  XP as DrawerFooter,
  JP as DrawerHeader,
  L2 as DrawerOverlay,
  WP as DrawerPortal,
  YP as DrawerTitle,
  S3 as DrawerTrigger,
  Os as DropdownMenu,
  rp as DropdownMenuCheckboxItem,
  Io as DropdownMenuContent,
  Fy as DropdownMenuGroup,
  jy as DropdownMenuItem,
  MC as DropdownMenuItemType,
  $u as DropdownMenuLabel,
  hC as DropdownMenuPortal,
  Pf as DropdownMenuRadioGroup,
  bo as DropdownMenuRadioItem,
  Ml as DropdownMenuSeparator,
  gC as DropdownMenuShortcut,
  pC as DropdownMenuSub,
  qy as DropdownMenuSubContent,
  By as DropdownMenuSubTrigger,
  nl as DropdownMenuTrigger,
  AC as ERROR_DUMP_STRING_KEYS,
  PL as ERROR_POPOVER_STRING_KEYS,
  DC as ErrorDump,
  LL as ErrorPopover,
  WL as FOOTNOTE_EDITOR_STRING_KEYS,
  qL as Filter,
  $L as FilterDropdown,
  BL as Footer,
  GL as FootnoteEditor,
  PR as FootnoteItem,
  JL as FootnoteList,
  n3 as INVENTORY_STRING_KEYS,
  Ca as Input,
  r3 as Inventory,
  Vt as Label,
  RL as MarkdownRenderer,
  FL as MoreInfo,
  RC as MultiSelectComboBox,
  p3 as NavigationContentSearch,
  aa as Popover,
  TL as PopoverAnchor,
  Zo as PopoverContent,
  la as PopoverTrigger,
  ZP as Progress,
  tp as RadioGroup,
  zc as RadioGroupItem,
  oC as RecentSearches,
  M3 as ResizableHandle,
  D3 as ResizablePanel,
  A3 as ResizablePanelGroup,
  y3 as ResultsCard,
  s3 as SCOPE_SELECTOR_STRING_KEYS,
  a3 as ScopeSelector,
  o3 as ScriptureResultsViewer,
  l3 as ScrollGroupSelector,
  Bg as SearchBar,
  Is as Select,
  Po as SelectContent,
  mC as SelectGroup,
  er as SelectItem,
  yC as SelectLabel,
  zy as SelectScrollDownButton,
  Uy as SelectScrollUpButton,
  vC as SelectSeparator,
  Ro as SelectTrigger,
  Rs as SelectValue,
  Pg as Separator,
  c3 as SettingsList,
  d3 as SettingsListHeader,
  u3 as SettingsListItem,
  uP as SettingsSidebar,
  i3 as SettingsSidebarContentSearch,
  h2 as Sidebar,
  g2 as SidebarContent,
  eP as SidebarFooter,
  Uh as SidebarGroup,
  nP as SidebarGroupAction,
  Vh as SidebarGroupContent,
  zh as SidebarGroupLabel,
  ZR as SidebarHeader,
  QR as SidebarInput,
  p2 as SidebarInset,
  w2 as SidebarMenu,
  iP as SidebarMenuAction,
  oP as SidebarMenuBadge,
  b2 as SidebarMenuButton,
  m2 as SidebarMenuItem,
  sP as SidebarMenuSkeleton,
  aP as SidebarMenuSub,
  cP as SidebarMenuSubButton,
  lP as SidebarMenuSubItem,
  f2 as SidebarProvider,
  YR as SidebarRail,
  tP as SidebarSeparator,
  XR as SidebarTrigger,
  Lf as Skeleton,
  eL as Slider,
  O3 as Sonner,
  AP as Spinner,
  tL as Switch,
  Hh as TabDropdownMenu,
  h3 as TabFloatingMenu,
  f3 as TabToolbar,
  Fu as Table,
  qu as TableBody,
  SC as TableCaption,
  xo as TableCell,
  CC as TableFooter,
  il as TableHead,
  Bu as TableHeader,
  hi as TableRow,
  I3 as Tabs,
  iL as TabsContent,
  nL as TabsList,
  rL as TabsTrigger,
  v3 as TextField,
  oL as Textarea,
  u2 as ToggleGroup,
  Uc as ToggleGroupItem,
  w3 as Toolbar,
  $g as Tooltip,
  gd as TooltipContent,
  Lg as TooltipProvider,
  Fg as TooltipTrigger,
  m3 as UiLanguageSelector,
  k2 as VerticalTabs,
  N2 as VerticalTabsContent,
  E2 as VerticalTabsList,
  vP as VerticalTabsTrigger,
  IC as badgeVariants,
  iC as buttonVariants,
  G as cn,
  t3 as getBookIdFromUSFM,
  ZL as getLinesFromUSFM,
  e3 as getNumberFromUSFM,
  HR as getStatusForItem,
  g3 as getToolbarOSReservedSpaceClassName,
  YL as inventoryCountColumn,
  XL as inventoryItemColumn,
  QL as inventoryStatusColumn,
  bC as selectTriggerVariants,
  B3 as sonner,
  R3 as useEvent,
  P3 as useEventAsync,
  L3 as useListbox,
  aL as usePromise,
  AL as useRecentSearches,
  wd as useSidebar
};
//# sourceMappingURL=index.js.map
