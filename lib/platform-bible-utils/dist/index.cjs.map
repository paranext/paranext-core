{"version":3,"file":"index.cjs","sources":["../src/promises/async-variable.ts","../src/intl/intl-collator.ts","../src/intl/intl-date-time-format.ts","../src/events/platform-event-emitter.model.ts","../src/util.ts","../src/document-combiner.ts","../src/event-rolling-time-counter.ts","../src/promises/mutex.ts","../src/promises/mutex-map.ts","../src/non-validating-document-combiner.ts","../src/intl/intl-number-format.ts","../src/promises/promise-chaining-map.ts","../src/sorted-number-map.ts","../src/sorted-set.ts","../src/lifetime-management/unsubscriber-async-list.ts","../src/platform-error.ts","../../../node_modules/@sillsdev/scripture/dist/index.es.js","../src/array-util.ts","../src/string-util.ts","../src/scripture/scripture-util.ts","../src/lifetime-management/unsubscriber.ts","../src/scripture/usj-reader-writer.model.ts","../src/html-utils.ts","../src/scripture/footnote-util.ts","../src/pane-utils.ts","../../../node_modules/fast-equals/dist/esm/index.mjs","../src/equality-checking.ts","../src/subset-checking.ts","../src/serialization.ts","../src/intl/intl-util.ts","../src/number-utils.ts","../src/date-time-format-util.ts","../src/keyboard-util.ts","../src/extension-contributions/settings.model.ts","../src/extension-contributions/localized-strings.model.ts","../src/extension-contributions/menus.model.ts","../src/extension-contributions/theme.model.ts","../src/extension-contributions/theme.util.ts","../src/scripture/markers-maps/markers-map-3.0.model.ts","../src/scripture/usj-reader-writer.ts"],"sourcesContent":["/** This class provides a convenient way for one task to wait on a variable that another task sets. */\nexport class AsyncVariable<T> {\n  private static verboseLoggingEnabled: boolean = false;\n  private readonly variableName: string;\n  private readonly promiseToValue: Promise<T>;\n  private timeoutId: ReturnType<typeof setTimeout> | undefined;\n  private timeoutOccurred: boolean;\n  private resolver: ((value: T) => void) | undefined;\n  private rejecter: ((reason: string | undefined) => void) | undefined;\n\n  /**\n   * Creates an instance of the class\n   *\n   * @param variableName Name to use when logging about this variable\n   * @param rejectIfNotSettledWithinMS Milliseconds to wait before verifying if the promise was\n   *   settled (resolved or rejected); will reject if it has not settled by that time. Use -1 if you\n   *   do not want a timeout at all. Defaults to 10000 ms\n   */\n  constructor(variableName: string, rejectIfNotSettledWithinMS: number = 10000) {\n    this.variableName = variableName;\n    this.timeoutOccurred = false;\n    this.promiseToValue = new Promise<T>((resolve, reject) => {\n      this.resolver = resolve;\n      this.rejecter = reject;\n    });\n    if (rejectIfNotSettledWithinMS > 0) {\n      this.timeoutId = setTimeout(() => {\n        if (this.rejecter) {\n          this.rejecter(`Timeout reached when waiting for ${this.variableName} to settle`);\n          this.timeoutOccurred = true;\n          this.complete();\n        }\n      }, rejectIfNotSettledWithinMS);\n    }\n    Object.seal(this);\n  }\n\n  /**\n   * Get this variable's promise to a value. This always returns the same promise even after the\n   * value has been resolved or rejected.\n   *\n   * @returns The promise for the value to be set\n   */\n  get promise(): Promise<T> {\n    return this.promiseToValue;\n  }\n\n  /**\n   * A simple way to see if this variable's promise was resolved or rejected already\n   *\n   * @returns Whether the variable was already resolved or rejected\n   */\n  get hasSettled(): boolean {\n    return Object.isFrozen(this);\n  }\n\n  /**\n   * Can use to determine if a rejection occurred due to a timeout\n   *\n   * @returns Whether the variable timed out while waiting for a value to resolve\n   */\n  get hasTimedOut(): boolean {\n    return this.timeoutOccurred;\n  }\n\n  /**\n   * Allows enabling more verbose logging when async variables resolve and reject\n   *\n   * @param enabled Whether to enable verbose logging\n   */\n  static setVerboseLogging(enabled: boolean): void {\n    this.verboseLoggingEnabled = enabled;\n  }\n\n  /**\n   * Resolve this variable's promise to the given value\n   *\n   * @param value This variable's promise will resolve to this value\n   * @param throwIfAlreadySettled Determines whether to throw if the variable was already resolved\n   *   or rejected. Defaults to `false`\n   */\n  resolveToValue(value: T, throwIfAlreadySettled: boolean = false): void {\n    if (this.resolver) {\n      if (AsyncVariable.verboseLoggingEnabled)\n        console.debug(`${this.variableName} is being resolved now`);\n      this.resolver(value);\n      this.complete();\n    } else {\n      if (throwIfAlreadySettled) throw Error(`${this.variableName} was already settled`);\n      console.debug(`Ignoring subsequent resolution of ${this.variableName}`);\n    }\n  }\n\n  /**\n   * Reject this variable's promise for the value with the given reason\n   *\n   * @param reason This variable's promise will be rejected with this reason\n   * @param throwIfAlreadySettled Determines whether to throw if the variable was already resolved\n   *   or rejected. Defaults to `false`\n   */\n  rejectWithReason(reason: string, throwIfAlreadySettled: boolean = false): void {\n    if (this.rejecter) {\n      if (AsyncVariable.verboseLoggingEnabled)\n        console.debug(`${this.variableName} is being rejected now with reason: ${reason}`);\n      this.rejecter(reason);\n      this.complete();\n    } else {\n      if (throwIfAlreadySettled) throw Error(`${this.variableName} was already settled`);\n      console.debug(`Ignoring subsequent rejection of ${this.variableName}`);\n    }\n  }\n\n  /** Prevent any further updates to this variable */\n  private complete(): void {\n    this.resolver = undefined;\n    this.rejecter = undefined;\n    if (this.timeoutId !== undefined) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = undefined;\n    }\n    Object.freeze(this);\n  }\n}\n\nexport default AsyncVariable;\n","/** Enables language-sensitive string comparison. Wraps Intl.Collator */\nexport class Collator {\n  private collator: Intl.Collator;\n\n  constructor(locales?: string | string[], options?: Intl.CollatorOptions) {\n    this.collator = new Intl.Collator(locales, options);\n  }\n\n  /**\n   * Compares two strings according to the sort order of this Collator object\n   *\n   * @param string1 String to compare\n   * @param string2 String to compare\n   * @returns A number indicating how string1 and string2 compare to each other according to the\n   *   sort order of this Collator object. Negative value if string1 comes before string2. Positive\n   *   value if string1 comes after string2. 0 if they are considered equal.\n   */\n  compare(string1: string, string2: string): number {\n    return this.collator.compare(string1, string2);\n  }\n\n  /**\n   * Returns a new object with properties reflecting the locale and collation options computed\n   * during initialization of this collator object.\n   *\n   * @returns ResolvedCollatorOptions object\n   */\n  resolvedOptions(): Intl.ResolvedCollatorOptions {\n    return this.collator.resolvedOptions();\n  }\n}\n\nexport default Collator;\n","/** Enables language-sensitive data and time formatting. Wraps Intl.DateTimeFormat */\nexport class DateTimeFormat {\n  private dateTimeFormatter: Intl.DateTimeFormat;\n\n  constructor(locales?: string | string[], options?: Intl.DateTimeFormatOptions) {\n    this.dateTimeFormatter = new Intl.DateTimeFormat(locales, options);\n  }\n\n  /**\n   * Formats a date according to the locale and formatting option for this DateTimeFormat object\n   *\n   * @param date The date to format\n   * @returns String representing the given date formatted according to the locale and formatting\n   *   options of this DateTimeFormat object\n   */\n  format(date: Date): string {\n    return this.dateTimeFormatter.format(date);\n  }\n\n  /**\n   * Formats a date range in the most concise way based on the locales and options provided when\n   * instantiating this DateTimeFormat object\n   *\n   * @param startDate Date object representing start of the date range\n   * @param endDate Date object representing the end of the date range\n   * @returns String representing the given date range formatted according to the locale and\n   *   formatting options of this DateTimeFormat object\n   */\n  formatRange(startDate: Date, endDate: Date): string {\n    return this.dateTimeFormatter.formatRange(startDate, endDate);\n  }\n\n  /**\n   * Returns an array of locale-specific tokens representing each part of the formatted date range\n   * produced by this DateTimeFormat object\n   *\n   * @param startDate Date object representing start of the date range\n   * @param endDate Date object representing the end of the date range\n   * @returns Array of DateTimeRangeFormatPart objects\n   */\n  formatRangeToParts(startDate: Date, endDate: Date): Intl.DateTimeRangeFormatPart[] {\n    return this.dateTimeFormatter.formatRangeToParts(startDate, endDate);\n  }\n\n  /**\n   * Allows locale-aware formatting of strings produced by this DateTimeFormat object\n   *\n   * @param date The date to format\n   * @returns Array of DateTimeFormatPart objects\n   */\n  formatToParts(date: Date): Intl.DateTimeFormatPart[] {\n    return this.dateTimeFormatter.formatToParts(date);\n  }\n\n  /**\n   * Returns a new object with properties reflecting the locale and date and time formatting options\n   * computed during initialization of this DateTimeFormat object\n   *\n   * @returns ResolvedDateTimeFormatOptions object\n   */\n  resolvedOptions(): Intl.ResolvedDateTimeFormatOptions {\n    return this.dateTimeFormatter.resolvedOptions();\n  }\n}\n\nexport default DateTimeFormat;\n","/** Interfaces, classes, and functions related to events and event emitters */\n\nimport { Dispose } from '../lifetime-management/disposal.model';\nimport { PlatformEvent, PlatformEventHandler } from './platform-event';\n\n/**\n * Event manager - accepts subscriptions to an event and runs the subscription callbacks when the\n * event is emitted Use eventEmitter.event(callback) to subscribe to the event. Use\n * eventEmitter.emit(event) to run the subscriptions. Generally, this EventEmitter should be\n * private, and its event should be public. That way, the emitter is not publicized, but anyone can\n * subscribe to the event.\n */\nexport class PlatformEventEmitter<T> implements Dispose {\n  /**\n   * Subscribes a function to run when this event is emitted.\n   *\n   * @param callback Function to run with the event when it is emitted\n   * @returns Unsubscriber function to run to stop calling the passed-in function when the event is\n   *   emitted\n   */\n  subscribe = this.event;\n\n  /** All callback functions that will run when this event is emitted. Lazy loaded */\n  private subscriptions?: PlatformEventHandler<T>[];\n  /** Event for listeners to subscribe to. Lazy loaded */\n  private lazyEvent?: PlatformEvent<T>;\n  /** Whether this emitter has been disposed */\n  private isDisposed = false;\n\n  /**\n   * Event for listeners to subscribe to. Subscribes a function to run when this event is emitted.\n   * Use like `const unsubscriber = event(callback)`\n   *\n   * @returns Unsubscriber function to run to stop calling the passed-in function when the event is\n   *   emitted\n   */\n  get event(): PlatformEvent<T> {\n    this.assertNotDisposed();\n\n    if (!this.lazyEvent) {\n      this.lazyEvent = (callback) => {\n        if (!callback || typeof callback !== 'function')\n          throw new Error(`Event handler callback must be a function!`);\n\n        // Initialize this.subscriptions if it does not exist\n        if (!this.subscriptions) this.subscriptions = [];\n\n        this.subscriptions.push(callback);\n\n        return () => {\n          if (!this.subscriptions) return false; // Did not find any subscribed callbacks\n\n          const callbackIndex = this.subscriptions.indexOf(callback);\n\n          if (callbackIndex < 0) return false; // Did not find this callback in the subscriptions\n\n          // Remove the callback\n          this.subscriptions.splice(callbackIndex, 1);\n\n          return true;\n        };\n      };\n    }\n    return this.lazyEvent;\n  }\n\n  /** Disposes of this event, preparing it to release from memory */\n  dispose = () => {\n    return this.disposeFn();\n  };\n\n  /**\n   * Runs the subscriptions for the event\n   *\n   * @param event Event data to provide to subscribed callbacks\n   */\n  emit = (event: T) => {\n    // Do not do anything other than emitFn here. This emit is just binding `this` to emitFn\n    this.emitFn(event);\n  };\n\n  /**\n   * Function that runs the subscriptions for the event. Added here so children can override emit\n   * and still call the base functionality. See NetworkEventEmitter.emit for example\n   */\n  protected emitFn(event: T) {\n    this.assertNotDisposed();\n\n    // Clone the subscriptions array before iterating over the callbacks so the callback index\n    // doesn't get messed up if someone subscribes or unsubscribes inside one of the callbacks\n    const emitCallbacks = [...(this.subscriptions ?? [])];\n    emitCallbacks.forEach((callback) => callback(event));\n  }\n\n  /** Check to make sure this emitter is not disposed. Throw if it is */\n  protected assertNotDisposed() {\n    if (this.isDisposed) throw new Error('Emitter is disposed');\n  }\n\n  /**\n   * Disposes of this event, preparing it to release from memory. Added here so children can\n   * override emit and still call the base functionality.\n   */\n  protected disposeFn() {\n    this.assertNotDisposed();\n\n    this.isDisposed = true;\n    this.subscriptions = undefined;\n    this.lazyEvent = undefined;\n    return Promise.resolve(true);\n  }\n}\n\nexport default PlatformEventEmitter;\n","/** Collection of functions, objects, and types that are used as helpers in other services. */\n\n// Thanks to blubberdiblub at https://stackoverflow.com/a/68141099/217579\nexport function newGuid(): string {\n  return '00-0-4-1-000'.replace(/[^-]/g, (s) =>\n    // @ts-expect-error ts(2363) this works fine\n    // eslint-disable-next-line no-bitwise\n    (((Math.random() + ~~s) * 0x10000) >> s).toString(16).padStart(4, '0'),\n  );\n}\n\n// thanks to DRAX at https://stackoverflow.com/a/9436948\n/**\n * Determine whether the object is a string\n *\n * @param o Object to determine if it is a string\n * @returns True if the object is a string; false otherwise\n */\nexport function isString(o: unknown): o is string {\n  return typeof o === 'string' || o instanceof String;\n}\n\n/**\n * If deepClone isn't used when copying properties between objects, you may be left with dangling\n * references between the source and target of property copying operations.\n *\n * @param obj Object to clone\n * @returns Duplicate copy of `obj` without any references back to the original one\n */\nexport function deepClone<T>(obj: T): T {\n  // Assert the return type matches what is expected\n  // eslint-disable-next-line no-type-assertion/no-type-assertion\n  return JSON.parse(JSON.stringify(obj)) as T;\n}\n\n/**\n * Get a function that reduces calls to the function passed in\n *\n * @template TFunc - A function type that takes any arguments and returns void. This is the type of\n *   the function being debounced.\n * @param fn The function to debounce\n * @param delay How much delay in milliseconds after the most recent call to the debounced function\n *   to call the function\n * @returns Function that, when called, only calls the function passed in at maximum every delay ms\n */\n// We don't know the parameter types since this function can be anything and can return anything\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function debounce<TFunc extends (...args: any[]) => any>(\n  fn: TFunc,\n  delay = 300,\n): (...args: Parameters<TFunc>) => Promise<ReturnType<TFunc>> {\n  let timeout: ReturnType<typeof setTimeout>;\n  let promise: Promise<ReturnType<TFunc>> | undefined;\n  let promiseResolve: (value: ReturnType<TFunc> | PromiseLike<ReturnType<TFunc>>) => void;\n  let promiseReject: (reason?: unknown) => void;\n\n  return (...args) => {\n    clearTimeout(timeout);\n    if (!promise)\n      promise = new Promise((resolve, reject) => {\n        promiseResolve = resolve;\n        promiseReject = reject;\n      });\n\n    timeout = setTimeout(async () => {\n      try {\n        promiseResolve(await fn(...args));\n      } catch (e) {\n        promiseReject(e);\n      } finally {\n        promise = undefined;\n      }\n    }, delay);\n\n    return promise;\n  };\n}\n\n/**\n * Groups each item in the array of items into a map according to the keySelector\n *\n * There are two overloads:\n *\n * - `groupBy(items, keySelector)` – groups the original items using the key returned by\n *   `keySelector`.\n * - `groupBy(items, keySelector, valueSelector)` – groups transformed values using the key returned\n *   by `keySelector` and the value returned by `valueSelector`.\n *\n * `valueSelector` is an optional third parameter. It is a function that runs on each item to get\n * the value to store in the group. The first argument is the item, the second argument is the key\n * for the group to which this item belongs, and the third argument is the index of the item in the\n * original array. If `valueSelector` is not provided, the original item is used in the resulting\n * groups.\n *\n * @param items - Array of items to group by.\n * @param keySelector - Function to run on each item to get the key for the group to which it\n *   belongs. The first argument is the item, and the second argument is the index of the item in\n *   the original array.\n * @returns Map of keys to groups of values corresponding to each item.\n */\nexport function groupBy<T, K>(\n  items: T[],\n  keySelector: (item: T, index: number) => K,\n): Map<K, Array<T>>;\nexport function groupBy<T, K, V>(\n  items: T[],\n  keySelector: (item: T, index: number) => K,\n  valueSelector: (item: T, key: K, index: number) => V,\n): Map<K, Array<V>>;\nexport function groupBy<T, K, V = T>(\n  items: T[],\n  keySelector: (item: T, index: number) => K,\n  valueSelector?: (item: T, key: K, index: number) => V,\n): Map<K, Array<V | T>> {\n  const map = new Map<K, Array<V | T>>();\n  items.forEach((item, index) => {\n    const key = keySelector(item, index);\n    const group = map.get(key);\n    const value = valueSelector ? valueSelector(item, key, index) : item;\n    if (group) group.push(value);\n    else map.set(key, [value]);\n  });\n  return map;\n}\n\n// From https://kentcdodds.com/blog/get-a-catch-block-error-message-with-typescript\ntype ErrorWithMessage = {\n  message: string;\n};\n\n// From https://kentcdodds.com/blog/get-a-catch-block-error-message-with-typescript\nfunction isErrorWithMessage(error: unknown): error is ErrorWithMessage {\n  return (\n    typeof error === 'object' &&\n    // We're potentially dealing with objects we didn't create, so they might contain `null`\n    // eslint-disable-next-line no-null/no-null\n    error !== null &&\n    'message' in error &&\n    // Type assert `error` to check it's `message`.\n    // eslint-disable-next-line no-type-assertion/no-type-assertion\n    typeof (error as Record<string, unknown>).message === 'string'\n  );\n}\n\n// From https://kentcdodds.com/blog/get-a-catch-block-error-message-with-typescript\n/**\n * Function to get an error from the object (useful for getting an error in a catch block)\n *\n * @param error Error object whose message to get\n * @returns Message of the error - if object has message, returns message. Otherwise tries to\n *   stringify\n */\nfunction toErrorWithMessage(maybeError: unknown): ErrorWithMessage {\n  if (isErrorWithMessage(maybeError)) return maybeError;\n\n  try {\n    return new Error(JSON.stringify(maybeError));\n  } catch {\n    // fallback in case there's an error stringifying the maybeError\n    // like with circular references for example.\n    return new Error(String(maybeError));\n  }\n}\n\n// From https://kentcdodds.com/blog/get-a-catch-block-error-message-with-typescript\n/**\n * Function to get an error message from the object (useful for getting error message in a catch\n * block)\n *\n * @example `try {...} catch (e) { logger.info(getErrorMessage(e)) }`\n *\n * @param error Error object whose message to get\n * @returns Message of the error - if object has message, returns message. Otherwise tries to\n *   stringify\n */\nexport function getErrorMessage(error: unknown) {\n  return toErrorWithMessage(error).message;\n}\n\n/** Asynchronously waits for the specified number of milliseconds. (wraps setTimeout in a promise) */\nexport function wait(ms: number) {\n  // eslint-disable-next-line no-promise-executor-return\n  return new Promise<void>((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Runs the specified function and will timeout if it takes longer than the specified wait time\n *\n * @param fn The function to run\n * @param maxWaitTimeInMS The maximum amount of time to wait for the function to resolve\n * @returns Promise that resolves to the resolved value of the function or undefined if it ran\n *   longer than the specified wait time\n */\nexport function waitForDuration<TResult>(fn: () => Promise<TResult>, maxWaitTimeInMS: number) {\n  const timeout = wait(maxWaitTimeInMS).then(() => undefined);\n  return Promise.any([timeout, fn()]);\n}\n\n/**\n * Get all functions on an object and its prototype chain (so we don't miss any class methods or any\n * object methods). Note that the functions on the final item in the prototype chain (i.e., Object)\n * are skipped to avoid including functions like `__defineGetter__`, `__defineSetter__`, `toString`,\n * etc.\n *\n * @param obj Object whose functions to get\n * @param _objId Optional ID of the object to use for debug logging\n * @returns Array of all function names on an object\n */\n// Note: lodash has something that MIGHT do the same thing as this. Investigate for https://github.com/paranext/paranext-core/issues/134\nexport function getAllObjectFunctionNames(\n  obj: { [property: string]: unknown },\n  // Leaving it here for debugging\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _objId: string = 'obj',\n): Set<string> {\n  const objectFunctionNames = new Set<string>();\n\n  // Get all function properties directly defined on the object\n  Object.getOwnPropertyNames(obj).forEach((property) => {\n    try {\n      if (typeof obj[property] === 'function') objectFunctionNames.add(property);\n    } catch (error) {\n      // Too noisy - only reenable if you need more details\n      // console.trace(`Skipping ${property} on ${objId} due to error: ${error}`);\n    }\n  });\n\n  // Walk up the prototype chain and get additional function properties, skipping the functions\n  // provided by the final (Object) prototype\n  let objectPrototype = Object.getPrototypeOf(obj);\n  while (objectPrototype && Object.getPrototypeOf(objectPrototype)) {\n    Object.getOwnPropertyNames(objectPrototype).forEach((property) => {\n      try {\n        if (typeof obj[property] === 'function') objectFunctionNames.add(property);\n      } catch (error) {\n        // Too noisy - only reenable if you need more details\n        // console.trace(`Skipping ${property} on ${objId}'s prototype due to error: ${error}`);\n      }\n    });\n    objectPrototype = Object.getPrototypeOf(objectPrototype);\n  }\n\n  return objectFunctionNames;\n}\n\n/**\n * Creates a synchronous proxy for an asynchronous object. The proxy allows calling methods on an\n * object that is asynchronously fetched using a provided asynchronous function.\n *\n * @param getObject - A function that returns a promise resolving to the object whose asynchronous\n *   methods to call.\n * @param objectToProxy - An optional object that is the object that is proxied. If a property is\n *   accessed that does exist on this object, it will be returned. If a property is accessed that\n *   does not exist on this object, it will be considered to be an asynchronous method called on the\n *   object returned from getObject.\n * @returns A synchronous proxy for the asynchronous object.\n */\nexport function createSyncProxyForAsyncObject<T extends object>(\n  getObject: (args?: unknown[]) => Promise<T>,\n  objectToProxy: Partial<T> = {},\n): T {\n  // objectToProxy will have only the synchronously accessed properties of T on it, and this proxy\n  // makes the async methods that do not exist yet available synchronously so we have all of T\n  // eslint-disable-next-line no-type-assertion/no-type-assertion\n  return new Proxy(objectToProxy as T, {\n    get(target, prop) {\n      // We don't have any type information for T, so we assume methodName exists on it and will let JavaScript throw if it doesn't exist\n      // @ts-expect-error 7053\n      if (prop in target) return target[prop];\n      return async (...args: unknown[]) => {\n        // 7053: We don't have any type information for T, so we assume methodName exists on it and will let JavaScript throw if it doesn't exist\n        // 2556: The args here are the parameters for the method specified\n        // @ts-expect-error 7053 2556\n        return (await getObject())[prop](...args);\n      };\n    },\n  });\n}\n\n/**\n * Indicates if the exception or error message provided appears to be from ParatextData.dll\n * indicating that Paratext is blocking internet access.\n *\n * @param errorMessage Error message or exception to check\n * @returns `true` if the message indicates Paratext is blocking internet access, `false` otherwise\n */\nexport function isErrorMessageAboutParatextBlockingInternetAccess(errorMessage: unknown): boolean {\n  // Copied from ParatextData/InternetAccess.cs, not a localized string\n  const paratextExceptionMessage =\n    'Bug in Paratext caused attempted access to Internet. Request has been blocked.';\n\n  if (isString(errorMessage)) return errorMessage.includes(paratextExceptionMessage);\n  return getErrorMessage(errorMessage).includes(paratextExceptionMessage);\n}\n\n/**\n * Indicates if the exception or error message provided appears to be from ParatextData.dll\n * indicating that an authorization failure occurred regarding registry credentials.\n *\n * @param errorMessage Error message or exception to check\n * @returns `true` if the message indicates an auth failure, `false` otherwise\n */\nexport function isErrorMessageAboutRegistryAuthFailure(errorMessage: unknown): boolean {\n  // Copied from ParatextProjectSendReceiveService.cs, not a localized string\n  const paratextExceptionMessage1 = '401 Unauthorized error while getting shared projects.';\n  // Copied from DblDownloadableDataProvider.cs, not a localized string\n  const paratextExceptionMessage2 =\n    'User registration is not valid. Cannot retrieve resources from DBL.';\n\n  const errorString = isString(errorMessage) ? errorMessage : getErrorMessage(errorMessage);\n  return (\n    errorString.includes(paratextExceptionMessage1) ||\n    errorString.includes(paratextExceptionMessage2)\n  );\n}\n\n/** Within type T, recursively change all properties to be optional */\nexport type DeepPartial<T> = T extends object ? { [P in keyof T]?: DeepPartial<T[P]> } : T;\n\n/** Within type T, recursively change properties that were of type A to be of type B */\nexport type ReplaceType<T, A, B> = T extends A\n  ? B\n  : T extends object\n    ? { [K in keyof T]: ReplaceType<T[K], A, B> }\n    : T;\n\n/**\n * Converts a string type from camelCase to kebab-case. Note this simply inserts hyphens before\n * uppercase letters and converts them to lowercase. It does not handle special cases like acronyms\n * or symbols. It can result in multiple hyphens in a row, leading hyphens, or trailing hyphens.\n *\n * By using this as the type for a string parameter or string property, you can enforce (somewhat)\n * at compile time that the string is in kebab-case format assuming it is provided as a string\n * literal.\n *\n * @example\n *\n * ```typescript\n * type Kebab1 = KebabCase<'backgroundColor'>; // 'background-color'\n * type Kebab2 = KebabCase<'HTMLParser'>; // '-h-t-m-l-parser'\n * type Kebab3 = KebabCase<'simpletest'>; // 'simpletest'\n * type Kebab4 = KebabCase<'My$Value'>; // '-my$-value'\n * ```\n */\nexport type KebabCase<T extends string> = T extends `${infer First}${infer Rest}`\n  ? `${First extends Lowercase<First> ? First : `-${Lowercase<First>}`}${KebabCase<Rest>}`\n  : T;\n\n// Thanks to jcalz at https://stackoverflow.com/a/50375286\n/**\n * Converts a union type to an intersection type (`|` to `&`).\n *\n * Note: this utility type is for use on object types. It may fail on other types.\n *\n * @example\n *\n * ```typescript\n * type TypeOne = { one: string };\n * type TypeTwo = { two: number };\n * type TypeThree = { three: string };\n *\n * type TypeNums = { one: TypeOne; two: TypeTwo; three: TypeThree };\n * const numNames = ['one', 'two'] as const;\n * type TypeNumNames = typeof numNames;\n *\n * // Same as `TypeOne | TypeTwo`\n * // `{ one: string } | { two: number }`\n * type TypeOneTwoUnion = TypeNums[TypeNumNames[number]];\n *\n * // Same as `TypeOne & TypeTwo`\n * // `{ one: string; two: number }`\n * type TypeOneTwoIntersection = UnionToIntersection<TypeOneTwoUnion>;\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (\n  x: infer I,\n) => void\n  ? I\n  : never;\n\n/**\n * Force VSCode to expand all the properties of a type by using this type. Useful for making complex\n * types more readable in hover tooltips.\n *\n * @example\n *\n * ```ts\n * type MyType = Prettify<SomeComplexType>;\n * ```\n */\nexport type Prettify<T> = {\n  [K in keyof T]: T[K];\n} & {};\n","import { PlatformEventEmitter } from './events/platform-event-emitter.model';\nimport { deepClone } from './util';\n\ntype JsonObjectLike = { [key: string]: unknown };\ntype JsonArrayLike = unknown[];\n\nexport type JsonDocumentLike = JsonObjectLike | JsonArrayLike;\n\n/**\n * Options for DocumentCombiner objects\n *\n * - `copyDocuments`: If true, this instance will perform a deep copy of all provided documents before\n *   composing the output. If false, then changes made to provided documents after they are\n *   contributed will be reflected in the next time output is composed.\n * - `ignoreDuplicateProperties`: If true, then duplicate properties are skipped if they are seen in\n *   contributed documents. If false, then throw when duplicate properties are seen in contributed\n *   documents.\n */\nexport type DocumentCombinerOptions = {\n  copyDocuments: boolean;\n  ignoreDuplicateProperties: boolean;\n};\n\n/**\n * Base class for any code that wants to compose JSON documents (primarily in the form of JS objects\n * or arrays) together into a single output document.\n */\nexport class DocumentCombiner {\n  protected baseDocument: JsonDocumentLike;\n  protected readonly contributions = new Map<string, JsonDocumentLike>();\n  protected latestOutput: JsonDocumentLike | undefined;\n  protected readonly options: DocumentCombinerOptions;\n  private readonly onDidRebuildEmitter = new PlatformEventEmitter<undefined>();\n  /** Event that emits to announce that the document has been rebuilt and the output has been updated */\n  // Need `onDidRebuildEmitter` to be instantiated before this line\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  readonly onDidRebuild = this.onDidRebuildEmitter.subscribe;\n\n  /**\n   * Create a DocumentCombiner instance\n   *\n   * @param baseDocument This is the first document that will be used when composing the output\n   * @param options Options used by this object when combining documents\n   */\n  protected constructor(baseDocument: JsonDocumentLike, options: DocumentCombinerOptions) {\n    // Setting baseDocument redundantly because TS doesn't understand that updateBaseDocument does it\n    this.baseDocument = baseDocument;\n    this.options = options;\n    this.updateBaseDocument(baseDocument);\n  }\n\n  /**\n   * Update the starting document for composition process\n   *\n   * @param baseDocument Base JSON document/JS object that all other documents are added to\n   * @returns Recalculated output document given the new starting state and existing other documents\n   */\n  updateBaseDocument(baseDocument: JsonDocumentLike): JsonDocumentLike | undefined {\n    this.validateBaseDocument(baseDocument);\n    this.baseDocument = this.options.copyDocuments ? deepClone(baseDocument) : baseDocument;\n    this.baseDocument = this.transformBaseDocumentAfterValidation(this.baseDocument);\n    return this.rebuild();\n  }\n\n  /**\n   * Add or update one of the contribution documents for the composition process\n   *\n   * Note: the order in which contribution documents are added can be considered indeterminate as it\n   * depends on the order in which `Map.forEach` iterates over the contributions. However, the order\n   * matters when merging two arrays into one. Also, when `options.ignoreDuplicateProperties` is is\n   * `true`, the order also matters when adding the same property to an object that is already\n   * provided previously. Please let us know if you have trouble because of indeterminate\n   * contribution ordering.\n   *\n   * @param documentName Name of the contributed document to combine\n   * @param document Content of the contributed document to combine\n   * @returns Recalculated output document given the new or updated contribution and existing other\n   *   documents\n   */\n  addOrUpdateContribution(\n    documentName: string,\n    document: JsonDocumentLike,\n  ): JsonDocumentLike | undefined {\n    this.validateContribution(documentName, document);\n    const previousDocumentVersion = this.contributions.get(documentName);\n    let documentToSet = this.options.copyDocuments && !!document ? deepClone(document) : document;\n    documentToSet = this.transformContributionAfterValidation(documentName, documentToSet);\n    this.contributions.set(documentName, documentToSet);\n    try {\n      return this.rebuild();\n    } catch (error) {\n      // If the output isn't valid after adding/updating the contribution, put it back how it was\n      if (previousDocumentVersion) this.contributions.set(documentName, previousDocumentVersion);\n      else this.contributions.delete(documentName);\n      throw new Error(`Error when setting the document named ${documentName}: ${error}`);\n    }\n  }\n\n  /**\n   * Delete one of the contribution documents for the composition process\n   *\n   * @param documentName Name of the contributed document to delete\n   * @returns Recalculated output document given the remaining other documents\n   */\n  deleteContribution(documentName: string): JsonDocumentLike | undefined {\n    const document = this.contributions.get(documentName);\n    if (!document) throw new Error(`${documentName} does not exist`);\n    this.contributions.delete(documentName);\n    try {\n      return this.rebuild();\n    } catch (error) {\n      // If the output isn't valid after deleting the contribution, put it back and rethrow\n      this.contributions.set(documentName, document);\n      throw new Error(`Error when deleting the document named ${documentName}: ${error}`);\n    }\n  }\n\n  /**\n   * Delete all present contribution documents for the composition process and return to the base\n   * document\n   *\n   * @returns Recalculated output document consisting only of the base document\n   */\n  deleteAllContributions(): JsonDocumentLike | undefined {\n    if (this.contributions.size <= 0) return this.latestOutput;\n\n    // Save out all contributions\n    const contributions = [...this.contributions.entries()];\n\n    // Delete all contributions\n    contributions.forEach(([contributionName]) => this.contributions.delete(contributionName));\n\n    // Rebuild with no contributions\n    try {\n      return this.rebuild();\n    } catch (error) {\n      // If the output isn't valid after deleting all contributions, put them back and rethrow\n      contributions.forEach(([contributionName, document]) =>\n        this.contributions.set(contributionName, document),\n      );\n      throw new Error(`Error when deleting all contributions: ${error}`);\n    }\n  }\n\n  /**\n   * Run the document composition process given the starting document and all contributions. Throws\n   * if the output document fails to validate properly.\n   *\n   * @returns Recalculated output document given the starting and contributed documents\n   */\n  rebuild(): JsonDocumentLike | undefined {\n    // The starting document is the output if there are no other contributions\n    if (this.contributions.size === 0) {\n      let potentialOutput = deepClone(this.baseDocument);\n      potentialOutput = this.transformFinalOutputBeforeValidation(potentialOutput);\n      this.validateOutput(potentialOutput);\n      this.latestOutput = potentialOutput;\n      this.onDidRebuildEmitter.emit(undefined);\n      return this.latestOutput;\n    }\n\n    // Compose the output by validating each document one at a time to pinpoint errors better\n    let outputIteration = this.baseDocument;\n    this.contributions.forEach((contribution: JsonDocumentLike) => {\n      outputIteration = mergeObjects(\n        outputIteration,\n        contribution,\n        this.options.ignoreDuplicateProperties,\n      );\n      this.validateOutput(outputIteration);\n    });\n    outputIteration = this.transformFinalOutputBeforeValidation(outputIteration);\n    this.validateOutput(outputIteration);\n    this.latestOutput = outputIteration;\n    this.onDidRebuildEmitter.emit(undefined);\n    return this.latestOutput;\n  }\n\n  /**\n   * Transform the starting document that is given to the combiner. This transformation occurs after\n   * validating the base document and before combining any contributions.\n   *\n   * WARNING: If you do not create the combiner with option `copyDocuments: true` or clone inside\n   * this method, this method will directly modify the `baseDocument` passed in.\n   *\n   * @param baseDocument Initial input document. Already validated via `validateBaseDocument`\n   * @returns Transformed base document\n   */\n  // We just don't need `this` here. This is basically a no-op function that is available to child\n  // classes to override\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this\n  protected transformBaseDocumentAfterValidation(baseDocument: JsonDocumentLike): JsonDocumentLike {\n    return baseDocument;\n  }\n\n  /**\n   * Transform the contributed document associated with `documentName`. This transformation occurs\n   * after validating the contributed document and before combining with other documents.\n   *\n   * WARNING: If you do not create the combiner with option `copyDocuments: true` or clone inside\n   * this method, this method will directly modify the contributed `document` passed in.\n   *\n   * @param documentName Name of the contributed document to combine\n   * @param document Content of the contributed document to combine. Already validated via\n   *   `validateContribution`\n   * @returns Transformed contributed document\n   */\n  // We just don't need `this` here. This is basically a no-op function that is available to child\n  // classes to override\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this\n  protected transformContributionAfterValidation(\n    // @ts-expect-error this parameter is unused but may be used in child classes\n    documentName: string,\n    document: JsonDocumentLike,\n  ): JsonDocumentLike {\n    return document;\n  }\n\n  /**\n   * Throw an error if the provided document is not a valid starting document.\n   *\n   * @param baseDocument Base JSON document/JS object that all other documents are added to\n   */\n  // no-op intended to be overridden by child classes. Can't be static\n  // @ts-expect-error ts(6133) parameter doesn't need to be used but still needs the right name\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this, @typescript-eslint/no-unused-vars\n  protected validateBaseDocument(baseDocument: JsonDocumentLike): void {}\n\n  /**\n   * Throw an error if the provided document is not a valid contribution document.\n   *\n   * @param documentName Name of the contributed document to combine\n   * @param document Content of the contributed document to combine\n   */\n  // no-op intended to be overridden by child classes. Can't be static\n  // @ts-expect-error ts(6133) parameter doesn't need to be used but still needs the right name\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this, @typescript-eslint/no-unused-vars\n  protected validateContribution(documentName: string, document: JsonDocumentLike): void {}\n\n  /**\n   * Throw an error if the provided output is not valid.\n   *\n   * @param output Output document that could potentially be returned to callers\n   */\n  // no-op intended to be overridden by child classes. Can't be static\n  // @ts-expect-error ts(6133) parameter doesn't need to be used but still needs the right name\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this, @typescript-eslint/no-unused-vars\n  protected validateOutput(output: JsonDocumentLike): void {}\n\n  /**\n   * Transform the document that is the composition of the base document and all contribution\n   * documents. This is the last step that will be run prior to validation via `validateOutput`\n   * before `this.latestOutput` is updated to the new output.\n   *\n   * @param finalOutput Final output document that could potentially be returned to callers. \"Final\"\n   *   means no further contribution documents will be merged.\n   */\n  // no-op intended to be overridden by child classes. Can't be static\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this\n  protected transformFinalOutputBeforeValidation(finalOutput: JsonDocumentLike): JsonDocumentLike {\n    return finalOutput;\n  }\n}\n\n// #region Helper functions\n\n/**\n * Determines if the input values are objects but not arrays\n *\n * @param values Objects to check\n * @returns True if all the values are objects but not arrays\n */\nfunction areNonArrayObjects(...values: unknown[]): boolean {\n  let allMatch = true;\n  values.forEach((value: unknown) => {\n    if (!value || typeof value !== 'object' || Array.isArray(value)) allMatch = false;\n  });\n  return allMatch;\n}\n\n/**\n * Determines if the input values are arrays\n *\n * @param value Objects to check\n * @returns True if the values are arrays\n */\nfunction areArrayObjects(...values: unknown[]): boolean {\n  let allMatch = true;\n  values.forEach((value: unknown) => {\n    if (!value || typeof value !== 'object' || !Array.isArray(value)) allMatch = false;\n  });\n  return allMatch;\n}\n\n/**\n * Deep clone and recursively merge the properties of one object (copyFrom) into another\n * (startingPoint). Throws if copyFrom would overwrite values already existing in startingPoint.\n *\n * Does not modify the objects passed in.\n *\n * @param startingPoint Object that is the starting point for the return value\n * @param copyFrom Object whose values are copied into the return value\n * @param ignoreDuplicateProperties Whether to ignore object properties that are present in\n *   `copyFrom` that are already present in `startingPoint`. If `false`, throws when an object\n *   property in `copyFrom` is already present in `startingPoint`\n * @returns Object that is the combination of the two documents\n */\nfunction mergeObjects(\n  startingPoint: JsonDocumentLike,\n  copyFrom: JsonDocumentLike,\n  ignoreDuplicateProperties: boolean,\n): JsonDocumentLike {\n  const retVal = deepClone(startingPoint);\n\n  if (!copyFrom) return retVal;\n\n  return mergeObjectsInternal(retVal, deepClone(copyFrom), ignoreDuplicateProperties);\n}\n\n/**\n * Recursively merge the properties of one object (copyFrom) into another (startingPoint). Throws if\n * copyFrom would overwrite values already existing in startingPoint.\n *\n * WARNING: Modifies the argument objects in some way. Recommended to use `mergeObjects`\n *\n * @param startingPoint Object that is the starting point for the return value\n * @param copyFrom Object whose values are copied into the return value\n * @param ignoreDuplicateProperties Whether to ignore object properties that are present in\n *   `copyFrom` that are already present in `startingPoint`. If `false`, throws when an object\n *   property in `copyFrom` is already present in `startingPoint`\n * @returns Object that is the combination of the two documents\n */\nfunction mergeObjectsInternal(\n  startingPoint: JsonDocumentLike,\n  copyFrom: JsonDocumentLike,\n  ignoreDuplicateProperties: boolean,\n): JsonDocumentLike {\n  if (!copyFrom) return startingPoint;\n\n  if (areNonArrayObjects(startingPoint, copyFrom)) {\n    // Merge properties since they are both objects\n\n    // We know these are objects from the `if` check\n    /* eslint-disable no-type-assertion/no-type-assertion */\n    const startingPointObj = startingPoint as JsonObjectLike;\n    const copyFromObj = copyFrom as JsonObjectLike;\n    /* eslint-enable no-type-assertion/no-type-assertion */\n    Object.keys(copyFromObj).forEach((key: string | number) => {\n      if (Object.hasOwn(startingPointObj, key)) {\n        if (areNonArrayObjects(startingPointObj[key], copyFromObj[key])) {\n          startingPointObj[key] = mergeObjectsInternal(\n            // We know these are objects from the `if` check\n            /* eslint-disable no-type-assertion/no-type-assertion */\n            startingPointObj[key] as JsonObjectLike,\n            copyFromObj[key] as JsonObjectLike,\n            ignoreDuplicateProperties,\n            /* eslint-enable no-type-assertion/no-type-assertion */\n          );\n        } else if (areArrayObjects(startingPointObj[key], copyFromObj[key])) {\n          // Concat the arrays since they are both arrays\n\n          // We know these are arrays from the `else if` check\n          /* eslint-disable no-type-assertion/no-type-assertion */\n          startingPointObj[key] = (startingPointObj[key] as JsonArrayLike).concat(\n            copyFromObj[key] as JsonArrayLike,\n          );\n          /* eslint-enable no-type-assertion/no-type-assertion */\n        } else if (!ignoreDuplicateProperties)\n          throw new Error(`Cannot merge objects: key \"${key}\" already exists in the target object`);\n        // Note that the first non-object non-array value that gets placed in a property stays.\n        // New values do not override existing ones\n      } else {\n        startingPointObj[key] = copyFromObj[key];\n      }\n    });\n  } else if (areArrayObjects(startingPoint, copyFrom)) {\n    // Concat the arrays since they are both arrays\n\n    // Push the contents of copyFrom into startingPoint since it is a const and was already deep cloned\n    // We know these are objects from the `else if` check\n    /* eslint-disable no-type-assertion/no-type-assertion */\n    (startingPoint as JsonArrayLike).push(...(copyFrom as JsonArrayLike));\n    /* eslint-enable no-type-assertion/no-type-assertion */\n  }\n\n  // Note that nothing happens if `startingPoint` is not an object or an array or if `startingPoint`\n  // and `copyFrom` are not both object or both arrays. Should we throw? Should we push `copyFrom`'s\n  // values into the array? Other? Maybe one day we can add some options to decide what to do in\n  // this situation, but YAGNI for now\n\n  return startingPoint;\n}\n\n// #endregion\n\nexport default DocumentCombiner;\n","/** Class that tracks how long it has taken the last N events to occur */\nexport class EventRollingTimeCounter {\n  /** The ring buffer to store times */\n  private readonly ringBuffer: number[];\n  /** The size of the ring buffer */\n  private readonly bufferSize: number;\n  /** The next location where a time will be written */\n  private writerIndex: number;\n  /** The location where the first time in the buffer will be read */\n  private readerIndex: number;\n  /** The most recent difference in time between the newest and oldest events */\n  private lastTimeDifference: number;\n  /** How many instances in total have been recorded */\n  private totalInstanceCount: number;\n\n  /**\n   * Create a new instance of the InstanceTimeCounter class\n   *\n   * @param bufferSize - Maximum number of instances to track\n   */\n  constructor(bufferSize: number) {\n    this.bufferSize = bufferSize;\n    this.ringBuffer = new Array(bufferSize).fill(0);\n    this.writerIndex = 0;\n    this.readerIndex = 0;\n    this.lastTimeDifference = 0;\n    this.totalInstanceCount = 0;\n  }\n\n  /** Get the total number of instances that have been recorded */\n  get totalInstances(): number {\n    return this.totalInstanceCount;\n  }\n\n  /** Add a new time measurement for an instance of an event */\n  recordInstance(): void {\n    this.totalInstanceCount += 1;\n    const currentTime = performance.now();\n    this.lastTimeDifference = currentTime - this.ringBuffer[this.readerIndex];\n\n    this.ringBuffer[this.writerIndex] = currentTime;\n    this.writerIndex += 1;\n    if (this.writerIndex >= this.bufferSize) this.writerIndex %= this.bufferSize;\n    if (this.writerIndex === this.readerIndex) {\n      this.readerIndex += 1;\n      if (this.readerIndex >= this.bufferSize) this.readerIndex %= this.bufferSize;\n    }\n  }\n\n  /**\n   * Check if the time between the last N events is less than the provided threshold\n   *\n   * @param minRollingTimeMs - Minimum time that must have passed when the last N events occurred\n   * @returns - True if the threshold is violated, false otherwise\n   */\n  hasViolatedThreshold(minRollingTimeMs: number): boolean {\n    return this.totalInstanceCount >= this.bufferSize && this.lastTimeDifference < minRollingTimeMs;\n  }\n}\n","import { Mutex as AsyncMutex } from 'async-mutex';\n\n// Extending Mutex from async-mutex so we can add JSDoc\n\n/**\n * Class that allows calling asynchronous functions multiple times at once while only running one at\n * a time.\n *\n * @example\n *\n * ```typescript\n * const mutex = new Mutex();\n *\n * mutex.runExclusive(async () => {\n *   // Do some asynchronous stuff\n *   console.log('These run one-at-a-time');\n * });\n *\n * mutex.runExclusive(async () => {\n *   // Do some asynchronous stuff\n *   console.log('These run one-at-a-time');\n * });\n * ```\n *\n * See [`async-mutex`](https://www.npmjs.com/package/async-mutex) for more information.\n */\nexport class Mutex extends AsyncMutex {}\n\nexport default Mutex;\n","import { Mutex } from './mutex';\n\n/** Map of {@link Mutex}es that automatically (lazily) generates a new {@link Mutex} for any new key */\nexport class MutexMap {\n  private mutexesByID = new Map<string, Mutex>();\n\n  /**\n   * Retrieves the {@link Mutex} associated with the given ID. If no Mutex exists for the provided\n   * ID, a new Mutex is created, stored, and returned.\n   *\n   * @param mutexID Unique identifier for the desired Mutex\n   * @returns The Mutex associated with the provided ID\n   */\n  get(mutexID: string): Mutex {\n    let retVal = this.mutexesByID.get(mutexID);\n    if (retVal) return retVal;\n\n    retVal = new Mutex();\n    this.mutexesByID.set(mutexID, retVal);\n    return retVal;\n  }\n}\n\nexport default MutexMap;\n","import { DocumentCombiner, DocumentCombinerOptions, JsonDocumentLike } from './document-combiner';\n\nexport class NonValidatingDocumentCombiner extends DocumentCombiner {\n  // Making the protected base constructor public\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(baseDocument: JsonDocumentLike, options: DocumentCombinerOptions) {\n    super(baseDocument, options);\n  }\n\n  get output(): JsonDocumentLike | undefined {\n    return this.latestOutput;\n  }\n}\n\nexport default NonValidatingDocumentCombiner;\n","/** Enables language-sensitive number formatting. Wraps Intl.NumberFormat */\nexport class NumberFormat {\n  private numberFormatter: Intl.NumberFormat;\n\n  constructor(locales?: string | string[], options?: Intl.NumberFormatOptions) {\n    this.numberFormatter = new Intl.NumberFormat(locales, options);\n  }\n\n  /**\n   * Formats a number according to the locale and formatting options of this NumberFormat object\n   *\n   * @param value Number or BigInt to format\n   * @returns String representing the given number formatted according to the locale and formatting\n   *   options of this NumberFormat object\n   */\n  format(value: number | bigint): string {\n    return this.numberFormatter.format(value);\n  }\n\n  /**\n   * Formats a range of numbers according to the locale and formatting options of this NumberFormat\n   * object\n   *\n   * @param startRange Number or bigint representing the start of the range\n   * @param endRange Number or bigint representing the end of the range\n   * @returns String representing the given range of numbers formatted according to the locale and\n   *   formatting options of this NumberFormat object\n   */\n  formatRange(startRange: number | bigint, endRange: number | bigint): string {\n    return this.numberFormatter.formatRange(startRange, endRange);\n  }\n\n  /**\n   * Returns an array of objects containing the locale-specific tokens from which it is possible to\n   * build custom strings while preserving the locale-specific parts.\n   *\n   * @param startRange Number or bigint representing start of the range\n   * @param endRange Number or bigint representing end of the range\n   * @returns Array of NumberRangeFormatPart objects containing the formatted range of numbers in\n   *   parts\n   */\n  formatRangeToParts(\n    startRange: number | bigint,\n    endRange: number | bigint,\n  ): Intl.NumberRangeFormatPart[] {\n    return this.numberFormatter.formatRangeToParts(startRange, endRange);\n  }\n\n  /**\n   * Allows locale-aware formatting of strings produced by this NumberFormat object\n   *\n   * @param value Number or bigint to format\n   * @returns Array of NumberFormatPart objects containing the formatted number in parts\n   */\n  formatToParts(value: number | bigint): Intl.NumberFormatPart[] {\n    return this.numberFormatter.formatToParts(value);\n  }\n\n  /**\n   * Returns a new object with properties reflecting the locale and number formatting options\n   * computed during initialization of this NumberFormat object\n   *\n   * @returns ResolvedNumberFormatOptions object\n   */\n  resolvedOptions(): Intl.ResolvedNumberFormatOptions {\n    return this.numberFormatter.resolvedOptions();\n  }\n}\n\nexport default NumberFormat;\n","const defaultPromise = Promise.resolve();\n\n/**\n * Class that allows you to chain promises for a given key. This is useful when:\n *\n * 1. You need to run promises from synchronous code and don't need to look at the results.\n * 2. The promises to run, or at least precisely when to run them, are not known in advance.\n * 3. The promises need to be run sequentially, waiting for the previous one to finish.\n *\n * An example of when this can be helpful is inside of React components. Component code is mostly\n * synchronous, but you may need to run some asynchronous code. You can't use `await` inside of\n * React component code in many situations, so you can use this class to chain promises together.\n *\n * When promises are added to the map with a key, they will run in the order they were added to the\n * map for that key. If a promise rejects, a warning will be logged and the chain will continue. If\n * a promise is added while another promise in the map for that key is running, the new promise will\n * be chained to the existing one.\n */\nexport class PromiseChainingMap<TKey = string> {\n  private readonly map = new Map<TKey, Promise<unknown>>();\n  private readonly logger: { warn: (message: string) => void };\n\n  /**\n   * Creates a new PromiseChainingMap\n   *\n   * @param logger Object with a `warn` method that will be called when a promise rejects. This\n   *   defaults to `console`.\n   */\n  constructor(logger: { warn: (message: string) => void } = console) {\n    this.logger = logger;\n  }\n\n  /**\n   * Adds a promise function to the map for a given key. If a promise is already running for the\n   * key, the new promise will be chained to the existing one. Once all promises for a key have\n   * settled, the map will be cleared for that key.\n   *\n   * @param key Unique key to identify a distinct promise chain\n   * @param promiseFunction Function that returns a promise to add to the chain\n   */\n  addPromiseFunction(key: TKey, promiseFunction: () => Promise<unknown>): void {\n    const currentPromise = this.map.get(key);\n    this.map.set(key, currentPromise ? currentPromise.then(promiseFunction) : promiseFunction());\n    this.cleanupPromiseChain(key);\n  }\n\n  /**\n   * Gets the current promise chain for the given key. This is mostly useful for testing. Normally\n   * you should just call {@link addPromiseFunction} and let the map handle the rest.\n   *\n   * @param key Unique key to identify a distinct promise chain\n   * @returns The current promise chain for the key\n   */\n  get(key: TKey): Promise<unknown> | undefined {\n    return this.map.get(key);\n  }\n\n  /**\n   * Configures a promise chain to be removed from the map for the given key after all the promises\n   * have settled\n   *\n   * @param key Unique key to identify a distinct promise chain\n   */\n  private cleanupPromiseChain(key: TKey): void {\n    const currentPromise = this.map.get(key);\n    if (!currentPromise) return;\n\n    const promiseHolder: { promise: Promise<unknown> } = { promise: defaultPromise };\n    const newPromise = currentPromise\n      .catch((e) => this.logger.warn(`Error in promise for ${key}: ${e.message}`))\n      .finally(() => {\n        if (this.map.get(key) === promiseHolder.promise) this.map.delete(key);\n      });\n    promiseHolder.promise = newPromise;\n    this.map.set(key, newPromise);\n  }\n}\n\nexport default PromiseChainingMap;\n","/**\n * A map-like data structure that maintains numeric keys in sorted order and provides efficient\n * operations for finding the closest key-value pair less than or equal to a target.\n *\n * This class combines the benefits of a Map (O(1) key-value lookups) with sorted key access (O(log\n * n) binary search operations). It's particularly useful when you need to frequently find the\n * \"closest\" entry to a given numeric key.\n *\n * @example\n *\n * ```typescript\n * const versionMap = new SortedNumberMap<string>();\n * versionMap.set(100, 'Version 1.0.0');\n * versionMap.set(150, 'Version 1.5.0');\n * versionMap.set(200, 'Version 2.0.0');\n *\n * // Find the highest version <= 175\n * const result = versionMap.findClosestLessThanOrEqual(175);\n * console.log(result); // { key: 150, value: 'Version 1.5.0' }\n * ```\n *\n * @template T The type of values stored in the map\n */\nexport class SortedNumberMap<T> {\n  private map = new Map<number, T>();\n  private sortedKeys: number[] = [];\n\n  /**\n   * Returns an iterable of keys in the map sorted in ascending order.\n   *\n   * Time complexity: internal detail to JavaScript engine. Reasonable expectation:\n   *\n   * - Executing this method to return an iterator: O(1)\n   * - Iterating over the returned iterator: O(n)\n   *\n   * Note that iterating over the keys this way negates the benefits of using this class over a\n   * using a {@link Map}. To access individual keys more quickly, use\n   * {@link SortedNumberMap.findClosestLessThanOrEqual} or {@link SortedNumberMap.get}.\n   *\n   * TSDoc adapted from {@link Map.keys}\n   */\n  keys() {\n    return this.sortedKeys.values();\n  }\n\n  /**\n   * Returns a specified element from the Map object. If the value that is associated to the\n   * provided key is an object, then you will get a reference to that object and any change made to\n   * that object will effectively modify it inside the Map.\n   *\n   * Time complexity: O(1)\n   *\n   * @returns Returns the element associated with the specified key. If no element is associated\n   *   with the specified key, returns `undefined`.\n   *\n   *   TSDoc adapted from {@link Map.get}\n   */\n  get(key: number) {\n    return this.map.get(key);\n  }\n\n  /**\n   * Sets a key-value pair in the map. If the key already exists, its value is updated. If the key\n   * is new, it's inserted in the correct sorted position.\n   *\n   * Time complexity: O(log n) for new keys (due to binary search and array insertion), O(1) for\n   * existing keys.\n   *\n   * @example\n   *\n   * ```typescript\n   * const map = new SortedNumberMap<string>();\n   * map.set(10, 'ten');\n   * map.set(5, 'five');\n   * map.set(15, 'fifteen');\n   * // Keys are automatically maintained in sorted order: [5, 10, 15]\n   * ```\n   *\n   * @param key - The numeric key to set\n   * @param value - The value to associate with the key\n   */\n  set(key: number, value: T): void {\n    if (!this.map.has(key)) {\n      // Insert key in sorted position\n      const insertIndex = this.binarySearchInsertIndex(key);\n      this.sortedKeys.splice(insertIndex, 0, key);\n    }\n    this.map.set(key, value);\n  }\n\n  /**\n   * Finds the key-value pair with the largest key that is less than or equal to the target.\n   *\n   * This method uses binary search to efficiently locate the closest match. If no key is less than\n   * or equal to the target, it returns undefined.\n   *\n   * Time complexity: O(log n)\n   *\n   * @example\n   *\n   * ```typescript\n   * const map = new SortedNumberMap<string>();\n   * map.set(10, 'ten');\n   * map.set(20, 'twenty');\n   * map.set(30, 'thirty');\n   *\n   * // Exact match\n   * map.findClosestLessThanOrEqual(20); // { key: 20, value: 'twenty' }\n   *\n   * // Closest less than\n   * map.findClosestLessThanOrEqual(25); // { key: 20, value: 'twenty' }\n   *\n   * // No match (target too small)\n   * map.findClosestLessThanOrEqual(5); // undefined\n   * ```\n   *\n   * @param target - The number to search for\n   * @returns The key-value pair with the largest key ≤ target, or undefined if none exists\n   */\n  findClosestLessThanOrEqual(target: number): { key: number; value: T } | undefined {\n    const index = this.binarySearchLessThanOrEqual(target);\n    if (index === -1) return undefined;\n\n    const key = this.sortedKeys[index];\n    const value = this.map.get(key);\n    if (value === undefined) return undefined;\n    return { key, value };\n  }\n\n  private binarySearchLessThanOrEqual(target: number): number {\n    let left = 0;\n    let right = this.sortedKeys.length - 1;\n    let result = -1;\n\n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.sortedKeys[mid] <= target) {\n        result = mid;\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return result;\n  }\n\n  private binarySearchInsertIndex(target: number): number {\n    let left = 0;\n    let right = this.sortedKeys.length;\n\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.sortedKeys[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n    return left;\n  }\n}\n","/**\n * A collection of unique items that are automatically maintained in sorted order, similar to C#'s\n * SortedSet.\n *\n * @template T The type of elements in the set\n */\nexport class SortedSet<T> {\n  /** Internal storage for the sorted items */\n  private readonly items: T[] = [];\n\n  /**\n   * Creates a new sorted set\n   *\n   * @param compareFn - Function used to determine the order of elements. Returns negative when a <\n   *   b, zero when a = b, positive when a > b\n   */\n  constructor(private readonly compareFn: (a: T, b: T) => number) {}\n\n  /** Gets the number of elements in the set */\n  get size(): number {\n    return this.items.length;\n  }\n\n  /** Returns whether the set is empty */\n  get isEmpty(): boolean {\n    return this.items.length === 0;\n  }\n\n  /**\n   * Inserts an item into the set if it's not already present\n   *\n   * @param item - The item to insert\n   * @returns True if the item was added; false if an equal item already exists\n   */\n  insert(item: T): boolean {\n    // Find where this item should be inserted\n    const index = this.findInsertionIndex(item);\n\n    // Check if an equal item exists at the found position\n    if (index < this.items.length && this.compareFn(this.items[index], item) === 0) {\n      // Item already exists\n      return false;\n    }\n\n    // Insert the item at the correct position to maintain sort order\n    this.items.splice(index, 0, item);\n    return true;\n  }\n\n  /**\n   * Removes an item from the set\n   *\n   * @param item - The item to remove\n   * @returns True if the item was removed; false if it wasn't found\n   */\n  remove(item: T): boolean {\n    const index = this.findIndex(item);\n    if (index < 0) return false;\n\n    this.items.splice(index, 1);\n    return true;\n  }\n\n  /**\n   * Checks if an item exists in the set\n   *\n   * @param item - The item to check\n   * @returns True if the item exists; false otherwise\n   */\n  has(item: T): boolean {\n    return this.findIndex(item) >= 0;\n  }\n\n  /** Returns all items in the set as an array, in sorted order */\n  toArray(): T[] {\n    return [...this.items];\n  }\n\n  /** Returns the index of an item in the set, or -1 if not found */\n  findIndex(item: T): number {\n    const index = this.findInsertionIndex(item);\n    if (index < this.items.length && this.compareFn(this.items[index], item) === 0) return index;\n    return -1;\n  }\n\n  /**\n   * Returns the element at the specified index in the sorted order\n   *\n   * @param index - The zero-based index of the element to get\n   * @returns The element at the specified index, or undefined if the index is out of range\n   */\n  at(index: number): T | undefined {\n    if (index < 0 || index >= this.items.length) return undefined;\n    return this.items[index];\n  }\n\n  /** Iterates through each item in the sorted set */\n  forEach(callback: (item: T, index: number, set: SortedSet<T>) => void): void {\n    this.items.forEach((item, index) => callback(item, index, this));\n  }\n\n  /** Returns an iterator for the set's items */\n  [Symbol.iterator](): Iterator<T> {\n    let index = 0;\n    return {\n      next: (): IteratorResult<T> => {\n        if (index < this.items.length) {\n          index += 1;\n          return { value: this.items[index - 1], done: false };\n        }\n        return { value: undefined as unknown, done: true };\n      },\n    };\n  }\n\n  /** Clears all items from the set */\n  clear(): void {\n    this.items.length = 0;\n  }\n\n  /**\n   * Uses binary search to find the position where an item should be inserted to maintain the sorted\n   * order\n   */\n  private findInsertionIndex(item: T): number {\n    let low = 0;\n    let high = this.items.length;\n\n    while (low < high) {\n      const mid = Math.floor((low + high) / 2);\n      const comparison = this.compareFn(this.items[mid], item);\n\n      if (comparison < 0) {\n        // Current item is less than the one we're looking for\n        low = mid + 1;\n      } else {\n        // Current item is greater than or equal to the one we're looking for\n        high = mid;\n      }\n    }\n\n    return low;\n  }\n}\n","import { Dispose } from './disposal.model';\nimport { Unsubscriber, UnsubscriberAsync } from './unsubscriber';\n\n/** Simple collection for UnsubscriberAsync objects that also provides an easy way to run them. */\nexport class UnsubscriberAsyncList {\n  readonly unsubscribers = new Set<UnsubscriberAsync | Unsubscriber>();\n\n  constructor(private name = 'Anonymous') {}\n\n  /**\n   * Add unsubscribers to the list. Note that duplicates are not added twice.\n   *\n   * @param unsubscribers - Objects that were returned from a registration process.\n   */\n  add(...unsubscribers: (UnsubscriberAsync | Unsubscriber | Dispose)[]) {\n    unsubscribers.forEach((unsubscriber) => {\n      if ('dispose' in unsubscriber)\n        this.unsubscribers.add(unsubscriber.dispose.bind(unsubscriber));\n      else this.unsubscribers.add(unsubscriber);\n    });\n  }\n\n  /**\n   * Run all unsubscribers added to this list and then clear the list.\n   *\n   * @returns `true` if all unsubscribers succeeded, `false` otherwise.\n   */\n  async runAllUnsubscribers(): Promise<boolean> {\n    const unsubs = [...this.unsubscribers].map((unsubscriber) => unsubscriber());\n    const results = await Promise.all(unsubs);\n    this.unsubscribers.clear();\n    return results.every((unsubscriberSucceeded, index) => {\n      if (!unsubscriberSucceeded)\n        console.error(`UnsubscriberAsyncList ${this.name}: Unsubscriber at index ${index} failed!`);\n\n      return unsubscriberSucceeded;\n    });\n  }\n}\n\nexport default UnsubscriberAsyncList;\n","import { isString } from './util';\n\n/** The version of the PlatformError type */\nexport const PLATFORM_ERROR_VERSION = 1;\n\n/**\n * PlatformError is an error type with stronger typing of properties than `Error`. It is used to\n * represent errors that are returned by the platform.\n *\n * You can create a new PlatformError object using {@link newPlatformError}. You can check if a value\n * is a PlatformError object using {@link isPlatformError}.\n */\nexport type PlatformError = {\n  /**\n   * The underlying cause of the error, if any. Normally this will be copied from an `Error object\n   * passed to {@link newPlatformError}. If a non-Error object is passed to {@link newPlatformError},\n   * it will be stored here.\n   */\n  cause?: unknown;\n  /**\n   * A descriptive message explaining the error. Normally this will be copied from an `Error` object\n   * passed to {@link newPlatformError}. If a string is passed to {@link newPlatformError}, it will be\n   * stored here.\n   */\n  message: string;\n  /** The version of the PlatformError type. */\n  platformErrorVersion: number;\n  /**\n   * The stack trace of the error, if available. Normally this will be copied from an `Error` object\n   * passed to {@link newPlatformError}.\n   */\n  stack?: string;\n};\n\n/**\n * Creates a new PlatformError object. If no argument is provided, a PlatformError object with an\n * empty `message` is returned.\n *\n * @param error The error message as a string, an Error object, or a value to assign to the `cause`\n *   property of the returned PlatformError object\n * @returns A new PlatformError object\n */\nexport function newPlatformError(error?: unknown): PlatformError {\n  if (!error) return { message: '', platformErrorVersion: PLATFORM_ERROR_VERSION };\n  if (isString(error)) return { message: error, platformErrorVersion: PLATFORM_ERROR_VERSION };\n  if (typeof error === 'object' && 'message' in error && typeof error.message === 'string') {\n    const platformError: PlatformError = {\n      message: error.message,\n      platformErrorVersion: PLATFORM_ERROR_VERSION,\n    };\n    Object.defineProperties(platformError, Object.getOwnPropertyDescriptors(error));\n    Object.defineProperty(platformError, 'message', { enumerable: true });\n    if ('stack' in error && isString(error.stack)) {\n      // stack is generated lazily, and it seems this is causing some troubles with copying it into\n      // another object via property descriptors as of Node 22.14.0 (no problems in 20.18.0).\n      // So we shall set the value directly on the object\n      Object.defineProperty(platformError, 'stack', { value: error.stack, enumerable: true });\n    }\n    if ('cause' in platformError)\n      Object.defineProperty(platformError, 'cause', { enumerable: true });\n    return platformError;\n  }\n  return { cause: error, message: '', platformErrorVersion: PLATFORM_ERROR_VERSION };\n}\n\n/**\n * Checks if the provided value is a PlatformError object.\n *\n * @param error The value to check\n * @returns `true` if the value is a PlatformError object, otherwise `false`\n */\nexport function isPlatformError(error: unknown): error is PlatformError {\n  return !!error && typeof error === 'object' && 'platformErrorVersion' in error;\n}\n","var P = Object.defineProperty;\nvar R = (t, e, s) => e in t ? P(t, e, { enumerable: !0, configurable: !0, writable: !0, value: s }) : t[e] = s;\nvar n = (t, e, s) => R(t, typeof e != \"symbol\" ? e + \"\" : e, s);\nclass _ {\n  constructor() {\n    n(this, \"books\");\n    n(this, \"firstSelectedBookNum\");\n    n(this, \"lastSelectedBookNum\");\n    n(this, \"count\");\n    n(this, \"selectedBookNumbers\");\n    n(this, \"selectedBookIds\");\n  }\n}\nconst N = [\n  \"GEN\",\n  \"EXO\",\n  \"LEV\",\n  \"NUM\",\n  \"DEU\",\n  \"JOS\",\n  \"JDG\",\n  \"RUT\",\n  \"1SA\",\n  \"2SA\",\n  // 10\n  \"1KI\",\n  \"2KI\",\n  \"1CH\",\n  \"2CH\",\n  \"EZR\",\n  \"NEH\",\n  \"EST\",\n  \"JOB\",\n  \"PSA\",\n  \"PRO\",\n  // 20\n  \"ECC\",\n  \"SNG\",\n  \"ISA\",\n  \"JER\",\n  \"LAM\",\n  \"EZK\",\n  \"DAN\",\n  \"HOS\",\n  \"JOL\",\n  \"AMO\",\n  // 30\n  \"OBA\",\n  \"JON\",\n  \"MIC\",\n  \"NAM\",\n  \"HAB\",\n  \"ZEP\",\n  \"HAG\",\n  \"ZEC\",\n  \"MAL\",\n  \"MAT\",\n  // 40\n  \"MRK\",\n  \"LUK\",\n  \"JHN\",\n  \"ACT\",\n  \"ROM\",\n  \"1CO\",\n  \"2CO\",\n  \"GAL\",\n  \"EPH\",\n  \"PHP\",\n  // 50\n  \"COL\",\n  \"1TH\",\n  \"2TH\",\n  \"1TI\",\n  \"2TI\",\n  \"TIT\",\n  \"PHM\",\n  \"HEB\",\n  \"JAS\",\n  \"1PE\",\n  // 60\n  \"2PE\",\n  \"1JN\",\n  \"2JN\",\n  \"3JN\",\n  \"JUD\",\n  \"REV\",\n  \"TOB\",\n  \"JDT\",\n  \"ESG\",\n  \"WIS\",\n  // 70\n  \"SIR\",\n  \"BAR\",\n  \"LJE\",\n  \"S3Y\",\n  \"SUS\",\n  \"BEL\",\n  \"1MA\",\n  \"2MA\",\n  \"3MA\",\n  \"4MA\",\n  // 80\n  \"1ES\",\n  \"2ES\",\n  \"MAN\",\n  \"PS2\",\n  \"ODA\",\n  \"PSS\",\n  \"JSA\",\n  // actual variant text for JOS, now in LXA text\n  \"JDB\",\n  // actual variant text for JDG, now in LXA text\n  \"TBS\",\n  // actual variant text for TOB, now in LXA text\n  \"SST\",\n  // actual variant text for SUS, now in LXA text // 90\n  \"DNT\",\n  // actual variant text for DAN, now in LXA text\n  \"BLT\",\n  // actual variant text for BEL, now in LXA text\n  \"XXA\",\n  \"XXB\",\n  \"XXC\",\n  \"XXD\",\n  \"XXE\",\n  \"XXF\",\n  \"XXG\",\n  \"FRT\",\n  // 100\n  \"BAK\",\n  \"OTH\",\n  \"3ES\",\n  // Used previously but really should be 2ES\n  \"EZA\",\n  // Used to be called 4ES, but not actually in any known project\n  \"5EZ\",\n  // Used to be called 5ES, but not actually in any known project\n  \"6EZ\",\n  // Used to be called 6ES, but not actually in any known project\n  \"INT\",\n  \"CNC\",\n  \"GLO\",\n  \"TDX\",\n  // 110\n  \"NDX\",\n  \"DAG\",\n  \"PS3\",\n  \"2BA\",\n  \"LBA\",\n  \"JUB\",\n  \"ENO\",\n  \"1MQ\",\n  \"2MQ\",\n  \"3MQ\",\n  // 120\n  \"REP\",\n  \"4BA\",\n  \"LAO\"\n], B = [\n  \"XXA\",\n  \"XXB\",\n  \"XXC\",\n  \"XXD\",\n  \"XXE\",\n  \"XXF\",\n  \"XXG\",\n  \"FRT\",\n  \"BAK\",\n  \"OTH\",\n  \"INT\",\n  \"CNC\",\n  \"GLO\",\n  \"TDX\",\n  \"NDX\"\n], O = [\n  \"Genesis\",\n  \"Exodus\",\n  \"Leviticus\",\n  \"Numbers\",\n  \"Deuteronomy\",\n  \"Joshua\",\n  \"Judges\",\n  \"Ruth\",\n  \"1 Samuel\",\n  \"2 Samuel\",\n  \"1 Kings\",\n  \"2 Kings\",\n  \"1 Chronicles\",\n  \"2 Chronicles\",\n  \"Ezra\",\n  \"Nehemiah\",\n  \"Esther (Hebrew)\",\n  \"Job\",\n  \"Psalms\",\n  \"Proverbs\",\n  \"Ecclesiastes\",\n  \"Song of Songs\",\n  \"Isaiah\",\n  \"Jeremiah\",\n  \"Lamentations\",\n  \"Ezekiel\",\n  \"Daniel (Hebrew)\",\n  \"Hosea\",\n  \"Joel\",\n  \"Amos\",\n  \"Obadiah\",\n  \"Jonah\",\n  \"Micah\",\n  \"Nahum\",\n  \"Habakkuk\",\n  \"Zephaniah\",\n  \"Haggai\",\n  \"Zechariah\",\n  \"Malachi\",\n  \"Matthew\",\n  \"Mark\",\n  \"Luke\",\n  \"John\",\n  \"Acts\",\n  \"Romans\",\n  \"1 Corinthians\",\n  \"2 Corinthians\",\n  \"Galatians\",\n  \"Ephesians\",\n  \"Philippians\",\n  \"Colossians\",\n  \"1 Thessalonians\",\n  \"2 Thessalonians\",\n  \"1 Timothy\",\n  \"2 Timothy\",\n  \"Titus\",\n  \"Philemon\",\n  \"Hebrews\",\n  \"James\",\n  \"1 Peter\",\n  \"2 Peter\",\n  \"1 John\",\n  \"2 John\",\n  \"3 John\",\n  \"Jude\",\n  \"Revelation\",\n  \"Tobit\",\n  \"Judith\",\n  \"Esther Greek\",\n  \"Wisdom of Solomon\",\n  \"Sirach (Ecclesiasticus)\",\n  \"Baruch\",\n  \"Letter of Jeremiah\",\n  \"Song of 3 Young Men\",\n  \"Susanna\",\n  \"Bel and the Dragon\",\n  \"1 Maccabees\",\n  \"2 Maccabees\",\n  \"3 Maccabees\",\n  \"4 Maccabees\",\n  \"1 Esdras (Greek)\",\n  \"2 Esdras (Latin)\",\n  \"Prayer of Manasseh\",\n  \"Psalm 151\",\n  \"Odes\",\n  \"Psalms of Solomon\",\n  // WARNING, if you change the spelling of the *obsolete* tag be sure to update\n  // IsObsolete routine\n  \"Joshua A. *obsolete*\",\n  \"Judges B. *obsolete*\",\n  \"Tobit S. *obsolete*\",\n  \"Susanna Th. *obsolete*\",\n  \"Daniel Th. *obsolete*\",\n  \"Bel Th. *obsolete*\",\n  \"Extra A\",\n  \"Extra B\",\n  \"Extra C\",\n  \"Extra D\",\n  \"Extra E\",\n  \"Extra F\",\n  \"Extra G\",\n  \"Front Matter\",\n  \"Back Matter\",\n  \"Other Matter\",\n  \"3 Ezra *obsolete*\",\n  \"Apocalypse of Ezra\",\n  \"5 Ezra (Latin Prologue)\",\n  \"6 Ezra (Latin Epilogue)\",\n  \"Introduction\",\n  \"Concordance \",\n  \"Glossary \",\n  \"Topical Index\",\n  \"Names Index\",\n  \"Daniel Greek\",\n  \"Psalms 152-155\",\n  \"2 Baruch (Apocalypse)\",\n  \"Letter of Baruch\",\n  \"Jubilees\",\n  \"Enoch\",\n  \"1 Meqabyan\",\n  \"2 Meqabyan\",\n  \"3 Meqabyan\",\n  \"Reproof (Proverbs 25-31)\",\n  \"4 Baruch (Rest of Baruch)\",\n  \"Laodiceans\"\n], S = K();\nfunction g(t, e = !0) {\n  return e && (t = t.toUpperCase()), t in S ? S[t] : 0;\n}\nfunction k(t) {\n  return g(t) > 0;\n}\nfunction x(t) {\n  const e = typeof t == \"string\" ? g(t) : t;\n  return e >= 40 && e <= 66;\n}\nfunction T(t) {\n  return (typeof t == \"string\" ? g(t) : t) <= 39;\n}\nfunction X(t) {\n  return t <= 66;\n}\nfunction V(t) {\n  const e = typeof t == \"string\" ? g(t) : t;\n  return w(e) && !X(e);\n}\nfunction* L() {\n  for (let t = 1; t <= N.length; t++) yield t;\n}\nconst G = 1, A = N.length;\nfunction H() {\n  return [\"XXA\", \"XXB\", \"XXC\", \"XXD\", \"XXE\", \"XXF\", \"XXG\"];\n}\nfunction C(t, e = \"***\") {\n  const s = t - 1;\n  return s < 0 || s >= N.length ? e : N[s];\n}\nfunction I(t) {\n  return t <= 0 || t > A ? \"******\" : O[t - 1];\n}\nfunction y(t) {\n  return I(g(t));\n}\nfunction w(t) {\n  const e = typeof t == \"number\" ? C(t) : t;\n  return k(e) && !B.includes(e);\n}\nfunction q(t) {\n  const e = typeof t == \"number\" ? C(t) : t;\n  return k(e) && B.includes(e);\n}\nfunction U(t) {\n  return O[t - 1].includes(\"*obsolete*\");\n}\nfunction K() {\n  const t = {};\n  for (let e = 0; e < N.length; e++)\n    t[N[e]] = e + 1;\n  return t;\n}\nconst m = {\n  allBookIds: N,\n  nonCanonicalIds: B,\n  bookIdToNumber: g,\n  isBookIdValid: k,\n  isBookNT: x,\n  isBookOT: T,\n  isBookOTNT: X,\n  isBookDC: V,\n  allBookNumbers: L,\n  firstBook: G,\n  lastBook: A,\n  extraBooks: H,\n  bookNumberToId: C,\n  bookNumberToEnglishName: I,\n  bookIdToEnglishName: y,\n  isCanonical: w,\n  isExtraMaterial: q,\n  isObsolete: U\n};\nvar l = /* @__PURE__ */ ((t) => (t[t.Unknown = 0] = \"Unknown\", t[t.Original = 1] = \"Original\", t[t.Septuagint = 2] = \"Septuagint\", t[t.Vulgate = 3] = \"Vulgate\", t[t.English = 4] = \"English\", t[t.RussianProtestant = 5] = \"RussianProtestant\", t[t.RussianOrthodox = 6] = \"RussianOrthodox\", t))(l || {});\nconst h = class h {\n  // private versInfo: Versification;\n  constructor(e) {\n    n(this, \"name\");\n    n(this, \"fullPath\");\n    n(this, \"isPresent\");\n    n(this, \"hasVerseSegments\");\n    n(this, \"isCustomized\");\n    n(this, \"baseVersification\");\n    n(this, \"scriptureBooks\");\n    n(this, \"_type\");\n    if (e == null)\n      throw new Error(\"Argument undefined\");\n    typeof e == \"string\" ? (this.name = e, this._type = l[e]) : (this._type = e, this.name = l[e]);\n  }\n  get type() {\n    return this._type;\n  }\n  equals(e) {\n    return !e.type || !this.type ? !1 : e.type === this.type;\n  }\n};\nn(h, \"Original\", new h(l.Original)), n(h, \"Septuagint\", new h(l.Septuagint)), n(h, \"Vulgate\", new h(l.Vulgate)), n(h, \"English\", new h(l.English)), n(h, \"RussianProtestant\", new h(l.RussianProtestant)), n(h, \"RussianOrthodox\", new h(l.RussianOrthodox));\nlet c = h;\nfunction E(t, e) {\n  const s = e[0];\n  for (let r = 1; r < e.length; r++)\n    t = t.split(e[r]).join(s);\n  return t.split(s);\n}\nvar D = /* @__PURE__ */ ((t) => (t[t.Valid = 0] = \"Valid\", t[t.UnknownVersification = 1] = \"UnknownVersification\", t[t.OutOfRange = 2] = \"OutOfRange\", t[t.VerseOutOfOrder = 3] = \"VerseOutOfOrder\", t[t.VerseRepeated = 4] = \"VerseRepeated\", t))(D || {});\nconst i = class i {\n  constructor(e, s, r, a) {\n    /** Not yet implemented. */\n    n(this, \"firstChapter\");\n    /** Not yet implemented. */\n    n(this, \"lastChapter\");\n    /** Not yet implemented. */\n    n(this, \"lastVerse\");\n    /** Not yet implemented. */\n    n(this, \"hasSegmentsDefined\");\n    /** Not yet implemented. */\n    n(this, \"text\");\n    /** Not yet implemented. */\n    n(this, \"BBBCCCVVVS\");\n    /** Not yet implemented. */\n    n(this, \"longHashCode\");\n    /** The versification of the reference. */\n    n(this, \"versification\");\n    n(this, \"rtlMark\", \"‏\");\n    n(this, \"_bookNum\", 0);\n    n(this, \"_chapterNum\", 0);\n    n(this, \"_verseNum\", 0);\n    n(this, \"_verse\");\n    if (r == null && a == null)\n      if (e != null && typeof e == \"string\") {\n        const o = e, u = s != null && s instanceof c ? s : void 0;\n        this.setEmpty(u), this.parse(o);\n      } else if (e != null && typeof e == \"number\") {\n        const o = s != null && s instanceof c ? s : void 0;\n        this.setEmpty(o), this._verseNum = e % i.chapterDigitShifter, this._chapterNum = Math.floor(\n          e % i.bookDigitShifter / i.chapterDigitShifter\n        ), this._bookNum = Math.floor(e / i.bookDigitShifter);\n      } else if (s == null)\n        if (e != null && e instanceof i) {\n          const o = e;\n          this._bookNum = o.bookNum, this._chapterNum = o.chapterNum, this._verseNum = o.verseNum, this._verse = o.verse, this.versification = o.versification;\n        } else {\n          if (e == null) return;\n          const o = e instanceof c ? e : i.defaultVersification;\n          this.setEmpty(o);\n        }\n      else\n        throw new Error(\"VerseRef constructor not supported.\");\n    else if (e != null && s != null && r != null)\n      if (typeof e == \"string\" && typeof s == \"string\" && typeof r == \"string\")\n        this.setEmpty(a), this.updateInternal(e, s, r);\n      else if (typeof e == \"number\" && typeof s == \"number\" && typeof r == \"number\")\n        this._bookNum = e, this._chapterNum = s, this._verseNum = r, this.versification = a ?? i.defaultVersification;\n      else\n        throw new Error(\"VerseRef constructor not supported.\");\n    else\n      throw new Error(\"VerseRef constructor not supported.\");\n  }\n  /**\n   * Determines if the verse string is in a valid format (does not consider versification).\n   */\n  static isVerseParseable(e) {\n    return e.length > 0 && \"0123456789\".includes(e[0]) && !e.endsWith(this.verseRangeSeparator) && !e.endsWith(this.verseSequenceIndicator);\n  }\n  /**\n   * Tries to parse the specified string into a verse reference.\n   * @param str - The string to attempt to parse.\n   * @returns success: `true` if the specified string was successfully parsed, `false` otherwise.\n   * @returns verseRef: The result of the parse if successful, or empty VerseRef if it failed\n   */\n  static tryParse(e) {\n    let s;\n    try {\n      return s = new i(e), { success: !0, verseRef: s };\n    } catch (r) {\n      if (r instanceof v)\n        return s = new i(), { success: !1, verseRef: s };\n      throw r;\n    }\n  }\n  /**\n   * Gets the reference as a comparable integer where the book, chapter, and verse each occupy 3\n   * digits.\n   * @param bookNum - Book number (this is 1-based, not an index).\n   * @param chapterNum - Chapter number.\n   * @param verseNum - Verse number.\n   * @returns The reference as a comparable integer where the book, chapter, and verse each occupy 3\n   * digits.\n   */\n  static getBBBCCCVVV(e, s, r) {\n    return e % i.bcvMaxValue * i.bookDigitShifter + (s >= 0 ? s % i.bcvMaxValue * i.chapterDigitShifter : 0) + (r >= 0 ? r % i.bcvMaxValue : 0);\n  }\n  /**\n   * Deserializes a serialized VerseRef.\n   * @param serializedVerseRef - Serialized VerseRef to create from.\n   * @returns the deserialized VerseRef.\n   */\n  static fromJSON(e) {\n    const { book: s, chapterNum: r, verseNum: a, verse: o, versificationStr: u } = e, f = o || a.toString();\n    let d;\n    return u && (d = new c(u)), s ? new i(s, r.toString(), f, d) : new i();\n  }\n  /**\n   * Parses a verse string and gets the leading numeric portion as a number.\n   * @param verseStr - verse string to parse\n   * @returns true if the entire string could be parsed as a single, simple verse number (1-999);\n   *    false if the verse string represented a verse bridge, contained segment letters, or was invalid\n   */\n  static tryGetVerseNum(e) {\n    let s;\n    if (!e)\n      return s = -1, { success: !0, vNum: s };\n    s = 0;\n    let r;\n    for (let a = 0; a < e.length; a++) {\n      if (r = e[a], r < \"0\" || r > \"9\")\n        return a === 0 && (s = -1), { success: !1, vNum: s };\n      if (s = s * 10 + +r - 0, s > i.bcvMaxValue)\n        return s = -1, { success: !1, vNum: s };\n    }\n    return { success: !0, vNum: s };\n  }\n  /**\n   * Checks to see if a VerseRef hasn't been set - all values are the default.\n   */\n  get isDefault() {\n    return this.bookNum === 0 && this.chapterNum === 0 && this.verseNum === 0 && this.versification == null;\n  }\n  /**\n   * Gets whether the verse contains multiple verses.\n   */\n  get hasMultiple() {\n    return this._verse != null && (this._verse.includes(i.verseRangeSeparator) || this._verse.includes(i.verseSequenceIndicator));\n  }\n  /**\n   * Gets or sets the book of the reference. Book is the 3-letter abbreviation in capital letters,\n   * e.g. `'MAT'`.\n   */\n  get book() {\n    return m.bookNumberToId(this.bookNum, \"\");\n  }\n  set book(e) {\n    this.bookNum = m.bookIdToNumber(e);\n  }\n  /**\n   * Gets or sets the chapter of the reference,. e.g. `'3'`.\n   */\n  get chapter() {\n    return this.isDefault || this._chapterNum < 0 ? \"\" : this._chapterNum.toString();\n  }\n  set chapter(e) {\n    const s = +e;\n    this._chapterNum = Number.isInteger(s) ? s : -1;\n  }\n  /**\n   * Gets or sets the verse of the reference, including range, segments, and sequences, e.g. `'4'`,\n   * or `'4b-5a, 7'`.\n   */\n  get verse() {\n    return this._verse != null ? this._verse : this.isDefault || this._verseNum < 0 ? \"\" : this._verseNum.toString();\n  }\n  set verse(e) {\n    const { success: s, vNum: r } = i.tryGetVerseNum(e);\n    this._verse = s ? void 0 : e.replace(this.rtlMark, \"\"), this._verseNum = r, !(this._verseNum >= 0) && ({ vNum: this._verseNum } = i.tryGetVerseNum(this._verse));\n  }\n  /**\n   * Get or set Book based on book number, e.g. `42`.\n   */\n  get bookNum() {\n    return this._bookNum;\n  }\n  set bookNum(e) {\n    if (e <= 0 || e > m.lastBook)\n      throw new v(\n        \"BookNum must be greater than zero and less than or equal to last book\"\n      );\n    this._bookNum = e;\n  }\n  /**\n   * Gets or sets the chapter number, e.g. `3`. `-1` if not valid.\n   */\n  get chapterNum() {\n    return this._chapterNum;\n  }\n  set chapterNum(e) {\n    this.chapterNum = e;\n  }\n  /**\n   * Gets or sets verse start number, e.g. `4`. `-1` if not valid.\n   */\n  get verseNum() {\n    return this._verseNum;\n  }\n  set verseNum(e) {\n    this._verseNum = e;\n  }\n  /**\n   * String representing the versification (should ONLY be used for serialization/deserialization).\n   *\n   * @remarks This is for backwards compatibility when ScrVers was an enumeration.\n   */\n  get versificationStr() {\n    var e;\n    return (e = this.versification) == null ? void 0 : e.name;\n  }\n  set versificationStr(e) {\n    this.versification = this.versification != null ? new c(e) : void 0;\n  }\n  /**\n   * Determines if the reference is valid.\n   */\n  get valid() {\n    return this.validStatus === 0;\n  }\n  /**\n   * Get the valid status for this reference.\n   */\n  get validStatus() {\n    return this.validateVerse(i.verseRangeSeparators, i.verseSequenceIndicators);\n  }\n  /**\n   * Gets the reference as a comparable integer where the book,\n   * chapter, and verse each occupy three digits and the verse is 0.\n   */\n  get BBBCCC() {\n    return i.getBBBCCCVVV(this._bookNum, this._chapterNum, 0);\n  }\n  /**\n   * Gets the reference as a comparable integer where the book,\n   * chapter, and verse each occupy three digits. If verse is not null\n   * (i.e., this reference represents a complex reference with verse\n   * segments or bridge) this cannot be used for an exact comparison.\n   */\n  get BBBCCCVVV() {\n    return i.getBBBCCCVVV(this._bookNum, this._chapterNum, this._verseNum);\n  }\n  /**\n   * Gets whether the verse is defined as an excluded verse in the versification.\n   * Does not handle verse ranges.\n   */\n  // eslint-disable-next-line @typescript-eslint/class-literal-property-style\n  get isExcluded() {\n    return !1;\n  }\n  /**\n   * Parses the reference in the specified string.\n   * Optionally versification can follow reference as in GEN 3:11/4\n   * Throw an exception if\n   * - invalid book name\n   * - chapter number is missing or not a number\n   * - verse number is missing or does not start with a number\n   * - versification is invalid\n   * @param verseStr - string to parse e.g. 'MAT 3:11'\n   */\n  parse(e) {\n    if (e = e.replace(this.rtlMark, \"\"), e.includes(\"/\")) {\n      const o = e.split(\"/\");\n      if (e = o[0], o.length > 1)\n        try {\n          const u = +o[1].trim();\n          this.versification = new c(l[u]);\n        } catch {\n          throw new v(\"Invalid reference : \" + e);\n        }\n    }\n    const s = e.trim().split(\" \");\n    if (s.length !== 2)\n      throw new v(\"Invalid reference : \" + e);\n    const r = s[1].split(\":\"), a = +r[0];\n    if (r.length !== 2 || m.bookIdToNumber(s[0]) === 0 || !Number.isInteger(a) || a < 0 || !i.isVerseParseable(r[1]))\n      throw new v(\"Invalid reference : \" + e);\n    this.updateInternal(s[0], r[0], r[1]);\n  }\n  /**\n   * Simplifies this verse ref so that it has no bridging of verses or\n   * verse segments like `'1a'`.\n   */\n  simplify() {\n    this._verse = void 0;\n  }\n  /**\n   * Makes a clone of the reference.\n   *\n   * @returns The cloned VerseRef.\n   */\n  clone() {\n    return new i(this);\n  }\n  toString() {\n    const e = this.book;\n    return e === \"\" ? \"\" : `${e} ${this.chapter}:${this.verse}`;\n  }\n  toJSON() {\n    let e = this.verse;\n    (e === \"\" || e === this.verseNum.toString()) && (e = void 0);\n    const s = {\n      book: this.book,\n      chapterNum: this.chapterNum,\n      verseNum: this.verseNum,\n      verse: e,\n      versificationStr: this.versificationStr\n    };\n    return e || delete s.verse, s;\n  }\n  /**\n   * Compares this `VerseRef` with supplied one.\n   * @param verseRef - object to compare this one to.\n   * @returns `true` if this `VerseRef` is equal to the supplied one, `false` otherwise.\n   */\n  equals(e) {\n    return e instanceof i ? e._bookNum === this._bookNum && e._chapterNum === this._chapterNum && e._verseNum === this._verseNum && e.verse === this.verse && (e.versification == null && this.versification == null || e.versification != null && this.versification != null && e.versification.equals(this.versification)) : !1;\n  }\n  /**\n   * Enumerate all individual verses contained in a VerseRef.\n   * Verse ranges are indicated by \"-\" and consecutive verses by \",\"s.\n   * Examples:\n   * GEN 1:2 returns GEN 1:2\n   * GEN 1:1a-3b,5 returns GEN 1:1a, GEN 1:2, GEN 1:3b, GEN 1:5\n   * GEN 1:2a-2c returns //! ??????\n   *\n   * @param specifiedVersesOnly - if set to <c>true</c> return only verses that are\n   * explicitly specified only, not verses within a range. Defaults to `false`.\n   * @param verseRangeSeparators - Verse range separators.\n   * Defaults to `VerseRef.verseRangeSeparators`.\n   * @param verseSequenceSeparators - Verse sequence separators.\n   * Defaults to `VerseRef.verseSequenceIndicators`.\n   * @returns An array of all single verse references in this VerseRef.\n   */\n  allVerses(e = !1, s = i.verseRangeSeparators, r = i.verseSequenceIndicators) {\n    if (this._verse == null || this.chapterNum <= 0)\n      return [this.clone()];\n    const a = [], o = E(this._verse, r);\n    for (const u of o.map((f) => E(f, s))) {\n      const f = this.clone();\n      f.verse = u[0];\n      const d = f.verseNum;\n      if (a.push(f), u.length > 1) {\n        const b = this.clone();\n        if (b.verse = u[1], !e)\n          for (let p = d + 1; p < b.verseNum; p++) {\n            const J = new i(\n              this._bookNum,\n              this._chapterNum,\n              p,\n              this.versification\n            );\n            this.isExcluded || a.push(J);\n          }\n        a.push(b);\n      }\n    }\n    return a;\n  }\n  /**\n   * Validates a verse number using the supplied separators rather than the defaults.\n   */\n  validateVerse(e, s) {\n    if (!this.verse)\n      return this.internalValid;\n    let r = 0;\n    for (const a of this.allVerses(!0, e, s)) {\n      const o = a.internalValid;\n      if (o !== 0)\n        return o;\n      const u = a.BBBCCCVVV;\n      if (r > u)\n        return 3;\n      if (r === u)\n        return 4;\n      r = u;\n    }\n    return 0;\n  }\n  /**\n   * Gets whether a single verse reference is valid.\n   */\n  get internalValid() {\n    return this.versification == null ? 1 : this._bookNum <= 0 || this._bookNum > m.lastBook ? 2 : (m.isCanonical(this._bookNum), 0);\n  }\n  setEmpty(e = i.defaultVersification) {\n    this._bookNum = 0, this._chapterNum = -1, this._verse = void 0, this.versification = e;\n  }\n  updateInternal(e, s, r) {\n    this.bookNum = m.bookIdToNumber(e), this.chapter = s, this.verse = r;\n  }\n};\nn(i, \"defaultVersification\", c.English), n(i, \"verseRangeSeparator\", \"-\"), n(i, \"verseSequenceIndicator\", \",\"), n(i, \"verseRangeSeparators\", [i.verseRangeSeparator]), n(i, \"verseSequenceIndicators\", [i.verseSequenceIndicator]), n(i, \"chapterDigitShifter\", 1e3), n(i, \"bookDigitShifter\", i.chapterDigitShifter * i.chapterDigitShifter), n(i, \"bcvMaxValue\", i.chapterDigitShifter - 1), /**\n * The valid status of the VerseRef.\n */\nn(i, \"ValidStatusType\", D);\nlet M = i;\nclass v extends Error {\n}\nexport {\n  _ as BookSet,\n  m as Canon,\n  c as ScrVers,\n  l as ScrVersType,\n  M as VerseRef,\n  v as VerseRefException\n};\n//# sourceMappingURL=index.es.js.map\n","/**\n * Ensures that the given input is returned as an array.\n *\n * This function takes a value that might be a single item, an array, or `undefined` and returns it\n * as an array:\n *\n * - If the input is `undefined`, an empty array is returned.\n * - If the input is already an array, it is returned as-is.\n * - If the input is a single item, it is wrapped in an array.\n *\n * @typeParam T - The type of the elements in the array.\n * @param maybeArray - The value that may be a single item, an array, or `undefined`.\n * @returns An array containing the input value(s). If the input is `undefined`, an empty array is\n *   returned.\n */\nexport function ensureArray<T>(maybeArray: T | T[] | undefined): T[] {\n  if (!maybeArray) return [];\n\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n}\n\nexport default ensureArray;\n","import { LocalizeKey } from 'extension-contributions/menus.model';\nimport {\n  indexOf as stringzIndexOf,\n  length as stringzLength,\n  limit as stringzLimit,\n  substr as stringzSubstr,\n  substring as stringzSubstring,\n  toArray as stringzToArray,\n} from 'stringz';\nimport { ensureArray } from './array-util';\nimport { isString } from './util';\n\n/**\n * This function mirrors the `at` function from the JavaScript Standard String object. It handles\n * Unicode code points instead of UTF-16 character codes.\n *\n * Finds the Unicode code point at the given index.\n *\n * @param string String to index\n * @param index Position of the character to be returned in range of -length(string) to\n *   length(string)\n * @returns New string consisting of the Unicode code point located at the specified offset,\n *   undefined if index is out of bounds\n */\nexport function at(string: string, index: number): string | undefined {\n  const stringLen: number = stringLength(string);\n  /*\n   * NOTE(mattg): The index bounds on a JS string/array look like this:\n   * String:   |--------------|\n   * Positive: 0............N-1\n   * Negative: -N............-1\n   *\n   * Total Bounds Range (inclusive): -N..N-1\n   */\n  if (index >= stringLen || index < -stringLen) return undefined;\n  return substr(string, index, 1);\n}\n\n/**\n * This function mirrors the `charAt` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Returns a new string consisting of the single unicode code point at the given index.\n *\n * @param string String to index\n * @param index Position of the string character to be returned, in the range of 0 to\n *   length(string)-1\n * @returns New string consisting of the Unicode code point located at the specified offset, empty\n *   string if index is out of bounds\n */\nexport function charAt(string: string, index: number): string {\n  if (index < 0 || index > stringLength(string) - 1) return '';\n  return substr(string, index, 1);\n}\n\n/**\n * This function mirrors the `codePointAt` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Returns a non-negative integer that is the Unicode code point value of the character starting at\n * the given index. Usage Warning: This function only takes the first code point in a multi-code\n * point grapheme.\n *\n * @param string String to index\n * @param index Position of the string character to be returned, in the range of 0 to\n *   length(string)-1\n * @returns Non-negative integer representing the code point value of the character at the given\n *   index, or undefined if there is no element at that position\n */\nexport function codePointAt(string: string, index: number): number | undefined {\n  if (index < 0 || index > stringLength(string) - 1) return undefined;\n  return substr(string, index, 1).codePointAt(0);\n}\n\n/**\n * This function mirrors the `endsWith` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Determines whether a string ends with the characters of this string.\n *\n * @param string String to search through\n * @param searchString Characters to search for at the end of the string\n * @param endPosition End position where searchString is expected to be found. Default is\n *   `length(string)`\n * @returns True if it ends with searchString, false if it does not\n */\nexport function endsWith(\n  string: string,\n  searchString: string,\n  endPosition: number = stringLength(string),\n): boolean {\n  /*\n   * NOTE(mattg): This re-write of endsWith reduces it\n   * from 210,808x slower than JS endsWith\n   * to 81,946x slower\n   */\n  const searchStringLen = stringLength(searchString);\n  const index = endPosition - searchStringLen;\n  if (index < 0) return false;\n  return substr(string, index, searchStringLen) === searchString;\n}\n\n/**\n * Get the index of the closest closing curly brace in a string.\n *\n * Note: when escaped, gets the index of the curly brace, not the backslash before it.\n *\n * @param str String to search\n * @param index Index at which to start searching. Inclusive of this index\n * @param escaped Whether to search for an escaped or an unescaped closing curly brace\n * @returns Index of closest closing curly brace or -1 if not found\n */\nfunction indexOfClosestClosingCurlyBrace(str: string, index: number, escaped: boolean) {\n  if (index < 0) return -1;\n  if (escaped) {\n    if (charAt(str, index) === '}' && charAt(str, index - 1) === '\\\\') return index;\n    const closeCurlyBraceIndex = indexOf(str, '\\\\}', index);\n    return closeCurlyBraceIndex >= 0 ? closeCurlyBraceIndex + 1 : closeCurlyBraceIndex;\n  }\n\n  let i = index;\n  const strLength = stringLength(str);\n  while (i < strLength) {\n    i = indexOf(str, '}', i);\n\n    if (i === -1 || charAt(str, i - 1) !== '\\\\') break;\n\n    // Didn't find an un-escaped close brace, so keep looking\n    i += 1;\n  }\n\n  return i >= strLength ? -1 : i;\n}\n\n/**\n * Formats a string into an array of objects (adjacent strings are concatenated in one array entry),\n * replacing `{replacer key}` with the value in the `replacers` at that replacer key (or multiple\n * replacer values if there are multiple in the string). Will also remove \\ before curly braces if\n * curly braces are escaped with a backslash in order to preserve the curly braces. E.g. 'Hi, this\n * is {name}! I like `\\{curly braces\\}`! would become Hi, this is Jim! I like {curly braces}!\n *\n * If the key in unescaped braces is not found, returns the key without the braces. Empty unescaped\n * curly braces will just return a string without the braces e.g. ('I am {Nemo}', { 'name': 'Jim'})\n * would return 'I am Nemo'.\n *\n * Note: React elements can be used as replacer values.\n *\n * @example\n *\n * ```tsx\n * <p>\n *   {formatReplacementStringToArray('Hi {other}! I am {name}.', {\n *     other: 'Billy',\n *     name: <span className=\"tw-text-red-500\">Jim</span>,\n *   })}\n * </p>\n * ```\n *\n * @example\n *\n * ```typescript\n * formatReplacementStringToArray(\n *   'Hi, this is {name}! I like \\{curly braces\\}! I have a {carInfo} car. My favorite food is {food}.',\n *   { name: ['Bill'], carInfo: { year: 2015, color: 'blue' } }\n * );\n *\n * =>\n *\n * ['Hi, this is ', ['Bill'], '! I like {curly braces}! I have a ', { year: 2015, color: 'blue' }, ' car. My favorite food is food.']\n * ```\n *\n * @param str String to format and break out into an array of objects\n * @param replacers Object whose keys are replacer keys and whose values are the values with which\n *   to replace `{replacer key}`s found in the string to format. If the replacer value is a string,\n *   it will be concatenated into existing strings in the array. Otherwise, the replacer value will\n *   be added as a new entry in the array\n * @returns Array of formatted strings and replaced objects\n */\nexport function formatReplacementStringToArray<T = unknown>(\n  str: string,\n  replacers: { [key: string | number]: T } | object,\n): (string | T)[] {\n  /** The compiled list of contents with replacers replaced appropriately */\n  const contents: (string | T)[] = [];\n\n  // current index in the string as we go through it\n  let i = 0;\n  // first index of characters to include in the next plain string added to the content\n  let nextIntermediateStartIndex = 0;\n\n  /**\n   * Adds some content to the array of contents that is being built and also add the intermediate\n   * string between the last added content and this added content\n   *\n   * @param newContent Content to add\n   * @param newContentIndex Position in string where newContent starts\n   * @param newContentLength Length in the string of the representation of this newContent\n   */\n  function addToContents(\n    newContent: string | T,\n    newContentIndex: number,\n    newContentLength: number,\n  ) {\n    // Get the string content between the last new content and this new content\n    const intermediateContent = substring(str, nextIntermediateStartIndex, newContentIndex);\n\n    // If the last item in contents is a string, pull it out and add intermediateContent to\n    // it. Otherwise stick with just intermediateContent\n    const baseSubstring =\n      contents.length > 0 && isString(contents[contents.length - 1])\n        ? `${contents.pop()}${intermediateContent}`\n        : intermediateContent;\n\n    if (isString(newContent)) {\n      // If the new content is a string, add it all together\n      contents.push(`${baseSubstring}${newContent}`);\n    } else {\n      // New content is not a string. Add the base string if it exists (don't add an\n      // empty string between added contents), then add the new content separately\n      if (baseSubstring) contents.push(baseSubstring);\n      contents.push(newContent);\n    }\n\n    // Set the intermediate start index to right after the new content so whatever\n    // string content is between replacers gets added\n    nextIntermediateStartIndex = newContentIndex + newContentLength;\n  }\n\n  const strLength = stringLength(str);\n  while (i < strLength) {\n    switch (charAt(str, i)) {\n      case '{':\n        if (charAt(str, i - 1) !== '\\\\') {\n          // This character is an un-escaped open curly brace. Try to match and replace\n          const closeCurlyBraceIndex = indexOfClosestClosingCurlyBrace(str, i, false);\n          if (closeCurlyBraceIndex >= 0) {\n            // We have matching open and close indices. Try to replace the contents\n            const replacerKey = substring(str, i + 1, closeCurlyBraceIndex);\n\n            // Replace with the replacer or just remove the curly braces\n            const replacerContent =\n              replacerKey in replacers\n                ? // Just checked that the key is in the object\n                  // eslint-disable-next-line no-type-assertion/no-type-assertion\n                  replacers[replacerKey as keyof typeof replacers]\n                : replacerKey;\n\n            addToContents(replacerContent, i, closeCurlyBraceIndex + 1 - i);\n\n            // Put our index at the closing brace to keep processing the string after it\n            i = closeCurlyBraceIndex;\n            // Set the intermediate start index to right after our closing curly brace so whatever\n            // string content is between replacers gets added\n            nextIntermediateStartIndex = closeCurlyBraceIndex + 1;\n          } else {\n            // This is an unexpected un-escaped open curly brace with no matching closing curly\n            // brace. Just ignore, I guess\n          }\n        } else {\n          // This character is an escaped open curly brace. Add the curly brace but skip over the\n          // escape backslash\n          addToContents('{', i - 1, 2);\n        }\n        break;\n      case '}':\n        if (charAt(str, i - 1) !== '\\\\') {\n          // This character is an un-escaped closing curly brace with no matching open curly\n          // brace. Just ignore, I guess\n        } else {\n          // This character is an escaped closing curly brace. Add the curly brace but skip over\n          // the escape backslash\n          addToContents('}', i - 1, 2);\n        }\n        break;\n      default:\n        // No need to do anything with other characters at this point\n        break;\n    }\n\n    i += 1;\n  }\n\n  // Now we are through the whole string and need to add the string content after all replacers if\n  // there is anything left\n  if (nextIntermediateStartIndex < strLength) {\n    // Get the string content between the last new content and this new content\n    const endContent = substring(str, nextIntermediateStartIndex);\n\n    // If the last item in contents is a string, pull it out and add endContent to\n    // it. Then put it in the contents array\n    contents.push(\n      contents.length > 0 && isString(contents[contents.length - 1])\n        ? `${contents.pop()}${endContent}`\n        : endContent,\n    );\n  }\n\n  return contents;\n}\n\n/**\n * Formats a string, replacing `{replacer key}` with the value in the `replacers` at that replacer\n * key (or multiple replacer values if there are multiple in the string). Will also remove \\ before\n * curly braces if curly braces are escaped with a backslash in order to preserve the curly braces.\n * E.g. 'Hi, this is {name}! I like `\\{curly braces\\}`! would become Hi, this is Jim! I like {curly\n * braces}!\n *\n * If the key in unescaped braces is not found, returns the key without the braces. Empty unescaped\n * curly braces will just return a string without the braces e.g. ('I am {Nemo}', { 'name': 'Jim'})\n * would return 'I am Nemo'.\n *\n * @example\n *\n * ```typescript\n * formatReplacementString(\n *   'Hi, this is {name}! I like \\{curly braces\\}! I have a {carColor} car. My favorite food is {food}.',\n *   { name: 'Bill', carColor: 'blue' }\n * );\n *\n * =>\n *\n * 'Hi, this is Bill! I like {curly braces}! I have a blue car. My favorite food is food.'\n * ```\n *\n * @param str String to format\n * @param replacers Object whose keys are replacer keys and whose values are the values with which\n *   to replace `{replacer key}`s found in the string to format. Will be coerced to strings using\n *   `${replacerValue}`\n * @returns Formatted string\n */\nexport function formatReplacementString(\n  str: string,\n  replacers: { [key: string | number]: string | unknown } | object,\n): string {\n  return formatReplacementStringToArray(str, replacers)\n    .map((content) => `${content}`)\n    .join('');\n}\n\n/**\n * This function mirrors the `includes` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Performs a case-sensitive search to determine if searchString is found in string.\n *\n * @param string String to search through\n * @param searchString String to search for\n * @param position Position within the string to start searching for searchString. Default is `0`\n * @returns True if search string is found, false if it is not\n */\nexport function includes(string: string, searchString: string, position: number = 0): boolean {\n  const partialString = substring(string, position);\n  const indexOfSearchString = indexOf(partialString, searchString);\n  if (indexOfSearchString === -1) return false;\n  return true;\n}\n\n/**\n * This function mirrors the `indexOf` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Returns the index of the first occurrence of a given string.\n *\n * @param string String to search through\n * @param searchString The string to search for\n * @param position Start of searching. Default is `0`\n * @returns Index of the first occurrence of a given string\n */\nexport function indexOf(\n  string: string,\n  searchString: string,\n  position: number | undefined = 0,\n): number {\n  return stringzIndexOf(string, searchString, position);\n}\n\n/**\n * This function mirrors the `lastIndexOf` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Searches this string and returns the index of the last occurrence of the specified substring.\n *\n * @param string String to search through\n * @param searchString Substring to search for\n * @param position The index at which to begin searching. If omitted, the search begins at the end\n *   of the string. Default is `undefined`\n * @returns Index of the last occurrence of searchString found, or -1 if not found.\n */\nexport function lastIndexOf(string: string, searchString: string, position?: number): number {\n  const stringLen: number = stringLength(string);\n  const searchStringLen: number = stringLength(searchString);\n  let validatedPosition = position === undefined ? stringLen : position;\n\n  if (validatedPosition < 0) {\n    validatedPosition = 0;\n  } else if (validatedPosition >= stringLen) {\n    validatedPosition = stringLen - 1;\n  }\n\n  for (let index = validatedPosition; index >= 0; index--) {\n    // this check is far cheaper than a `substr` call,\n    // so this is is a huge performance improvement!\n    // if (string[index] === searchString[0]) {\n    if (substr(string, index, searchStringLen) === searchString) {\n      return index;\n    }\n    // }\n  }\n\n  return -1;\n}\n\n/**\n * This function mirrors the `length` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes. Since `length` appears to be a\n * reserved keyword, the function was renamed to `stringLength`\n *\n * Returns the length of a string.\n *\n * @param string String to return the length for\n * @returns Number that is length of the starting string\n */\nexport function stringLength(string: string): number {\n  return stringzLength(string);\n}\n\n/**\n * This function mirrors the `normalize` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Returns the Unicode Normalization Form of this string.\n *\n * @param string The starting string\n * @param form Form specifying the Unicode Normalization Form. Default is `'NFC'`\n * @returns A string containing the Unicode Normalization Form of the given string.\n */\nexport function normalize(string: string, form: 'NFC' | 'NFD' | 'NFKC' | 'NFKD' | 'none'): string {\n  const upperCaseForm = form.toUpperCase();\n  if (upperCaseForm === 'NONE') {\n    return string;\n  }\n  return string.normalize(upperCaseForm);\n}\n\n/**\n * Compares two strings using an ordinal comparison approach based on the specified collation\n * options. This function uses the built-in `localeCompare` method with the 'en' locale and the\n * provided collation options to compare the strings.\n *\n * @param string1 The first string to compare.\n * @param string2 The second string to compare.\n * @param options Optional. The collation options used for comparison.\n * @returns A number indicating the result of the comparison: - Negative value if string1 precedes\n *   string2 in sorting order. - Zero if string1 and string2 are equivalent in sorting order. -\n *   Positive value if string1 follows string2 in sorting order.\n */\nexport function ordinalCompare(\n  string1: string,\n  string2: string,\n  options?: Intl.CollatorOptions,\n): number {\n  return string1.localeCompare(string2, 'en', options);\n}\n\n/**\n * This function mirrors the `padEnd` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Pads this string with another string (multiple times, if needed) until the resulting string\n * reaches the given length. The padding is applied from the end of this string.\n *\n * @param string String to add padding too\n * @param targetLength The length of the resulting string once the starting string has been padded.\n *   If value is less than or equal to length(string), then string is returned as is.\n * @param padString The string to pad the current string with. If padString is too long to stay\n *   within targetLength, it will be truncated. Default is `\" \"`\n * @returns String with appropriate padding at the end\n */\n// Note: Limit with padString only works when length(padString) = 1, will be fixed with https://github.com/sallar/stringz/pull/59\nexport function padEnd(string: string, targetLength: number, padString: string = ' '): string {\n  if (targetLength <= stringLength(string)) return string;\n  return stringzLimit(string, targetLength, padString, 'right');\n}\n\n/**\n * This function mirrors the `padStart` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Pads this string with another string (multiple times, if needed) until the resulting string\n * reaches the given length. The padding is applied from the start of this string.\n *\n * @param string String to add padding too\n * @param targetLength The length of the resulting string once the starting string has been padded.\n *   If value is less than or equal to length(string), then string is returned as is.\n * @param padString The string to pad the current string with. If padString is too long to stay\n *   within the targetLength, it will be truncated from the end. Default is `\" \"`\n * @returns String with of specified targetLength with padString applied from the start\n */\n// Note: Limit with padString only works when length(padString) = 1, will be fixed with https://github.com/sallar/stringz/pull/59\nexport function padStart(string: string, targetLength: number, padString: string = ' '): string {\n  if (targetLength <= stringLength(string)) return string;\n  return stringzLimit(string, targetLength, padString, 'left');\n}\n\n// This is a helper function that performs a correction on the slice index to make sure it\n// cannot go out of bounds\nfunction correctSliceIndex(length: number, index: number) {\n  if (index > length) return length;\n  if (index < -length) return 0;\n  if (index < 0) return index + length;\n  return index;\n}\n\n/**\n * This function mirrors the `slice` function from the JavaScript Standard String object. It handles\n * Unicode code points instead of UTF-16 character codes.\n *\n * Extracts a section of this string and returns it as a new string, without modifying the original\n * string.\n *\n * @param string The starting string\n * @param indexStart The index of the first character to include in the returned substring.\n * @param indexEnd The index of the first character to exclude from the returned substring.\n * @returns A new string containing the extracted section of the string.\n */\nexport function slice(string: string, indexStart: number, indexEnd?: number): string {\n  const length: number = stringLength(string);\n  if (\n    indexStart > length ||\n    (indexEnd &&\n      ((indexStart > indexEnd &&\n        !(indexStart >= 0 && indexStart < length && indexEnd < 0 && indexEnd > -length)) ||\n        indexEnd < -length))\n  )\n    return '';\n\n  const newStart = correctSliceIndex(length, indexStart);\n  const newEnd = indexEnd ? correctSliceIndex(length, indexEnd) : undefined;\n\n  return substring(string, newStart, newEnd);\n}\n\n/**\n * This function mirrors the `split` function from the JavaScript Standard String object. It handles\n * Unicode code points instead of UTF-16 character codes.\n *\n * Takes a pattern and divides the string into an ordered list of substrings by searching for the\n * pattern, puts these substrings into an array, and returns the array.\n *\n * @param string The string to split\n * @param separator The pattern describing where each split should occur\n * @param splitLimit Limit on the number of substrings to be included in the array. Splits the\n *   string at each occurrence of specified separator, but stops when limit entries have been placed\n *   in the array.\n * @returns An array of strings, split at each point where separator occurs in the starting string.\n *   Returns undefined if separator is not found in string.\n */\nexport function split(string: string, separator: string | RegExp, splitLimit?: number): string[] {\n  const result: string[] = [];\n\n  if (splitLimit !== undefined && splitLimit <= 0) {\n    return [string];\n  }\n\n  if (separator === '') return toArray(string).slice(0, splitLimit);\n\n  let regexSeparator = separator;\n  if (\n    typeof separator === 'string' ||\n    (separator instanceof RegExp && !includes(separator.flags, 'g'))\n  ) {\n    regexSeparator = new RegExp(separator, 'g');\n  }\n\n  const matches: RegExpMatchArray | null = string.match(regexSeparator);\n\n  let currentIndex = 0;\n\n  if (!matches) return [string];\n\n  for (let index = 0; index < (splitLimit ? splitLimit - 1 : matches.length); index++) {\n    const matchIndex = indexOf(string, matches[index], currentIndex);\n    const matchLength = stringLength(matches[index]);\n\n    result.push(substring(string, currentIndex, matchIndex));\n    currentIndex = matchIndex + matchLength;\n\n    if (splitLimit !== undefined && result.length === splitLimit) {\n      break;\n    }\n  }\n\n  result.push(substring(string, currentIndex));\n\n  return result;\n}\n\n/**\n * This function mirrors the `startsWith` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Determines whether the string begins with the characters of a specified string, returning true or\n * false as appropriate.\n *\n * @param string String to search through\n * @param searchString The characters to be searched for at the start of this string.\n * @param position The start position at which searchString is expected to be found (the index of\n *   searchString's first character). Default is `0`\n * @returns True if the given characters are found at the beginning of the string, including when\n *   searchString is an empty string; otherwise, false.\n */\nexport function startsWith(string: string, searchString: string, position: number = 0): boolean {\n  const indexOfSearchString = indexOf(string, searchString, position);\n  if (indexOfSearchString !== position) return false;\n  return true;\n}\n\n/**\n * This function mirrors the `substr` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Returns a substring by providing start and length. This function is not exported because it is\n * considered deprecated, however it is still useful as a local helper function.\n *\n * @param string String to be divided\n * @param begin Start position. Default is `Start of string`\n * @param len Length of result. Default is `String length minus start parameter`. Default is `String\n *   length minus start parameter`\n * @returns Substring from starting string\n */\nfunction substr(\n  string: string,\n  begin: number = 0,\n  len: number = stringLength(string) - begin,\n): string {\n  return stringzSubstr(string, begin, len);\n}\n\n/**\n * This function mirrors the `substring` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Returns a substring by providing start and end position.\n *\n * @param string String to be divided\n * @param begin Start position\n * @param end End position. Default is `End of string`\n * @returns Substring from starting string\n */\nexport function substring(\n  string: string,\n  begin: number,\n  end: number = stringLength(string),\n): string {\n  return stringzSubstring(string, begin, end);\n}\n\n/**\n * This function mirrors the `toArray` function from the JavaScript Standard String object. It\n * handles Unicode code points instead of UTF-16 character codes.\n *\n * Converts a string to an array of string characters.\n *\n * @param string String to convert to array\n * @returns An array of characters from the starting string\n */\nexport function toArray(string: string): string[] {\n  return stringzToArray(string);\n}\n\n/** Determine whether the string is a `LocalizeKey` meant to be localized in Platform.Bible. */\nexport function isLocalizeKey(str: string): str is LocalizeKey {\n  return startsWith(str, '%') && endsWith(str, '%');\n}\n\n/**\n * Escape RegExp special characters.\n *\n * You can also use this to escape a string that is inserted into the middle of a regex, for\n * example, into a character class.\n *\n * All credit to [`escape-string-regexp`](https://www.npmjs.com/package/escape-string-regexp) - this\n * function is simply copied directly from there to allow a common js export\n *\n * @example\n *\n *     import escapeStringRegexp from 'platform-bible-utils';\n *\n *     const escapedString = escapeStringRegexp('How much $ for a 🦄?');\n *     //=> 'How much \\\\$ for a 🦄\\\\?'\n *\n *     new RegExp(escapedString);\n */\nexport function escapeStringRegexp(string: string): string {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  // Escape characters with special meaning either inside or outside character sets.\n  // Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}\n\n/**\n * Transforms a string or an array of strings into an array of regular expressions, ensuring that\n * the result is always an array.\n *\n * This function accepts a value that may be a single string, an array of strings, or `undefined`.\n * It then:\n *\n * - Converts each string into a `RegExp` object.\n * - If the input is an array containing nested arrays, it converts each string in the nested arrays\n *   into `RegExp` objects.\n * - Ensures that the result is always an array of `RegExp` objects or arrays of `RegExp` objects.\n *\n * @param stringStringMaybeArray - The value to be transformed, which can be a single string, an\n *   array of strings or arrays of strings, or `undefined`.\n * @returns An array of `RegExp` objects or arrays of `RegExp` objects. If the input is `undefined`,\n *   an empty array is returned.\n */\nexport function transformAndEnsureRegExpRegExpArray(\n  stringStringMaybeArray: string | (string | string[])[] | undefined,\n): (RegExp | RegExp[])[] {\n  if (!stringStringMaybeArray) return [];\n\n  const stringStringArray = ensureArray(stringStringMaybeArray);\n\n  const regExpRegExpArray = stringStringArray.map((stringMaybeStringArray: string | string[]) =>\n    Array.isArray(stringMaybeStringArray)\n      ? stringMaybeStringArray.map((str) => new RegExp(str))\n      : new RegExp(stringMaybeStringArray),\n  );\n\n  return regExpRegExpArray;\n}\n\n/**\n * Transforms a string or an array of strings into an array of regular expressions.\n *\n * This function accepts a value that may be a single string, an array of strings, or `undefined`.\n * It then:\n *\n * - Converts each string into a `RegExp` object.\n * - Ensures that the result is always an array of `RegExp` objects.\n *\n * @param stringMaybeArray - The value to be transformed, which can be a single string, an array of\n *   strings, or `undefined`.\n * @returns An array of `RegExp` objects. If the input is `undefined`, an empty array is returned.\n */\nexport function transformAndEnsureRegExpArray(\n  stringMaybeArray: string | string[] | undefined,\n): RegExp[] {\n  if (!stringMaybeArray) return [];\n\n  const stringArray = ensureArray(stringMaybeArray);\n\n  const regExpArray = stringArray.map((str: string) => new RegExp(str));\n\n  return regExpArray;\n}\n\nconst whiteSpaceRegex =\n  // Using unicode control characters to be very explicit about which characters we are using.\n  // The first 6 characters are the control characters \\f\\n\\r\\t\\v.\n  // eslint-disable-next-line no-control-regex\n  /^[\\u000C\\u000A\\u000D\\u0009\\u000B\\u0020\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\u0085]+$/;\n/**\n * Determines whether a string contains one or more white space characters and no other characters.\n *\n * This implementation uses [dotnet's `Char.IsWhiteSpace` definition of white\n * space](https://learn.microsoft.com/en-us/dotnet/api/system.char.iswhitespace?view=net-9.0):\n *\n * ```ts\n * /^[\\u000C\\u000A\\u000D\\u0009\\u000B\\u0020\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\u0085]+$/.test(\n *   ch,\n * );\n * ```\n *\n * Note: This differs from\n * [`/\\s/.test(ch)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes#:~:text=Matches%20a%20single%20white%20space%20character%2C%20including%20space)\n * (usually considered the determiner of what is white space in JavaScript) in that it does not\n * include ZWNBSP (U+FEFF) but rather includes NEXT LINE (U+0085)\n *\n * @param ch Single character or a string of characters\n * @returns `true` if the string consists of one or more white space characters and no other\n *   characters, `false` otherwise\n */\nexport function isWhiteSpace(ch: string) {\n  return whiteSpaceRegex.test(ch);\n}\n\n/**\n * Converts PascalCase or camelCase string to kebab-case. To detect upper- and lower-case\n * characters, uses `.toUpperCase` and `.toLowerCase` to be locale-independent.\n *\n * Current implementation supports only UTF-16.\n *\n * Thanks to ChatGPT https://chatgpt.com/share/67c8aa44-e054-800c-8068-e1e6630081f7\n */\nexport function toKebabCase(input: string): string {\n  let result = '';\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const isUpper = char === char.toUpperCase() && char !== char.toLowerCase();\n\n    if (isUpper) {\n      if (i > 0) {\n        const prevChar = input[i - 1];\n        const isPrevUpper =\n          prevChar === prevChar.toUpperCase() && prevChar !== prevChar.toLowerCase();\n\n        // If previous is not uppercase, always insert dash.\n        if (!isPrevUpper) {\n          result += '-';\n        } else if (i + 1 < input.length) {\n          // Deal with initialisms and acronyms as if they are whole words (\"APIFinder\" -> \"api-finder\")\n          // Previous was uppercase; insert dash only if the next character exists and is lowercase.\n          const nextChar = input[i + 1];\n          const isNextLower =\n            nextChar === nextChar.toLowerCase() && nextChar !== nextChar.toUpperCase();\n          if (isNextLower) {\n            result += '-';\n          }\n        }\n      }\n      result += char.toLowerCase();\n    } else {\n      result += char;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Shortens text by splitting by space, removing tokens from the middle and replacing them with\n * `[...]`\n *\n * @param text The input text\n * @param numberOfTokensToKeepBeforeAndAfter Count of space separated tokens to keep at the\n *   beginning and end of the text\n * @returns The full text if shorter than tokens to keep for beginning plus end, otherwise the first\n *   x tokens, followed by `[...]` and the last x tokens\n */\nexport function collapseMiddleWords(\n  text: string,\n  numberOfTokensToKeepBeforeAndAfter: number,\n): string {\n  const tokens = text.split(/\\s+/);\n\n  // If the text is too short to truncate, return as-is\n  if (\n    tokens.length <= numberOfTokensToKeepBeforeAndAfter * 2 ||\n    numberOfTokensToKeepBeforeAndAfter < 1\n  ) {\n    return text;\n  }\n\n  const startTokens = tokens.slice(0, numberOfTokensToKeepBeforeAndAfter);\n  const endTokens = tokens.slice(-numberOfTokensToKeepBeforeAndAfter);\n\n  return [...startTokens, `[...]`, ...endTokens].join(' ');\n}\n\n/** This is an internal-only export for testing purposes and should not be used in development */\nexport const testingStringUtils = {\n  indexOfClosestClosingCurlyBrace,\n  substr,\n};\n","import { Canon, SerializedVerseRef, VerseRef } from '@sillsdev/scripture';\nimport {\n  MarkerContent,\n  MarkerObject,\n  Usj,\n  USJ_TYPE,\n} from '@eten-tech-foundation/scripture-utilities';\nimport { BookInfo, ScrollGroupId } from './scripture.model';\nimport { at, isWhiteSpace, slice, split, startsWith } from '../string-util';\nimport { LocalizeKey } from '../extension-contributions/menus.model';\nimport { isString } from '../util';\n\n/**\n * All marker types that seem to be block-level according to `UsxFragmenter.AppendStartUsfm`. And\n * the `type` for USJ documents' top-level object because that is effectively a block\n *\n * Note: This \"block-level\" means the marker is in its own paragraph (a [CSS\n * Block](https://developer.mozilla.org/en-US/docs/Glossary/Block/CSS)) as opposed to being\n * in-line.\n */\nconst BLOCK_MARKER_TYPES = ['chapter', 'book', 'para', 'row', 'sidebar', USJ_TYPE];\n\nconst ZWSP = '\\u200B';\n\nconst scrBookData: BookInfo[] = [\n  { shortName: 'ERR', fullNames: ['ERROR'], chapters: -1 },\n  { shortName: 'GEN', fullNames: ['Genesis'], chapters: 50 },\n  { shortName: 'EXO', fullNames: ['Exodus'], chapters: 40 },\n  { shortName: 'LEV', fullNames: ['Leviticus'], chapters: 27 },\n  { shortName: 'NUM', fullNames: ['Numbers'], chapters: 36 },\n  { shortName: 'DEU', fullNames: ['Deuteronomy'], chapters: 34 },\n  { shortName: 'JOS', fullNames: ['Joshua'], chapters: 24 },\n  { shortName: 'JDG', fullNames: ['Judges'], chapters: 21 },\n  { shortName: 'RUT', fullNames: ['Ruth'], chapters: 4 },\n  { shortName: '1SA', fullNames: ['1 Samuel'], chapters: 31 },\n  { shortName: '2SA', fullNames: ['2 Samuel'], chapters: 24 },\n  { shortName: '1KI', fullNames: ['1 Kings'], chapters: 22 },\n  { shortName: '2KI', fullNames: ['2 Kings'], chapters: 25 },\n  { shortName: '1CH', fullNames: ['1 Chronicles'], chapters: 29 },\n  { shortName: '2CH', fullNames: ['2 Chronicles'], chapters: 36 },\n  { shortName: 'EZR', fullNames: ['Ezra'], chapters: 10 },\n  { shortName: 'NEH', fullNames: ['Nehemiah'], chapters: 13 },\n  { shortName: 'EST', fullNames: ['Esther'], chapters: 10 },\n  { shortName: 'JOB', fullNames: ['Job'], chapters: 42 },\n  { shortName: 'PSA', fullNames: ['Psalm', 'Psalms'], chapters: 150 },\n  { shortName: 'PRO', fullNames: ['Proverbs'], chapters: 31 },\n  { shortName: 'ECC', fullNames: ['Ecclesiastes'], chapters: 12 },\n  { shortName: 'SNG', fullNames: ['Song of Solomon', 'Song of Songs'], chapters: 8 },\n  { shortName: 'ISA', fullNames: ['Isaiah'], chapters: 66 },\n  { shortName: 'JER', fullNames: ['Jeremiah'], chapters: 52 },\n  { shortName: 'LAM', fullNames: ['Lamentations'], chapters: 5 },\n  { shortName: 'EZK', fullNames: ['Ezekiel'], chapters: 48 },\n  { shortName: 'DAN', fullNames: ['Daniel'], chapters: 12 },\n  { shortName: 'HOS', fullNames: ['Hosea'], chapters: 14 },\n  { shortName: 'JOL', fullNames: ['Joel'], chapters: 3 },\n  { shortName: 'AMO', fullNames: ['Amos'], chapters: 9 },\n  { shortName: 'OBA', fullNames: ['Obadiah'], chapters: 1 },\n  { shortName: 'JON', fullNames: ['Jonah'], chapters: 4 },\n  { shortName: 'MIC', fullNames: ['Micah'], chapters: 7 },\n  { shortName: 'NAM', fullNames: ['Nahum'], chapters: 3 },\n  { shortName: 'HAB', fullNames: ['Habakkuk'], chapters: 3 },\n  { shortName: 'ZEP', fullNames: ['Zephaniah'], chapters: 3 },\n  { shortName: 'HAG', fullNames: ['Haggai'], chapters: 2 },\n  { shortName: 'ZEC', fullNames: ['Zechariah'], chapters: 14 },\n  { shortName: 'MAL', fullNames: ['Malachi'], chapters: 4 },\n  { shortName: 'MAT', fullNames: ['Matthew'], chapters: 28 },\n  { shortName: 'MRK', fullNames: ['Mark'], chapters: 16 },\n  { shortName: 'LUK', fullNames: ['Luke'], chapters: 24 },\n  { shortName: 'JHN', fullNames: ['John'], chapters: 21 },\n  { shortName: 'ACT', fullNames: ['Acts'], chapters: 28 },\n  { shortName: 'ROM', fullNames: ['Romans'], chapters: 16 },\n  { shortName: '1CO', fullNames: ['1 Corinthians'], chapters: 16 },\n  { shortName: '2CO', fullNames: ['2 Corinthians'], chapters: 13 },\n  { shortName: 'GAL', fullNames: ['Galatians'], chapters: 6 },\n  { shortName: 'EPH', fullNames: ['Ephesians'], chapters: 6 },\n  { shortName: 'PHP', fullNames: ['Philippians'], chapters: 4 },\n  { shortName: 'COL', fullNames: ['Colossians'], chapters: 4 },\n  { shortName: '1TH', fullNames: ['1 Thessalonians'], chapters: 5 },\n  { shortName: '2TH', fullNames: ['2 Thessalonians'], chapters: 3 },\n  { shortName: '1TI', fullNames: ['1 Timothy'], chapters: 6 },\n  { shortName: '2TI', fullNames: ['2 Timothy'], chapters: 4 },\n  { shortName: 'TIT', fullNames: ['Titus'], chapters: 3 },\n  { shortName: 'PHM', fullNames: ['Philemon'], chapters: 1 },\n  { shortName: 'HEB', fullNames: ['Hebrews'], chapters: 13 },\n  { shortName: 'JAS', fullNames: ['James'], chapters: 5 },\n  { shortName: '1PE', fullNames: ['1 Peter'], chapters: 5 },\n  { shortName: '2PE', fullNames: ['2 Peter'], chapters: 3 },\n  { shortName: '1JN', fullNames: ['1 John'], chapters: 5 },\n  { shortName: '2JN', fullNames: ['2 John'], chapters: 1 },\n  { shortName: '3JN', fullNames: ['3 John'], chapters: 1 },\n  { shortName: 'JUD', fullNames: ['Jude'], chapters: 1 },\n  { shortName: 'REV', fullNames: ['Revelation'], chapters: 22 },\n];\n\n/** The first book number */\nexport const FIRST_SCR_BOOK_NUM = 1;\n/** The last book number */\nexport const LAST_SCR_BOOK_NUM = scrBookData.length - 1;\n/** The first chapter number */\nexport const FIRST_SCR_CHAPTER_NUM = 1;\n/** The first verse number */\nexport const FIRST_SCR_VERSE_NUM = 1;\n\n/** The default Scripture reference, representing the first chapter and verse of the first book. */\nexport const defaultScrRef: SerializedVerseRef = {\n  book: 'GEN',\n  chapterNum: 1,\n  verseNum: 1,\n};\n\n/**\n * Retrieves the number of chapters for a given book number.\n *\n * @param bookNum The number representing the book.\n * @returns The number of chapters in the book, or -1 if the book number is invalid.\n */\nexport const getChaptersForBook = (bookNum: number): number => {\n  return scrBookData[bookNum]?.chapters ?? -1;\n};\n\n/**\n * Adjusts the book of a Scripture reference by a specified offset.\n *\n * @param scrRef The Scripture reference whose book is to be adjusted.\n * @param offset The number of books to offset the current book by. Positive values move forward,\n *   negative values move backward.\n * @returns A new Scripture reference with the adjusted book. The chapter and verse numbers are\n *   reset to 1. If the resulting book number exceeds the bounds of available books, it is clamped\n *   to the nearest valid book.\n */\nexport const offsetBook = (scrRef: SerializedVerseRef, offset: number): SerializedVerseRef => ({\n  book: Canon.bookNumberToId(\n    Math.max(\n      FIRST_SCR_BOOK_NUM,\n      Math.min(Canon.bookIdToNumber(scrRef.book) + offset, LAST_SCR_BOOK_NUM),\n    ),\n  ),\n  chapterNum: 1,\n  verseNum: 1,\n});\n\n/**\n * Adjusts the chapter of a Scripture reference by a specified offset.\n *\n * @param scrRef The Scripture reference whose chapter is to be adjusted.\n * @param offset The number of chapters to offset the current chapter by. Positive values move\n *   forward, negative values move backward.\n * @returns A new Scripture reference with the adjusted chapter. The verse number is reset to 1. The\n *   chapter number is clamped to stay within valid bounds for the book.\n */\nexport const offsetChapter = (scrRef: SerializedVerseRef, offset: number): SerializedVerseRef => ({\n  ...scrRef,\n  chapterNum: Math.min(\n    Math.max(FIRST_SCR_CHAPTER_NUM, scrRef.chapterNum + offset),\n    getChaptersForBook(Canon.bookIdToNumber(scrRef.book)),\n  ),\n  verseNum: 1,\n});\n\n/**\n * Adjusts the verse of a Scripture reference by a specified offset.\n *\n * @param scrRef The Scripture reference whose verse is to be adjusted.\n * @param offset The number of verses to offset the current verse by. Positive values move forward,\n *   negative values move backward.\n * @returns A new Scripture reference with the adjusted verse. The verse number is clamped to stay\n *   within valid bounds for the chapter.\n */\nexport const offsetVerse = (scrRef: SerializedVerseRef, offset: number): SerializedVerseRef => ({\n  ...scrRef,\n  verseNum: Math.max(FIRST_SCR_VERSE_NUM, scrRef.verseNum + offset),\n});\n\n/**\n * https://github.com/ubsicap/Paratext/blob/master/ParatextData/SILScriptureExtensions.cs#L72\n *\n * Convert book number to a localized Id (a short description of the book). This should be used\n * whenever a book ID (short code) is shown to the user. It is primarily needed for people who do\n * not read Roman script well and need to have books identified in a alternate script (e.g. Chinese\n * or Russian)\n *\n * @param bookNumber\n * @param localizationLanguage In BCP 47 format\n * @param getLocalizedString Function that provides the localized versions of the book ids and names\n *   asynchronously.\n * @returns\n */\nexport async function getLocalizedIdFromBookNumber(\n  bookNumber: number,\n  localizationLanguage: string,\n  getLocalizedString: (item: {\n    localizeKey: string;\n    languagesToSearch?: string[];\n  }) => Promise<string>,\n) {\n  const id = Canon.bookNumberToId(bookNumber);\n\n  if (!startsWith(Intl.getCanonicalLocales(localizationLanguage)[0], 'zh'))\n    return getLocalizedString({\n      localizeKey: `LocalizedId.${id}`,\n      languagesToSearch: [localizationLanguage],\n    });\n\n  // For Chinese the normal book name is already fairly short.\n  const bookName = await getLocalizedString({\n    localizeKey: `Book.${id}`,\n    languagesToSearch: [localizationLanguage],\n  });\n  const parts = split(bookName, '-');\n  // some entries had a second name inside ideographic parenthesis\n  const parts2 = split(parts[0], '\\xff08');\n  const retVal = parts2[0].trim();\n  return retVal;\n}\n\n/**\n * Get the Scripture reference as an easily comparable/sortable integer, without considering the\n * verse.\n *\n * @param scrRef The Scripture reference.\n * @returns An integer where the first three digits represent the book, the next three represent the\n *   chapter and the last three represent the verse.\n */\nexport function scrRefToBBBCCC(scrRef: SerializedVerseRef): number {\n  return new VerseRef(Canon.bookIdToNumber(scrRef.book), scrRef.chapterNum, scrRef.verseNum).BBBCCC;\n}\n\n/**\n * Get the Scripture reference as an easily comparable/sortable integer.\n *\n * @param scrRef The Scripture reference.\n * @returns An integer where the first three digits represent the book, the next three represent the\n *   chapter and the last three represent the verse.\n */\nexport function scrRefToBBBCCCVVV(scrRef: SerializedVerseRef): number {\n  return new VerseRef(Canon.bookIdToNumber(scrRef.book), scrRef.chapterNum, scrRef.verseNum)\n    .BBBCCCVVV;\n}\n\n/**\n * Compares two Scripture references canonically.\n *\n * @param scrRef1 The first Scripture reference to compare.\n * @param scrRef2 The second Scripture reference to compare.\n * @returns A number indicating the result of the comparison: - Negative value if scrRef1 precedes\n *   scrRef2 in sorting order. - Zero if scrRef1 and scrRef2 are equivalent in sorting order. -\n *   Positive value if scrRef1 follows scrRef2 in sorting order.\n */\nexport function compareScrRefs(scrRef1: SerializedVerseRef, scrRef2: SerializedVerseRef): number {\n  // TODO: consider edge cases for invalid references (current implementation should suffice for\n  // all but the most extreme cases)\n  return scrRefToBBBCCCVVV(scrRef1) - scrRefToBBBCCCVVV(scrRef2);\n}\n\n/** Get the localized string key for a given scroll group Id (or no scroll group if `undefined`) */\nexport function getLocalizeKeyForScrollGroupId(\n  scrollGroupId: ScrollGroupId | undefined | 'undefined',\n): LocalizeKey {\n  return `%scrollGroup_${scrollGroupId}%`;\n}\n\n/**\n * Gets a list of localized string keys for provided scroll group Ids. Uses\n * {@link getLocalizeKeyForScrollGroupId} internally\n *\n * @example\n *\n * ```typescript\n * getLocalizeKeysForScrollGroupIds([undefined, 0, 1, 2, 3, 4]);\n * // Gives localized string keys for the provided scroll group ids in an array\n * ```\n *\n * @param scrollGroupIds Scroll group ids to include\n * @returns List of localized string keys for scroll group Ids\n */\nexport function getLocalizeKeysForScrollGroupIds(scrollGroupIds: (ScrollGroupId | undefined)[]) {\n  return scrollGroupIds.map((scrollGroupId) => getLocalizeKeyForScrollGroupId(scrollGroupId));\n}\n\n/**\n * Get the formatted or provided book name of a Scripture reference\n *\n * @param scrRef The Scripture reference to format.\n * @param optionOrLocalizedBookName Either 'id' (the default) to format using the \"standard\" (as\n *   defined by SIL/UBS) 3-letter book ID, 'English' to format using the English book name spelled\n *   out, or some other string (e.g., a localized book name, vernacular abbreviation, FCBH book id,\n *   etc.) to use.\n * @returns The formatted or provided book name of a Scripture reference\n */\nexport function getBookNameFromVerseRef(\n  scrRef: SerializedVerseRef,\n  optionOrLocalizedBookName?: 'id' | 'English' | string,\n): string {\n  switch (optionOrLocalizedBookName) {\n    case 'English':\n      return Canon.bookIdToEnglishName(scrRef.book);\n    case 'id':\n    case undefined:\n      return scrRef.book;\n    default:\n      return optionOrLocalizedBookName;\n  }\n}\n\n/** Formatting options for formatScrRef */\nexport type FormatScrRefOptions = {\n  /**\n   * Either 'id' (the default) to format using the \"standard\" (as defined by SIL/UBS) 3-letter book\n   * ID, 'English' to format using the English book name spelled out, or some other string (e.g., a\n   * localized book name, vernacular abbreviation, FCBH book id, etc.) to use.\n   */\n  optionOrLocalizedBookName?: 'id' | 'English' | string;\n  /** The character(s) used to separate the chapter number from the verse number. */\n  chapterVerseSeparator?: string;\n  /** The character(s) used to separate the book from the chapter number. */\n  bookChapterSeparator?: string;\n};\n\n/**\n * Formats a Scripture reference\n *\n * @param scrRef The Scripture reference to format.\n * @param formatScrRefOptions Optional FormatScrRefOptions to format the scripture reference.\n *   Default chapterVerseSepator is a colon (:). Default chapterVerseSeparator is a single space.\n * @returns The formatted reference.\n */\nexport function formatScrRefWithOptions(\n  scrRef: SerializedVerseRef,\n  formatScrRefOptions?: FormatScrRefOptions,\n) {\n  const bookName = getBookNameFromVerseRef(scrRef, formatScrRefOptions?.optionOrLocalizedBookName);\n  const bookChapterSeparator = formatScrRefOptions?.bookChapterSeparator ?? ' ';\n  const chapterVerseSeparator = formatScrRefOptions?.chapterVerseSeparator ?? ':';\n  return `${bookName}${bookChapterSeparator}${scrRef.chapterNum}${chapterVerseSeparator}${scrRef.verseNum}`;\n}\n\n/**\n * Formats a Scripture reference\n *\n * @param scrRef The Scripture reference to format.\n * @param optionOrLocalizedBookName Either 'id' (the default) to format using the \"standard\" (as\n *   defined by SIL/UBS) 3-letter book ID, 'English' to format using the English book name spelled\n *   out, or some other string (e.g., a localized book name, vernacular abbreviation, FCBH book id,\n *   etc.) to use.\n * @param chapterVerseSeparator The character(s) used to separate the chapter number from the verse\n *   number. Default is a colon (:).\n * @param bookChapterSeparator The character(s) used to separate the book from the chapter number.\n *   Default is a single space.\n * @returns The formatted reference.\n */\nexport function formatScrRef(\n  scrRef: SerializedVerseRef,\n  optionOrLocalizedBookName?: 'id' | 'English' | string,\n  chapterVerseSeparator?: string,\n  bookChapterSeparator?: string,\n): string {\n  return formatScrRefWithOptions(scrRef, {\n    optionOrLocalizedBookName,\n    chapterVerseSeparator,\n    bookChapterSeparator,\n  });\n}\n\n/**\n * Formats chapter and/or verse number of a Scripture reference. Negative chapter or verse results\n * in omitting that part.\n *\n * @param scrRef The Scripture reference to format.\n * @param chapterVerseSeparator The characters(s) used to separate the chapter number from the verse\n *   number. Default is a colon (:).\n * @returns The formatted chapter and/or verse.\n */\nexport function formatChapterAndVerseWithOptionalParts(\n  scrRef: SerializedVerseRef,\n  chapterVerseSeparator?: string,\n): string {\n  const formattedVerse =\n    scrRef.verseNum < 0 ? '' : `${chapterVerseSeparator ?? ':'}${scrRef.verseNum}`;\n  return scrRef.chapterNum < 0 ? '' : `${scrRef.chapterNum}${formattedVerse}`;\n}\n\n/**\n * Formats a Scripture reference. Empty book, negative chapter or verse results in omitting that\n * part.\n *\n * @param scrRef The Scripture reference to format.\n * @param FormatScrRefOptions Optional FormatScrRefOptions to format the scripture reference\n * @returns The formatted reference. This may be only parts like only book or only chapter or only\n *   verse or a combination.\n */\nexport function formatScrRefWithOptionalParts(\n  scrRef: SerializedVerseRef,\n  options?: FormatScrRefOptions,\n): string {\n  const book = getBookNameFromVerseRef(scrRef, options?.optionOrLocalizedBookName);\n  const chapterAndVerse = formatChapterAndVerseWithOptionalParts(\n    scrRef,\n    options?.chapterVerseSeparator,\n  );\n  return `${book}${book && chapterAndVerse ? (options?.bookChapterSeparator ?? ' ') : ''}${chapterAndVerse}`;\n}\n\n/**\n * Options to format a scripture reference or range\n *\n * Extends FormatScrRefOptions\n */\nexport type FormatScrRefRangeOptions = FormatScrRefOptions & {\n  /** See optionOrLocalizedBookName */\n  endRefOptionOrLocalizedBookName?: 'id' | 'English' | string;\n  /** The character(s) used to separate the two references. */\n  rangeSeparator?: string;\n  /** Wether or not to repeat the book name in the end reference if it is the same. Default false. */\n  repeatBookName?: boolean;\n};\n\n/**\n * Formats a range of two Scripture references. Empty book, negative chapter or verse results in\n * omitting that part.\n *\n * @param startScrRef The Scripture reference to format at the start of the range.\n * @param endScrRef The Scripture reference to format at the end of the range.\n * @param options Optional FormatScrRefRangeOptions to format the scripture reference range. Default\n *   range separator is a hyphen surrounded by two spaces. Default book name options for the end ref\n *   are the book name options for the start ref. The book name is not repeated by default.\n * @returns The formatted range.\n */\nexport function formatScrRefRange(\n  startScrRef: SerializedVerseRef,\n  endScrRef: SerializedVerseRef,\n  options?: FormatScrRefRangeOptions,\n): string {\n  const formattedStartRef = formatScrRefWithOptionalParts(startScrRef, options);\n  if (compareScrRefs(startScrRef, endScrRef) === 0) return formattedStartRef;\n\n  const endRefBookName =\n    startScrRef.book === endScrRef.book && !options?.repeatBookName\n      ? ''\n      : (options?.endRefOptionOrLocalizedBookName ?? options?.optionOrLocalizedBookName);\n  const formattedEndRef = formatScrRefWithOptionalParts(endScrRef, {\n    ...options,\n    optionOrLocalizedBookName: endRefBookName,\n  });\n\n  return `${formattedStartRef}${options?.rangeSeparator ?? ' - '}${formattedEndRef}`;\n}\n\n/**\n * Represents the major sections of the Bible and extra materials. Used for grouping and filtering\n * books in the book selector.\n */\nexport enum Section {\n  /** Old Testament books (Genesis through Malachi) */\n  OT = 'OT',\n  /** New Testament books (Matthew through Revelation) */\n  NT = 'NT',\n  /** Deuterocanonical books (e.g. Tobit, Judith, 1-2 Maccabees) */\n  DC = 'DC',\n  /** Additional materials not part of the biblical canon (e.g. XXA, XXB etc.) */\n  Extra = 'Extra',\n}\n\n/**\n * Determines which section a book belongs to based on its ID\n *\n * @param bookId The ID of the book (e.g., 'GEN', 'MAT')\n * @returns The section (OT, NT, DC, or Extra) that the book belongs to\n * @throws Error if the book ID is not recognized or cannot be categorized\n */\nexport const getSectionForBook = (bookId: string): Section => {\n  if (Canon.isBookOT(bookId)) return Section.OT;\n  if (Canon.isBookNT(bookId)) return Section.NT;\n  if (Canon.isBookDC(bookId)) return Section.DC;\n  if (Canon.isExtraMaterial(bookId)) return Section.Extra;\n\n  throw new Error(`Unknown section for book: ${bookId}`);\n};\n\n// #region white space functions\n\nconst nonSemanticWhiteSpaceRegex =\n  // Using unicode control characters to be very explicit about which characters we are using.\n  // The first 6 characters are the control characters \\f\\n\\r\\t\\v.\n  // eslint-disable-next-line no-control-regex\n  /^[\\u000C\\u000A\\u000D\\u0009\\u000B\\u0020\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u200B\\u0085]+$/;\n/**\n * Determines whether a string contains one or more \"non-meaningful\" white space characters\n * according to `ParatextData.dll` and no other characters.\n *\n * \"Non-meaningful\" white space according to `ParatextData.dll` is white space (according to\n * {@link isWhiteSpace}) other than IDEOGRAPHIC SPACE (U+3000) and also includes ZWSP (U+200B)\n *\n * This function is a direct translation of `UsfmToken.IsNonSemanticWhiteSpace` from\n * `ParatextData.dll`\n *\n * @param ch Single character or a string of characters\n * @returns `true` if the string consists of one or more \"non-meaningful\" white space characters and\n *   no other characters, `false` otherwise\n */\nfunction isNonSemanticWhiteSpace(ch: string) {\n  return nonSemanticWhiteSpaceRegex.test(ch);\n}\n\n// Note Zero-width joiner is at the start because eslint thinks we're trying to test for joined\n// characters if it's in the middle. https://eslint.org/docs/latest/rules/no-misleading-character-class\nconst invisibleCharOrWhiteSpaceRegex =\n  /^[\\u200d\\u2003\\u2002\\u0020\\u00a0\\u202f\\u2009\\u200a\\u3000\\u200b\\u200c\\u2060\\u200e\\u200f]+$/;\n/**\n * Determines whether a string contains one or more Paratext-9-selectable invisible characters or\n * white space characters and no other characters.\n *\n * Paratext-9-selectable invisible characters or white space characters are characters listed in\n * [Paratext 9's \"Whitespace and invisible characters\n * drop-down\"](https://paratext.myjetbrains.com/youtrack/issue/PTX-23623) that the user can insert\n * into the text:\n *\n * ```ts\n * // Zero-width joiner, em space, en space, space, no-break space, narrow no-break space,\n * // thin space, hair space, ideographic space, zero-width space, zero-width non-joiner,\n * // word joiner, left-to-right mark, right-to-left mark\n * /^[\\u200d\\u2003\\u2002\\u0020\\u00a0\\u202f\\u2009\\u200a\\u3000\\u200b\\u200c\\u2060\\u200e\\u200f]+$/.test(\n *   ch,\n * );\n * ```\n *\n * Note: more white space characters are supported in Paratext 9 but are not listed in this\n * dropdown. See {@link isWhiteSpace} for more information.\n *\n * This function is a direct translation of `CharExtensions.IsInvisibleCharOrWhitespace` from\n * `ParatextData.dll`\n *\n * @param ch Single character or a string of characters\n * @returns `true` if the string consists of one or more Paratext-9-selectable invisible characters\n *   or white space characters and no other characters, `false` otherwise\n */\nfunction isParatextSelectableInvisibleCharOrWhiteSpace(ch: string) {\n  return invisibleCharOrWhiteSpaceRegex.test(ch);\n}\n\n/**\n * Converts all control characters, carriage returns, and tabs into spaces and then strips duplicate\n * spaces.\n *\n * This is mainly intended for use with individual Scripture strings in USFM, USX, USJ, etc. format.\n * It is not intended to implement the [USFM white space definition or reduction\n * rules](https://docs.usfm.bible/usfm/3.1/whitespace.html) but strictly follows Paratext 9's white\n * space rules. It is generally best suited to normalizing spaces within a Scripture marker as it\n * removes all newlines.\n *\n * This function is a direct translation of `UsfmToken.RegularizeSpaces` from `ParatextData.dll`\n */\nexport function normalizeScriptureSpaces(str: string): string {\n  let result = '';\n  let lastCharWasSpace = false;\n  // Initialized to placeholder previous character\n  let prevCh = '\\0';\n  for (let i = 0; i < str.length; i += 1) {\n    const ch = str[i];\n    // Control characters, CR/LF, and TAB become spaces\n    if (ch.charCodeAt(0) < 32) {\n      if (!lastCharWasSpace) result += ' ';\n      lastCharWasSpace = true;\n    } else if (\n      !lastCharWasSpace &&\n      ch === ZWSP &&\n      i + 1 < str.length &&\n      isNonSemanticWhiteSpace(str[i + 1])\n    ) {\n      // ZWSP is redundant if followed by a space\n    } else if (isNonSemanticWhiteSpace(ch)) {\n      // Keep other kinds of spaces\n      if (!lastCharWasSpace) result += ch;\n      lastCharWasSpace = true;\n    } else if (isParatextSelectableInvisibleCharOrWhiteSpace(ch) && prevCh === ch) {\n      // If the char is a whitespace or invisible char that has not already been handled and is a\n      // duplicate, remove the duplicate\n    } else {\n      result += ch;\n      lastCharWasSpace = false;\n    }\n\n    prevCh = ch;\n  }\n\n  return result;\n}\n\n/**\n * Determines whether the array of marker contents is \"empty\" meaning it is undefined, is an empty\n * array, or has just `undefined` or `''` in it\n *\n * Paratext passed up \"\\va \\va*\" which had no content array coming in translated to USJ, but the\n * editor put a content array with an empty string. So this will help them be considered equal.\n */\nfunction isUsjContentEmpty(content: MarkerContent[] | undefined) {\n  if (!content) return true;\n  if (content.length === 0) return true;\n  return content.length === 1 && (content[0] === undefined || content[0] === '');\n}\n\n/**\n * Determines if the content object is the final child of a parent that is a block-level marker.\n *\n * We do not need to walk up the ancestors to the _closest_ block marker because spaces are\n * preserved at the end of in-line markers even at the end of a paragraph. We just need to know if\n * the parent is a block marker because space at the end of a block marker is not preserved.\n *\n * @param contentObject USJ document or marker to check\n * @param parent Parent object of `contentObject`. If `contentObject` is a USJ document, this should\n *   be `undefined`.\n * @returns `true` if `contentObject` is the final child of the closest block-level marker; `false`\n *   otherwise\n */\nfunction isAtEndOfBlockMarker(\n  contentObject: MarkerContent | Usj,\n  parent: MarkerObject | Usj | undefined,\n) {\n  if (!parent) return false;\n  // If the parent is not a block-level marker, the content object is not at the end of a block-level marker\n  if (!BLOCK_MARKER_TYPES.includes(parent.type)) return false;\n\n  if (!parent.content)\n    throw new Error(\n      `Parent ${JSON.stringify(parent)} of ${JSON.stringify(contentObject)} does not have a content array! This should not happen!`,\n    );\n  // If the content object is not the last in its parent, it is not at the end of a block-level marker\n  if (contentObject !== parent.content[parent.content.length - 1]) return false;\n\n  return true;\n}\n\n/**\n * Determines if the USJ documents or markers (and all contents) are equivalent after regularizing\n * spaces according to the way `ParatextData.dll` does.\n *\n * Note that this will not work properly if there ever exist any properties of USJ document or USJ\n * markers other than `content` that are complex objects like arrays or objects as the properties\n * are shallow equaled.\n *\n * @param a First USJ document or marker to compare\n * @param aParent Parent object of `a`. If `a` is a USJ document, this should be `undefined`.\n * @param b Second USJ document or marker to compare\n * @param bParent Parent object of `b`. If `b` is a USJ document, this should be `undefined`.\n */\nfunction areUsjContentsEqualExceptWhitespaceInternal(\n  a: MarkerContent | Usj | undefined,\n  aParent: MarkerObject | Usj | undefined,\n  b: MarkerContent | Usj | undefined,\n  bParent: MarkerObject | Usj | undefined,\n) {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n\n  const aIsString = isString(a);\n  const bIsString = isString(b);\n  if (aIsString && bIsString) {\n    const aNormalized = normalizeScriptureSpaces(a);\n    const bNormalized = normalizeScriptureSpaces(b);\n    // Check to see if their regularized forms are equal. If so, they're equal. If not, they may still\n    // be equal if they are at the end of a block-level marker and the only difference is space at the end.\n    // If at the end of a block-level marker with space at the end, take off the final space and compare again\n    if (aNormalized !== bNormalized) {\n      // If neither ends in whitespace, they are not equal\n      if (!isWhiteSpace(at(aNormalized, -1) ?? '') && !isWhiteSpace(at(bNormalized, -1) ?? ''))\n        return false;\n\n      // If either is not at the end of a block-level marker, they are not equal\n      if (!isAtEndOfBlockMarker(a, aParent)) return false;\n      if (!isAtEndOfBlockMarker(b, bParent)) return false;\n\n      // Trim the end of each string\n      let aTrimmed = aNormalized;\n      while (isWhiteSpace(at(aTrimmed, -1) ?? '')) aTrimmed = slice(aTrimmed, 0, -1);\n      let bTrimmed = bNormalized;\n      while (isWhiteSpace(at(bTrimmed, -1) ?? '')) bTrimmed = slice(bTrimmed, 0, -1);\n      // If they are not equal after trimming, they are not equal\n      if (aTrimmed !== bTrimmed) return false;\n    }\n  } else if (!aIsString && !bIsString) {\n    // We have determined they are not strings, so they must be objects with various simple properties and possibly a `content` array\n    const aObject: MarkerObject | Usj = a;\n    const bObject: MarkerObject | Usj = b;\n    // Check if all properties are present and equal. We will check `content` separately\n    // Seems Object.keys doesn't support proper key typing? Asserting to the key types\n    // eslint-disable-next-line no-type-assertion/no-type-assertion\n    const aKeys = Object.keys(aObject).filter(\n      (key) => key !== 'content',\n    ) as (keyof typeof aObject)[];\n    if (aKeys.length !== Object.keys(bObject).filter((key) => key !== 'content').length)\n      return false;\n    if (aKeys.some((key) => !(key in bObject) || aObject[key] !== bObject[key])) return false;\n\n    // Check that both `content`s are equal\n    const isAContentEmpty = isUsjContentEmpty(aObject.content);\n    const isBContentEmpty = isUsjContentEmpty(bObject.content);\n    // If one is empty and the other is not, they are not equal\n    if (isAContentEmpty !== isBContentEmpty) return false;\n    // If both are empty, they are equal. If neither is empty, do more testing\n    if (!isAContentEmpty && !isBContentEmpty) {\n      // Although TypeScript doesn't realize `!isUsjContentEmpty(a)` means a is an array, we know\n      // they are both arrays, so we can access the content with a bang.\n      /* eslint-disable no-type-assertion/no-type-assertion */\n      let aContent: MarkerContent[] = aObject.content!;\n      let bContent: MarkerContent[] = bObject.content!;\n      /* eslint-enable no-type-assertion/no-type-assertion */\n\n      // If either of the two contents is block-level and has an extra whitespace string at the end, remove it\n      const aLast = aContent[aContent.length - 1];\n      if (BLOCK_MARKER_TYPES.includes(aObject.type) && isString(aLast) && isWhiteSpace(aLast))\n        aContent = aContent.slice(0, -1);\n\n      // If either of the two contents is block-level and has an extra whitespace string at the end, remove it\n      const bLast = bContent[bContent.length - 1];\n      if (BLOCK_MARKER_TYPES.includes(bObject.type) && isString(bLast) && isWhiteSpace(bLast))\n        bContent = bContent.slice(0, -1);\n\n      if (aContent.length !== bContent.length) return false;\n      for (let i = 0; i < aContent.length; i += 1) {\n        if (\n          !areUsjContentsEqualExceptWhitespaceInternal(aContent[i], aObject, bContent[i], bObject)\n        )\n          return false;\n      }\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Determines if the USJ documents or markers (and all contents) are equivalent after regularizing\n * spaces according to the way `ParatextData.dll` does.\n *\n * Note that this will not work properly if there ever exist any properties of USJ document or USJ\n * markers other than `content` that are complex objects like arrays or objects as the properties\n * are shallow equaled.\n */\nexport function areUsjContentsEqualExceptWhitespace(a: Usj | undefined, b: Usj | undefined) {\n  return areUsjContentsEqualExceptWhitespaceInternal(a, undefined, b, undefined);\n}\n\n// #endregion\n","/** Function to run to dispose of something. Returns true if successfully unsubscribed */\nexport type Unsubscriber = () => boolean;\n\n/**\n * Returns an Unsubscriber function that combines all the unsubscribers passed in.\n *\n * @param unsubscribers All unsubscribers to aggregate into one unsubscriber\n * @returns Function that unsubscribes from all passed in unsubscribers when run\n */\nexport const aggregateUnsubscribers = (unsubscribers: Unsubscriber[]): Unsubscriber => {\n  return (...args) => {\n    // Run the unsubscriber for each handler\n    const unsubs = unsubscribers.map((unsubscriber) => unsubscriber(...args));\n\n    // If all the unsubscribers resolve to truthiness, we succeed\n    return unsubs.every((success) => success);\n  };\n};\n\n/**\n * Function to run to dispose of something that runs asynchronously. The promise resolves to true if\n * successfully unsubscribed\n */\nexport type UnsubscriberAsync = () => Promise<boolean>;\n\n/**\n * Returns an UnsubscriberAsync function that combines all the unsubscribers passed in.\n *\n * @param unsubscribers - All unsubscribers to aggregate into one unsubscriber.\n * @returns Function that unsubscribes from all passed in unsubscribers when run\n */\nexport const aggregateUnsubscriberAsyncs = (\n  unsubscribers: (UnsubscriberAsync | Unsubscriber)[],\n): UnsubscriberAsync => {\n  return async (...args) => {\n    // Run the unsubscriber for each handler\n    const unsubPromises = unsubscribers.map(async (unsubscriber) => unsubscriber(...args));\n\n    // If all the unsubscribers resolve to truthiness, we succeed\n    return (await Promise.all(unsubPromises)).every((success) => success);\n  };\n};\n","import {\n  Usj,\n  type MarkerContent,\n  type MarkerObject,\n} from '@eten-tech-foundation/scripture-utilities';\nimport { SerializedVerseRef } from '@sillsdev/scripture';\nimport { MarkersMap } from './markers-maps/markers-map-3.0.model';\n\n/** USJ content node type for a book */\nexport const BOOK_TYPE = 'book';\n\n/** USJ content node type for a chapter */\nexport const CHAPTER_TYPE = 'chapter';\n\n/** USJ content node type for a verse */\nexport const VERSE_TYPE = 'verse';\n\n/** 3-character code that indicates there is no known book */\nexport const NO_BOOK_ID = '***';\n\n/**\n * Represents a book, chapter, verse, and offset\n *\n * @deprecated 23 October 2025. Use {@link UsfmVerseLocation} or {@link UsfmVerseRefVerseLocation}\n *   instead.\n */\nexport type VerseRefOffset = {\n  verseRef: SerializedVerseRef;\n  offset: number;\n};\n\n// #region Serializable USFM locations\n\n/**\n * A verse ref and an offset within that verse in USFM space that point to a specific location in\n * USFM. If only a verse ref is provided, the offset is assumed to be 0.\n *\n * The USJ representation of the positions represented by this type are {@link UsjLocation}. Both are\n * absolute verse reference locations.\n *\n * {@link UsjDocumentLocation} also represents positions of this type, but those locations are\n * relative to a specific USJ document rather than being absolute verse reference locations like\n * this type. The closest equivalent concept in USFM to {@link UsjDocumentLocation} is a string\n * character index in a USFM document; such an index is relative to a specific USFM document rather\n * than indicating an absolute position in a Scripture text.\n *\n * To see many examples of the same point represented by both USFM and USJ locations, go to\n * https://github.com/paranext/paranext-core/tree/main/lib/platform-bible-utils/src/scripture/usj-reader-writer-test-data/testUSFM-2SA-1-locations.ts\n *\n * Note: some forms of this type are deprecated and will be removed eventually; see\n * {@link UsfmScrRefVerseLocation} for details.\n */\nexport type UsfmVerseLocation =\n  | UsfmVerseRefVerseLocation\n  | SerializedVerseRef\n  | UsfmScrRefVerseLocation;\n\n/**\n * A verse ref and an offset within that verse in USFM space that point to a specific location in\n * USFM\n */\nexport type UsfmVerseRefVerseLocation = {\n  /** Verse reference indicating which verse the location is in */\n  verseRef: SerializedVerseRef;\n  /**\n   * Offset to apply to start of the verse indicated by `verseRef`.\n   *\n   * If the verse is 0, offset 0 is the start of the chapter. If the verse is greater than 0, offset\n   * 0 is the backslash on the verse marker.\n   *\n   * If not provided, defaults to 0.\n   */\n  offset?: number;\n};\n\n/**\n * A verse ref and an offset within that verse in USFM space that point to a specific location in\n * USFM. This uses `scrRef` instead of `verseRef` for backwards compatibility.\n *\n * @deprecated 13 November 2025. Use {@link UsfmVerseLocation} instead.\n */\nexport type UsfmScrRefVerseLocation = {\n  /** Verse reference indicating which verse the location is in */\n  scrRef: SerializedVerseRef;\n  /**\n   * Offset to apply to start of the verse indicated by `verseRef`.\n   *\n   * If the verse is 0, offset 0 is the start of the chapter. If the verse is greater than 0, offset\n   * 0 is the backslash on the verse marker.\n   *\n   * If not provided, defaults to 0.\n   */\n  offset?: number;\n};\n\n// #endregion Serializable USFM locations\n\n// #region Serializable absolute USJ locations\n\n/**\n * A verse ref and a location in USJ space that point to a specific location in USJ. The location in\n * USJ space should be interpreted as starting from either the start of the book or the chapter\n * depending on the type of location used.\n *\n * The USFM representation of the positions represented by this type are {@link UsfmVerseLocation}.\n *\n * The locations in USJ space are specified as {@link UsjDocumentLocation}s, which, on their own, are\n * relative to a specific USJ document. However, the other information in this type specifies which\n * USJ document the document location is relative to, meaning this location is an absolute verse\n * reference location.\n *\n * The JSONPaths in these USJ-based locations are specified relative to the following USJ documents:\n *\n * - {@link UsjBookLocation} - a USJ document that contains the entire specified book. The first\n *   content entry of the top-level `USJ` marker is the `id` marker of the book.\n * - {@link UsjChapterLocation} - a USJ document that contains only the specified chapter in the\n *   specified book. If the chapter number is 1, the first content entry of the top-level `USJ`\n *   marker is the `id` marker of the book because the intro content before chapter 1 is part of\n *   chapter 1. If the chapter number is greater than 1, the first content entry of the top-level\n *   `USJ` marker is the `c` marker of the chapter.\n *\n * This type intends to represent USFM positions ({@link UsfmVerseLocation}) in USJ space. However,\n * there are some USFM positions that are not currently representable with these types; see\n * {@link UsjDocumentLocation} for more information.\n *\n * You can specify a particular kind of `UsjDocumentLocation` in the generic type\n * `TDocumentLocation`, and that will narrow `documentLocation` to that specific kind of location.\n */\nexport type UsjLocation<TDocumentLocation extends UsjDocumentLocation = UsjDocumentLocation> =\n  | UsjChapterLocation<TDocumentLocation>\n  | UsjBookLocation<TDocumentLocation>;\n\n/**\n * A verse ref and a location in USJ space that point to a specific location in USJ. The location in\n * USJ space should be interpreted as starting from the start of the book specified.\n *\n * The USFM representation of the positions represented by this type are {@link UsfmVerseLocation}.\n *\n * The locations in USJ space are specified as {@link UsjDocumentLocation}s, which, on their own, are\n * relative to a specific USJ document. However, the other information in this type specifies which\n * USJ document the document location is relative to, meaning this location is an absolute verse\n * reference location.\n *\n * The JSONPaths in these USJ-based locations are specified relative to the USJ document that\n * contains the entire specified book. The first content entry of the top-level `USJ` marker is the\n * `id` marker of the book.\n *\n * This type intends to represent USFM positions ({@link UsfmVerseLocation}) in USJ space. However,\n * there are some USFM positions that are not currently representable with these types; see\n * {@link UsjDocumentLocation} for more information.\n *\n * You can specify a particular kind of `UsjDocumentLocation` in the generic type\n * `TDocumentLocation`, and that will narrow `documentLocation` to that specific kind of location.\n */\nexport type UsjBookLocation<TDocumentLocation extends UsjDocumentLocation = UsjDocumentLocation> =\n  | UsjVerseRefBookLocation<TDocumentLocation>\n  | UsjFlatBookLocation<TDocumentLocation>;\n\n/**\n * A verse ref and a location in USJ space that point to a specific location in USJ. The location in\n * USJ space should be interpreted as starting from the start of the chapter specified.\n *\n * The USFM representation of the positions represented by this type are {@link UsfmVerseLocation}.\n *\n * The locations in USJ space are specified as {@link UsjDocumentLocation}s, which, on their own, are\n * relative to a specific USJ document. However, the other information in this type specifies which\n * USJ document the document location is relative to, meaning this location is an absolute verse\n * reference location.\n *\n * The JSONPaths in these USJ-based locations are specified relative to the USJ document that\n * contains only the specified chapter in the specified book. If the chapter number is 1, the first\n * content entry of the top-level `USJ` marker is the `id` marker of the book because the intro\n * content before chapter 1 is part of chapter 1. If the chapter number is greater than 1, the first\n * content entry of the top-level `USJ` marker is the `c` marker of the chapter.\n *\n * This type intends to represent USFM positions ({@link UsfmVerseLocation}) in USJ space. However,\n * there are some USFM positions that are not currently representable with these types; see\n * {@link UsjDocumentLocation} for more information.\n *\n * You can specify a particular kind of `UsjDocumentLocation` in the generic type\n * `TDocumentLocation`, and that will narrow `documentLocation` to that specific kind of location.\n *\n * Note: some forms of this type are deprecated and will be removed eventually; see\n * {@link UsjFlatTextChapterLocation} for details. Also note that {@link UsjFlatTextChapterLocation}\n * can only be a marker- or text-based location and will _not_ follow the generic type specified as\n * `TDocumentLocation`.\n */\nexport type UsjChapterLocation<\n  TDocumentLocation extends UsjDocumentLocation = UsjDocumentLocation,\n> =\n  | UsjVerseRefChapterLocation<TDocumentLocation>\n  | UsjFlatChapterLocation<TDocumentLocation>\n  | UsjFlatTextChapterLocation;\n\n/**\n * A verse ref and a location in USJ space that point to a specific location in USJ. The location in\n * USJ space starts from the start of the book specified in the verse ref. The rest of the verse ref\n * is meaningless and can be disregarded.\n */\nexport type UsjVerseRefBookLocation<\n  TDocumentLocation extends UsjDocumentLocation = UsjDocumentLocation,\n> = {\n  /** Verse reference indicating which book the document location is in */\n  verseRef: SerializedVerseRef;\n  /**\n   * Specifies which part of the verse reference the document location is relative to:\n   *\n   * - `book` = document location is specified relative to the start of the book. The first content\n   *   entry of the top-level `USJ` marker is the `id` marker of the book\n   * - `chapter` = document location is specified relative to the start of the chapter in the\n   *   specified book. If the chapter number is 1, the first content entry of the top-level `USJ`\n   *   marker is the `id` marker of the book because the intro content before chapter 1 is part of\n   *   chapter 1. If the chapter number is greater than 1, the first content entry of the top-level\n   *   `USJ` marker is the `c` marker of the chapter\n   *\n   *   - Note: this is likely to be the case with peripheral books as well, but these books have\n   *       `periph` markers between `id` and chapters, so this may need to be revised when\n   *       peripheral books are more fully supported\n   *\n   * Defaults to 'chapter' (see {@link UsjVerseRefChapterLocation})\n   */\n  granularity: 'book';\n  /** USJ document location specifying where in the book the location is pointing to */\n  documentLocation: TDocumentLocation;\n};\n\n/**\n * A verse ref and a location in USJ space that point to a specific location in USJ. The location in\n * USJ space starts from the start of the chapter specified in the verse ref. The rest of the verse\n * ref is meaningless and can be disregarded.\n */\nexport type UsjVerseRefChapterLocation<\n  TDocumentLocation extends UsjDocumentLocation = UsjDocumentLocation,\n> = {\n  /** Verse reference indicating which chapter in which book the document location is in */\n  verseRef: SerializedVerseRef;\n  /**\n   * Specifies which part of the verse reference the document location is relative to:\n   *\n   * - `book` = document location is specified relative to the start of the book. The first content\n   *   entry of the top-level `USJ` marker is the `id` marker of the book\n   * - `chapter` = document location is specified relative to the start of the chapter in the\n   *   specified book. If the chapter number is 1, the first content entry of the top-level `USJ`\n   *   marker is the `id` marker of the book. If the chapter number is greater than 1, the first\n   *   content entry of the top-level `USJ` marker is the `c` marker of the chapter\n   *\n   *   - Note: this is likely to be the case with peripheral books as well, but these books have\n   *       `periph` markers between `id` and chapters, so this may need to be revised when\n   *       peripheral books are more fully supported\n   *\n   * Defaults to 'chapter' (can alternatively be 'book'; {@link UsjVerseRefBookLocation})\n   */\n  granularity?: 'chapter';\n  /** USJ document location specifying where in the chapter the location is pointing to */\n  documentLocation: TDocumentLocation;\n};\n\n/**\n * A book ID and a location in USJ space that point to a specific location in USJ. The location in\n * USJ space starts from the start of the book specified.\n */\nexport type UsjFlatBookLocation<\n  TDocumentLocation extends UsjDocumentLocation = UsjDocumentLocation,\n> = {\n  /** Book ID indicating which book the document location is in */\n  book: string;\n  /** USJ document location specifying where in the chapter the location is pointing to */\n  documentLocation: TDocumentLocation;\n};\n\n/**\n * A book ID, chapter number, and location in USJ space that point to a specific location in USJ.\n * The location in USJ space starts from the start of the chapter specified.\n */\nexport type UsjFlatChapterLocation<\n  TDocumentLocation extends UsjDocumentLocation = UsjDocumentLocation,\n> = UsjFlatBookLocation<TDocumentLocation> & {\n  /** Chapter number indicating which chapter the document location is in */\n  chapterNum: number;\n};\n\n/**\n * A book ID, chapter number, and text location or beginning of marker location in USJ space that\n * point to a specific location in USJ. The location in USJ space starts from the start of the\n * chapter specified. This can only represent the beginning of a marker or a location in the USJ\n * document's text content.\n *\n * @deprecated 13 November 2025. This type of location is not generic enough to support all\n *   positions we need to be able to represent in USJ space. Use other forms of\n *   {@link UsjChapterLocation} instead.\n */\nexport type UsjFlatTextChapterLocation = {\n  /** Book ID indicating which book the document location is in */\n  book: string;\n  /** Chapter number indicating which chapter the document location is in */\n  chapterNum: number;\n} & ((UsjMarkerLocation & { offset?: undefined }) | UsjTextContentLocation);\n\n// #endregion Serializable absolute USJ locations\n\n// #region Serializable USJ locations relative to a specific USJ document (chapter or book)\n\n/**\n * JSON path to a {@link MarkerObject}, {@link Usj}, or text content string in the current USJ\n * document.\n *\n * This could actually have more content clauses at the end, but TS types are limited\n */\nexport type ContentJsonPath =\n  | ''\n  | `$`\n  | `$.content[${number}]`\n  | `$.content[${number}].content[${number}]`\n  | `$.content[${number}].content[${number}].content[${number}]`\n  | `$.content[${number}].content[${number}].content[${number}].content[${number}]`;\n\n/**\n * JSON path to the `marker` or an attribute on a {@link MarkerObject} or {@link Usj} in the current\n * USJ document. Note that it seems you must use `['bracket notation']` rather than `.dot` notation\n * if there are symbols other than underscore in the property name\n *\n * This could actually have more content clauses at the end, but TS types are limited\n */\nexport type PropertyJsonPath =\n  | ''\n  | `$.${string}`\n  | `$['${string}']`\n  | `$.content[${number}].${string}`\n  | `$.content[${number}]['${string}']`\n  | `$.content[${number}].content[${number}].${string}`\n  | `$.content[${number}].content[${number}]['${string}']`\n  | `$.content[${number}].content[${number}].content[${number}].${string}`\n  | `$.content[${number}].content[${number}].content[${number}]['${string}']`\n  | `$.content[${number}].content[${number}].content[${number}].content[${number}].${string}`\n  | `$.content[${number}].content[${number}].content[${number}].content[${number}]['${string}']`;\n\n/**\n * A JSONPath query to a {@link MarkerContent}, {@link Usj}, or property within a USJ document and\n * additional information that point to a specific location in that USJ document.\n *\n * This type does not include a verse reference because the JSONPath is relative to a specific USJ\n * document; that USJ document may have a book, a chapter, or something else in it. Use\n * {@link UsjLocation} to specify which USJ document this location is relative to, making the\n * location an absolute verse reference location. The closest equivalent concept in USFM to this\n * relative document location is a string character index in a USFM document; such an index is\n * relative to a specific USFM document rather than indicating an absolute position in a Scripture\n * text.\n *\n * This type intends to represent USFM positions ({@link UsfmVerseLocation}) in USJ space. However,\n * there are some USFM positions that are not currently representable with these types:\n *\n * - The second slash in `optbreak`'s USFM representation `//` (literally not representable)\n * - Nested marker prefix on opening markers like `+` for character markers (literally not\n *   representable)\n * - The bar `|` that indicates the start of closing marker attributes (no official representation)\n * - The equals sign for closing marker attributes (no official representation)\n * - The quotes around closing marker attribute values (no official representation)\n * - The space between closing marker attributes (no official representation)\n *\n * Also note that the following types do not specify a concrete location that is actually in the USJ\n * document but represent a USFM location relative to the most similar thing in USJ that there is:\n *\n * - {@link UsjClosingMarkerLocation} - there are no distinct closing objects in JSON; there is a\n *   common syntax for closing every object, but it is only one character and is on every single\n *   object as opposed to USFM closing markers which are multiple characters long and are only\n *   sometimes present.\n * - {@link UsjAttributeKeyLocation} - when the attribute whose key is being pointed to is an attribute\n *   marker in USFM, the `keyOffset` does not apply to the USJ attribute name (e.g. `altnumber`) but\n *   to the USFM attribute marker name (e.g. `ca`).\n * - {@link UsjAttributeMarkerLocation} - attribute markers are just properties in JSON; they do not\n *   have their own object such that they would have an opening that can be pointed to in the JSON\n *   like they have their own opening in USFM.\n * - {@link UsjClosingAttributeMarkerLocation} - attribute markers are just properties in JSON, plus\n *   they are in the same situation as {@link UsjClosingMarkerLocation} as detailed above.\n *\n * To see many examples of the same point represented by both USFM and USJ locations, go to\n * https://github.com/paranext/paranext-core/tree/main/lib/platform-bible-utils/src/scripture/usj-reader-writer-test-data/testUSFM-2SA-1-locations.ts\n */\nexport type UsjDocumentLocation =\n  | UsjMarkerLocation\n  | UsjClosingMarkerLocation\n  | UsjTextContentLocation\n  | UsjPropertyValueLocation\n  | UsjAttributeKeyLocation\n  | UsjAttributeMarkerLocation\n  | UsjClosingAttributeMarkerLocation;\n\n/**\n * A JSONPath query to a {@link MarkerObject} or {@link Usj} node. Indicates the very beginning of\n * that marker (at the backslash in USFM).\n */\nexport type UsjMarkerLocation = {\n  /** JSON path to the marker object the location is pointing to. */\n  jsonPath: ContentJsonPath;\n};\n\n/**\n * A JSONPath query to a specific point in the closing marker representation of a\n * {@link MarkerObject} or {@link Usj} node.\n */\nexport type UsjClosingMarkerLocation = {\n  /**\n   * JSON path to the marker object whose closing marker the location is pointing to. The offset\n   * applies to the closing marker representation of that marker (for example, `\\nd*` in USFM).\n   */\n  jsonPath: ContentJsonPath;\n  /**\n   * The character index in the closing marker representation where this location is pointing. The\n   * location is at this offset within the closing marker representation.\n   */\n  closingMarkerOffset: number;\n};\n\n/**\n * A JSONPath query to a specific point in a text content string in a {@link MarkerObject.content}\n * array.\n */\nexport type UsjTextContentLocation = {\n  /**\n   * JSON path to the text content string the location is pointing to. The offset applies to this\n   * text string.\n   */\n  jsonPath: ContentJsonPath;\n  /**\n   * The character index in the text content string where this location is pointing. The location is\n   * at this offset within the text content string.\n   */\n  offset: number;\n};\n\n/**\n * A JSONPath query to a specific point in a property (`marker` or an attribute) value string in a\n * {@link MarkerObject} or {@link Usj}. The property cannot be `type` because `type`'s value has no\n * representation in USFM.\n *\n * To represent a location in an attribute's key, use {@link UsjAttributeKeyLocation}.\n */\nexport type UsjPropertyValueLocation = {\n  /**\n   * JSON path to the property the location is pointing to. The offset applies to this property's\n   * value string.\n   */\n  jsonPath: PropertyJsonPath;\n  /**\n   * The character index in the property's value string where this location is pointing. The\n   * location is at this offset within the property's value string.\n   */\n  propertyOffset: number;\n};\n\n/**\n * A JSONPath query to a specific point in an attribute key string in a {@link MarkerObject} or\n * {@link Usj}. The property cannot be `type` or `marker` because these properties' keys have no\n * representation in USFM. The property also cannot be any special attribute whose key doesn't have\n * a text representation in USFM like default attribute, leading attribute, text content attribute\n *\n * To represent a location in an attribute's value, use {@link UsjPropertyValueLocation}.\n */\nexport type UsjAttributeKeyLocation = {\n  /**\n   * JSON path to the marker whose attribute key the location is pointing to. The offset applies to\n   * this attribute's key string unless the attribute is an attribute marker in USFM.\n   */\n  jsonPath: ContentJsonPath;\n  /** Attribute name on the marker object whose key this location is pointing to. */\n  keyName: string;\n  /**\n   * The character index in the attribute's key string where this location is pointing.\n   *\n   * If the attribute is an attribute marker in USFM, the location is at this offset within the\n   * marker name for this attribute marker (for example, `c`'s `altnumber` attribute has attribute\n   * marker `ca`, so its `keyOffset` applies to `ca`).\n   *\n   * If the attribute is not an attribute marker in USFM, the location is at this offset within the\n   * attribute's key string.\n   */\n  keyOffset: number;\n};\n\n/**\n * A JSONPath query to an attribute marker derived from an attribute on a {@link MarkerObject} or\n * {@link Usj}. Indicates the very beginning of that marker (at the backslash in USFM).\n */\nexport type UsjAttributeMarkerLocation = {\n  /** JSON path to the marker whose attribute marker the location is pointing to. */\n  jsonPath: ContentJsonPath;\n  /**\n   * Attribute name on the marker object whose key this location is pointing to. This attribute is\n   * an attribute marker in USFM.\n   */\n  keyName: string;\n};\n\n/**\n * A JSONPath query to a specific point in the closing marker representation of an attribute marker\n * derived from an attribute on a {@link MarkerObject} or {@link Usj}.\n */\nexport type UsjClosingAttributeMarkerLocation = {\n  /**\n   * JSON path to the marker whose attribute marker's closing marker the location is pointing to.\n   * The offset applies to the closing marker representation of that attribute marker (for example,\n   * `\\ca*` in USFM).\n   */\n  jsonPath: ContentJsonPath;\n  /**\n   * Attribute name on the marker object whose key this location is pointing to. This attribute is\n   * an attribute marker in USFM.\n   */\n  keyName: string;\n  /**\n   * The character index in the closing marker representation where this location is pointing. The\n   * location is at this offset within the closing marker representation of the attribute marker.\n   */\n  keyClosingMarkerOffset: number;\n};\n\n// #endregion Serializable USJ locations relative to a specific USJ document (chapter or book)\n\n/**\n * Node in a USJ object (including the top-level Usj object) and its location in the document. You\n * must make sure you only add `node`s that correspond to the appropriate type of\n * `UsjDocumentLocation` (e.g. if `documentLocation` is a {@link UsjTextContentLocation}, `node` must\n * be a text content string)\n *\n * You can specify a particular kind of `UsjDocumentLocation` in the generic type\n * `TDocumentLocation`, and that will narrow `documentLocation` to that specific kind of location.\n */\nexport type UsjNodeAndDocumentLocation<\n  TDocumentLocation extends UsjDocumentLocation = UsjDocumentLocation,\n> = {\n  node: TDocumentLocation extends UsjTextContentLocation ? string : MarkerObject | Usj;\n  documentLocation: TDocumentLocation;\n};\n\n/** Result of a search for text within a USJ object */\nexport type UsjSearchResult = {\n  /**\n   * Beginning location in the USJ document of the search result. The text is inclusive of this\n   * location, meaning this is the location of the first character of the found text\n   */\n  start: UsjNodeAndDocumentLocation<UsjTextContentLocation>;\n  /**\n   * Ending location in the USJ document of the search result. The text is exclusive of this\n   * location, meaning this is the location right after the last character of the found text\n   */\n  end: UsjNodeAndDocumentLocation<UsjTextContentLocation>;\n  /**\n   * The matching Scripture text (not USFM string) that was found between the start and end\n   * locations\n   */\n  text: string;\n};\n\n/**\n * Set of options to provide to `UsjReaderWriter`'s constructor to customize how the reading and\n * writing works\n */\nexport type UsjReaderWriterOptions = {\n  /**\n   * A map of all USFM/USX/USJ markers and some information about them. Used for translating between\n   * the formats\n   *\n   * Defaults to trying to use a built-in markers map that matches the version of the USJ passed in.\n   *\n   * Currently supported built-in USFM versions:\n   *\n   * - 3.0/3.0.x\n   */\n  markersMap?: MarkersMap;\n  /**\n   * Whether the transformations should preserve invisible characters as in Paratext 9\n   * (`ScrText.Settings.AllowInvisibleChars`).\n   *\n   * Defaults to `false`\n   */\n  shouldAllowInvisibleCharacters?: boolean;\n};\n\n/** Utilities for reading from and writing to `Usj` objects */\nexport interface IUsjReaderWriter {\n  /**\n   * Return a copy of text following a given starting point\n   *\n   * @param start Point where text extraction will start\n   * @param desiredLength Length of text to extract from this USJ data\n   */\n  extractText(start: UsjNodeAndDocumentLocation, desiredLength: number): string;\n  /**\n   * Return a copy of text between two points\n   *\n   * @param start Point where text extraction will start\n   * @param end Point where text extraction will end\n   * @param maxLength Maximum length of string to return (defaults to 100)\n   * @returns Text between the two points, capped at length `maxLength`\n   */\n  extractTextBetweenPoints(\n    start: UsjNodeAndDocumentLocation,\n    end: UsjNodeAndDocumentLocation,\n    maxLength: number,\n  ): string;\n  /**\n   * Given a starting point, find the next location in this USJ data that matches the given text\n   *\n   * @param start Point where the search for `text` will start\n   * @param text Text to find. Note you can use an empty string to find the closest text in or after\n   *   the `start` point.\n   * @param maxTextLengthToSearch Maximum length of text to search before stopping (default is 1000)\n   * @returns Object containing the USJ node where `text` begins (it might be split across nodes),\n   *   offset within that node that indicates where `text` begins, and a JSONPath string that\n   *   indicates the location of the of USJ node within `usj`. Note that if the USJ node returned is\n   *   an object, it is the same object that is within this USJ data. So if you change it, you are\n   *   changing this USJ data.\n   */\n  findNextLocationOfMatchingText(\n    start: UsjNodeAndDocumentLocation,\n    text: string,\n    maxTextLengthToSearch: number,\n  ): UsjNodeAndDocumentLocation<UsjTextContentLocation> | undefined;\n  /** Find the first value matching the given JSONPath query within this USJ data */\n  findSingleValue<T>(jsonPathQuery: string): T | undefined;\n  /** Find the parent of the first value matching the given JSONPath query within this USJ data */\n  findParent<T>(jsonPathQuery: string): T | undefined;\n  /**\n   * Convert a JSONPath query into a SerializedVerseRef and offset\n   *\n   * @param jsonPathQuery JSONPath search expression that indicates a node within this USJ data. If\n   *   the expression matches more than one node, then only the first node found is considered. Note\n   *   that this query must yield a {@link MarkerContent} or {@link Usj}; JSONPaths yielding\n   *   properties on nodes are not currently supported.\n   * @param bookIdIfNotFound 3-letter ID of the book this USJ document is in (only used if a book ID\n   *   is not found in the USJ document)\n   * @returns SerializedVerseRef and offset that represent the location within this USJ data\n   *   indicated by `jsonPathQuery`\n   * @throws If not able to find a book ID in the USJ document and `bookIdIfNotFound` is not\n   *   provided\n   */\n  jsonPathToUsfmVerseRefVerseLocation(\n    jsonPathQuery: string,\n    bookIdIfNotFound?: string,\n  ): UsfmVerseRefVerseLocation;\n  /**\n   * Convert a JSONPath query into a USJ node, JSONPath, and offset\n   *\n   * @param jsonPathQuery JSONPath search expression that indicates a node within this USJ data. If\n   *   the expression matches more than one node, then only the first node found is considered. Note\n   *   that this query must yield a {@link MarkerContent} or {@link Usj}; JSONPaths yielding\n   *   properties on nodes are not currently supported.\n   * @returns USJ node, JSONPath, and offset that represent the location within this USJ data\n   *   indicated by `jsonPathQuery`\n   */\n  jsonPathToUsjNodeAndDocumentLocation(jsonPathQuery: string): UsjNodeAndDocumentLocation;\n  /** Build a JSONPath query that uniquely identifies the given node with this USJ data. */\n  nodeToJsonPath(node: MarkerObject): ContentJsonPath;\n  /**\n   * Determine the location in the USFM representation of this data that corresponds to the location\n   * of a node somewhere within this USJ data\n   *\n   * @param node JSON object or string in the USJ data to get the USFM location for\n   * @param nodeParent JSON object that owns the `content` array that includes `node`. Required if\n   *   `node` is a string; optional and unused if `node` is a {@link MarkerObject} or {@link Usj}\n   * @param bookIdIfNotFound 3-letter ID of the book this USJ document is in (only used if a book ID\n   *   is not found in the USJ document)\n   * @returns SerializedVerseRef and offset representing the location of `node`, if one could be\n   *   found\n   * @throws If `node` is a string and no `nodeParent` is provided\n   * @throws If not able to establish relationship between string `node` and `nodeParent`\n   * @throws If not able to find the node in the USJ document\n   * @throws If not able to find a book ID in the USJ document and `bookIdIfNotFound` is not\n   *   provided\n   */\n  nodeToUsfmVerseRefVerseLocation(\n    node: MarkerContent | Usj,\n    nodeParent?: MarkerObject | MarkerContent[] | Usj,\n    bookIdIfNotFound?: string,\n  ): UsfmVerseRefVerseLocation;\n  /**\n   * Determine the location in the USJ document that corresponds to the location of a node somewhere\n   * within this USJ data\n   *\n   * @param node JSON object or string in the USJ data to get the USJ location for\n   * @param nodeParent JSON object that owns the `content` array that includes `node`. Required if\n   *   `node` is a string; optional and unused if `node` is a {@link MarkerObject} or {@link Usj}\n   * @returns Node, JSONPath, and offset info representing the location of `node`, if one could be\n   *   found\n   * @throws If `node` is a string and no `nodeParent` is provided\n   * @throws If not able to establish relationship between string `node` and `nodeParent`\n   * @throws If not able to find the node in the USJ document\n   */\n  nodeToUsjNodeAndDocumentLocation(\n    node: MarkerContent | Usj,\n    nodeParent?: MarkerObject | MarkerContent[] | Usj,\n  ): UsjNodeAndDocumentLocation;\n  /**\n   * Remove all nodes from this USJ data that match a given search function.\n   *\n   * @param searchFunction Function that returns `true` if the given node should be removed\n   * @returns Number of nodes removed\n   */\n  removeContentNodes(searchFunction: (potentiallyMatchingNode: MarkerContent) => boolean): number;\n  /**\n   * Search for matches of a regular expression within this USJ's text data\n   *\n   * @param regex Regular expression to search for. Specify the global flag to find all matches.\n   * @returns Array of `UsjSearchResult` objects that match the given regular expression\n   */\n  search(regex: RegExp): UsjSearchResult[];\n  /** Transforms the USJ document into USFM */\n  toUsfm(): string;\n  /**\n   * Get the index in the USFM representation of this data relative to the start of the document\n   * that corresponds to the absolute verse location in USFM space passed in\n   *\n   * @param usfmVerseLocation The location in USFM space relative to a verse to get the index for\n   * @returns Index in the USFM representation of this data relative to the start of the document\n   */\n  usfmVerseLocationToIndexInUsfm(usfmVerseLocation: UsfmVerseLocation): number;\n  /**\n   * Get the node + offset and JSONPath query within this USJ data of the first encountered string\n   * after the provided USFM location for a specific verse in a USJ document.\n   *\n   * Note: this may return a node that is in a subsequent verse or even chapter depending on how\n   * much content the USJ data contains. It simply looks through the rest of the USJ data for the\n   * first text node and returns that.\n   *\n   * @param usfmVerseLocation Indicates the location in USFM space (book, chapter, verse, character\n   *   offset) to find the next text for\n   * @returns Object containing the first USJ text node after `verseRef`, and a JSONPath string that\n   *   indicates the location of the USJ text node within this USJ data.\n   * @throws Error if there is no text after `usfmVerseLocation`\n   * @throws Error if `usfmVerseLocation` does not point to a valid location in this USJ data\n   */\n  usfmVerseLocationToNextTextLocation(\n    usfmVerseLocation: UsfmVerseLocation,\n  ): UsjNodeAndDocumentLocation<UsjTextContentLocation>;\n  /**\n   * Convert a verse-based location in USFM space into a location in USJ space within this USJ data.\n   *\n   * If the USJ document has no book markers in it to determine which book the USJ is in, the\n   * `verseRef.book` will be ignored, and only the chapter and verse numbers will be used to\n   * determine the location.\n   *\n   * @param usfmVerseLocation Location in USFM space - a book, chapter, verse, and character offset\n   *   within the verse's USFM\n   * @returns Object containing the USJ location within the USJ document indicated by\n   *   `usfmVerseLocation`.\n   */\n  usfmVerseLocationToUsjDocumentLocation(usfmVerseLocation: UsfmVerseLocation): UsjDocumentLocation;\n  /**\n   * Convert a verse-based location in USFM space into a node and location in USJ space within this\n   * USJ data.\n   *\n   * If the USJ document has no book markers in it to determine which book the USJ is in, the\n   * `verseRef.book` will be ignored, and only the chapter and verse numbers will be used to\n   * determine the location.\n   *\n   * @param usfmVerseLocation Location in USFM space - a book, chapter, verse, and character offset\n   *   within the verse's USFM\n   * @returns Object containing the USJ node and location within the USJ document indicated by\n   *   `usfmVerseLocation`. Note that if the USJ node returned is an object, it is the same object\n   *   that is within this USJ data. So if you change it, you are changing this USJ data.\n   */\n  usfmVerseLocationToUsjNodeAndDocumentLocation(\n    usfmVerseLocation: UsfmVerseLocation,\n  ): UsjNodeAndDocumentLocation;\n  /**\n   * Inform this UsjReaderWriter that the underlying USJ object changed. This is needed to clear\n   * caches used when querying.\n   */\n  usjChanged(): void;\n  /**\n   * Convert a location in USJ space within this USJ data into a location in USFM space.\n   *\n   * @param usjLocation Location in USJ space - a jsonPath and other information about where the\n   *   location is\n   * @param bookIdIfNotFound 3-letter ID of the book this USJ document is in (only used if a book ID\n   *   is not found in the USJ document)\n   * @returns Location in USFM space that is equivalent to the USJ location specified\n   * @throws If not able to find the location in the USJ document\n   * @throws If not able to find a book ID in the USJ document and `bookIdIfNotFound` is not\n   *   provided\n   */\n  usjDocumentLocationToUsfmVerseRefVerseLocation(\n    usjLocation: UsjDocumentLocation,\n    bookIdIfNotFound?: string,\n  ): UsfmVerseRefVerseLocation;\n}\n","import DOMPurify from 'dompurify';\n\n/**\n * Check if an HTML string contains custom Paratext-specific tags\n *\n * @param html - HTML string to check\n * @returns True if the HTML contains <color> or <language> tags\n */\nexport function hasCustomParatextTags(html: string): boolean {\n  return /<color[^>]*>|<language[^>]*>/i.test(html);\n}\n\n/**\n * Parse Paratext specific HTML tags to standard HTML\n *\n * @param html - HTML string to parse\n * @returns Parsed HTML string\n */\nexport function parseParatextHtml(html: string): string {\n  return (\n    html\n      // Replace `<strikethrough>` with `<s>`\n      .replace(/<strikethrough>([\\s\\S]*?)<\\/strikethrough>/gi, '<s>$1</s>')\n      // Convert `<color>` tags to `<span>` with inline color styles\n      .replace(\n        /<color[^>]*name=\"([^\"]+)\"[^>]*>([\\s\\S]*?)<\\/color>/gi,\n        (_match, colorName, content) => {\n          // Map common color names to CSS colors\n          const colorMap: Record<string, string> = {\n            red: '#ef4444',\n            green: '#22c55e',\n            blue: '#3b82f6',\n          };\n\n          const cssColor = colorMap[colorName.toLowerCase()] || colorName;\n          return `<span style=\"color: ${cssColor}\">${content}</span>`;\n        },\n      )\n      // Remove `<language>` tags but keep their content\n      // TODO: This needs to be revisited when we support multilingual content\n      .replace(/<language[^>]*>([\\s\\S]*?)<\\/language>/gi, '$1')\n  );\n}\n\n/**\n * Sanitizes HTML content to prevent security risks while preserving safe formatting.\n *\n * @param html - The HTML string to sanitize\n * @returns Sanitized HTML string safe for rendering\n */\nexport function sanitizeHtml(html: string): string {\n  return DOMPurify.sanitize(html, {\n    ALLOWED_TAGS: [\n      'p',\n      'br',\n      'b',\n      'i',\n      'strong',\n      'em',\n      'u',\n      's',\n      'span',\n      'div',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'ul',\n      'ol',\n      'li',\n      'a',\n      'blockquote',\n      'code',\n      'pre',\n    ],\n    ALLOWED_ATTR: ['style', 'href', 'target', 'rel', 'class', 'dir'],\n    ALLOWED_URI_REGEXP:\n      /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.-]+(?:[^a-z+.\\-:]|$))/i,\n  });\n}\n","import { MarkerObject, MarkerContent } from '@eten-tech-foundation/scripture-utilities';\n\n/** Gets the default caller sequence to use to generate callers for textual notes. */\nexport function getDefaultCallerSequence(): string[] {\n  return Array.from({ length: 26 }, (_, i) => String.fromCharCode('a'.charCodeAt(0) + i));\n}\n\n/**\n * Gets a caller to be displayed for a textual note. This is primarily useful as a helper function\n * in {@link getFormatCallerFunction} , but it might be useful in stories, UI preview code, etc.\n *\n * @param callers Array of caller symbols, or `undefined` to use the default sequence, which is the\n *   lowercase Roman-script letters as sequenced in the English alphabet.\n * @param n Zero-based index into the caller list.\n */\nexport function getNthCaller(n: number, callers?: string[]): string {\n  const callerList = callers && callers.length > 0 ? callers : getDefaultCallerSequence();\n  return callerList[n % callerList.length];\n}\n\n/**\n * Gets a function that provides a (stable) caller based on a given sequence of textual notes.\n *\n * @param footnotes Sequence of footnotes, cross-references, and/or end-notes.\n * @param callers Array of caller symbols, or `undefined` to use the default sequence, which is the\n *   lowercase Roman-script letters as sequenced in the English alphabet.\n */\nexport function getFormatCallerFunction(footnotes: MarkerObject[], callers: string[] | undefined) {\n  const callerList = callers && callers.length > 0 ? callers : getDefaultCallerSequence();\n  // Precompute a stable sequence for '+' callers\n  const plusSequenceMap = (() => {\n    const map = new Map<number, string>();\n    let autoCallerCounter = 0;\n    footnotes.forEach((fn, idx) => {\n      if (fn.caller === '+') {\n        map.set(idx, getNthCaller(autoCallerCounter, callerList));\n        autoCallerCounter += 1;\n      }\n    });\n    return map;\n  })();\n\n  return (caller: string | undefined, index: number): string | undefined => {\n    if (caller === '+') {\n      const formattedCaller = plusSequenceMap.get(index);\n      if (!formattedCaller) {\n        console.warn(`Caller index ${index} out of range for '+' callers`);\n        return '?'; // Out of range'\n      }\n      return formattedCaller;\n    }\n    if (caller === '-') return undefined;\n    return caller;\n  };\n}\n\n/**\n * Extract footnotes from an array of `MarkerContent` objects.\n *\n * @param contents - An array of `MarkerContent` objects\n * @returns An array of MarkerObjects representing all textual notes found in the contents.\n */\nexport function extractFootnotesFromUsjContent(contents?: MarkerContent[]): MarkerObject[] {\n  const footnotes: MarkerObject[] = [];\n  if (!contents || contents.length === 0) return footnotes;\n\n  function traverse(item: MarkerContent) {\n    if (typeof item === 'string') return; // plain text node, ignore\n\n    // item is a MarkerObject\n    if (item.type === 'note') {\n      footnotes.push(item);\n    } else if (Array.isArray(item.content) && item.content.length > 0) {\n      item.content.forEach(traverse);\n    }\n  }\n\n  contents.forEach(traverse);\n  return footnotes;\n}\n","/** Options for calculating resizable pane size limits. */\nexport type PaneSizeLimitsOptions = {\n  /**\n   * The thickness of the splitter between the two panes, in pixels.\n   *\n   * @default 4\n   */\n  splitterThicknessPx?: number;\n  /**\n   * Minimum size (height or width) of the secondary pane (the pane whose size is to be\n   * constrained), in pixels. Ensures the secondary pane never shrinks below this size, if\n   * possible.\n   *\n   * @default 20\n   */\n  secondaryPaneMinSizePx?: number;\n  /**\n   * Minimum size (height or width) of the main pane (the other pane), in pixels. Ensures the main\n   * pane always has some visible content.\n   *\n   * @default 60\n   */\n  mainPaneMinSizePx?: number;\n  /**\n   * Absolute minimum percentage of the total available that the secondary pane can occupy. Used to\n   * avoid the pane collapsing completely (e.g., if the available height or width is less than the\n   * combined minimums).\n   *\n   * @default 3\n   */\n  absoluteMinPercent?: number;\n  /**\n   * Absolute maximum percentage of the total available that the secondary pane can occupy. Can be\n   * used to keep the \"main\" pane from being overwhelmed by the size of the secondary pane.\n   *\n   * @default 90\n   */\n  absoluteMaxPercent?: number;\n};\n\n/**\n * Calculates the minimum and maximum size (as percentages) for a resizable pane in a two-pane\n * layout based on the total available height or width and optional constraints.\n *\n * The returned percentages indicate the allowable range for the secondary pane (the one whose size\n * limits are being computed). When applied, they ensure that pane never shrinks below its minimum\n * or grows beyond its maximum, leaving adequate space for both panes.\n *\n * @param availablePx - Total height or width available for both panes, in pixels.\n * @param options - Optional parameters for customizing pane size constraints.\n * @returns An object containing the minimum and maximum percentages the secondary pane can occupy:\n *   `{ minPercent, maxPercent }`.\n */\nexport function getPaneSizeLimits(\n  availablePx: number,\n  options: PaneSizeLimitsOptions = {},\n): { minPercent: number; maxPercent: number } {\n  const {\n    splitterThicknessPx = 4,\n    secondaryPaneMinSizePx = 20,\n    mainPaneMinSizePx = 60,\n    absoluteMinPercent = 3,\n    absoluteMaxPercent = 90,\n  } = options;\n\n  const usableHeightPx = availablePx - splitterThicknessPx;\n\n  let minPercent: number;\n  let maxPercent: number;\n\n  if (usableHeightPx < secondaryPaneMinSizePx + mainPaneMinSizePx) {\n    minPercent = absoluteMinPercent;\n    maxPercent = absoluteMaxPercent;\n  } else {\n    maxPercent = Math.min(\n      Math.floor(((usableHeightPx - mainPaneMinSizePx) / usableHeightPx) * 100),\n      absoluteMaxPercent,\n    );\n\n    minPercent = Math.min(\n      Math.max(Math.ceil((secondaryPaneMinSizePx / usableHeightPx) * 100), absoluteMinPercent),\n      maxPercent,\n    );\n  }\n\n  return { minPercent, maxPercent };\n}\n","var getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Combine two comparators into a single comparators.\n */\nfunction combineComparators(comparatorA, comparatorB) {\n    return function isEqual(a, b, state) {\n        return comparatorA(a, b, state) && comparatorB(a, b, state);\n    };\n}\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */\nfunction createIsCircular(areItemsEqual) {\n    return function isCircular(a, b, state) {\n        if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n            return areItemsEqual(a, b, state);\n        }\n        var cache = state.cache;\n        var cachedA = cache.get(a);\n        var cachedB = cache.get(b);\n        if (cachedA && cachedB) {\n            return cachedA === b && cachedB === a;\n        }\n        cache.set(a, b);\n        cache.set(b, a);\n        var result = areItemsEqual(a, b, state);\n        cache.delete(a);\n        cache.delete(b);\n        return result;\n    };\n}\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */\nfunction getStrictProperties(object) {\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Whether the object contains the property passed as an own property.\n */\nvar hasOwn = Object.hasOwn ||\n    (function (object, property) {\n        return hasOwnProperty.call(object, property);\n    });\n/**\n * Whether the values passed are strictly equal or both NaN.\n */\nfunction sameValueZeroEqual(a, b) {\n    return a === b || (!a && !b && a !== a && b !== b);\n}\n\nvar PREACT_VNODE = '__v';\nvar PREACT_OWNER = '__o';\nvar REACT_OWNER = '_owner';\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys = Object.keys;\n/**\n * Whether the arrays are equal in value.\n */\nfunction areArraysEqual(a, b, state) {\n    var index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while (index-- > 0) {\n        if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the dates passed are equal in value.\n */\nfunction areDatesEqual(a, b) {\n    return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n/**\n * Whether the errors passed are equal in value.\n */\nfunction areErrorsEqual(a, b) {\n    return (a.name === b.name &&\n        a.message === b.message &&\n        a.cause === b.cause &&\n        a.stack === b.stack);\n}\n/**\n * Whether the functions passed are equal in value.\n */\nfunction areFunctionsEqual(a, b) {\n    return a === b;\n}\n/**\n * Whether the `Map`s are equal in value.\n */\nfunction areMapsEqual(a, b, state) {\n    var size = a.size;\n    if (size !== b.size) {\n        return false;\n    }\n    if (!size) {\n        return true;\n    }\n    var matchedIndices = new Array(size);\n    var aIterable = a.entries();\n    var aResult;\n    var bResult;\n    var index = 0;\n    while ((aResult = aIterable.next())) {\n        if (aResult.done) {\n            break;\n        }\n        var bIterable = b.entries();\n        var hasMatch = false;\n        var matchIndex = 0;\n        while ((bResult = bIterable.next())) {\n            if (bResult.done) {\n                break;\n            }\n            if (matchedIndices[matchIndex]) {\n                matchIndex++;\n                continue;\n            }\n            var aEntry = aResult.value;\n            var bEntry = bResult.value;\n            if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) &&\n                state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {\n                hasMatch = matchedIndices[matchIndex] = true;\n                break;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n        index++;\n    }\n    return true;\n}\n/**\n * Whether the numbers are equal in value.\n */\nvar areNumbersEqual = sameValueZeroEqual;\n/**\n * Whether the objects are equal in value.\n */\nfunction areObjectsEqual(a, b, state) {\n    var properties = keys(a);\n    var index = properties.length;\n    if (keys(b).length !== index) {\n        return false;\n    }\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while (index-- > 0) {\n        if (!isPropertyEqual(a, b, state, properties[index])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the objects are equal in value with strict property checking.\n */\nfunction areObjectsEqualStrict(a, b, state) {\n    var properties = getStrictProperties(a);\n    var index = properties.length;\n    if (getStrictProperties(b).length !== index) {\n        return false;\n    }\n    var property;\n    var descriptorA;\n    var descriptorB;\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while (index-- > 0) {\n        property = properties[index];\n        if (!isPropertyEqual(a, b, state, property)) {\n            return false;\n        }\n        descriptorA = getOwnPropertyDescriptor(a, property);\n        descriptorB = getOwnPropertyDescriptor(b, property);\n        if ((descriptorA || descriptorB) &&\n            (!descriptorA ||\n                !descriptorB ||\n                descriptorA.configurable !== descriptorB.configurable ||\n                descriptorA.enumerable !== descriptorB.enumerable ||\n                descriptorA.writable !== descriptorB.writable)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the primitive wrappers passed are equal in value.\n */\nfunction arePrimitiveWrappersEqual(a, b) {\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n/**\n * Whether the regexps passed are equal in value.\n */\nfunction areRegExpsEqual(a, b) {\n    return a.source === b.source && a.flags === b.flags;\n}\n/**\n * Whether the `Set`s are equal in value.\n */\nfunction areSetsEqual(a, b, state) {\n    var size = a.size;\n    if (size !== b.size) {\n        return false;\n    }\n    if (!size) {\n        return true;\n    }\n    var matchedIndices = new Array(size);\n    var aIterable = a.values();\n    var aResult;\n    var bResult;\n    while ((aResult = aIterable.next())) {\n        if (aResult.done) {\n            break;\n        }\n        var bIterable = b.values();\n        var hasMatch = false;\n        var matchIndex = 0;\n        while ((bResult = bIterable.next())) {\n            if (bResult.done) {\n                break;\n            }\n            if (!matchedIndices[matchIndex] &&\n                state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {\n                hasMatch = matchedIndices[matchIndex] = true;\n                break;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the TypedArray instances are equal in value.\n */\nfunction areTypedArraysEqual(a, b) {\n    var index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while (index-- > 0) {\n        if (a[index] !== b[index]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the URL instances are equal in value.\n */\nfunction areUrlsEqual(a, b) {\n    return (a.hostname === b.hostname &&\n        a.pathname === b.pathname &&\n        a.protocol === b.protocol &&\n        a.port === b.port &&\n        a.hash === b.hash &&\n        a.username === b.username &&\n        a.password === b.password);\n}\nfunction isPropertyEqual(a, b, state, property) {\n    if ((property === REACT_OWNER ||\n        property === PREACT_OWNER ||\n        property === PREACT_VNODE) &&\n        (a.$$typeof || b.$$typeof)) {\n        return true;\n    }\n    return (hasOwn(b, property) &&\n        state.equals(a[property], b[property], property, property, a, b, state));\n}\n\nvar ARGUMENTS_TAG = '[object Arguments]';\nvar BOOLEAN_TAG = '[object Boolean]';\nvar DATE_TAG = '[object Date]';\nvar ERROR_TAG = '[object Error]';\nvar MAP_TAG = '[object Map]';\nvar NUMBER_TAG = '[object Number]';\nvar OBJECT_TAG = '[object Object]';\nvar REG_EXP_TAG = '[object RegExp]';\nvar SET_TAG = '[object Set]';\nvar STRING_TAG = '[object String]';\nvar URL_TAG = '[object URL]';\nvar isArray = Array.isArray;\nvar isTypedArray = typeof ArrayBuffer === 'function' && ArrayBuffer.isView\n    ? ArrayBuffer.isView\n    : null;\nvar assign = Object.assign;\nvar getTag = Object.prototype.toString.call.bind(Object.prototype.toString);\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */\nfunction createEqualityComparator(_a) {\n    var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areErrorsEqual = _a.areErrorsEqual, areFunctionsEqual = _a.areFunctionsEqual, areMapsEqual = _a.areMapsEqual, areNumbersEqual = _a.areNumbersEqual, areObjectsEqual = _a.areObjectsEqual, arePrimitiveWrappersEqual = _a.arePrimitiveWrappersEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, areTypedArraysEqual = _a.areTypedArraysEqual, areUrlsEqual = _a.areUrlsEqual;\n    /**\n     * compare the value of the two objects and return true if they are equivalent in values\n     */\n    return function comparator(a, b, state) {\n        // If the items are strictly equal, no need to do a value comparison.\n        if (a === b) {\n            return true;\n        }\n        // If either of the items are nullish and fail the strictly equal check\n        // above, then they must be unequal.\n        if (a == null || b == null) {\n            return false;\n        }\n        var type = typeof a;\n        if (type !== typeof b) {\n            return false;\n        }\n        if (type !== 'object') {\n            if (type === 'number') {\n                return areNumbersEqual(a, b, state);\n            }\n            if (type === 'function') {\n                return areFunctionsEqual(a, b, state);\n            }\n            // If a primitive value that is not strictly equal, it must be unequal.\n            return false;\n        }\n        var constructor = a.constructor;\n        // Checks are listed in order of commonality of use-case:\n        //   1. Common complex object types (plain object, array)\n        //   2. Common data values (date, regexp)\n        //   3. Less-common complex object types (map, set)\n        //   4. Less-common data values (promise, primitive wrappers)\n        // Inherently this is both subjective and assumptive, however\n        // when reviewing comparable libraries in the wild this order\n        // appears to be generally consistent.\n        // Constructors should match, otherwise there is potential for false positives\n        // between class and subclass or custom object and POJO.\n        if (constructor !== b.constructor) {\n            return false;\n        }\n        // `isPlainObject` only checks against the object's own realm. Cross-realm\n        // comparisons are rare, and will be handled in the ultimate fallback, so\n        // we can avoid capturing the string tag.\n        if (constructor === Object) {\n            return areObjectsEqual(a, b, state);\n        }\n        // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n        // the string tag or doing an `instanceof` check.\n        if (isArray(a)) {\n            return areArraysEqual(a, b, state);\n        }\n        // `isTypedArray()` works on all possible TypedArray classes, so we can avoid\n        // capturing the string tag or comparing against all possible constructors.\n        if (isTypedArray != null && isTypedArray(a)) {\n            return areTypedArraysEqual(a, b, state);\n        }\n        // Try to fast-path equality checks for other complex object types in the\n        // same realm to avoid capturing the string tag. Strict equality is used\n        // instead of `instanceof` because it is more performant for the common\n        // use-case. If someone is subclassing a native class, it will be handled\n        // with the string tag comparison.\n        if (constructor === Date) {\n            return areDatesEqual(a, b, state);\n        }\n        if (constructor === RegExp) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (constructor === Map) {\n            return areMapsEqual(a, b, state);\n        }\n        if (constructor === Set) {\n            return areSetsEqual(a, b, state);\n        }\n        // Since this is a custom object, capture the string tag to determing its type.\n        // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n        var tag = getTag(a);\n        if (tag === DATE_TAG) {\n            return areDatesEqual(a, b, state);\n        }\n        // For RegExp, the properties are not enumerable, and therefore will give false positives if\n        // tested like a standard object.\n        if (tag === REG_EXP_TAG) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (tag === MAP_TAG) {\n            return areMapsEqual(a, b, state);\n        }\n        if (tag === SET_TAG) {\n            return areSetsEqual(a, b, state);\n        }\n        if (tag === OBJECT_TAG) {\n            // The exception for value comparison is custom `Promise`-like class instances. These should\n            // be treated the same as standard `Promise` objects, which means strict equality, and if\n            // it reaches this point then that strict equality comparison has already failed.\n            return (typeof a.then !== 'function' &&\n                typeof b.then !== 'function' &&\n                areObjectsEqual(a, b, state));\n        }\n        // If a URL tag, it should be tested explicitly. Like RegExp, the properties are not\n        // enumerable, and therefore will give false positives if tested like a standard object.\n        if (tag === URL_TAG) {\n            return areUrlsEqual(a, b, state);\n        }\n        // If an error tag, it should be tested explicitly. Like RegExp, the properties are not\n        // enumerable, and therefore will give false positives if tested like a standard object.\n        if (tag === ERROR_TAG) {\n            return areErrorsEqual(a, b, state);\n        }\n        // If an arguments tag, it should be treated as a standard object.\n        if (tag === ARGUMENTS_TAG) {\n            return areObjectsEqual(a, b, state);\n        }\n        // As the penultimate fallback, check if the values passed are primitive wrappers. This\n        // is very rare in modern JS, which is why it is deprioritized compared to all other object\n        // types.\n        if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n            return arePrimitiveWrappersEqual(a, b, state);\n        }\n        // If not matching any tags that require a specific type of comparison, then we hard-code false because\n        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n        //     comparison that can be made.\n        //   - For types that can be introspected, but rarely have requirements to be compared\n        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n        //     use-cases (may be included in a future release, if requested enough).\n        //   - For types that can be introspected but do not have an objective definition of what\n        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n        // In all cases, these decisions should be reevaluated based on changes to the language and\n        // common development practices.\n        return false;\n    };\n}\n/**\n * Create the configuration object used for building comparators.\n */\nfunction createEqualityComparatorConfig(_a) {\n    var circular = _a.circular, createCustomConfig = _a.createCustomConfig, strict = _a.strict;\n    var config = {\n        areArraysEqual: strict\n            ? areObjectsEqualStrict\n            : areArraysEqual,\n        areDatesEqual: areDatesEqual,\n        areErrorsEqual: areErrorsEqual,\n        areFunctionsEqual: areFunctionsEqual,\n        areMapsEqual: strict\n            ? combineComparators(areMapsEqual, areObjectsEqualStrict)\n            : areMapsEqual,\n        areNumbersEqual: areNumbersEqual,\n        areObjectsEqual: strict\n            ? areObjectsEqualStrict\n            : areObjectsEqual,\n        arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,\n        areRegExpsEqual: areRegExpsEqual,\n        areSetsEqual: strict\n            ? combineComparators(areSetsEqual, areObjectsEqualStrict)\n            : areSetsEqual,\n        areTypedArraysEqual: strict\n            ? areObjectsEqualStrict\n            : areTypedArraysEqual,\n        areUrlsEqual: areUrlsEqual,\n    };\n    if (createCustomConfig) {\n        config = assign({}, config, createCustomConfig(config));\n    }\n    if (circular) {\n        var areArraysEqual$1 = createIsCircular(config.areArraysEqual);\n        var areMapsEqual$1 = createIsCircular(config.areMapsEqual);\n        var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);\n        var areSetsEqual$1 = createIsCircular(config.areSetsEqual);\n        config = assign({}, config, {\n            areArraysEqual: areArraysEqual$1,\n            areMapsEqual: areMapsEqual$1,\n            areObjectsEqual: areObjectsEqual$1,\n            areSetsEqual: areSetsEqual$1,\n        });\n    }\n    return config;\n}\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */\nfunction createInternalEqualityComparator(compare) {\n    return function (a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {\n        return compare(a, b, state);\n    };\n}\n/**\n * Create the `isEqual` function used by the consuming application.\n */\nfunction createIsEqual(_a) {\n    var circular = _a.circular, comparator = _a.comparator, createState = _a.createState, equals = _a.equals, strict = _a.strict;\n    if (createState) {\n        return function isEqual(a, b) {\n            var _a = createState(), _b = _a.cache, cache = _b === void 0 ? circular ? new WeakMap() : undefined : _b, meta = _a.meta;\n            return comparator(a, b, {\n                cache: cache,\n                equals: equals,\n                meta: meta,\n                strict: strict,\n            });\n        };\n    }\n    if (circular) {\n        return function isEqual(a, b) {\n            return comparator(a, b, {\n                cache: new WeakMap(),\n                equals: equals,\n                meta: undefined,\n                strict: strict,\n            });\n        };\n    }\n    var state = {\n        cache: undefined,\n        equals: equals,\n        meta: undefined,\n        strict: strict,\n    };\n    return function isEqual(a, b) {\n        return comparator(a, b, state);\n    };\n}\n\n/**\n * Whether the items passed are deeply-equal in value.\n */\nvar deepEqual = createCustomEqual();\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */\nvar strictDeepEqual = createCustomEqual({ strict: true });\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */\nvar circularDeepEqual = createCustomEqual({ circular: true });\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */\nvar strictCircularDeepEqual = createCustomEqual({\n    circular: true,\n    strict: true,\n});\n/**\n * Whether the items passed are shallowly-equal in value.\n */\nvar shallowEqual = createCustomEqual({\n    createInternalComparator: function () { return sameValueZeroEqual; },\n});\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */\nvar strictShallowEqual = createCustomEqual({\n    strict: true,\n    createInternalComparator: function () { return sameValueZeroEqual; },\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */\nvar circularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: function () { return sameValueZeroEqual; },\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */\nvar strictCircularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: function () { return sameValueZeroEqual; },\n    strict: true,\n});\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */\nfunction createCustomEqual(options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.circular, circular = _a === void 0 ? false : _a, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === void 0 ? false : _b;\n    var config = createEqualityComparatorConfig(options);\n    var comparator = createEqualityComparator(config);\n    var equals = createCustomInternalComparator\n        ? createCustomInternalComparator(comparator)\n        : createInternalEqualityComparator(comparator);\n    return createIsEqual({ circular: circular, comparator: comparator, createState: createState, equals: equals, strict: strict });\n}\n\nexport { circularDeepEqual, circularShallowEqual, createCustomEqual, deepEqual, sameValueZeroEqual, shallowEqual, strictCircularDeepEqual, strictCircularShallowEqual, strictDeepEqual, strictShallowEqual };\n//# sourceMappingURL=index.mjs.map\n","// There is a circular version https://www.npmjs.com/package/fast-equals#circulardeepequal that I\n// think allows comparing React refs (which have circular references in particular places that this\n// library would ignore). Maybe we can change to that version sometime if needed.\nimport { deepEqual as isEqualDeep } from 'fast-equals';\n\n/**\n * Check that two objects are deeply equal, comparing members of each object and such\n *\n * @param a The first object to compare\n * @param b The second object to compare\n *\n *   WARNING: Objects like arrays from different iframes have different constructor function\n *   references even if they do the same thing, so this deep equality comparison fails objects that\n *   look the same but have different constructors because different constructors could produce\n *   false positives in [a few specific\n *   situations](https://github.com/planttheidea/fast-equals/blob/a41afc0a240ad5a472e47b53791e9be017f52281/src/comparator.ts#L96).\n *   This means that two objects like arrays from different iframes that look the same will fail\n *   this check. Please use some other means to check deep equality in those situations.\n *\n *   Note: This deep equality check considers `undefined` values on keys of objects NOT to be equal to\n *   not specifying the key at all. For example, `{ stuff: 3, things: undefined }` and `{ stuff: 3\n *   }` are not considered equal in this case\n *\n *   - For more information and examples, see [this\n *       CodeSandbox](https://codesandbox.io/s/deepequallibrarycomparison-4g4kk4?file=/src/index.mjs).\n *\n * @returns True if a and b are deeply equal; false otherwise\n */\nexport function deepEqual(a: unknown, b: unknown) {\n  return isEqualDeep(a, b);\n}\n\nexport default deepEqual;\n","import { deepEqual } from './equality-checking';\n\n/**\n * Check if one object is a subset of the other object. \"Subset\" means that all properties of one\n * object are present in the other object, and if they are present that all values of those\n * properties are deeply equal. Sub-objects are also checked to be subsets of the corresponding\n * sub-object in the other object.\n *\n * @example ObjB is a subset of objA given these objects:\n *\n * ```ts\n * objA = { name: 'Alice', age: 30, address: { city: 'Seattle', state: 'Washington' } };\n * objB = { name: 'Alice', address: { city: 'Seattle' } };\n * ```\n *\n * It is important to note that only arrays of primitives (i.e., booleans, numbers, strings) are\n * supported. In particular, objects in arrays will not be checked for deep equality. Also, presence\n * in an array is all this checks, not the number of times that an item appears in an array. `[1,\n * 1]` is a subset of `[1]`.\n *\n * @param objectWithAllProperties Object to be checked if it is a superset of\n *   `objectWithPartialProperties`\n * @param objectWithPartialProperties Object to be checked if it is a subset of\n *   `objectWithAllProperties`\n * @returns True if `objectWithAllProperties` contains all the properties of\n *   `objectWithPartialProperties` and all values of those properties are deeply equal\n */\nexport function isSubset(\n  objectWithAllProperties: unknown,\n  objectWithPartialProperties: unknown,\n): boolean {\n  if (typeof objectWithAllProperties !== typeof objectWithPartialProperties) return false;\n\n  // For this function we're saying that all falsy things of the same type are equal to each other\n  if (!objectWithAllProperties && !objectWithPartialProperties) return true;\n\n  if (Array.isArray(objectWithAllProperties)) {\n    // We know these are arrays from the line above\n    /* eslint-disable no-type-assertion/no-type-assertion */\n    const partialArray = objectWithPartialProperties as Array<unknown>;\n    const allArray = objectWithAllProperties as Array<unknown>;\n    /* eslint-enable no-type-assertion/no-type-assertion */\n\n    if (partialArray.length === 0) return true;\n\n    // This only works with arrays of primitives.\n    // If someone cares about checking arrays of objects this needs updating.\n    return partialArray.every((item) => allArray.includes(item));\n  }\n\n  if (typeof objectWithAllProperties !== 'object')\n    return deepEqual(objectWithAllProperties, objectWithPartialProperties);\n\n  // We know these are objects that potentially have properties because of the earlier checks\n  /* eslint-disable no-type-assertion/no-type-assertion */\n  const partialObj = objectWithPartialProperties as Record<string, unknown>;\n  const allObj = objectWithAllProperties as Record<string, unknown>;\n  /* eslint-enable no-type-assertion/no-type-assertion */\n\n  let retVal = true;\n  Object.keys(partialObj).forEach((key) => {\n    if (!retVal) return;\n    if (!Object.hasOwn(allObj, key)) retVal = false;\n    else if (!isSubset(allObj[key], partialObj[key])) retVal = false;\n  });\n  return retVal;\n}\n\nexport default isSubset;\n","/**\n * Converts a JavaScript value to a JSON string, changing `undefined` properties in the JavaScript\n * object to `null` properties in the JSON string.\n *\n * WARNING: `null` values will become `undefined` values after passing through {@link serialize} then\n * {@link deserialize}. For example, `{ a: 1, b: undefined, c: null }` will become `{ a: 1, b:\n * undefined, c: undefined }`. If you are passing around user data that needs to retain `null`\n * values, you should wrap them yourself in a string before using this function. Alternatively, you\n * can write your own replacer that will preserve `null` in a way that you can recover later.\n *\n * @param value A JavaScript value, usually an object or array, to be converted.\n * @param replacer A function that transforms the results. Note that all `undefined` values returned\n *   by the replacer will be further transformed into `null` in the JSON string.\n * @param space Adds indentation, white space, and line break characters to the return-value JSON\n *   text to make it easier to read. See the `space` parameter of `JSON.stringify` for more\n *   details.\n */\nexport function serialize(\n  value: unknown,\n  replacer?: (this: unknown, key: string, value: unknown) => unknown,\n  space?: string | number,\n): string {\n  const undefinedReplacer = (replacerKey: string, replacerValue: unknown) => {\n    let newValue = replacerValue;\n    if (replacer) newValue = replacer(replacerKey, newValue);\n    // All `undefined` values become `null` on the way from JS objects into JSON strings\n    // eslint-disable-next-line no-null/no-null\n    if (newValue === undefined) newValue = null;\n    return newValue;\n  };\n  return JSON.stringify(value, undefinedReplacer, space);\n}\n\n/**\n * Converts a JSON string into a value, converting all `null` properties from JSON into `undefined`\n * in the returned JavaScript value/object.\n *\n * WARNING: `null` values will become `undefined` values after passing through {@link serialize} then\n * {@link deserialize}. For example, `{ a: 1, b: undefined, c: null }` will become `{ a: 1, b:\n * undefined, c: undefined }`. If you are passing around user data that needs to retain `null`\n * values, you should wrap them yourself in a string before using this function. Alternatively, you\n * can write your own replacer that will preserve `null` in a way that you can recover later.\n *\n * @param value A valid JSON string.\n * @param reviver A function that transforms the results. This function is called for each member of\n *   the object. If a member contains nested objects, the nested objects are transformed before the\n *   parent object is. Note that `null` values are converted into `undefined` values after the\n *   reviver has run.\n */\nexport function deserialize(\n  value: string,\n  reviver?: (this: unknown, key: string, value: unknown) => unknown,\n  // Need to use `any` instead of `unknown` here to match the signature of JSON.parse\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): any {\n  // Helper function to replace `null` with `undefined` on a per property basis. This can't be done\n  // with our own reviver because `JSON.parse` removes `undefined` properties from the return value.\n  function replaceNull(obj: Record<string | number, unknown>): Record<string | number, unknown> {\n    Object.keys(obj).forEach((key: string | number) => {\n      // We only want to replace `null`, not other falsy values\n      // eslint-disable-next-line no-null/no-null\n      if (obj[key] === null) obj[key] = undefined;\n      // If the property is an object, recursively call the helper function on it\n      else if (typeof obj[key] === 'object')\n        // Since the object came from a string, we know the keys will not be symbols\n        // eslint-disable-next-line no-type-assertion/no-type-assertion\n        obj[key] = replaceNull(obj[key] as Record<string | number, unknown>);\n    });\n    return obj;\n  }\n\n  const parsedObject = JSON.parse(value, reviver);\n  // Explicitly convert the value 'null' that isn't stored as a property on an object to 'undefined'\n  // eslint-disable-next-line no-null/no-null\n  if (parsedObject === null) return undefined;\n  if (typeof parsedObject === 'object') return replaceNull(parsedObject);\n  return parsedObject;\n}\n\n/**\n * Check to see if the value is serializable without losing information\n *\n * @param value Value to test\n * @returns True if serializable; false otherwise\n *\n *   Note: the values `undefined` and `null` are serializable (on their own or in an array), but\n *   `null` values get transformed into `undefined` when serializing/deserializing.\n *\n *   WARNING: This is inefficient right now as it stringifies, parses, stringifies, and === the value.\n *   Please only use this if you need to\n *\n *   DISCLAIMER: this does not successfully detect that values are not serializable in some cases:\n *\n *   - Losses of removed properties like functions and `Map`s\n *   - Class instances (not deserializable into class instances without special code)\n *\n *   We intend to improve this in the future if it becomes important to do so. See [`JSON.stringify`\n *   documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description)\n *   for more information.\n */\nexport function isSerializable(value: unknown): boolean {\n  try {\n    const serializedValue = serialize(value);\n    return serializedValue === serialize(deserialize(serializedValue));\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * HTML Encodes the provided string. Thanks to ChatGPT\n *\n * @param str String to HTML encode\n * @returns HTML-encoded string\n */\nexport const htmlEncode = (str: string): string =>\n  str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;')\n    .replace(/\\//g, '&#x2F;');\n","import { DateTimeFormat } from './intl-date-time-format';\n\n/**\n * Retrieves the current locale of the user's environment.\n *\n * @returns A string representing the current locale. If the locale cannot be determined, the\n *   function returns an empty string.\n */\nexport function getCurrentLocale(): string {\n  // Use navigator when available\n  if (typeof navigator !== 'undefined' && navigator.languages) {\n    const rawLocale = navigator.languages[0];\n    // According to the MDN page for navigator.languages it should always return a valid BCP 47 tag.\n    // However, some environments (e.g., certain Linux distros) may use the 'POSIX locale format'.\n    // This code removes a (potential) trailing \"@posix\" so we will always return a valid BCP 47 tag\n    // You can find the MDN page for navigator.languages here:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Navigator/language\n    // You can learn more about the 'POSIX locale format' here:\n    // https://learn.microsoft.com/en-us/globalization/locale/other-locale-names\n    return rawLocale.replace(/@posix$/i, '');\n  }\n  // For Node.js\n  return new DateTimeFormat().resolvedOptions().locale;\n}\n\nexport default getCurrentLocale;\n","import { NumberFormat } from './intl/intl-number-format';\n\n/**\n * Formats a number according to the locale and formatting options of this NumberFormat object\n *\n * @example FormatBytes(1024) => \"1 KB\"\n *\n * @example FormatBytes(1024, 0) => \"1 KB\"\n *\n * @param fileSize Number to format\n * @param decimals Number of decimal places to round to\n * @returns String representing the given number formatted according to the locale and formatting\n *   options of this NumberFormat object\n */\nexport function formatBytes(fileSize: number, decimals: number = 2): string {\n  if (fileSize === 0) return '0 Bytes';\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n  const i = Math.floor(Math.log(fileSize) / Math.log(1024));\n  const sizeToUse = sizes[i];\n  const formattingFileSize = new NumberFormat('en', {\n    style: 'decimal',\n    maximumFractionDigits: decimals,\n    minimumFractionDigits: 0,\n  }).format(fileSize / 1024 ** i);\n  return `${formattingFileSize} ${sizeToUse}`;\n}\n\nexport default formatBytes;\n","const MILLISECONDS_PER_SECOND = 1000;\nconst SECONDS_PER_MINUTE = 60;\nconst SECONDS_PER_HOUR = SECONDS_PER_MINUTE * 60;\nconst SECONDS_PER_DAY = SECONDS_PER_HOUR * 24;\n\n/**\n * Get a localized string representation of the time between two dates\n *\n * @example\n *\n * `since` = 3 Aug 2024 8:00 AM\n *\n * `to` = 5 Aug 2024 8:000 AM\n *\n * Returns: \"two days ago\"\n *\n * @param since \"Destination\" time. time against which to get the time span.\n * @param to \"Starting\" time. Time span will be formatted relative to `to`. Defaults to `new Date()`\n * @returns Time span in words from `to` to `since`\n */\nexport function formatTimeSpan(\n  relativeTimeFormatter: Intl.RelativeTimeFormat,\n  since: Date,\n  to = new Date(),\n) {\n  const spanSeconds = Math.floor((since.getTime() - to.getTime()) / MILLISECONDS_PER_SECOND);\n\n  const totalDays = Math.round(spanSeconds / SECONDS_PER_DAY);\n  if (Math.abs(totalDays) >= 1) return relativeTimeFormatter.format(totalDays, 'day');\n\n  const totalHours = Math.round(spanSeconds / SECONDS_PER_HOUR);\n  if (Math.abs(totalHours) >= 1) return relativeTimeFormatter.format(totalHours, 'hour');\n\n  const totalMinutes = Math.round(spanSeconds / SECONDS_PER_MINUTE);\n  if (Math.abs(totalMinutes) >= 1) return relativeTimeFormatter.format(totalMinutes, 'minute');\n\n  return relativeTimeFormatter.format(spanSeconds, 'second');\n}\n\n/**\n * Formats a date relative to today, showing \"Today\" or \"Yesterday\" when applicable, otherwise\n * returns the date in the specified format\n *\n * @param date The date to format\n * @param todayString The string to display when the date is today\n * @param yesterdayString The string to display when the date is yesterday\n * @param locale The locale to use for date formatting (defaults to user's locale)\n * @param options The Intl.DateTimeFormatOptions to use for date formatting when not\n *   today/yesterday. Defaults to `{ year: 'numeric', month: 'short', day: 'numeric' }` which\n *   produces formats like \"Nov 9, 2025\"\n */\nexport function formatRelativeDate(\n  date: Date,\n  todayString: string,\n  yesterdayString: string,\n  locale?: string,\n  options: Intl.DateTimeFormatOptions = {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n  },\n): string {\n  const today = new Date();\n  const yesterday = new Date(today);\n  yesterday.setDate(yesterday.getDate() - 1);\n\n  const isToday =\n    date.getDate() === today.getDate() &&\n    date.getMonth() === today.getMonth() &&\n    date.getFullYear() === today.getFullYear();\n\n  const isYesterday =\n    date.getDate() === yesterday.getDate() &&\n    date.getMonth() === yesterday.getMonth() &&\n    date.getFullYear() === yesterday.getFullYear();\n\n  if (isToday) {\n    return todayString;\n  }\n  if (isYesterday) {\n    return yesterdayString;\n  }\n\n  return date.toLocaleString(locale, options);\n}\n","/**\n * Modifier keys that don't constitute typed input\n *\n * Sourced from\n * https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values#modifier_keys\n */\nexport const MODIFIER_KEYS = new Set([\n  'Alt',\n  'AltGraph',\n  'CapsLock',\n  'Control',\n  'Fn',\n  'FnLock',\n  'Hyper',\n  'Meta',\n  'NumLock',\n  'ScrollLock',\n  'Shift',\n  'Super',\n  'Symbol',\n  'SymbolLock',\n]);\n","//----------------------------------------------------------------------------------------------\n// NOTE: If you change any of the types, make sure the JSON schema at the end of this file gets\n// changed so they align.\n//----------------------------------------------------------------------------------------------\n\nimport { LocalizeKey, ReferencedItem } from './menus.model';\n\n/** The data an extension provides to inform Platform.Bible of the settings it provides */\nexport type SettingsContribution = SettingsGroup | SettingsGroup[];\n/** A description of an extension's setting entry */\nexport type Setting = ExtensionControlledSetting;\n/** Setting definition that is validated by the extension. */\nexport type ExtensionControlledSetting = SettingBase & ModifierExtensionControlled;\n/** Base information needed to describe a setting entry */\nexport type SettingBase = StateBase & {\n  [k: string]: unknown;\n  /** LocalizeKey that displays in the settings dialog as the setting name */\n  label: LocalizeKey;\n  /** LocalizeKey that displays in the settings dialog to describe the setting */\n  description?: LocalizeKey;\n  /**\n   * Boolean that controls whether a setting should be hidden or not. If hidden, the setting will\n   * not show up in the settings dialog in `paranext-core`, and thus will not be configurable by the\n   * user unless an extension provides a way to interact with the setting.\n   */\n  isHidden?: boolean;\n};\n/** The data an extension provides to inform Platform.Bible of the project settings it provides */\nexport type ProjectSettingsContribution = ProjectSettingsGroup | ProjectSettingsGroup[];\n/** A description of an extension's setting entry */\nexport type ProjectSetting = ExtensionControlledProjectSetting;\n/** Setting definition that is validated by the extension. */\nexport type ExtensionControlledProjectSetting = ProjectSettingBase & ModifierExtensionControlled;\n/** Base information needed to describe a project setting entry */\nexport type ProjectSettingBase = SettingBase & ModifierProject;\n/** A description of an extension's user state entry */\nexport type UserState = ExtensionControlledState;\n/** State definition that is validated by the extension. */\nexport type ExtensionControlledState = StateBase & ModifierExtensionControlled;\n/** Group of related settings definitions */\nexport interface SettingsGroup {\n  [k: string]: unknown;\n  /** LocalizeKey that displays in the settings dialog as the group name */\n  label: LocalizeKey;\n  /** LocalizeKey that displays in the settings dialog to describe the group */\n  description?: LocalizeKey;\n  properties: SettingProperties;\n}\n/** Object whose keys are setting IDs and whose values are settings objects */\nexport interface SettingProperties {\n  [k: ReferencedItem]: Setting;\n}\n/** Base information needed to describe a state entry */\nexport interface StateBase {\n  [k: string]: unknown;\n  /** Default value for the state/setting */\n  default: unknown;\n  /**\n   * A state/setting ID whose value to set to this state/setting's starting value the first time\n   * this state/setting is loaded\n   */\n  derivesFrom?: ReferencedItem;\n}\n/**\n * Modifies state/setting type to be extension-controlled. \"Extension-controlled\" means the\n * extension provides the component and the validator for the state/setting, so the state/setting is\n * controlled by the extension.\n */\nexport interface ModifierExtensionControlled {\n  [k: string]: unknown;\n  platformType?: undefined;\n  type?: undefined;\n}\n/** Group of related settings definitions */\nexport interface ProjectSettingsGroup {\n  [k: string]: unknown;\n  /** LocalizeKey that displays in the project settings dialog as the group name */\n  label: LocalizeKey;\n  /** LocalizeKey that displays in the project settings dialog to describe the group */\n  description?: LocalizeKey;\n  properties: ProjectSettingProperties;\n}\n/** Object whose keys are setting IDs and whose values are settings objects */\nexport interface ProjectSettingProperties {\n  [k: ReferencedItem]: ProjectSetting;\n}\n\n// Note: we removed the index signature on ModifierProject to avoid having it on\n// `ProjectMetadataFilterOptions`. Unfortunately adding \"additionalProperties\": false on the json\n// schema messes up validation. Please remove the index signature again in the future if you\n// regenerate types\n/**\n * Defines a set of optional properties that can be used to filter projects based on their\n * `projectInterface` and Project Data Provider Factory Ids.\n */\nexport interface ModifierProject {\n  /**\n   * String representation of `RegExp` pattern(s) to match against projects' `projectInterface`s\n   * (using the\n   * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)\n   * function) to determine if they should be included.\n   *\n   * If this is one string, it will be matched against `projectInterface`s. If this is an array,\n   * each entry is handled based on its type (at least one entry must match for this filter\n   * condition to pass):\n   *\n   * - If the entry is a string, it will be matched against each `projectInterface`. If any match, the\n   *   project will pass this filter condition\n   * - If the entry is an array of strings, each will be matched against each `projectInterface`. If\n   *   every string matches against at least one `projectInterface`, the project will pass this\n   *   filter condition\n   *\n   * In other words, each entry in the first-level array is `OR`'ed together. Each entry in\n   * second-level arrays (arrays within the first-level array) are `AND`'ed together.\n   *\n   * Defaults to all `ProjectInterfaces`, so all projects that do not match\n   * `excludeProjectInterfaces` will be included\n   *\n   * @example\n   *\n   * ```typescript\n   * includeProjectInterfaces: ['one', ['two', 'three']];\n   * ```\n   *\n   * This filter condition will succeed on projects whose `projectInterface`s fulfill at least one\n   * of the following conditions (At least one entry in the array must match):\n   *\n   * - Include `one`\n   * - Include both `two` and `three`.\n   */\n  includeProjectInterfaces?: undefined | string | (string | string[])[];\n  /**\n   * String representation of `RegExp` pattern(s) to match against projects' `projectInterface`s\n   * (using the\n   * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)\n   * function) to determine if they should absolutely not be included even if they match with\n   * `includeProjectInterfaces`.\n   *\n   * If this is one string, it will be matched against `projectInterface`s. If this is an array,\n   * each entry is handled based on its type (at least one entry must match for this filter\n   * condition to exclude the project):\n   *\n   * - If the entry is a string, it will be matched against each `projectInterface`. If any match, the\n   *   project will pass this filter condition and exclude the project\n   * - If the entry is an array of strings, each will be matched against each `projectInterface`. If\n   *   every string matches against at least one `projectInterface`, the project will pass this\n   *   filter condition and exclude the project\n   *\n   * In other words, each entry in the first-level array is `OR`'ed together. Each entry in\n   * second-level arrays (arrays within the first-level array) are `AND`'ed together.\n   *\n   * Defaults to no `ProjectInterfaces`, so all projects that match `includeProjectInterfaces` will\n   * be included\n   *\n   * @example\n   *\n   * ```typescript\n   * excludeProjectInterfaces: ['one', ['two', 'three']];\n   * ```\n   *\n   * This filter condition will succeed and exclude projects whose `projectInterface`s fulfill at\n   * least one of the following conditions (At least one entry in the array must match):\n   *\n   * - Include `one`\n   * - Include both `two` and `three`.\n   */\n  excludeProjectInterfaces?: undefined | string | (string | string[])[];\n  /**\n   * String representation of `RegExp` pattern(s) to match against the Project Data Provider Factory\n   * Ids that provided each project's metadata (using the\n   * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)\n   * function) to determine if the projects should be included.\n   *\n   * Defaults to all Project Data Provider Factory Ids, so all projects that do not match\n   * `excludePdpFactoryIds` will be included\n   */\n  includePdpFactoryIds?: undefined | string | string[];\n  /**\n   * String representation of `RegExp` pattern(s) to match against the Project Data Provider Factory\n   * Ids that provided each project's metadata (using the\n   * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)\n   * function) to determine if the projects should absolutely not be included even if they match\n   * with `includeProjectInterfaces`.\n   *\n   * Defaults to none, so all projects that match `includePdpFactoryIds` will be included\n   */\n  excludePdpFactoryIds?: undefined | string | string[];\n}\n\n/** The data an extension provides to inform Platform.Bible of the user state it provides */\nexport interface UserStateContribution {\n  [k: ReferencedItem]: UserState;\n}\n/** The data an extension provides to inform Platform.Bible of the project state it provides */\nexport interface ProjectStateContribution {\n  [k: ReferencedItem]: UserState;\n}\n\n//----------------------------------------------------------------------------------------------\n// NOTE: If you change the schema below, make sure the TS types above get changed so they align.\n//----------------------------------------------------------------------------------------------\nconst settingsDefs = {\n  projectSettingsContribution: {\n    description:\n      'The data an extension provides to inform Platform.Bible of the project settings it provides',\n    anyOf: [\n      {\n        $ref: '#/$defs/projectSettingsGroup',\n      },\n      {\n        type: 'array',\n        items: {\n          $ref: '#/$defs/projectSettingsGroup',\n        },\n      },\n    ],\n  },\n  projectSettingsGroup: {\n    description: 'Group of related settings definitions',\n    type: 'object',\n    properties: {\n      label: {\n        description: 'localizeKey that displays in the project settings dialog as the group name',\n        $ref: '#/$defs/localizeKey',\n      },\n      description: {\n        description:\n          'localizeKey that displays in the project settings dialog to describe the group',\n        $ref: '#/$defs/localizeKey',\n      },\n      properties: {\n        $ref: '#/$defs/projectSettingProperties',\n      },\n    },\n    required: ['label', 'properties'],\n  },\n  projectSettingProperties: {\n    description: 'Object whose keys are setting IDs and whose values are settings objects',\n    type: 'object',\n    patternProperties: {\n      '^[\\\\w\\\\-]+\\\\.[\\\\w\\\\-]+$': {\n        $ref: '#/$defs/projectSetting',\n      },\n    },\n    additionalProperties: false,\n  },\n  projectSetting: {\n    description: \"A description of an extension's setting entry\",\n    anyOf: [\n      {\n        $ref: '#/$defs/extensionControlledProjectSetting',\n      },\n    ],\n  },\n  extensionControlledProjectSetting: {\n    description: 'Setting definition that is validated by the extension.',\n    allOf: [\n      {\n        $ref: '#/$defs/projectSettingBase',\n      },\n      {\n        $ref: '#/$defs/modifierExtensionControlled',\n      },\n    ],\n  },\n  projectSettingBase: {\n    description: 'Base information needed to describe a project setting entry',\n    allOf: [\n      {\n        $ref: '#/$defs/settingBase',\n      },\n      {\n        $ref: '#/$defs/modifierProject',\n      },\n    ],\n  },\n  modifierProject: {\n    description: 'Modifies setting type to be project setting',\n    type: 'object',\n    properties: {\n      includeProjectInterfaces: {\n        description:\n          \"String representation of `RegExp` pattern(s) to match against projects' `projectInterface`s (using the [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test) function) to determine if they should be included.\\n\\nIf this is one string, it will be matched against `projectInterface`s. If this is an array, each entry is handled based on its type (at least one entry must match for this filter condition to pass):\\n\\n- If the entry is a string, it will be matched against each `projectInterface`. If any match, the project will pass this filter condition\\n- If the entry is an array of strings, each will be matched against each `projectInterface`. If every string matches against at least one `projectInterface`, the project will pass this filter condition\\n\\nIn other words, each entry in the first-level array is `OR`'ed together. Each entry in second-level arrays (arrays within the first-level array) are `AND`'ed together.\\n\\nDefaults to all `ProjectInterfaces`, so all projects that do not match `excludeProjectInterfaces` will be included\\n\\n@example\\n\\n```typescript\\nincludeProjectInterfaces: ['one', ['two', 'three']];\\n```\\n\\nThis filter condition will succeed on projects whose `projectInterface`s fulfill at least one of the following conditions (At least one entry in the array must match):\\n\\n- Include `one`\\n- Include both `two` and `three`.\",\n        anyOf: [\n          {\n            type: 'null',\n          },\n          {\n            type: 'string',\n          },\n          {\n            type: 'array',\n            items: {\n              anyOf: [\n                {\n                  type: 'string',\n                },\n                {\n                  type: 'array',\n                  items: { type: 'string' },\n                },\n              ],\n            },\n          },\n        ],\n      },\n      excludeProjectInterfaces: {\n        description:\n          \"String representation of `RegExp` pattern(s) to match against projects' `projectInterface`s (using the [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test) function) to determine if they should absolutely not be included even if they match with `includeProjectInterfaces`.\\n\\nIf this is one string, it will be matched against `projectInterface`s. If this is an array, each entry is handled based on its type (at least one entry must match for this filter condition to exclude the project):\\n\\n- If the entry is a string, it will be matched against each `projectInterface`. If any match, the project will pass this filter condition and exclude the project\\n- If the entry is an array of strings, each will be matched against each `projectInterface`. If every string matches against at least one `projectInterface`, the project will pass this filter condition and exclude the project\\n\\nIn other words, each entry in the first-level array is `OR`'ed together. Each entry in second-level arrays (arrays within the first-level array) are `AND`'ed together.\\n\\nDefaults to no `ProjectInterfaces`, so all projects that match `includeProjectInterfaces` will be included\\n\\n@example\\n\\n```typescript\\nexcludeProjectInterfaces: ['one', ['two', 'three']];\\n```\\n\\nThis filter condition will succeed and exclude projects whose `projectInterface`s fulfill at least one of the following conditions (At least one entry in the array must match):\\n\\n- Include `one`\\n- Include both `two` and `three`.\",\n        anyOf: [\n          {\n            type: 'null',\n          },\n          {\n            type: 'string',\n          },\n          {\n            type: 'array',\n            items: {\n              anyOf: [\n                {\n                  type: 'string',\n                },\n                {\n                  type: 'array',\n                  items: { type: 'string' },\n                },\n              ],\n            },\n          },\n        ],\n      },\n      includePdpFactoryIds: {\n        description:\n          \"String representation of `RegExp` pattern(s) to match against the Project Data Provider Factory Ids that provided each project's metadata (using the [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test) function) to determine if the projects should be included.\\n\\nDefaults to all Project Data Provider Factory Ids, so all projects that do not match `excludePdpFactoryIds` will be included\",\n        anyOf: [\n          {\n            type: 'null',\n          },\n          {\n            type: 'string',\n          },\n          {\n            type: 'array',\n            items: { type: 'string' },\n          },\n        ],\n      },\n      excludePdpFactoryIds: {\n        description:\n          \"String representation of `RegExp` pattern(s) to match against the Project Data Provider Factory Ids that provided each project's metadata (using the [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test) function) to determine if the projects should absolutely not be included even if they match with `includeProjectInterfaces`.\\n\\nDefaults to none, so all projects that match `includePdpFactoryIds` will be included\",\n        anyOf: [\n          {\n            type: 'null',\n          },\n          {\n            type: 'string',\n          },\n          {\n            type: 'array',\n            items: { type: 'string' },\n          },\n        ],\n      },\n    },\n  },\n  settingsContribution: {\n    description:\n      'The data an extension provides to inform Platform.Bible of the settings it provides',\n    anyOf: [\n      {\n        $ref: '#/$defs/settingsGroup',\n      },\n      {\n        type: 'array',\n        items: {\n          $ref: '#/$defs/settingsGroup',\n        },\n      },\n    ],\n  },\n  settingsGroup: {\n    description: 'Group of related settings definitions',\n    type: 'object',\n    properties: {\n      label: {\n        description: 'localizeKey that displays in the settings dialog as the group name',\n        $ref: '#/$defs/localizeKey',\n      },\n      description: {\n        description: 'localizeKey that displays in the settings dialog to describe the group',\n        $ref: '#/$defs/localizeKey',\n      },\n      properties: {\n        $ref: '#/$defs/settingProperties',\n      },\n    },\n    required: ['label', 'properties'],\n  },\n  settingProperties: {\n    description: 'Object whose keys are setting IDs and whose values are settings objects',\n    type: 'object',\n    patternProperties: {\n      '^[\\\\w-]+\\\\.[\\\\w-]+$': {\n        $ref: '#/$defs/setting',\n      },\n    },\n    additionalProperties: false,\n  },\n  setting: {\n    description: \"A description of an extension's setting entry\",\n    anyOf: [\n      {\n        $ref: '#/$defs/extensionControlledSetting',\n      },\n    ],\n  },\n  extensionControlledSetting: {\n    description: 'Setting definition that is validated by the extension.',\n    allOf: [\n      {\n        $ref: '#/$defs/settingBase',\n      },\n      {\n        $ref: '#/$defs/modifierExtensionControlled',\n      },\n    ],\n  },\n  settingBase: {\n    description: 'Base information needed to describe a setting entry',\n    allOf: [\n      {\n        $ref: '#/$defs/stateBase',\n      },\n      {\n        type: 'object',\n        properties: {\n          label: {\n            description: 'localizeKey that displays in the settings dialog as the setting name',\n            $ref: '#/$defs/localizeKey',\n          },\n          description: {\n            description: 'localizeKey that displays in the settings dialog to describe the setting',\n            $ref: '#/$defs/localizeKey',\n          },\n          isHidden: {\n            description: `Boolean that controls whether a setting should be hidden or not. If hidden\n            , the setting will not show up in the settings dialog in \\`paranext-core\\`, and thus\n            will not be configurable by the user unless an extension provides a way to interact with\n            the setting.`,\n            type: 'boolean',\n          },\n        },\n        required: ['label'],\n      },\n    ],\n  },\n  projectStateContribution: {\n    description:\n      'The data an extension provides to inform Platform.Bible of the project state it provides',\n    $ref: '#/$defs/userStateProperties',\n  },\n  userStateContribution: {\n    description:\n      'The data an extension provides to inform Platform.Bible of the user state it provides',\n    $ref: '#/$defs/userStateProperties',\n  },\n  userStateProperties: {\n    description: 'Object whose keys are state IDs and whose values are state objects',\n    type: 'object',\n    patternProperties: {\n      '^[\\\\w\\\\-]+\\\\.[\\\\w\\\\-]+$': {\n        $ref: '#/$defs/userState',\n      },\n    },\n    additionalProperties: false,\n  },\n  userState: {\n    description: \"A description of an extension's user state entry\",\n    anyOf: [\n      {\n        $ref: '#/$defs/extensionControlledState',\n      },\n    ],\n  },\n  extensionControlledState: {\n    description: 'State definition that is validated by the extension.',\n    allOf: [\n      {\n        $ref: '#/$defs/stateBase',\n      },\n      {\n        $ref: '#/$defs/modifierExtensionControlled',\n      },\n    ],\n  },\n  modifierExtensionControlled: {\n    description:\n      'Modifies state/setting type to be extension-controlled. \"Extension-controlled\" means the extension provides the component and the validator for the state/setting, so the state/setting is controlled by the extension.',\n    not: {\n      anyOf: [\n        {\n          type: 'object',\n          required: ['platformType'],\n        },\n        {\n          type: 'object',\n          required: ['type'],\n        },\n      ],\n    },\n  },\n  stateBase: {\n    description: 'Base information needed to describe a state entry',\n    type: 'object',\n    properties: {\n      default: {\n        description: 'default value for the state/setting',\n        type: 'any',\n      },\n      derivesFrom: {\n        description:\n          \"a state/setting ID whose value to set to this state/setting's starting value the first time this state/setting is loaded\",\n        $ref: '#/$defs/id',\n      },\n    },\n    required: ['default'],\n  },\n  localizeKey: {\n    description: \"Identifier for a string that will be localized based on the user's UI language\",\n    type: 'string',\n    pattern: '^%[\\\\w\\\\-\\\\.]+%$',\n    tsType: 'LocalizeKey',\n  },\n  id: {\n    description: '',\n    type: 'string',\n    pattern: '^[\\\\w\\\\-]+\\\\.[\\\\w\\\\-]+$',\n    tsType: 'Id',\n  },\n};\n\n/**\n * Json-schema-to-typescript has some added stuff that isn't actually compatible with JSON schema,\n * so we remove them here\n *\n * @param defs The `$defs` property of a JSON schema (will be modified in place)\n */\n// JSON schema types are weird, so we'll just be careful\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function removeJsonToTypeScriptTypesStuff(defs: any) {\n  if (!defs) return;\n\n  // JSON schema types are weird, so we'll just be careful\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Object.values(defs).forEach((def: any) => {\n    if (!def.type) return;\n\n    if ('tsType' in def) delete def.tsType;\n\n    if (def.type === 'any') {\n      delete def.type;\n      return;\n    }\n\n    if (def.type === 'object') {\n      removeJsonToTypeScriptTypesStuff(def.properties);\n    }\n  });\n}\n\nremoveJsonToTypeScriptTypesStuff(settingsDefs);\n\n/** JSON schema object that aligns with the ProjectSettingsContribution type */\nexport const projectSettingsDocumentSchema = {\n  $schema: 'https://json-schema.org/draft/2020-12/schema',\n  title: 'Project Settings Contribution',\n  description:\n    'The data an extension provides to inform Platform.Bible of the project settings it provides',\n  anyOf: [\n    {\n      $ref: '#/$defs/projectSettingsGroup',\n    },\n    {\n      type: 'array',\n      items: {\n        $ref: '#/$defs/projectSettingsGroup',\n      },\n    },\n  ],\n\n  $defs: settingsDefs,\n};\n\nObject.freeze(projectSettingsDocumentSchema);\n\n/** JSON schema object that aligns with the {@link SettingsContribution} type */\nexport const settingsDocumentSchema = {\n  $schema: 'https://json-schema.org/draft/2020-12/schema',\n  title: 'Settings Contribution',\n  description:\n    'The data an extension provides to inform Platform.Bible of the settings it provides',\n  anyOf: [\n    {\n      $ref: '#/$defs/settingsGroup',\n    },\n    {\n      type: 'array',\n      items: {\n        $ref: '#/$defs/settingsGroup',\n      },\n    },\n  ],\n\n  $defs: settingsDefs,\n};\n\nObject.freeze(settingsDocumentSchema);\n","//----------------------------------------------------------------------------------------------\n// NOTE: If you change any of the types, make sure the JSON schema at the end of this file gets\n// changed so they align.\n//----------------------------------------------------------------------------------------------\n\nimport { LocalizeKey } from './menus.model';\nimport { removeJsonToTypeScriptTypesStuff } from './settings.model';\n\n/** Localized string value associated with this key */\nexport type LocalizedStringValue = string;\n/**\n * Date in YYYY-MM-DD format\n *\n * Use regex `^\\d\\d\\d\\d-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$` to test.\n *\n * Thanks to Vinod at https://stackoverflow.com/a/22061879 for the regex.\n */\nexport type DateYYYYMMDD = `${number}-${number}-${number}`;\n\n/** The data an extension provides to inform Platform.Bible of the localized strings it provides. */\nexport interface LocalizedStringDataContribution {\n  [k: string]: unknown;\n  metadata?: StringsMetadata;\n  localizedStrings?: {\n    [k: string]: LanguageStrings;\n  };\n}\n/**\n * Map whose keys are localized string keys and whose values provide additional non-locale-specific\n * information about the localized string key\n */\nexport interface StringsMetadata {\n  [k: LocalizeKey]: StringMetadata;\n}\n/** Additional non-locale-specific information about a localized string key */\nexport interface StringMetadata {\n  [k: string]: unknown;\n  /**\n   * Localized string key from which to get this value if one does not exist in the specified\n   * language. If a new key/value pair needs to be made to replace an existing one, this could help\n   * smooth over the transition if the meanings are close enough\n   *\n   * You can use Paratext 9 Localized String Keys here. Be sure to escape any % signs with a\n   * backslash `\\`.\n   */\n  fallbackKey?: LocalizeKey;\n  /**\n   * Additional information provided by developers in English to help the translator to know how to\n   * translate this localized string accurately\n   */\n  notes?: string;\n  /**\n   * If this property is filled, the localized string is deprecated. Contains information about the\n   * deprecation.\n   */\n  deprecationInfo?: LocalizedStringDeprecationInfo;\n}\n/**\n * Contains information about the deprecation of a localized string key, including the date of\n * deprecation and the reason.\n */\nexport interface LocalizedStringDeprecationInfo {\n  [k: string]: unknown;\n  /**\n   * Date of deprecation. Must be in YYYY-MM-DD format e.g. 2024-11-13.\n   *\n   * Tested against regex `^\\d\\d\\d\\d-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$`.\n   *\n   * Thanks to Vinod at https://stackoverflow.com/a/22061879 for the regex.\n   */\n  date: DateYYYYMMDD;\n  /**\n   * Should contain the reason for deprecation and what to use instead in what contexts.\n   *\n   * @example Reworded to clarify the meaning. Use %my_key_2% instead.\n   */\n  message: string;\n}\n/**\n * Map whose keys are localized string keys and whose values provide information about how to\n * localize strings for the localized string key\n */\nexport interface LanguageStrings {\n  [k: LocalizeKey]: LocalizedStringValue;\n}\n\n//----------------------------------------------------------------------------------------------\n// NOTE: If you change the schema below, make sure the TS types above get changed so they align.\n//----------------------------------------------------------------------------------------------\n\nconst localizedStringsDefs = {\n  languageStrings: {\n    description:\n      'Map whose keys are localized string keys and whose values provide information about how to localize strings for the localized string key',\n    type: 'object',\n    patternProperties: {\n      '^%[\\\\w\\\\-\\\\.]+%$': {\n        $ref: '#/$defs/localizedStringValue',\n      },\n    },\n    additionalProperties: false,\n  },\n  localizedStringValue: {\n    description: 'Localized string value associated with this key',\n    type: 'string',\n  },\n  stringsMetadata: {\n    description:\n      'Map whose keys are localized string keys and whose values provide additional non-locale-specific information about the localized string key',\n    type: 'object',\n    patternProperties: {\n      '^%[\\\\w\\\\-\\\\.]+%$': {\n        $ref: '#/$defs/stringMetadata',\n      },\n    },\n    additionalProperties: false,\n  },\n  stringMetadata: {\n    description: 'Additional non-locale-specific information about a localized string key',\n    type: 'object',\n    properties: {\n      fallbackKey: {\n        description:\n          'Localized string key from which to get this value if one does not exist in the specified language. If a new key/value pair needs to be made to replace an existing one, this could help smooth over the transition if the meanings are close enough.\\nYou can use Paratext 9 Localized String Keys here. Be sure to escape any % signs with a backslash `\\\\`.',\n        type: 'string',\n        pattern: \"^%[\\\\w\\\\-\\\\.;&,' (){}#:/\\\\\\\\?%⋮|[\\\\]“”‘’!~*\\u00A0+=•`…\\u200B↑↓]+%$\",\n        tsType: 'LocalizeKey',\n      },\n      notes: {\n        description:\n          'Additional information provided by developers in English to help the translator to know how to translate this localized string accurately',\n        type: 'string',\n      },\n      deprecationInfo: {\n        description:\n          'If this property is filled, the localized string is deprecated. Contains information about the deprecation.',\n        $ref: '#/$defs/localizedStringDeprecationInfo',\n      },\n    },\n  },\n  localizedStringDeprecationInfo: {\n    description:\n      'Date of deprecation, the reason for deprecation, and what to use instead in what contexts',\n    type: 'object',\n    properties: {\n      date: {\n        description:\n          'Date of deprecation. Must be in YYYY-MM-DD format e.g. 2024-11-13.\\n\\nTested against regex `^\\\\d\\\\d\\\\d\\\\d-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$`.\\n\\nThanks to Vinod at https://stackoverflow.com/a/22061879 for the regex.',\n        type: 'string',\n        pattern: '^\\\\d\\\\d\\\\d\\\\d-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$',\n        tsType: 'DateYYYYMMDD',\n      },\n      message: {\n        description:\n          'Should contain the reason for deprecation and what to use instead in what contexts.\\n\\n@example Reworded to clarify the meaning. Use %my_key_2% instead.',\n        type: 'string',\n      },\n    },\n    required: ['date', 'message'],\n  },\n  localizeKey: {\n    description: \"Identifier for a string that will be localized based on the user's UI language\",\n    type: 'string',\n    pattern: '^%[\\\\w\\\\-\\\\.]+%$',\n    tsType: 'LocalizeKey',\n  },\n};\n\nremoveJsonToTypeScriptTypesStuff(localizedStringsDefs);\n\n/** JSON schema object that aligns with the LocalizedStringDataContribution type */\nexport const localizedStringsDocumentSchema = {\n  $schema: 'https://json-schema.org/draft/2020-12/schema',\n  title: 'Localized String Data Contribution',\n  description:\n    'The data an extension provides to inform Platform.Bible of the localized strings it provides.',\n  type: 'object',\n  properties: {\n    metadata: {\n      $ref: '#/$defs/stringsMetadata',\n    },\n    localizedStrings: {\n      type: 'object',\n      additionalProperties: {\n        $ref: '#/$defs/languageStrings',\n      },\n    },\n  },\n  $defs: localizedStringsDefs,\n};\n\nObject.freeze(localizedStringsDocumentSchema);\n","//----------------------------------------------------------------------------------------------\n// NOTE: If you change any of the types, make sure the JSON schema at the end of this file gets\n// changed so they align.\n//----------------------------------------------------------------------------------------------\n\nimport { ReplaceType } from '../util';\n\n/** Identifier for a string that will be localized in a menu based on the user's UI language */\nexport type LocalizeKey = `%${string}%`;\n\n/** Name of some UI element (i.e., tab, column, group, menu item) or some PAPI object (i.e., command) */\nexport type ReferencedItem = `${string}.${string}`;\n\nexport type OrderedItem = {\n  /** Relative order of this item compared to other items in the same parent/scope (sorted ascending) */\n  order: number;\n};\n\nexport type OrderedExtensibleContainer = OrderedItem & {\n  /** Determines whether other items can be added to this after it has been defined */\n  isExtensible?: boolean;\n};\n\n/** Group of menu items that belongs in a column */\nexport type MenuGroupDetailsInColumn = OrderedExtensibleContainer & {\n  /** ID of column in which this group resides */\n  column: ReferencedItem;\n};\n\n/** Group of menu items that belongs in a submenu */\nexport type MenuGroupDetailsInSubMenu = OrderedExtensibleContainer & {\n  /** ID of menu item hosting the submenu in which this group resides */\n  menuItem: ReferencedItem;\n};\n\n/** Column that includes header text in a menu */\nexport type MenuColumnWithHeader = OrderedExtensibleContainer & {\n  /** Key that represents the text of the header text of the column */\n  label: LocalizeKey;\n};\n\nexport type MenuItemBase = OrderedItem & {\n  /** Menu group to which this menu item belongs */\n  group: ReferencedItem;\n  /** Key that represents the text of this menu item to display */\n  label: LocalizeKey;\n  /** Key that represents words the platform should reference when users are searching for menu items */\n  searchTerms?: LocalizeKey;\n  /** Key that represents the text to display if a mouse pointer hovers over the menu item */\n  tooltip?: LocalizeKey;\n  /** Additional information provided by developers to help people who perform localization */\n  localizeNotes: string;\n};\n\n/** Menu item that hosts a submenu */\nexport type MenuItemContainingSubmenu = MenuItemBase & {\n  /** ID for this menu item that holds a submenu */\n  id: ReferencedItem;\n};\n\n/** Menu item that runs a command */\nexport type MenuItemContainingCommand = MenuItemBase & {\n  /** Name of the PAPI command to run when this menu item is selected. */\n  command: ReferencedItem;\n  /**\n   * Uri path to the icon to display after the menu text. Ex:\n   * `papi-extension://helloWorld/assets/icon.png`\n   */\n  iconPathAfter?: string;\n  /**\n   * Uri path to the icon to display before the menu text. Ex:\n   * `papi-extension://helloWorld/assets/icon.png`\n   */\n  iconPathBefore?: string;\n};\n\n/**\n * Group of menu items that can be combined with other groups to form a single context menu/submenu.\n * Groups are separated using a line within the menu/submenu.\n */\nexport type GroupsInSingleColumnMenu = {\n  /** Named menu group */\n  [property: ReferencedItem]: OrderedExtensibleContainer | MenuGroupDetailsInSubMenu;\n};\n\n/**\n * Group of menu items that can be combined with other groups to form a single menu/submenu within a\n * multi-column menu. Groups are separated using a line within the menu/submenu.\n */\nexport type GroupsInMultiColumnMenu = {\n  /** Named menu group */\n  [property: ReferencedItem]: MenuGroupDetailsInColumn | MenuGroupDetailsInSubMenu;\n};\n\n/** Group of columns that can be combined with other columns to form a multi-column menu */\nexport type ColumnsWithHeaders = {\n  /** Named column of a menu */\n  [property: ReferencedItem]: MenuColumnWithHeader;\n  /** Defines whether columns can be added to this multi-column menu */\n  isExtensible?: boolean;\n};\n\n/** Menu that contains a column without a header */\nexport type SingleColumnMenu = {\n  /** Groups that belong in this menu */\n  groups: GroupsInSingleColumnMenu;\n  /** List of menu items that belong in this menu */\n  items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];\n};\n\n/** Menu that contains multiple columns with headers */\nexport type MultiColumnMenu = {\n  /** Columns that belong in this menu */\n  columns: ColumnsWithHeaders;\n  /** Groups that belong in this menu */\n  groups: GroupsInMultiColumnMenu;\n  /** List of menu items that belong in this menu */\n  items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];\n};\n\n/** Menus for one single web view */\nexport type WebViewMenu = {\n  /** Indicates whether the platform default menus should be included for this webview */\n  includeDefaults: boolean | undefined;\n  /** Menu that opens when you click on the top left corner of a tab */\n  topMenu: MultiColumnMenu | undefined;\n  /** Menu that opens when you right click on the main body/area of a tab */\n  contextMenu: SingleColumnMenu | undefined;\n};\n\n/** Menus for all web views */\nexport type WebViewMenus = {\n  /** Named web view */\n  [property: ReferencedItem]: WebViewMenu;\n};\n\n/** Platform.Bible menus before they are localized */\nexport type PlatformMenus = {\n  /** Top level menu for the application */\n  mainMenu: MultiColumnMenu;\n  /** Menus that apply per web view in the application */\n  webViewMenus: WebViewMenus;\n  /** Default context menu for web views that don't specify their own */\n  defaultWebViewContextMenu: SingleColumnMenu;\n  /** Default top menu for web views that don't specify their own */\n  defaultWebViewTopMenu: MultiColumnMenu;\n};\n\n/**\n * Type that converts any menu type before it is localized to what it is after it is localized. This\n * can be applied to any menu type as needed.\n */\nexport type Localized<T> = ReplaceType<ReplaceType<T, LocalizeKey, string>, ReferencedItem, string>;\n\n//----------------------------------------------------------------------------------------------\n// NOTE: If you change the schema below, make sure the TS types above get changed so they align.\n//----------------------------------------------------------------------------------------------\n/** JSON schema object that aligns with the PlatformMenus type */\nexport const menuDocumentSchema = {\n  title: 'Platform.Bible menus',\n  type: 'object',\n  properties: {\n    mainMenu: {\n      description: 'Top level menu for the application',\n      $ref: '#/$defs/multiColumnMenu',\n    },\n    defaultWebViewTopMenu: {\n      description: \"Default top menu for web views that don't specify their own\",\n      $ref: '#/$defs/multiColumnMenu',\n    },\n    defaultWebViewContextMenu: {\n      description: \"Default context menu for web views that don't specify their own\",\n      $ref: '#/$defs/singleColumnMenu',\n    },\n    webViewMenus: {\n      description: 'Menus that apply per web view in the application',\n      type: 'object',\n      patternProperties: {\n        '^[\\\\w\\\\-]+\\\\.[\\\\w\\\\-]+$': {\n          $ref: '#/$defs/menusForOneWebView',\n        },\n      },\n      additionalProperties: false,\n    },\n  },\n  required: ['mainMenu', 'defaultWebViewTopMenu', 'defaultWebViewContextMenu', 'webViewMenus'],\n  additionalProperties: false,\n  $defs: {\n    localizeKey: {\n      description:\n        \"Identifier for a string that will be localized in a menu based on the user's UI language\",\n      type: 'string',\n      pattern: '^%[\\\\w\\\\-\\\\.]+%$',\n    },\n    referencedItem: {\n      description:\n        'Name of some UI element (i.e., tab, column, group, menu item) or some PAPI object (i.e., command)',\n      type: 'string',\n      pattern: '^[\\\\w\\\\-]+\\\\.[\\\\w\\\\-]+$',\n    },\n    columnsWithHeaders: {\n      description:\n        'Group of columns that can be combined with other columns to form a multi-column menu',\n      type: 'object',\n      patternProperties: {\n        '^[\\\\w\\\\-]+\\\\.[\\\\w\\\\-]+$': {\n          description: 'Single column with a header string',\n          type: 'object',\n          properties: {\n            label: {\n              description: 'Header text for this this column in the UI',\n              $ref: '#/$defs/localizeKey',\n            },\n            localizeNotes: {\n              description:\n                'Additional information provided by developers to help people who perform localization',\n              type: 'string',\n            },\n            order: {\n              description:\n                'Relative order of this column compared to other columns (sorted ascending)',\n              type: 'number',\n            },\n            isExtensible: {\n              description:\n                'Defines whether contributions are allowed to add menu groups to this column',\n              type: 'boolean',\n            },\n          },\n          required: ['label', 'order'],\n          additionalProperties: false,\n        },\n      },\n      properties: {\n        isExtensible: {\n          description:\n            'Defines whether contributions are allowed to add columns to this multi-column menu',\n          type: 'boolean',\n        },\n      },\n    },\n    menuGroups: {\n      description:\n        'Group of menu items that can be combined with other groups to form a single menu/submenu. Groups are separated using a line within the menu/submenu.',\n      type: 'object',\n      patternProperties: {\n        '^[\\\\w\\\\-]+\\\\.[\\\\w\\\\-]+$': {\n          description: 'Single group that contains menu items',\n          type: 'object',\n          oneOf: [\n            {\n              properties: {\n                column: {\n                  description:\n                    'Column where this group belongs, not required for single column menus',\n                  $ref: '#/$defs/referencedItem',\n                },\n                order: {\n                  description:\n                    'Relative order of this group compared to other groups in the same column or submenu (sorted ascending)',\n                  type: 'number',\n                },\n                isExtensible: {\n                  description:\n                    'Defines whether contributions are allowed to add menu items to this menu group',\n                  type: 'boolean',\n                },\n              },\n              required: ['order'],\n              additionalProperties: false,\n            },\n            {\n              properties: {\n                menuItem: {\n                  description: 'Menu item that anchors the submenu where this group belongs',\n                  $ref: '#/$defs/referencedItem',\n                },\n                order: {\n                  description:\n                    'Relative order of this group compared to other groups in the same column or submenu (sorted ascending)',\n                  type: 'number',\n                },\n                isExtensible: {\n                  description:\n                    'Defines whether contributions are allowed to add menu items to this menu group',\n                  type: 'boolean',\n                },\n              },\n              required: ['menuItem', 'order'],\n              additionalProperties: false,\n            },\n          ],\n        },\n      },\n      additionalProperties: false,\n    },\n    menuItem: {\n      description:\n        'Single item in a menu that can be clicked on to take an action or can be the parent of a submenu',\n      type: 'object',\n      oneOf: [\n        {\n          properties: {\n            id: {\n              description: 'ID for this menu item that holds a submenu',\n              $ref: '#/$defs/referencedItem',\n            },\n          },\n          required: ['id'],\n        },\n        {\n          properties: {\n            command: {\n              description: 'Name of the PAPI command to run when this menu item is selected.',\n              $ref: '#/$defs/referencedItem',\n            },\n            iconPathBefore: {\n              description:\n                'Uri path to the icon to display before the menu text. Ex: `papi-extension://helloWorld/assets/icon.png`',\n              type: 'string',\n            },\n            iconPathAfter: {\n              description:\n                'Uri path to the icon to display after the menu text. Ex: `papi-extension://helloWorld/assets/icon.png`',\n              type: 'string',\n            },\n          },\n          required: ['command'],\n        },\n      ],\n      properties: {\n        label: {\n          description: 'Key that represents the text of this menu item to display',\n          $ref: '#/$defs/localizeKey',\n        },\n        tooltip: {\n          description:\n            'Key that represents the text to display if a mouse pointer hovers over the menu item',\n          $ref: '#/$defs/localizeKey',\n        },\n        searchTerms: {\n          description:\n            'Key that represents additional words the platform should reference when users are searching for menu items',\n          $ref: '#/$defs/localizeKey',\n        },\n        localizeNotes: {\n          description:\n            'Additional information provided by developers to help people who perform localization',\n          type: 'string',\n        },\n        group: {\n          description: 'Group to which this menu item belongs',\n          $ref: '#/$defs/referencedItem',\n        },\n        order: {\n          description:\n            'Relative order of this menu item compared to other menu items in the same group (sorted ascending)',\n          type: 'number',\n        },\n      },\n      required: ['label', 'group', 'order'],\n      unevaluatedProperties: false,\n    },\n    groupsAndItems: {\n      description: 'Core schema for a column',\n      type: 'object',\n      properties: {\n        groups: {\n          description: 'Groups that belong in this menu',\n          $ref: '#/$defs/menuGroups',\n        },\n        items: {\n          description: 'List of menu items that belong in this menu',\n          type: 'array',\n          items: { $ref: '#/$defs/menuItem' },\n          uniqueItems: true,\n        },\n      },\n      required: ['groups', 'items'],\n    },\n    singleColumnMenu: {\n      description: 'Menu that contains a column without a header',\n      type: 'object',\n      allOf: [{ $ref: '#/$defs/groupsAndItems' }],\n      unevaluatedProperties: false,\n    },\n    multiColumnMenu: {\n      description: 'Menu that can contain multiple columns with headers',\n      type: 'object',\n      allOf: [\n        { $ref: '#/$defs/groupsAndItems' },\n        {\n          properties: {\n            columns: {\n              description: 'Columns that belong in this menu',\n              $ref: '#/$defs/columnsWithHeaders',\n            },\n          },\n          required: ['columns'],\n        },\n      ],\n      unevaluatedProperties: false,\n    },\n    menusForOneWebView: {\n      description: 'Set of menus that are associated with a single tab',\n      type: 'object',\n      properties: {\n        includeDefaults: {\n          description:\n            'Indicates whether the platform default menus should be included for this webview',\n          type: 'boolean',\n        },\n        topMenu: {\n          description: 'Menu that opens when you click on the top left corner of a tab',\n          $ref: '#/$defs/multiColumnMenu',\n        },\n        contextMenu: {\n          description: 'Menu that opens when you right click on the main body/area of a tab',\n          $ref: '#/$defs/singleColumnMenu',\n        },\n      },\n      additionalProperties: false,\n    },\n  },\n};\n\nObject.freeze(menuDocumentSchema);\n","//----------------------------------------------------------------------------------------------\n// NOTE: If you change any of the types, make sure the JSON schema at the end of this file gets\n// changed so they align.\n//----------------------------------------------------------------------------------------------\n\nimport { removeJsonToTypeScriptTypesStuff } from './settings.model';\nimport { LocalizeKey } from './menus.model';\n\n/** The data an extension provides to inform Platform.Bible of the themes it provides. */\nexport type ThemeContribution = ThemeFamiliesById;\n\n/** Object whose keys are theme family ids and whose values are {@link ThemeFamily}. */\nexport interface ThemeFamiliesById {\n  [themeFamilyId: string]: ThemeFamily | undefined;\n}\n\n/**\n * A group of related themes. Each key is a theme type, and each value is a {@link ThemeDefinition}.\n *\n * A theme type indicates the kind of theme (e.g. light, dark). Some UI elements use the theme type\n * to determine how to look. Colors not present in the theme will fall back to the built-in colors\n * for this type.\n */\nexport interface ThemeFamily {\n  [themeType: string]: ThemeDefinition | undefined;\n  light?: ThemeDefinition;\n  dark?: ThemeDefinition;\n}\n\n/**\n * The data an extension provides for one individual theme. Each theme has a type (e.g. light, dark)\n * and belongs to a theme family. An extension can provide multiple themes with\n * {@link ThemeContribution}.\n */\nexport interface ThemeDefinition {\n  [k: string]: unknown;\n  /** LocalizeKey that is the display name for the theme */\n  label: LocalizeKey;\n  /**\n   * Theme colors and other CSS variable properties that adjust the looks of the application. These\n   * are applied in CSS properties using `hsl(var(--variableName))` or Tailwind classes like\n   * `tw-bg-primary`\n   *\n   * See the wiki's [Matching Application\n   * Theme](https://github.com/paranext/paranext-extension-template/wiki/Extension-Anatomy#matching-application-theme)\n   * section for more information.\n   */\n  cssVariables: ThemeCssVariables;\n}\n/**\n * Theme colors and other CSS variable properties that adjust the looks of the application. These\n * are applied in CSS properties using `hsl(var(--variableName))` or Tailwind classes like\n * `tw-bg-primary`\n *\n * See the wiki's [Matching Application\n * Theme](https://github.com/paranext/paranext-extension-template/wiki/Extension-Anatomy#matching-application-theme)\n * section for more information.\n */\nexport interface ThemeCssVariables {\n  [variableName: string]: string | undefined;\n  background?: string;\n  foreground?: string;\n  card?: string;\n  'card-foreground'?: string;\n  popover?: string;\n  'popover-foreground'?: string;\n  primary?: string;\n  'primary-foreground'?: string;\n  secondary?: string;\n  'secondary-foreground'?: string;\n  muted?: string;\n  'muted-foreground'?: string;\n  accent?: string;\n  'accent-foreground'?: string;\n  destructive?: string;\n  'destructive-foreground'?: string;\n  border?: string;\n  input?: string;\n  ring?: string;\n  'sidebar-background'?: string;\n  'sidebar-foreground'?: string;\n  'sidebar-primary'?: string;\n  'sidebar-primary-foreground'?: string;\n  'sidebar-accent'?: string;\n  'sidebar-accent-foreground'?: string;\n  'sidebar-border'?: string;\n  'sidebar-ring'?: string;\n  radius?: string;\n}\n\nconst themeDefs = {\n  themeCssVariables: {\n    description:\n      \"Theme colors and other CSS variable properties that adjust the looks of the application. These are applied in CSS properties using `hsl(var(--variableName))` or Tailwind classes like `tw-bg-primary`\\n\\nSee the wiki's [Matching Application Theme](https://github.com/paranext/paranext-extension-template/wiki/Extension-Anatomy#matching-application-theme) section for more information.\",\n    type: 'object',\n    properties: {\n      background: { type: 'string' },\n      foreground: { type: 'string' },\n      card: { type: 'string' },\n      'card-foreground': { type: 'string' },\n      popover: { type: 'string' },\n      'popover-foreground': { type: 'string' },\n      primary: { type: 'string' },\n      'primary-foreground': { type: 'string' },\n      secondary: { type: 'string' },\n      'secondary-foreground': { type: 'string' },\n      muted: { type: 'string' },\n      'muted-foreground': { type: 'string' },\n      accent: { type: 'string' },\n      'accent-foreground': { type: 'string' },\n      destructive: { type: 'string' },\n      'destructive-foreground': { type: 'string' },\n      border: { type: 'string' },\n      input: { type: 'string' },\n      ring: { type: 'string' },\n      'sidebar-background': { type: 'string' },\n      'sidebar-foreground': { type: 'string' },\n      'sidebar-primary': { type: 'string' },\n      'sidebar-primary-foreground': { type: 'string' },\n      'sidebar-accent': { type: 'string' },\n      'sidebar-accent-foreground': { type: 'string' },\n      'sidebar-border': { type: 'string' },\n      'sidebar-ring': { type: 'string' },\n      radius: { type: 'string' },\n    },\n    additionalProperties: { anyOf: [{ type: 'string' }, { type: 'null' }] },\n  },\n  themeDefinition: {\n    description:\n      'The data an extension provides for one individual theme. Each theme has a type (e.g. light, dark) and belongs to a theme family. An extension can provide multiple themes with {@link ThemeContribution}.',\n    type: 'object',\n    properties: {\n      label: {\n        description: 'LocalizeKey that is the display name for the theme',\n        type: 'string',\n        pattern: '^%[\\\\w\\\\-\\\\.]+%$',\n        tsType: 'LocalizeKey',\n      },\n      cssVariables: {\n        $ref: '#/$defs/themeCssVariables',\n      },\n    },\n    required: ['label', 'cssVariables'],\n  },\n  themeFamily: {\n    description:\n      'A group of related themes. Each key is a theme type, and each value is a {@link ThemeDefinition}.\\n\\nA theme type indicates the kind of theme (e.g. light, dark). Some UI elements use the theme type to determine how to look. Colors not present in the theme will fall back to the built-in colors for this type.',\n    type: 'object',\n    properties: {\n      light: {\n        $ref: '#/$defs/themeDefinition',\n      },\n      dark: {\n        $ref: '#/$defs/themeDefinition',\n      },\n    },\n    additionalProperties: {\n      anyOf: [\n        {\n          $ref: '#/$defs/themeDefinition',\n        },\n        { type: 'null' },\n      ],\n    },\n  },\n  themeFamiliesById: {\n    description: 'Object whose keys are theme family ids and whose values are {@link ThemeFamily}.',\n    type: 'object',\n    additionalProperties: {\n      anyOf: [\n        {\n          $ref: '#/$defs/themeFamily',\n        },\n        { type: 'null' },\n      ],\n    },\n  },\n};\n\nremoveJsonToTypeScriptTypesStuff(themeDefs);\n\n/** JSON schema object for ThemeContribution */\nexport const themeDocumentSchema = {\n  $schema: 'https://json-schema.org/draft/2020-12/schema',\n  title: 'Theme Contribution',\n  description: 'The data an extension provides to inform Platform.Bible of the themes it provides.',\n  anyOf: [\n    {\n      $ref: '#/$defs/themeFamiliesById',\n    },\n  ],\n  $defs: themeDefs,\n};\n\nObject.freeze(themeDocumentSchema);\n","import { ReplaceType } from '../util';\nimport { ThemeDefinition, ThemeFamiliesById, ThemeFamily } from './theme.model';\n\n/**\n * {@link ThemeDefinition} with some additional properties derived from the {@link ThemeFamiliesById}\n * it comes from to help with managing the theme\n */\nexport type ThemeDefinitionExpanded = ThemeDefinition & {\n  /**\n   * Unique identifier for the {@link ThemeFamily} this theme is in.\n   *\n   * This is derived from the key of the {@link ThemeFamiliesById} this theme is in\n   */\n  themeFamilyId: string;\n  /**\n   * The kind of theme (e.g. light, dark). Some UI elements use the theme type to determine how to\n   * look. Colors not present in the theme will fall back to the built-in colors for this type.\n   *\n   * This is derived from the key of the {@link ThemeFamily} this theme is in\n   */\n  type: string;\n  /**\n   * Unique identifier for this theme.\n   *\n   * This is derived by combining the theme family and type\n   */\n  id: string;\n};\n\n/**\n * Replaces {@link ThemeDefinition} with {@link ThemeDefinitionExpanded} recursively in the provided\n * type. Modifies the type to what is used in the theme service.\n */\nexport type ExpandThemeDefinition<T> = ReplaceType<T, ThemeDefinition, ThemeDefinitionExpanded>;\n\n/**\n * {@link ThemeFamily} with all {@link ThemeDefinition} replaced by {@link ThemeDefinitionExpanded}.\n * This is used in the theme service\n */\nexport type ThemeFamilyExpanded = ExpandThemeDefinition<ThemeFamily>;\n\n/**\n * {@link ThemeFamiliesById} with all {@link ThemeDefinition} replaced by\n * {@link ThemeDefinitionExpanded}. This is used in the theme service\n */\nexport type ThemeFamiliesByIdExpanded = ExpandThemeDefinition<ThemeFamiliesById>;\n\n/** ID for the style element the theme styles should go into */\nexport const THEME_STYLE_ELEMENT_ID = 'theme-styles';\n\nfunction getThemeId(themeFamilyId: string, type: string) {\n  return `${themeFamilyId ? `${themeFamilyId}-` : ''}${type}`;\n}\n\n/**\n * Add the derived properties in {@link ThemeDefinitionExpanded} to {@link ThemeDefinition}s in the\n * given {@link ThemeFamiliesById} and fill in any missing `cssVariables` in the theme definitions\n * with those from the default themes.\n *\n * Does not modify the input object.\n *\n * @param themeFamiliesById Theme families to expand with the additional derived properties\n * @param defaultThemeFamily If provided, themes from this family are used to fill in missing\n *   `cssVariables` in the theme definitions to make sure each theme definition has all necessary\n *   `cssVariables`\n * @returns The expanded theme families\n */\nexport function expandThemeContribution(\n  themeFamiliesById: ThemeFamiliesById,\n  defaultThemeFamily: ThemeFamily | undefined,\n): ThemeFamiliesByIdExpanded {\n  const themeFamiliesByIdExpanded: ThemeFamiliesByIdExpanded = Object.fromEntries(\n    Object.entries(themeFamiliesById)\n      .map(([themeFamilyId, themeFamily]) => [\n        themeFamilyId,\n        themeFamily\n          ? Object.fromEntries(\n              Object.entries(themeFamily)\n                .map(([type, themeDefinition]): [string, ThemeDefinitionExpanded | undefined] => [\n                  type,\n                  themeDefinition\n                    ? {\n                        ...themeDefinition,\n                        // Add the derived properties\n                        themeFamilyId,\n                        type,\n                        id: getThemeId(themeFamilyId, type),\n                        cssVariables: {\n                          // Fill in the default css variables\n                          ...defaultThemeFamily?.[type]?.cssVariables,\n                          ...themeDefinition.cssVariables,\n                        },\n                      }\n                    : undefined,\n                ])\n                .filter(([, themeDefinition]) => !!themeDefinition),\n            )\n          : undefined,\n      ])\n      .filter(([, themeFamily]) => !!themeFamily),\n  );\n  return themeFamiliesByIdExpanded;\n}\n\n/** Gets the CSS stylesheet that should be applied for the given theme */\nexport function getStylesheetForTheme(theme: ThemeDefinitionExpanded): string {\n  return `\n.${theme.id} {\n${Object.entries(theme.cssVariables)\n  .map(([variableName, value]) => `  --${variableName}: ${value};`)\n  .join('\\n')}\n}\n`;\n}\n\n/**\n * Applies a CSS stylesheet for the provided theme to the current window\n *\n * WARNING: THIS MUST BE BOUND TO `window` IN ORDER TO USE!\n *\n * ```ts\n * applyThemeStylesheet.bind(window)()`\n * ```\n *\n * @param theme Theme to apply\n * @param previousStyleElement Previous style element if applicable\n * @param styleElementIdSuffix Suffix to apply to the ID of the new style element. Will be\n *   {@link THEME_STYLE_ELEMENT_ID} with a dash and the suffix added to it\n * @returns\n */\n// Must use `this` so it works across iframes\nexport function applyThemeStylesheet(\n  this: Window,\n  theme: ThemeDefinitionExpanded,\n  previousStyleElement?: HTMLStyleElement,\n  styleElementIdSuffix?: string,\n): HTMLStyleElement {\n  // Set the class on the body\n  const previousThemeId = previousStyleElement?.dataset.themeId;\n  if (previousThemeId) this.document.body.classList.remove(previousThemeId);\n  this.document.body.classList.add(theme.id);\n\n  // Set up the stylesheet element\n  if (previousStyleElement) this.document.head.removeChild(previousStyleElement);\n  const themeStyleElement = this.document.createElement('style');\n  themeStyleElement.id = `${THEME_STYLE_ELEMENT_ID}${styleElementIdSuffix ? `-${styleElementIdSuffix}` : ''}`;\n  themeStyleElement.dataset.themeId = theme.id;\n  themeStyleElement.textContent = getStylesheetForTheme(theme);\n  this.document.head.appendChild(themeStyleElement);\n  return themeStyleElement;\n}\n","/** WARNING: This file is generated in https://github.com/paranext/usfm-tools. Make changes there */\n\n/**\n * Information about a USFM marker that is just an attribute in USX/USJ. See {@link MarkerInfo} for\n * other kinds of markers.\n *\n * An attribute marker is a marker that adds information to a previous marker in USFM and is an\n * attribute on that previous marker instead in USX/USJ.\n *\n * @example\n *\n * `ca` and `cp` are attribute markers for `c`. `va` and `vp` are attribute markers for `v`. `cat`\n * is an attribute marker for `f`, `esb`, and more.\n *\n * Following is an example of using the `ca` and `cp` attribute markers in USFM:\n *\n * ```usfm\n * \\c 1 \\ca 2\\ca*\n * \\cp A\n * \\s1 This is a section header\n * ```\n *\n * The equivalent in USX would be:\n *\n * ```xml\n * <!-- prettier-ignore -->\n * <chapter number=\"1\" style=\"c\" altnumber=\"2\" pubnumber=\"A\" sid=\"GEN 1\" />\n * <para style=\"s1\">This is a section header</para>\n * ```\n */\nexport type AttributeMarkerInfo = NormalMarkerInfo & {\n  /**\n   * List of normal marker names for which this marker is an attribute marker.\n   *\n   * @example\n   *\n   * `ca` and `cp` are attribute markers for `c`. `isAttributeMarkerFor` would be `['c']` for both\n   * `ca` and `cp`.\n   */\n  isAttributeMarkerFor?: string[];\n  /**\n   * List of RegExp patterns matching marker names for which this marker is an attribute marker.\n   *\n   * @example\n   *\n   * Pretend `ex1` and `ex2` are attribute markers for markers matching RegExp `/test/`.\n   * `isAttributeMarkerForRegExp` would be `['test']` for both `ex1` and `ex2`.\n   */\n  isAttributeMarkerForRegExp?: string[];\n  /**\n   * The name of the USX/USJ attribute this attribute marker represents.\n   *\n   * @example\n   *\n   * `ca` is an attribute marker for `c` and represents the `altnumber` attribute on the `c` marker\n   * in USX/USJ. `attributeMarkerAttributeName` would be `altnumber` for the `ca` marker.\n   */\n  attributeMarkerAttributeName: string;\n  /**\n   * Whether there should be a structural space after the normal closing marker in output USFM if\n   * this marker is an attribute marker. If this marker is not an attribute marker, it should not\n   * have a structural space after the normal closing marker.\n   *\n   * This field should be ignored if {@link MarkersMap.isSpaceAfterAttributeMarkersContent} is `true`\n   * because this space is only supposed to be added in contexts in which the space here is\n   * structural. Otherwise we would be mistakenly adding content to the USFM.\n   *\n   * Note that, if {@link MarkersMap.isSpaceAfterAttributeMarkersContent} is `false` (which is the\n   * case according to spec), horizontal spaces after attribute markers are always considered\n   * structural; this property only indicates whether there should be a space after the attribute\n   * marker when outputting USFM as opposed to parsing it.\n   *\n   * If not present or `undefined`, defaults to `false`.\n   *\n   * @example\n   *\n   * According to specification, the `va` and `vp` attribute markers have a space after their normal\n   * closing markers:\n   *\n   * ```usfm\n   * \\p \\v 10 \\va 10 va\\va* \\vp 10 vp\\vp* Some verse text\n   * ```\n   *\n   * The verse text in this example is just \"Some verse text\" without a space at the start.\n   *\n   * However, when the `vp` marker is not an attribute marker, such as when it has markers in its\n   * contents, there should not be a structural space after the normal closing marker, and any space\n   * should be considered content:\n   *\n   * ```usfm\n   * \\p \\v 10 \\va 10 va\\va* \\vp \\+wj 10 vp\\+wj*\\vp* Some verse text.\n   * ```\n   *\n   * The verse text in this example is \" Some verse text\" including a space at the start.\n   *\n   * @example\n   *\n   * The `cat` attribute marker does not have a structural space after its normal closing marker:\n   *\n   * ```usfm\n   * \\f + \\cat category here\\cat*\\fr 1:2 \\ft Some footnote text\\f*\n   * ```\n   *\n   * The verse text in this example is just \"Some verse text\" without a space at the start.\n   */\n  hasStructuralSpaceAfterCloseAttributeMarker?: boolean;\n};\n\n/**\n * Information about a regular USFM/USX/USJ marker. See {@link MarkerInfo} for other kinds of\n * markers.\n */\nexport type NormalMarkerInfo = {\n  /**\n   * Which marker type the marker is. Determines how the marker is structured in the data such as\n   * what kind of mandatory whitespace is around the marker in USFM. See {@link MarkerTypeInfoBase}\n   * for information.\n   */\n  type: string;\n  /** Explanation of the meaning of this marker */\n  description?: string;\n  /**\n   * Which attribute can be provided without specifying the attribute name in USFM.\n   *\n   * A marker can have a default attribute only if it has zero or one non-optional attributes.\n   *\n   * An attribute can be provided with default syntax in the USFM only if it is the only attribute\n   * provided for the marker.\n   *\n   * @example\n   *\n   * A marker with a default attribute:\n   *\n   * ```usfm\n   * \\w stuff|thisIsTheLemmaDefaultAttribute\\w*\n   * ```\n   *\n   * @example\n   *\n   * A marker with multiple attributes (cannot use default attribute syntax):\n   *\n   * ```usfm\n   * \\w stuff|lemma=\"thisIsTheLemma\" strong=\"H1234,G1234\"\\w*\n   * ```\n   */\n  defaultAttribute?: string;\n  /**\n   * The name of the text content attribute that is present on this marker if this marker has text\n   * content in USFM.\n   *\n   * Text content attributes are attributes in USX/USJ that are represented in USFM as the actual\n   * text content of the marker.\n   *\n   * @example\n   *\n   * `alt` is a text content attribute on the `periph` marker. This value would be `alt` for the\n   * `periph` marker.\n   *\n   * Following is an example of a `periph` marker in USFM:\n   *\n   * ```usfm\n   * \\periph Example Peripheral|id=\"x-example\"\n   * \\p Some contents of the example peripheral\n   * ```\n   *\n   * The equivalent in USX would be:\n   *\n   * ```xml\n   * <!-- prettier-ignore -->\n   * <periph alt=\"Example Peripheral\" id=\"x-example\">\n   *   <para style=\"p\">Some contents of the example peripheral</para>\n   * </periph>\n   * ```\n   */\n  textContentAttribute?: string;\n  /**\n   * List of leading attributes that must be present on this marker. This list is ordered by the\n   * order in which the attributes should appear.\n   *\n   * Leading attributes are attributes in USJ/USX that are listed in USFM directly after the marker\n   * and separated only by a space.\n   *\n   * @example\n   *\n   * `code` is a leading attribute on the `id` marker. This value would be `['code']` for the `id`\n   * marker.\n   *\n   * Following is an example of an `id` marker in USFM:\n   *\n   * ```usfm\n   * \\id MAT 41MATEX.SFM, Example Translation, September 2025\n   * ```\n   *\n   * The equivalent in USX would be:\n   *\n   * ```xml\n   * <!-- prettier-ignore -->\n   * <book code=\"MAT\" style=\"id\">41MATEX.SFM, Example Translation, September 2025</book>\n   * ```\n   */\n  leadingAttributes?: string[];\n  /**\n   * List of attribute markers that may be present on this marker. This list is ordered by the order\n   * in which the markers should appear.\n   *\n   * An attribute marker is a marker that adds information to a previous marker in USFM and is an\n   * attribute on that previous marker in USX/USJ.\n   *\n   * Note: the attribute names for attribute markers may be different than the marker names. See\n   * {@link AttributeMarkerInfo.attributeMarkerAttributeName} for more information.\n   *\n   * @example\n   *\n   * `ca` and `cp` are attribute markers for `c`. This value would be `['ca', 'cp']` for `c`.\n   */\n  attributeMarkers?: string[];\n  /**\n   * Whether the normal closing marker for this marker is considered optional in USFM, meaning in\n   * some cases that the normal closing marker would be expected not to be present.\n   *\n   * If this marker's type has {@link CloseableMarkerTypeInfo.isCloseable} set to `true`, this marker\n   * may or may not be expected to have a normal closing marker actually present in USFM depending\n   * on the value of this property.\n   *\n   * - If this is `true`, the normal closing marker for this marker in USFM may be expected to be\n   *   present or absent depending on the value of\n   *   {@link MarkersMap.shouldOptionalClosingMarkersBePresent}. If\n   *   {@link MarkersMap.shouldOptionalClosingMarkersBePresent} is `true`, this marker is expected to\n   *   have the normal closing marker actually present in USFM just like markers for which this\n   *   property is `false`. If {@link MarkersMap.shouldOptionalClosingMarkersBePresent} is `false`,\n   *   this marker is expected not to have the normal closing marker actually present in USFM. The\n   *   `closed` attribute should be present if the presence of a normal closing marker for this\n   *   marker in USFM does not match the presence implied by\n   *   {@link MarkersMap.shouldOptionalClosingMarkersBePresent}.\n   * - If this is `false`, the normal closing marker for this marker in USFM is expected to always be\n   *   present. If the normal closing marker is absent in USFM, the USX/USJ for this marker should\n   *   have the attribute `closed` set to `false`.\n   *\n   * If this marker's type has {@link CloseableMarkerTypeInfo.isCloseable} set to `false`, this\n   * property is unused; markers of that type do not have a normal closing marker.\n   *\n   * If not present or `undefined`, defaults to `false`\n   */\n  isClosingMarkerOptional?: boolean;\n  /**\n   * List of independent closing marker names for this marker in USFM if it has any. If this is\n   * defined, this marker does not have a normal closing marker but rather is closed by a completely\n   * separate marker in USFM. All contents between this marker and the independent closing marker\n   * are contents of this marker. In USX and USJ, this marker is closed normally like any other\n   * object because USX and USJ have clear hierarchical structure.\n   *\n   * Note that independent closing markers do not have a `*` at the end because they are not normal\n   * closing marker for but rather are completely separate markers that close the corresponding\n   * opening marker.\n   *\n   * @example\n   *\n   * `esb` (a sidebar) is closed by the independent closing marker `esbe`.\n   * `independentClosingMarkers` would be `['esbe']` for `esb`. Following is an example of a\n   * sidebar:\n   *\n   * ```usfm\n   * \\esb\n   * \\p This paragraph is in a \\bd sidebar\\bd*.\n   * \\p The sidebar can contain multiple paragraphs.\n   * \\esbe\n   * ```\n   */\n  independentClosingMarkers?: string[];\n  /**\n   * List of marker names for which this marker is an independent closing marker. See\n   * {@link NormalMarkerInfo.independentClosingMarkers} for more information on independent closing\n   * markers and their syntax.\n   *\n   * @example\n   *\n   * `esbe` is an independent closing marker for `esb`. `isIndependentClosingMarkerFor` would be\n   * `['esb']` for `esbe`.\n   */\n  isIndependentClosingMarkerFor?: string[];\n  /**\n   * List of RegExp patterns matching marker names for which this marker is an independent closing\n   * marker. See {@link NormalMarkerInfo.independentClosingMarkers} for more information on\n   * independent closing markers and their syntax.\n   *\n   * @example\n   *\n   * Pretend `ex1` and `ex2` are independent closing markers for markers matching RegExp `/test/`.\n   * `isIndependentClosingMarkerForRegExp` would be `['test']` for both `ex1` and `ex2`.\n   */\n  isIndependentClosingMarkerForRegExp?: string[];\n  /**\n   * Marker to use when operating on the USFM representation of this marker. For example, when\n   * outputting to USFM, the marker info for the marker listed here in `markerUsfm` should be used\n   * instead of the marker info for the marker as listed in USX or USJ.\n   *\n   * @example\n   *\n   * When the `usx` marker is output to USFM, it should be transformed to the `usfm` marker.\n   */\n  markerUsfm?: string;\n  /**\n   * Instructions written in plain text regarding special handling required for this marker when\n   * transforming from USFM to USX or USJ. These instructions are an explanation of what needs to be\n   * done to this marker to properly transform it to USX or USJ.\n   *\n   * This property is generally only included when it is exceptionally difficult to parse a marker\n   * properly from USFM; the markers map attempts to use this property as little as possible,\n   * favoring encoding information in other properties for more automatic transformation instead.\n   */\n  parseUsfmInstructions?: string;\n};\n\n/**\n * Information about a USFM/USX/USJ marker that is essential for proper translation between formats.\n *\n * @example\n *\n * `w` is a `char`-type marker, so it shares the characteristics of the `char` {@link MarkerTypeInfo}\n * with other `char`-type markers and has its own set of characteristics. `w`'s `MarkerInfo` is as\n * follows:\n *\n * ```json\n * {\n *   \"type\": \"char\",\n *   \"defaultAttribute\": \"lemma\"\n * }\n * ```\n */\nexport type MarkerInfo = NormalMarkerInfo | AttributeMarkerInfo;\n\n/**\n * Information about a USFM/USX/USJ marker type that has a closing marker. See {@link MarkerTypeInfo}\n * for other kinds of marker types.\n *\n * If the marker type has a closing marker but the closing marker is not present in the USFM for a\n * marker with this marker type, the USX/USJ for the marker will have the attribute `closed` set to\n * `false` unless {@link NormalMarkerInfo.isClosingMarkerOptional} is `true`.\n *\n * @example\n *\n * `char` marker types such as `nd` markers have closing markers, but `para` markers such as `p` do\n * not:\n *\n * ```usfm\n * \\p This is a plain paragraph.\n * \\p This is a paragraph \\nd with some special text\\nd* in it.\n * ```\n */\nexport type CloseableMarkerTypeInfo = MarkerTypeInfoBase & {\n  /**\n   * Whether markers of this type can have a normal closing marker in USFM. This property concerns\n   * normal closing markers like `\\wj*`, not independent closing markers like\n   * {@link NormalMarkerInfo.independentClosingMarkers}, which are completely separate markers.\n   *\n   * If this is `true`, markers of this type _may_ have a normal closing marker present in USFM.\n   * Usually, markers whose type has `isCloseable` set to `true` are expected to have a normal\n   * closing marker actually present in USFM unless otherwise specified using the `closed`\n   * attribute. However, some markers are expected _not_ to have a normal closing marker actually\n   * present in USFM unless otherwise specified using the `closed` attribute. To determine whether a\n   * specific marker of this type is expected not to have a closing marker present in USFM, see\n   * {@link NormalMarkerInfo.isClosingMarkerOptional}.\n   *\n   * If this is `false`, markers of this type do not have a normal closing marker; there is never\n   * expected to be a normal closing marker in USFM for markers of this type. In this case,\n   * {@link NormalMarkerInfo.isClosingMarkerOptional} is unused.\n   *\n   * If not present or `undefined`, defaults to `false` (meaning this `MarkerTypeInfo` is a\n   * {@link NonCloseableMarkerTypeInfo}, not a {@link CloseableMarkerTypeInfo})\n   */\n  isCloseable: true;\n  /**\n   * Whether the closing marker for markers of this type is \"empty\" in USFM, meaning the marker name\n   * is absent from the closing marker. This also means that there should not be a structural space\n   * between the opening and the closing markers in USFM if there are no attributes listed on the\n   * marker.\n   *\n   * If not present or `undefined`, defaults to `false`\n   *\n   * @example\n   *\n   * Markers of type `ms` (such as `qt1-s` and `qt1-e`) have an empty closing marker:\n   *\n   * ```usfm\n   * \\qt1-s\\*\n   * ...\n   * \\qt1-e\\*\n   * ```\n   *\n   * The closing marker for `qt1-s` is `\\*` as opposed to the closing marker for `nd` which is\n   * `\\nd*`.\n   *\n   * Note that there is still a structural space after the opening marker if there are attributes\n   * present:\n   *\n   * ```usfm\n   * \\qt1-s |Someone\\*\n   * ...\n   * \\qt1-e\\*\n   * ```\n   */\n  isClosingMarkerEmpty?: boolean;\n};\n\n/**\n * Information about a USFM/USX/USJ marker type that does not have a closing marker. See\n * {@link MarkerTypeInfo} for other kinds of marker types.\n *\n * @example\n *\n * `char` marker types such as `nd` markers have closing markers, but `para` marker types such as\n * `p` do not:\n *\n * ```usfm\n * \\p This is a plain paragraph.\n * \\p This is a paragraph \\nd with some special text\\nd* in it.\n * ```\n */\nexport type NonCloseableMarkerTypeInfo = MarkerTypeInfoBase & {\n  /**\n   * Whether markers of this type can have a normal closing marker in USFM. This property concerns\n   * normal closing markers like `\\wj*`, not independent closing markers like\n   * {@link NormalMarkerInfo.independentClosingMarkers}, which are completely separate markers.\n   *\n   * If this is `true`, markers of this type _may_ have a normal closing marker present in USFM.\n   * Usually, markers whose type has `isCloseable` set to `true` are expected to have a normal\n   * closing marker actually present in USFM unless otherwise specified using the `closed`\n   * attribute. However, some markers are expected _not_ to have a normal closing marker actually\n   * present in USFM unless otherwise specified using the `closed` attribute. To determine whether a\n   * specific marker of this type is expected not to have a closing marker present in USFM, see\n   * {@link NormalMarkerInfo.isClosingMarkerOptional}.\n   *\n   * If this is `false`, markers of this type do not have a normal closing marker; there is never\n   * expected to be a normal closing marker in USFM for markers of this type. In this case,\n   * {@link NormalMarkerInfo.isClosingMarkerOptional} is unused.\n   *\n   * If not present or `undefined`, defaults to `false` (meaning this `MarkerTypeInfo` is a\n   * {@link NonCloseableMarkerTypeInfo}, not a {@link CloseableMarkerTypeInfo})\n   */\n  isCloseable?: false;\n};\n\n/**\n * Information about a USFM/USX/USJ marker type that is common to all marker types. See\n * {@link MarkerTypeInfo} for various kinds of marker types.\n */\nexport type MarkerTypeInfoBase = {\n  /** Explanation of the meaning of this marker type */\n  description?: string;\n  /**\n   * Whether markers of this type should have a `style` attribute in USX/USJ.\n   *\n   * If this is `false`, it also means the marker type is the same as the marker name.\n   *\n   * If not present or `undefined`, defaults to `true`.\n   */\n  hasStyleAttribute?: boolean;\n  /**\n   * List of attributes that should not be output to USFM on markers of this type.\n   *\n   * This is used for attributes that are not present in USFM.\n   *\n   * This property is not used when converting to USX or USJ.\n   *\n   * @example\n   *\n   * The `sid` attribute on the `verse` type marker is not present in USFM because it is derived\n   * metadata in USX/USJ and is not present in USFM.\n   */\n  skipOutputAttributeToUsfm?: string[];\n  /**\n   * List of attributes indicating whether to skip outputting this marker to USFM. If any of the\n   * listed attributes is present on the marker, skip outputting this marker when converting to\n   * USFM. Only skip outputting the opening and closing marker representations, though; the content\n   * inside the marker (if present) should not be skipped.\n   *\n   * This is used for certain markers that sometimes are normal markers but sometimes are derived\n   * metadata and are not present in USFM. These derived metadata markers are identified by whether\n   * they have specific attributes on them.\n   *\n   * This property is not used when converting to USX or USJ.\n   *\n   * @example\n   *\n   * If the `verse` marker has an `eid` attribute, it indicates it is a marker denoting the end of\n   * the verse that is derived metadata in USX/USJ and is not present in USFM. Note that the `verse`\n   * marker does not have the `style=\"v\"` attribute in this situation, so this list of attributes is\n   * on the marker type.\n   *\n   * Following is an example of a derived metadata `verse` marker in USX:\n   *\n   * ```xml\n   * <!-- prettier-ignore -->\n   * <para style=\"p\">\n   *   <verse number=\"21\" style=\"v\" sid=\"2SA 1:21\" />This is verse 21.<verse eid=\"2SA 1:21\" />\n   * </para>\n   * ```\n   *\n   * The equivalent in USFM would be:\n   *\n   * ```usfm\n   * \\p\n   * \\v 21 This is verse 21.\n   * ```\n   *\n   * @example\n   *\n   * Generated `ref`s should be skipped but have content inside the marker that should not be\n   * skipped. These `ref`s wrap project-localized Scripture references in `xt` markers and have\n   * computer-readable Scripture References as their `loc` attribute. These `ref`s that are derived\n   * metadata have the `gen` attribute set to `\"true\"` and can be removed if `gen=\"true\"` is\n   * present.\n   *\n   * Following is an example of a generated `ref` in USX:\n   *\n   * ```xml\n   * <!-- prettier-ignore -->\n   * <char style=\"xt\"><ref loc=\"2SA 1:1\" gen=\"true\">2Sam 1:1</ref>; <ref loc=\"2SA 1:2-3\">2Sam 1:2-3</ref>.</char>\n   * ```\n   *\n   * The equivalent in USFM would be:\n   *\n   * ```usfm\n   * \\xt 2Sam 1:1; 2Sam 1:2-3.\\xt*\n   * ```\n   */\n  skipOutputMarkerToUsfmIfAttributeIsPresent?: string[];\n  /**\n   * Whether to always skip outputting this marker when converting to USFM. Only skip outputting the\n   * opening and closing marker representations, though; the content inside the marker (if present)\n   * should not be skipped.\n   *\n   * This is used for marker types that have no representation in USFM in a given version, likely\n   * meaning they are derived metadata and are not present in USFM.\n   *\n   * This property is not used when converting to USX or USJ.\n   *\n   * If not present or `undefined`, defaults to `false`\n   *\n   * @example\n   *\n   * In USFM 3.1, the `table` marker type is generated while transforming USFM into USX/USJ and is\n   * not preserved when transforming from USX/USJ to USFM.\n   *\n   * Following is an example of a derived metadata `table` marker in USX:\n   *\n   * ```xml\n   * <!-- prettier-ignore -->\n   * <table>\n   *   <row style=\"tr\">\n   *     <cell style=\"th1\" align=\"start\">Header 1</cell>\n   *     <cell style=\"th2\" align=\"start\">Header 2 space after </cell>\n   *     <cell style=\"thc3\" align=\"center\" colspan=\"2\">Header 3-4 centered</cell>\n   *     <cell style=\"thr5\" align=\"end\">Header 5 right</cell>\n   *   </row>\n   *   <row style=\"tr\">\n   *     <cell style=\"tc1\" align=\"start\">Row 1 cell 1</cell>\n   *     <cell style=\"tc2\" align=\"start\">Row 1 cell 2 space after </cell>\n   *     <cell style=\"thc3\" align=\"center\">Row 1 cell 3 centered</cell>\n   *     <cell style=\"thr4\" align=\"end\" colspan=\"2\">Row 1 cell 4-5 right</cell>\n   *   </row>\n   *   <row style=\"tr\">\n   *     <cell style=\"tcr1\" align=\"end\" colspan=\"4\">Row 2 cell 1-4 right</cell>\n   *     <cell style=\"tc5\" align=\"start\">Row 2 cell 5</cell>\n   *   </row>\n   * </table>\n   * ```\n   *\n   * The equivalent in USFM would be:\n   *\n   * ```usfm\n   * \\tr \\th1 Header 1\\th2 Header 2 space after \\thc3-4 Header 3-4 centered\\thr5 Header 5 right\n   * \\tr \\tc1 Row 1 cell 1\\tc2 Row 1 cell 2 space after \\thc3 Row 1 cell 3 centered\\thr4-5 Row 1 cell 4-5 right\n   * \\tr \\tcr1-4 Row 2 cell 1-4 right\\tc5 Row 2 cell 5\n   * ```\n   */\n  skipOutputMarkerToUsfm?: boolean;\n  /**\n   * Whether markers of this type should have a newline before them in USFM.\n   *\n   * Note that the newline is never strictly necessary, and it is not usually present if the very\n   * first marker in the file (or in examples such as the following example) should have a newline.\n   *\n   * If not present or `undefined`, defaults to `false`\n   *\n   * @example\n   *\n   * `para` marker types such as `p` should have a newline, but `char` marker types such as `nd`\n   * markers should not:\n   *\n   * ```usfm\n   * \\p This is a plain paragraph.\n   * \\p This is a paragraph \\nd with some special text\\nd* in it.\n   * ```\n   */\n  hasNewlineBefore?: boolean;\n  /**\n   * Marker type to use when operating on the USFM representation of markers of this type. For\n   * example, when outputting to USFM, the marker type listed here in `markerTypeUsfm` should be\n   * used instead of the marker's type as listed in USX or USJ.\n   */\n  markerTypeUsfm?: string;\n  /**\n   * Marker type to use when operating on the USX representation of markers of this type. For\n   * example, when outputting to USX, the marker type listed here in `markerTypeUsx` should be used\n   * instead of the marker's type as listed in USFM or USJ.\n   */\n  markerTypeUsx?: string;\n  /**\n   * Marker type to use when operating on the USJ representation of markers of this type. For\n   * example, when outputting to USJ, the marker type listed here in `markerTypeUsj` should be used\n   * instead of the marker's type as listed in USFM or USX.\n   */\n  markerTypeUsj?: string;\n  /**\n   * Prefix to add to the opening and closing marker before the marker name if a marker of this type\n   * occurs within another marker of this type when outputting to USFM.\n   *\n   * @example\n   *\n   * In USFM 3.0, `char`-type markers that are nested must have a `+` prefix. Following is an\n   * example of `nd` inside `wj` (both are `char`-type markers) in USFM:\n   *\n   * ```usfm\n   * \\p \\wj This is \\+nd nested\\+nd*!\\wj*\n   * ```\n   */\n  nestedPrefix?: string;\n  /**\n   * Instructions written in plain text regarding special handling required for this marker type\n   * when transforming to USFM. These instructions are an explanation of what needs to be done to\n   * markers of this type to properly transform the marker to USFM.\n   *\n   * This property is generally only included when it is exceptionally difficult to output a marker\n   * properly to USFM; the markers map attempts to use this property as little as possible, favoring\n   * encoding information in other properties for more automatic transformation instead.\n   */\n  outputToUsfmInstructions?: string;\n  /**\n   * Instructions written in plain text regarding special handling required for this marker type\n   * when transforming from USFM to USX or USJ. These instructions are an explanation of what needs\n   * to be done to markers of this type to properly transform the marker to USX or USJ.\n   *\n   * This property is generally only included when it is exceptionally difficult to parse a marker\n   * properly from USFM; the markers map attempts to use this property as little as possible,\n   * favoring encoding information in other properties for more automatic transformation instead.\n   */\n  parseUsfmInstructions?: string;\n};\n\n/**\n * Information about a USFM/USX/USJ marker type that is essential for proper translation between\n * formats.\n *\n * @example\n *\n * `char` is a marker type, which means markers like `w` whose marker type is `char` share some\n * characteristics, and each marker also has its own set of characteristics which are presented with\n * type {@link MarkerInfo}. `char`'s `MarkerTypeInfo` is as follows:\n *\n * ```json\n * {\n *   \"isCloseable\": true,\n *   \"nestedPrefix\": \"+\"\n * }\n * ```\n */\nexport type MarkerTypeInfo = CloseableMarkerTypeInfo | NonCloseableMarkerTypeInfo;\n\n/** A map of all USFM/USX/USJ markers and some information about them */\nexport type MarkersMap = {\n  /** Which version of USFM/USX/USJ this map represents */\n  version: string;\n  /** Which repository this map came from. */\n  schemaRepo: string;\n  /**\n   * Which commit this map came from. This is necessary because the schema file seems to be\n   * distributed multiple times in one release version. As such, this specifies the exact version of\n   * the schema file.\n   */\n  schemaCommit: string;\n  /**\n   * Which version of the markers map types this markers map conforms to. Follows [Semantic\n   * versioning](https://semver.org/); the same major version contains no breaking changes.\n   */\n  markersMapVersion: `1.${number}.${number}${string}`;\n  /**\n   * Which tag or commit in the `https://github.com/paranext/usfm-tools` repo this map is generated\n   * from.\n   *\n   * Contains the output from `git tag --points-at HEAD` or `git rev-parse HEAD`\n   *\n   * Will also have a `+` at the end if there were working changes outside the `src/test-data`\n   * folder when this was generated.\n   */\n  usfmToolsCommit: string;\n  /**\n   * Whether any whitespace after attribute markers and before the next content is not just\n   * structural but should actually be considered part of the content of the marker.\n   *\n   * Structural whitespace is whitespace in the USFM that is required as part of the USFM syntax and\n   * usually acts as a delimiter between markers and other things. Content whitespace is whitespace\n   * in USFM that is part of the actual Scripture text or the \"content\" of the marker.\n   *\n   * According to specification, whitespace after attribute markers is not content but is just\n   * structural.\n   *\n   * According to Paratext 9.4, whitespace after attribute markers is content and is not just\n   * structural.\n   *\n   * This setting determines which interpretation to use when converting from USFM to USX/USJ.\n   *\n   * If not present or `undefined`, defaults to `false`.\n   */\n  isSpaceAfterAttributeMarkersContent?: boolean;\n  /**\n   * Whether markers with optional closing markers (see\n   * {@link NormalMarkerInfo.isClosingMarkerOptional}) should still be explicitly closed in USFM.\n   * That is, whether markers with optional closing markers still need the `closed` attribute set to\n   * `\"false\"` in USX/USJ if the closing marker is not present in USFM.\n   *\n   * In other words, this setting determines whether markers with optional closing markers should\n   * still be expected to be explicitly closed (meaning the closing marker is present in USFM) when\n   * transforming USX/USJ to USFM unless otherwise indicated by the `closed` attribute.\n   *\n   * If this is `true` (matches Paratext 9.4), markers with optional closing markers are treated\n   * like markers whose normal closing marker is not optional in that they are expected to be\n   * explicitly closed in USFM unless otherwise indicated:\n   *\n   * - If they are not explicitly closed in USFM, they should have `closed=\"false\"`\n   * - If they are explicitly closed in USFM, they do not need `closed=\"true\"`\n   *\n   * If this is `false` (matches specification), markers with optional closing markers are expected\n   * _not_ to be explicitly closed in USFM unless otherwise indicated:\n   *\n   * - If they are not explicitly closed in USFM, they do not need `closed=\"false\"`\n   * - If they are explicitly closed in USFM, they should have `closed=\"true\"`\n   *\n   *   - Disclaimer: It is not clear that `closed=\"true\"` should be present in this case according to\n   *       `usx.rng`; it seems `usx.rng` indicates that optional closing markers should never be\n   *       output to USFM. It is possible that `usx.rng` considers this to be a case where\n   *       preserving the exact USFM is not important.\n   *\n   * If not present or `undefined`, defaults to `false`.\n   */\n  shouldOptionalClosingMarkersBePresent?: boolean;\n  /**\n   * Map whose keys are the marker names and whose values are information about that marker\n   *\n   * If you find the marker name in this map, you do not need to search the `markersRegExp` map.\n   */\n  markers: Record<string, MarkerInfo | undefined>;\n  /**\n   * Map whose keys are string representations of `RegExp` patterns to match against marker names\n   * (using the\n   * [test](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)\n   * function) and whose values are information about that marker\n   *\n   * You do not need to search this map if you found the marker name in the `markers` map.\n   */\n  markersRegExp: Record<string, MarkerInfo | undefined>;\n  /** Map whose keys are the marker types and whose values are information about that marker type */\n  markerTypes: Record<string, MarkerTypeInfo | undefined>;\n};\n\n// This function should safely freeze anything, but TypeScript doesn't understand.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction deepFreeze(o: any) {\n  Object.freeze(o);\n  // Don't want to crash out on null\n  // eslint-disable-next-line no-null/no-null\n  if (o === undefined || o === null) {\n    return o;\n  }\n\n  Object.getOwnPropertyNames(o).forEach(function freezeProperty(prop) {\n    if (\n      // Need to make sure to avoid null, which is an object type\n      // eslint-disable-next-line no-null/no-null\n      o[prop] !== null &&\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n}\n\n/**\n * A map of all USFM/USX/USJ markers and some information about them. Generated from a `usx.rng`\n * file\n */\nexport const USFM_MARKERS_MAP: MarkersMap = deepFreeze({\n  version: '3.0.7',\n  schemaRepo: 'https://github.com/ubsicap/usx.git',\n  schemaCommit: '6c490bb5675d281b0fa01876fe67f6e3fd50a4ce',\n  markersMapVersion: '1.0.0',\n  usfmToolsCommit: '979b4d5cf16c04f6744fe1fc5c730807a8b90187',\n  markers: {\n    add: {\n      type: 'char',\n      description: 'For a translational addition to the text',\n    },\n    addpn: {\n      type: 'char',\n      description:\n        'For chinese words to be dot underline & underline (DEPRECATED - used nested char@style pn)',\n    },\n    b: {\n      type: 'para',\n      description: 'Poetry text stanza break (e.g. stanza break)',\n    },\n    bd: {\n      type: 'char',\n      description: 'A character style, use bold text',\n    },\n    bdit: {\n      type: 'char',\n      description: 'A character style, use bold + italic text',\n    },\n    bk: {\n      type: 'char',\n      description: 'For the quoted name of a book',\n    },\n    c: {\n      type: 'chapter',\n      leadingAttributes: ['number'],\n      attributeMarkers: ['ca', 'cp'],\n    },\n    ca: {\n      type: 'char',\n      attributeMarkerAttributeName: 'altnumber',\n      isAttributeMarkerFor: ['c'],\n      hasStructuralSpaceAfterCloseAttributeMarker: true,\n      description: 'Second (alternate) chapter number',\n    },\n    cat: {\n      type: 'char',\n      attributeMarkerAttributeName: 'category',\n      isAttributeMarkerFor: ['ef', 'efe', 'esb', 'ex', 'f', 'fe', 'x'],\n      description: 'Note category (study Bible)',\n    },\n    cd: {\n      type: 'para',\n      description: 'Chapter Description (Publishing option D, e.g. in Russian Bibles)',\n    },\n    cl: {\n      type: 'para',\n      description: 'Chapter label used for translations that add a word such as \"Chapter\"',\n    },\n    cls: {\n      type: 'para',\n      description: 'Closure of an Epistle',\n    },\n    cp: {\n      type: 'para',\n      description: 'Published chapter number',\n      attributeMarkerAttributeName: 'pubnumber',\n      isAttributeMarkerFor: ['c'],\n    },\n    d: {\n      type: 'para',\n      description: 'A Hebrew text heading, to provide description (e.g. Psalms)',\n    },\n    dc: {\n      type: 'char',\n      description: 'Deuterocanonical/LXX additions or insertions in the Protocanonical text',\n    },\n    ef: {\n      type: 'note',\n      description: 'Study note',\n      leadingAttributes: ['caller'],\n      attributeMarkers: ['cat'],\n    },\n    efe: {\n      type: 'note',\n      description: 'Extended study endnote',\n      leadingAttributes: ['caller'],\n      attributeMarkers: ['cat'],\n    },\n    efm: {\n      type: 'char',\n      description: 'Reference to caller of previous footnote in a study Bible',\n    },\n    em: {\n      type: 'char',\n      description: 'A character style, use emphasized text style',\n    },\n    esb: {\n      type: 'sidebar',\n      independentClosingMarkers: ['esbe'],\n      attributeMarkers: ['cat'],\n    },\n    esbe: {\n      type: 'sidebar',\n      isIndependentClosingMarkerFor: ['esb'],\n    },\n    ex: {\n      type: 'note',\n      description: 'Extended cross reference',\n      leadingAttributes: ['caller'],\n      attributeMarkers: ['cat'],\n    },\n    f: {\n      type: 'note',\n      description: 'Footnote',\n      leadingAttributes: ['caller'],\n      attributeMarkers: ['cat'],\n    },\n    fdc: {\n      type: 'char',\n      description: 'Footnote text, applies to Deuterocanon only (DEPRECATED - use char@style dc)',\n      isClosingMarkerOptional: true,\n    },\n    fe: {\n      type: 'note',\n      description: 'Endnote',\n      leadingAttributes: ['caller'],\n      attributeMarkers: ['cat'],\n    },\n    fig: {\n      type: 'figure',\n    },\n    fk: {\n      type: 'char',\n      description: 'A footnote keyword',\n      isClosingMarkerOptional: true,\n    },\n    fl: {\n      type: 'char',\n      description:\n        'A footnote label text item, for marking or \"labelling\" the type or alternate translation being provided in the note.',\n      isClosingMarkerOptional: true,\n    },\n    fm: {\n      type: 'char',\n      description: 'Reference to caller of previous footnote',\n    },\n    fp: {\n      type: 'char',\n      description: 'A Footnote additional paragraph marker',\n      isClosingMarkerOptional: true,\n    },\n    fq: {\n      type: 'char',\n      description: 'A footnote scripture quote or alternate rendering',\n      isClosingMarkerOptional: true,\n    },\n    fqa: {\n      type: 'char',\n      description: 'A footnote alternate rendering for a portion of scripture text',\n      isClosingMarkerOptional: true,\n    },\n    fr: {\n      type: 'char',\n      description: 'The origin reference for the footnote',\n      isClosingMarkerOptional: true,\n    },\n    ft: {\n      type: 'char',\n      description: 'Footnote text, Protocanon',\n      isClosingMarkerOptional: true,\n    },\n    fv: {\n      type: 'char',\n      description: 'A verse number within the footnote text',\n    },\n    fw: {\n      type: 'char',\n      description:\n        'A footnote witness list, for distinguishing a list of sigla representing witnesses in critical editions.',\n      isClosingMarkerOptional: true,\n    },\n    h: {\n      type: 'para',\n      description: 'Running header text for a book',\n    },\n    h1: {\n      type: 'para',\n      description: 'Running header text (DEPRECATED)',\n    },\n    h2: {\n      type: 'para',\n      description: 'Running header text, left side of page (DEPRECATED)',\n    },\n    h3: {\n      type: 'para',\n      description: 'Running header text, right side of page (DEPRECATED)',\n    },\n    ib: {\n      type: 'para',\n      description: 'Introduction blank line',\n    },\n    id: {\n      type: 'book',\n      leadingAttributes: ['code'],\n    },\n    ide: {\n      type: 'para',\n      description: 'File encoding information',\n    },\n    ie: {\n      type: 'para',\n      description: 'Introduction ending marker',\n    },\n    iex: {\n      type: 'para',\n      description:\n        'Introduction explanatory or bridge text (e.g. explanation of missing book in Short Old Testament)',\n    },\n    ili: {\n      type: 'para',\n      description: 'A list entry, level 1 (if single level)',\n    },\n    ili1: {\n      type: 'para',\n      description: 'A list entry, level 1 (if multiple levels)',\n    },\n    ili2: {\n      type: 'para',\n      description: 'A list entry, level 2',\n    },\n    im: {\n      type: 'para',\n      description:\n        'Introduction prose paragraph, with no first line indent (may occur after poetry)',\n    },\n    imi: {\n      type: 'para',\n      description: 'Introduction prose paragraph text, indented, with no first line indent',\n    },\n    imq: {\n      type: 'para',\n      description:\n        'Introduction prose paragraph, quote from the body text, with no first line indent',\n    },\n    imt: {\n      type: 'para',\n      description:\n        'Introduction major title, level 1 (if single level)\\nIntroduction major title, level 1 - (if single level)',\n    },\n    imt1: {\n      type: 'para',\n      description: 'Introduction major title, level 1 (if multiple levels)',\n    },\n    imt2: {\n      type: 'para',\n      description: 'Introduction major title, level 2',\n    },\n    imt3: {\n      type: 'para',\n      description: 'Introduction major title, level 3',\n    },\n    imt4: {\n      type: 'para',\n      description: 'Introduction major title, level 4 (usually within parenthesis)',\n    },\n    imte: {\n      type: 'para',\n      description: 'Introduction major title at introduction end, level 1 (if single level)',\n    },\n    imte1: {\n      type: 'para',\n      description: 'Introduction major title at introduction end, level 1 (if multiple levels)',\n    },\n    imte2: {\n      type: 'para',\n      description: 'Introduction major title at introduction end, level 2',\n    },\n    io: {\n      type: 'para',\n      description: 'Introduction outline text, level 1 (if single level)',\n    },\n    io1: {\n      type: 'para',\n      description: 'Introduction outline text, level 1 (if multiple levels)',\n    },\n    io2: {\n      type: 'para',\n      description: 'Introduction outline text, level 2',\n    },\n    io3: {\n      type: 'para',\n      description: 'Introduction outline text, level 3',\n    },\n    io4: {\n      type: 'para',\n      description: 'Introduction outline text, level 4',\n    },\n    ior: {\n      type: 'char',\n      description:\n        'Introduction references range for outline entry; for marking references separately',\n    },\n    iot: {\n      type: 'para',\n      description: 'Introduction outline title',\n    },\n    ip: {\n      type: 'para',\n      description:\n        'Introduction prose paragraph\\nDivision or Section introductory paragraph (study Bible)',\n    },\n    ipi: {\n      type: 'para',\n      description: 'Introduction prose paragraph, indented, with first line indent',\n    },\n    ipq: {\n      type: 'para',\n      description: 'Introduction prose paragraph, quote from the body text',\n    },\n    ipr: {\n      type: 'para',\n      description: 'Introduction prose paragraph, right aligned',\n    },\n    iq: {\n      type: 'para',\n      description: 'Introduction poetry text, level 1 (if single level)',\n    },\n    iq1: {\n      type: 'para',\n      description: 'Introduction poetry text, level 1 (if multiple levels)',\n    },\n    iq2: {\n      type: 'para',\n      description: 'Introduction poetry text, level 2',\n    },\n    iq3: {\n      type: 'para',\n      description: 'Introduction poetry text, level 3',\n    },\n    iqt: {\n      type: 'char',\n    },\n    is: {\n      type: 'para',\n      description: 'Introduction section heading, level 1 (if single level)',\n    },\n    is1: {\n      type: 'para',\n      description: 'Introduction section heading, level 1 (if multiple levels)',\n    },\n    is2: {\n      type: 'para',\n      description: 'Introduction section heading, level 2',\n    },\n    it: {\n      type: 'char',\n      description: 'A character style, use italic text',\n    },\n    jmp: {\n      type: 'char',\n      defaultAttribute: 'link-href',\n      description: 'For associating linking attributes to a span of text',\n    },\n    k: {\n      type: 'char',\n      description: 'For a keyword',\n    },\n    k1: {\n      type: 'para',\n      description: 'Concordance main entry text or keyword, level 1',\n    },\n    k2: {\n      type: 'para',\n      description: 'Concordance main entry text or keyword, level 2',\n    },\n    lf: {\n      type: 'para',\n      description: 'List footer (introductory remark)',\n    },\n    lh: {\n      type: 'para',\n      description: 'List header (introductory remark)',\n    },\n    li: {\n      type: 'para',\n      description: 'A list entry, level 1 (if single level)',\n    },\n    li1: {\n      type: 'para',\n      description: 'A list entry, level 1 (if multiple levels)',\n    },\n    li2: {\n      type: 'para',\n      description: 'A list entry, level 2',\n    },\n    li3: {\n      type: 'para',\n      description: 'A list entry, level 3',\n    },\n    li4: {\n      type: 'para',\n      description: 'A list entry, level 4',\n    },\n    lik: {\n      type: 'char',\n      description: 'Structured list entry key text',\n    },\n    lim: {\n      type: 'para',\n      description: 'An embedded list entry, level 1 (if single level)',\n    },\n    lim1: {\n      type: 'para',\n      description: 'An embedded list entry, level 1 (if multiple levels)',\n    },\n    lim2: {\n      type: 'para',\n      description: 'An embedded list entry, level 2',\n    },\n    lim3: {\n      type: 'para',\n      description: 'An embedded list entry, level 3',\n    },\n    lim4: {\n      type: 'para',\n      description: 'An embedded list entry, level 4',\n    },\n    lit: {\n      type: 'para',\n      description: 'For a comment or note inserted for liturgical use',\n    },\n    litl: {\n      type: 'char',\n      description: 'List entry total text',\n    },\n    liv: {\n      type: 'char',\n      description: 'Structured list entry value 1 content (if single value)',\n    },\n    liv1: {\n      type: 'char',\n      description: 'Structured list entrt value 1 content (if multiple values)',\n    },\n    liv2: {\n      type: 'char',\n      description: 'Structured list entry value 2 content',\n    },\n    liv3: {\n      type: 'char',\n      description: 'Structured list entry value 3 content',\n    },\n    liv4: {\n      type: 'char',\n      description: 'Structured list entry value 4 content',\n    },\n    liv5: {\n      type: 'char',\n      description: 'Structured list entry value 5 content',\n    },\n    m: {\n      type: 'para',\n      description:\n        'Paragraph text, with no first line indent (may occur after poetry) aka: Paragraph Continuation',\n    },\n    mi: {\n      type: 'para',\n      description: 'Paragraph text, indented, with no first line indent; often used for discourse',\n    },\n    mr: {\n      type: 'para',\n      description: 'A major section division references range heading',\n    },\n    ms: {\n      type: 'para',\n      description: 'A major section division heading, level 1 (if single level)',\n    },\n    ms1: {\n      type: 'para',\n      description: 'A major section division heading, level 1 (if multiple levels)',\n    },\n    ms2: {\n      type: 'para',\n      description: 'A major section division heading, level 2',\n    },\n    ms3: {\n      type: 'para',\n      description: 'A major section division heading, level 3',\n    },\n    mt: {\n      type: 'para',\n      description: 'The main title of the book (if single level)',\n    },\n    mt1: {\n      type: 'para',\n      description: 'The main title of the book (if multiple levels)',\n    },\n    mt2: {\n      type: 'para',\n      description: 'A secondary title usually occurring before the main title',\n    },\n    mt3: {\n      type: 'para',\n      description: 'A tertiary title occurring after the main title',\n    },\n    mt4: {\n      type: 'para',\n      description:\n        'Introduction major title, level 1 (if single level)\\nA small secondary title sometimes occuring within parentheses',\n    },\n    mte: {\n      type: 'para',\n      description:\n        'The main title of the book repeated at the end of the book, level 1 (if single level)',\n    },\n    mte1: {\n      type: 'para',\n      description:\n        'The main title of the book repeat /ed at the end of the book, level 1 (if multiple levels)',\n    },\n    mte2: {\n      type: 'para',\n      description: \"A secondary title occurring before or after the 'ending' main title\",\n    },\n    nb: {\n      type: 'para',\n      description:\n        'Paragraph text, with no break from previous paragraph text (at chapter boundary)',\n    },\n    nd: {\n      type: 'char',\n      description: 'For name of deity',\n    },\n    ndx: {\n      type: 'char',\n      description: 'A subject index text item',\n    },\n    no: {\n      type: 'char',\n      description: 'A character style, use normal text',\n    },\n    optbreak: {\n      type: 'optbreak',\n    },\n    ord: {\n      type: 'char',\n      description: 'For the text portion of an ordinal number',\n    },\n    p: {\n      type: 'para',\n      description:\n        'Paragraph text, with first line indent\\nFront or back matter text paragraph, level 1',\n    },\n    p1: {\n      type: 'para',\n      description: 'Front or back matter text paragraph, level 1 (if multiple levels)',\n    },\n    p2: {\n      type: 'para',\n      description: 'Front or back matter text paragraph, level 2 (if multiple levels)',\n    },\n    pb: {\n      type: 'para',\n      description:\n        \"Page Break used for new reader portions and children's bibles where content is controlled by the page\",\n    },\n    pc: {\n      type: 'para',\n      description: 'Inscription (paragraph text centered)',\n    },\n    periph: {\n      type: 'periph',\n      textContentAttribute: 'alt',\n    },\n    ph: {\n      type: 'para',\n      description:\n        'Paragraph text, with level 1 hanging indent (if single level) (DEPRECATED - use para@style li#)',\n    },\n    ph1: {\n      type: 'para',\n      description: 'Paragraph text, with level 1 hanging indent (if multiple levels)',\n    },\n    ph2: {\n      type: 'para',\n      description: 'Paragraph text, with level 2 hanging indent',\n    },\n    ph3: {\n      type: 'para',\n      description: 'Paragraph text, with level 3 hanging indent',\n    },\n    pi: {\n      type: 'para',\n      description:\n        'Paragraph text, level 1 indent (if single level), with first line indent; often used for discourse',\n    },\n    pi1: {\n      type: 'para',\n      description:\n        'Paragraph text, level 1 indent (if multiple levels), with first line indent; often used for discourse',\n    },\n    pi2: {\n      type: 'para',\n      description:\n        'Paragraph text, level 2 indent, with first line indent; often used for discourse',\n    },\n    pi3: {\n      type: 'para',\n      description:\n        'Paragraph text, level 3 indent, with first line indent; often used for discourse',\n    },\n    pm: {\n      type: 'para',\n      description: 'Embedded text paragraph',\n    },\n    pmc: {\n      type: 'para',\n      description: 'Embedded text closing',\n    },\n    pmo: {\n      type: 'para',\n      description: 'Embedded text opening',\n    },\n    pmr: {\n      type: 'para',\n      description: 'Embedded text refrain',\n    },\n    pn: {\n      type: 'char',\n      description: 'For a proper name',\n    },\n    png: {\n      type: 'char',\n      description: 'For a geographic proper name',\n    },\n    po: {\n      type: 'para',\n      description: 'Letter opening',\n    },\n    pr: {\n      type: 'para',\n      description: 'Text refrain (paragraph right-aligned)',\n    },\n    pro: {\n      type: 'char',\n      description: 'For indicating pronunciation in CJK texts (DEPRECATED - used char@style rb)',\n    },\n    q: {\n      type: 'para',\n      description: 'Poetry text, level 1 indent (if single level)',\n    },\n    q1: {\n      type: 'para',\n      description: 'Poetry text, level 1 indent (if multiple levels)',\n    },\n    q2: {\n      type: 'para',\n      description: 'Poetry text, level 2 indent',\n    },\n    q3: {\n      type: 'para',\n      description: 'Poetry text, level 3 indent',\n    },\n    q4: {\n      type: 'para',\n      description: 'Poetry text, level 4 indent',\n    },\n    qa: {\n      type: 'para',\n      description: 'Poetry text, Acrostic marker/heading',\n    },\n    qac: {\n      type: 'char',\n      description:\n        'Poetry text, Acrostic markup of the first character of a line of acrostic poetry',\n    },\n    qc: {\n      type: 'para',\n      description: 'Poetry text, centered',\n    },\n    qd: {\n      type: 'para',\n      description:\n        'A Hebrew musical performance annotation, similar in content to Hebrew descriptive title.',\n    },\n    qm: {\n      type: 'para',\n      description: 'Poetry text, embedded, level 1 indent (if single level)',\n    },\n    qm1: {\n      type: 'para',\n      description: 'Poetry text, embedded, level 1 indent (if multiple levels)',\n    },\n    qm2: {\n      type: 'para',\n      description: 'Poetry text, embedded, level 2 indent',\n    },\n    qm3: {\n      type: 'para',\n      description: 'Poetry text, embedded, level 3 indent',\n    },\n    qr: {\n      type: 'para',\n      description: 'Poetry text, Right Aligned',\n    },\n    qs: {\n      type: 'char',\n      description: 'Poetry text, Selah',\n    },\n    qt: {\n      type: 'char',\n      description: 'For Old Testament quoted text appearing in the New Testament',\n    },\n    'qt-e': {\n      type: 'ms',\n      defaultAttribute: 'eid',\n    },\n    'qt-s': {\n      type: 'ms',\n      defaultAttribute: 'who',\n    },\n    'qt1-e': {\n      type: 'ms',\n      defaultAttribute: 'eid',\n    },\n    'qt1-s': {\n      type: 'ms',\n      defaultAttribute: 'who',\n    },\n    'qt2-e': {\n      type: 'ms',\n      defaultAttribute: 'eid',\n    },\n    'qt2-s': {\n      type: 'ms',\n      defaultAttribute: 'who',\n    },\n    'qt3-e': {\n      type: 'ms',\n      defaultAttribute: 'eid',\n    },\n    'qt3-s': {\n      type: 'ms',\n      defaultAttribute: 'who',\n    },\n    'qt4-e': {\n      type: 'ms',\n      defaultAttribute: 'eid',\n    },\n    'qt4-s': {\n      type: 'ms',\n      defaultAttribute: 'who',\n    },\n    'qt5-e': {\n      type: 'ms',\n      defaultAttribute: 'eid',\n    },\n    'qt5-s': {\n      type: 'ms',\n      defaultAttribute: 'who',\n    },\n    r: {\n      type: 'para',\n      description: 'Parallel reference(s)',\n    },\n    rb: {\n      type: 'char',\n      defaultAttribute: 'gloss',\n    },\n    ref: {\n      type: 'ref',\n      defaultAttribute: 'loc',\n    },\n    rem: {\n      type: 'para',\n      description: 'Remark',\n    },\n    restore: {\n      type: 'para',\n      description: 'Comment about when text was restored',\n    },\n    rq: {\n      type: 'char',\n      description: 'A cross-reference indicating the source text for the preceding quotation.',\n    },\n    s: {\n      type: 'para',\n      description: 'A section heading, level 1 (if single level)',\n    },\n    s1: {\n      type: 'para',\n      description: 'A section heading, level 1 (if multiple levels)',\n    },\n    s2: {\n      type: 'para',\n      description: 'A section heading, level 2 (e.g. Proverbs 22-24)',\n    },\n    s3: {\n      type: 'para',\n      description: 'A section heading, level 3 (e.g. Genesis \"The First Day\")',\n    },\n    s4: {\n      type: 'para',\n      description: 'A section heading, level 4',\n    },\n    sc: {\n      type: 'char',\n      description: 'A character style, for small capitalization text',\n    },\n    sd: {\n      type: 'para',\n      description:\n        'Vertical space used to divide the text into sections, level 1 (if single level)',\n    },\n    sd1: {\n      type: 'para',\n      description:\n        'Semantic division location (vertical space used to divide the text into sections), level 1 (if multiple levels)',\n    },\n    sd2: {\n      type: 'para',\n      description:\n        'Semantic division location (vertical space used to divide the text into sections), level 2',\n    },\n    sd3: {\n      type: 'para',\n      description:\n        'Semantic division location (vertical space used to divide the text into sections), level 3',\n    },\n    sd4: {\n      type: 'para',\n      description:\n        'Semantic division location (vertical space used to divide the text into sections), level 4',\n    },\n    sig: {\n      type: 'char',\n      description: 'For the signature of the author of an Epistle',\n    },\n    sls: {\n      type: 'char',\n      description:\n        'To represent where the original text is in a secondary language or from an alternate text source',\n    },\n    sp: {\n      type: 'para',\n      description: 'A heading, to identify the speaker (e.g. Job)',\n    },\n    sr: {\n      type: 'para',\n      description: 'A section division references range heading',\n    },\n    sts: {\n      type: 'para',\n      description: 'Status\\nRemark',\n    },\n    sup: {\n      type: 'char',\n      description:\n        'A character style, for superscript text. Typically for use in critical edition footnotes.',\n    },\n    't-e': {\n      type: 'ms',\n      defaultAttribute: 'eid',\n    },\n    't-s': {\n      type: 'ms',\n      defaultAttribute: 'sid',\n    },\n    table: {\n      type: 'table',\n    },\n    tl: {\n      type: 'char',\n      description: 'For transliterated words',\n    },\n    toc1: {\n      type: 'para',\n      description: 'Long table of contents text',\n    },\n    toc2: {\n      type: 'para',\n      description: 'Short table of contents text',\n    },\n    toc3: {\n      type: 'para',\n      description: 'Book Abbreviation',\n    },\n    toca1: {\n      type: 'para',\n      description: 'Alternative language long table of contents text',\n    },\n    toca2: {\n      type: 'para',\n      description: 'Alternative language short table of contents text',\n    },\n    toca3: {\n      type: 'para',\n      description: 'Alternative language book Abbreviation',\n    },\n    tr: {\n      type: 'row',\n      description: 'Table row',\n    },\n    ts: {\n      type: 'ms',\n      description:\n        \"Translator's chunk (to identify chunks of text suitable for translating at one time)\",\n    },\n    'ts-e': {\n      type: 'ms',\n      defaultAttribute: 'eid',\n    },\n    'ts-s': {\n      type: 'ms',\n      defaultAttribute: 'sid',\n    },\n    usfm: {\n      type: 'para',\n      textContentAttribute: 'version',\n      parseUsfmInstructions:\n        \"If this marker is directly after the first id marker, this marker's version attribute should determine the version attribute of the usx or USJ marker at the top of the USX or USJ document, then this marker should be removed.\",\n    },\n    USJ: {\n      type: 'USJ',\n      textContentAttribute: 'version',\n      markerUsfm: 'usfm',\n    },\n    usx: {\n      type: 'usx',\n      textContentAttribute: 'version',\n      markerUsfm: 'usfm',\n    },\n    v: {\n      type: 'verse',\n      leadingAttributes: ['number'],\n      attributeMarkers: ['va', 'vp'],\n    },\n    va: {\n      type: 'char',\n      attributeMarkerAttributeName: 'altnumber',\n      isAttributeMarkerFor: ['v'],\n      hasStructuralSpaceAfterCloseAttributeMarker: true,\n      description:\n        'Second (alternate) verse number (for coding dual numeration in Psalms; see also NRSV Exo 22.1-4)',\n    },\n    vp: {\n      type: 'char',\n      description:\n        'Published verse marker - this is a verse marking that would be used in the published text',\n      attributeMarkerAttributeName: 'pubnumber',\n      isAttributeMarkerFor: ['v'],\n      hasStructuralSpaceAfterCloseAttributeMarker: true,\n    },\n    w: {\n      type: 'char',\n      defaultAttribute: 'lemma',\n    },\n    wa: {\n      type: 'char',\n      description: 'An Aramaic wordlist text item',\n    },\n    wg: {\n      type: 'char',\n      description: 'A Greek Wordlist text item',\n    },\n    wh: {\n      type: 'char',\n      description: 'A Hebrew wordlist text item',\n    },\n    wj: {\n      type: 'char',\n      description: 'For marking the words of Jesus',\n    },\n    x: {\n      type: 'note',\n      description: 'Cross reference',\n      leadingAttributes: ['caller'],\n      attributeMarkers: ['cat'],\n    },\n    xdc: {\n      type: 'char',\n      description:\n        'Cross-reference target reference(s), Deuterocanon only (DEPRECATED - use char@style dc)',\n      isClosingMarkerOptional: true,\n    },\n    xk: {\n      type: 'char',\n      description: 'A cross reference keyword',\n      isClosingMarkerOptional: true,\n    },\n    xnt: {\n      type: 'char',\n      description: 'Cross-reference target reference(s), New Testament only',\n      isClosingMarkerOptional: true,\n    },\n    xo: {\n      type: 'char',\n      description: 'The cross reference origin reference',\n      isClosingMarkerOptional: true,\n    },\n    xop: {\n      type: 'char',\n      description:\n        'Published cross reference origin text (origin reference that should appear in the published text)',\n      isClosingMarkerOptional: true,\n    },\n    xot: {\n      type: 'char',\n      description: 'Cross-reference target reference(s), Old Testament only',\n      isClosingMarkerOptional: true,\n    },\n    xq: {\n      type: 'char',\n      description: 'A cross-reference quotation from the scripture text',\n      isClosingMarkerOptional: true,\n    },\n    xt: {\n      type: 'char',\n      defaultAttribute: 'link-href',\n      description:\n        'A target reference(s)\\nA cross reference target reference(s)\\nThe cross reference target reference(s), protocanon only',\n      isClosingMarkerOptional: true,\n    },\n    xta: {\n      type: 'char',\n      description: 'Cross reference target references added text',\n      isClosingMarkerOptional: true,\n    },\n  },\n  markersRegExp: {\n    '[Zz].+': {\n      type: 'ms',\n      defaultAttribute: 'sid',\n    },\n    'qt[1-5]?(\\\\-[se])?': {\n      type: 'ms',\n      defaultAttribute: 'sid',\n    },\n    't[hc][rc]?\\\\d+': {\n      type: 'cell',\n    },\n    'ts?(\\\\-[se])?': {\n      type: 'ms',\n      defaultAttribute: 'sid',\n    },\n  },\n  markerTypes: {\n    book: {},\n    cell: {\n      skipOutputAttributeToUsfm: ['align'],\n      outputToUsfmInstructions:\n        \"If this marker has a colspan attribute, the USFM marker name should be this marker's name plus hyphen (-) plus the marker's final column number (first column number found in the marker name plus colspan minus 1). Then the colspan attribute should not be output as a USFM attribute.\",\n      parseUsfmInstructions:\n        \"If this marker's name has a hyphen (-) and a number after the marker, the USX/USJ marker name should be just the portion of the marker name before the hyphen, and it should have the colspan attribute which is the number of columns spanned by the marker (second column number plus 1 minus first column number).\",\n      markerTypeUsj: 'table:cell',\n    },\n    chapter: {\n      hasNewlineBefore: true,\n      skipOutputAttributeToUsfm: ['sid'],\n      skipOutputMarkerToUsfmIfAttributeIsPresent: ['eid'],\n    },\n    char: {\n      isCloseable: true,\n      nestedPrefix: '+',\n    },\n    figure: {\n      isCloseable: true,\n      outputToUsfmInstructions: 'The USX/USJ file attribute needs its name changed to src in USFM',\n      parseUsfmInstructions: 'The USFM src attribute needs its name changed to file in USX/USJ',\n    },\n    ms: {\n      isCloseable: true,\n      isClosingMarkerEmpty: true,\n    },\n    note: {\n      isCloseable: true,\n    },\n    optbreak: {\n      hasStyleAttribute: false,\n    },\n    para: {\n      hasNewlineBefore: true,\n      skipOutputAttributeToUsfm: ['vid'],\n    },\n    periph: {\n      hasNewlineBefore: true,\n      hasStyleAttribute: false,\n    },\n    ref: {\n      isCloseable: true,\n      hasStyleAttribute: false,\n      skipOutputMarkerToUsfmIfAttributeIsPresent: ['gen'],\n      skipOutputMarkerToUsfm: true,\n    },\n    row: {\n      hasNewlineBefore: true,\n      markerTypeUsj: 'table:row',\n    },\n    sidebar: {\n      hasNewlineBefore: true,\n    },\n    table: {\n      hasStyleAttribute: false,\n      skipOutputAttributeToUsfm: ['vid'],\n      skipOutputMarkerToUsfm: true,\n    },\n    'table:cell': {\n      skipOutputAttributeToUsfm: ['align'],\n      outputToUsfmInstructions:\n        \"If this marker has a colspan attribute, the USFM marker name should be this marker's name plus hyphen (-) plus the marker's final column number (first column number found in the marker name plus colspan minus 1). Then the colspan attribute should not be output as a USFM attribute.\",\n      parseUsfmInstructions:\n        \"If this marker's name has a hyphen (-) and a number after the marker, the USX/USJ marker name should be just the portion of the marker name before the hyphen, and it should have the colspan attribute which is the number of columns spanned by the marker (second column number plus 1 minus first column number).\",\n      markerTypeUsj: 'table:cell',\n      markerTypeUsfm: 'cell',\n      markerTypeUsx: 'cell',\n    },\n    'table:row': {\n      hasNewlineBefore: true,\n      markerTypeUsj: 'table:row',\n      markerTypeUsfm: 'row',\n      markerTypeUsx: 'row',\n    },\n    unmatched: {\n      description:\n        'Paratext uses this type for closing markers that it cannot find opening markers for. They are treated like char markers but have no contents, no closing markers, and no space after the marker.',\n      outputToUsfmInstructions:\n        'Do not output a structural space after the opening marker for markers with unmatched type.',\n      parseUsfmInstructions:\n        'If a closing marker occurs but does not seem to have a matching opening marker, create an unmatched-type marker. There is no structural space after the unmatched-type marker; its end is determined by the asterisk at the end of the marker.',\n    },\n    USJ: {\n      hasNewlineBefore: true,\n      hasStyleAttribute: false,\n      skipOutputAttributeToUsfm: ['xsi:noNamespaceSchemaLocation'],\n      outputToUsfmInstructions:\n        \"If this marker is the top-level marker containing all other markers in this document, it should not be directly output to USFM. Instead, if this marker's version attribute is other than 3.0, a new usfm marker with this version attribute needs to be added after the id marker if one is present in the USFM.\",\n    },\n    usx: {\n      hasNewlineBefore: true,\n      hasStyleAttribute: false,\n      skipOutputAttributeToUsfm: ['xsi:noNamespaceSchemaLocation'],\n      outputToUsfmInstructions:\n        \"If this marker is the top-level marker containing all other markers in this document, it should not be directly output to USFM. Instead, if this marker's version attribute is other than 3.0, a new usfm marker with this version attribute needs to be added after the id marker if one is present in the USFM.\",\n    },\n    verse: {\n      hasNewlineBefore: true,\n      skipOutputAttributeToUsfm: ['sid'],\n      skipOutputMarkerToUsfmIfAttributeIsPresent: ['eid'],\n    },\n  },\n});\n\n/**\n * A map of all USFM/USX/USJ markers and some information about them. Generated from a `usx.rng`\n * file and adjusted to reflect the way Paratext 9.4 handles USFM.\n */\nexport const USFM_MARKERS_MAP_PARATEXT: MarkersMap = Object.freeze({\n  ...USFM_MARKERS_MAP,\n  isSpaceAfterAttributeMarkersContent: true,\n  shouldOptionalClosingMarkersBePresent: true,\n});\n","// This was disabled so class functions that are similar in purpose can be grouped together\n/* eslint-disable @typescript-eslint/member-ordering */\nimport {\n  USJ_TYPE,\n  type MarkerContent,\n  type MarkerObject,\n  type Usj,\n} from '@eten-tech-foundation/scripture-utilities';\nimport { SerializedVerseRef } from '@sillsdev/scripture';\nimport { JSONPath } from 'jsonpath-plus';\nimport { deepEqual } from '../equality-checking';\nimport { SortedNumberMap } from '../sorted-number-map';\nimport { isString } from '../util';\nimport { extractFootnotesFromUsjContent } from './footnote-util';\nimport {\n  AttributeMarkerInfo,\n  MarkerInfo,\n  MarkersMap,\n  MarkerTypeInfo,\n  USFM_MARKERS_MAP as USFM_MARKERS_MAP_3_0,\n} from './markers-maps/markers-map-3.0.model';\nimport {\n  BOOK_TYPE,\n  CHAPTER_TYPE,\n  ContentJsonPath,\n  IUsjReaderWriter,\n  NO_BOOK_ID,\n  PropertyJsonPath,\n  UsfmVerseLocation,\n  UsfmVerseRefVerseLocation,\n  UsjAttributeKeyLocation,\n  UsjAttributeMarkerLocation,\n  UsjBookLocation,\n  UsjChapterLocation,\n  UsjClosingAttributeMarkerLocation,\n  UsjClosingMarkerLocation,\n  UsjDocumentLocation,\n  UsjMarkerLocation,\n  UsjNodeAndDocumentLocation,\n  UsjPropertyValueLocation,\n  UsjReaderWriterOptions,\n  UsjSearchResult,\n  UsjTextContentLocation,\n  UsjVerseRefBookLocation,\n  UsjVerseRefChapterLocation,\n  VERSE_TYPE,\n} from './usj-reader-writer.model';\n\nconst NODE_TYPES_NOT_CONTAINING_VERSE_TEXT = ['figure', 'note', 'sidebar', 'table'];\nObject.freeze(NODE_TYPES_NOT_CONTAINING_VERSE_TEXT);\n\n/** RegExp that matches all NBSP characters in a string. Used to convert NBSP in USJ to ~ in USFM */\nconst TEXT_CONTENT_NBSP_REGEXP = /\\u00A0/g;\n\n/**\n * RegExp that matches a USX/USJ table marker to get the number out of it. Used to figure out the\n * USFM cell range for table markers with `colspan` attribute in USX/USJ\n *\n * Matches:\n *\n * - 0: the whole string\n * - 1: the number portion of the marker (the starting column of this cell)\n */\nconst TABLE_MARKER_NUMBER_REGEXP = /\\w+(\\d+)/;\n\n/**\n * RegExp that matches a USFM/USX/USJ verse number (optionally a span) to get the starting verse\n * number and optionally an ending verse number out of it.\n *\n * Matches:\n *\n * - 0: the whole string\n * - 1: the starting number portion of the verse number\n * - 2: the ending number portion of the verse number if one exists\n *\n * Example:\n *\n * ```usfm\n * \\v 15-16\n * ```\n *\n * We would match this RegExp against `\"15-16\"`\n *\n * Match 1 would be `\"15\"`, and match 2 would be `\"16\"`\n */\nconst VERSE_MARKER_NUMBER_SPAN_REGEXP = /(\\d+)-?(\\d+)?/;\n\n/**\n * Map of USJ content arrays and objects inside content arrays to the content array owner\n *\n * Note that `USJ` markers may have parents if they are unexpectedly present within the contents of\n * the USJ document. We can tell which `USJ` marker is the top-level marker by receiving `undefined`\n * when looking up the `USJ` marker.\n */\ntype UsjParentMap = Map<MarkerObject | MarkerContent[] | Usj, MarkerObject | Usj>;\n\n/** Fragment indicating a marker closed */\ntype UsjClosingMarkerFragment = { isClosingMarker: true; forMarker: MarkerObject | Usj };\n/** Fragment indicating the value for an attribute */\ntype UsjAttributeValueFragment = { attributeValueForKey: string; forMarker: MarkerObject | Usj };\n/** Fragment indicating the key for an attribute */\ntype UsjAttributeKeyFragment = { attributeKey: string; forMarker: MarkerObject | Usj };\n/** Fragment indicating the opening of an attribute marker */\ntype UsjAttributeMarkerFragment = { attributeMarker: string; forMarker: MarkerObject | Usj };\n/** Fragment indicating the closing of an attribute marker */\ntype UsjAttributeMarkerClosingMarkerFragment = {\n  attributeMarkerClosingMarker: string;\n  forMarker: MarkerObject | Usj;\n};\n\n/**\n * A piece of Scripture data in a USJ document. This could be any of the following:\n *\n * 1. A marker or content string in a USJ document\n *\n *    - `Usj`\n *    - `MarkerContent`\n * 2. A JavaScript object representation of some part of a marker that isn't actually a JavaScript\n *    object\n *\n *    - `UsjClosingMarker`\n *    - `UsjAttributeValue`\n *    - `UsjAttributeKey` except when the attribute whose key is being pointed to is an attribute marker\n *         in USFM, in which case this fragment is type 3 below. This fragment represents the USFM\n *         attribute marker name in USFM (e.g. `ca`), not the attribute key name (e.g. `altnumber`)\n * 3. Part of a marker as it appears in USFM but that doesn't have a direct equivalence in USJ\n *\n *    - `UsjAttributeKey` when pointing to an attribute marker. See fragment type 2 above.\n *    - `UsjAttributeMarker`\n *    - `UsjAttributeMarkerClosingMarker`\n *\n * This is somewhat similar to `UsfmToken` in `ParatextData.dll`, but there are many differences.\n * `UsfmToken` is a class with many methods and divides Scripture data based on the USFM contents.\n * `UsjFragment`, however, is just a union of object types (and `string`) that indicates the\n * division of Scripture data primarily by USJ contents.\n *\n * This is not the same as or similar to `IFragment` in `ParatextData.dll`. `IFragment` is a bit\n * more similar to {@link UsjFragmentInfo}.\n *\n * If you think of a better name for this, feel free to replace it.\n */\ntype UsjFragment =\n  | Usj\n  | MarkerContent\n  | UsjClosingMarkerFragment\n  | UsjAttributeValueFragment\n  | UsjAttributeKeyFragment\n  | UsjAttributeMarkerFragment\n  | UsjAttributeMarkerClosingMarkerFragment;\n\n/**\n * Information about a fragment including its position in the USFM representation. Built while\n * determining the USFM representation of the USJ document\n */\ntype UsjFragmentInfoMinimal = {\n  fragment: UsjFragment;\n  indexInUsfm: number;\n};\n\n/**\n * A snippet of USFM along with information about what fragments of the marker are where in that\n * USFM snippet\n */\ntype UsfmSnippetAndUsjFragmentsInfo = {\n  usfm: string;\n  /** USFM position info about the fragments that are represented in this USFM string */\n  fragmentsInfo: UsjFragmentInfoMinimal[];\n};\n\n/**\n * Information about a fragment that includes its position in the USFM and the USJ representation.\n * Transformed from {@link UsjFragmentInfoMinimal} in\n * {@link UsjReaderWriter.transferFragmentsInfoArrayToMaps} while sorting the fragments into the\n * right places after finishing determining the USFM representation.\n *\n * This is somewhat similar to `IFragment` in `ParatextData.dll` in that both contain information\n * that connects some position in USFM to some position in USX (`IFragment`) or USJ\n * (`UsjFragmentInfo`).\n */\ntype UsjFragmentInfo = UsjFragmentInfoMinimal & {\n  /**\n   * The node this fragment is on and the document location of the start of this fragment (any\n   * offset property will be 0)\n   */\n  nodeAndDocumentLocation: UsjNodeAndDocumentLocation;\n};\n\n/** Fragments at each index in the USFM string */\ntype FragmentsByIndexInUsfm = SortedNumberMap<UsjFragmentInfo>;\n\n/**\n * Array of fragments that have the JSONPath (content or property) that is the key\n *\n * The JSONPath must be \"normalized\" as generated by UsjReaderWriter.convertWorkingStackToJsonPath\n * and UsjReaderWriter.convertWorkingStackAndPropertyToJsonPath. Otherwise, your JSONPath will not\n * match the keys in this map.\n */\ntype FragmentsByJsonPath = Map<string, UsjFragmentInfo[]>;\n\n/**\n * String index of the start of each verse (the backslash on the verse marker) in the USFM\n * representation of the USJ document. Used for taking an index based on the start of a verse and\n * determining the index in the whole USFM document to look up in {@link FragmentsByIndexInUsfm}.\n *\n * Notes:\n *\n * - All indices before a book id are associated with the first book id present. If there is not a\n *   book id present in the USJ data, everything will be in book {@link NO_BOOK_ID}.\n * - All indices before a chapter number are associated with the first chapter number present. If\n *   there is not a chapter number present in the USJ data, everything will be in chapter 0.\n * - Any indices that occur before a verse number will be in verse 0.\n * - The start of a book is at the book name, chapter 1 (or 0 if no chapter numbers), verse 0. The\n *   start of a chapter is at the book name, chapter number, verse 0.\n * - There are no verse ranges in this object. Only the starting verse in any range that is found in\n *   the USFM is added to this map (in {@link UsjReaderWriter.transferFragmentsInfoArrayToMaps}), so\n *   we should always look up verse ranges with the starting verse in the range (in\n *   {@link UsjReaderWriter.getIndexInUsfmForVerseRef}). Presumably, if someone is trying to find the\n *   index in USFM of a verse that isn't standalone but is in the middle of a range, they are likely\n *   going to run into less obvious trouble with index in USFM calculations.\n *\n * TODO: Should we do something else to support verse ranges? Depending on how we want to support\n * them, we can do different things:\n *\n * - If we just want to support getting the first verse in a range (`SerializedVerseRef.verseNum`), we\n *   don't need to change anything as this is how it works currently.\n * - If we want to support getting the verse range exactly as it appears in the text and _not_ from\n *   the first verse in the range, we could change the index signature `[verseNum: number]` to be\n *   accessible by `string | number` and put the `SerializedVerseRef.verse` range text as the key\n *   instead of `verseNum` when it is defined and looked up (in at least\n *   {@link UsjReaderWriter.transferFragmentsInfoArrayToMaps} and\n *   {@link UsjReaderWriter.getIndexInUsfmForVerseRef}; maybe other places as well).\n * - If we want to support getting any verse in a range, we could add the same index in USFM for all\n *   the verses within a verse range `SerializedVerseRef.verse` (in\n *   {@link UsjReaderWriter.transferFragmentsInfoArrayToMaps}).\n *\n * In any case, once we come to a clear decision on what we want to do, we should probably document\n * it in the TSDoc for {@link UsjReaderWriter}.\n */\ntype IndicesInUsfmByVerseRef = {\n  [book: string]:\n    | {\n        [chapterNum: number]:\n          | {\n              [verseNum: number]: number | undefined;\n            }\n          | undefined;\n      }\n    | undefined;\n};\n\n/**\n * Represents information about where a USJ node resides in the `content` array of its parent.\n * `parent` is a reference to the node's parent, and `index` represents the numeric index inside of\n * `parent`'s content array.\n */\ntype StackItem = { parent: MarkerObject | Usj; index: number };\n\n/**\n * Stack of levels inside a USJ tree relative to a specific node. The top of the stack should always\n * be the root Usj object.\n */\ntype WorkingStack = StackItem[];\n\n/**\n * Represents USJ formatted scripture with helpful utilities for working with it. Some notable\n * features:\n *\n * - Find Scripture text in the USJ document\n *\n *   - `extractText`\n *   - `extractTextBetweenPoints`\n *   - `findNextLocationOfMatchingText`\n *   - `search`\n *   - `usfmVerseLocationToNextTextLocation`\n * - Edit the USJ document: `removeContentNodes`\n * - Transform USJ to USFM: `toUsfm`\n * - Transform USJ document locations to USFM locations and vice versa\n *\n *   - `usfmVerseLocationToUsjDocumentLocation`\n *   - `usjDocumentLocationToUsfmVerseRefVerseLocation`\n * - Use the version of USFM you need by passing in a custom markers map to the constructor if the\n *   version in your USJ document is not supported by default:\n *   {@link UsjReaderWriterOptions.markersMap}\n *\n * Notes:\n *\n * - \"node\" is a term used in the methods in this class that usually means an object or content string\n *   somewhere in the USj document, either {@link Usj} or {@link MarkerContent}. However, in specific\n *   situations, it may refer only to {@link MarkerObject} or {@link MarkerContent}. The TypeScript\n *   types indicate when this is the case.\n * - See {@link UsfmVerseLocation} and {@link UsjDocumentLocation} for information about transforming\n *   USFM locations and USJ locations including what kinds of USFM locations are and are not\n *   representable in USJ locations, which USJ locations actually correspond to something in USJ,\n *   etc.\n * - It is best to reuse the same `UsjReaderWriter` for the same USJ document as long as possible\n *   because there is a significant amount of processing and caching done internally to facilitate\n *   various operations. Note that, if the USJ document added to `UsjReaderWriter` changes, you must\n *   run `usjChanged` to clear the internal caches and receive accurate results from future method\n *   calls\n */\nexport class UsjReaderWriter implements IUsjReaderWriter {\n  private readonly usj: Usj;\n  private readonly markersMap: MarkersMap;\n  private readonly shouldAllowInvisibleCharacters: boolean;\n\n  // Cached properties\n  private parentMapInternal: UsjParentMap | undefined;\n  private fragmentsByIndexInUsfmInternal: FragmentsByIndexInUsfm | undefined;\n  private fragmentsByJsonPathInternal: FragmentsByJsonPath | undefined;\n  private indicesInUsfmByVerseRefInternal: IndicesInUsfmByVerseRef | undefined;\n  private usfmInternal: string | undefined;\n\n  constructor(usj: Usj, options?: UsjReaderWriterOptions) {\n    this.usj = usj;\n\n    const { markersMap: providedMarkersMap, shouldAllowInvisibleCharacters } = options ?? {};\n\n    // If they passed in a markers map, use it\n    if (providedMarkersMap) {\n      this.markersMap = providedMarkersMap;\n\n      // Warn if the passed in markers map is not compatible\n      if (!UsjReaderWriter.areUsjVersionsCompatible(this.usj.version, this.markersMap.version))\n        console.warn(\n          `Warning: USJ provided has version ${\n            this.usj.version\n          }, but provided markers map has version ${\n            this.markersMap.version\n          }. This may cause unexpected issues when transforming between formats.\\nUSJ: ${JSON.stringify(\n            this.usj,\n          )}`,\n        );\n    }\n    // They didn't pass in a markers map, so try to use a built-in markers map matching the USJ version\n    else if (\n      UsjReaderWriter.areUsjVersionsCompatible(this.usj.version, USFM_MARKERS_MAP_3_0.version)\n    )\n      this.markersMap = USFM_MARKERS_MAP_3_0;\n    else\n      throw new Error(\n        'USJ version is not 3.0 or 3.0.x! Not equipped to handle yet without passing in a markers map',\n      );\n\n    if (!this.markersMap.markersMapVersion.startsWith('1.'))\n      throw new Error(\n        `Incompatible markers map version: ${\n          this.markersMap.markersMapVersion\n        }. This class only supports version 1.x.y`,\n      );\n\n    this.shouldAllowInvisibleCharacters = shouldAllowInvisibleCharacters ?? false;\n  }\n\n  // If new variables are created to speed up queries, they should be reset here\n  usjChanged(): void {\n    this.parentMapInternal = undefined;\n    this.fragmentsByIndexInUsfmInternal = undefined;\n    this.fragmentsByJsonPathInternal = undefined;\n    this.indicesInUsfmByVerseRefInternal = undefined;\n    this.usfmInternal = undefined;\n  }\n\n  private static areUsjVersionsCompatible(versionA: string, versionB: string) {\n    if (versionA === '3.0' || versionA.startsWith('3.0.'))\n      return versionB === '3.0' || versionB.startsWith('3.0.');\n    return versionA === versionB;\n  }\n\n  // #region Directly using the JSONPath package to perform JSONPath query -> USJ node\n\n  findSingleValue<T>(jsonPathQuery: string): T | undefined {\n    const wrappedResults = JSONPath({ path: jsonPathQuery, json: this.usj, wrap: true });\n    if (wrappedResults === undefined || wrappedResults.length === 0) return undefined;\n    if (!Array.isArray(wrappedResults[0])) return wrappedResults[0];\n\n    // There is no way to tell the difference between a query that returns a single result that is an\n    // array and a query that returns multiple results wrapped in an array when `wrap` is false.\n    // However, if `wrap` is true then a single result that is an array will be a different array\n    // object than the array object within `usj`. So we need to run with `wrap` as true and false to\n    // get the original array object back for a query that returns a single array.\n    const unwrappedResults = JSONPath({ path: jsonPathQuery, json: this.usj, wrap: false });\n    if (unwrappedResults.length === 1 && Array.isArray(unwrappedResults[0]))\n      // I have no idea why eslint is mad about casting from `any` to `T`, but it doesn't like it\n      // eslint-disable-next-line no-type-assertion/no-type-assertion\n      return unwrappedResults[0] as T;\n    return unwrappedResults;\n  }\n\n  findParent<T>(jsonPathQuery: string): T | undefined {\n    // Note that \"resultType: 'parent'\" does not work for queries\n    // The \"jsonpath-plus\" package allows putting a carat at the end of a query to get a parent\n    return this.findSingleValue(`${jsonPathQuery}^`);\n  }\n\n  // #endregion Directly using the JSONPath package to perform JSONPath query -> USJ node\n\n  // #region marker helper methods\n\n  /**\n   * Determine if the passed in marker is the top-level USJ marker.\n   *\n   * Note that USJ markers that are not the top-level USJ markers technically should not occur, but\n   * they can occur. We should treat them like any other marker. They conform to\n   * {@link MarkerObject}, so it's not hard to do.\n   *\n   * @param marker Marker to test if it is USJ marker\n   * @returns `true` if it is a USJ marker; false otherwise\n   */\n  static isTopLevelUsjMarker(\n    marker: Usj | MarkerContent,\n    workingStack: WorkingStack,\n  ): marker is Usj {\n    return typeof marker === 'object' && marker.type === USJ_TYPE && workingStack.length === 0;\n  }\n\n  /**\n   * Determine if a fragment is a marker, not a text content string or some kind of position\n   * fragment that isn't actually a marker e.g. closing marker fragment\n   */\n  private static isFragmentAMarker(fragment: UsjFragment): fragment is MarkerObject | Usj {\n    return !isString(fragment) && !('forMarker' in fragment);\n  }\n\n  // #endregion marker helper methods\n\n  // #region Parent Maps\n\n  private static createParentMapInternal(\n    obj: MarkerObject,\n    parent: MarkerObject | Usj,\n    parentMap: UsjParentMap,\n  ): void {\n    parentMap.set(obj, parent);\n    // USJ queries may return pointers to content arrays, not just objects\n    if (obj.content) parentMap.set(obj.content, obj);\n    obj.content?.forEach((child) => {\n      if (typeof child === 'object') UsjReaderWriter.createParentMapInternal(child, obj, parentMap);\n    });\n  }\n\n  /** Viewing a Usj object as a tree, build a map to walk up the tree */\n  private createUsjParentMap(): UsjParentMap {\n    const parentMap = new Map<MarkerObject | MarkerContent[] | Usj, MarkerObject | Usj>();\n    if (this.usj.content) parentMap.set(this.usj.content, this.usj);\n    this.usj.content.forEach((content) => {\n      if (typeof content === 'object')\n        UsjReaderWriter.createParentMapInternal(content, this.usj, parentMap);\n    });\n    return parentMap;\n  }\n\n  /** Create the parent map if it doesn't already exist and return it */\n  private get parentMap(): UsjParentMap {\n    if (this.parentMapInternal) return this.parentMapInternal;\n    this.parentMapInternal = this.createUsjParentMap();\n    return this.parentMapInternal;\n  }\n\n  // #endregion Parent Maps\n\n  // #region Working Stacks\n\n  /**\n   * Checks if two stack items are equal using shallow equivalence, testing the stack item\n   * properties for [strict\n   * equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality)\n   *\n   * Note that this requires the parent of the two stack items to have reference equality\n   */\n  private static areStackItemsShallowEqual(a: StackItem, b: StackItem): boolean {\n    return a.index === b.index && a.parent === b.parent;\n  }\n\n  /** Return the working stack applicable to the given node */\n  private createWorkingStack(node: MarkerObject | Usj): WorkingStack {\n    // Represents levels in the USJ node tree that are above the current node (i.e., ancestors)\n    // Levels in the tree are represented as a stack, so the last item in the stack is node's parent\n    const workingStack: WorkingStack = [];\n\n    // Grab a reference so we don't keep checking if it exists\n    const { parentMap } = this;\n\n    // `node` might be in the middle of the USJ tree, so build up the stack before walking the tree\n    let tempNode: MarkerObject | Usj = node;\n    let tempParent = parentMap.get(tempNode);\n    while (tempParent !== undefined) {\n      if (!tempParent.content)\n        throw new Error('Invalid parentMap: all parents should have content');\n\n      if (\n        // Referencing tempNode and tempParent is OK in the loop since 'let' is used instead of 'var'\n        // eslint-disable-next-line no-loop-func\n        !tempParent.content.find((tempChild, index) => {\n          if (tempChild !== tempNode) return false;\n          if (!tempParent) throw new Error('undefined \"tempParent\" should not be possible');\n          workingStack.unshift({ parent: tempParent, index });\n          return true;\n        })\n      )\n        throw new Error(`Unable to find correct parent node of ${JSON.stringify(tempNode)}`);\n\n      tempNode = tempParent;\n      tempParent = parentMap.get(tempParent);\n    }\n\n    return workingStack;\n  }\n\n  /**\n   * Transform a JSONPath array (`JSONPath.toPathArray`) to a \"normalized\" JSONPath. We can use this\n   * JSONPath for lookups in {@link FragmentsByJsonPath}\n   */\n  private static jsonPathArrayToJsonPath(pathArray: string[]): string {\n    return pathArray.reduce((pathAcc, pathEntry) => {\n      if (pathEntry === 'content') return `${pathAcc}.${pathEntry}`;\n      if (!Number.isNaN(parseInt(pathEntry, 10))) return `${pathAcc}[${pathEntry}]`;\n      return `${pathAcc}['${pathEntry}']`;\n    });\n  }\n\n  /** \"Normalize\" the JSONPath passed in so we can use it for lookups in {@link FragmentsByJsonPath} */\n  private static normalizeJsonPath(jsonPath: string): string {\n    // Convert to path array and back to standardize property access syntax\n    const pathArray = JSONPath.toPathArray(jsonPath);\n    return UsjReaderWriter.jsonPathArrayToJsonPath(pathArray);\n  }\n\n  /**\n   * Returns a \"normalized\" JSONPath transformed from the working stack. We can use this JSONPath\n   * for lookups in {@link FragmentsByJsonPath}\n   */\n  private static convertWorkingStackToJsonPath(stack: WorkingStack): ContentJsonPath {\n    let jsonPath = '$';\n    stack.forEach((stackLevel) => {\n      jsonPath = `${jsonPath}.content[${stackLevel.index}]`;\n    });\n    // The JSONPath string construction above conforms to the ContentJsonPath type\n    // eslint-disable-next-line no-type-assertion/no-type-assertion\n    return jsonPath as ContentJsonPath;\n  }\n\n  /**\n   * Returns a \"normalized\" JSONPath transformed from the working stack and property. We can use\n   * this JSONPath for lookups in {@link FragmentsByJsonPath}\n   */\n  private static convertWorkingStackAndPropertyToJsonPath(\n    stack: WorkingStack,\n    property: string,\n  ): PropertyJsonPath {\n    // Adding this property makes it conform to PropertyJsonPath. Always using bracket notation\n    // because it works in more cases than dot notation does\n    // eslint-disable-next-line no-type-assertion/no-type-assertion\n    return `${UsjReaderWriter.convertWorkingStackToJsonPath(stack)}['${property}']` as PropertyJsonPath;\n  }\n\n  private convertJsonPathToWorkingStack(\n    jsonPath: ContentJsonPath | PropertyJsonPath,\n  ): WorkingStack {\n    const retVal: WorkingStack = [];\n\n    // If the JSONPath is pointing to the top marker, there are no content levels\n    if (jsonPath === '$') return retVal;\n\n    const levels = jsonPath.match(/content\\[(\\d+)\\]/g);\n    if (!levels) throw new Error(`Malformed or unexpected jsonPath: ${jsonPath}`);\n\n    let onNode: Usj | MarkerObject = this.usj;\n\n    levels.forEach((level, onLevel) => {\n      const indexString = /(\\d+)/.exec(level);\n      if (!indexString) throw new Error(`Malformed or unexpected jsonPath: ${jsonPath}`);\n      const index = parseInt(indexString[0], 10);\n      retVal.push({ parent: onNode, index });\n      if (onLevel + 1 < levels.length) {\n        if (typeof onNode === 'string' || !onNode.content)\n          throw new Error(`jsonPath points to node without children: ${JSON.stringify(onNode)}`);\n        const nextNode = onNode.content[index];\n        if (typeof nextNode === 'string')\n          throw new Error(`jsonPath points to node without children: ${JSON.stringify(nextNode)}`);\n        onNode = nextNode;\n      }\n    });\n\n    return retVal;\n  }\n\n  // #endregion Working Stacks\n\n  // #region Walk the node tree\n\n  /**\n   * Extract textual notes (aka, \"footnotes\") from a full USJ object.\n   *\n   * @returns An array of MarkerObjects representing all textual notes found in the USJ content.\n   */\n  findAllNotes(): MarkerObject[] {\n    return extractFootnotesFromUsjContent(this.usj?.content);\n\n    // Note that the following could be used instead of the above call to\n    // extractFootnotesFromUsjContent, and that function could be removed. However, this is about\n    // 100x slower than the custom traversal in extractFootnotesFromUsjContent.\n    // return this.findAll('$.content..[?(@.type==\"note\")]');\n    // This would depend on implementing findAll in this class:\n    // findAll<T>(jsonPathQuery: string): T[] {\n    //   const results = JSONPath({ path: jsonPathQuery, json: this.usj, wrap: true });\n    //   return Array.isArray(results) ? results as T[] : [];\n    // }\n  }\n\n  /**\n   * Look through the USJ document for a node or the closing of a node matching some condition. This\n   * will run `searchFunction` for `node`, all nodes encountered in `node.contents` (recursively),\n   * when `node` closes, and all nodes after `node`\n   *\n   * @param node Node from which to start looking\n   * @param workingStack Working stack pointing to this node (should not include this node)\n   * @param skipTypes List of marker types to skip (skips all contents of skipped markers)\n   * @param searchFunction Function that nodes and representations of the closing of nodes will be\n   *   passed into to determine if they are the correct node or representation of the closing of a\n   *   node. Stops searching and returns the node/close if this function returns `true`\n   * @returns Node or representation of the closing of a node matching condition tested by the\n   *   search function\n   */\n  private static findNextMatchingNodeOrClosingFragmentUsingWorkingStack(\n    node: MarkerContent | Usj,\n    workingStack: WorkingStack,\n    skipTypes: string[],\n    searchFunction: (\n      potentiallyMatchingNodeOrClose: MarkerContent | Usj | UsjClosingMarkerFragment,\n      workingStack: WorkingStack,\n    ) => boolean,\n  ) {\n    let nextNode: MarkerContent | Usj | undefined = node;\n\n    const topNode = workingStack.length === 0 ? node : workingStack[0].parent;\n    // If the top node is a marker as we would expect, we need to check if `node` is under a\n    // skipped-type node and skip past all that skipped stuff if so. If the top node is a `string`,\n    // don't need to worry about this since we should just be searching against that one string\n    if (!isString(topNode)) {\n      // Determine if we are in a skipped-type node and skip to the next node after it if so\n      // If the top node is skipped, return `undefined` because everything is skipped\n      if (skipTypes.includes(topNode.type)) return undefined;\n\n      // Find the highest (lowest index) stack item level that is skipped so we can go to its next\n      // sibling\n      let highestSkippedNode: MarkerContent | undefined;\n      workingStack.some((stackItem) => {\n        // We know that `content` exists due to its presence in this data structure\n        // eslint-disable-next-line no-type-assertion/no-type-assertion\n        const stackNode = stackItem.parent.content![stackItem.index];\n        if (!isString(stackNode) && skipTypes.includes(stackNode.type)) {\n          highestSkippedNode = stackNode;\n          return true;\n        }\n\n        return false;\n      });\n\n      // Set nextNode to the highest skipped node so it will skip and go to the next sibling in the\n      // following code\n      if (highestSkippedNode) nextNode = highestSkippedNode;\n    }\n\n    // Walk the nodes in a depth-first, left-to-right manner until the search function returns true\n    while (nextNode !== undefined) {\n      const skipNextNode = typeof nextNode === 'object' && skipTypes.includes(nextNode.type);\n\n      // If we found the node we're looking for, we're done\n      if (!skipNextNode && searchFunction(nextNode, workingStack)) return nextNode;\n\n      // Look at the node's children\n      if (!skipNextNode && typeof nextNode === 'object' && (nextNode.content?.length ?? 0) > 0) {\n        workingStack.push({ parent: nextNode, index: 0 });\n        // Same as `nextNode = nextNode.content[0];` without triggering 2 different eslint errors\n        [nextNode] = nextNode.content;\n      } else {\n        if (!skipNextNode) {\n          // The node has no children, so check the closing marker for this node\n          const nextNodeClosingMarker: UsjClosingMarkerFragment | undefined =\n            typeof nextNode === 'object'\n              ? { isClosingMarker: true, forMarker: nextNode }\n              : undefined;\n          if (nextNodeClosingMarker && searchFunction(nextNodeClosingMarker, workingStack))\n            return nextNodeClosingMarker;\n        }\n\n        // Then look at the next sibling, or the parent's next sibling, or the parent's closing\n        // marker, etc. up the stack\n        nextNode = undefined;\n        while (workingStack.length > 0) {\n          const nextLevel = workingStack.pop();\n          if (nextLevel) {\n            // We know that `content` exists due to its presence in this data structure\n            // eslint-disable-next-line no-type-assertion/no-type-assertion\n            if (nextLevel.index + 1 < nextLevel.parent.content!.length) {\n              // Check the next sibling\n              nextLevel.index += 1;\n              workingStack.push(nextLevel);\n              // We know that `content` exists due to its presence in this data structure\n              // eslint-disable-next-line no-type-assertion/no-type-assertion\n              nextNode = nextLevel.parent.content![nextLevel.index];\n              break;\n            } else {\n              // There is no next sibling, so check the closing marker for the parent before we\n              // continue to look at the parent's next sibling and etc.\n              const parentClosingMarker: UsjClosingMarkerFragment = {\n                isClosingMarker: true,\n                forMarker: nextLevel.parent,\n              };\n              if (searchFunction(parentClosingMarker, workingStack)) return parentClosingMarker;\n            }\n          }\n        }\n      }\n    }\n\n    // We've looked everywhere, so there must not be an appropriate node anywhere\n    return undefined;\n  }\n\n  /**\n   * Look through the USJ document for a node matching some condition\n   *\n   * @param node Node from which to start looking\n   * @param workingStack Working stack pointing to this node (should not include this node)\n   * @param skipTypes List of marker types to skip (skips all contents of skipped markers)\n   * @param searchFunction Function that nodes will be passed into to determine if they are the\n   *   correct node. Stops searching and returns the node if this function returns `true`\n   * @returns Node matching condition tested by the search function\n   */\n  private static findNextMatchingNodeUsingWorkingStack(\n    node: MarkerContent | Usj,\n    workingStack: WorkingStack,\n    skipTypes: string[],\n    searchFunction: (\n      potentiallyMatchingNode: MarkerContent | Usj,\n      workingStack: WorkingStack,\n    ) => boolean,\n  ): MarkerContent | undefined {\n    // We are filtering out closing markers in our search function\n    // eslint-disable-next-line no-type-assertion/no-type-assertion\n    const result = this.findNextMatchingNodeOrClosingFragmentUsingWorkingStack(\n      node,\n      workingStack,\n      skipTypes,\n      (potentiallyMatchingNodeOrClose, currentWorkingStack) => {\n        if (\n          typeof potentiallyMatchingNodeOrClose === 'object' &&\n          'isClosingMarker' in potentiallyMatchingNodeOrClose\n        )\n          // Skip closing markers\n          return false;\n\n        // Just search normal markers and text as appropriate for this method\n        return searchFunction(potentiallyMatchingNodeOrClose, currentWorkingStack);\n      },\n    ) as MarkerContent | undefined;\n\n    return result;\n  }\n\n  // #endregion Walk the node tree\n\n  // #region Node -> JSONPath\n\n  nodeToJsonPath(node: MarkerObject): ContentJsonPath {\n    return UsjReaderWriter.convertWorkingStackToJsonPath(this.createWorkingStack(node));\n  }\n\n  // #endregion Node -> JSONPath\n\n  // #region USJ node -> SerializedVerseRef + offset in USFM\n\n  nodeToUsfmVerseRefVerseLocation(\n    node: MarkerContent | Usj,\n    nodeParent?: MarkerObject | MarkerContent[] | Usj,\n    bookIdIfNotFound?: string,\n  ): UsfmVerseRefVerseLocation {\n    const { documentLocation: usjLocation } = this.nodeToUsjNodeAndDocumentLocation(\n      node,\n      nodeParent,\n    );\n\n    // Find the UsjFragmentInfo at this location\n    return this.usjDocumentLocationToUsfmVerseRefVerseLocation(usjLocation, bookIdIfNotFound);\n  }\n\n  // #endregion USJ node -> SerializedVerseRef + offset in USFM\n\n  // #region USJ node -> USJ location\n\n  nodeToUsjNodeAndDocumentLocation(\n    node: MarkerContent | Usj,\n    nodeParent?: MarkerObject | MarkerContent[] | Usj,\n  ): UsjNodeAndDocumentLocation {\n    // Get working stack to the node\n    let workingStack: WorkingStack;\n\n    if (isString(node)) {\n      // If the node is a string, we need to get the working stack from the parent and add the last\n      // level for the string node\n      if (nodeParent === undefined)\n        throw new Error(`If \"node\" is a string, then \"nodeParent\" cannot be undefined`);\n\n      // Get the real parent\n      const realParent = Array.isArray(nodeParent) ? this.parentMap.get(nodeParent) : nodeParent;\n      if (realParent === undefined)\n        throw new Error(`Cannot find parent for ${JSON.stringify(nodeParent)}`);\n\n      // Get the working stack to the parent\n      workingStack = this.createWorkingStack(realParent);\n\n      // Add the stack item for the string node\n      const nodeIndexInParent = realParent.content?.indexOf(node);\n      if (nodeIndexInParent === undefined || nodeIndexInParent < 0)\n        throw new Error(`Could not find index of node in parent for creating working stack`);\n      workingStack.push({ parent: realParent, index: nodeIndexInParent });\n    } else {\n      // The node is not a string, so it's easy to get the working stack\n      workingStack = this.createWorkingStack(node);\n    }\n\n    // Get the UsjDocumentLocation for this node so we can find the fragment at that location\n    const usjLocation = UsjReaderWriter.convertNodeToUsjDocumentLocation(node, workingStack);\n\n    return {\n      node,\n      documentLocation: usjLocation,\n    };\n  }\n\n  // #endregion USJ node -> USJ location\n\n  // #region JSONPath > USJ location\n\n  /**\n   * Finds the node associated with the JSONPath provided, and also gets the parent of the node if\n   * the node is a string. This is helpful so you can find a real object that is actually somewhere\n   * in the USJ document from the JSONPath\n   *\n   * @param jsonPathQuery JSONPath search expression that indicates a node within this USJ data. If\n   *   the expression matches more than one node, then only the first node found is considered.\n   * @returns First node found at the JSONPath and the parent of that node _if_ the node is a\n   *   string. Note that the object returned is the actual object in the USJ document.\n   */\n  private jsonPathToNodeAndParentIfString(jsonPathQuery: string): {\n    node: MarkerContent | Usj;\n    parent: MarkerObject | Usj | MarkerContent[] | undefined;\n  } {\n    // Find the node this JSONPath is pointing to\n    const target: MarkerContent | Usj | undefined = this.findSingleValue(jsonPathQuery);\n    if (!target) throw new Error(`No result found for JSONPath query: ${jsonPathQuery}`);\n\n    // Find the parent of this node if it is a string so we can know where it is\n    const parent: MarkerObject | Usj | MarkerContent[] | undefined = isString(target)\n      ? this.findParent(jsonPathQuery)\n      : undefined;\n    if (!parent && isString(target))\n      throw new Error(`Could not determine parent for ${jsonPathQuery}`);\n\n    return {\n      node: target,\n      parent,\n    };\n  }\n\n  jsonPathToUsjNodeAndDocumentLocation(jsonPathQuery: string): UsjNodeAndDocumentLocation {\n    const { node, parent } = this.jsonPathToNodeAndParentIfString(jsonPathQuery);\n\n    const usjNodeAndDocumentLocation = this.nodeToUsjNodeAndDocumentLocation(node, parent);\n\n    return usjNodeAndDocumentLocation;\n  }\n\n  // #endregion JSONPath > USJ location\n\n  // #region JSONPath or USJ location -> SerializedVerseRef + offset in USFM\n\n  jsonPathToUsfmVerseRefVerseLocation(\n    jsonPathQuery: string,\n    bookIdIfNotFound?: string,\n  ): UsfmVerseRefVerseLocation {\n    const { node, parent } = this.jsonPathToNodeAndParentIfString(jsonPathQuery);\n\n    const usfmVerseLocation = this.nodeToUsfmVerseRefVerseLocation(node, parent, bookIdIfNotFound);\n\n    return usfmVerseLocation;\n  }\n\n  usjDocumentLocationToUsfmVerseRefVerseLocation(\n    usjLocation: UsjDocumentLocation,\n    bookIdIfNotFound?: string,\n  ): UsfmVerseRefVerseLocation {\n    // Find the fragment with the matching UsjDocumentLocation except offset\n    const fragmentInfo = this.findFragmentInfoAtUsjDocumentLocation(usjLocation);\n    if (fragmentInfo === undefined)\n      throw new Error(\n        `Could not find fragment info at USJ document location while transforming to USFM verse location: ${JSON.stringify(\n          usjLocation,\n        )}`,\n      );\n\n    const verseRef = this.getVerseRefForIndexInUsfm(fragmentInfo.indexInUsfm, bookIdIfNotFound);\n\n    const verseIndexInUsfm = this.getIndexInUsfmForVerseRef(verseRef);\n\n    return {\n      verseRef,\n      // Final USFM verse offset is the fragment's location relative to the verse plus whatever\n      // offset is in the USJ location\n      offset:\n        fragmentInfo.indexInUsfm -\n        verseIndexInUsfm +\n        UsjReaderWriter.getOffsetInUsjDocumentLocation(usjLocation),\n    };\n  }\n\n  // #endregion JSONPath or USJ location -> SerializedVerseRef + offset in USFM\n\n  // #region Handling VerseRefs\n\n  /**\n   * Gets the book ID in the internal USJ document data corresponding to the book ID passed in.\n   *\n   * @param bookId The book ID to look up data in the USJ document for\n   * @returns If there isn't a book ID in the USJ document, {@link NO_BOOK_ID} will be returned\n   * @throws If the requested book is not found in the USJ data and there are other books\n   * @throws If there is no USJ content in the document whatsoever\n   */\n  private getEffectiveBookId(bookId: string): string {\n    const availableBookIds = Object.keys(this.indicesInUsfmByVerseRef);\n    const noBookIdsFound =\n      availableBookIds.length === 0 ||\n      (availableBookIds.length === 1 && availableBookIds[0] === NO_BOOK_ID);\n    const effectiveBookId = noBookIdsFound ? NO_BOOK_ID : bookId;\n    const bookIndices = this.indicesInUsfmByVerseRef[effectiveBookId];\n    if (!bookIndices)\n      throw new Error(\n        `Book ID ${bookId} not found in USJ! ${noBookIdsFound ? `There seems to be no USJ content because there is no content in ${NO_BOOK_ID} either` : `Book IDs in USJ: ${JSON.stringify(availableBookIds)}`}`,\n      );\n\n    return effectiveBookId;\n  }\n\n  /**\n   * Gets the index in USFM of the start of the verse (the backslash on the verse marker or the\n   * beginning of the chapter if verse 0 is provided)\n   */\n  private getIndexInUsfmForVerseRef(verseRef: SerializedVerseRef): number {\n    // Make sure the requested book ID is in the USJ content\n    const bookId = this.getEffectiveBookId(verseRef.book);\n    // `getEffectiveBookId` guaranteed bookIndices is defined\n    // eslint-disable-next-line no-type-assertion/no-type-assertion\n    const bookIndices = this.indicesInUsfmByVerseRef[bookId]!;\n\n    // Make sure the requested chapter number is in the USJ content\n    const chapterIndices = bookIndices[verseRef.chapterNum];\n    if (!chapterIndices) throw new Error(`Could not find ${bookId} chapter ${verseRef.chapterNum}`);\n\n    // Make sure the requested verse number is in the USJ content\n    // Only look for the verse number even if it is the starting number in a requested verse range\n    // because you are likely going to run into less obvious trouble if you get the index in USFM of\n    // the wrong verse in a range\n    const verseIndexInUsfm = chapterIndices[verseRef.verseNum];\n    if (verseIndexInUsfm === undefined)\n      throw new Error(`Verse ${verseRef.verseNum} not found in ${bookId} ${verseRef.chapterNum}`);\n\n    return verseIndexInUsfm;\n  }\n\n  /**\n   * Gets the verse ref that the provided index in USFM is in (including verse range if applicable).\n   * Finds the closest verse ref before the index in USFM.\n   *\n   * @param indexInUsfm The index in USFM from the beginning of this document\n   * @param bookIdIfNotFound 3-letter ID of the book this USJ document is in (only used if a book ID\n   *   is not found in the USJ document)\n   * @returns Closest verse reference before or at the index in USFM\n   * @throws If not able to find a book ID in the USJ document and `bookIdIfNotFound` is not\n   *   provided\n   */\n  private getVerseRefForIndexInUsfm(\n    indexInUsfm: number,\n    bookIdIfNotFound?: string,\n  ): SerializedVerseRef {\n    // ENHANCE: This could be sped up and simplified significantly by storing a sorted number map of\n    // verse refs by index in USFM like so:\n    /**\n     * Index in the USFM representation of the USJ document of where the start of each verse ref is\n     * (the backslash on the verse marker)\n     */\n    // type VerseRefsByIndexInUsfm = SortedNumberMap<SerializedVerseRef>;\n\n    const bookEntries = Object.entries(this.indicesInUsfmByVerseRef);\n    let bookIndex = 0;\n    let lastVerseRef: SerializedVerseRef | undefined;\n    let didFindVerseRef = false;\n\n    // Loop through all the books looking for the right book\n    while (!didFindVerseRef && bookIndex < bookEntries.length) {\n      const [bookId, chapterIndices] = bookEntries[bookIndex];\n\n      if (chapterIndices) {\n        const chapterEntries = Object.entries(chapterIndices);\n        let chapterIndex = 0;\n        // Loop through all the chapters looking for the right chapter\n        while (!didFindVerseRef && chapterIndex < chapterEntries.length) {\n          const [chapterNumString, verseIndices] = chapterEntries[chapterIndex];\n          if (verseIndices) {\n            const verseEntries = Object.entries(verseIndices);\n            let verseIndex = 0;\n            // Loop through all the verses looking for the right verse\n            while (!didFindVerseRef && verseIndex < verseEntries.length) {\n              const [verseNumString, verseIndexInUsfm] = verseEntries[verseIndex];\n\n              if (verseIndexInUsfm !== undefined) {\n                // If the verse ref index in USFM is past the index in USFM to find for the first time,\n                // this is the verse ref after this index in USFM. Return the last one\n                if (indexInUsfm < verseIndexInUsfm) {\n                  if (!lastVerseRef)\n                    // Somehow the index to find is less than the very first known index. Maybe that\n                    // means it's negative? Either way, it doesn't make sense\n                    throw new Error(\n                      `Could not find verse ref for index in USFM ${\n                        indexInUsfm\n                      } less than the first known index ${verseIndexInUsfm}`,\n                    );\n\n                  // We know the last verse ref, which was the final verse ref before this index.\n                  // Return that last verse ref\n                  didFindVerseRef = true;\n                  break;\n                }\n                // This verse ref is not past the index in USFM to find, so record this current verse\n                // ref to return later if we determine this is the right verse ref\n                lastVerseRef = {\n                  book: bookId,\n                  chapterNum: parseInt(chapterNumString, 10),\n                  verseNum: parseInt(verseNumString, 10),\n                };\n                // If the verse ref index is the same as the index to find, go ahead and return the\n                // current verse ref. No need to look at the next index\n                if (indexInUsfm === verseIndexInUsfm) {\n                  didFindVerseRef = true;\n                  break;\n                }\n              }\n\n              verseIndex += 1;\n            }\n          }\n\n          chapterIndex += 1;\n        }\n      }\n\n      bookIndex += 1;\n    }\n\n    if (!lastVerseRef)\n      throw new Error(`Did not find any verse refs while looking for index in USFM ${indexInUsfm}`);\n\n    if (lastVerseRef.book === NO_BOOK_ID) {\n      // Deal with no book ID\n      if (!bookIdIfNotFound)\n        throw new Error(\n          `Could not find book ID and no book ID provided when finding USFM verse ref for index in USFM ${\n            indexInUsfm\n          }`,\n        );\n\n      lastVerseRef.book = bookIdIfNotFound;\n    }\n\n    // If `didFindVerseRef` is `false`, the index in USFM to find is greater than all known indices\n    // in USFM. That means it's in the very last verse ref. That's fine; no need to do anything\n    // special.\n\n    // Add the verse range if the verse marker for this location's verse is a range\n    const verseIndexInUsfm = this.getIndexInUsfmForVerseRef(lastVerseRef);\n    const verseFragmentInfo = this.fragmentsByIndexInUsfm.get(verseIndexInUsfm);\n    if (\n      verseFragmentInfo &&\n      UsjReaderWriter.isFragmentAMarker(verseFragmentInfo.fragment) &&\n      verseFragmentInfo.fragment.type === VERSE_TYPE &&\n      verseFragmentInfo.fragment.number &&\n      verseFragmentInfo.fragment.number !== `${lastVerseRef.verseNum}`\n    )\n      lastVerseRef.verse = verseFragmentInfo.fragment.number;\n\n    return lastVerseRef;\n  }\n\n  usfmVerseLocationToIndexInUsfm(usfmVerseLocation: UsfmVerseLocation): number {\n    const { verseRef, offset: verseRefOffset } =\n      UsjReaderWriter.usfmVerseLocationToUsfmVerseRefVerseLocation(usfmVerseLocation);\n\n    if (verseRefOffset < 0) throw new Error('offset must be >= 0');\n\n    // Find the index in the whole USFM of this verse\n    const verseIndexInUsfm = this.getIndexInUsfmForVerseRef(verseRef);\n\n    // Add the verse offset to the verse index to get the USFM location's index in the USFM\n    // representation of this USJ document\n    const usfmVerseLocationIndexInUsfm = verseIndexInUsfm + verseRefOffset;\n\n    return usfmVerseLocationIndexInUsfm;\n  }\n\n  // #endregion Handling VerseRefs\n\n  // #region transforming location types to different types\n\n  /**\n   * Transforms a USFM verse-based location into a single standardized format of USFM verse-based\n   * location for ease of accessing the location's properties\n   *\n   * @param usfmVerseLocation USFM verse-based location in one of multiple forms\n   * @returns USFM verse-based location in one particular form. Also ensures `offset` is defined\n   *   (defaults to 0 as described in {@link UsfmVerseLocation})\n   */\n  static usfmVerseLocationToUsfmVerseRefVerseLocation(\n    usfmVerseLocation: UsfmVerseLocation,\n  ): UsfmVerseRefVerseLocation & { offset: number } {\n    if ('verseRef' in usfmVerseLocation) {\n      // UsfmVerseRefVerseLocation\n      return {\n        verseRef: usfmVerseLocation.verseRef,\n        offset: usfmVerseLocation.offset ?? 0,\n      };\n    }\n\n    if ('scrRef' in usfmVerseLocation) {\n      // Old deprecated form UsfmScrRefVerseLocation\n      return {\n        verseRef: usfmVerseLocation.scrRef,\n        offset: usfmVerseLocation.offset ?? 0,\n      };\n    }\n\n    // SerializedVerseRef\n    return {\n      verseRef: usfmVerseLocation,\n      offset: 0,\n    };\n  }\n\n  /**\n   * Transforms a USJ chapter-based location into a single standardized format of USJ chapter-based\n   * location for ease of accessing the location's properties\n   *\n   * @param usjChapterLocation USJ chapter-based location in one of multiple forms\n   * @returns USJ chapter-based location in one particular form.\n   * @throws If erroneously received a {@link UsjBookLocation}, not a {@link UsjChapterLocation}.\n   *   Cannot statically transform between those because there is no way to know how to change the\n   *   JSONPath\n   */\n  static usjChapterLocationToUsjVerseRefChapterLocation(\n    usjChapterLocation: UsjChapterLocation,\n  ): UsjVerseRefChapterLocation {\n    // Old deprecated UsjFlatTextChapterLocation\n    if ('jsonPath' in usjChapterLocation) {\n      if (usjChapterLocation.offset !== undefined)\n        // with UsjTextContentLocation (has offset). Unfortunately, TypeScript really doesn't like\n        // having this and the following type returned via the same object even though they're very\n        // similar because of the required presence/absence of `offset` in each of the returned\n        // types. Just breaking them out into separate returns.\n        return {\n          verseRef: {\n            book: usjChapterLocation.book,\n            chapterNum: usjChapterLocation.chapterNum,\n            verseNum: 0,\n          },\n          granularity: 'chapter',\n          documentLocation: {\n            jsonPath: usjChapterLocation.jsonPath,\n            offset: usjChapterLocation.offset,\n          },\n        };\n      // with UsjMarkerLocation (does not have offset)\n      return {\n        verseRef: {\n          book: usjChapterLocation.book,\n          chapterNum: usjChapterLocation.chapterNum,\n          verseNum: 0,\n        },\n        granularity: 'chapter',\n        documentLocation: {\n          jsonPath: usjChapterLocation.jsonPath,\n        },\n      };\n    }\n\n    // UsjVerseRefChapterLocation<TDocumentLocation>\n    if ('verseRef' in usjChapterLocation) {\n      if (\n        // Make sure we are receiving a chapter location, not a book location\n        usjChapterLocation.granularity !== undefined &&\n        usjChapterLocation.granularity !== 'chapter'\n      )\n        throw new Error(\n          'Received UsjVerseRefBookLocation! Cannot statically transform JSONPath from book-relative to chapter-relative',\n        );\n\n      return usjChapterLocation;\n    }\n\n    // UsjFlatChapterLocation<TDocumentLocation>\n    // Make sure we are receiving a chapter location, not a book location\n    if (usjChapterLocation.chapterNum === undefined)\n      throw new Error(\n        'Received UsjFlatBookLocation! Cannot statically transform JSONPath from book-relative to chapter-relative',\n      );\n\n    return {\n      verseRef: {\n        book: usjChapterLocation.book,\n        chapterNum: usjChapterLocation.chapterNum,\n        verseNum: 0,\n      },\n      granularity: 'chapter',\n      documentLocation: usjChapterLocation.documentLocation,\n    };\n  }\n\n  /**\n   * Transforms a USJ book-based location into a single standardized format of USJ book-based\n   * location for ease of accessing the location's properties\n   *\n   * @param usjBookLocation USJ book-based location in one of multiple forms\n   * @returns USJ book-based location in one particular form.\n   * @throws If erroneously received a {@link UsjChapterLocation}, not a {@link UsjBookLocation}.\n   *   Cannot statically transform between those because there is no way to know how to change the\n   *   JSONPath\n   */\n  static usjBookLocationToUsjVerseRefBookLocation(\n    usjBookLocation: UsjBookLocation,\n  ): UsjVerseRefBookLocation {\n    // UsjVerseRefBookLocation<TDocumentLocation>\n    if ('verseRef' in usjBookLocation) {\n      if (\n        // Make sure we are receiving a book location, not a chapter location\n        usjBookLocation.granularity !== 'book'\n      )\n        throw new Error(\n          'Received UsjVerseRefChapterLocation! Cannot statically transform JSONPath from chapter-relative to book-relative',\n        );\n\n      return usjBookLocation;\n    }\n\n    // UsjFlatBookLocation<TDocumentLocation>\n    // Make sure we are receiving a book location, not a chapter location\n    if ('chapterNum' in usjBookLocation)\n      throw new Error(\n        'Received UsjFlatChapterLocation! Cannot statically transform JSONPath from chapter-relative to book-relative',\n      );\n\n    return {\n      verseRef: {\n        book: usjBookLocation.book,\n        chapterNum: 1,\n        verseNum: 0,\n      },\n      granularity: 'book',\n      documentLocation: usjBookLocation.documentLocation,\n    };\n  }\n\n  // #endregion transforming location types to different types\n\n  // #region USFM location -> USJ location\n\n  usfmVerseLocationToUsjNodeAndDocumentLocation(\n    usfmVerseLocation: UsfmVerseLocation,\n  ): UsjNodeAndDocumentLocation {\n    const { verseRef, offset: verseRefOffset } =\n      UsjReaderWriter.usfmVerseLocationToUsfmVerseRefVerseLocation(usfmVerseLocation);\n\n    // Get the USFM location's index in the USFM representation of this USJ document\n    const usfmVerseLocationIndexInUsfm = this.usfmVerseLocationToIndexInUsfm(usfmVerseLocation);\n\n    // Find the fragment info at this USFM location\n    const { value: fragmentInfo } = this.fragmentsByIndexInUsfm.findClosestLessThanOrEqual(\n      usfmVerseLocationIndexInUsfm,\n    ) ?? {\n      value: undefined,\n    };\n    if (!fragmentInfo)\n      throw new Error(\n        `Somehow, did not find anything at index in verse ${verseRefOffset} or below in ${verseRef.book} ${verseRef.chapterNum}:${verseRef.verseNum}. Not sure how this would happen.`,\n      );\n\n    // Get the offset within the fragment where the USFM location is pointing\n    const usjOffset = usfmVerseLocationIndexInUsfm - fragmentInfo.indexInUsfm;\n\n    // Add the offset to the fragment's UsjDocumentLocation and return it\n    return {\n      ...fragmentInfo.nodeAndDocumentLocation,\n      documentLocation: UsjReaderWriter.moveUsjDocumentLocationToNewOffset(\n        fragmentInfo.nodeAndDocumentLocation.documentLocation,\n        usjOffset,\n      ),\n    };\n  }\n\n  usfmVerseLocationToUsjDocumentLocation(\n    usfmVerseLocation: UsfmVerseLocation | SerializedVerseRef,\n  ): UsjDocumentLocation {\n    return this.usfmVerseLocationToUsjNodeAndDocumentLocation(usfmVerseLocation).documentLocation;\n  }\n\n  // #endregion USFM location -> USJ location\n\n  // #region UsjDocumentLocation utilities\n\n  /**\n   * Determine if the USJ document location is pointing to a text content location instead of some\n   * location related to a marker object\n   *\n   * @param usjDocumentLocation USJ document location to test\n   * @returns `true` if the location is for text content; `false` otherwise\n   */\n  static isUsjDocumentLocationForTextContent(\n    usjDocumentLocation: UsjDocumentLocation,\n  ): usjDocumentLocation is UsjTextContentLocation;\n  /**\n   * Determine if the USJ document location in this node and document location is pointing to a text\n   * content location instead of some location related to a marker object\n   *\n   * @param usjNodeAndDocumentLocation USJ node and document location to test\n   * @returns `true` if the location is for text content; `false` otherwise\n   */\n  static isUsjDocumentLocationForTextContent(\n    usjNodeAndDocumentLocation: UsjNodeAndDocumentLocation,\n  ): usjNodeAndDocumentLocation is UsjNodeAndDocumentLocation<UsjTextContentLocation>;\n  static isUsjDocumentLocationForTextContent(\n    usjDocumentLocationMaybeNode: UsjDocumentLocation | UsjNodeAndDocumentLocation,\n  ): boolean {\n    let documentLocation = usjDocumentLocationMaybeNode;\n    if ('node' in usjDocumentLocationMaybeNode) {\n      // If it's a UsjNodeAndDocumentLocation, the node must be a string\n      if (!isString(usjDocumentLocationMaybeNode.node)) return false;\n\n      documentLocation = usjDocumentLocationMaybeNode.documentLocation;\n    }\n\n    // Text content representation in USJDocumentLocation requires offset and nothing else has offset\n    return 'offset' in documentLocation;\n  }\n\n  // #endregion UsjDocumentLocation utilities\n\n  // #region Search for text from a certain point\n\n  usfmVerseLocationToNextTextLocation(\n    usfmVerseLocation: UsfmVerseLocation,\n  ): UsjNodeAndDocumentLocation<UsjTextContentLocation> {\n    // Get the location of the verse marker\n    const verseLocation = this.usfmVerseLocationToUsjNodeAndDocumentLocation(usfmVerseLocation);\n\n    // Find the first string after the verse marker\n    const firstStringLocationAfterVerseMarker = this.findNextLocationOfMatchingText(\n      verseLocation,\n      '',\n    );\n\n    if (!firstStringLocationAfterVerseMarker)\n      throw new Error(\n        `Could not find next text location after verse ${JSON.stringify(usfmVerseLocation)} at location ${\n          verseLocation.documentLocation.jsonPath\n        }`,\n      );\n\n    return firstStringLocationAfterVerseMarker;\n  }\n\n  findNextLocationOfMatchingText(\n    startingPoint: UsjNodeAndDocumentLocation,\n    text: string,\n    maxTextLengthToSearch: number = 1000,\n  ): UsjNodeAndDocumentLocation<UsjTextContentLocation> | undefined {\n    let textScanned = '';\n    let lengthScanned = 0;\n    let lengthTrimmed = 0;\n    let foundStartingAtOffset = -1;\n    const workingStackForStartingPoint = this.convertJsonPathToWorkingStack(\n      startingPoint.documentLocation.jsonPath,\n    );\n    // Get the starting point stack item so we can offset our staring search point by the offset.\n    // But if we started at the top USJ marker, the starting point isn't text, so we don't need to\n    // worry about offsetting as there is no offset.\n    // Cloning because the working stack items are modified during search\n    const startingPointStackItem =\n      workingStackForStartingPoint.length > 0\n        ? {\n            ...workingStackForStartingPoint[workingStackForStartingPoint.length - 1],\n          }\n        : undefined;\n    UsjReaderWriter.findNextMatchingNodeUsingWorkingStack(\n      startingPoint.node,\n      workingStackForStartingPoint,\n      NODE_TYPES_NOT_CONTAINING_VERSE_TEXT,\n      (node, workingStack) => {\n        if (typeof node !== 'string') return false;\n\n        let nodeTextToSearch = node;\n\n        const currentStackItem = workingStack[workingStack.length - 1];\n\n        // If the node is the starting point, then we need to start scanning from the offset.\n        // Otherwise look from the start of the string\n        if (\n          startingPointStackItem &&\n          UsjReaderWriter.areStackItemsShallowEqual(currentStackItem, startingPointStackItem)\n        ) {\n          if (!('offset' in startingPoint.documentLocation))\n            throw new Error(\n              `Somehow 'offset' was not in text content string document location. This should not happen. ${JSON.stringify(startingPoint.documentLocation)}`,\n            );\n          nodeTextToSearch = node.substring(startingPoint.documentLocation.offset);\n          // We're skipping the offset characters in the first node, so we need to adjust the final\n          // foundStartingAtOffset to account for that\n          lengthTrimmed += startingPoint.documentLocation.offset;\n        }\n\n        lengthScanned += nodeTextToSearch.length;\n        textScanned = `${textScanned}${nodeTextToSearch}`;\n        const textIndex = textScanned.indexOf(text);\n        if (textIndex < 0) {\n          // Keep the string we're keeping around from going too large\n          lengthTrimmed += textScanned.length;\n          if (textScanned.length > text.length)\n            textScanned = textScanned.substring(textScanned.length - text.length);\n          lengthTrimmed -= textScanned.length;\n\n          // Stop looking if we haven't found it after scanning a lot of text\n          return lengthScanned > maxTextLengthToSearch;\n        }\n\n        // We found it!\n        foundStartingAtOffset = lengthTrimmed + textIndex;\n        return true;\n      },\n    );\n\n    // We never found what we wanted\n    if (foundStartingAtOffset < 0) return undefined;\n\n    // The text might have been split between nodes, so we have to go through it one more time\n    lengthScanned = 0;\n    let finalOffset = 0;\n    let finalStack: WorkingStack = [];\n    const finalNode = UsjReaderWriter.findNextMatchingNodeUsingWorkingStack(\n      startingPoint.node,\n      this.convertJsonPathToWorkingStack(startingPoint.documentLocation.jsonPath),\n      NODE_TYPES_NOT_CONTAINING_VERSE_TEXT,\n      (node, stack) => {\n        if (typeof node !== 'string') return false;\n\n        lengthScanned += node.length;\n        if (lengthScanned < foundStartingAtOffset + 1) return false;\n\n        finalOffset = foundStartingAtOffset - lengthScanned + node.length;\n        finalStack = stack;\n        return true;\n      },\n    );\n    if (!finalNode) throw new Error('Internal error: inconsistent search results');\n    if (!isString(finalNode))\n      throw new Error(\n        `Somehow found non-string node while searching for strings: ${JSON.stringify(finalNode)}`,\n      );\n\n    return {\n      node: finalNode,\n      documentLocation: {\n        jsonPath: UsjReaderWriter.convertWorkingStackToJsonPath(finalStack),\n        offset: finalOffset,\n      },\n    };\n  }\n\n  search(regex: RegExp): UsjSearchResult[] {\n    const retVal: UsjSearchResult[] = [];\n    if (this.usj.content.length === 0) return retVal;\n\n    // Start searching from the first node in the USJ content tree\n    const startingPoint: UsjNodeAndDocumentLocation = {\n      node: this.usj,\n      documentLocation: {\n        jsonPath: `$`,\n      },\n    };\n\n    // This will hold all of the text content from the USJ, so we can search it all at once\n    const textChunks: string[] = [];\n    // This will map the index of each text chunk in the full text, so we can find the location\n    const fullTextIndexMap = new SortedNumberMap<\n      UsjNodeAndDocumentLocation<UsjTextContentLocation>\n    >();\n\n    // Variables to track our current position while walking through the USJ content tree\n    let currentIndex = 0;\n    let nextNode: MarkerContent | Usj | undefined = startingPoint.node;\n    while (nextNode !== undefined) {\n      nextNode = UsjReaderWriter.findNextMatchingNodeUsingWorkingStack(\n        startingPoint.node,\n        this.convertJsonPathToWorkingStack(startingPoint.documentLocation.jsonPath),\n        [],\n        // We need to use variables from outside the function to keep track of our current position\n        // eslint-disable-next-line no-loop-func\n        (node, workingStack) => {\n          if (typeof node !== 'string') return false;\n\n          textChunks.push(node);\n          fullTextIndexMap.set(currentIndex, {\n            node,\n            documentLocation: {\n              offset: 0,\n              jsonPath: UsjReaderWriter.convertWorkingStackToJsonPath(workingStack),\n            },\n          });\n          currentIndex += node.length;\n          return false;\n        },\n      );\n    }\n\n    // Connect all the text chunks together so we can search them all at once. Note that there are\n    // no spaces between the text chunks. If we need spaces inserted between verses, chapters, etc.\n    // then we should adjust how we walk through the tree to insert extra spaces at the right times.\n    const fullText = textChunks.join('');\n\n    // Lean on regular expressions to do the heavy lifting of finding matches\n    let match: RegExpExecArray | null = regex.exec(fullText);\n    while (match) {\n      // If the match is empty, then we don't want to include it in the results\n      if (match[0].length > 0) {\n        if (match.index < 0 || match.index >= fullText.length)\n          throw new Error(`Match index out of bounds: ${match.index}`);\n\n        const startingNodeEntry = fullTextIndexMap.findClosestLessThanOrEqual(match.index);\n        if (!startingNodeEntry)\n          throw new Error(`Internal error: no starting node found for index ${match.index}`);\n        const start: UsjNodeAndDocumentLocation<UsjTextContentLocation> = {\n          node: startingNodeEntry.value.node,\n          documentLocation: {\n            jsonPath: startingNodeEntry.value.documentLocation.jsonPath,\n            offset: match.index - startingNodeEntry.key,\n          },\n        };\n\n        // Have to find the node containing the last character in the match so we don't go past the\n        // ending text node and to the next text node that may be multiple markers past the end text\n        // node. Then do NOT subtract one from the index in the offset since the ending location is\n        // exclusive, meaning the last character in the match is the character before the ending\n        // location.\n        const endingNodeEntry = fullTextIndexMap.findClosestLessThanOrEqual(\n          match.index + match[0].length - 1,\n        );\n        if (!endingNodeEntry)\n          throw new Error(`Internal error: no ending node found for index ${match.index}`);\n        const end: UsjNodeAndDocumentLocation<UsjTextContentLocation> = {\n          node: endingNodeEntry.value.node,\n          documentLocation: {\n            jsonPath: endingNodeEntry.value.documentLocation.jsonPath,\n            offset: match.index + match[0].length - endingNodeEntry.key,\n          },\n        };\n\n        retVal.push({ text: match[0], start, end });\n      }\n\n      // If the regex is not global, then running `exec` again will return the same match\n      if (!regex.global) break;\n      match = regex.exec(fullText);\n    }\n\n    return retVal;\n  }\n\n  // #endregion Search for text from a certain point\n\n  // #region Extract text from a node + JSONPath + offset\n\n  extractText(start: UsjNodeAndDocumentLocation, desiredLength: number): string {\n    let retVal = '';\n    let offsetRemaining = 'offset' in start.documentLocation ? start.documentLocation.offset : 0;\n    let lengthRecorded = 0;\n    UsjReaderWriter.findNextMatchingNodeUsingWorkingStack(\n      start.node,\n      this.convertJsonPathToWorkingStack(start.documentLocation.jsonPath),\n      NODE_TYPES_NOT_CONTAINING_VERSE_TEXT,\n      (node) => {\n        if (typeof node !== 'string') return false;\n        if (offsetRemaining >= node.length) {\n          offsetRemaining -= node.length;\n          return false;\n        }\n        let remainingNode = node;\n        if (offsetRemaining > 0) {\n          remainingNode = remainingNode.substring(offsetRemaining);\n          offsetRemaining = 0;\n        }\n        if (lengthRecorded + remainingNode.length < desiredLength) {\n          lengthRecorded += remainingNode.length;\n          retVal = `${retVal}${remainingNode}`;\n          return false;\n        }\n        const lengthToCopy = desiredLength - lengthRecorded;\n        retVal = `${retVal}${remainingNode.substring(0, lengthToCopy - 1)}`;\n        return true;\n      },\n    );\n    return retVal;\n  }\n\n  extractTextBetweenPoints(\n    start: UsjNodeAndDocumentLocation,\n    end: UsjNodeAndDocumentLocation,\n    maxLength: number = 100,\n  ): string {\n    let retVal = '';\n    UsjReaderWriter.findNextMatchingNodeUsingWorkingStack(\n      start.node,\n      this.convertJsonPathToWorkingStack(start.documentLocation.jsonPath),\n      NODE_TYPES_NOT_CONTAINING_VERSE_TEXT,\n      (node, currentStack) => {\n        // `node` and `end.node` are both `MarkerContent` which might be strings or objects\n        if (node === end.node) {\n          // If both objects are the same, then we definitely found `end`\n          if (typeof node === 'object') return true;\n\n          // If both strings are the same, we need to verify that we're at the same place in `usj`\n          if (\n            end.documentLocation.jsonPath ===\n            UsjReaderWriter.convertWorkingStackToJsonPath(currentStack)\n          )\n            return true;\n        }\n        if (typeof node !== 'string') return false;\n        retVal = `${retVal}${node}`;\n        if (retVal.length > maxLength) retVal = retVal.substring(0, maxLength);\n        return retVal.length >= maxLength;\n      },\n    );\n    return retVal;\n  }\n\n  // #endregion Extract text from a node + JSONPath + offset\n\n  // #region Edit this USJ data\n\n  private static removeContentNodesFromArray(\n    contentArray: MarkerContent[],\n    searchFunction: (potentiallyMatchingNode: MarkerContent) => boolean,\n  ) {\n    let removedCount = 0;\n    for (let i = contentArray.length - 1; i >= 0; i--) {\n      const node = contentArray[i];\n      if (searchFunction(node)) {\n        contentArray.splice(i, 1);\n        removedCount += 1;\n      } else if (typeof node !== 'string' && node.content)\n        removedCount += this.removeContentNodesFromArray(node.content, searchFunction);\n    }\n    return removedCount;\n  }\n\n  removeContentNodes(searchFunction: (potentiallyMatchingNode: MarkerContent) => boolean): number {\n    const retVal = UsjReaderWriter.removeContentNodesFromArray(this.usj.content, searchFunction);\n    this.usjChanged();\n    return retVal;\n  }\n\n  // #endregion Edit this USJ data\n\n  // #region transform USJ to USFM\n\n  /**\n   * Get `MarkerInfo` by marker name\n   *\n   * @param markerName Name of the marker for which to get `MarkerInfo`\n   * @returns `MarkerInfo` for the marker by name if the marker is in the markers map. `undefined`\n   *   if the marker is not in the markers map. If you have the marker type, you can build a fake\n   *   `MarkerInfo` for an unknown marker by making an object with just the type. If not, might be\n   *   best to throw an error since there probably isn't enough information available to do anything\n   *   with that marker.\n   */\n  private getMarkerInfo(markerName: string): MarkerInfo | undefined {\n    // Try to get by exact marker name first\n    let markerInfo = this.markersMap.markers[markerName];\n\n    // If not found by exact name, try to match the RegExp marker names\n    if (!markerInfo)\n      [, markerInfo] =\n        Object.entries(this.markersMap.markersRegExp).find(([markerRegExp]) =>\n          new RegExp(markerRegExp).test(markerName),\n        ) ?? [];\n\n    // Return the marker info we found or `undefined` if we didn't find one\n    return markerInfo;\n  }\n\n  /**\n   * Gathers various pieces of information about a marker that are helpful for transforming the\n   * marker to USFM\n   *\n   * WARNING: this only has the ability to return the info for the marker to be used in USFM. If you\n   * need to use info for the marker in USX or USJ, this method needs to be modified.\n   *\n   * @param marker A USJ marker (can be USJ type) or a string which is the marker name\n   * @param scriptureFormat The Scripture format to get the marker information for. For example, if\n   *   you are using this marker info to transform the marker into USFM, this should be `usfm`.\n   *   Defaults to `usfm`\n   * @returns Various pieces of info about the marker\n   */\n  private getInfoForMarker(\n    marker: MarkerObject | Usj | string,\n    scriptureFormat: 'usfm' = 'usfm',\n  ): {\n    /**\n     * Marker name on the original marker itself as opposed to the marker name in this Scripture\n     * format\n     */\n    markerNameOriginal: string;\n    /**\n     * Name of the marker in this Scripture format. For example, In USFM format, the `usx` marker's\n     * name is `usfm`\n     */\n    markerName: string;\n    /** Marker info corresponding to `markerName`, not `markerNameOriginal` */\n    markerInfo: MarkerInfo;\n    /**\n     * This marker's type in this Scripture format. For example, In USFM format, the `table:cell`\n     * type is `cell`\n     */\n    markerType: string;\n    /** Marker info corresponding to `markerType`, not the marker's original `type` */\n    markerTypeInfo: MarkerTypeInfo;\n    /**\n     * Array of tuples containing the USFM name of an attribute marker that may be present on this\n     * marker and the marker info for that attribute marker\n     *\n     * This is like the returned value from `Object.entries`. However, the order of these is\n     * important in some cases, so it cannot simply be an object.\n     */\n    attributeMarkerInfoEntries: [\n      attributeMarkerName: string,\n      attributeMarkerInfo: AttributeMarkerInfo,\n    ][];\n  } {\n    if (scriptureFormat !== 'usfm')\n      throw new Error(\n        'Scripture formats beside usfm are not supported for getting info for markers',\n      );\n\n    const markerNameOriginal = isString(marker)\n      ? marker\n      : // Usj type has no `marker` property, but the Usj marker isn't really different than any other\n        // marker with no `marker` property. It is appropriate to treat them the same to get the name\n        // eslint-disable-next-line no-type-assertion/no-type-assertion\n        ((marker as MarkerObject).marker ?? marker.type);\n\n    // If we don't have marker info for the marker or the marker type doesn't match the type in the\n    // marker info, this marker is considered unknown. Do some special handling.\n    let markerIsUnknown = false;\n\n    let markerInfo = this.getMarkerInfo(markerNameOriginal);\n    const markerTypeFromFirstMarkerInfo = markerInfo?.type ?? (isString(marker) ? '' : marker.type);\n    let markerName = markerNameOriginal;\n\n    // Get the actual marker name and info in this format if it is different\n    if (markerInfo?.markerUsfm) {\n      // Replace the current marker name and info with the info appropriate to this format\n      markerName = markerInfo.markerUsfm;\n      markerInfo = this.getMarkerInfo(markerName);\n    }\n\n    // Didn't find the marker, so create `MarkerInfo` with the marker type if possible\n    if (!markerInfo) {\n      if (isString(marker))\n        throw new Error(`Unknown marker ${markerNameOriginal} and no marker type provided`);\n\n      markerInfo = { type: marker.type };\n      markerIsUnknown = true;\n\n      console.warn(\n        `Unknown marker ${markerNameOriginal}. Creating MarkerInfo to use: ${JSON.stringify(markerInfo)}`,\n      );\n    }\n\n    // Get the marker type\n    let markerType = markerInfo.type;\n    let markerTypeInfo = this.markersMap.markerTypes[markerType];\n\n    // Get the actual marker type and type info in this format if it is different\n    if (markerTypeInfo?.markerTypeUsfm) {\n      // Replace the current marker name and info with the info appropriate to this format\n      markerType = markerTypeInfo.markerTypeUsfm;\n      markerTypeInfo = this.markersMap.markerTypes[markerType];\n    }\n\n    // If the actual marker's type is not one of the expected types, something is wrong. Use the\n    // actual marker's type\n    if (\n      !isString(marker) &&\n      marker.type !== markerTypeFromFirstMarkerInfo &&\n      (!markerTypeInfo ||\n        (marker.type !== markerTypeInfo.markerTypeUsfm &&\n          marker.type !== markerTypeInfo.markerTypeUsx &&\n          marker.type !== markerTypeInfo.markerTypeUsj))\n    ) {\n      console.warn(\n        `Warning: Mismatching marker type in the USJ content ${marker.type} vs marker type in the marker info ${markerInfo.type} for marker ${markerNameOriginal}. Using the type from the USJ content.`,\n      );\n      markerType = marker.type;\n      markerTypeInfo = this.markersMap.markerTypes[markerType];\n      markerIsUnknown = true;\n    }\n\n    // Couldn't find the marker type info\n    // Note: In this case, Paratext just ignores the marker and prints the marker's content. This\n    // really shouldn't happen, though. I had to manually change a marker type in USX and then import\n    // it to Paratext to see this behavior. If you hit this, something is already going terribly wrong.\n    if (!markerTypeInfo) {\n      throw new Error(\n        `Unknown marker type ${markerType} on marker ${markerNameOriginal}! Cannot proceed.`,\n      );\n    }\n\n    if (markerIsUnknown && markerType === 'para')\n      // Special case: If the marker type is para and it is unknown, do not add a newline before\n      // the marker to match Paratext 9.4. We'll just do the same for spec for now since spec\n      // seems to be silent regarding what to do about unknown markers\n      markerTypeInfo = { ...markerTypeInfo, hasNewlineBefore: false };\n\n    // Figure out attribute marker attribute names\n    const attributeMarkerInfoEntries: [string, AttributeMarkerInfo][] = [];\n    if (markerInfo.attributeMarkers) {\n      markerInfo.attributeMarkers.forEach((attributeMarkerName) => {\n        // Note: we are not attempting to get the appropriate marker for the relevant Scripture\n        // representation aka we are not using `markerUsfm` for example. There are no attribute\n        // markers that have alternate representations and are not likely to be any ever. If that\n        // changes, this may cause bugs.\n        const attributeMarkerInfo = this.getMarkerInfo(attributeMarkerName);\n\n        // Markers map lists an attribute marker that doesn't exist. Just skip this attribute\n        if (!attributeMarkerInfo) return;\n\n        // Markers map lists an attribute marker that doesn't seem to be an attribute marker.\n        // Just skip this attribute\n        if (!('attributeMarkerAttributeName' in attributeMarkerInfo)) return;\n\n        attributeMarkerInfoEntries.push([attributeMarkerName, attributeMarkerInfo]);\n      });\n    }\n\n    // According to `cell`'s `outputToUsfmInstructions`, cell-type markers with `colspan` need to be\n    // cell range marker in USFM, so let's figure that out now\n    // Markers can have any properties. All are strings. Only exception is content, so don't use\n    // it here\n    // eslint-disable-next-line no-type-assertion/no-type-assertion\n    const markerWithAnyAttributes = marker as unknown as Record<string, string>;\n    if (scriptureFormat === 'usfm' && markerType === 'cell' && markerWithAnyAttributes.colspan) {\n      // Get the number of columns that this cell spans\n      const columnsSpanned = parseInt(markerWithAnyAttributes.colspan, 10);\n\n      const tableMarkerMatches = TABLE_MARKER_NUMBER_REGEXP.exec(markerNameOriginal);\n\n      if (tableMarkerMatches?.[1]) {\n        // Get the starting cell column number\n        const startingColumn = parseInt(tableMarkerMatches[1], 10);\n        if (!Number.isNaN(startingColumn) && !Number.isNaN(columnsSpanned)) {\n          // Create cell range marker like `tc1-3`\n          markerName = `${markerNameOriginal}-${startingColumn + columnsSpanned - 1}`;\n          // Set `colspan` so it is not output to USFM since it was just incorporated properly\n          markerTypeInfo = {\n            ...markerTypeInfo,\n            skipOutputAttributeToUsfm: [\n              ...(markerTypeInfo.skipOutputAttributeToUsfm ?? []),\n              'colspan',\n            ],\n          };\n        }\n      }\n    }\n\n    return {\n      markerNameOriginal,\n      markerName,\n      markerInfo,\n      markerType,\n      markerTypeInfo,\n      attributeMarkerInfoEntries,\n    };\n  }\n\n  /** Converts the text content of a marker to its equivalent in USFM */\n  private textContentToUsfm(textContent: string): UsfmSnippetAndUsjFragmentsInfo {\n    // Special case: NBSP should be replaced with ~ in USFM if invisible characters are not allowed\n    return {\n      usfm: this.shouldAllowInvisibleCharacters\n        ? textContent\n        : textContent.replace(TEXT_CONTENT_NBSP_REGEXP, '~'),\n      fragmentsInfo: [{ fragment: textContent, indexInUsfm: 0 }],\n    };\n  }\n\n  /**\n   * Merge an independent array of fragment info into an existing array of fragment info, offsetting\n   * the indices of the new fragments so their locations start from the end of the string\n   */\n  private static mergeFragmentsInfoIntoExistingArray(\n    newFragmentsInfo: UsjFragmentInfoMinimal[],\n    existingFragmentsInfo: UsjFragmentInfoMinimal[],\n    existingUsfmLength: number,\n  ) {\n    newFragmentsInfo.forEach((fragmentInfo) => {\n      const fragmentIndex = existingUsfmLength + fragmentInfo.indexInUsfm;\n      existingFragmentsInfo.push({\n        ...fragmentInfo,\n        indexInUsfm: fragmentIndex,\n      });\n    });\n  }\n\n  /**\n   * Transforms the provided USJ marker into its opening marker representation in USFM\n   *\n   * Includes a newline before the marker if applicable. Generally also includes a space at the end.\n   *\n   * Opening markers generally look like the following:\n   *\n   * ```text\n   * \\markerName leadingAttributes textContentAttribute attributeMarkers\n   * ```\n   *\n   * @param marker The marker to transform\n   * @param isInsideMarkerWithSameType `true` if this marker is inside another marker of the same\n   *   type. This is used to determine if a prefix should be added before the marker name.\n   * @returns String containing the marker information that should come before the contents of the\n   *   marker in USFM\n   */\n  private openingMarkerToUsfm(\n    marker: MarkerObject | Usj,\n    isInsideMarkerWithSameType: boolean,\n  ): UsfmSnippetAndUsjFragmentsInfo {\n    let usfm = '';\n    const fragmentsInfo: UsjFragmentInfoMinimal[] = [];\n\n    const { markerName, markerInfo, markerType, markerTypeInfo, attributeMarkerInfoEntries } =\n      this.getInfoForMarker(marker);\n\n    // Markers can have any properties. All are strings. Only exception is content, so don't use\n    // it here\n    // eslint-disable-next-line no-type-assertion/no-type-assertion\n    const markerWithAnyAttributes = marker as unknown as Record<string, string>;\n\n    // Add newline before the marker if there's supposed to be one\n    if (markerTypeInfo.hasNewlineBefore) usfm += `\\n`;\n\n    // Add the nested prefix if the marker is in a marker of the same type\n    const markerPrefix = isInsideMarkerWithSameType ? (markerTypeInfo.nestedPrefix ?? '') : '';\n\n    // Add the marker name\n    // Fragment representing the very beginning of the marker is the marker itself\n    fragmentsInfo.push({ fragment: marker, indexInUsfm: usfm.length });\n    // Special case: `optbreak` - transform to `//`\n    usfm += markerType === 'optbreak' ? '//' : `\\\\${markerPrefix}`;\n\n    if (markerType !== 'optbreak') {\n      // Fragment representing the marker name is the `marker` property\n      fragmentsInfo.push({\n        fragment: { attributeValueForKey: 'marker', forMarker: marker },\n        indexInUsfm: usfm.length,\n      });\n\n      // According to `unmatched`'s `outputToUsfmInstructions`, no space after the marker name\n      // because it is basically a closing marker\n      usfm += `${markerName}${markerType === 'unmatched' ? '' : ' '}`;\n    }\n\n    // Add leading attributes in listed order\n    if (markerInfo.leadingAttributes) {\n      markerInfo.leadingAttributes.forEach((attributeName) => {\n        const attributeValue = markerWithAnyAttributes[attributeName];\n\n        if (!attributeValue) return;\n\n        fragmentsInfo.push({\n          fragment: { attributeValueForKey: attributeName, forMarker: marker },\n          indexInUsfm: usfm.length,\n        });\n        usfm += `${attributeValue} `;\n      });\n    }\n\n    // Add text content attribute\n    if (\n      markerInfo.textContentAttribute &&\n      markerWithAnyAttributes[markerInfo.textContentAttribute]\n    ) {\n      fragmentsInfo.push({\n        fragment: { attributeValueForKey: markerInfo.textContentAttribute, forMarker: marker },\n        indexInUsfm: usfm.length,\n      });\n      usfm += `${markerWithAnyAttributes[markerInfo.textContentAttribute]} `;\n    }\n\n    // Add attribute markers in listed order\n    if (markerInfo.attributeMarkers) {\n      attributeMarkerInfoEntries.forEach(([attributeMarkerName, attributeMarkerInfo]) => {\n        const attributeValue =\n          markerWithAnyAttributes[attributeMarkerInfo.attributeMarkerAttributeName];\n\n        if (!attributeValue) return;\n\n        // Create a marker that represents this attribute marker so we can make the USFM\n        const attributeMarker: MarkerObject = {\n          type: attributeMarkerInfo.type,\n          marker: attributeMarkerName,\n          content: [attributeValue],\n        };\n\n        // Add the attribute marker USFM to the document\n\n        // Collect opening and closing attribute marker fragments so we can modify them before adding\n        // them to the main fragments\n        const attributeMarkerFragmentsInfo: UsjFragmentInfoMinimal[] = [];\n\n        // Caveat: it's not technically always true that this marker is the parent of the attribute\n        // markers, but there is currently no known case where it matters because there are no\n        // attribute markers that have the same marker type as the marker on which they are\n        // attributes. It likely will never matter as this is a very strange concept and it seems\n        // the USFM committee doesn't want to create more attribute markers.\n        usfm = this.addMarkerUsfmToString(\n          usfm,\n          attributeMarker,\n          marker,\n          attributeMarkerFragmentsInfo,\n        );\n        const { usfm: textContentUsfm } = this.textContentToUsfm(attributeValue);\n        fragmentsInfo.push({\n          fragment: {\n            attributeValueForKey: attributeMarkerInfo.attributeMarkerAttributeName,\n            forMarker: marker,\n          },\n          indexInUsfm: usfm.length,\n        });\n        usfm += textContentUsfm;\n        usfm = this.addMarkerUsfmToString(\n          usfm,\n          {\n            isClosingMarker: true,\n            forMarker: attributeMarker,\n          },\n          marker,\n          attributeMarkerFragmentsInfo,\n        );\n\n        // Transform the opening fragments to attribute marker fragments and add them to the main\n        // fragments\n        attributeMarkerFragmentsInfo.forEach((fragmentInfo) => {\n          // There should never be such a thing as text content in the opening/closing of an attribute\n          // marker or an attribute key for an attribute marker\n          if (isString(fragmentInfo.fragment) || 'attributeKey' in fragmentInfo.fragment)\n            throw new Error(\n              `Attribute marker opening or closing markers generated a text content fragment or an attribute key fragment! This does not make sense. ${JSON.stringify(fragmentInfo)}`,\n            );\n\n          if (UsjReaderWriter.isFragmentAMarker(fragmentInfo.fragment)) {\n            // Opening marker. Need to point to the original marker and indicate this is the opening\n            // marker for its attribute marker\n            fragmentsInfo.push({\n              ...fragmentInfo,\n              fragment: {\n                attributeMarker: attributeMarkerInfo.attributeMarkerAttributeName,\n                forMarker: marker,\n              },\n            });\n\n            return;\n          }\n\n          if ('attributeValueForKey' in fragmentInfo.fragment) {\n            // There should never be an attribute value for an attribute marker other than the marker name\n            if (fragmentInfo.fragment.attributeValueForKey !== 'marker')\n              throw new Error(\n                `Attribute marker opening or closing markers generated an attribute value fragment for a key that was not marker! This does not make sense. ${JSON.stringify(fragmentInfo)}`,\n              );\n            // Marker representation of the attribute marker. Change to attribute key for attribute\n            // marker attribute name.\n            fragmentsInfo.push({\n              ...fragmentInfo,\n              fragment: {\n                attributeKey: attributeMarkerInfo.attributeMarkerAttributeName,\n                forMarker: marker,\n              },\n            });\n            return;\n          }\n\n          if ('isClosingMarker' in fragmentInfo.fragment) {\n            // Closing marker. Need to point to the original marker and indicate this is the closing\n            // marker for its attribute marker\n\n            // Need to remove isClosingMarker but will not use it again. This was the easiest way to\n            // delete it without TypeScript going berserk\n            // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-unused-vars\n            const { isClosingMarker: _, ...partialClosingFragment } = fragmentInfo.fragment;\n\n            const fragment: UsjAttributeMarkerClosingMarkerFragment = {\n              ...partialClosingFragment,\n              forMarker: marker,\n              attributeMarkerClosingMarker: attributeMarkerInfo.attributeMarkerAttributeName,\n            };\n\n            fragmentsInfo.push({\n              ...fragmentInfo,\n              fragment,\n            });\n\n            return;\n          }\n\n          // That should have been all of them, so not sure what other fragment this could be\n          throw new Error(\n            `Attribute marker opening or closing markers generated an unrecognized fragment: ${JSON.stringify(fragmentInfo)}`,\n          );\n        });\n\n        if (\n          !this.markersMap.isSpaceAfterAttributeMarkersContent &&\n          attributeMarkerInfo.hasStructuralSpaceAfterCloseAttributeMarker\n        )\n          // Add the optional structural space after the attribute marker according to spec\n          usfm += ' ';\n      });\n    }\n\n    return { usfm, fragmentsInfo };\n  }\n\n  /**\n   * Transforms the provided USJ marker into its closing marker representation in USFM\n   *\n   * Closing markers do not include the attributes listed as part of the opening markers (leading\n   * attributes, text content attributes, and attribute markers). They only include other kinds of\n   * attributes including the default attribute if present.\n   *\n   * Closing markers with only the default attribute present generally look like the following:\n   *\n   * ```text\n   * |defaultAttribute\\markerName*\n   * ```\n   *\n   * Closing markers with at least one non-default attribute present generally look like the\n   * following:\n   *\n   * ```text\n   * |attributeName=\"AttributeValue\" attributeName=\"AttributeValue\"\\markerName*\n   * ```\n   *\n   * @param marker The marker to transform\n   * @param isInsideMarkerWithSameType `true` if this marker is inside another marker of the same\n   *   type. This is used to determine if a prefix should be added before the marker name.\n   * @returns String containing the marker information that should come after the contents of the\n   *   marker in USFM\n   */\n  private closingMarkerToUsfm(\n    marker: MarkerObject | Usj,\n    isInsideMarkerWithSameType: boolean,\n  ): UsfmSnippetAndUsjFragmentsInfo {\n    const {\n      markerNameOriginal,\n      markerName,\n      markerInfo,\n      markerType,\n      markerTypeInfo,\n      attributeMarkerInfoEntries,\n    } = this.getInfoForMarker(marker);\n\n    // Gather attributes that are not listed as part of the opening marker and not skipped in USFM\n    const closingMarkerAttributeNames = Object.keys(marker).filter((attributeName) => {\n      // Special case: skip properties that are not attributes\n      if (attributeName === 'type') return false;\n      if (attributeName === 'marker') return false;\n      if (attributeName === 'content') return false;\n      if (attributeName === 'closed') return false;\n\n      // Skip attributes that are supposed to be skipped when outputting to USFM\n      if (markerTypeInfo.skipOutputAttributeToUsfm?.includes(attributeName)) return false;\n\n      // Not a leadingAttribute\n      if (markerInfo.leadingAttributes?.includes(attributeName)) return false;\n\n      // Not a textContentAttribute\n      if (markerInfo.textContentAttribute === attributeName) return false;\n\n      // Not an attributeMarker\n      if (\n        attributeMarkerInfoEntries.some(\n          ([, attributeMarkerInfo]) =>\n            attributeMarkerInfo.attributeMarkerAttributeName === attributeName,\n        )\n      )\n        return false;\n\n      // There are no other attributes that go on the opening marker, so this must go on the closing\n      // marker\n      return true;\n    });\n\n    // Markers can have any properties. All are strings. Only exception is content, so don't use\n    // it here\n    // eslint-disable-next-line no-type-assertion/no-type-assertion\n    const markerWithAnyAttributes = marker as unknown as Record<string, string>;\n\n    // We don't have examples of markers that have both normal closing markers and independent\n    // closing markers, so just throw an error if we encounter this situation\n    if (\n      markerTypeInfo.isCloseable &&\n      markerInfo.independentClosingMarkers &&\n      markerInfo.independentClosingMarkers.length > 0\n    )\n      throw new Error(\n        `Marker ${\n          markerName\n        } is intended to have a normal closing marker and independent closing markers. As of writing this code, there is no known syntax for this situation in USFM. Cannot proceed.`,\n      );\n\n    // Determine if the marker is supposed to have an explicit closing marker\n    let hasExplicitClosingMarker = true;\n    // If the closing marker is specified as not present, it should not be present no matter what\n    if (markerWithAnyAttributes.closed === 'false') hasExplicitClosingMarker = false;\n    else if (\n      markerInfo.isClosingMarkerOptional &&\n      !this.markersMap.shouldOptionalClosingMarkersBePresent &&\n      markerWithAnyAttributes.closed !== 'true'\n    ) {\n      // If the closing marker is optional, if optional closing markers should be left out, and\n      // if it is not specified as closed, then it should not have a closing marker\n      hasExplicitClosingMarker = false;\n    }\n\n    // If this marker has an independent closing marker, create that\n    if (\n      markerInfo.independentClosingMarkers &&\n      markerInfo.independentClosingMarkers.length > 0 &&\n      hasExplicitClosingMarker\n    ) {\n      // Create a marker that represents this independent closing marker so we can make the USFM\n      const independentClosingMarker: MarkerObject = {\n        type: markerType,\n        marker: markerInfo.independentClosingMarkers[0],\n        // Put all the closing marker attributes on here since we don't really have a better place\n        // to put them and might as well\n        ...Object.fromEntries(\n          closingMarkerAttributeNames.map((attributeName) => [\n            attributeName,\n            markerWithAnyAttributes[attributeName],\n          ]),\n        ),\n      };\n\n      let usfm = '';\n      const fragmentsInfo: UsjFragmentInfoMinimal[] = [];\n\n      const { usfm: openingMarkerUsfm, fragmentsInfo: openingFragmentsInfo } =\n        this.openingMarkerToUsfm(independentClosingMarker, isInsideMarkerWithSameType);\n      // Fragment for independent closing marker is just the normal closing fragment. So find the\n      // opening fragment, change it to closing fragment, and add it to the fragments for this\n      // marker. Need to get the opening marker so we have the right indexInUsfm (might be 1 if\n      // the marker has a newline before it, for example)\n      const openingFragmentInfo = openingFragmentsInfo.find((fragmentInfo) => {\n        return UsjReaderWriter.isFragmentAMarker(fragmentInfo.fragment);\n      });\n      if (!openingFragmentInfo)\n        throw new Error(\n          `Could not find opening fragment info for independent closing marker ${JSON.stringify(\n            independentClosingMarker,\n          )}. Fragments info generated: ${JSON.stringify(openingFragmentsInfo)}`,\n        );\n      fragmentsInfo.push({\n        ...openingFragmentInfo,\n        fragment: { isClosingMarker: true, forMarker: marker },\n      });\n      usfm += openingMarkerUsfm;\n      // Only add the independent closing marker if it does not have the same name as the marker we\n      // are closing so we don't get in an infinite loop\n      if (markerNameOriginal !== independentClosingMarker.marker)\n        // ENHANCE: If we ever have a situation where closing marker attributes get on a marker\n        // with an independent closing marker, let's add fragments for the attributes here. Though\n        // I think this may be something the USFM committee intends to avoid doing based on the\n        // proposal to add attributes at the opening marker\n        usfm = this.addMarkerUsfmToString(\n          usfm,\n          {\n            isClosingMarker: true,\n            forMarker: independentClosingMarker,\n          },\n          isInsideMarkerWithSameType,\n        );\n\n      return { usfm, fragmentsInfo };\n    }\n\n    // This marker doesn't have an independent closing marker, so create a normal closing marker\n    let usfm = '';\n    const fragmentsInfo: UsjFragmentInfoMinimal[] = [];\n\n    // Add attributes to the closing marker USFM\n    if (closingMarkerAttributeNames.length > 0) {\n      // Add the bar before closing attributes\n      usfm += '|';\n\n      // Default attribute syntax if it is the only attribute present\n      if (\n        closingMarkerAttributeNames.length === 1 &&\n        closingMarkerAttributeNames[0] === markerInfo.defaultAttribute\n      ) {\n        fragmentsInfo.push({\n          fragment: { attributeValueForKey: markerInfo.defaultAttribute, forMarker: marker },\n          indexInUsfm: usfm.length,\n        });\n        usfm += markerWithAnyAttributes[markerInfo.defaultAttribute];\n      } else {\n        // List all attributes with key and value\n        closingMarkerAttributeNames.forEach((attributeName, index) => {\n          // According to `figure`'s `outputToUsfmInstructions`, figure's file attribute is src in USFM\n          const attributeNameUsfm =\n            markerType === 'figure' && attributeName === 'file' ? 'src' : attributeName;\n          // Add to the accumulated usfm (starting with a bar): a space if this is after the first\n          // attribute, then the attribute name, then =, then \"the attribute value\"\n          if (index > 0) usfm += ' ';\n          fragmentsInfo.push({\n            fragment: { attributeKey: attributeName, forMarker: marker },\n            indexInUsfm: usfm.length,\n          });\n          usfm += `${attributeNameUsfm}=\"`;\n          fragmentsInfo.push({\n            fragment: { attributeValueForKey: attributeName, forMarker: marker },\n            indexInUsfm: usfm.length,\n          });\n          usfm += `${markerWithAnyAttributes[attributeName]}\"`;\n        });\n      }\n    }\n\n    // Add the normal closing marker\n    if (markerTypeInfo.isCloseable && hasExplicitClosingMarker) {\n      const closingMarkerName = markerTypeInfo.isClosingMarkerEmpty ? '' : markerName;\n\n      // Add the nested prefix if the marker is in a marker of the same type\n      const markerPrefix = isInsideMarkerWithSameType ? (markerTypeInfo.nestedPrefix ?? '') : '';\n\n      fragmentsInfo.push({\n        fragment: { isClosingMarker: true, forMarker: marker },\n        indexInUsfm: usfm.length,\n      });\n      usfm += `\\\\${markerPrefix}${closingMarkerName}*`;\n    }\n\n    return { usfm, fragmentsInfo };\n  }\n\n  /**\n   * Determines whether this marker and all its content should be skipped entirely when outputting\n   * to USFM\n   *\n   * @param marker Marker to check\n   * @returns `true` if this marker should be skipped; `false` otherwise\n   */\n  private shouldSkipOutputMarkerToUsfm(marker: MarkerObject | Usj) {\n    const { markerTypeInfo } = this.getInfoForMarker(marker);\n\n    if (markerTypeInfo.skipOutputMarkerToUsfm) return true;\n\n    if (\n      markerTypeInfo.skipOutputMarkerToUsfmIfAttributeIsPresent?.some(\n        (attributeName) => attributeName in marker,\n      )\n    )\n      return true;\n\n    return false;\n  }\n\n  /** Removes one space at the end of the string if present */\n  private static removeEndSpace(value: string) {\n    // TODO: should this use the surrogate-aware functions?\n    if (value.at(-1) !== ' ') return value;\n    return value.slice(0, -1);\n  }\n\n  /**\n   * Add an opening or closing marker USFM representation to the end of a string of USFM\n   *\n   * @param usfm The USFM string to add the marker to\n   * @param marker The opening or closing marker to add to the USFM\n   * @param markerParent Parent of the marker being added. Used to determine if this marker is\n   *   nested within another marker of the same type\n   * @param fragmentsInfo The array of fragment information built so far for the USFM string passed\n   *   in. THIS METHOD WILL MODIFY THE ARRAY PASSED IN; it will add new fragments that correspond to\n   *   the marker added.\n   * @returns Final USFM string with the marker added\n   */\n  private addMarkerUsfmToString(\n    usfm: string,\n    marker: MarkerObject | Usj | UsjClosingMarkerFragment,\n    markerParent: MarkerObject | Usj | undefined,\n    fragmentsInfo?: UsjFragmentInfoMinimal[],\n  ): string;\n  /**\n   * Add an opening or closing marker USFM representation to the end of a string of USFM\n   *\n   * @param usfm The USFM string to add the marker to\n   * @param marker The opening or closing marker to add to the USFM\n   * @param isInsideMarkerWithSameType `true` if this marker is inside another marker of the same\n   *   type. This is used to determine if a prefix should be added before the marker name.\n   * @param fragmentsInfo The array of fragment information built so far for the USFM string passed\n   *   in. THIS METHOD WILL MODIFY THE ARRAY PASSED IN; it will add new fragments that correspond to\n   *   the marker added.\n   * @returns Final USFM string with the marker added\n   */\n  private addMarkerUsfmToString(\n    usfm: string,\n    marker: MarkerObject | UsjClosingMarkerFragment,\n    isInsideMarkerWithSameType: boolean,\n    fragmentsInfo?: UsjFragmentInfoMinimal[],\n  ): string;\n  private addMarkerUsfmToString(\n    usfm: string,\n    marker: MarkerObject | UsjClosingMarkerFragment,\n    markerParentOrIsInsideMarkerWithSameType: MarkerObject | Usj | boolean | undefined,\n    fragmentsInfo?: UsjFragmentInfoMinimal[],\n  ): string {\n    let usfmOutput = usfm;\n\n    // Build up the marker's usfm and fragment info separately first because we may modify it before\n    // adding it to the full usfm\n    let markerUsfmOutput;\n    let markerFragmentsInfo: UsjFragmentInfoMinimal[];\n\n    const { markerNameOriginal, markerType, markerTypeInfo } = this.getInfoForMarker(\n      'isClosingMarker' in marker ? marker.forMarker : marker,\n    );\n\n    // Determine if this marker is a direct child of another marker of the same type\n    let isParentSameType = false;\n    if (typeof markerParentOrIsInsideMarkerWithSameType === 'boolean')\n      isParentSameType = markerParentOrIsInsideMarkerWithSameType;\n    else if (markerParentOrIsInsideMarkerWithSameType) {\n      const { markerType: parentMarkerType } = this.getInfoForMarker(\n        markerParentOrIsInsideMarkerWithSameType,\n      );\n      if (parentMarkerType === markerType) {\n        isParentSameType = true;\n      }\n    }\n\n    if ('isClosingMarker' in marker) {\n      const { usfm: closingUsfm, fragmentsInfo: closingFragmentsInfo } = this.closingMarkerToUsfm(\n        marker.forMarker,\n        isParentSameType,\n      );\n      markerFragmentsInfo = closingFragmentsInfo;\n      markerUsfmOutput = closingUsfm;\n\n      // If the closing marker is supposed to be empty, there was nothing in the marker content, and\n      // there are no closing marker attributes present, we need to remove the structural space after\n      // the opening marker\n      if (\n        markerTypeInfo.isCloseable &&\n        markerTypeInfo.isClosingMarkerEmpty &&\n        // No contents\n        (!marker.forMarker.content || marker.forMarker.content.length === 0) &&\n        // No closing marker attributes\n        !markerUsfmOutput.startsWith('|')\n      ) {\n        usfmOutput = UsjReaderWriter.removeEndSpace(usfmOutput);\n      }\n    } else {\n      const { usfm: openingUsfm, fragmentsInfo: openingFragmentsInfo } = this.openingMarkerToUsfm(\n        marker,\n        isParentSameType,\n      );\n      markerFragmentsInfo = openingFragmentsInfo;\n      markerUsfmOutput = openingUsfm;\n    }\n\n    if (markerUsfmOutput.startsWith('\\n')) {\n      if (usfmOutput.length === 0) {\n        // If the USFM is empty, don't add a newline at the start\n        markerFragmentsInfo = markerFragmentsInfo.map((fragmentInfo) => ({\n          ...fragmentInfo,\n          indexInUsfm: fragmentInfo.indexInUsfm - 1,\n        }));\n        markerUsfmOutput = markerUsfmOutput.substring(1);\n      } else {\n        // If there's supposed to be a newline before the marker, it should eat the last space if\n        // there is one (that last space gets turned into the newline in this format)\n        usfmOutput = UsjReaderWriter.removeEndSpace(usfmOutput);\n      }\n    }\n\n    // Special case: `ca` after chapter marker needs a newline and space before in Paratext USFM for\n    // some reason\n    // Note that there is not a newline and space before `ca` after importing from USX in Paratext,\n    // so maybe we should just remove the newline and space in the PDP\n    if (this.markersMap.isSpaceAfterAttributeMarkersContent && markerNameOriginal === 'ca') {\n      // Find the last marker in the current USFM output\n      const lastMarkerBackslashIndex = usfmOutput.lastIndexOf('\\\\');\n      if (lastMarkerBackslashIndex >= 0) {\n        // We just want to know if it's a chapter marker, so we can just get two characters, c and space\n        const lastMarker = usfm.substring(\n          lastMarkerBackslashIndex + 1,\n          lastMarkerBackslashIndex + 3,\n        );\n        if (lastMarker === 'c ') {\n          usfmOutput = UsjReaderWriter.removeEndSpace(usfmOutput);\n          usfmOutput += '\\n ';\n        }\n      }\n    }\n\n    // Add the marker fragments and USFM into the existing fragments and USFM\n    if (fragmentsInfo)\n      UsjReaderWriter.mergeFragmentsInfoIntoExistingArray(\n        markerFragmentsInfo,\n        fragmentsInfo,\n        usfmOutput.length,\n      );\n    usfmOutput += markerUsfmOutput;\n\n    return usfmOutput;\n  }\n\n  toUsfm() {\n    // See calculateUsfmProperties method for implementation\n    return this.usfm;\n  }\n\n  // #endregion transform USJ to USFM\n\n  // #region fragment utilities\n\n  /**\n   * Returns a new {@link UsjDocumentLocation} based on the one passed in but with the offset\n   * provided. If the location passed in does not have an offset property, a shallow clone of the\n   * location will be returned with no changes.\n   */\n  private static moveUsjDocumentLocationToNewOffset(\n    usjLocation: UsjDocumentLocation,\n    usjOffset: number,\n  ): UsjDocumentLocation {\n    const newLocation = { ...usjLocation };\n\n    // UsjTextContentLocation\n    if ('offset' in newLocation) newLocation.offset = usjOffset;\n    // UsjClosingMarkerLocation\n    else if ('closingMarkerOffset' in newLocation) newLocation.closingMarkerOffset = usjOffset;\n    // UsjPropertyValueLocation\n    else if ('propertyOffset' in newLocation) newLocation.propertyOffset = usjOffset;\n    // UsjAttributeKeyLocation\n    else if ('keyOffset' in newLocation) newLocation.keyOffset = usjOffset;\n    // UsjClosingAttributeMarkerLocation\n    else if ('keyClosingMarkerOffset' in newLocation)\n      newLocation.keyClosingMarkerOffset = usjOffset;\n    // No offset; no change:\n    //  UsjMarkerLocation\n    //  UsjAttributeMarkerLocation\n    return newLocation;\n  }\n\n  /**\n   * Returns the offset of whatever kind that is found in the UsjDocumentLocation. Returns 0 if the\n   * location passed in does not have an offset property.\n   */\n  private static getOffsetInUsjDocumentLocation(usjLocation: UsjDocumentLocation): number {\n    // UsjTextContentLocation\n    if ('offset' in usjLocation) return usjLocation.offset;\n    // UsjClosingMarkerLocation\n    if ('closingMarkerOffset' in usjLocation) return usjLocation.closingMarkerOffset;\n    // UsjPropertyValueLocation\n    if ('propertyOffset' in usjLocation) return usjLocation.propertyOffset;\n    // UsjAttributeKeyLocation\n    if ('keyOffset' in usjLocation) return usjLocation.keyOffset;\n    // UsjClosingAttributeMarkerLocation\n    if ('keyClosingMarkerOffset' in usjLocation) return usjLocation.keyClosingMarkerOffset;\n    // No offset:\n    //  UsjMarkerLocation\n    //  UsjAttributeMarkerLocation\n    return 0;\n  }\n\n  /**\n   * Compares two UsjDocumentLocations to determine if they are pointing to the same location\n   *\n   * @param a The first location to compare\n   * @param b The second location to compare\n   * @param ignoreJsonPath If `true`, the JSONPath properties of the locations will be ignored in\n   *   the comparison. This is useful if you have already determined that the JSONPaths are the\n   *   same\n   */\n  private static areUsjDocumentLocationsEqual(\n    a: UsjDocumentLocation,\n    b: UsjDocumentLocation,\n    ignoreJsonPath = false,\n  ) {\n    const { jsonPath: aJsonPath, ...restOfA } = a;\n    const { jsonPath: bJsonPath, ...restOfB } = b;\n\n    // Determine if the two JSONPaths are equivalent even if they use different property syntax\n    if (\n      !ignoreJsonPath &&\n      !deepEqual(JSONPath.toPathArray(aJsonPath), JSONPath.toPathArray(bJsonPath))\n    )\n      return false;\n\n    // Determine if the rest of the location information is the same\n    return deepEqual(restOfA, restOfB);\n  }\n\n  /** Find the fragment info corresponding to the specified USJ Document location. */\n  private findFragmentInfoAtUsjDocumentLocation(\n    usjLocation: UsjDocumentLocation,\n  ): UsjFragmentInfo | undefined {\n    // Set offset to 0 because all the fragments' locations are at offset 0\n    const zeroedUsjLocation = UsjReaderWriter.moveUsjDocumentLocationToNewOffset(usjLocation, 0);\n\n    let fragmentInfoAtLocation: UsjFragmentInfo | undefined;\n    const allFragmentsInfoAtJsonPath = this.fragmentsByJsonPath.get(\n      UsjReaderWriter.normalizeJsonPath(usjLocation.jsonPath),\n    );\n\n    // Couldn't find any fragment info at this JSONPath\n    if (!allFragmentsInfoAtJsonPath) return undefined;\n\n    // Look in the fragments at this JSONPath to find one that matches the full location\n    allFragmentsInfoAtJsonPath.find((fragmentInfo) => {\n      if (\n        !UsjReaderWriter.areUsjDocumentLocationsEqual(\n          fragmentInfo.nodeAndDocumentLocation.documentLocation,\n          zeroedUsjLocation,\n          // We already compared the JSONPaths by looking in the map for this JSONPath\n          true,\n        )\n      )\n        return false;\n\n      fragmentInfoAtLocation = fragmentInfo;\n      return true;\n    });\n\n    return fragmentInfoAtLocation;\n  }\n\n  /**\n   * Transform a node and its working stack into the {@link UsjDocumentLocation} corresponding to it.\n   *\n   * @param node Marker or string to convert\n   * @param workingStack Working stack pointing to the node\n   * @param locationOffset If applicable, this is the offset that will be put on the\n   *   {@link UsjDocumentLocation}. If not present, offset on the {@link UsjDocumentLocation} will be\n   *   `0`. Not all subtypes of {@link UsjDocumentLocation}s have offsets, so this is not used in all\n   *   situations\n   * @returns The node and the document location corresponding to this fragment\n   */\n  private static convertNodeToUsjDocumentLocation(\n    node: MarkerContent | Usj,\n    workingStack: WorkingStack,\n    locationOffset = 0,\n  ): UsjTextContentLocation | UsjMarkerLocation {\n    const jsonPath = UsjReaderWriter.convertWorkingStackToJsonPath(workingStack);\n\n    if (isString(node)) {\n      // If the node is a text content string, location is the jsonPath and the offset in that\n      // string\n      const documentLocation: UsjTextContentLocation = { jsonPath, offset: locationOffset };\n      return documentLocation;\n    }\n\n    // The node is a marker itself, so location is just the marker jsonPath. We don't currently\n    // provide a way to represent an offset within the opening marker.\n    const documentLocation: UsjMarkerLocation = { jsonPath };\n    return documentLocation;\n  }\n\n  /**\n   * Transform a fragment and its working stack into the {@link UsjNodeAndDocumentLocation}\n   * corresponding to it.\n   *\n   * @param fragment Fragment to convert\n   * @param workingStack Working stack pointing to the marker or string the fragment is in\n   * @param offsetWithinFragment If applicable, this is the offset within the fragment that the\n   *   location is pointing to, which is offset that will be put on the {@link UsjDocumentLocation}.\n   *   If not present, offset on the {@link UsjDocumentLocation} will be `0` because fragments don't\n   *   have their own offsets into the contents. Not all {@link UsjDocumentLocation}s have offsets,\n   *   so this is not used in all situations\n   * @returns The node and the document location corresponding to this fragment\n   */\n  private static convertFragmentToUsjNodeAndDocumentLocation(\n    fragment: UsjFragment,\n    workingStack: WorkingStack,\n    offsetWithinFragment = 0,\n  ): UsjNodeAndDocumentLocation {\n    // Return the appropriate `UsjDocumentLocation` subtype based on what this fragment is\n\n    // Check if the fragment itself is the target, meaning the fragment is the node in the USJ\n    // document (`string`, `MarkerObject`, and `Usj`)\n    if (isString(fragment) || UsjReaderWriter.isFragmentAMarker(fragment)) {\n      // The fragment/node itself is the target. Get document location for this node\n      const documentLocation: UsjTextContentLocation | UsjMarkerLocation =\n        UsjReaderWriter.convertNodeToUsjDocumentLocation(\n          fragment,\n          workingStack,\n          offsetWithinFragment,\n        );\n      return {\n        node: fragment,\n        documentLocation,\n      };\n    }\n\n    // Check if the target is a closing marker\n    if ('isClosingMarker' in fragment) {\n      // Get JsonPath to the marker this is a closing marker for\n      const jsonPath = UsjReaderWriter.convertWorkingStackToJsonPath(workingStack);\n\n      // Location is the jsonPath to the marker and an offset within the closing marker\n      const documentLocation: UsjClosingMarkerLocation = {\n        jsonPath,\n        closingMarkerOffset: offsetWithinFragment,\n      };\n      return {\n        node: fragment.forMarker,\n        documentLocation,\n      };\n    }\n\n    // Check if the target is a property value (`marker` or an attribute)\n    if ('attributeValueForKey' in fragment) {\n      // Get JsonPath to the indicated property on the marker this is a property for\n      const jsonPath = UsjReaderWriter.convertWorkingStackAndPropertyToJsonPath(\n        workingStack,\n        fragment.attributeValueForKey,\n      );\n\n      // Location is the jsonPath to the property on the marker and the offset within the property\n      // value\n      const documentLocation: UsjPropertyValueLocation = {\n        jsonPath,\n        propertyOffset: offsetWithinFragment,\n      };\n      return {\n        node: fragment.forMarker,\n        documentLocation,\n      };\n    }\n\n    // Check if the target is an attribute key\n    if ('attributeKey' in fragment) {\n      // Get JsonPath to the marker this is an attribute key for\n      const jsonPath = UsjReaderWriter.convertWorkingStackToJsonPath(workingStack);\n\n      // Location is the jsonPath to the marker, the key, and the offset within that key\n      const documentLocation: UsjAttributeKeyLocation = {\n        jsonPath,\n        keyName: fragment.attributeKey,\n        keyOffset: offsetWithinFragment,\n      };\n      return {\n        node: fragment.forMarker,\n        documentLocation,\n      };\n    }\n\n    // Check if the target is an attribute marker\n    if ('attributeMarker' in fragment) {\n      // Get JsonPath to the marker this is an attribute marker for\n      const jsonPath = UsjReaderWriter.convertWorkingStackToJsonPath(workingStack);\n\n      // Location is the jsonPath to the marker and the key for the attribute marker. We don't\n      // currently provide a way to represent an offset within the opening marker.\n      const documentLocation: UsjAttributeMarkerLocation = {\n        jsonPath,\n        keyName: fragment.attributeMarker,\n      };\n      return {\n        node: fragment.forMarker,\n        documentLocation,\n      };\n    }\n\n    // Check if the target is an attribute marker closing marker\n    if ('attributeMarkerClosingMarker' in fragment) {\n      // Get JsonPath to the marker this is an attribute marker for\n      const jsonPath = UsjReaderWriter.convertWorkingStackToJsonPath(workingStack);\n\n      // Location is the jsonPath to the marker and the key for the attribute marker\n      const documentLocation: UsjClosingAttributeMarkerLocation = {\n        jsonPath,\n        keyName: fragment.attributeMarkerClosingMarker,\n        keyClosingMarkerOffset: offsetWithinFragment,\n      };\n      return {\n        node: fragment.forMarker,\n        documentLocation,\n      };\n    }\n\n    throw new Error(\n      `Could not transform unrecognized fragment to UsjNodeAndDocumentLocation: ${JSON.stringify(\n        fragment,\n      )} at working stack ${JSON.stringify(JSON.stringify(fragment))}`,\n    );\n  }\n\n  /**\n   * Fill out fragments info from a minimal fragments info array and move them into the final\n   * fragments map\n   *\n   * @param fragmentsInfo Minimal fragments info array to fill out and put into maps. ALL CONTENTS\n   *   OF THIS ARRAY ARE REMOVED IN THIS METHOD\n   * @param workingStack Current working stack\n   * @param position Object containing properties describing where in the USFM document these\n   *   fragments are. If this method encounters a verse range, only the starting verse number is\n   *   used (hence this is not a {@link SerializedVerseRef}). PROPERTIES ON THIS OBJECT ARE MODIFIED\n   *   IN THIS METHOD\n   * @param fragmentsByIndexInUsfm Map to add fragment information to by index in USFM\n   * @param fragmentsByJsonPath Map to add fragment information to by JSONPath\n   * @param indicesInUsfmByVerseRef Map to add verse start locations to. If this method encounters a\n   *   verse range, only the starting verse number is used. See {@link IndicesInUsfmByVerseRef} for\n   *   potential adjustments to handle verse ranges differently when we know better what we ought to\n   *   do.\n   */\n  private static transferFragmentsInfoArrayToMaps(\n    fragmentsInfo: UsjFragmentInfoMinimal[],\n    workingStack: WorkingStack,\n    position: {\n      bookId: string;\n      chapterNum: number;\n      verseNum: number;\n    },\n    fragmentsByIndexInUsfm: FragmentsByIndexInUsfm,\n    fragmentsByJsonPath: FragmentsByJsonPath,\n    indicesInUsfmByVerseRef: IndicesInUsfmByVerseRef,\n  ): void {\n    // Add the extra information to each fragment to make it complete\n    const fullFragmentsInfo = fragmentsInfo.map((fragmentInfo) => {\n      // Adjust current verse ref if we find start of book, chapter, or verse marker\n      if (typeof fragmentInfo.fragment === 'object' && 'type' in fragmentInfo.fragment) {\n        const marker = fragmentInfo.fragment;\n\n        if (marker.type === BOOK_TYPE && marker.code) {\n          // Found book marker. Update current verse ref to new book\n          position.bookId = marker.code;\n          position.chapterNum = 0;\n          position.verseNum = 0;\n\n          // If there are any fragments before the first encountered book id, move them to the first\n          // encountered book id\n          if (indicesInUsfmByVerseRef[NO_BOOK_ID]) {\n            indicesInUsfmByVerseRef[position.bookId] = indicesInUsfmByVerseRef[NO_BOOK_ID];\n            delete indicesInUsfmByVerseRef[NO_BOOK_ID];\n          }\n        } else if (marker.type === CHAPTER_TYPE && marker.number) {\n          // Found chapter marker. Try to update chapter\n          const nextChapterNum = parseInt(marker.number, 10);\n\n          if (Number.isNaN(nextChapterNum)) {\n            console.warn(\n              `Found ${CHAPTER_TYPE} type marker with number ${\n                marker.number\n              }, but could not parse chapter number from it. Continuing using previous chapter number ${\n                position.chapterNum\n              }`,\n            );\n          } else {\n            // Update current verse ref to new chapter\n            position.chapterNum = nextChapterNum;\n            position.verseNum = 0;\n\n            // If there are any fragments before the first encountered chapter number, move them to\n            // the first encountered chapter number\n            const currentBookFragments = indicesInUsfmByVerseRef[position.bookId];\n            if (currentBookFragments?.[0]) {\n              // Not array destructuring because it's really hard to read here\n              // eslint-disable-next-line prefer-destructuring\n              currentBookFragments[position.chapterNum] = currentBookFragments[0];\n              delete currentBookFragments[0];\n            }\n          }\n        } else if (marker.type === VERSE_TYPE && marker.number) {\n          // Found verse marker. Try to update verse\n          const nextVerseNumString = VERSE_MARKER_NUMBER_SPAN_REGEXP.exec(marker.number)?.[1];\n\n          if (!nextVerseNumString) {\n            console.warn(\n              `Found ${VERSE_TYPE} type marker with number ${\n                marker.number\n              }, but could not find starting verse number in it. Continuing using previous verse number ${\n                position.verseNum\n              }`,\n            );\n          } else {\n            const nextVerseNum = parseInt(nextVerseNumString, 10);\n\n            if (Number.isNaN(nextVerseNum)) {\n              console.warn(\n                `Found ${VERSE_TYPE} type marker with number ${\n                  marker.number\n                }, but could not parse starting verse number from ${nextVerseNumString}. Continuing using previous verse number ${\n                  position.verseNum\n                }`,\n              );\n            } else if (\n              indicesInUsfmByVerseRef[position.bookId]?.[position.chapterNum]?.[nextVerseNum]\n            ) {\n              console.warn(`Found ${VERSE_TYPE} marker with existing number ${nextVerseNum} after\n                  current ${VERSE_TYPE} number ${\n                    position.verseNum\n                  }! Not updating verse start index. All positions in this duplicate verse will be based on the current ${\n                    VERSE_TYPE\n                  } marker, not the new duplicate marker.`);\n            } else {\n              if (nextVerseNum < position.verseNum)\n                console.debug(\n                  `Found ${VERSE_TYPE} marker with number ${nextVerseNum} lower than current ${\n                    VERSE_TYPE\n                  } number ${position.verseNum}. Verses are out of order. There may be some issues.`,\n                );\n\n              // Update current verse ref to new verse\n              position.verseNum = nextVerseNum;\n            }\n          }\n        }\n      }\n\n      // Fill out the rest of the fragment info\n      const fullFragmentInfo: UsjFragmentInfo = {\n        ...fragmentInfo,\n        // Determine the appropriate `UsjDocumentLocation` subtype based on what this fragment is\n        nodeAndDocumentLocation: UsjReaderWriter.convertFragmentToUsjNodeAndDocumentLocation(\n          fragmentInfo.fragment,\n          workingStack,\n        ),\n      };\n\n      return fullFragmentInfo;\n    });\n\n    // Add staged fragments to final fragments maps\n    fullFragmentsInfo.forEach((fragmentInfo) => {\n      // Put the fragment info in the map by index in USFM\n      fragmentsByIndexInUsfm.set(fragmentInfo.indexInUsfm, fragmentInfo);\n\n      // Put the fragment info in the map by JSONPath. Note this JSONPath is generated using\n      // UsjReaderWriter.convertWorkingStackToJsonPath and\n      // UsjReaderWriter.convertWorkingStackAndPropertyToJsonPath, so it is \"normalized\".\n      // Must use \"normalized\" JSONPath when looking up fragments by JSONPath.\n      const fragmentJsonPath = fragmentInfo.nodeAndDocumentLocation.documentLocation.jsonPath;\n      const fragmentsAtJsonPath = fragmentsByJsonPath.get(fragmentJsonPath);\n      if (fragmentsAtJsonPath) fragmentsAtJsonPath.push(fragmentInfo);\n      else fragmentsByJsonPath.set(fragmentJsonPath, [fragmentInfo]);\n\n      // Put the fragment's index in USFM in the map by verse reference\n      // We are ensuring the properties are defined all the way through before use, so allow the\n      // bang operator. This would be way more verbose without bang operator.\n      /* eslint-disable no-type-assertion/no-type-assertion */\n      if (!indicesInUsfmByVerseRef[position.bookId]) indicesInUsfmByVerseRef[position.bookId] = {};\n      if (!indicesInUsfmByVerseRef[position.bookId]![position.chapterNum])\n        indicesInUsfmByVerseRef[position.bookId]![position.chapterNum] = {};\n      if (\n        indicesInUsfmByVerseRef[position.bookId]![position.chapterNum]![position.verseNum] ===\n        undefined\n      )\n        indicesInUsfmByVerseRef[position.bookId]![position.chapterNum]![position.verseNum] =\n          fragmentInfo.indexInUsfm;\n      /* eslint-enable no-type-assertion/no-type-assertion */\n    });\n\n    // Remove all elements from fragmentsInfo\n    fragmentsInfo.splice(0);\n  }\n\n  // #endregion fragment utilities\n\n  // #region USFM-related cached properties\n\n  /**\n   * Generates USFM representation of the USJ document passed in and returns it along with\n   * information about how various locations in USFM and USJ map to each other\n   */\n  private calculateUsfmProperties(): {\n    usfm: string;\n    fragmentsByIndexInUsfm: FragmentsByIndexInUsfm;\n    fragmentsByJsonPath: FragmentsByJsonPath;\n    indicesInUsfmByVerseRef: IndicesInUsfmByVerseRef;\n  } {\n    // Build the USFM up from the USJ content\n    let usfm = '';\n    // Build the fragments maps as we go\n    const fragmentsByIndexInUsfm = new SortedNumberMap<UsjFragmentInfo>();\n    const fragmentsByJsonPath = new Map<string, UsjFragmentInfo[]>();\n    const indicesInUsfmByVerseRef: IndicesInUsfmByVerseRef = {};\n\n    // Temporary staging array to put fragments in before loading them into the map\n    const fragmentsInfo: UsjFragmentInfoMinimal[] = [];\n\n    // Keep track of current verse reference numbers as we go through the content so we can put\n    // fragments in the right place\n    const currentPosition = {\n      bookId: NO_BOOK_ID,\n      chapterNum: 0,\n      verseNum: 0,\n    };\n    /** Move the fragments info that are in `fragmentsInfo` into the final fragments map */\n    function transferFragmentsInfo(workingStack: WorkingStack) {\n      UsjReaderWriter.transferFragmentsInfoArrayToMaps(\n        fragmentsInfo,\n        workingStack,\n        currentPosition,\n        fragmentsByIndexInUsfm,\n        fragmentsByJsonPath,\n        indicesInUsfmByVerseRef,\n      );\n    }\n\n    // According to `USJ`'s `outputToUsfmInstructions`, need to move the top-level `USJ` marker after\n    // `id` closes in USFM even though it is before it in USJ\n    let topLevelUsjMarker: Usj | undefined;\n    // The marker objects we're currently skipping ordered as a stack (last entry is the deepest\n    // marker we are skipping and therefore will be the next to close). If this has entries, it\n    // means we are walking through contents of marker objects whose opening marker we already skipped\n    // and whose closing marker we should also skip outputting to USFM\n    const markersToSkipOutput: (MarkerObject | Usj)[] = [];\n\n    UsjReaderWriter.findNextMatchingNodeOrClosingFragmentUsingWorkingStack(\n      this.usj,\n      // Working stack is empty since the top-level object doesn't have any parents\n      [],\n      // Don't skip anything\n      [],\n      (nodeOrClosingFragment, workingStack) => {\n        if (typeof nodeOrClosingFragment !== 'object') {\n          // Add the text contents USFM representation\n          const { usfm: textContentUsfm, fragmentsInfo: textContentFragmentsInfo } =\n            this.textContentToUsfm(nodeOrClosingFragment);\n          UsjReaderWriter.mergeFragmentsInfoIntoExistingArray(\n            textContentFragmentsInfo,\n            fragmentsInfo,\n            usfm.length,\n          );\n          transferFragmentsInfo(workingStack);\n          usfm += textContentUsfm;\n          return false;\n        }\n\n        // Determine this marker's parent\n        let markerParent: MarkerObject | Usj | undefined;\n        if (workingStack.length > 0) {\n          markerParent = workingStack[workingStack.length - 1].parent;\n        }\n\n        if ('isClosingMarker' in nodeOrClosingFragment) {\n          // If we are supposed to skip this marker in USFM, skip its closing marker\n          if (\n            markersToSkipOutput.length > 0 &&\n            markersToSkipOutput[markersToSkipOutput.length - 1] === nodeOrClosingFragment.forMarker\n          ) {\n            // Indicate the skipped marker has now closed by removing it from the stack\n            markersToSkipOutput.pop();\n            return false;\n          }\n\n          // Add the closing marker USFM representation\n          usfm = this.addMarkerUsfmToString(\n            usfm,\n            nodeOrClosingFragment,\n            markerParent,\n            fragmentsInfo,\n          );\n          transferFragmentsInfo(workingStack);\n\n          // If this is closing the `id` marker (the only marker whose type is `book`), add the\n          // top-level USJ opening marker after it\n          if (nodeOrClosingFragment.forMarker.type === 'book' && topLevelUsjMarker) {\n            usfm = this.addMarkerUsfmToString(usfm, topLevelUsjMarker, markerParent, fragmentsInfo);\n            transferFragmentsInfo(workingStack);\n            topLevelUsjMarker = undefined;\n          }\n\n          return false;\n        }\n\n        // If we are supposed to skip this marker in USFM, skip its opening marker\n        if (this.shouldSkipOutputMarkerToUsfm(nodeOrClosingFragment)) {\n          markersToSkipOutput.push(nodeOrClosingFragment);\n          return false;\n        }\n\n        // If this is the USJ marker at the start of the doc, save it until after `id` marker closes\n        if (\n          UsjReaderWriter.isTopLevelUsjMarker(nodeOrClosingFragment, workingStack) &&\n          !topLevelUsjMarker\n        ) {\n          // The USJ types aren't set up to know about 3.0 right now, but we should handle it anyway\n          // eslint-disable-next-line no-type-assertion/no-type-assertion\n          if ((nodeOrClosingFragment.version as string) !== '3.0') {\n            // Don't output the USJ marker if it is 3.0 (3.0 is assumed and should not appear in\n            // the USFM)\n            topLevelUsjMarker = nodeOrClosingFragment;\n          }\n          return false;\n        }\n\n        // Add the opening marker USFM representation\n        usfm = this.addMarkerUsfmToString(usfm, nodeOrClosingFragment, markerParent, fragmentsInfo);\n        transferFragmentsInfo(workingStack);\n\n        // Keep going through the whole document\n        return false;\n      },\n    );\n\n    // Always add newline at the end of the file; likely replaces a space\n    usfm = `${UsjReaderWriter.removeEndSpace(usfm)}\\n`;\n\n    return { usfm, fragmentsByIndexInUsfm, fragmentsByJsonPath, indicesInUsfmByVerseRef };\n  }\n\n  /** The USFM representation of the USJ document passed in */\n  private get usfm(): string {\n    if (this.usfmInternal !== undefined) return this.usfmInternal;\n\n    ({\n      usfm: this.usfmInternal,\n      fragmentsByIndexInUsfm: this.fragmentsByIndexInUsfmInternal,\n      fragmentsByJsonPath: this.fragmentsByJsonPathInternal,\n      indicesInUsfmByVerseRef: this.indicesInUsfmByVerseRefInternal,\n    } = this.calculateUsfmProperties());\n\n    return this.usfmInternal;\n  }\n\n  /** Fragments at each index in the USFM string */\n  private get fragmentsByIndexInUsfm(): FragmentsByIndexInUsfm {\n    if (this.fragmentsByIndexInUsfmInternal) return this.fragmentsByIndexInUsfmInternal;\n\n    ({\n      usfm: this.usfmInternal,\n      fragmentsByIndexInUsfm: this.fragmentsByIndexInUsfmInternal,\n      fragmentsByJsonPath: this.fragmentsByJsonPathInternal,\n      indicesInUsfmByVerseRef: this.indicesInUsfmByVerseRefInternal,\n    } = this.calculateUsfmProperties());\n\n    return this.fragmentsByIndexInUsfmInternal;\n  }\n\n  /** Fragments at each index in the USFM string */\n  private get fragmentsByJsonPath(): FragmentsByJsonPath {\n    if (this.fragmentsByJsonPathInternal) return this.fragmentsByJsonPathInternal;\n\n    ({\n      usfm: this.usfmInternal,\n      fragmentsByIndexInUsfm: this.fragmentsByIndexInUsfmInternal,\n      fragmentsByJsonPath: this.fragmentsByJsonPathInternal,\n      indicesInUsfmByVerseRef: this.indicesInUsfmByVerseRefInternal,\n    } = this.calculateUsfmProperties());\n\n    return this.fragmentsByJsonPathInternal;\n  }\n\n  /**\n   * String index of the start of each verse (the backslash on the verse marker) in the USFM\n   * representation of the USJ document. See {@link IndicesInUsfmByVerseRef} for more information.\n   */\n  private get indicesInUsfmByVerseRef(): IndicesInUsfmByVerseRef {\n    if (this.indicesInUsfmByVerseRefInternal) return this.indicesInUsfmByVerseRefInternal;\n\n    ({\n      usfm: this.usfmInternal,\n      fragmentsByIndexInUsfm: this.fragmentsByIndexInUsfmInternal,\n      fragmentsByJsonPath: this.fragmentsByJsonPathInternal,\n      indicesInUsfmByVerseRef: this.indicesInUsfmByVerseRefInternal,\n    } = this.calculateUsfmProperties());\n\n    return this.indicesInUsfmByVerseRefInternal;\n  }\n\n  // #endregion USFM-related cached properties\n}\n\nexport default UsjReaderWriter;\n"],"names":["_AsyncVariable","variableName","rejectIfNotSettledWithinMS","__publicField","resolve","reject","enabled","value","throwIfAlreadySettled","reason","AsyncVariable","Collator","locales","options","string1","string2","DateTimeFormat","date","startDate","endDate","PlatformEventEmitter","event","callback","callbackIndex","newGuid","s","isString","o","deepClone","obj","debounce","fn","delay","timeout","promise","promiseResolve","promiseReject","args","e","groupBy","items","keySelector","valueSelector","map","item","index","key","group","isErrorWithMessage","error","toErrorWithMessage","maybeError","getErrorMessage","wait","ms","waitForDuration","maxWaitTimeInMS","getAllObjectFunctionNames","_objId","objectFunctionNames","property","objectPrototype","createSyncProxyForAsyncObject","getObject","objectToProxy","target","prop","isErrorMessageAboutParatextBlockingInternetAccess","errorMessage","paratextExceptionMessage","isErrorMessageAboutRegistryAuthFailure","paratextExceptionMessage1","paratextExceptionMessage2","errorString","DocumentCombiner","baseDocument","documentName","document","previousDocumentVersion","documentToSet","contributions","contributionName","potentialOutput","outputIteration","contribution","mergeObjects","output","finalOutput","areNonArrayObjects","values","allMatch","areArrayObjects","startingPoint","copyFrom","ignoreDuplicateProperties","retVal","mergeObjectsInternal","startingPointObj","copyFromObj","EventRollingTimeCounter","bufferSize","currentTime","minRollingTimeMs","Mutex","AsyncMutex","MutexMap","mutexID","NonValidatingDocumentCombiner","NumberFormat","startRange","endRange","defaultPromise","PromiseChainingMap","logger","promiseFunction","currentPromise","promiseHolder","newPromise","SortedNumberMap","insertIndex","left","right","result","mid","SortedSet","compareFn","low","high","UnsubscriberAsyncList","name","unsubscribers","unsubscriber","unsubs","results","unsubscriberSucceeded","PLATFORM_ERROR_VERSION","newPlatformError","platformError","isPlatformError","P","R","t","n","N","B","O","S","K","g","k","x","T","X","V","w","L","G","A","H","C","I","y","q","U","m","l","h","c","E","r","D","i","a","u","v","f","d","b","p","J","M","ensureArray","maybeArray","at","string","stringLen","stringLength","substr","charAt","codePointAt","endsWith","searchString","endPosition","searchStringLen","indexOfClosestClosingCurlyBrace","str","escaped","closeCurlyBraceIndex","indexOf","strLength","formatReplacementStringToArray","replacers","contents","nextIntermediateStartIndex","addToContents","newContent","newContentIndex","newContentLength","intermediateContent","substring","baseSubstring","replacerKey","replacerContent","endContent","formatReplacementString","content","includes","position","partialString","stringzIndexOf","lastIndexOf","validatedPosition","stringzLength","normalize","form","upperCaseForm","ordinalCompare","padEnd","targetLength","padString","stringzLimit","padStart","correctSliceIndex","length","slice","indexStart","indexEnd","newStart","newEnd","split","separator","splitLimit","toArray","regexSeparator","matches","currentIndex","matchIndex","matchLength","startsWith","begin","len","stringzSubstr","end","stringzSubstring","stringzToArray","isLocalizeKey","escapeStringRegexp","transformAndEnsureRegExpRegExpArray","stringStringMaybeArray","stringMaybeStringArray","transformAndEnsureRegExpArray","stringMaybeArray","whiteSpaceRegex","isWhiteSpace","ch","toKebabCase","input","char","prevChar","nextChar","collapseMiddleWords","text","numberOfTokensToKeepBeforeAndAfter","tokens","startTokens","endTokens","BLOCK_MARKER_TYPES","USJ_TYPE","ZWSP","scrBookData","FIRST_SCR_BOOK_NUM","LAST_SCR_BOOK_NUM","FIRST_SCR_CHAPTER_NUM","FIRST_SCR_VERSE_NUM","defaultScrRef","getChaptersForBook","bookNum","_a","offsetBook","scrRef","offset","Canon","offsetChapter","offsetVerse","getLocalizedIdFromBookNumber","bookNumber","localizationLanguage","getLocalizedString","id","bookName","parts","scrRefToBBBCCC","VerseRef","scrRefToBBBCCCVVV","compareScrRefs","scrRef1","scrRef2","getLocalizeKeyForScrollGroupId","scrollGroupId","getLocalizeKeysForScrollGroupIds","scrollGroupIds","getBookNameFromVerseRef","optionOrLocalizedBookName","formatScrRefWithOptions","formatScrRefOptions","bookChapterSeparator","chapterVerseSeparator","formatScrRef","formatChapterAndVerseWithOptionalParts","formattedVerse","formatScrRefWithOptionalParts","book","chapterAndVerse","formatScrRefRange","startScrRef","endScrRef","formattedStartRef","endRefBookName","formattedEndRef","Section","getSectionForBook","bookId","nonSemanticWhiteSpaceRegex","isNonSemanticWhiteSpace","invisibleCharOrWhiteSpaceRegex","isParatextSelectableInvisibleCharOrWhiteSpace","normalizeScriptureSpaces","lastCharWasSpace","prevCh","isUsjContentEmpty","isAtEndOfBlockMarker","contentObject","parent","areUsjContentsEqualExceptWhitespaceInternal","aParent","bParent","aIsString","bIsString","aNormalized","bNormalized","aTrimmed","bTrimmed","aObject","bObject","aKeys","isAContentEmpty","isBContentEmpty","aContent","bContent","aLast","bLast","areUsjContentsEqualExceptWhitespace","aggregateUnsubscribers","success","aggregateUnsubscriberAsyncs","unsubPromises","BOOK_TYPE","CHAPTER_TYPE","VERSE_TYPE","NO_BOOK_ID","hasCustomParatextTags","html","parseParatextHtml","_match","colorName","sanitizeHtml","DOMPurify","getDefaultCallerSequence","_","getNthCaller","callers","callerList","getFormatCallerFunction","footnotes","plusSequenceMap","autoCallerCounter","idx","caller","formattedCaller","extractFootnotesFromUsjContent","traverse","getPaneSizeLimits","availablePx","splitterThicknessPx","secondaryPaneMinSizePx","mainPaneMinSizePx","absoluteMinPercent","absoluteMaxPercent","usableHeightPx","minPercent","maxPercent","getOwnPropertyNames","getOwnPropertySymbols","hasOwnProperty","combineComparators","comparatorA","comparatorB","state","createIsCircular","areItemsEqual","cache","cachedA","cachedB","getStrictProperties","object","hasOwn","sameValueZeroEqual","PREACT_VNODE","PREACT_OWNER","REACT_OWNER","getOwnPropertyDescriptor","keys","areArraysEqual","areDatesEqual","areErrorsEqual","areFunctionsEqual","areMapsEqual","size","matchedIndices","aIterable","aResult","bResult","bIterable","hasMatch","aEntry","bEntry","areNumbersEqual","areObjectsEqual","properties","isPropertyEqual","areObjectsEqualStrict","descriptorA","descriptorB","arePrimitiveWrappersEqual","areRegExpsEqual","areSetsEqual","areTypedArraysEqual","areUrlsEqual","ARGUMENTS_TAG","BOOLEAN_TAG","DATE_TAG","ERROR_TAG","MAP_TAG","NUMBER_TAG","OBJECT_TAG","REG_EXP_TAG","SET_TAG","STRING_TAG","URL_TAG","isArray","isTypedArray","assign","getTag","createEqualityComparator","type","constructor","tag","createEqualityComparatorConfig","circular","createCustomConfig","strict","config","areArraysEqual$1","areMapsEqual$1","areObjectsEqual$1","areSetsEqual$1","createInternalEqualityComparator","compare","_indexOrKeyA","_indexOrKeyB","_parentA","_parentB","createIsEqual","comparator","createState","equals","_b","meta","deepEqual","createCustomEqual","createCustomInternalComparator","isEqualDeep","isSubset","objectWithAllProperties","objectWithPartialProperties","partialArray","allArray","partialObj","allObj","serialize","replacer","space","replacerValue","newValue","deserialize","reviver","replaceNull","parsedObject","isSerializable","serializedValue","htmlEncode","getCurrentLocale","formatBytes","fileSize","decimals","sizes","sizeToUse","MILLISECONDS_PER_SECOND","SECONDS_PER_MINUTE","SECONDS_PER_HOUR","SECONDS_PER_DAY","formatTimeSpan","relativeTimeFormatter","since","to","spanSeconds","totalDays","totalHours","totalMinutes","formatRelativeDate","todayString","yesterdayString","locale","today","yesterday","isToday","isYesterday","MODIFIER_KEYS","settingsDefs","removeJsonToTypeScriptTypesStuff","defs","def","projectSettingsDocumentSchema","settingsDocumentSchema","localizedStringsDefs","localizedStringsDocumentSchema","menuDocumentSchema","themeDefs","themeDocumentSchema","THEME_STYLE_ELEMENT_ID","getThemeId","themeFamilyId","expandThemeContribution","themeFamiliesById","defaultThemeFamily","themeFamily","themeDefinition","getStylesheetForTheme","theme","applyThemeStylesheet","previousStyleElement","styleElementIdSuffix","previousThemeId","themeStyleElement","deepFreeze","USFM_MARKERS_MAP","USFM_MARKERS_MAP_PARATEXT","NODE_TYPES_NOT_CONTAINING_VERSE_TEXT","TEXT_CONTENT_NBSP_REGEXP","TABLE_MARKER_NUMBER_REGEXP","VERSE_MARKER_NUMBER_SPAN_REGEXP","UsjReaderWriter","usj","providedMarkersMap","shouldAllowInvisibleCharacters","USFM_MARKERS_MAP_3_0","versionA","versionB","jsonPathQuery","wrappedResults","JSONPath","unwrappedResults","marker","workingStack","fragment","parentMap","child","node","tempNode","tempParent","tempChild","pathArray","pathAcc","pathEntry","jsonPath","stack","stackLevel","levels","onNode","level","onLevel","indexString","nextNode","skipTypes","searchFunction","topNode","highestSkippedNode","stackItem","stackNode","skipNextNode","nextNodeClosingMarker","nextLevel","parentClosingMarker","potentiallyMatchingNodeOrClose","currentWorkingStack","nodeParent","bookIdIfNotFound","usjLocation","realParent","nodeIndexInParent","fragmentInfo","verseRef","verseIndexInUsfm","availableBookIds","noBookIdsFound","effectiveBookId","chapterIndices","indexInUsfm","bookEntries","bookIndex","lastVerseRef","didFindVerseRef","chapterEntries","chapterIndex","chapterNumString","verseIndices","verseEntries","verseIndex","verseNumString","verseFragmentInfo","usfmVerseLocation","verseRefOffset","usjChapterLocation","usjBookLocation","usfmVerseLocationIndexInUsfm","usjOffset","usjDocumentLocationMaybeNode","documentLocation","verseLocation","firstStringLocationAfterVerseMarker","maxTextLengthToSearch","textScanned","lengthScanned","lengthTrimmed","foundStartingAtOffset","workingStackForStartingPoint","startingPointStackItem","nodeTextToSearch","currentStackItem","textIndex","finalOffset","finalStack","finalNode","regex","textChunks","fullTextIndexMap","fullText","match","startingNodeEntry","start","endingNodeEntry","desiredLength","offsetRemaining","lengthRecorded","remainingNode","lengthToCopy","maxLength","currentStack","contentArray","removedCount","markerName","markerInfo","markerRegExp","scriptureFormat","markerNameOriginal","markerIsUnknown","markerTypeFromFirstMarkerInfo","markerType","markerTypeInfo","attributeMarkerInfoEntries","attributeMarkerName","attributeMarkerInfo","markerWithAnyAttributes","columnsSpanned","tableMarkerMatches","startingColumn","textContent","newFragmentsInfo","existingFragmentsInfo","existingUsfmLength","fragmentIndex","isInsideMarkerWithSameType","usfm","fragmentsInfo","markerPrefix","attributeName","attributeValue","attributeMarker","attributeMarkerFragmentsInfo","textContentUsfm","partialClosingFragment","closingMarkerAttributeNames","hasExplicitClosingMarker","independentClosingMarker","openingMarkerUsfm","openingFragmentsInfo","openingFragmentInfo","attributeNameUsfm","closingMarkerName","markerParentOrIsInsideMarkerWithSameType","usfmOutput","markerUsfmOutput","markerFragmentsInfo","isParentSameType","parentMarkerType","closingUsfm","closingFragmentsInfo","openingUsfm","lastMarkerBackslashIndex","newLocation","ignoreJsonPath","aJsonPath","restOfA","bJsonPath","restOfB","zeroedUsjLocation","fragmentInfoAtLocation","allFragmentsInfoAtJsonPath","locationOffset","offsetWithinFragment","fragmentsByIndexInUsfm","fragmentsByJsonPath","indicesInUsfmByVerseRef","nextChapterNum","currentBookFragments","nextVerseNumString","nextVerseNum","_c","fragmentJsonPath","fragmentsAtJsonPath","currentPosition","transferFragmentsInfo","topLevelUsjMarker","markersToSkipOutput","nodeOrClosingFragment","textContentFragmentsInfo","markerParent"],"mappings":"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MACA,MACA,MACA,MACA,MAEA,MACA,MACA,MACA,MACA,MACA,MACA,MAEA,MAEA,MAEA,MAEA,MAEA,MAEA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MAEA,MACA,MACA,MAEA,MAEA,MAEA,MAEA,MACA,MACA,MACA,MAEA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MAEA,MACA,MACA,KACF,EAAGC,GAAI,CACL,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACF,EAAGC,GAAI,CACL,UACA,SACA,YACA,UACA,cACA,SACA,SACA,OACA,WACA,WACA,UACA,UACA,eACA,eACA,OACA,WACA,kBACA,MACA,SACA,WACA,eACA,gBACA,SACA,WACA,eACA,UACA,kBACA,QACA,OACA,OACA,UACA,QACA,QACA,QACA,WACA,YACA,SACA,YACA,UACA,UACA,OACA,OACA,OACA,OACA,SACA,gBACA,gBACA,YACA,YACA,cACA,aACA,kBACA,kBACA,YACA,YACA,QACA,WACA,UACA,QACA,UACA,UACA,SACA,SACA,SACA,OACA,aACA,QACA,SACA,eACA,oBACA,0BACA,SACA,qBACA,sBACA,UACA,qBACA,cACA,cACA,cACA,cACA,mBACA,mBACA,qBACA,YACA,OACA,oBAGA,uBACA,uBACA,sBACA,yBACA,wBACA,qBACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,eACA,cACA,eACA,oBACA,qBACA,0BACA,0BACA,eACA,eACA,YACA,gBACA,cACA,eACA,iBACA,wBACA,mBACA,WACA,QACA,aACA,aACA,aACA,2BACA,4BACA,YACF,EAAGC,GAAIC,GAAG,EACV,SAASC,EAAEP,EAAG,EAAI,GAAI,CACpB,OAAO,IAAMA,EAAIA,EAAE,YAAa,GAAGA,KAAKK,GAAIA,GAAEL,CAAC,EAAI,CACrD,CACA,SAASQ,GAAER,EAAG,CACZ,OAAOO,EAAEP,CAAC,EAAI,CAChB,CACA,SAASS,GAAET,EAAG,CACZ,MA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L,YAAa,6EACb,KAAM,qBACR,EACA,YAAa,CACX,YACE,iFACF,KAAM,qBACR,EACA,WAAY,CACV,KAAM,kCAAA,CAEV,EACA,SAAU,CAAC,QAAS,YAAY,CAClC,EACA,yBAA0B,CACxB,YAAa,0EACb,KAAM,SACN,kBAAmB,CACjB,0BAA2B,CACzB,KAAM,wBAAA,CAEV,EACA,qBAAsB,EACxB,EACA,eAAgB,CACd,YAAa,gDACb,MAAO,CACL,CACE,KAAM,2CAAA,CACR,CAEJ,EACA,kCAAmC,CACjC,YAAa,yDACb,MAAO,CACL,CACE,KAAM,4BACR,EACA,CACE,KAAM,qCAAA,CACR,CAEJ,EACA,mBAAoB,CAClB,YAAa,8DACb,MAAO,CACL,CACE,KAAM,qBACR,EACA,CACE,KAAM,yBAAA,CACR,CAEJ,EACA,gBAAiB,CACf,YAAa,8CACb,KAAM,SACN,WAAY,CACV,yBAA0B,CACxB,YACE,+3CACF,MAAO,CACL,CACE,KAAM,MACR,EACA,CACE,KAAM,QACR,EACA,CACE,KAAM,QACN,MAAO,CACL,MAAO,CACL,CACE,KAAM,QACR,EACA,CACE,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,CAAA,CAC1B,CACF,CACF,CACF,CAEJ,EACA,yBAA0B,CACxB,YACE,igDACF,MAAO,CACL,CACE,KAAM,MACR,EACA,CACE,KAAM,QACR,EACA,CACE,KAAM,QACN,MAAO,CACL,MAAO,CACL,CACE,KAAM,QACR,EACA,CACE,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,CAAA,CAC1B,CACF,CACF,CACF,CAEJ,EACA,qBAAsB,CACpB,YACE,ybACF,MAAO,CACL,CACE,KAAM,MACR,EACA,CACE,KAAM,QACR,EACA,CACE,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,CAAA,CAC1B,CAEJ,EACA,qBAAsB,CACpB,YACE,mdACF,MAAO,CACL,CACE,KAAM,MACR,EACA,CACE,KAAM,QACR,EACA,CACE,KAAM,QACN,MAAO,CAAE,KAAM,QAAS,CAAA,CAC1B,CACF,CACF,CAEJ,EACA,qBAAsB,CACpB,YACE,sFACF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,KAAM,QACR,EACA,aAAc,CACZ,YACE,8EACF,KAAM,SAAA,CAEV,EACA,SAAU,CAAC,QAAS,OAAO,EAC3B,qBAAsB,EAAA,CAE1B,EACA,WAAY,CACV,aAAc,CACZ,YACE,qFACF,KAAM,SAAA,CACR,CAEJ,EACA,WAAY,CACV,YACE,uJACF,KAAM,SACN,kBAAmB,CACjB,0BAA2B,CACzB,YAAa,wCACb,KAAM,SACN,MAAO,CACL,CACE,WAAY,CACV,OAAQ,CACN,YACE,wEACF,KAAM,wBACR,EACA,MAAO,CACL,YACE,yGACF,KAAM,QACR,EACA,aAAc,CACZ,YACE,iFACF,KAAM,SAAA,CAEV,EACA,SAAU,CAAC,OAAO,EAClB,qBAAsB,EACxB,EACA,CACE,WAAY,CACV,SAAU,CACR,YAAa,8DACb,KAAM,wBACR,EACA,MAAO,CACL,YACE,yGACF,KAAM,QACR,EACA,aAAc,CACZ,YACE,iFACF,KAAM,SAAA,CAEV,EACA,SAAU,CAAC,WAAY,OAAO,EAC9B,qBAAsB,EAAA,CACxB,CACF,CAEJ,EACA,qBAAsB,EACxB,EACA,SAAU,CACR,YACE,mGACF,KAAM,SACN,MAAO,CACL,CACE,WAAY,CACV,GAAI,CACF,YAAa,6CACb,KAAM,wBAAA,CAEV,EACA,SAAU,CAAC,IAAI,CACjB,EACA,CACE,WAAY,CACV,QAAS,CACP,YAAa,mEACb,KAAM,wBACR,EACA,eAAgB,CACd,YACE,0GACF,KAAM,QACR,EACA,cAAe,CACb,YACE,yGACF,KAAM,QAAA,CAEV,EACA,SAAU,CAAC,SAAS,CAAA,CAExB,EACA,WAAY,CACV,MAAO,CACL,YAAa,4DACb,KAAM,qBACR,EACA,QAAS,CACP,YACE,uFACF,KAAM,qBACR,EACA,YAAa,CACX,YACE,6GACF,KAAM,qBACR,EACA,cAAe,CACb,YACE,wFACF,KAAM,QACR,EACA,MAAO,CACL,YAAa,wCACb,KAAM,wBACR,EACA,MAAO,CACL,YACE,qGACF,KAAM,QAAA,CAEV,EACA,SAAU,CAAC,QAAS,QAAS,OAAO,EACpC,sBAAuB,EACzB,EACA,eAAgB,C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IAAK,CACH,KAAM,OACN,YAAa,yCACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,4CACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,uBACf,EACA,GAAI,CACF,KAAM,OACN,YACE,kFACJ,EACA,IAAK,CACH,KAAM,OACN,YAAa,wEACf,EACA,IAAK,CACH,KAAM,OACN,YACE,mFACJ,EACA,IAAK,CACH,KAAM,OACN,YACE;AAAA,sDACJ,EACA,KAAM,CACJ,KAAM,OACN,YAAa,wDACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,mCACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,mCACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,gEACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,yEACf,EACA,MAAO,CACL,KAAM,OACN,YAAa,4EACf,EACA,MAAO,CACL,KAAM,OACN,YAAa,uDACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,sDACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,yDACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,oCACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,oCACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,oCACf,EACA,IAAK,CACH,KAAM,OACN,YACE,oFACJ,EACA,IAAK,CACH,KAAM,OACN,YAAa,4BACf,EACA,GAAI,CACF,KAAM,OACN,YACE;AAAA,yDACJ,EACA,IAAK,CACH,KAAM,OACN,YAAa,gEACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,wDACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,6CACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,qDACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,wDACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,mCACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,mCACf,EACA,IAAK,CACH,KAAM,MACR,EACA,GAAI,CACF,KAAM,OACN,YAAa,yDACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,4DACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,uCACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,oCACf,EACA,IAAK,CACH,KAAM,OACN,iBAAkB,YAClB,YAAa,sDACf,EACA,EAAG,CACD,KAAM,OACN,YAAa,eACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,iDACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,iDACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,mCACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,mCACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,yCACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,4CACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,uBACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,uBACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,uBACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,gCACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,mDACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,sDACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,iCACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,iCACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,iCACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,mDACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,uBACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,yDACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,4DACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,uCACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,uCACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,uCACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,uCACf,EACA,EAAG,CACD,KAAM,OACN,YACE,gGACJ,EACA,GAAI,CACF,KAAM,OACN,YAAa,+EACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,mDACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,6DACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,gEACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,2CACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,2CACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,8CACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,iDACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,2DACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,iDACf,EACA,IAAK,CACH,KAAM,OACN,YACE;AAAA,8DACJ,EACA,IAAK,CACH,KAAM,OACN,YACE,uFACJ,EACA,KAAM,CACJ,KAAM,OACN,YACE,4FACJ,EACA,KAAM,CACJ,KAAM,OACN,YAAa,qEACf,EACA,GAAI,CACF,KAAM,OACN,YACE,kFACJ,EACA,GAAI,CACF,KAAM,OACN,YAAa,mBACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,2BACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,oCACf,EACA,SAAU,CACR,KAAM,UACR,EACA,IAAK,CACH,KAAM,OACN,YAAa,2CACf,EACA,EAAG,CACD,KAAM,OACN,YACE;AAAA,6CACJ,EACA,GAAI,CACF,KAAM,OACN,YAAa,mEACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,mEACf,EACA,GAAI,CACF,KAAM,OACN,YACE,uGACJ,EACA,GAAI,CACF,KAAM,OACN,YAAa,uCACf,EACA,OAAQ,CACN,KAAM,SACN,qBAAsB,KACxB,EACA,GAAI,CACF,KAAM,OACN,YACE,iGACJ,EACA,IAAK,CACH,KAAM,OACN,YAAa,kEACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,6CACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,6CACf,EACA,GAAI,CACF,KAAM,OACN,YACE,oGACJ,EACA,IAAK,CACH,KAAM,OACN,YACE,uGACJ,EACA,IAAK,CACH,KAAM,OACN,YACE,kFACJ,EACA,IAAK,CACH,KAAM,OACN,YACE,kFACJ,EACA,GAAI,CACF,KAAM,OACN,YAAa,yBACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,uBACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,uBACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,uBACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,mBACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,8BACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,gBACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,wCACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,6EACf,EACA,EAAG,CACD,KAAM,OACN,YAAa,+CACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,kDACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,6BACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,6BACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,6BACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,sCACf,EACA,IAAK,CACH,KAAM,OACN,YACE,kFACJ,EACA,GAAI,CACF,KAAM,OACN,YAAa,uBACf,EACA,GAAI,CACF,KAAM,OACN,YACE,0FACJ,EACA,GAAI,CACF,KAAM,OACN,YAAa,yDACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,4DACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,uCACf,EACA,IAAK,CACH,KAAM,OACN,YAAa,uCACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,4BACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,oBACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,8DACf,EACA,OAAQ,CACN,KAAM,KACN,iBAAkB,KACpB,EACA,OAAQ,CACN,KAAM,KACN,iBAAkB,KACpB,EACA,QAAS,CACP,KAAM,KACN,iBAAkB,KACpB,EACA,QAAS,CACP,KAAM,KACN,iBAAkB,KACpB,EACA,QAAS,CACP,KAAM,KACN,iBAAkB,KACpB,EACA,QAAS,CACP,KAAM,KACN,iBAAkB,KACpB,EACA,QAAS,CACP,KAAM,KACN,iBAAkB,KACpB,EACA,QAAS,CACP,KAAM,KACN,iBAAkB,KACpB,EACA,QAAS,CACP,KAAM,KACN,iBAAkB,KACpB,EACA,QAAS,CACP,KAAM,KACN,iBAAkB,KACpB,EACA,QAAS,CACP,KAAM,KACN,iBAAkB,KACpB,EACA,QAAS,CACP,KAAM,KACN,iBAAkB,KACpB,EACA,EAAG,CACD,KAAM,OACN,YAAa,uBACf,EACA,GAAI,CACF,KAAM,OACN,iBAAkB,OACpB,EACA,IAAK,CACH,KAAM,MACN,iBAAkB,KACpB,EACA,IAAK,CACH,KAAM,OACN,YAAa,QACf,EACA,QAAS,CACP,KAAM,OACN,YAAa,sCACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,2EACf,EACA,EAAG,CACD,KAAM,OACN,YAAa,8CACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,iDACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,kDACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,2DACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,4BACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,kDACf,EACA,GAAI,CACF,KAAM,OACN,YACE,iFACJ,EACA,IAAK,CACH,KAAM,OACN,YACE,iHACJ,EACA,IAAK,CACH,KAAM,OACN,YACE,4FACJ,EACA,IAAK,CACH,KAAM,OACN,YACE,4FACJ,EACA,IAAK,CACH,KAAM,OACN,YACE,4FACJ,EACA,IAAK,CACH,KAAM,OACN,YAAa,+CACf,EACA,IAAK,CACH,KAAM,OACN,YACE,kGACJ,EACA,GAAI,CACF,KAAM,OACN,YAAa,+CACf,EACA,GAAI,CACF,KAAM,OACN,YAAa,6CACf,EACA,IAAK,CACH,KAAM,OACN,YAAa;AAAA,OACf,EACA,IAAK,CACH,KAAM,OACN,YACE,2FACJ,EACA,MAAO,CACL,KAAM,KACN,iBAAkB,KACpB,EACA,MAAO,CACL,KAAM,KACN,iBAAkB,KACpB,EACA,MAAO,CACL,KAAM,OACR,EACA,GAAI,CACF,KAAM,OACN,YAAa,0BACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,6BACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,8BACf,EACA,KAAM,CACJ,KAAM,OACN,YAAa,mBACf,EACA,MAAO,CACL,KAAM,OACN,YAAa,kDACf,EACA,MAAO,CACL,KAAM,OACN,YAAa,mDACf,EACA,MAAO,CACL,KAAM,OACN,YAAa,wCACf,EACA,GAAI,CACF,KAAM,MACN,YAAa,WACf,EACA,GAAI,CACF,KAAM,KACN,YACE,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","x_google_ignoreList":[16,25]}