// Generated by dts-bundle-generator v9.5.1

import { MarkerContent, MarkerObject, Usj } from '@eten-tech-foundation/scripture-utilities';
import { SerializedVerseRef } from '@sillsdev/scripture';
import { Mutex as AsyncMutex } from 'async-mutex';

/** This class provides a convenient way for one task to wait on a variable that another task sets. */
export declare class AsyncVariable<T> {
	private static verboseLoggingEnabled;
	private readonly variableName;
	private readonly promiseToValue;
	private timeoutId;
	private timeoutOccurred;
	private resolver;
	private rejecter;
	/**
	 * Creates an instance of the class
	 *
	 * @param variableName Name to use when logging about this variable
	 * @param rejectIfNotSettledWithinMS Milliseconds to wait before verifying if the promise was
	 *   settled (resolved or rejected); will reject if it has not settled by that time. Use -1 if you
	 *   do not want a timeout at all. Defaults to 10000 ms
	 */
	constructor(variableName: string, rejectIfNotSettledWithinMS?: number);
	/**
	 * Get this variable's promise to a value. This always returns the same promise even after the
	 * value has been resolved or rejected.
	 *
	 * @returns The promise for the value to be set
	 */
	get promise(): Promise<T>;
	/**
	 * A simple way to see if this variable's promise was resolved or rejected already
	 *
	 * @returns Whether the variable was already resolved or rejected
	 */
	get hasSettled(): boolean;
	/**
	 * Can use to determine if a rejection occurred due to a timeout
	 *
	 * @returns Whether the variable timed out while waiting for a value to resolve
	 */
	get hasTimedOut(): boolean;
	/**
	 * Allows enabling more verbose logging when async variables resolve and reject
	 *
	 * @param enabled Whether to enable verbose logging
	 */
	static setVerboseLogging(enabled: boolean): void;
	/**
	 * Resolve this variable's promise to the given value
	 *
	 * @param value This variable's promise will resolve to this value
	 * @param throwIfAlreadySettled Determines whether to throw if the variable was already resolved
	 *   or rejected. Defaults to `false`
	 */
	resolveToValue(value: T, throwIfAlreadySettled?: boolean): void;
	/**
	 * Reject this variable's promise for the value with the given reason
	 *
	 * @param reason This variable's promise will be rejected with this reason
	 * @param throwIfAlreadySettled Determines whether to throw if the variable was already resolved
	 *   or rejected. Defaults to `false`
	 */
	rejectWithReason(reason: string, throwIfAlreadySettled?: boolean): void;
	/** Prevent any further updates to this variable */
	private complete;
}
/** Enables language-sensitive string comparison. Wraps Intl.Collator */
export declare class Collator {
	private collator;
	constructor(locales?: string | string[], options?: Intl.CollatorOptions);
	/**
	 * Compares two strings according to the sort order of this Collator object
	 *
	 * @param string1 String to compare
	 * @param string2 String to compare
	 * @returns A number indicating how string1 and string2 compare to each other according to the
	 *   sort order of this Collator object. Negative value if string1 comes before string2. Positive
	 *   value if string1 comes after string2. 0 if they are considered equal.
	 */
	compare(string1: string, string2: string): number;
	/**
	 * Returns a new object with properties reflecting the locale and collation options computed
	 * during initialization of this collator object.
	 *
	 * @returns ResolvedCollatorOptions object
	 */
	resolvedOptions(): Intl.ResolvedCollatorOptions;
}
/** Enables language-sensitive data and time formatting. Wraps Intl.DateTimeFormat */
export declare class DateTimeFormat {
	private dateTimeFormatter;
	constructor(locales?: string | string[], options?: Intl.DateTimeFormatOptions);
	/**
	 * Formats a date according to the locale and formatting option for this DateTimeFormat object
	 *
	 * @param date The date to format
	 * @returns String representing the given date formatted according to the locale and formatting
	 *   options of this DateTimeFormat object
	 */
	format(date: Date): string;
	/**
	 * Formats a date range in the most concise way based on the locales and options provided when
	 * instantiating this DateTimeFormat object
	 *
	 * @param startDate Date object representing start of the date range
	 * @param endDate Date object representing the end of the date range
	 * @returns String representing the given date range formatted according to the locale and
	 *   formatting options of this DateTimeFormat object
	 */
	formatRange(startDate: Date, endDate: Date): string;
	/**
	 * Returns an array of locale-specific tokens representing each part of the formatted date range
	 * produced by this DateTimeFormat object
	 *
	 * @param startDate Date object representing start of the date range
	 * @param endDate Date object representing the end of the date range
	 * @returns Array of DateTimeRangeFormatPart objects
	 */
	formatRangeToParts(startDate: Date, endDate: Date): Intl.DateTimeRangeFormatPart[];
	/**
	 * Allows locale-aware formatting of strings produced by this DateTimeFormat object
	 *
	 * @param date The date to format
	 * @returns Array of DateTimeFormatPart objects
	 */
	formatToParts(date: Date): Intl.DateTimeFormatPart[];
	/**
	 * Returns a new object with properties reflecting the locale and date and time formatting options
	 * computed during initialization of this DateTimeFormat object
	 *
	 * @returns ResolvedDateTimeFormatOptions object
	 */
	resolvedOptions(): Intl.ResolvedDateTimeFormatOptions;
}
export type JsonObjectLike = {
	[key: string]: unknown;
};
export type JsonArrayLike = unknown[];
export type JsonDocumentLike = JsonObjectLike | JsonArrayLike;
/**
 * Options for DocumentCombiner objects
 *
 * - `copyDocuments`: If true, this instance will perform a deep copy of all provided documents before
 *   composing the output. If false, then changes made to provided documents after they are
 *   contributed will be reflected in the next time output is composed.
 * - `ignoreDuplicateProperties`: If true, then duplicate properties are skipped if they are seen in
 *   contributed documents. If false, then throw when duplicate properties are seen in contributed
 *   documents.
 */
export type DocumentCombinerOptions = {
	copyDocuments: boolean;
	ignoreDuplicateProperties: boolean;
};
/**
 * Base class for any code that wants to compose JSON documents (primarily in the form of JS objects
 * or arrays) together into a single output document.
 */
export declare class DocumentCombiner {
	protected baseDocument: JsonDocumentLike;
	protected readonly contributions: Map<string, JsonDocumentLike>;
	protected latestOutput: JsonDocumentLike | undefined;
	protected readonly options: DocumentCombinerOptions;
	private readonly onDidRebuildEmitter;
	/** Event that emits to announce that the document has been rebuilt and the output has been updated */
	readonly onDidRebuild: PlatformEvent<undefined>;
	/**
	 * Create a DocumentCombiner instance
	 *
	 * @param baseDocument This is the first document that will be used when composing the output
	 * @param options Options used by this object when combining documents
	 */
	protected constructor(baseDocument: JsonDocumentLike, options: DocumentCombinerOptions);
	/**
	 * Update the starting document for composition process
	 *
	 * @param baseDocument Base JSON document/JS object that all other documents are added to
	 * @returns Recalculated output document given the new starting state and existing other documents
	 */
	updateBaseDocument(baseDocument: JsonDocumentLike): JsonDocumentLike | undefined;
	/**
	 * Add or update one of the contribution documents for the composition process
	 *
	 * Note: the order in which contribution documents are added can be considered indeterminate as it
	 * depends on the order in which `Map.forEach` iterates over the contributions. However, the order
	 * matters when merging two arrays into one. Also, when `options.ignoreDuplicateProperties` is is
	 * `true`, the order also matters when adding the same property to an object that is already
	 * provided previously. Please let us know if you have trouble because of indeterminate
	 * contribution ordering.
	 *
	 * @param documentName Name of the contributed document to combine
	 * @param document Content of the contributed document to combine
	 * @returns Recalculated output document given the new or updated contribution and existing other
	 *   documents
	 */
	addOrUpdateContribution(documentName: string, document: JsonDocumentLike): JsonDocumentLike | undefined;
	/**
	 * Delete one of the contribution documents for the composition process
	 *
	 * @param documentName Name of the contributed document to delete
	 * @returns Recalculated output document given the remaining other documents
	 */
	deleteContribution(documentName: string): JsonDocumentLike | undefined;
	/**
	 * Delete all present contribution documents for the composition process and return to the base
	 * document
	 *
	 * @returns Recalculated output document consisting only of the base document
	 */
	deleteAllContributions(): JsonDocumentLike | undefined;
	/**
	 * Run the document composition process given the starting document and all contributions. Throws
	 * if the output document fails to validate properly.
	 *
	 * @returns Recalculated output document given the starting and contributed documents
	 */
	rebuild(): JsonDocumentLike | undefined;
	/**
	 * Transform the starting document that is given to the combiner. This transformation occurs after
	 * validating the base document and before combining any contributions.
	 *
	 * WARNING: If you do not create the combiner with option `copyDocuments: true` or clone inside
	 * this method, this method will directly modify the `baseDocument` passed in.
	 *
	 * @param baseDocument Initial input document. Already validated via `validateBaseDocument`
	 * @returns Transformed base document
	 */
	protected transformBaseDocumentAfterValidation(baseDocument: JsonDocumentLike): JsonDocumentLike;
	/**
	 * Transform the contributed document associated with `documentName`. This transformation occurs
	 * after validating the contributed document and before combining with other documents.
	 *
	 * WARNING: If you do not create the combiner with option `copyDocuments: true` or clone inside
	 * this method, this method will directly modify the contributed `document` passed in.
	 *
	 * @param documentName Name of the contributed document to combine
	 * @param document Content of the contributed document to combine. Already validated via
	 *   `validateContribution`
	 * @returns Transformed contributed document
	 */
	protected transformContributionAfterValidation(documentName: string, document: JsonDocumentLike): JsonDocumentLike;
	/**
	 * Throw an error if the provided document is not a valid starting document.
	 *
	 * @param baseDocument Base JSON document/JS object that all other documents are added to
	 */
	protected validateBaseDocument(baseDocument: JsonDocumentLike): void;
	/**
	 * Throw an error if the provided document is not a valid contribution document.
	 *
	 * @param documentName Name of the contributed document to combine
	 * @param document Content of the contributed document to combine
	 */
	protected validateContribution(documentName: string, document: JsonDocumentLike): void;
	/**
	 * Throw an error if the provided output is not valid.
	 *
	 * @param output Output document that could potentially be returned to callers
	 */
	protected validateOutput(output: JsonDocumentLike): void;
	/**
	 * Transform the document that is the composition of the base document and all contribution
	 * documents. This is the last step that will be run prior to validation via `validateOutput`
	 * before `this.latestOutput` is updated to the new output.
	 *
	 * @param finalOutput Final output document that could potentially be returned to callers. "Final"
	 *   means no further contribution documents will be merged.
	 */
	protected transformFinalOutputBeforeValidation(finalOutput: JsonDocumentLike): JsonDocumentLike;
}
/** Class that tracks how long it has taken the last N events to occur */
export declare class EventRollingTimeCounter {
	/** The ring buffer to store times */
	private readonly ringBuffer;
	/** The size of the ring buffer */
	private readonly bufferSize;
	/** The next location where a time will be written */
	private writerIndex;
	/** The location where the first time in the buffer will be read */
	private readerIndex;
	/** The most recent difference in time between the newest and oldest events */
	private lastTimeDifference;
	/** How many instances in total have been recorded */
	private totalInstanceCount;
	/**
	 * Create a new instance of the InstanceTimeCounter class
	 *
	 * @param bufferSize - Maximum number of instances to track
	 */
	constructor(bufferSize: number);
	/** Get the total number of instances that have been recorded */
	get totalInstances(): number;
	/** Add a new time measurement for an instance of an event */
	recordInstance(): void;
	/**
	 * Check if the time between the last N events is less than the provided threshold
	 *
	 * @param minRollingTimeMs - Minimum time that must have passed when the last N events occurred
	 * @returns - True if the threshold is violated, false otherwise
	 */
	hasViolatedThreshold(minRollingTimeMs: number): boolean;
}
/**
 * Class that allows calling asynchronous functions multiple times at once while only running one at
 * a time.
 *
 * @example
 *
 * ```typescript
 * const mutex = new Mutex();
 *
 * mutex.runExclusive(async () => {
 *   // Do some asynchronous stuff
 *   console.log('These run one-at-a-time');
 * });
 *
 * mutex.runExclusive(async () => {
 *   // Do some asynchronous stuff
 *   console.log('These run one-at-a-time');
 * });
 * ```
 *
 * See [`async-mutex`](https://www.npmjs.com/package/async-mutex) for more information.
 */
export declare class Mutex extends AsyncMutex {
}
/** Map of {@link Mutex}es that automatically (lazily) generates a new {@link Mutex} for any new key */
export declare class MutexMap {
	private mutexesByID;
	/**
	 * Retrieves the {@link Mutex} associated with the given ID. If no Mutex exists for the provided
	 * ID, a new Mutex is created, stored, and returned.
	 *
	 * @param mutexID Unique identifier for the desired Mutex
	 * @returns The Mutex associated with the provided ID
	 */
	get(mutexID: string): Mutex;
}
export declare class NonValidatingDocumentCombiner extends DocumentCombiner {
	constructor(baseDocument: JsonDocumentLike, options: DocumentCombinerOptions);
	get output(): JsonDocumentLike | undefined;
}
/** Enables language-sensitive number formatting. Wraps Intl.NumberFormat */
export declare class NumberFormat {
	private numberFormatter;
	constructor(locales?: string | string[], options?: Intl.NumberFormatOptions);
	/**
	 * Formats a number according to the locale and formatting options of this NumberFormat object
	 *
	 * @param value Number or BigInt to format
	 * @returns String representing the given number formatted according to the locale and formatting
	 *   options of this NumberFormat object
	 */
	format(value: number | bigint): string;
	/**
	 * Formats a range of numbers according to the locale and formatting options of this NumberFormat
	 * object
	 *
	 * @param startRange Number or bigint representing the start of the range
	 * @param endRange Number or bigint representing the end of the range
	 * @returns String representing the given range of numbers formatted according to the locale and
	 *   formatting options of this NumberFormat object
	 */
	formatRange(startRange: number | bigint, endRange: number | bigint): string;
	/**
	 * Returns an array of objects containing the locale-specific tokens from which it is possible to
	 * build custom strings while preserving the locale-specific parts.
	 *
	 * @param startRange Number or bigint representing start of the range
	 * @param endRange Number or bigint representing end of the range
	 * @returns Array of NumberRangeFormatPart objects containing the formatted range of numbers in
	 *   parts
	 */
	formatRangeToParts(startRange: number | bigint, endRange: number | bigint): Intl.NumberRangeFormatPart[];
	/**
	 * Allows locale-aware formatting of strings produced by this NumberFormat object
	 *
	 * @param value Number or bigint to format
	 * @returns Array of NumberFormatPart objects containing the formatted number in parts
	 */
	formatToParts(value: number | bigint): Intl.NumberFormatPart[];
	/**
	 * Returns a new object with properties reflecting the locale and number formatting options
	 * computed during initialization of this NumberFormat object
	 *
	 * @returns ResolvedNumberFormatOptions object
	 */
	resolvedOptions(): Intl.ResolvedNumberFormatOptions;
}
/** Function to run to dispose of something. Returns true if successfully unsubscribed */
export type Unsubscriber = () => boolean;
/**
 * Returns an Unsubscriber function that combines all the unsubscribers passed in.
 *
 * @param unsubscribers All unsubscribers to aggregate into one unsubscriber
 * @returns Function that unsubscribes from all passed in unsubscribers when run
 */
export declare const aggregateUnsubscribers: (unsubscribers: Unsubscriber[]) => Unsubscriber;
/**
 * Function to run to dispose of something that runs asynchronously. The promise resolves to true if
 * successfully unsubscribed
 */
export type UnsubscriberAsync = () => Promise<boolean>;
/**
 * Returns an UnsubscriberAsync function that combines all the unsubscribers passed in.
 *
 * @param unsubscribers - All unsubscribers to aggregate into one unsubscriber.
 * @returns Function that unsubscribes from all passed in unsubscribers when run
 */
export declare const aggregateUnsubscriberAsyncs: (unsubscribers: (UnsubscriberAsync | Unsubscriber)[]) => UnsubscriberAsync;
/** Callback function that accepts an event and should run when an event is emitted */
export type PlatformEventHandler<T> = (event: T) => void;
/**
 * Function that subscribes the provided callback to run when this event is emitted.
 *
 * @param callback Function to run with the event when it is emitted
 * @returns Unsubscriber function to run to stop calling the passed-in function when the event is
 *   emitted
 */
export type PlatformEvent<T> = (callback: PlatformEventHandler<T>) => Unsubscriber;
/**
 * A PapiEvent that subscribes asynchronously and resolves an asynchronous unsubscriber.
 *
 * Note: The callback itself is not asynchronous.
 */
export type PlatformEventAsync<T> = (callback: PlatformEventHandler<T>) => Promise<UnsubscriberAsync>;
/** Require a `dispose` function */
export interface Dispose {
	/** Release resources and notify dependent services when tearing down an object */
	dispose: UnsubscriberAsync;
}
/** Require an `onDidDispose` event */
export interface OnDidDispose {
	/** Event that emits when `dispose` is called on an object */
	onDidDispose: PlatformEvent<void>;
}
/**
 * Indicates than an object cannot have an `onDidDispose` event. Also allows an object to include a
 * `dispose` function.
 */
export interface CannotHaveOnDidDispose {
	/** Release resources and notify dependent services when tearing down an object */
	dispose?: UnsubscriberAsync;
	/** Event that emits when `dispose` is called on an object */
	onDidDispose?: undefined;
}
/** Allow onDidDispose to exist on the type if it was previously disallowed by CannotHaveOnDidDispose */
export type CanHaveOnDidDispose<T extends CannotHaveOnDidDispose> = Omit<T, "onDidDispose">;
/**
 * Event manager - accepts subscriptions to an event and runs the subscription callbacks when the
 * event is emitted Use eventEmitter.event(callback) to subscribe to the event. Use
 * eventEmitter.emit(event) to run the subscriptions. Generally, this EventEmitter should be
 * private, and its event should be public. That way, the emitter is not publicized, but anyone can
 * subscribe to the event.
 */
export declare class PlatformEventEmitter<T> implements Dispose {
	/**
	 * Subscribes a function to run when this event is emitted.
	 *
	 * @param callback Function to run with the event when it is emitted
	 * @returns Unsubscriber function to run to stop calling the passed-in function when the event is
	 *   emitted
	 */
	subscribe: PlatformEvent<T>;
	/** All callback functions that will run when this event is emitted. Lazy loaded */
	private subscriptions?;
	/** Event for listeners to subscribe to. Lazy loaded */
	private lazyEvent?;
	/** Whether this emitter has been disposed */
	private isDisposed;
	/**
	 * Event for listeners to subscribe to. Subscribes a function to run when this event is emitted.
	 * Use like `const unsubscriber = event(callback)`
	 *
	 * @returns Unsubscriber function to run to stop calling the passed-in function when the event is
	 *   emitted
	 */
	get event(): PlatformEvent<T>;
	/** Disposes of this event, preparing it to release from memory */
	dispose: () => Promise<boolean>;
	/**
	 * Runs the subscriptions for the event
	 *
	 * @param event Event data to provide to subscribed callbacks
	 */
	emit: (event: T) => void;
	/**
	 * Function that runs the subscriptions for the event. Added here so children can override emit
	 * and still call the base functionality. See NetworkEventEmitter.emit for example
	 */
	protected emitFn(event: T): void;
	/** Check to make sure this emitter is not disposed. Throw if it is */
	protected assertNotDisposed(): void;
	/**
	 * Disposes of this event, preparing it to release from memory. Added here so children can
	 * override emit and still call the base functionality.
	 */
	protected disposeFn(): Promise<boolean>;
}
/**
 * Class that allows you to chain promises for a given key. This is useful when:
 *
 * 1. You need to run promises from synchronous code and don't need to look at the results.
 * 2. The promises to run, or at least precisely when to run them, are not known in advance.
 * 3. The promises need to be run sequentially, waiting for the previous one to finish.
 *
 * An example of when this can be helpful is inside of React components. Component code is mostly
 * synchronous, but you may need to run some asynchronous code. You can't use `await` inside of
 * React component code in many situations, so you can use this class to chain promises together.
 *
 * When promises are added to the map with a key, they will run in the order they were added to the
 * map for that key. If a promise rejects, a warning will be logged and the chain will continue. If
 * a promise is added while another promise in the map for that key is running, the new promise will
 * be chained to the existing one.
 */
export declare class PromiseChainingMap<TKey = string> {
	private readonly map;
	private readonly logger;
	/**
	 * Creates a new PromiseChainingMap
	 *
	 * @param logger Object with a `warn` method that will be called when a promise rejects. This
	 *   defaults to `console`.
	 */
	constructor(logger?: {
		warn: (message: string) => void;
	});
	/**
	 * Adds a promise function to the map for a given key. If a promise is already running for the
	 * key, the new promise will be chained to the existing one. Once all promises for a key have
	 * settled, the map will be cleared for that key.
	 *
	 * @param key Unique key to identify a distinct promise chain
	 * @param promiseFunction Function that returns a promise to add to the chain
	 */
	addPromiseFunction(key: TKey, promiseFunction: () => Promise<unknown>): void;
	/**
	 * Gets the current promise chain for the given key. This is mostly useful for testing. Normally
	 * you should just call {@link addPromiseFunction} and let the map handle the rest.
	 *
	 * @param key Unique key to identify a distinct promise chain
	 * @returns The current promise chain for the key
	 */
	get(key: TKey): Promise<unknown> | undefined;
	/**
	 * Configures a promise chain to be removed from the map for the given key after all the promises
	 * have settled
	 *
	 * @param key Unique key to identify a distinct promise chain
	 */
	private cleanupPromiseChain;
}
/**
 * A map-like data structure that maintains numeric keys in sorted order and provides efficient
 * operations for finding the closest key-value pair less than or equal to a target.
 *
 * This class combines the benefits of a Map (O(1) key-value lookups) with sorted key access (O(log
 * n) binary search operations). It's particularly useful when you need to frequently find the
 * "closest" entry to a given numeric key.
 *
 * @example
 *
 * ```typescript
 * const versionMap = new SortedNumberMap<string>();
 * versionMap.set(100, 'Version 1.0.0');
 * versionMap.set(150, 'Version 1.5.0');
 * versionMap.set(200, 'Version 2.0.0');
 *
 * // Find the highest version <= 175
 * const result = versionMap.findClosestLessThanOrEqual(175);
 * console.log(result); // { key: 150, value: 'Version 1.5.0' }
 * ```
 *
 * @template T The type of values stored in the map
 */
export declare class SortedNumberMap<T> {
	private map;
	private sortedKeys;
	/**
	 * Returns an iterable of keys in the map. These keys are not necessarily sorted.
	 *
	 * Time complexity: internal detail to JavaScript engine. Reasonable expectation:
	 *
	 * - Executing this method to return an iterator: O(1)
	 * - Iterating over the returned iterator: O(n)
	 *
	 * Note that iterating over the keys this way negates the benefits of using this class over a
	 * using a {@link Map}. To access individual keys more quickly, use
	 * {@link SortedNumberMap.findClosestLessThanOrEqual} or {@link SortedNumberMap.get}.
	 *
	 * TSDoc adapted from {@link Map.keys}
	 */
	keys(): MapIterator<number>;
	/**
	 * Returns a specified element from the Map object. If the value that is associated to the
	 * provided key is an object, then you will get a reference to that object and any change made to
	 * that object will effectively modify it inside the Map.
	 *
	 * Time complexity: O(1)
	 *
	 * @returns Returns the element associated with the specified key. If no element is associated
	 *   with the specified key, returns `undefined`.
	 *
	 *   TSDoc adapted from {@link Map.get}
	 */
	get(key: number): T | undefined;
	/**
	 * Sets a key-value pair in the map. If the key already exists, its value is updated. If the key
	 * is new, it's inserted in the correct sorted position.
	 *
	 * Time complexity: O(log n) for new keys (due to binary search and array insertion), O(1) for
	 * existing keys.
	 *
	 * @example
	 *
	 * ```typescript
	 * const map = new SortedNumberMap<string>();
	 * map.set(10, 'ten');
	 * map.set(5, 'five');
	 * map.set(15, 'fifteen');
	 * // Keys are automatically maintained in sorted order: [5, 10, 15]
	 * ```
	 *
	 * @param key - The numeric key to set
	 * @param value - The value to associate with the key
	 */
	set(key: number, value: T): void;
	/**
	 * Finds the key-value pair with the largest key that is less than or equal to the target.
	 *
	 * This method uses binary search to efficiently locate the closest match. If no key is less than
	 * or equal to the target, it returns undefined.
	 *
	 * Time complexity: O(log n)
	 *
	 * @example
	 *
	 * ```typescript
	 * const map = new SortedNumberMap<string>();
	 * map.set(10, 'ten');
	 * map.set(20, 'twenty');
	 * map.set(30, 'thirty');
	 *
	 * // Exact match
	 * map.findClosestLessThanOrEqual(20); // { key: 20, value: 'twenty' }
	 *
	 * // Closest less than
	 * map.findClosestLessThanOrEqual(25); // { key: 20, value: 'twenty' }
	 *
	 * // No match (target too small)
	 * map.findClosestLessThanOrEqual(5); // undefined
	 * ```
	 *
	 * @param target - The number to search for
	 * @returns The key-value pair with the largest key ≤ target, or undefined if none exists
	 */
	findClosestLessThanOrEqual(target: number): {
		key: number;
		value: T;
	} | undefined;
	private binarySearchLessThanOrEqual;
	private binarySearchInsertIndex;
}
/**
 * A collection of unique items that are automatically maintained in sorted order, similar to C#'s
 * SortedSet.
 *
 * @template T The type of elements in the set
 */
export declare class SortedSet<T> {
	private readonly compareFn;
	/** Internal storage for the sorted items */
	private readonly items;
	/**
	 * Creates a new sorted set
	 *
	 * @param compareFn - Function used to determine the order of elements. Returns negative when a <
	 *   b, zero when a = b, positive when a > b
	 */
	constructor(compareFn: (a: T, b: T) => number);
	/** Gets the number of elements in the set */
	get size(): number;
	/** Returns whether the set is empty */
	get isEmpty(): boolean;
	/**
	 * Inserts an item into the set if it's not already present
	 *
	 * @param item - The item to insert
	 * @returns True if the item was added; false if an equal item already exists
	 */
	insert(item: T): boolean;
	/**
	 * Removes an item from the set
	 *
	 * @param item - The item to remove
	 * @returns True if the item was removed; false if it wasn't found
	 */
	remove(item: T): boolean;
	/**
	 * Checks if an item exists in the set
	 *
	 * @param item - The item to check
	 * @returns True if the item exists; false otherwise
	 */
	has(item: T): boolean;
	/** Returns all items in the set as an array, in sorted order */
	toArray(): T[];
	/** Returns the index of an item in the set, or -1 if not found */
	findIndex(item: T): number;
	/**
	 * Returns the element at the specified index in the sorted order
	 *
	 * @param index - The zero-based index of the element to get
	 * @returns The element at the specified index, or undefined if the index is out of range
	 */
	at(index: number): T | undefined;
	/** Iterates through each item in the sorted set */
	forEach(callback: (item: T, index: number, set: SortedSet<T>) => void): void;
	/** Returns an iterator for the set's items */
	[Symbol.iterator](): Iterator<T>;
	/** Clears all items from the set */
	clear(): void;
	/**
	 * Uses binary search to find the position where an item should be inserted to maintain the sorted
	 * order
	 */
	private findInsertionIndex;
}
/** Simple collection for UnsubscriberAsync objects that also provides an easy way to run them. */
export declare class UnsubscriberAsyncList {
	private name;
	readonly unsubscribers: Set<Unsubscriber | UnsubscriberAsync>;
	constructor(name?: string);
	/**
	 * Add unsubscribers to the list. Note that duplicates are not added twice.
	 *
	 * @param unsubscribers - Objects that were returned from a registration process.
	 */
	add(...unsubscribers: (UnsubscriberAsync | Unsubscriber | Dispose)[]): void;
	/**
	 * Run all unsubscribers added to this list and then clear the list.
	 *
	 * @returns `true` if all unsubscribers succeeded, `false` otherwise.
	 */
	runAllUnsubscribers(): Promise<boolean>;
}
/** The version of the PlatformError type */
export declare const PLATFORM_ERROR_VERSION = 1;
/**
 * PlatformError is an error type with stronger typing of properties than `Error`. It is used to
 * represent errors that are returned by the platform.
 *
 * You can create a new PlatformError object using {@link newPlatformError}. You can check if a value
 * is a PlatformError object using {@link isPlatformError}.
 */
export type PlatformError = {
	/**
	 * The underlying cause of the error, if any. Normally this will be copied from an `Error object
	 * passed to {@link newPlatformError}. If a non-Error object is passed to {@link newPlatformError},
	 * it will be stored here.
	 */
	cause?: unknown;
	/**
	 * A descriptive message explaining the error. Normally this will be copied from an `Error` object
	 * passed to {@link newPlatformError}. If a string is passed to {@link newPlatformError}, it will be
	 * stored here.
	 */
	message: string;
	/** The version of the PlatformError type. */
	platformErrorVersion: number;
	/**
	 * The stack trace of the error, if available. Normally this will be copied from an `Error` object
	 * passed to {@link newPlatformError}.
	 */
	stack?: string;
};
/**
 * Creates a new PlatformError object. If no argument is provided, a PlatformError object with an
 * empty `message` is returned.
 *
 * @param error The error message as a string, an Error object, or a value to assign to the `cause`
 *   property of the returned PlatformError object
 * @returns A new PlatformError object
 */
export declare function newPlatformError(error?: unknown): PlatformError;
/**
 * Checks if the provided value is a PlatformError object.
 *
 * @param error The value to check
 * @returns `true` if the value is a PlatformError object, otherwise `false`
 */
export declare function isPlatformError(error: unknown): error is PlatformError;
/**
 * Represents a book, with its short name (e.g. "Gen") and full names (e.g. "Genesis"), and number
 * of chapters.
 */
export interface BookInfo {
	shortName: string;
	fullNames: string[];
	chapters: number;
}
/**
 * Represents a "node" in the JSON used to present Scripture in the editor, with a path that is
 * relative to the start of a verse.
 */
export type ScriptureNode = SerializedVerseRef & {
	jsonPath: string;
};
/** Represents a specific character offset in the text of a textual Scripture node (in the editor.) */
export type ScriptureTextAnchor = ScriptureNode & {
	offset: number;
};
/**
 * Represents a range of text in the Scripture editor. The start and end node are expected to be in
 * the same book.
 */
export type ScriptureSelection = {
	start: ScriptureNode | ScriptureTextAnchor;
	end?: ScriptureNode | ScriptureTextAnchor;
};
/**
 * An identifier corresponding to a Scripture reference shared by a group of Scripture reference
 * consumers.
 *
 * For example, a few web views that share a Scroll Group Id would all change Scripture Reference
 * together.
 *
 * These are generally expected to be non-negative numbers (starting at 0).
 */
export type ScrollGroupId = number;
/** Collection of functions, objects, and types that are used as helpers in other services. */
export declare function newGuid(): string;
/**
 * Determine whether the object is a string
 *
 * @param o Object to determine if it is a string
 * @returns True if the object is a string; false otherwise
 */
export declare function isString(o: unknown): o is string;
/**
 * If deepClone isn't used when copying properties between objects, you may be left with dangling
 * references between the source and target of property copying operations.
 *
 * @param obj Object to clone
 * @returns Duplicate copy of `obj` without any references back to the original one
 */
export declare function deepClone<T>(obj: T): T;
/**
 * Get a function that reduces calls to the function passed in
 *
 * @template T - A function type that takes any arguments and returns void. This is the type of the
 *   function being debounced.
 * @param fn The function to debounce
 * @param delay How much delay in milliseconds after the most recent call to the debounced function
 *   to call the function
 * @returns Function that, when called, only calls the function passed in at maximum every delay ms
 */
export declare function debounce<TFunc extends (...args: any[]) => any>(fn: TFunc, delay?: number): (...args: Parameters<TFunc>) => Promise<ReturnType<TFunc>>;
/**
 * Groups each item in the array of items into a map according to the keySelector
 *
 * There are two overloads:
 *
 * - `groupBy(items, keySelector)` – groups the original items using the key returned by
 *   `keySelector`.
 * - `groupBy(items, keySelector, valueSelector)` – groups transformed values using the key returned
 *   by `keySelector` and the value returned by `valueSelector`.
 *
 * If `valueSelector` is not provided, the original item is used in the resulting groups.
 *
 * @param items - Array of items to group by.
 * @param keySelector - Function to run on each item to get the key for the group to which it
 *   belongs
 * @returns Map of keys to groups of values corresponding to each item.
 */
export declare function groupBy<T, K>(items: T[], keySelector: (item: T) => K): Map<K, Array<T>>;
export declare function groupBy<T, K, V>(items: T[], keySelector: (item: T) => K, valueSelector: (item: T, key: K) => V): Map<K, Array<V>>;
/**
 * Function to get an error message from the object (useful for getting error message in a catch
 * block)
 *
 * @example `try {...} catch (e) { logger.info(getErrorMessage(e)) }`
 *
 * @param error Error object whose message to get
 * @returns Message of the error - if object has message, returns message. Otherwise tries to
 *   stringify
 */
export declare function getErrorMessage(error: unknown): string;
/** Asynchronously waits for the specified number of milliseconds. (wraps setTimeout in a promise) */
export declare function wait(ms: number): Promise<void>;
/**
 * Runs the specified function and will timeout if it takes longer than the specified wait time
 *
 * @param fn The function to run
 * @param maxWaitTimeInMS The maximum amount of time to wait for the function to resolve
 * @returns Promise that resolves to the resolved value of the function or undefined if it ran
 *   longer than the specified wait time
 */
export declare function waitForDuration<TResult>(fn: () => Promise<TResult>, maxWaitTimeInMS: number): Promise<Awaited<TResult> | undefined>;
/**
 * Get all functions on an object and its prototype chain (so we don't miss any class methods or any
 * object methods). Note that the functions on the final item in the prototype chain (i.e., Object)
 * are skipped to avoid including functions like `__defineGetter__`, `__defineSetter__`, `toString`,
 * etc.
 *
 * @param obj Object whose functions to get
 * @param _objId Optional ID of the object to use for debug logging
 * @returns Array of all function names on an object
 */
export declare function getAllObjectFunctionNames(obj: {
	[property: string]: unknown;
}, _objId?: string): Set<string>;
/**
 * Creates a synchronous proxy for an asynchronous object. The proxy allows calling methods on an
 * object that is asynchronously fetched using a provided asynchronous function.
 *
 * @param getObject - A function that returns a promise resolving to the object whose asynchronous
 *   methods to call.
 * @param objectToProxy - An optional object that is the object that is proxied. If a property is
 *   accessed that does exist on this object, it will be returned. If a property is accessed that
 *   does not exist on this object, it will be considered to be an asynchronous method called on the
 *   object returned from getObject.
 * @returns A synchronous proxy for the asynchronous object.
 */
export declare function createSyncProxyForAsyncObject<T extends object>(getObject: (args?: unknown[]) => Promise<T>, objectToProxy?: Partial<T>): T;
/**
 * Indicates if the exception or error message provided appears to be from ParatextData.dll
 * indicating that Paratext is blocking internet access.
 *
 * @param errorMessage Error message or exception to check
 * @returns `true` if the message indicates Paratext is blocking internet access, `false` otherwise
 */
export declare function isErrorMessageAboutParatextBlockingInternetAccess(errorMessage: unknown): boolean;
/**
 * Indicates if the exception or error message provided appears to be from ParatextData.dll
 * indicating that an authorization failure occurred regarding registry credentials.
 *
 * @param errorMessage Error message or exception to check
 * @returns `true` if the message indicates an auth failure, `false` otherwise
 */
export declare function isErrorMessageAboutRegistryAuthFailure(errorMessage: unknown): boolean;
/** Within type T, recursively change all properties to be optional */
export type DeepPartial<T> = T extends object ? {
	[P in keyof T]?: DeepPartial<T[P]>;
} : T;
/** Within type T, recursively change properties that were of type A to be of type B */
export type ReplaceType<T, A, B> = T extends A ? B : T extends object ? {
	[K in keyof T]: ReplaceType<T[K], A, B>;
} : T;
/**
 * Converts a string type from camelCase to kebab-case. Note this simply inserts hyphens before
 * uppercase letters and converts them to lowercase. It does not handle special cases like acronyms
 * or symbols. It can result in multiple hyphens in a row, leading hyphens, or trailing hyphens.
 *
 * By using this as the type for a string parameter or string property, you can enforce (somewhat)
 * at compile time that the string is in kebab-case format assuming it is provided as a string
 * literal.
 *
 * @example
 *
 * ```typescript
 * type Kebab1 = KebabCase<'backgroundColor'>; // 'background-color'
 * type Kebab2 = KebabCase<'HTMLParser'>; // '-h-t-m-l-parser'
 * type Kebab3 = KebabCase<'simpletest'>; // 'simpletest'
 * type Kebab4 = KebabCase<'My$Value'>; // '-my$-value'
 * ```
 */
export type KebabCase<T extends string> = T extends `${infer First}${infer Rest}` ? `${First extends Lowercase<First> ? First : `-${Lowercase<First>}`}${KebabCase<Rest>}` : T;
/**
 * Converts a union type to an intersection type (`|` to `&`).
 *
 * Note: this utility type is for use on object types. It may fail on other types.
 *
 * @example
 *
 * ```typescript
 * type TypeOne = { one: string };
 * type TypeTwo = { two: number };
 * type TypeThree = { three: string };
 *
 * type TypeNums = { one: TypeOne; two: TypeTwo; three: TypeThree };
 * const numNames = ['one', 'two'] as const;
 * type TypeNumNames = typeof numNames;
 *
 * // Same as `TypeOne | TypeTwo`
 * // `{ one: string } | { two: number }`
 * type TypeOneTwoUnion = TypeNums[TypeNumNames[number]];
 *
 * // Same as `TypeOne & TypeTwo`
 * // `{ one: string; two: number }`
 * type TypeOneTwoIntersection = UnionToIntersection<TypeOneTwoUnion>;
 * ```
 */
export type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;
/** Identifier for a string that will be localized in a menu based on the user's UI language */
export type LocalizeKey = `%${string}%`;
/** Name of some UI element (i.e., tab, column, group, menu item) or some PAPI object (i.e., command) */
export type ReferencedItem = `${string}.${string}`;
export type OrderedItem = {
	/** Relative order of this item compared to other items in the same parent/scope (sorted ascending) */
	order: number;
};
export type OrderedExtensibleContainer = OrderedItem & {
	/** Determines whether other items can be added to this after it has been defined */
	isExtensible?: boolean;
};
/** Group of menu items that belongs in a column */
export type MenuGroupDetailsInColumn = OrderedExtensibleContainer & {
	/** ID of column in which this group resides */
	column: ReferencedItem;
};
/** Group of menu items that belongs in a submenu */
export type MenuGroupDetailsInSubMenu = OrderedExtensibleContainer & {
	/** ID of menu item hosting the submenu in which this group resides */
	menuItem: ReferencedItem;
};
/** Column that includes header text in a menu */
export type MenuColumnWithHeader = OrderedExtensibleContainer & {
	/** Key that represents the text of the header text of the column */
	label: LocalizeKey;
};
export type MenuItemBase = OrderedItem & {
	/** Menu group to which this menu item belongs */
	group: ReferencedItem;
	/** Key that represents the text of this menu item to display */
	label: LocalizeKey;
	/** Key that represents words the platform should reference when users are searching for menu items */
	searchTerms?: LocalizeKey;
	/** Key that represents the text to display if a mouse pointer hovers over the menu item */
	tooltip?: LocalizeKey;
	/** Additional information provided by developers to help people who perform localization */
	localizeNotes: string;
};
/** Menu item that hosts a submenu */
export type MenuItemContainingSubmenu = MenuItemBase & {
	/** ID for this menu item that holds a submenu */
	id: ReferencedItem;
};
/** Menu item that runs a command */
export type MenuItemContainingCommand = MenuItemBase & {
	/** Name of the PAPI command to run when this menu item is selected. */
	command: ReferencedItem;
	/**
	 * Uri path to the icon to display after the menu text. Ex:
	 * `papi-extension://helloWorld/assets/icon.png`
	 */
	iconPathAfter?: string;
	/**
	 * Uri path to the icon to display before the menu text. Ex:
	 * `papi-extension://helloWorld/assets/icon.png`
	 */
	iconPathBefore?: string;
};
/**
 * Group of menu items that can be combined with other groups to form a single context menu/submenu.
 * Groups are separated using a line within the menu/submenu.
 */
export type GroupsInSingleColumnMenu = {
	/** Named menu group */
	[property: ReferencedItem]: OrderedExtensibleContainer | MenuGroupDetailsInSubMenu;
};
/**
 * Group of menu items that can be combined with other groups to form a single menu/submenu within a
 * multi-column menu. Groups are separated using a line within the menu/submenu.
 */
export type GroupsInMultiColumnMenu = {
	/** Named menu group */
	[property: ReferencedItem]: MenuGroupDetailsInColumn | MenuGroupDetailsInSubMenu;
};
/** Group of columns that can be combined with other columns to form a multi-column menu */
export type ColumnsWithHeaders = {
	/** Named column of a menu */
	[property: ReferencedItem]: MenuColumnWithHeader;
	/** Defines whether columns can be added to this multi-column menu */
	isExtensible?: boolean;
};
/** Menu that contains a column without a header */
export type SingleColumnMenu = {
	/** Groups that belong in this menu */
	groups: GroupsInSingleColumnMenu;
	/** List of menu items that belong in this menu */
	items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];
};
/** Menu that contains multiple columns with headers */
export type MultiColumnMenu = {
	/** Columns that belong in this menu */
	columns: ColumnsWithHeaders;
	/** Groups that belong in this menu */
	groups: GroupsInMultiColumnMenu;
	/** List of menu items that belong in this menu */
	items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];
};
/** Menus for one single web view */
export type WebViewMenu = {
	/** Indicates whether the platform default menus should be included for this webview */
	includeDefaults: boolean | undefined;
	/** Menu that opens when you click on the top left corner of a tab */
	topMenu: MultiColumnMenu | undefined;
	/** Menu that opens when you right click on the main body/area of a tab */
	contextMenu: SingleColumnMenu | undefined;
};
/** Menus for all web views */
export type WebViewMenus = {
	/** Named web view */
	[property: ReferencedItem]: WebViewMenu;
};
/** Platform.Bible menus before they are localized */
export type PlatformMenus = {
	/** Top level menu for the application */
	mainMenu: MultiColumnMenu;
	/** Menus that apply per web view in the application */
	webViewMenus: WebViewMenus;
	/** Default context menu for web views that don't specify their own */
	defaultWebViewContextMenu: SingleColumnMenu;
	/** Default top menu for web views that don't specify their own */
	defaultWebViewTopMenu: MultiColumnMenu;
};
/**
 * Type that converts any menu type before it is localized to what it is after it is localized. This
 * can be applied to any menu type as needed.
 */
export type Localized<T> = ReplaceType<ReplaceType<T, LocalizeKey, string>, ReferencedItem, string>;
/** JSON schema object that aligns with the PlatformMenus type */
export declare const menuDocumentSchema: {
	title: string;
	type: string;
	properties: {
		mainMenu: {
			description: string;
			$ref: string;
		};
		defaultWebViewTopMenu: {
			description: string;
			$ref: string;
		};
		defaultWebViewContextMenu: {
			description: string;
			$ref: string;
		};
		webViewMenus: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
	};
	required: string[];
	additionalProperties: boolean;
	$defs: {
		localizeKey: {
			description: string;
			type: string;
			pattern: string;
		};
		referencedItem: {
			description: string;
			type: string;
			pattern: string;
		};
		columnsWithHeaders: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					description: string;
					type: string;
					properties: {
						label: {
							description: string;
							$ref: string;
						};
						localizeNotes: {
							description: string;
							type: string;
						};
						order: {
							description: string;
							type: string;
						};
						isExtensible: {
							description: string;
							type: string;
						};
					};
					required: string[];
					additionalProperties: boolean;
				};
			};
			properties: {
				isExtensible: {
					description: string;
					type: string;
				};
			};
		};
		menuGroups: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					description: string;
					type: string;
					oneOf: ({
						properties: {
							column: {
								description: string;
								$ref: string;
							};
							order: {
								description: string;
								type: string;
							};
							isExtensible: {
								description: string;
								type: string;
							};
							menuItem?: undefined;
						};
						required: string[];
						additionalProperties: boolean;
					} | {
						properties: {
							menuItem: {
								description: string;
								$ref: string;
							};
							order: {
								description: string;
								type: string;
							};
							isExtensible: {
								description: string;
								type: string;
							};
							column?: undefined;
						};
						required: string[];
						additionalProperties: boolean;
					})[];
				};
			};
			additionalProperties: boolean;
		};
		menuItem: {
			description: string;
			type: string;
			oneOf: ({
				properties: {
					id: {
						description: string;
						$ref: string;
					};
					command?: undefined;
					iconPathBefore?: undefined;
					iconPathAfter?: undefined;
				};
				required: string[];
			} | {
				properties: {
					command: {
						description: string;
						$ref: string;
					};
					iconPathBefore: {
						description: string;
						type: string;
					};
					iconPathAfter: {
						description: string;
						type: string;
					};
					id?: undefined;
				};
				required: string[];
			})[];
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				tooltip: {
					description: string;
					$ref: string;
				};
				searchTerms: {
					description: string;
					$ref: string;
				};
				localizeNotes: {
					description: string;
					type: string;
				};
				group: {
					description: string;
					$ref: string;
				};
				order: {
					description: string;
					type: string;
				};
			};
			required: string[];
			unevaluatedProperties: boolean;
		};
		groupsAndItems: {
			description: string;
			type: string;
			properties: {
				groups: {
					description: string;
					$ref: string;
				};
				items: {
					description: string;
					type: string;
					items: {
						$ref: string;
					};
					uniqueItems: boolean;
				};
			};
			required: string[];
		};
		singleColumnMenu: {
			description: string;
			type: string;
			allOf: {
				$ref: string;
			}[];
			unevaluatedProperties: boolean;
		};
		multiColumnMenu: {
			description: string;
			type: string;
			allOf: ({
				$ref: string;
				properties?: undefined;
				required?: undefined;
			} | {
				properties: {
					columns: {
						description: string;
						$ref: string;
					};
				};
				required: string[];
				$ref?: undefined;
			})[];
			unevaluatedProperties: boolean;
		};
		menusForOneWebView: {
			description: string;
			type: string;
			properties: {
				includeDefaults: {
					description: string;
					type: string;
				};
				topMenu: {
					description: string;
					$ref: string;
				};
				contextMenu: {
					description: string;
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
	};
};
/** The first book number */
export declare const FIRST_SCR_BOOK_NUM = 1;
/** The last book number */
export declare const LAST_SCR_BOOK_NUM: number;
/** The first chapter number */
export declare const FIRST_SCR_CHAPTER_NUM = 1;
/** The first verse number */
export declare const FIRST_SCR_VERSE_NUM = 1;
/** The default Scripture reference, representing the first chapter and verse of the first book. */
export declare const defaultScrRef: SerializedVerseRef;
/**
 * Retrieves the number of chapters for a given book number.
 *
 * @param bookNum The number representing the book.
 * @returns The number of chapters in the book, or -1 if the book number is invalid.
 */
export declare const getChaptersForBook: (bookNum: number) => number;
/**
 * Adjusts the book of a Scripture reference by a specified offset.
 *
 * @param scrRef The Scripture reference whose book is to be adjusted.
 * @param offset The number of books to offset the current book by. Positive values move forward,
 *   negative values move backward.
 * @returns A new Scripture reference with the adjusted book. The chapter and verse numbers are
 *   reset to 1. If the resulting book number exceeds the bounds of available books, it is clamped
 *   to the nearest valid book.
 */
export declare const offsetBook: (scrRef: SerializedVerseRef, offset: number) => SerializedVerseRef;
/**
 * Adjusts the chapter of a Scripture reference by a specified offset.
 *
 * @param scrRef The Scripture reference whose chapter is to be adjusted.
 * @param offset The number of chapters to offset the current chapter by. Positive values move
 *   forward, negative values move backward.
 * @returns A new Scripture reference with the adjusted chapter. The verse number is reset to 1. The
 *   chapter number is clamped to stay within valid bounds for the book.
 */
export declare const offsetChapter: (scrRef: SerializedVerseRef, offset: number) => SerializedVerseRef;
/**
 * Adjusts the verse of a Scripture reference by a specified offset.
 *
 * @param scrRef The Scripture reference whose verse is to be adjusted.
 * @param offset The number of verses to offset the current verse by. Positive values move forward,
 *   negative values move backward.
 * @returns A new Scripture reference with the adjusted verse. The verse number is clamped to stay
 *   within valid bounds for the chapter.
 */
export declare const offsetVerse: (scrRef: SerializedVerseRef, offset: number) => SerializedVerseRef;
/**
 * https://github.com/ubsicap/Paratext/blob/master/ParatextData/SILScriptureExtensions.cs#L72
 *
 * Convert book number to a localized Id (a short description of the book). This should be used
 * whenever a book ID (short code) is shown to the user. It is primarily needed for people who do
 * not read Roman script well and need to have books identified in a alternate script (e.g. Chinese
 * or Russian)
 *
 * @param bookNumber
 * @param localizationLanguage In BCP 47 format
 * @param getLocalizedString Function that provides the localized versions of the book ids and names
 *   asynchronously.
 * @returns
 */
export declare function getLocalizedIdFromBookNumber(bookNumber: number, localizationLanguage: string, getLocalizedString: (item: {
	localizeKey: string;
	languagesToSearch?: string[];
}) => Promise<string>): Promise<string>;
/**
 * Get the Scripture reference as an easily comparable/sortable integer, without considering the
 * verse.
 *
 * @param scrRef The Scripture reference.
 * @returns An integer where the first three digits represent the book, the next three represent the
 *   chapter and the last three represent the verse.
 */
export declare function scrRefToBBBCCC(scrRef: SerializedVerseRef): number;
/**
 * Get the Scripture reference as an easily comparable/sortable integer.
 *
 * @param scrRef The Scripture reference.
 * @returns An integer where the first three digits represent the book, the next three represent the
 *   chapter and the last three represent the verse.
 */
export declare function scrRefToBBBCCCVVV(scrRef: SerializedVerseRef): number;
/**
 * Compares two Scripture references canonically.
 *
 * @param scrRef1 The first Scripture reference to compare.
 * @param scrRef2 The second Scripture reference to compare.
 * @returns A number indicating the result of the comparison: - Negative value if scrRef1 precedes
 *   scrRef2 in sorting order. - Zero if scrRef1 and scrRef2 are equivalent in sorting order. -
 *   Positive value if scrRef1 follows scrRef2 in sorting order.
 */
export declare function compareScrRefs(scrRef1: SerializedVerseRef, scrRef2: SerializedVerseRef): number;
/** Get the localized string key for a given scroll group Id (or no scroll group if `undefined`) */
export declare function getLocalizeKeyForScrollGroupId(scrollGroupId: ScrollGroupId | undefined | "undefined"): LocalizeKey;
/**
 * Gets a list of localized string keys for provided scroll group Ids. Uses
 * {@link getLocalizeKeyForScrollGroupId} internally
 *
 * @example
 *
 * ```typescript
 * getLocalizeKeysForScrollGroupIds([undefined, 0, 1, 2, 3, 4]);
 * // Gives localized string keys for the provided scroll group ids in an array
 * ```
 *
 * @param scrollGroupIds Scroll group ids to include
 * @returns List of localized string keys for scroll group Ids
 */
export declare function getLocalizeKeysForScrollGroupIds(scrollGroupIds: (ScrollGroupId | undefined)[]): `%${string}%`[];
/**
 * Formats a Scripture reference.
 *
 * @param scrRef The Scripture reference to format.
 * @param optionOrLocalizedBookName Either 'id' (the default) to format using the "standard" (as
 *   defined by SIL/UBS) 3-letter book ID, 'English' to format using the English book name spelled
 *   out, or some other string (e.g., a localized book name, vernacular abbreviation, FCBH book id,
 *   etc.) to use.
 * @param chapterVerseSeparator The character used to separate the chapter number from the verse
 *   number. Default is a colon (:). Note: More than one character is allowed.
 * @param bookChapterSeparator The character used to separate the book from the chapter number.
 *   Default is a single space. Note: More than one character is allowed.
 * @returns The formatted reference.
 */
export declare function formatScrRef(scrRef: SerializedVerseRef, optionOrLocalizedBookName?: "id" | "English" | string, chapterVerseSeparator?: string, bookChapterSeparator?: string): string;
/**
 * Represents the major sections of the Bible and extra materials. Used for grouping and filtering
 * books in the book selector.
 */
export declare enum Section {
	/** Old Testament books (Genesis through Malachi) */
	OT = "OT",
	/** New Testament books (Matthew through Revelation) */
	NT = "NT",
	/** Deuterocanonical books (e.g. Tobit, Judith, 1-2 Maccabees) */
	DC = "DC",
	/** Additional materials not part of the biblical canon (e.g. XXA, XXB etc.) */
	Extra = "Extra"
}
/**
 * Determines which section a book belongs to based on its ID
 *
 * @param bookId The ID of the book (e.g., 'GEN', 'MAT')
 * @returns The section (OT, NT, DC, or Extra) that the book belongs to
 * @throws Error if the book ID is not recognized or cannot be categorized
 */
export declare const getSectionForBook: (bookId: string) => Section;
/**
 * Converts all control characters, carriage returns, and tabs into spaces and then strips duplicate
 * spaces.
 *
 * This is mainly intended for use with individual Scripture strings in USFM, USX, USJ, etc. format.
 * It is not intended to implement the [USFM white space definition or reduction
 * rules](https://docs.usfm.bible/usfm/3.1/whitespace.html) but strictly follows Paratext 9's white
 * space rules. It is generally best suited to normalizing spaces within a Scripture marker as it
 * removes all newlines.
 *
 * This function is a direct translation of `UsfmToken.RegularizeSpaces` from `ParatextData.dll`
 */
export declare function normalizeScriptureSpaces(str: string): string;
/**
 * Determines if the USJ documents or markers (and all contents) are equivalent after regularizing
 * spaces according to the way `ParatextData.dll` does.
 *
 * Note that this will not work properly if there ever exist any properties of USJ document or USJ
 * markers other than `content` that are complex objects like arrays or objects as the properties
 * are shallow equaled.
 */
export declare function areUsjContentsEqualExceptWhitespace(a: Usj | undefined, b: Usj | undefined): boolean;
/**
 * Information about a USFM marker that is just an attribute in USX/USJ. See {@link MarkerInfo} for
 * other kinds of markers.
 *
 * An attribute marker is a marker that adds information to a previous marker in USFM and is an
 * attribute on that previous marker instead in USX/USJ.
 *
 * For example, `ca` and `cp` are attribute markers for `c`. `va` and `vp` are attribute markers for
 * `v`. `cat` is an attribute marker for `f`, `esb`, and more.
 *
 * Following is an example of using the `ca` and `cp` attribute markers in USFM:
 *
 * ```usfm
 * \c 1 \ca 2\ca*
 * \cp A
 * \s1 This is a section header
 * ```
 *
 * The equivalent in USX would be:
 *
 * ```xml
 * <!-- prettier-ignore -->
 * <chapter number="1" style="c" altnumber="2" pubnumber="A" sid="GEN 1" />
 * <para style="s1">This is a section header</para>
 * ```
 */
export type AttributeMarkerInfo = NormalMarkerInfo & {
	/**
	 * List of normal marker names for which this marker is an attribute marker.
	 *
	 * For example, `ca` and `cp` are attribute markers for `c`. `isAttributeMarkerFor` would be
	 * `['c']` for both `ca` and `cp`.
	 */
	isAttributeMarkerFor?: string[];
	/**
	 * List of RegExp patterns matching marker names for which this marker is an attribute marker.
	 *
	 * For example, pretend `ex1` and `ex2` are attribute markers for markers matching RegExp
	 * `/test/`. `isAttributeMarkerForRegExp` would be `['test']` for both `ex1` and `ex2`.
	 */
	isAttributeMarkerForRegExp?: string[];
	/**
	 * The name of the USX/USJ attribute this attribute marker represents.
	 *
	 * For example, `ca` is an attribute marker for `c` and represents the `altnumber` attribute on
	 * the `c` marker in USX/USJ. `attributeMarkerAttributeName` would be `altnumber` for the `ca`
	 * marker.
	 */
	attributeMarkerAttributeName: string;
	/**
	 * Whether there should be a structural space after the closing marker in output USFM if this
	 * marker is an attribute marker. If this marker is not an attribute marker, it should not have a
	 * structural space after the closing marker.
	 *
	 * This field should be ignored if {@link MarkersMap.isSpaceAfterAttributeMarkersContent} is `true`
	 * because this space is only supposed to be added in contexts in which the space here is
	 * structural. Otherwise we would be mistakenly adding content to the USFM.
	 *
	 * Note that, if {@link MarkersMap.isSpaceAfterAttributeMarkersContent} is `true` (which is the
	 * case according to spec), horizontal spaces after attribute markers are always considered
	 * structural. This property only indicates whether there should be a space after the attribute
	 * marker when outputting USFM.
	 *
	 * For example, according to specification, the `va` and `vp` attribute markers have a space after
	 * their closing markers:
	 *
	 * ```usfm
	 * \p \v 10 \va 10 va\va* \vp 10 vp\vp* Some verse text
	 * ```
	 *
	 * The verse text in this example is just "Some verse text" without a space at the start.
	 *
	 * However, when the `vp` marker is not an attribute marker, such as when it has markers in its
	 * contents, there should not be a structural space after the closing marker, and any space should
	 * be considered content:
	 *
	 * ```usfm
	 * \p \v 10 \va 10 va\va* \vp \+wj 10 vp\+wj*\vp* Some verse text.
	 * ```
	 *
	 * The verse text in this example is " Some verse text" including a space at the start.
	 *
	 * The `cat` attribute marker does not have a structural space after its closing marker:
	 *
	 * ```usfm
	 * \f + \cat category here\cat*\fr 1:2 \ft Some footnote text\f*
	 * ```
	 *
	 * The verse text in this example is just "Some verse text" without a space at the start.
	 *
	 * If not present, defaults to `false`.
	 */
	hasStructuralSpaceAfterCloseAttributeMarker?: boolean;
};
/**
 * Information about a regular USFM/USX/USJ marker. See {@link MarkerInfo} for other kinds of
 * markers.
 */
export type NormalMarkerInfo = {
	/**
	 * Which marker type the marker is. Determines how the marker is structured in the data such as
	 * what kind of mandatory whitespace is around the marker in USFM. See {@link MarkerTypeInfoBase}
	 * for information.
	 */
	type: string;
	/** Explanation of the meaning of this marker */
	description?: string;
	/**
	 * Which attribute can be provided without specifying the attribute name in USFM.
	 *
	 * A marker can have a default attribute only if it has zero or one non-optional attributes.
	 *
	 * An attribute can be provided with default syntax in the USFM only if it is the only attribute
	 * provided for the marker.
	 *
	 * Following is an example of a marker with a default attribute:
	 *
	 * ```usfm
	 * \w stuff|thisIsTheLemmaDefaultAttribute\w*
	 * ```
	 *
	 * Following is an example of a marker with multiple attributes (cannot use default attribute
	 * syntax):
	 *
	 * ```usfm
	 * \w stuff|lemma="thisIsTheLemma" strong="H1234,G1234"\w*
	 * ```
	 */
	defaultAttribute?: string;
	/**
	 * The name of the text content attribute that is present on this marker if this marker has text
	 * content in USFM.
	 *
	 * Text content attributes are attributes in USX/USJ that are represented in USFM as the actual
	 * text content of the marker.
	 *
	 * For example, `alt` is a text content attribute on the `periph` marker. This value would be
	 * `alt` for the `periph` marker.
	 *
	 * Following is an example of a `periph` marker in USFM:
	 *
	 * ```usfm
	 * \periph Example Peripheral|id="x-example"
	 * \p Some contents of the example peripheral
	 * ```
	 *
	 * The equivalent in USX would be:
	 *
	 * ```xml
	 * <!-- prettier-ignore -->
	 * <periph alt="Example Peripheral" id="x-example">
	 *   <para style="p">Some contents of the example peripheral</para>
	 * </periph>
	 * ```
	 */
	textContentAttribute?: string;
	/**
	 * List of leading attributes that must be present on this marker. This list is ordered by the
	 * order in which the attributes should appear.
	 *
	 * Leading attributes are attributes in USJ/USX that are listed in USFM directly after the marker
	 * and separated only by a space.
	 *
	 * For example, `code` is a leading attribute on the `id` marker. This value would be `['code']`
	 * for the `id` marker.
	 *
	 * Following is an example of an `id` marker in USFM:
	 *
	 * ```usfm
	 * \id MAT 41MATEX.SFM, Example Translation, September 2025
	 * ```
	 *
	 * The equivalent in USX would be:
	 *
	 * ```xml
	 * <!-- prettier-ignore -->
	 * <book code="MAT" style="id">41MATEX.SFM, Example Translation, September 2025</book>
	 * ```
	 */
	leadingAttributes?: string[];
	/**
	 * List of attribute markers that may be present on this marker. This list is ordered by the order
	 * in which the markers should appear.
	 *
	 * An attribute marker is a marker that adds information to a previous marker in USFM and is an
	 * attribute on that previous marker in USX/USJ.
	 *
	 * For example, `ca` and `cp` are attribute markers for `c`. This value would be `['ca', 'cp']`
	 * for `c`.
	 *
	 * Note: the attribute names for attribute markers may be different than the marker names. See
	 * {@link AttributeMarkerInfo.attributeMarkerAttributeName} for more information.
	 */
	attributeMarkers?: string[];
	/**
	 * Whether the closing marker for this marker is considered optional in USFM. This should always
	 * be not present or `false` if there is no closing marker for the marker type of this marker.
	 *
	 * If this is `false` and a closing marker for this marker in USFM is _not_ present, the USX/USJ
	 * for this marker should have the attribute `closed` set to `false`.
	 *
	 * If this is `true`, the `closed` attribute should be present if the presence of a closing marker
	 * for this marker in USFM does not match the assumption implied by
	 * {@link MarkersMap.shouldOptionalClosingMarkersBePresent}.
	 *
	 * If not present, defaults to `false`
	 */
	isClosingMarkerOptional?: boolean;
	/**
	 * List of independent closing marker names for this marker in USFM if it has any. If this is
	 * defined, this marker does not have a normal closing marker but rather is closed by a completely
	 * separate marker in USFM. All contents between this marker and the independent closing marker
	 * are contents of this marker. In USX and USJ, this marker is closed normally like any other
	 * object because USX and USJ have clear hierarchical structure.
	 *
	 * For example, `esb` (a sidebar) is closed by the independent closing marker `esbe`.
	 * `independentClosingMarkers` would be `['esbe']` for `esb`. Following is an example of a
	 * sidebar:
	 *
	 * ```usfm
	 * \esb
	 * \p This paragraph is in a \bd sidebar\bd*.
	 * \p The sidebar can contain multiple paragraphs.
	 * \esbe
	 * ```
	 *
	 * Note that the independent closing marker does not have a `*` at the end because it is not a
	 * closing marker for `esb` but rather a completely separate marker that closes the `esb` marker.
	 *
	 * When outputting to USFM, the first independent closing marker listed in this array should be
	 * used.
	 */
	independentClosingMarkers?: string[];
	/**
	 * List of marker names for which this marker is an independent closing marker. See
	 * {@link NormalMarkerInfo.independentClosingMarker} for more information on independent closing
	 * markers and their syntax.
	 *
	 * For example, `esbe` is an independent closing marker for `esb`. `isIndependentClosingMarkerFor`
	 * would be `['esb']` for `esbe`.
	 */
	isIndependentClosingMarkerFor?: string[];
	/**
	 * List of RegExp patterns matching marker names for which this marker is an independent closing
	 * marker. See {@link NormalMarkerInfo.independentClosingMarker} for more information on
	 * independent closing markers and their syntax.
	 *
	 * For example, pretend `ex1` and `ex2` are independent closing markers for markers matching
	 * RegExp `/test/`. `isIndependentClosingMarkerForRegExp` would be `['test']` for both `ex1` and
	 * `ex2`.
	 */
	isIndependentClosingMarkerForRegExp?: string[];
	/**
	 * Marker to use when operating on the USFM representation of this marker. For example, when
	 * outputting to USFM, the marker info for the marker listed here in `markerUsfm` should be used
	 * instead of the marker info for the marker as listed in USX or USJ.
	 */
	markerUsfm?: string;
	/**
	 * Instructions regarding special handling required for this marker when transforming from USFM to
	 * USX or USJ. These instructions are an explanation of what needs to be done to this marker to
	 * properly transform it to USX or USJ.
	 *
	 * This property is generally only included when it is exceptionally difficult to parse a marker
	 * properly from USFM; the markers map attempts to use this property as little as possible,
	 * favoring encoding information in other properties for more automatic transformation instead.
	 */
	parseUsfmInstructions?: string;
};
/** Information about a USFM/USX/USJ marker that is essential for proper translation between formats */
export type MarkerInfo = NormalMarkerInfo | AttributeMarkerInfo;
/**
 * Information about a USFM/USX/USJ marker type that does not have a closing marker. See
 * {@link MarkerInfo} for other kinds of marker types.
 *
 * For example, `char` marker types such as `nd` markers have closing markers, but `para` markers
 * such as `p` do not:
 *
 * ```usfm
 * \p This is a plain paragraph.
 * \p This is a paragraph \nd with some special text\nd* in it.
 * ```
 *
 * If the marker type has a closing marker but the closing marker is not present in the USFM for a
 * marker with this marker type, the USX/USJ for the marker will have the attribute `closed` set to
 * `false` unless {@link CloseableMarkerTypeInfo.isClosingMarkerOptional} is `true`.
 */
export type CloseableMarkerTypeInfo = MarkerTypeInfoBase & {
	/**
	 * Whether markers of this type have a closing marker in USFM. This property concerns normal
	 * closing markers like `\wj*`, not independent closing markers like
	 * {@link NormalMarkerInfo.independentClosingMarkers}, which are completely separate markers.
	 *
	 * If not present, defaults to `false`
	 */
	hasClosingMarker: true;
	/**
	 * Whether the closing marker for markers of this type is "empty" in USFM, meaning the marker name
	 * is absent from the closing marker. This also means that there should not be a structural space
	 * between the opening and the closing markers in USFM if there are no attributes listed on the
	 * marker.
	 *
	 * For example, markers of type `ms` (such as `qt1-s` and `qt1-e`) have an empty closing marker:
	 *
	 * ```usfm
	 * \qt1-s\*
	 * ...
	 * \qt1-e\*
	 * ```
	 *
	 * The closing marker for `qt1-s` is `\*` as opposed to the closing marker for `nd` which is
	 * `\nd*`.
	 *
	 * Note that there is still a structural space after the opening marker if there are attributes
	 * present:
	 *
	 * ```usfm
	 * \qt1-s |Someone\*
	 * ...
	 * \qt1-e\*
	 * ```
	 *
	 * If not present, defaults to `false`
	 */
	isClosingMarkerEmpty?: boolean;
};
/**
 * Information about a USFM/USX/USJ marker type that does not have a closing marker. See
 * {@link MarkerInfo} for other kinds of marker types.
 *
 * For example, `char` marker types such as `nd` markers have closing markers, but `para` marker
 * types such as `p` do not:
 *
 * ```usfm
 * \p This is a plain paragraph.
 * \p This is a paragraph \nd with some special text\nd* in it.
 * ```
 *
 * If the marker type has a closing marker but the closing marker is not present in the USFM for a
 * marker with this marker type, the USX/USJ for the marker will have the attribute `closed` set to
 * `false` unless {@link CloseableMarkerTypeInfo.isClosingMarkerOptional} is `true`.
 */
export type NonCloseableMarkerTypeInfo = MarkerTypeInfoBase & {
	/**
	 * Whether markers of this type need a closing marker in USFM.
	 *
	 * If not present, defaults to `false`
	 */
	hasClosingMarker?: false;
};
/**
 * Information about a USFM/USX/USJ marker type that is common to all marker types. See
 * {@link MarkerTypeInfo} for various kinds of marker types.
 */
export type MarkerTypeInfoBase = {
	/** Explanation of the meaning of this marker type */
	description?: string;
	/**
	 * Whether markers of this type should have a `style` attribute in USX/USJ.
	 *
	 * If this is `false`, it also means the marker type is the same as the marker name.
	 *
	 * If not present, defaults to `true`.
	 */
	hasStyleAttribute?: boolean;
	/**
	 * List of attributes that should not be output to USFM on markers of this type.
	 *
	 * This is used for attributes that are not present in USFM. For example, the `sid` attribute on
	 * the `verse` type marker is not present in USFM because it is derived metadata in USX/USJ and is
	 * not present in USFM.
	 *
	 * This property is not used when converting to USX or USJ.
	 */
	skipOutputAttributeToUsfm?: string[];
	/**
	 * List of attributes indicating whether to skip outputting this marker to USFM. If any of the
	 * listed attributes is present on the marker, skip outputting this marker when converting to
	 * USFM. Only skip outputting the opening and closing marker representations, though; the content
	 * inside the marker (if present) should not be skipped.
	 *
	 * This is used for certain markers that sometimes are normal markers but sometimes are derived
	 * metadata and are not present in USFM. These derived metadata markers are identified by whether
	 * they have specific attributes on them.
	 *
	 * For example, if the `verse` marker has an `eid` attribute, it indicates it is a marker denoting
	 * the end of the verse that is derived metadata in USX/USJ and is not present in USFM. Note that
	 * the `verse` marker does not have the `style="v"` attribute in this situation, so this list of
	 * attributes is on the marker type.
	 *
	 * Following is an example of a derived metadata `verse` marker in USX:
	 *
	 * ```xml
	 * <!-- prettier-ignore -->
	 * <para style="p">
	 *   <verse number="21" style="v" sid="2SA 1:21" />This is verse 21.<verse eid="2SA 1:21" />
	 * </para>
	 * ```
	 *
	 * The equivalent in USFM would be:
	 *
	 * ```usfm
	 * \p
	 * \v 21 This is verse 21.
	 * ```
	 *
	 * An example with content inside the marker that should not be skipped is generated `ref`s. These
	 * `ref`s wrap project-localized Scripture references in `xt` markers and have computer-readable
	 * Scripture References as their `loc` attribute. These `ref`s that are derived metadata have the
	 * `gen` attribute set to `"true"` and can be removed if `gen="true"` is present.
	 *
	 * Following is an example of a generated `ref` in USX:
	 *
	 * ```xml
	 * <!-- prettier-ignore -->
	 * <char style="xt"><ref loc="2SA 1:1" gen="true">2Sam 1:1</ref>; <ref loc="2SA 1:2-3">2Sam 1:2-3</ref>.</char>
	 * ```
	 *
	 * The equivalent in USFM would be:
	 *
	 * ```usfm
	 * \xt 2Sam 1:1; 2Sam 1:2-3.\xt*
	 * ```
	 *
	 * This property is not used when converting to USX or USJ.
	 */
	skipOutputMarkerToUsfmIfAttributeIsPresent?: string[];
	/**
	 * Whether to always skip outputting this marker to USFM. Skip outputting this marker when
	 * converting to USFM. Only skip outputting the opening and closing marker representations,
	 * though; the content inside the marker (if present) should not be skipped.
	 *
	 * This is used for marker types that have no representation in USFM in a given version, likely
	 * meaning they are derived metadata and are not present in USFM.
	 *
	 * For example, in USFM 3.1, the `table` marker type is generated while transforming USFM into
	 * USX/USJ and is not preserved when transforming from USX/USJ to USFM.
	 *
	 * Following is an example of a derived metadata `table` marker in USX:
	 *
	 * ```xml
	 * <!-- prettier-ignore -->
	 * <table>
	 *   <row style="tr">
	 *     <cell style="th1" align="start">Header 1</cell>
	 *     <cell style="th2" align="start">Header 2 space after </cell>
	 *     <cell style="thc3" align="center" colspan="2">Header 3-4 centered</cell>
	 *     <cell style="thr5" align="end">Header 5 right</cell>
	 *   </row>
	 *   <row style="tr">
	 *     <cell style="tc1" align="start">Row 1 cell 1</cell>
	 *     <cell style="tc2" align="start">Row 1 cell 2 space after </cell>
	 *     <cell style="thc3" align="center">Row 1 cell 3 centered</cell>
	 *     <cell style="thr4" align="end" colspan="2">Row 1 cell 4-5 right</cell>
	 *   </row>
	 *   <row style="tr">
	 *     <cell style="tcr1" align="end" colspan="4">Row 2 cell 1-4 right</cell>
	 *     <cell style="tc5" align="start">Row 2 cell 5</cell>
	 *   </row>
	 * </table>
	 * ```
	 *
	 * The equivalent in USFM would be:
	 *
	 * ```usfm
	 * \tr \th1 Header 1\th2 Header 2 space after \thc3-4 Header 3-4 centered\thr5 Header 5 right
	 * \tr \tc1 Row 1 cell 1\tc2 Row 1 cell 2 space after \thc3 Row 1 cell 3 centered\thr4-5 Row 1 cell 4-5 right
	 * \tr \tcr1-4 Row 2 cell 1-4 right\tc5 Row 2 cell 5
	 * ```
	 *
	 * This property is not used when converting to USX or USJ.
	 *
	 * If not present, defaults to `false`
	 */
	skipOutputMarkerToUsfm?: boolean;
	/**
	 * Whether markers of this type should have a newline before them in USFM.
	 *
	 * For example, `para` marker types such as `p` should have a newline, but `char` marker types
	 * such as `nd` markers should not:
	 *
	 * ```usfm
	 * \p This is a plain paragraph.
	 * \p This is a paragraph \nd with some special text\nd* in it.
	 * ```
	 *
	 * Note that the newline is never strictly necessary, and it is not usually present if the very
	 * first marker in the file (or in examples such as this) should have a newline.
	 *
	 * If not present, defaults to `false`
	 */
	hasNewlineBefore?: boolean;
	/**
	 * Marker type to use when operating on the USFM representation of markers of this type. For
	 * example, when outputting to USFM, the marker type listed here in `markerTypeUsfm` should be
	 * used instead of the marker's type as listed in USX or USJ.
	 */
	markerTypeUsfm?: string;
	/**
	 * Marker type to use when operating on the USX representation of markers of this type. For
	 * example, when outputting to USX, the marker type listed here in `markerTypeUsx` should be used
	 * instead of the marker's type as listed in USFM or USJ.
	 */
	markerTypeUsx?: string;
	/**
	 * Marker type to use when operating on the USJ representation of markers of this type. For
	 * example, when outputting to USJ, the marker type listed here in `markerTypeUsj` should be used
	 * instead of the marker's type as listed in USFM or USX.
	 */
	markerTypeUsj?: string;
	/**
	 * Prefix to add to the opening and closing marker before the marker name if a marker of this type
	 * occurs within another marker of this type when outputting to USFM.
	 *
	 * Following is an example of `nd` inside `wj` (both are `char`-type markers) in USFM:
	 *
	 * ```usfm
	 * \p \wj This is \+nd nested\+nd*!\wj*
	 * ```
	 */
	nestedPrefix?: string;
	/**
	 * Instructions regarding special handling required for this marker type when transforming to
	 * USFM. These instructions are an explanation of what needs to be done to markers of this type to
	 * properly transform the marker to USFM.
	 *
	 * This property is generally only included when it is exceptionally difficult to output a marker
	 * properly to USFM; the markers map attempts to use this property as little as possible, favoring
	 * encoding information in other properties for more automatic transformation instead.
	 */
	outputToUsfmInstructions?: string;
	/**
	 * Instructions regarding special handling required for this marker type when transforming from
	 * USFM to USX or USJ. These instructions are an explanation of what needs to be done to markers
	 * of this type to properly transform the marker to USX or USJ.
	 *
	 * This property is generally only included when it is exceptionally difficult to parse a marker
	 * properly from USFM; the markers map attempts to use this property as little as possible,
	 * favoring encoding information in other properties for more automatic transformation instead.
	 */
	parseUsfmInstructions?: string;
};
/**
 * Information about a USFM/USX/USJ marker type that is essential for proper translation between
 * formats
 */
export type MarkerTypeInfo = CloseableMarkerTypeInfo | NonCloseableMarkerTypeInfo;
/** A map of all USFM/USX/USJ markers and some information about them */
export type MarkersMap = {
	/** Which version of USFM/USX/USJ this map represents */
	version: string;
	/**
	 * Which commit this map came from. This is necessary because the schema file seems to be
	 * distributed multiple times in one release version. As such, this specifies the exact version of
	 * the schema file.
	 */
	commit: string;
	/**
	 * Which version of the markers map types this markers map conforms to. Follows [Semantic
	 * versioning](https://semver.org/); the same major version contains no breaking changes.
	 */
	markersMapVersion: `1.${number}.${number}${string}`;
	/**
	 * Which tag or commit of `usfm-tools` repo this map is generated from.
	 *
	 * Contains the output from `git tag --points-at HEAD` or `git rev-parse HEAD`
	 *
	 * Will also have a `+` at the end if there were working changes outside the `src/test-data`
	 * folder when this was generated.
	 */
	usfmToolsVersion: string;
	/**
	 * Whether any whitespace after attribute markers and before the next content is not just
	 * structural but should actually be considered part of the content of the marker.
	 *
	 * According to specification, whitespace after attribute markers is not content but is just
	 * structural.
	 *
	 * According to Paratext 9.4, whitespace after attribute markers is content and is not just
	 * structural.
	 *
	 * This setting determines which interpretation to use when converting from USFM to USX/USJ.
	 *
	 * If not present, defaults to `false`.
	 */
	isSpaceAfterAttributeMarkersContent?: boolean;
	/**
	 * Whether markers with optional closing markers (see
	 * {@link NormalMarkerInfo.isClosingMarkerOptional}) should still be explicitly closed in USFM.
	 * That is, whether markers with optional closing markers still need the `closed` attribute set to
	 * `"false"` in USX/USJ if the closing marker is not present in USFM.
	 *
	 * In other words, this setting determines whether markers with optional closing markers should be
	 * assumed to be explicitly closed (meaning the closing marker is present in USFM) when
	 * transforming USX/USJ to USFM unless otherwise indicated by the `closed` attribute.
	 *
	 * If this is `true` (matches Paratext 9.4), markers with optional closing markers are treated
	 * like other markers in that they are assumed to be explicitly closed in USFM unless otherwise
	 * indicated:
	 *
	 * - If they are not explicitly closed in USFM, they should have `closed="false"`
	 * - If they are explicitly closed in USFM, they do not need `closed="true"`
	 *
	 * If this is `false` (matches specification), markers with optional closing markers are assumed
	 * not to be explicitly closed in USFM unless otherwise indicated:
	 *
	 * - If they are not explicitly closed in USFM, they do not need `closed="false"`
	 * - If they are explicitly closed in USFM, they should have `closed="true"`
	 *
	 *   - Disclaimer: It is not clear that `closed="true"` should be present in this case according to
	 *       `usx.rng`; it seems `usx.rng` indicates that optional closing markers should never be
	 *       output to USFM. It is possible that `usx.rng` considers this to be a case where
	 *       preserving the exact USFM is not important.
	 *
	 * If not present, defaults to `false`.
	 */
	shouldOptionalClosingMarkersBePresent?: boolean;
	/**
	 * Map whose keys are the marker names and whose values are information about that marker
	 *
	 * If you find the marker name in this map, you do not need to search the `markersRegExp` map.
	 */
	markers: Record<string, MarkerInfo | undefined>;
	/**
	 * Map whose keys are string representations of `RegExp` patterns to match against marker names
	 * (using the
	 * [test](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) and whose values are information about that marker
	 *
	 * You do not need to search this map if you found the marker name in the `markers` map.
	 */
	markersRegExp: Record<string, MarkerInfo | undefined>;
	/** Map whose keys are the marker types and whose values are information about that marker type */
	markerTypes: Record<string, MarkerTypeInfo | undefined>;
};
/**
 * A map of all USFM/USX/USJ markers and some information about them. Generated from a `usx.rng`
 * file
 */
declare const USFM_MARKERS_MAP: MarkersMap;
/**
 * A map of all USFM/USX/USJ markers and some information about them. Generated from a `usx.rng`
 * file and adjusted to reflect the way Paratext 9.4 handles USFM.
 */
declare const USFM_MARKERS_MAP_PARATEXT: MarkersMap;
/** USJ content node type for a chapter */
export declare const CHAPTER_TYPE = "chapter";
/** USJ content node type for a verse */
export declare const VERSE_TYPE = "verse";
/**
 * Represents a book, chapter, verse, and offset
 *
 * @deprecated 23 October 2025. Use {@link UsfmVerseLocation} or {@link UsfmLocation} instead.
 */
export type VerseRefOffset = {
	verseRef: SerializedVerseRef;
	offset: number;
};
/**
 * JSON path to a {@link MarkerObject}, {@link Usj}, or text content string in the current USJ
 * document.
 *
 * This could actually have more content clauses at the end, but TS types are limited
 */
export type ContentJsonPath = "" | `$` | `$.content[${number}]` | `$.content[${number}].content[${number}]` | `$.content[${number}].content[${number}].content[${number}]` | `$.content[${number}].content[${number}].content[${number}].content[${number}]`;
/**
 * JSON path to the `marker` or an attribute on a {@link MarkerObject} or {@link Usj} in the current
 * USJ document. Note that it seems you must use `['bracket notation']` rather than `.dot` notation
 * if there are symbols other than underscore in the property name
 *
 * This could actually have more content clauses at the end, but TS types are limited
 */
export type PropertyJsonPath = "" | `$.${string}` | `$['${string}']` | `$.content[${number}].${string}` | `$.content[${number}]['${string}']` | `$.content[${number}].content[${number}].${string}` | `$.content[${number}].content[${number}]['${string}']` | `$.content[${number}].content[${number}].content[${number}].${string}` | `$.content[${number}].content[${number}].content[${number}]['${string}']` | `$.content[${number}].content[${number}].content[${number}].content[${number}].${string}` | `$.content[${number}].content[${number}].content[${number}].content[${number}]['${string}']`;
/**
 * A verse ref and an offset in USFM space that point to a specific location in USFM.
 *
 * The USJ representation of the positions represented by this type are {@link UsjDocumentLocation}.
 * Note, however, that those locations are relative to a specific USJ document rather than being
 * absolute verse reference locations like this type.
 *
 * To see many examples of the same point represented by both USFM and USJ locations, go to
 * https://github.com/paranext/paranext-core/tree/main/lib/platform-bible-utils/src/scripture/usj-reader-writer-test-data/testUSFM-2SA-1-locations.ts
 *
 * Note: This type may be expanded in the future to allow for specifying offsets based on other
 * locations than a specific verse like from the start of a chapter or book. If you do not want to
 * offer such features, use {@link UsfmVerseLocation}, whose offset is based on a specific verse.
 */
export type UsfmLocation = UsfmVerseLocation;
/**
 * A verse ref and an offset within that verse in USFM space that point to a specific location in
 * USFM
 */
export type UsfmVerseLocation = {
	/** Verse reference indicating which verse the location is in */
	verseRef: SerializedVerseRef;
	/**
	 * Offset to apply to start of the verse indicated by `verseRef`.
	 *
	 * If the verse is 0, offset 0 is the start of the chapter. If the verse is greater than 0, offset
	 * 0 is the backslash on the verse marker.
	 *
	 * If not provided, defaults to 0.
	 */
	offset?: number;
};
/**
 * A JSONPath query to a {@link MarkerContent}, {@link Usj}, or property within a USJ document and
 * additional information that point to a specific location in USJ.
 *
 * This type does not include a verse reference because the JSONPath is relative to a specific USJ
 * document; that USJ document may have a book, a chapter, or something else in it.
 *
 * This type intends to represent USFM positions ({@link UsfmLocation}) in USJ space. However, there
 * are some USFM positions that are not currently representable with these types:
 *
 * - The second slash in `optbreak`'s USFM representation `//` (literally not representable)
 * - Nested marker prefix on opening markers like `+` for character markers (literally not
 *   representable)
 * - The bar `|` that indicates the start of closing marker attributes (no official representation)
 * - The equals sign for closing marker attributes (no official representation)
 * - The quotes around closing marker attribute values (no official representation)
 * - The space between closing marker attributes (no official representation)
 *
 * To see many examples of the same point represented by both USFM and USJ locations, go to
 * https://github.com/paranext/paranext-core/tree/main/lib/platform-bible-utils/src/scripture/usj-reader-writer-test-data/testUSFM-2SA-1-locations.ts
 */
export type UsjDocumentLocation = UsjMarkerLocation | UsjClosingMarkerLocation | UsjTextContentLocation | UsjPropertyValueLocation | UsjAttributeKeyLocation | UsjAttributeMarkerLocation | UsjClosingAttributeMarkerLocation;
/**
 * A JSONPath query to a {@link MarkerObject} or {@link Usj} node. Indicates the very beginning of
 * that marker (at the backslash in USFM).
 */
export type UsjMarkerLocation = {
	/** JSON path to the marker object the location is pointing to. */
	jsonPath: ContentJsonPath;
};
/**
 * A JSONPath query to a specific point in the closing marker representation of a
 * {@link MarkerObject} or {@link Usj} node.
 */
export type UsjClosingMarkerLocation = {
	/**
	 * JSON path to the marker object whose closing marker the location is pointing to. The offset
	 * applies to the closing marker representation of that marker (for example, `\nd*` in USFM).
	 */
	jsonPath: ContentJsonPath;
	/**
	 * The character index in the closing marker representation where this location is pointing. The
	 * location is at this offset within the closing marker representation.
	 */
	closingMarkerOffset: number;
};
/**
 * A JSONPath query to a specific point in a text content string in a {@link MarkerObject.content}
 * array.
 */
export type UsjTextContentLocation = {
	/**
	 * JSON path to the text content string the location is pointing to. The offset applies to this
	 * text string.
	 */
	jsonPath: ContentJsonPath;
	/**
	 * The character index in the text content string where this location is pointing. The location is
	 * at this offset within the text content string.
	 */
	offset: number;
};
/**
 * A JSONPath query to a specific point in a property (`marker` or an attribute) value string in a
 * {@link MarkerObject} or {@link Usj}. The property cannot be `type` because `type`'s value has no
 * representation in USFM.
 *
 * To represent a location in an attribute's key, use {@link UsjAttributeKeyLocation}.
 */
export type UsjPropertyValueLocation = {
	/**
	 * JSON path to the property the location is pointing to. The offset applies to this property's
	 * value string.
	 */
	jsonPath: PropertyJsonPath;
	/**
	 * The character index in the property's value string where this location is pointing. The
	 * location is at this offset within the property's value string.
	 */
	propertyOffset: number;
};
/**
 * A JSONPath query to a specific point in an attribute key string in a {@link MarkerObject} or
 * {@link Usj}. The property cannot be `type` or `marker` because these properties' keys have no
 * representation in USFM. The property also cannot be any special attribute whose key doesn't have
 * a text representation in USFM like default attribute, leading attribute, text content attribute
 *
 * To represent a location in an attribute's value, use {@link UsjPropertyValueLocation}.
 */
export type UsjAttributeKeyLocation = {
	/**
	 * JSON path to the marker whose attribute key the location is pointing to. The offset applies to
	 * this attribute's key string unless the attribute is an attribute marker in USFM.
	 */
	jsonPath: ContentJsonPath;
	/** Attribute name on the marker object whose key this location is pointing to. */
	keyName: string;
	/**
	 * The character index in the attribute's key string where this location is pointing.
	 *
	 * If the attribute is an attribute marker in USFM, the location is at this offset within the
	 * marker name for this attribute marker (for example, `c`'s `altnumber` attribute has attribute
	 * marker `ca`, so its `keyOffset` applies to `ca`).
	 *
	 * If the attribute is not an attribute marker in USFM, the location is at this offset within the
	 * attribute's key string.
	 */
	keyOffset: number;
};
/**
 * A JSONPath query to an attribute marker derived from an attribute on a {@link MarkerObject} or
 * {@link Usj}. Indicates the very beginning of that marker (at the backslash in USFM).
 */
export type UsjAttributeMarkerLocation = {
	/** JSON path to the marker whose attribute marker the location is pointing to. */
	jsonPath: ContentJsonPath;
	/**
	 * Attribute name on the marker object whose key this location is pointing to. This attribute is
	 * an attribute marker in USFM.
	 */
	keyName: string;
};
/**
 * A JSONPath query to a specific point in the closing marker representation of an attribute marker
 * derived from an attribute on a {@link MarkerObject} or {@link Usj}.
 */
export type UsjClosingAttributeMarkerLocation = {
	/**
	 * JSON path to the marker whose attribute marker's closing marker the location is pointing to.
	 * The offset applies to the closing marker representation of that attribute marker (for example,
	 * `\ca*` in USFM).
	 */
	jsonPath: ContentJsonPath;
	/**
	 * Attribute name on the marker object whose key this location is pointing to. This attribute is
	 * an attribute marker in USFM.
	 */
	keyName: string;
	/**
	 * The character index in the closing marker representation where this location is pointing. The
	 * location is at this offset within the closing marker representation of the attribute marker.
	 */
	keyClosingMarkerOffset: number;
};
/**
 * Node in a USJ object (including the top-level Usj object) and its location in the document. You
 * must make sure you only add `node`s that correspond to the appropriate type of
 * `UsjDocumentLocation` (e.g. if `documentLocation` is a {@link UsjTextContentLocation}, `node` must
 * be a text content string)
 *
 * You can specify a particular kind of `UsjDocumentLocation` in the generic type
 * `TDocumentLocation`, and that will narrow `documentLocation` to that specific kind of location.
 */
export type UsjNodeAndDocumentLocation<TDocumentLocation extends UsjDocumentLocation = UsjDocumentLocation> = {
	node: TDocumentLocation extends UsjTextContentLocation ? string : MarkerObject | Usj;
	documentLocation: TDocumentLocation;
};
/** Result of a search for text within a USJ object */
export type UsjSearchResult = {
	location: UsjNodeAndDocumentLocation<UsjTextContentLocation>;
	/** The matching text that was found at the location */
	text: string;
};
/**
 * Set of options to provide to `UsjReaderWriter`'s constructor to customize how the reading and
 * writing works
 */
export type UsjReaderWriterOptions = {
	/**
	 * A map of all USFM/USX/USJ markers and some information about them. Used for translating between
	 * the formats
	 *
	 * Defaults to trying to use a built-in markers map that matches the version of the USJ passed in.
	 *
	 * Currently supported built-in USFM versions:
	 *
	 * - 3.0/3.0.x
	 */
	markersMap?: MarkersMap;
	/**
	 * Whether the transformations should preserve invisible characters as in Paratext 9
	 * (`ScrText.Settings.AllowInvisibleChars`).
	 *
	 * Defaults to `false`
	 */
	shouldAllowInvisibleCharacters?: boolean;
};
/** Utilities for reading from and writing to `Usj` objects */
export interface IUsjReaderWriter {
	/**
	 * Return a copy of text following a given starting point
	 *
	 * @param start Point where text extraction will start
	 * @param desiredLength Length of text to extract from this USJ data
	 */
	extractText(start: UsjNodeAndDocumentLocation, desiredLength: number): string;
	/**
	 * Return a copy of text between two points
	 *
	 * @param start Point where text extraction will start
	 * @param end Point where text extraction will end
	 * @param maxLength Maximum length of string to return (defaults to 100)
	 * @returns Text between the two points, capped at length `maxLength`
	 */
	extractTextBetweenPoints(start: UsjNodeAndDocumentLocation, end: UsjNodeAndDocumentLocation, maxLength: number): string;
	/**
	 * Given a starting point, find the next location in this USJ data that matches the given text
	 *
	 * @param start Point where the search for `text` will start
	 * @param text Text to find. Note you can use an empty string to find the closest text in or after
	 *   the `start` point.
	 * @param maxTextLengthToSearch Maximum length of text to search before stopping (default is 1000)
	 * @returns Object containing the USJ node where `text` begins (it might be split across nodes),
	 *   offset within that node that indicates where `text` begins, and a JSONPath string that
	 *   indicates the location of the of USJ node within `usj`. Note that if the USJ node returned is
	 *   an object, it is the same object that is within this USJ data. So if you change it, you are
	 *   changing this USJ data.
	 */
	findNextLocationOfMatchingText(start: UsjNodeAndDocumentLocation, text: string, maxTextLengthToSearch: number): UsjNodeAndDocumentLocation<UsjTextContentLocation> | undefined;
	/** Find the first value matching the given JSONPath query within this USJ data */
	findSingleValue<T>(jsonPathQuery: string): T | undefined;
	/** Find the parent of the first value matching the given JSONPath query within this USJ data */
	findParent<T>(jsonPathQuery: string): T | undefined;
	/**
	 * Convert a JSONPath query into a SerializedVerseRef and offset
	 *
	 * @param jsonPathQuery JSONPath search expression that indicates a node within this USJ data. If
	 *   the expression matches more than one node, then only the first node found is considered.
	 * @param bookIdIfNotFound 3-letter ID of the book this USJ document is in (only used if a book ID
	 *   is not found in the USJ document)
	 * @returns SerializedVerseRef and offset that represents the location within this USJ data
	 *   indicated by `jsonPathQuery`
	 */
	jsonPathToUsfmVerseLocation(jsonPathQuery: string, bookIdIfNotFound?: string): UsfmVerseLocation;
	/** Build a JSONPath query that uniquely identifies the given node with this USJ data. */
	nodeToJsonPath(node: MarkerObject): ContentJsonPath;
	/**
	 * Determine the location in the USFM representation of this data that corresponds to the location
	 * of a node somewhere within this USJ data
	 *
	 * @param node JSON object or string in the USJ data to get the USFM location for
	 * @param nodeParent JSON object that owns the `content` array that includes `node`. Required if
	 *   `node` is a string; optional and unused if `node` is a {@link MarkerObject} or {@link Usj}
	 * @param bookIdIfNotFound 3-letter ID of the book this USJ document is in (only used if a book ID
	 *   is not found in the USJ document)
	 * @returns SerializedVerseRef and offset representing the location of `node`, if one could be
	 *   found
	 * @throws If `node` is a string and no `nodeParent` is provided
	 * @throws If not able to establish relationship between string `node` and `nodeParent`
	 * @throws If not able to find the node in the USJ document
	 * @throws If not able to find a book ID in the USJ document and `bookIdIfNotFound` is not
	 *   provided
	 */
	nodeToUsfmVerseLocation(node: MarkerContent | Usj, nodeParent?: MarkerObject | MarkerContent[] | Usj, bookIdIfNotFound?: string): UsfmVerseLocation;
	/**
	 * Remove all nodes from this USJ data that match a given search function.
	 *
	 * @param searchFunction Function that returns `true` if the given node should be removed
	 * @returns Number of nodes removed
	 */
	removeContentNodes(searchFunction: (potentiallyMatchingNode: MarkerContent) => boolean): number;
	/**
	 * Search for matches of a regular expression within this USJ's text data
	 *
	 * @param regex Regular expression to search for. Specify the global flag to find all matches.
	 * @returns Array of `UsjSearchResult` objects that match the given regular expression
	 */
	search(regex: RegExp): UsjSearchResult[];
	/** Transforms the USJ document into USFM */
	toUsfm(): string;
	/**
	 * Inform this UsjReaderWriter that the underlying USJ object changed. This is needed to clear
	 * caches used when querying.
	 */
	usjChanged(): void;
	/**
	 * Convert a location in USFM space into a location in USJ space within this USJ data.
	 *
	 * If the USJ document has no book markers in it to determine which book the USJ is in, the
	 * `verseRef.book` will be ignored, and only the chapter and verse numbers will be used to
	 * determine the location.
	 *
	 * @param usfmLocation Location in USFM space - a book, chapter, verse, and character offset
	 *   within the verse's USFM
	 * @returns Object containing the USJ location within the USJ document indicated by
	 *   `usfmLocation`. Note that if the USJ node returned is an object, it is the same object that
	 *   is within this USJ data. So if you change it, you are changing this USJ data.
	 */
	usfmLocationToUsjDocumentLocation(usfmLocation: UsfmLocation | SerializedVerseRef): UsjDocumentLocation;
	/**
	 * Convert a location in USFM space into a node and location in USJ space within this USJ data.
	 *
	 * If the USJ document has no book markers in it to determine which book the USJ is in, the
	 * `verseRef.book` will be ignored, and only the chapter and verse numbers will be used to
	 * determine the location.
	 *
	 * @param usfmLocation Location in USFM space - a book, chapter, verse, and character offset
	 *   within the verse's USFM
	 * @returns Object containing the USJ node and location within the USJ document indicated by
	 *   `usfmLocation`. Note that if the USJ node returned is an object, it is the same object that
	 *   is within this USJ data. So if you change it, you are changing this USJ data.
	 */
	usfmLocationToUsjNodeAndDocumentLocation(usfmLocation: UsfmLocation | SerializedVerseRef): UsjNodeAndDocumentLocation;
	/**
	 * Convert a location in USJ space within this USJ data into a location in USFM space.
	 *
	 * @param usjLocation Location in USJ space - a jsonPath and other information about where the
	 *   location is
	 * @param bookIdIfNotFound 3-letter ID of the book this USJ document is in (only used if a book ID
	 *   is not found in the USJ document)
	 * @returns Location in USFM space that is equivalent to the USJ location specified
	 * @throws If not able to find the location in the USJ document
	 * @throws If not able to find a book ID in the USJ document and `bookIdIfNotFound` is not
	 *   provided
	 */
	usjDocumentLocationToUsfmVerseLocation(usjLocation: UsjDocumentLocation, bookIdIfNotFound?: string): UsfmVerseLocation;
	/**
	 * Get the node + offset and JSONPath query within this USJ data of the first encountered string
	 * after the verse marker for a specific verse in a USJ chapter.
	 *
	 * Note: this may return a node that is in a subsequent verse or even chapter depending on how
	 * much content the USJ data contains. It simply looks through the rest of the USJ data for the
	 * first text node and returns that.
	 *
	 * @param verseRef Indicates the book, chapter, and verse of interest to find the next text for
	 * @returns Object containing the first USJ text node after `verseRef`, and a JSONPath string that
	 *   indicates the location of the of USJ text node within this USJ data.
	 * @throws Error if there is no text after the verse marker for `verseRef`
	 * @throws Error if `verseRef` does not point to a valid verse in this USJ data
	 */
	verseRefToNextTextLocation(verseRef: SerializedVerseRef): UsjNodeAndDocumentLocation<UsjTextContentLocation>;
}
/** Gets the default caller sequence to use to generate callers for textual notes. */
export declare function getDefaultCallerSequence(): string[];
/**
 * Gets a caller to be displayed for a textual note. This is primarily useful as a helper function
 * in {@link getFormatCallerFunction} , but it might be useful in stories, UI preview code, etc.
 *
 * @param callers Array of caller symbols, or `undefined` to use the default sequence, which is the
 *   lowercase Roman-script letters as sequenced in the English alphabet.
 * @param n Zero-based index into the caller list.
 */
export declare function getNthCaller(n: number, callers?: string[]): string;
/**
 * Gets a function that provides a (stable) caller based on a given sequence of textual notes.
 *
 * @param footnotes Sequence of footnotes, cross-references, and/or end-notes.
 * @param callers Array of caller symbols, or `undefined` to use the default sequence, which is the
 *   lowercase Roman-script letters as sequenced in the English alphabet.
 */
export declare function getFormatCallerFunction(footnotes: MarkerObject[], callers: string[] | undefined): (caller: string | undefined, index: number) => string | undefined;
/**
 * This function mirrors the `at` function from the JavaScript Standard String object. It handles
 * Unicode code points instead of UTF-16 character codes.
 *
 * Finds the Unicode code point at the given index.
 *
 * @param string String to index
 * @param index Position of the character to be returned in range of -length(string) to
 *   length(string)
 * @returns New string consisting of the Unicode code point located at the specified offset,
 *   undefined if index is out of bounds
 */
export declare function at(string: string, index: number): string | undefined;
/**
 * This function mirrors the `charAt` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns a new string consisting of the single unicode code point at the given index.
 *
 * @param string String to index
 * @param index Position of the string character to be returned, in the range of 0 to
 *   length(string)-1
 * @returns New string consisting of the Unicode code point located at the specified offset, empty
 *   string if index is out of bounds
 */
export declare function charAt(string: string, index: number): string;
/**
 * This function mirrors the `codePointAt` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns a non-negative integer that is the Unicode code point value of the character starting at
 * the given index.
 *
 * @param string String to index
 * @param index Position of the string character to be returned, in the range of 0 to
 *   length(string)-1
 * @returns Non-negative integer representing the code point value of the character at the given
 *   index, or undefined if there is no element at that position
 */
export declare function codePointAt(string: string, index: number): number | undefined;
/**
 * This function mirrors the `endsWith` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Determines whether a string ends with the characters of this string.
 *
 * @param string String to search through
 * @param searchString Characters to search for at the end of the string
 * @param endPosition End position where searchString is expected to be found. Default is
 *   `length(string)`
 * @returns True if it ends with searchString, false if it does not
 */
export declare function endsWith(string: string, searchString: string, endPosition?: number): boolean;
/**
 * Formats a string into an array of objects (adjacent strings are concatenated in one array entry),
 * replacing `{replacer key}` with the value in the `replacers` at that replacer key (or multiple
 * replacer values if there are multiple in the string). Will also remove \ before curly braces if
 * curly braces are escaped with a backslash in order to preserve the curly braces. E.g. 'Hi, this
 * is {name}! I like `\{curly braces\}`! would become Hi, this is Jim! I like {curly braces}!
 *
 * If the key in unescaped braces is not found, returns the key without the braces. Empty unescaped
 * curly braces will just return a string without the braces e.g. ('I am {Nemo}', { 'name': 'Jim'})
 * would return 'I am Nemo'.
 *
 * Note: React elements can be used as replacer values.
 *
 * @example
 *
 * ```tsx
 * <p>
 *   {formatReplacementStringToArray('Hi {other}! I am {name}.', {
 *     other: 'Billy',
 *     name: <span className="tw-text-red-500">Jim</span>,
 *   })}
 * </p>
 * ```
 *
 * @example
 *
 * ```typescript
 * formatReplacementStringToArray(
 *   'Hi, this is {name}! I like \{curly braces\}! I have a {carInfo} car. My favorite food is {food}.',
 *   { name: ['Bill'], carInfo: { year: 2015, color: 'blue' } }
 * );
 *
 * =>
 *
 * ['Hi, this is ', ['Bill'], '! I like {curly braces}! I have a ', { year: 2015, color: 'blue' }, ' car. My favorite food is food.']
 * ```
 *
 * @param str String to format and break out into an array of objects
 * @param replacers Object whose keys are replacer keys and whose values are the values with which
 *   to replace `{replacer key}`s found in the string to format. If the replacer value is a string,
 *   it will be concatenated into existing strings in the array. Otherwise, the replacer value will
 *   be added as a new entry in the array
 * @returns Array of formatted strings and replaced objects
 */
export declare function formatReplacementStringToArray<T = unknown>(str: string, replacers: {
	[key: string | number]: T;
} | object): (string | T)[];
/**
 * Formats a string, replacing `{replacer key}` with the value in the `replacers` at that replacer
 * key (or multiple replacer values if there are multiple in the string). Will also remove \ before
 * curly braces if curly braces are escaped with a backslash in order to preserve the curly braces.
 * E.g. 'Hi, this is {name}! I like `\{curly braces\}`! would become Hi, this is Jim! I like {curly
 * braces}!
 *
 * If the key in unescaped braces is not found, returns the key without the braces. Empty unescaped
 * curly braces will just return a string without the braces e.g. ('I am {Nemo}', { 'name': 'Jim'})
 * would return 'I am Nemo'.
 *
 * @example
 *
 * ```typescript
 * formatReplacementString(
 *   'Hi, this is {name}! I like \{curly braces\}! I have a {carColor} car. My favorite food is {food}.',
 *   { name: 'Bill', carColor: 'blue' }
 * );
 *
 * =>
 *
 * 'Hi, this is Bill! I like {curly braces}! I have a blue car. My favorite food is food.'
 * ```
 *
 * @param str String to format
 * @param replacers Object whose keys are replacer keys and whose values are the values with which
 *   to replace `{replacer key}`s found in the string to format. Will be coerced to strings using
 *   `${replacerValue}`
 * @returns Formatted string
 */
export declare function formatReplacementString(str: string, replacers: {
	[key: string | number]: string | unknown;
} | object): string;
/**
 * This function mirrors the `includes` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Performs a case-sensitive search to determine if searchString is found in string.
 *
 * @param string String to search through
 * @param searchString String to search for
 * @param position Position within the string to start searching for searchString. Default is `0`
 * @returns True if search string is found, false if it is not
 */
export declare function includes(string: string, searchString: string, position?: number): boolean;
/**
 * This function mirrors the `indexOf` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns the index of the first occurrence of a given string.
 *
 * @param string String to search through
 * @param searchString The string to search for
 * @param position Start of searching. Default is `0`
 * @returns Index of the first occurrence of a given string
 */
export declare function indexOf(string: string, searchString: string, position?: number | undefined): number;
/**
 * This function mirrors the `lastIndexOf` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Searches this string and returns the index of the last occurrence of the specified substring.
 *
 * @param string String to search through
 * @param searchString Substring to search for
 * @param position The index at which to begin searching. If omitted, the search begins at the end
 *   of the string. Default is `undefined`
 * @returns Index of the last occurrence of searchString found, or -1 if not found.
 */
export declare function lastIndexOf(string: string, searchString: string, position?: number): number;
/**
 * This function mirrors the `length` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes. Since `length` appears to be a
 * reserved keyword, the function was renamed to `stringLength`
 *
 * Returns the length of a string.
 *
 * @param string String to return the length for
 * @returns Number that is length of the starting string
 */
export declare function stringLength(string: string): number;
/**
 * This function mirrors the `normalize` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns the Unicode Normalization Form of this string.
 *
 * @param string The starting string
 * @param form Form specifying the Unicode Normalization Form. Default is `'NFC'`
 * @returns A string containing the Unicode Normalization Form of the given string.
 */
export declare function normalize(string: string, form: "NFC" | "NFD" | "NFKC" | "NFKD" | "none"): string;
/**
 * Compares two strings using an ordinal comparison approach based on the specified collation
 * options. This function uses the built-in `localeCompare` method with the 'en' locale and the
 * provided collation options to compare the strings.
 *
 * @param string1 The first string to compare.
 * @param string2 The second string to compare.
 * @param options Optional. The collation options used for comparison.
 * @returns A number indicating the result of the comparison: - Negative value if string1 precedes
 *   string2 in sorting order. - Zero if string1 and string2 are equivalent in sorting order. -
 *   Positive value if string1 follows string2 in sorting order.
 */
export declare function ordinalCompare(string1: string, string2: string, options?: Intl.CollatorOptions): number;
/**
 * This function mirrors the `padEnd` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Pads this string with another string (multiple times, if needed) until the resulting string
 * reaches the given length. The padding is applied from the end of this string.
 *
 * @param string String to add padding too
 * @param targetLength The length of the resulting string once the starting string has been padded.
 *   If value is less than or equal to length(string), then string is returned as is.
 * @param padString The string to pad the current string with. If padString is too long to stay
 *   within targetLength, it will be truncated. Default is `" "`
 * @returns String with appropriate padding at the end
 */
export declare function padEnd(string: string, targetLength: number, padString?: string): string;
/**
 * This function mirrors the `padStart` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Pads this string with another string (multiple times, if needed) until the resulting string
 * reaches the given length. The padding is applied from the start of this string.
 *
 * @param string String to add padding too
 * @param targetLength The length of the resulting string once the starting string has been padded.
 *   If value is less than or equal to length(string), then string is returned as is.
 * @param padString The string to pad the current string with. If padString is too long to stay
 *   within the targetLength, it will be truncated from the end. Default is `" "`
 * @returns String with of specified targetLength with padString applied from the start
 */
export declare function padStart(string: string, targetLength: number, padString?: string): string;
/**
 * This function mirrors the `slice` function from the JavaScript Standard String object. It handles
 * Unicode code points instead of UTF-16 character codes.
 *
 * Extracts a section of this string and returns it as a new string, without modifying the original
 * string.
 *
 * @param string The starting string
 * @param indexStart The index of the first character to include in the returned substring.
 * @param indexEnd The index of the first character to exclude from the returned substring.
 * @returns A new string containing the extracted section of the string.
 */
export declare function slice(string: string, indexStart: number, indexEnd?: number): string;
/**
 * This function mirrors the `split` function from the JavaScript Standard String object. It handles
 * Unicode code points instead of UTF-16 character codes.
 *
 * Takes a pattern and divides the string into an ordered list of substrings by searching for the
 * pattern, puts these substrings into an array, and returns the array.
 *
 * @param string The string to split
 * @param separator The pattern describing where each split should occur
 * @param splitLimit Limit on the number of substrings to be included in the array. Splits the
 *   string at each occurrence of specified separator, but stops when limit entries have been placed
 *   in the array.
 * @returns An array of strings, split at each point where separator occurs in the starting string.
 *   Returns undefined if separator is not found in string.
 */
export declare function split(string: string, separator: string | RegExp, splitLimit?: number): string[];
/**
 * This function mirrors the `startsWith` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Determines whether the string begins with the characters of a specified string, returning true or
 * false as appropriate.
 *
 * @param string String to search through
 * @param searchString The characters to be searched for at the start of this string.
 * @param position The start position at which searchString is expected to be found (the index of
 *   searchString's first character). Default is `0`
 * @returns True if the given characters are found at the beginning of the string, including when
 *   searchString is an empty string; otherwise, false.
 */
export declare function startsWith(string: string, searchString: string, position?: number): boolean;
/**
 * This function mirrors the `substring` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns a substring by providing start and end position.
 *
 * @param string String to be divided
 * @param begin Start position
 * @param end End position. Default is `End of string`
 * @returns Substring from starting string
 */
export declare function substring(string: string, begin: number, end?: number): string;
/**
 * This function mirrors the `toArray` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Converts a string to an array of string characters.
 *
 * @param string String to convert to array
 * @returns An array of characters from the starting string
 */
export declare function toArray(string: string): string[];
/** Determine whether the string is a `LocalizeKey` meant to be localized in Platform.Bible. */
export declare function isLocalizeKey(str: string): str is LocalizeKey;
/**
 * Escape RegExp special characters.
 *
 * You can also use this to escape a string that is inserted into the middle of a regex, for
 * example, into a character class.
 *
 * All credit to [`escape-string-regexp`](https://www.npmjs.com/package/escape-string-regexp) - this
 * function is simply copied directly from there to allow a common js export
 *
 * @example
 *
 *     import escapeStringRegexp from 'platform-bible-utils';
 *
 *     const escapedString = escapeStringRegexp('How much $ for a 🦄?');
 *     //=> 'How much \\$ for a 🦄\\?'
 *
 *     new RegExp(escapedString);
 */
export declare function escapeStringRegexp(string: string): string;
/**
 * Transforms a string or an array of strings into an array of regular expressions, ensuring that
 * the result is always an array.
 *
 * This function accepts a value that may be a single string, an array of strings, or `undefined`.
 * It then:
 *
 * - Converts each string into a `RegExp` object.
 * - If the input is an array containing nested arrays, it converts each string in the nested arrays
 *   into `RegExp` objects.
 * - Ensures that the result is always an array of `RegExp` objects or arrays of `RegExp` objects.
 *
 * @param stringStringMaybeArray - The value to be transformed, which can be a single string, an
 *   array of strings or arrays of strings, or `undefined`.
 * @returns An array of `RegExp` objects or arrays of `RegExp` objects. If the input is `undefined`,
 *   an empty array is returned.
 */
export declare function transformAndEnsureRegExpRegExpArray(stringStringMaybeArray: string | (string | string[])[] | undefined): (RegExp | RegExp[])[];
/**
 * Transforms a string or an array of strings into an array of regular expressions.
 *
 * This function accepts a value that may be a single string, an array of strings, or `undefined`.
 * It then:
 *
 * - Converts each string into a `RegExp` object.
 * - Ensures that the result is always an array of `RegExp` objects.
 *
 * @param stringMaybeArray - The value to be transformed, which can be a single string, an array of
 *   strings, or `undefined`.
 * @returns An array of `RegExp` objects. If the input is `undefined`, an empty array is returned.
 */
export declare function transformAndEnsureRegExpArray(stringMaybeArray: string | string[] | undefined): RegExp[];
/**
 * Determines whether a string contains one or more white space characters and no other characters.
 *
 * This implementation uses [dotnet's `Char.IsWhiteSpace` definition of white
 * space](https://learn.microsoft.com/en-us/dotnet/api/system.char.iswhitespace?view=net-9.0):
 *
 * ```ts
 * /^[\u000C\u000A\u000D\u0009\u000B\u0020\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\u0085]+$/.test(
 *   ch,
 * );
 * ```
 *
 * Note: This differs from
 * [`/\s/.test(ch)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes#:~:text=Matches%20a%20single%20white%20space%20character%2C%20including%20space)
 * (usually considered the determiner of what is white space in JavaScript) in that it does not
 * include ZWNBSP (U+FEFF) but rather includes NEXT LINE (U+0085)
 *
 * @param ch Single character or a string of characters
 * @returns `true` if the string consists of one or more white space characters and no other
 *   characters, `false` otherwise
 */
export declare function isWhiteSpace(ch: string): boolean;
/**
 * Converts PascalCase or camelCase string to kebab-case. To detect upper- and lower-case
 * characters, uses `.toUpperCase` and `.toLowerCase` to be locale-independent.
 *
 * Current implementation supports only UTF-16.
 *
 * Thanks to ChatGPT https://chatgpt.com/share/67c8aa44-e054-800c-8068-e1e6630081f7
 */
export declare function toKebabCase(input: string): string;
/**
 * Check that two objects are deeply equal, comparing members of each object and such
 *
 * @param a The first object to compare
 * @param b The second object to compare
 *
 *   WARNING: Objects like arrays from different iframes have different constructor function
 *   references even if they do the same thing, so this deep equality comparison fails objects that
 *   look the same but have different constructors because different constructors could produce
 *   false positives in [a few specific
 *   situations](https://github.com/planttheidea/fast-equals/blob/a41afc0a240ad5a472e47b53791e9be017f52281/src/comparator.ts#L96).
 *   This means that two objects like arrays from different iframes that look the same will fail
 *   this check. Please use some other means to check deep equality in those situations.
 *
 *   Note: This deep equality check considers `undefined` values on keys of objects NOT to be equal to
 *   not specifying the key at all. For example, `{ stuff: 3, things: undefined }` and `{ stuff: 3
 *   }` are not considered equal in this case
 *
 *   - For more information and examples, see [this
 *       CodeSandbox](https://codesandbox.io/s/deepequallibrarycomparison-4g4kk4?file=/src/index.mjs).
 *
 * @returns True if a and b are deeply equal; false otherwise
 */
export declare function deepEqual(a: unknown, b: unknown): boolean;
/**
 * Check if one object is a subset of the other object. "Subset" means that all properties of one
 * object are present in the other object, and if they are present that all values of those
 * properties are deeply equal. Sub-objects are also checked to be subsets of the corresponding
 * sub-object in the other object.
 *
 * @example ObjB is a subset of objA given these objects:
 *
 * ```ts
 * objA = { name: 'Alice', age: 30, address: { city: 'Seattle', state: 'Washington' } };
 * objB = { name: 'Alice', address: { city: 'Seattle' } };
 * ```
 *
 * It is important to note that only arrays of primitives (i.e., booleans, numbers, strings) are
 * supported. In particular, objects in arrays will not be checked for deep equality. Also, presence
 * in an array is all this checks, not the number of times that an item appears in an array. `[1,
 * 1]` is a subset of `[1]`.
 *
 * @param objectWithAllProperties Object to be checked if it is a superset of
 *   `objectWithPartialProperties`
 * @param objectWithPartialProperties Object to be checked if it is a subset of
 *   `objectWithAllProperties`
 * @returns True if `objectWithAllProperties` contains all the properties of
 *   `objectWithPartialProperties` and all values of those properties are deeply equal
 */
export declare function isSubset(objectWithAllProperties: unknown, objectWithPartialProperties: unknown): boolean;
/**
 * Converts a JavaScript value to a JSON string, changing `undefined` properties in the JavaScript
 * object to `null` properties in the JSON string.
 *
 * WARNING: `null` values will become `undefined` values after passing through {@link serialize} then
 * {@link deserialize}. For example, `{ a: 1, b: undefined, c: null }` will become `{ a: 1, b:
 * undefined, c: undefined }`. If you are passing around user data that needs to retain `null`
 * values, you should wrap them yourself in a string before using this function. Alternatively, you
 * can write your own replacer that will preserve `null` in a way that you can recover later.
 *
 * @param value A JavaScript value, usually an object or array, to be converted.
 * @param replacer A function that transforms the results. Note that all `undefined` values returned
 *   by the replacer will be further transformed into `null` in the JSON string.
 * @param space Adds indentation, white space, and line break characters to the return-value JSON
 *   text to make it easier to read. See the `space` parameter of `JSON.stringify` for more
 *   details.
 */
export declare function serialize(value: unknown, replacer?: (this: unknown, key: string, value: unknown) => unknown, space?: string | number): string;
/**
 * Converts a JSON string into a value, converting all `null` properties from JSON into `undefined`
 * in the returned JavaScript value/object.
 *
 * WARNING: `null` values will become `undefined` values after passing through {@link serialize} then
 * {@link deserialize}. For example, `{ a: 1, b: undefined, c: null }` will become `{ a: 1, b:
 * undefined, c: undefined }`. If you are passing around user data that needs to retain `null`
 * values, you should wrap them yourself in a string before using this function. Alternatively, you
 * can write your own replacer that will preserve `null` in a way that you can recover later.
 *
 * @param value A valid JSON string.
 * @param reviver A function that transforms the results. This function is called for each member of
 *   the object. If a member contains nested objects, the nested objects are transformed before the
 *   parent object is. Note that `null` values are converted into `undefined` values after the
 *   reviver has run.
 */
export declare function deserialize(value: string, reviver?: (this: unknown, key: string, value: unknown) => unknown): any;
/**
 * Check to see if the value is serializable without losing information
 *
 * @param value Value to test
 * @returns True if serializable; false otherwise
 *
 *   Note: the values `undefined` and `null` are serializable (on their own or in an array), but
 *   `null` values get transformed into `undefined` when serializing/deserializing.
 *
 *   WARNING: This is inefficient right now as it stringifies, parses, stringifies, and === the value.
 *   Please only use this if you need to
 *
 *   DISCLAIMER: this does not successfully detect that values are not serializable in some cases:
 *
 *   - Losses of removed properties like functions and `Map`s
 *   - Class instances (not deserializable into class instances without special code)
 *
 *   We intend to improve this in the future if it becomes important to do so. See [`JSON.stringify`
 *   documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description)
 *   for more information.
 */
export declare function isSerializable(value: unknown): boolean;
/**
 * HTML Encodes the provided string. Thanks to ChatGPT
 *
 * @param str String to HTML encode
 * @returns HTML-encoded string
 */
export declare const htmlEncode: (str: string) => string;
/**
 * Retrieves the current locale of the user's environment.
 *
 * @returns A string representing the current locale. If the locale cannot be determined, the
 *   function returns an empty string.
 */
export declare function getCurrentLocale(): string;
/**
 * Formats a number according to the locale and formatting options of this NumberFormat object
 *
 * @example FormatBytes(1024) => "1 KB"
 *
 * @example FormatBytes(1024, 0) => "1 KB"
 *
 * @param fileSize Number to format
 * @param decimals Number of decimal places to round to
 * @returns String representing the given number formatted according to the locale and formatting
 *   options of this NumberFormat object
 */
export declare function formatBytes(fileSize: number, decimals?: number): string;
/**
 * Ensures that the given input is returned as an array.
 *
 * This function takes a value that might be a single item, an array, or `undefined` and returns it
 * as an array:
 *
 * - If the input is `undefined`, an empty array is returned.
 * - If the input is already an array, it is returned as-is.
 * - If the input is a single item, it is wrapped in an array.
 *
 * @typeParam T - The type of the elements in the array.
 * @param maybeArray - The value that may be a single item, an array, or `undefined`.
 * @returns An array containing the input value(s). If the input is `undefined`, an empty array is
 *   returned.
 */
export declare function ensureArray<T>(maybeArray: T | T[] | undefined): T[];
/**
 * Get a localized string representation of the time between two dates
 *
 * @example
 *
 * `since` = 3 Aug 2024 8:00 AM
 *
 * `to` = 5 Aug 2024 8:000 AM
 *
 * Returns: "two days ago"
 *
 * @param since "Destination" time. time against which to get the time span.
 * @param to "Starting" time. Time span will be formatted relative to `to`. Defaults to `new Date()`
 * @returns Time span in words from `to` to `since`
 */
export declare function formatTimeSpan(relativeTimeFormatter: Intl.RelativeTimeFormat, since: Date, to?: Date): string;
/**
 * Modifier keys that don't constitute typed input
 *
 * Sourced from
 * https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values#modifier_keys
 */
export declare const MODIFIER_KEYS: Set<string>;
/** Localized string value associated with this key */
export type LocalizedStringValue = string;
/**
 * Date in YYYY-MM-DD format
 *
 * Use regex `^\d\d\d\d-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$` to test.
 *
 * Thanks to Vinod at https://stackoverflow.com/a/22061879 for the regex.
 */
export type DateYYYYMMDD = `${number}-${number}-${number}`;
/** The data an extension provides to inform Platform.Bible of the localized strings it provides. */
export interface LocalizedStringDataContribution {
	[k: string]: unknown;
	metadata?: StringsMetadata;
	localizedStrings?: {
		[k: string]: LanguageStrings;
	};
}
/**
 * Map whose keys are localized string keys and whose values provide additional non-locale-specific
 * information about the localized string key
 */
export interface StringsMetadata {
	[k: LocalizeKey]: StringMetadata;
}
/** Additional non-locale-specific information about a localized string key */
export interface StringMetadata {
	[k: string]: unknown;
	/**
	 * Localized string key from which to get this value if one does not exist in the specified
	 * language. If a new key/value pair needs to be made to replace an existing one, this could help
	 * smooth over the transition if the meanings are close enough
	 *
	 * You can use Paratext 9 Localized String Keys here. Be sure to escape any % signs with a
	 * backslash `\`.
	 */
	fallbackKey?: LocalizeKey;
	/**
	 * Additional information provided by developers in English to help the translator to know how to
	 * translate this localized string accurately
	 */
	notes?: string;
	/**
	 * If this property is filled, the localized string is deprecated. Contains information about the
	 * deprecation.
	 */
	deprecationInfo?: LocalizedStringDeprecationInfo;
}
/**
 * Contains information about the deprecation of a localized string key, including the date of
 * deprecation and the reason.
 */
export interface LocalizedStringDeprecationInfo {
	[k: string]: unknown;
	/**
	 * Date of deprecation. Must be in YYYY-MM-DD format e.g. 2024-11-13.
	 *
	 * Tested against regex `^\d\d\d\d-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$`.
	 *
	 * Thanks to Vinod at https://stackoverflow.com/a/22061879 for the regex.
	 */
	date: DateYYYYMMDD;
	/**
	 * Should contain the reason for deprecation and what to use instead in what contexts.
	 *
	 * @example Reworded to clarify the meaning. Use %my_key_2% instead.
	 */
	message: string;
}
/**
 * Map whose keys are localized string keys and whose values provide information about how to
 * localize strings for the localized string key
 */
export interface LanguageStrings {
	[k: LocalizeKey]: LocalizedStringValue;
}
/** JSON schema object that aligns with the LocalizedStringDataContribution type */
export declare const localizedStringsDocumentSchema: {
	$schema: string;
	title: string;
	description: string;
	type: string;
	properties: {
		metadata: {
			$ref: string;
		};
		localizedStrings: {
			type: string;
			additionalProperties: {
				$ref: string;
			};
		};
	};
	$defs: {
		languageStrings: {
			description: string;
			type: string;
			patternProperties: {
				"^%[\\w\\-\\.]+%$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		localizedStringValue: {
			description: string;
			type: string;
		};
		stringsMetadata: {
			description: string;
			type: string;
			patternProperties: {
				"^%[\\w\\-\\.]+%$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		stringMetadata: {
			description: string;
			type: string;
			properties: {
				fallbackKey: {
					description: string;
					type: string;
					pattern: string;
					tsType: string;
				};
				notes: {
					description: string;
					type: string;
				};
				deprecationInfo: {
					description: string;
					$ref: string;
				};
			};
		};
		localizedStringDeprecationInfo: {
			description: string;
			type: string;
			properties: {
				date: {
					description: string;
					type: string;
					pattern: string;
					tsType: string;
				};
				message: {
					description: string;
					type: string;
				};
			};
			required: string[];
		};
		localizeKey: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
	};
};
export type ResourceType = "ScriptureResource" | "EnhancedResource" | "XmlResource" | "SourceLanguageResource";
export type DblResourceData = {
	dblEntryUid: string;
	displayName: string;
	fullName: string;
	bestLanguageName: string;
	type: ResourceType;
	size: number;
	installed: boolean;
	updateAvailable: boolean;
	projectId: string;
};
/** The data an extension provides to inform Platform.Bible of the settings it provides */
export type SettingsContribution = SettingsGroup | SettingsGroup[];
/** A description of an extension's setting entry */
export type Setting = ExtensionControlledSetting;
/** Setting definition that is validated by the extension. */
export type ExtensionControlledSetting = SettingBase & ModifierExtensionControlled;
/** Base information needed to describe a setting entry */
export type SettingBase = StateBase & {
	[k: string]: unknown;
	/** LocalizeKey that displays in the settings dialog as the setting name */
	label: LocalizeKey;
	/** LocalizeKey that displays in the settings dialog to describe the setting */
	description?: LocalizeKey;
	/**
	 * Boolean that controls whether a setting should be hidden or not. If hidden, the setting will
	 * not show up in the settings dialog in `paranext-core`, and thus will not be configurable by the
	 * user unless an extension provides a way to interact with the setting.
	 */
	isHidden?: boolean;
};
/** The data an extension provides to inform Platform.Bible of the project settings it provides */
export type ProjectSettingsContribution = ProjectSettingsGroup | ProjectSettingsGroup[];
/** A description of an extension's setting entry */
export type ProjectSetting = ExtensionControlledProjectSetting;
/** Setting definition that is validated by the extension. */
export type ExtensionControlledProjectSetting = ProjectSettingBase & ModifierExtensionControlled;
/** Base information needed to describe a project setting entry */
export type ProjectSettingBase = SettingBase & ModifierProject;
/** A description of an extension's user state entry */
export type UserState = ExtensionControlledState;
/** State definition that is validated by the extension. */
export type ExtensionControlledState = StateBase & ModifierExtensionControlled;
/** Group of related settings definitions */
export interface SettingsGroup {
	[k: string]: unknown;
	/** LocalizeKey that displays in the settings dialog as the group name */
	label: LocalizeKey;
	/** LocalizeKey that displays in the settings dialog to describe the group */
	description?: LocalizeKey;
	properties: SettingProperties;
}
/** Object whose keys are setting IDs and whose values are settings objects */
export interface SettingProperties {
	[k: ReferencedItem]: Setting;
}
/** Base information needed to describe a state entry */
export interface StateBase {
	[k: string]: unknown;
	/** Default value for the state/setting */
	default: unknown;
	/**
	 * A state/setting ID whose value to set to this state/setting's starting value the first time
	 * this state/setting is loaded
	 */
	derivesFrom?: ReferencedItem;
}
/**
 * Modifies state/setting type to be extension-controlled. "Extension-controlled" means the
 * extension provides the component and the validator for the state/setting, so the state/setting is
 * controlled by the extension.
 */
export interface ModifierExtensionControlled {
	[k: string]: unknown;
	platformType?: undefined;
	type?: undefined;
}
/** Group of related settings definitions */
export interface ProjectSettingsGroup {
	[k: string]: unknown;
	/** LocalizeKey that displays in the project settings dialog as the group name */
	label: LocalizeKey;
	/** LocalizeKey that displays in the project settings dialog to describe the group */
	description?: LocalizeKey;
	properties: ProjectSettingProperties;
}
/** Object whose keys are setting IDs and whose values are settings objects */
export interface ProjectSettingProperties {
	[k: ReferencedItem]: ProjectSetting;
}
/**
 * Defines a set of optional properties that can be used to filter projects based on their
 * `projectInterface` and Project Data Provider Factory Ids.
 */
export interface ModifierProject {
	/**
	 * String representation of `RegExp` pattern(s) to match against projects' `projectInterface`s
	 * (using the
	 * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) to determine if they should be included.
	 *
	 * If this is one string, it will be matched against `projectInterface`s. If this is an array,
	 * each entry is handled based on its type (at least one entry must match for this filter
	 * condition to pass):
	 *
	 * - If the entry is a string, it will be matched against each `projectInterface`. If any match, the
	 *   project will pass this filter condition
	 * - If the entry is an array of strings, each will be matched against each `projectInterface`. If
	 *   every string matches against at least one `projectInterface`, the project will pass this
	 *   filter condition
	 *
	 * In other words, each entry in the first-level array is `OR`'ed together. Each entry in
	 * second-level arrays (arrays within the first-level array) are `AND`'ed together.
	 *
	 * Defaults to all `ProjectInterfaces`, so all projects that do not match
	 * `excludeProjectInterfaces` will be included
	 *
	 * @example
	 *
	 * ```typescript
	 * includeProjectInterfaces: ['one', ['two', 'three']];
	 * ```
	 *
	 * This filter condition will succeed on projects whose `projectInterface`s fulfill at least one
	 * of the following conditions (At least one entry in the array must match):
	 *
	 * - Include `one`
	 * - Include both `two` and `three`.
	 */
	includeProjectInterfaces?: undefined | string | (string | string[])[];
	/**
	 * String representation of `RegExp` pattern(s) to match against projects' `projectInterface`s
	 * (using the
	 * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) to determine if they should absolutely not be included even if they match with
	 * `includeProjectInterfaces`.
	 *
	 * If this is one string, it will be matched against `projectInterface`s. If this is an array,
	 * each entry is handled based on its type (at least one entry must match for this filter
	 * condition to exclude the project):
	 *
	 * - If the entry is a string, it will be matched against each `projectInterface`. If any match, the
	 *   project will pass this filter condition and exclude the project
	 * - If the entry is an array of strings, each will be matched against each `projectInterface`. If
	 *   every string matches against at least one `projectInterface`, the project will pass this
	 *   filter condition and exclude the project
	 *
	 * In other words, each entry in the first-level array is `OR`'ed together. Each entry in
	 * second-level arrays (arrays within the first-level array) are `AND`'ed together.
	 *
	 * Defaults to no `ProjectInterfaces`, so all projects that match `includeProjectInterfaces` will
	 * be included
	 *
	 * @example
	 *
	 * ```typescript
	 * excludeProjectInterfaces: ['one', ['two', 'three']];
	 * ```
	 *
	 * This filter condition will succeed and exclude projects whose `projectInterface`s fulfill at
	 * least one of the following conditions (At least one entry in the array must match):
	 *
	 * - Include `one`
	 * - Include both `two` and `three`.
	 */
	excludeProjectInterfaces?: undefined | string | (string | string[])[];
	/**
	 * String representation of `RegExp` pattern(s) to match against the Project Data Provider Factory
	 * Ids that provided each project's metadata (using the
	 * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) to determine if the projects should be included.
	 *
	 * Defaults to all Project Data Provider Factory Ids, so all projects that do not match
	 * `excludePdpFactoryIds` will be included
	 */
	includePdpFactoryIds?: undefined | string | string[];
	/**
	 * String representation of `RegExp` pattern(s) to match against the Project Data Provider Factory
	 * Ids that provided each project's metadata (using the
	 * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) to determine if the projects should absolutely not be included even if they match
	 * with `includeProjectInterfaces`.
	 *
	 * Defaults to none, so all projects that match `includePdpFactoryIds` will be included
	 */
	excludePdpFactoryIds?: undefined | string | string[];
}
/** The data an extension provides to inform Platform.Bible of the user state it provides */
export interface UserStateContribution {
	[k: ReferencedItem]: UserState;
}
/** The data an extension provides to inform Platform.Bible of the project state it provides */
export interface ProjectStateContribution {
	[k: ReferencedItem]: UserState;
}
/** JSON schema object that aligns with the ProjectSettingsContribution type */
export declare const projectSettingsDocumentSchema: {
	$schema: string;
	title: string;
	description: string;
	anyOf: ({
		$ref: string;
		type?: undefined;
		items?: undefined;
	} | {
		type: string;
		items: {
			$ref: string;
		};
		$ref?: undefined;
	})[];
	$defs: {
		projectSettingsContribution: {
			description: string;
			anyOf: ({
				$ref: string;
				type?: undefined;
				items?: undefined;
			} | {
				type: string;
				items: {
					$ref: string;
				};
				$ref?: undefined;
			})[];
		};
		projectSettingsGroup: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				description: {
					description: string;
					$ref: string;
				};
				properties: {
					$ref: string;
				};
			};
			required: string[];
		};
		projectSettingProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		projectSetting: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledProjectSetting: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		projectSettingBase: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		modifierProject: {
			description: string;
			type: string;
			properties: {
				includeProjectInterfaces: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							anyOf: ({
								type: string;
								items?: undefined;
							} | {
								type: string;
								items: {
									type: string;
								};
							})[];
						};
					})[];
				};
				excludeProjectInterfaces: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							anyOf: ({
								type: string;
								items?: undefined;
							} | {
								type: string;
								items: {
									type: string;
								};
							})[];
						};
					})[];
				};
				includePdpFactoryIds: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							type: string;
						};
					})[];
				};
				excludePdpFactoryIds: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							type: string;
						};
					})[];
				};
			};
		};
		settingsContribution: {
			description: string;
			anyOf: ({
				$ref: string;
				type?: undefined;
				items?: undefined;
			} | {
				type: string;
				items: {
					$ref: string;
				};
				$ref?: undefined;
			})[];
		};
		settingsGroup: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				description: {
					description: string;
					$ref: string;
				};
				properties: {
					$ref: string;
				};
			};
			required: string[];
		};
		settingProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w-]+\\.[\\w-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		setting: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledSetting: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		settingBase: {
			description: string;
			allOf: ({
				$ref: string;
				type?: undefined;
				properties?: undefined;
				required?: undefined;
			} | {
				type: string;
				properties: {
					label: {
						description: string;
						$ref: string;
					};
					description: {
						description: string;
						$ref: string;
					};
					isHidden: {
						description: string;
						type: string;
					};
				};
				required: string[];
				$ref?: undefined;
			})[];
		};
		projectStateContribution: {
			description: string;
			$ref: string;
		};
		userStateContribution: {
			description: string;
			$ref: string;
		};
		userStateProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		userState: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledState: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		modifierExtensionControlled: {
			description: string;
			not: {
				anyOf: {
					type: string;
					required: string[];
				}[];
			};
		};
		stateBase: {
			description: string;
			type: string;
			properties: {
				default: {
					description: string;
					type: string;
				};
				derivesFrom: {
					description: string;
					$ref: string;
				};
			};
			required: string[];
		};
		localizeKey: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
		id: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
	};
};
/** JSON schema object that aligns with the {@link SettingsContribution} type */
export declare const settingsDocumentSchema: {
	$schema: string;
	title: string;
	description: string;
	anyOf: ({
		$ref: string;
		type?: undefined;
		items?: undefined;
	} | {
		type: string;
		items: {
			$ref: string;
		};
		$ref?: undefined;
	})[];
	$defs: {
		projectSettingsContribution: {
			description: string;
			anyOf: ({
				$ref: string;
				type?: undefined;
				items?: undefined;
			} | {
				type: string;
				items: {
					$ref: string;
				};
				$ref?: undefined;
			})[];
		};
		projectSettingsGroup: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				description: {
					description: string;
					$ref: string;
				};
				properties: {
					$ref: string;
				};
			};
			required: string[];
		};
		projectSettingProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		projectSetting: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledProjectSetting: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		projectSettingBase: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		modifierProject: {
			description: string;
			type: string;
			properties: {
				includeProjectInterfaces: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							anyOf: ({
								type: string;
								items?: undefined;
							} | {
								type: string;
								items: {
									type: string;
								};
							})[];
						};
					})[];
				};
				excludeProjectInterfaces: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							anyOf: ({
								type: string;
								items?: undefined;
							} | {
								type: string;
								items: {
									type: string;
								};
							})[];
						};
					})[];
				};
				includePdpFactoryIds: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							type: string;
						};
					})[];
				};
				excludePdpFactoryIds: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							type: string;
						};
					})[];
				};
			};
		};
		settingsContribution: {
			description: string;
			anyOf: ({
				$ref: string;
				type?: undefined;
				items?: undefined;
			} | {
				type: string;
				items: {
					$ref: string;
				};
				$ref?: undefined;
			})[];
		};
		settingsGroup: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				description: {
					description: string;
					$ref: string;
				};
				properties: {
					$ref: string;
				};
			};
			required: string[];
		};
		settingProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w-]+\\.[\\w-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		setting: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledSetting: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		settingBase: {
			description: string;
			allOf: ({
				$ref: string;
				type?: undefined;
				properties?: undefined;
				required?: undefined;
			} | {
				type: string;
				properties: {
					label: {
						description: string;
						$ref: string;
					};
					description: {
						description: string;
						$ref: string;
					};
					isHidden: {
						description: string;
						type: string;
					};
				};
				required: string[];
				$ref?: undefined;
			})[];
		};
		projectStateContribution: {
			description: string;
			$ref: string;
		};
		userStateContribution: {
			description: string;
			$ref: string;
		};
		userStateProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		userState: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledState: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		modifierExtensionControlled: {
			description: string;
			not: {
				anyOf: {
					type: string;
					required: string[];
				}[];
			};
		};
		stateBase: {
			description: string;
			type: string;
			properties: {
				default: {
					description: string;
					type: string;
				};
				derivesFrom: {
					description: string;
					$ref: string;
				};
			};
			required: string[];
		};
		localizeKey: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
		id: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
	};
};
/** The data an extension provides to inform Platform.Bible of the themes it provides. */
export type ThemeContribution = ThemeFamiliesById;
/** Object whose keys are theme family ids and whose values are {@link ThemeFamily}. */
export interface ThemeFamiliesById {
	[themeFamilyId: string]: ThemeFamily | undefined;
}
/**
 * A group of related themes. Each key is a theme type, and each value is a {@link ThemeDefinition}.
 *
 * A theme type indicates the kind of theme (e.g. light, dark). Some UI elements use the theme type
 * to determine how to look. Colors not present in the theme will fall back to the built-in colors
 * for this type.
 */
export interface ThemeFamily {
	[themeType: string]: ThemeDefinition | undefined;
	light?: ThemeDefinition;
	dark?: ThemeDefinition;
}
/**
 * The data an extension provides for one individual theme. Each theme has a type (e.g. light, dark)
 * and belongs to a theme family. An extension can provide multiple themes with
 * {@link ThemeContribution}.
 */
export interface ThemeDefinition {
	[k: string]: unknown;
	/** LocalizeKey that is the display name for the theme */
	label: LocalizeKey;
	/**
	 * Theme colors and other CSS variable properties that adjust the looks of the application. These
	 * are applied in CSS properties using `hsl(var(--variableName))` or Tailwind classes like
	 * `tw-bg-primary`
	 *
	 * See the wiki's [Matching Application
	 * Theme](https://github.com/paranext/paranext-extension-template/wiki/Extension-Anatomy#matching-application-theme)
	 * section for more information.
	 */
	cssVariables: ThemeCssVariables;
}
/**
 * Theme colors and other CSS variable properties that adjust the looks of the application. These
 * are applied in CSS properties using `hsl(var(--variableName))` or Tailwind classes like
 * `tw-bg-primary`
 *
 * See the wiki's [Matching Application
 * Theme](https://github.com/paranext/paranext-extension-template/wiki/Extension-Anatomy#matching-application-theme)
 * section for more information.
 */
export interface ThemeCssVariables {
	[variableName: string]: string | undefined;
	background?: string;
	foreground?: string;
	card?: string;
	"card-foreground"?: string;
	popover?: string;
	"popover-foreground"?: string;
	primary?: string;
	"primary-foreground"?: string;
	secondary?: string;
	"secondary-foreground"?: string;
	muted?: string;
	"muted-foreground"?: string;
	accent?: string;
	"accent-foreground"?: string;
	destructive?: string;
	"destructive-foreground"?: string;
	border?: string;
	input?: string;
	ring?: string;
	"sidebar-background"?: string;
	"sidebar-foreground"?: string;
	"sidebar-primary"?: string;
	"sidebar-primary-foreground"?: string;
	"sidebar-accent"?: string;
	"sidebar-accent-foreground"?: string;
	"sidebar-border"?: string;
	"sidebar-ring"?: string;
	radius?: string;
}
export declare const themeDocumentSchema: {
	$schema: string;
	title: string;
	description: string;
	anyOf: {
		$ref: string;
	}[];
	$defs: {
		themeCssVariables: {
			description: string;
			type: string;
			properties: {
				background: {
					type: string;
				};
				foreground: {
					type: string;
				};
				card: {
					type: string;
				};
				"card-foreground": {
					type: string;
				};
				popover: {
					type: string;
				};
				"popover-foreground": {
					type: string;
				};
				primary: {
					type: string;
				};
				"primary-foreground": {
					type: string;
				};
				secondary: {
					type: string;
				};
				"secondary-foreground": {
					type: string;
				};
				muted: {
					type: string;
				};
				"muted-foreground": {
					type: string;
				};
				accent: {
					type: string;
				};
				"accent-foreground": {
					type: string;
				};
				destructive: {
					type: string;
				};
				"destructive-foreground": {
					type: string;
				};
				border: {
					type: string;
				};
				input: {
					type: string;
				};
				ring: {
					type: string;
				};
				"sidebar-background": {
					type: string;
				};
				"sidebar-foreground": {
					type: string;
				};
				"sidebar-primary": {
					type: string;
				};
				"sidebar-primary-foreground": {
					type: string;
				};
				"sidebar-accent": {
					type: string;
				};
				"sidebar-accent-foreground": {
					type: string;
				};
				"sidebar-border": {
					type: string;
				};
				"sidebar-ring": {
					type: string;
				};
				radius: {
					type: string;
				};
			};
			additionalProperties: {
				anyOf: {
					type: string;
				}[];
			};
		};
		themeDefinition: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					type: string;
					pattern: string;
					tsType: string;
				};
				cssVariables: {
					$ref: string;
				};
			};
			required: string[];
		};
		themeFamily: {
			description: string;
			type: string;
			properties: {
				light: {
					$ref: string;
				};
				dark: {
					$ref: string;
				};
			};
			additionalProperties: {
				anyOf: ({
					$ref: string;
					type?: undefined;
				} | {
					type: string;
					$ref?: undefined;
				})[];
			};
		};
		themeFamiliesById: {
			description: string;
			type: string;
			additionalProperties: {
				anyOf: ({
					$ref: string;
					type?: undefined;
				} | {
					type: string;
					$ref?: undefined;
				})[];
			};
		};
	};
};
/**
 * {@link ThemeDefinition} with some additional properties derived from the {@link ThemeFamiliesById}
 * it comes from to help with managing the theme
 */
export type ThemeDefinitionExpanded = ThemeDefinition & {
	/**
	 * Unique identifier for the {@link ThemeFamily} this theme is in.
	 *
	 * This is derived from the key of the {@link ThemeFamiliesById} this theme is in
	 */
	themeFamilyId: string;
	/**
	 * The kind of theme (e.g. light, dark). Some UI elements use the theme type to determine how to
	 * look. Colors not present in the theme will fall back to the built-in colors for this type.
	 *
	 * This is derived from the key of the {@link ThemeFamily} this theme is in
	 */
	type: string;
	/**
	 * Unique identifier for this theme.
	 *
	 * This is derived by combining the theme family and type
	 */
	id: string;
};
/**
 * Replaces {@link ThemeDefinition} with {@link ThemeDefinitionExpanded} recursively in the provided
 * type. Modifies the type to what is used in the theme service.
 */
export type ExpandThemeDefinition<T> = ReplaceType<T, ThemeDefinition, ThemeDefinitionExpanded>;
/**
 * {@link ThemeFamily} with all {@link ThemeDefinition} replaced by {@link ThemeDefinitionExpanded}.
 * This is used in the theme service
 */
export type ThemeFamilyExpanded = ExpandThemeDefinition<ThemeFamily>;
/**
 * {@link ThemeFamiliesById} with all {@link ThemeDefinition} replaced by
 * {@link ThemeDefinitionExpanded}. This is used in the theme service
 */
export type ThemeFamiliesByIdExpanded = ExpandThemeDefinition<ThemeFamiliesById>;
/** ID for the style element the theme styles should go into */
export declare const THEME_STYLE_ELEMENT_ID = "theme-styles";
/**
 * Add the derived properties in {@link ThemeDefinitionExpanded} to {@link ThemeDefinition}s in the
 * given {@link ThemeFamiliesById} and fill in any missing `cssVariables` in the theme definitions
 * with those from the default themes.
 *
 * Does not modify the input object.
 *
 * @param themeFamiliesById Theme families to expand with the additional derived properties
 * @param defaultThemeFamily If provided, themes from this family are used to fill in missing
 *   `cssVariables` in the theme definitions to make sure each theme definition has all necessary
 *   `cssVariables`
 * @returns The expanded theme families
 */
export declare function expandThemeContribution(themeFamiliesById: ThemeFamiliesById, defaultThemeFamily: ThemeFamily | undefined): ThemeFamiliesByIdExpanded;
/** Gets the CSS stylesheet that should be applied for the given theme */
export declare function getStylesheetForTheme(theme: ThemeDefinitionExpanded): string;
/**
 * Applies a CSS stylesheet for the provided theme to the current window
 *
 * WARNING: THIS MUST BE BOUND TO `window` IN ORDER TO USE!
 *
 * ```ts
 * applyThemeStylesheet.bind(window)()`
 * ```
 *
 * @param theme Theme to apply
 * @param previousStyleElement Previous style element if applicable
 * @param styleElementIdSuffix Suffix to apply to the ID of the new style element. Will be
 *   {@link THEME_STYLE_ELEMENT_ID} with a dash and the suffix added to it
 * @returns
 */
export declare function applyThemeStylesheet(this: Window, theme: ThemeDefinitionExpanded, previousStyleElement?: HTMLStyleElement, styleElementIdSuffix?: string): HTMLStyleElement;
/**
 * Represents information about where a USJ node resides in the `content` array of its parent.
 * `parent` is a reference to the node's parent, and `index` represents the numeric index inside of
 * `parent`'s content array.
 */
export type StackItem = {
	parent: MarkerObject | Usj;
	index: number;
};
/**
 * Stack of levels inside a USJ tree relative to a specific node. The top of the stack should always
 * be the root Usj object.
 */
export type WorkingStack = StackItem[];
/** Represents USJ formatted scripture with helpful utilities for working with it */
export declare class UsjReaderWriter implements IUsjReaderWriter {
	private readonly usj;
	private readonly markersMap;
	private readonly shouldAllowInvisibleCharacters;
	private parentMapInternal;
	private fragmentsByIndexInUsfmInternal;
	private indicesInUsfmByVerseRefInternal;
	private usfmInternal;
	constructor(usj: Usj, options?: UsjReaderWriterOptions);
	usjChanged(): void;
	findSingleValue<T>(jsonPathQuery: string): T | undefined;
	findParent<T>(jsonPathQuery: string): T | undefined;
	/**
	 * Determine if the passed in marker is the top-level USJ marker.
	 *
	 * Note that USJ markers that are not the top-level USJ markers technically should not occur, but
	 * they can occur. We should treat them like any other marker. They conform to
	 * {@link MarkerObject}, so it's not hard to do.
	 *
	 * @param marker Marker to test if it is USJ marker
	 * @returns `true` if it is a USJ marker; false otherwise
	 */
	static isTopLevelUsjMarker(marker: Usj | MarkerContent, workingStack: WorkingStack): marker is Usj;
	/**
	 * Determine if a fragment is a marker, not a text content string or some kind of position
	 * fragment that isn't actually a marker e.g. closing marker fragment
	 */
	private static isFragmentAMarker;
	private static createParentMapInternal;
	/** Viewing a Usj object as a tree, build a map to walk up the tree */
	private createUsjParentMap;
	/** Create the parent map if it doesn't already exist and return it */
	private get parentMap();
	/**
	 * Checks if two stack items are equal using shallow equivalence, testing the stack item
	 * properties for [strict
	 * equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality)
	 *
	 * Note that this requires the parent of the two stack items to have reference equality
	 */
	private static areStackItemsShallowEqual;
	/** Return the working stack applicable to the given node */
	private createWorkingStack;
	private static convertWorkingStackToJsonPath;
	private static convertWorkingStackAndPropertyToJsonPath;
	private convertJsonPathToWorkingStack;
	/**
	 * Extract textual notes (aka, "footnotes") from a full USJ object.
	 *
	 * @returns An array of MarkerObjects representing all textual notes found in the USJ content.
	 */
	findAllNotes(): MarkerObject[];
	/**
	 * Look through the USJ document for a token matching some condition
	 *
	 * @param token Token from which to start looking
	 * @param workingStack Working stack pointing to this token (should not include this token)
	 * @param skipTypes List of marker types to skip
	 * @param searchFunction Function that tokens will be passed into to determine if they are the
	 *   correct token. Stops searching and returns the token if this function returns `true`
	 * @returns Token matching condition tested by the search function
	 */
	private static findNextMatchingTokenUsingWorkingStack;
	/**
	 * Look through the USJ document for a node matching some condition
	 *
	 * @param node Node from which to start looking
	 * @param workingStack Working stack pointing to this node (should not include this node)
	 * @param skipTypes List of marker types to skip
	 * @param searchFunction Function that nodes will be passed into to determine if they are the
	 *   correct node. Stops searching and returns the node if this function returns `true`
	 * @returns Node matching condition tested by the search function
	 */
	private static findNextMatchingNodeUsingWorkingStack;
	nodeToJsonPath(node: MarkerObject): ContentJsonPath;
	nodeToUsfmVerseLocation(node: MarkerContent | Usj, nodeParent?: MarkerObject | MarkerContent[] | Usj, bookIdIfNotFound?: string): UsfmVerseLocation;
	jsonPathToUsfmVerseLocation(jsonPathQuery: string, bookIdIfNotFound?: string): UsfmVerseLocation;
	usjDocumentLocationToUsfmVerseLocation(usjLocation: UsjDocumentLocation, bookIdIfNotFound?: string): UsfmVerseLocation;
	/**
	 * Gets the book ID in the internal USJ document data corresponding to the book ID passed in.
	 *
	 * @param bookId The book ID to look up data in the USJ document for
	 * @returns If there isn't a book ID in the USJ document, {@link NO_BOOK_ID} will be returned
	 * @throws If the requested book is not found in the USJ data and there are other books
	 * @throws If there is no USJ content in the document whatsoever
	 */
	private getEffectiveBookId;
	/**
	 * Gets the index in USFM of the start of the verse (the backslash on the verse marker or the
	 * beginning of the chapter if verse 0 is provided)
	 */
	private getIndexInUsfmForVerseRef;
	/**
	 * Gets the verse ref that the provided index in USFM is in. Finds the closest verse ref before
	 * the index in USFM.
	 *
	 * WARNING: This does not include the verse range if there is one for this verse. If you need it,
	 * consider adding it in here (see {@link UsjReaderWriter.usjDocumentLocationToUsfmVerseLocation}).
	 * It's not already in here because then we would have to run
	 * {@link UsjReaderWriter.getIndexInUsfmForVerseRef} twice unless we did a refactor.
	 */
	private getVerseRefForIndexInUsfm;
	usfmLocationToUsjNodeAndDocumentLocation(usfmLocation: UsfmLocation | SerializedVerseRef): UsjNodeAndDocumentLocation;
	usfmLocationToUsjDocumentLocation(usfmLocation: UsfmLocation | SerializedVerseRef): UsjDocumentLocation;
	/**
	 * Determine if the USJ document location is pointing to a text content location instead of some
	 * location related to a marker object
	 *
	 * @param usjDocumentLocation USJ document location to test
	 * @returns `true` if the location is for text content; `false` otherwise
	 */
	static isUsjDocumentLocationForTextContent(usjDocumentLocation: UsjDocumentLocation): usjDocumentLocation is UsjTextContentLocation;
	/**
	 * Determine if the USJ document location in this node and document location is pointing to a text
	 * content location instead of some location related to a marker object
	 *
	 * @param usjNodeAndDocumentLocation USJ node and document location to test
	 * @returns `true` if the location is for text content; `false` otherwise
	 */
	static isUsjDocumentLocationForTextContent(usjNodeAndDocumentLocation: UsjNodeAndDocumentLocation): usjNodeAndDocumentLocation is UsjNodeAndDocumentLocation<UsjTextContentLocation>;
	verseRefToNextTextLocation(verseRef: SerializedVerseRef): UsjNodeAndDocumentLocation<UsjTextContentLocation>;
	findNextLocationOfMatchingText(startingPoint: UsjNodeAndDocumentLocation, text: string, maxTextLengthToSearch?: number): UsjNodeAndDocumentLocation<UsjTextContentLocation> | undefined;
	search(regex: RegExp): UsjSearchResult[];
	extractText(start: UsjNodeAndDocumentLocation, desiredLength: number): string;
	extractTextBetweenPoints(start: UsjNodeAndDocumentLocation, end: UsjNodeAndDocumentLocation, maxLength?: number): string;
	private static removeContentNodesFromArray;
	removeContentNodes(searchFunction: (potentiallyMatchingNode: MarkerContent) => boolean): number;
	/**
	 * Get `MarkerInfo` by marker name
	 *
	 * @param markerName Name of the marker for which to get `MarkerInfo`
	 * @returns `MarkerInfo` for the marker by name if the marker is in the markers map. `undefined`
	 *   if the marker is not in the markers map. If you have the marker type, you can build a fake
	 *   `MarkerInfo` for an unknown marker by making an object with just the type. If not, might be
	 *   best to throw an error since there probably isn't enough information available to do anything
	 *   with that marker.
	 */
	private getMarkerInfo;
	/**
	 * Gathers various pieces of information about a marker that are helpful for transforming the
	 * marker to USFM
	 *
	 * WARNING: this only has the ability to return the info for the marker to be used in USFM. If you
	 * need to use info for the marker in USX or USJ, this method needs to be modified.
	 *
	 * @param marker A USJ marker (can be USJ type) or a string which is the marker name
	 * @param scriptureFormat The Scripture format to get the marker information for. For example, if
	 *   you are using this marker info to transform the marker into USFM, this should be `usfm`.
	 *   Defaults to `usfm`
	 * @returns Various pieces of info about the marker
	 */
	private getInfoForMarker;
	/** Converts the text content of a marker to its equivalent in USFM */
	private textContentToUsfm;
	/**
	 * Merge an independent array of fragment info into an existing array of fragment info, offsetting
	 * the indices of the new fragments so their locations start from the end of the string
	 */
	private static mergeFragmentsInfoIntoExistingArray;
	/**
	 * Transforms the provided USJ marker into its opening marker representation in USFM
	 *
	 * Includes a newline before the marker if applicable. Generally also includes a space at the end.
	 *
	 * Opening markers generally look like the following:
	 *
	 * ```text
	 * \markerName leadingAttributes textContentAttribute attributeMarkers
	 * ```
	 *
	 * @param marker The marker to transform
	 * @param isInsideMarkerWithSameType `true` if this marker is inside another marker of the same
	 *   type. This is used to determine if a prefix should be added before the marker name.
	 * @returns String containing the marker information that should come before the contents of the
	 *   marker in USFM
	 */
	private openingMarkerToUsfm;
	/**
	 * Transforms the provided USJ marker into its closing marker representation in USFM
	 *
	 * Closing markers do not include the attributes listed as part of the opening markers (leading
	 * attributes, text content attributes, and attribute markers). They only include other kinds of
	 * attributes including the default attribute if present.
	 *
	 * Closing markers with only the default attribute present generally look like the following:
	 *
	 * ```text
	 * |defaultAttribute\markerName*
	 * ```
	 *
	 * Closing markers with at least one non-default attribute present generally look like the
	 * following:
	 *
	 * ```text
	 * |attributeName="AttributeValue" attributeName="AttributeValue"\markerName*
	 * ```
	 *
	 * @param marker The marker to transform
	 * @param isInsideMarkerWithSameType `true` if this marker is inside another marker of the same
	 *   type. This is used to determine if a prefix should be added before the marker name.
	 * @returns String containing the marker information that should come after the contents of the
	 *   marker in USFM
	 */
	private closingMarkerToUsfm;
	/**
	 * Determines whether this marker and all its content should be skipped entirely when outputting
	 * to USFM
	 *
	 * @param marker Marker to check
	 * @returns `true` if this marker should be skipped; `false` otherwise
	 */
	private shouldSkipOutputMarkerToUsfm;
	/** Removes one space at the end of the string if present */
	private static removeEndSpace;
	/**
	 * Add an opening or closing marker USFM representation to the end of a string of USFM
	 *
	 * @param usfm The USFM string to add the marker to
	 * @param marker The opening or closing marker to add to the USFM
	 * @param tokenParent Parent of the marker being added. Used to determine if this marker is nested
	 *   within another marker of the same type
	 * @param fragmentsInfo The array of fragment information built so far for the USFM string passed
	 *   in. THIS METHOD WILL MODIFY THE ARRAY PASSED IN; it will add new fragments that correspond to
	 *   the marker added.
	 * @returns Final USFM string with the marker added
	 */
	private addMarkerUsfmToString;
	toUsfm(): string;
	/**
	 * Returns a new {@link UsjDocumentLocation} based on the one passed in but with the offset
	 * provided. If the location passed in does not have an offset property, a shallow clone of the
	 * location will be returned with no changes.
	 */
	private static moveUsjDocumentLocationToNewOffset;
	/**
	 * Returns the offset of whatever kind that is found in the UsjDocumentLocation. Returns 0 if the
	 * location passed in does not have an offset property.
	 */
	private static getOffsetInUsjDocumentLocation;
	/**
	 * Split a USJ document JSONPath into the part before the property accessor (presumably
	 * `ContentJsonPath`, but this method does not check that this is true) and the property being
	 * accessed
	 *
	 * @param jsonPath USJ document JSONPath that may include a property accessor at the end
	 * @returns The part before any property accessor (whole original `jsonPath` if there is no
	 *   property accessor) and the property being accessed in the `jsonPath` (`undefined` if there is
	 *   no property accessor)
	 */
	private static splitJsonPathIntoContentAndProperty;
	/** Compares two UsjDocumentLocations to determine if they are pointing to the same location */
	private static areUsjDocumentLocationsEqual;
	/** Find the fragment info corresponding to the specified USJ Document location. */
	private findFragmentInfoAtUsjDocumentLocation;
	/**
	 * Transform a node and its working stack into the {@link UsjDocumentLocation} corresponding to it.
	 *
	 * @param node Marker or string to convert
	 * @param workingStack Working stack pointing to the node
	 * @param locationOffset If applicable, this is the offset that will be put on the
	 *   {@link UsjDocumentLocation}. If not present, offset on the {@link UsjDocumentLocation} will be
	 *   `0`. Not all subtypes of {@link UsjDocumentLocation}s have offsets, so this is not used in all
	 *   situations
	 * @returns The node and the document location corresponding to this fragment
	 */
	private static convertNodeToUsjDocumentLocation;
	/**
	 * Transform a fragment and its working stack into the {@link UsjNodeAndDocumentLocation}
	 * corresponding to it.
	 *
	 * @param fragment Fragment to convert
	 * @param workingStack Working stack pointing to the marker or string the fragment is in
	 * @param offsetWithinFragment If applicable, this is the offset within the fragment that the
	 *   location is pointing to, which is offset that will be put on the {@link UsjDocumentLocation}.
	 *   If not present, offset on the {@link UsjDocumentLocation} will be `0` because fragments don't
	 *   have their own offsets into the contents. Not all {@link UsjDocumentLocation}s have offsets,
	 *   so this is not used in all situations
	 * @returns The node and the document location corresponding to this fragment
	 */
	private static convertFragmentToUsjNodeAndDocumentLocation;
	/**
	 * Fill out fragments info from a minimal fragments info array and move them into the final
	 * fragments map
	 *
	 * @param fragmentsInfo Minimal fragments info array to fill out and put into maps. ALL CONTENTS
	 *   OF THIS ARRAY ARE REMOVED IN THIS METHOD
	 * @param workingStack Current working stack
	 * @param position Object containing properties describing where in the USFM document these
	 *   fragments are. PROPERTIES ON THIS OBJECT ARE MODIFIED IN THIS METHOD
	 * @param fragmentsByIndexInUsfm Map to add fragment information to
	 * @param indicesInUsfmByVerseRef Map to add verse start locations to
	 */
	private static transferFragmentsInfoArrayToMaps;
	private calculateUsfmProperties;
	private get usfm();
	private get fragmentsByIndexInUsfm();
	private get indicesInUsfmByVerseRef();
}

export {
	USFM_MARKERS_MAP as USFM_MARKERS_MAP_3_0,
	USFM_MARKERS_MAP_PARATEXT as USFM_MARKERS_MAP_PARATEXT_3_0,
};

export {};
