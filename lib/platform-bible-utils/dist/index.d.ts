// Generated by dts-bundle-generator v9.5.1

import { MarkerContent, MarkerObject, Usj } from '@biblionexus-foundation/scripture-utilities';
import { SerializedVerseRef } from '@sillsdev/scripture';
import { Mutex as AsyncMutex } from 'async-mutex';

/** This class provides a convenient way for one task to wait on a variable that another task sets. */
export declare class AsyncVariable<T> {
	private readonly variableName;
	private readonly promiseToValue;
	private resolver;
	private rejecter;
	/**
	 * Creates an instance of the class
	 *
	 * @param variableName Name to use when logging about this variable
	 * @param rejectIfNotSettledWithinMS Milliseconds to wait before verifying if the promise was
	 *   settled (resolved or rejected); will reject if it has not settled by that time. Use -1 if you
	 *   do not want a timeout at all. Defaults to 10000 ms
	 */
	constructor(variableName: string, rejectIfNotSettledWithinMS?: number);
	/**
	 * Get this variable's promise to a value. This always returns the same promise even after the
	 * value has been resolved or rejected.
	 *
	 * @returns The promise for the value to be set
	 */
	get promise(): Promise<T>;
	/**
	 * A simple way to see if this variable's promise was resolved or rejected already
	 *
	 * @returns Whether the variable was already resolved or rejected
	 */
	get hasSettled(): boolean;
	/**
	 * Resolve this variable's promise to the given value
	 *
	 * @param value This variable's promise will resolve to this value
	 * @param throwIfAlreadySettled Determines whether to throw if the variable was already resolved
	 *   or rejected. Defaults to `false`
	 */
	resolveToValue(value: T, throwIfAlreadySettled?: boolean): void;
	/**
	 * Reject this variable's promise for the value with the given reason
	 *
	 * @param reason This variable's promise will be rejected with this reason
	 * @param throwIfAlreadySettled Determines whether to throw if the variable was already resolved
	 *   or rejected. Defaults to `false`
	 */
	rejectWithReason(reason: string, throwIfAlreadySettled?: boolean): void;
	/** Prevent any further updates to this variable */
	private complete;
}
/** Enables language-sensitive string comparison. Wraps Intl.Collator */
export declare class Collator {
	private collator;
	constructor(locales?: string | string[], options?: Intl.CollatorOptions);
	/**
	 * Compares two strings according to the sort order of this Collator object
	 *
	 * @param string1 String to compare
	 * @param string2 String to compare
	 * @returns A number indicating how string1 and string2 compare to each other according to the
	 *   sort order of this Collator object. Negative value if string1 comes before string2. Positive
	 *   value if string1 comes after string2. 0 if they are considered equal.
	 */
	compare(string1: string, string2: string): number;
	/**
	 * Returns a new object with properties reflecting the locale and collation options computed
	 * during initialization of this collator object.
	 *
	 * @returns ResolvedCollatorOptions object
	 */
	resolvedOptions(): Intl.ResolvedCollatorOptions;
}
/** Enables language-sensitive data and time formatting. Wraps Intl.DateTimeFormat */
export declare class DateTimeFormat {
	private dateTimeFormatter;
	constructor(locales?: string | string[], options?: Intl.DateTimeFormatOptions);
	/**
	 * Formats a date according to the locale and formatting option for this DateTimeFormat object
	 *
	 * @param date The date to format
	 * @returns String representing the given date formatted according to the locale and formatting
	 *   options of this DateTimeFormat object
	 */
	format(date: Date): string;
	/**
	 * Formats a date range in the most concise way based on the locales and options provided when
	 * instantiating this DateTimeFormat object
	 *
	 * @param startDate Date object representing start of the date range
	 * @param endDate Date object representing the end of the date range
	 * @returns String representing the given date range formatted according to the locale and
	 *   formatting options of this DateTimeFormat object
	 */
	formatRange(startDate: Date, endDate: Date): string;
	/**
	 * Returns an array of locale-specific tokens representing each part of the formatted date range
	 * produced by this DateTimeFormat object
	 *
	 * @param startDate Date object representing start of the date range
	 * @param endDate Date object representing the end of the date range
	 * @returns Array of DateTimeRangeFormatPart objects
	 */
	formatRangeToParts(startDate: Date, endDate: Date): Intl.DateTimeRangeFormatPart[];
	/**
	 * Allows locale-aware formatting of strings produced by this DateTimeFormat object
	 *
	 * @param date The date to format
	 * @returns Array of DateTimeFormatPart objects
	 */
	formatToParts(date: Date): Intl.DateTimeFormatPart[];
	/**
	 * Returns a new object with properties reflecting the locale and date and time formatting options
	 * computed during initialization of this DateTimeFormat object
	 *
	 * @returns ResolvedDateTimeFormatOptions object
	 */
	resolvedOptions(): Intl.ResolvedDateTimeFormatOptions;
}
/** Function to run to dispose of something. Returns true if successfully unsubscribed */
export type Unsubscriber = () => boolean;
/**
 * Returns an Unsubscriber function that combines all the unsubscribers passed in.
 *
 * @param unsubscribers All unsubscribers to aggregate into one unsubscriber
 * @returns Function that unsubscribes from all passed in unsubscribers when run
 */
export declare const aggregateUnsubscribers: (unsubscribers: Unsubscriber[]) => Unsubscriber;
/**
 * Function to run to dispose of something that runs asynchronously. The promise resolves to true if
 * successfully unsubscribed
 */
export type UnsubscriberAsync = () => Promise<boolean>;
/**
 * Returns an UnsubscriberAsync function that combines all the unsubscribers passed in.
 *
 * @param unsubscribers - All unsubscribers to aggregate into one unsubscriber.
 * @returns Function that unsubscribes from all passed in unsubscribers when run
 */
export declare const aggregateUnsubscriberAsyncs: (unsubscribers: (UnsubscriberAsync | Unsubscriber)[]) => UnsubscriberAsync;
/** Callback function that accepts an event and should run when an event is emitted */
export type PlatformEventHandler<T> = (event: T) => void;
/**
 * Function that subscribes the provided callback to run when this event is emitted.
 *
 * @param callback Function to run with the event when it is emitted
 * @returns Unsubscriber function to run to stop calling the passed-in function when the event is
 *   emitted
 */
export type PlatformEvent<T> = (callback: PlatformEventHandler<T>) => Unsubscriber;
/**
 * A PapiEvent that subscribes asynchronously and resolves an asynchronous unsubscriber.
 *
 * Note: The callback itself is not asynchronous.
 */
export type PlatformEventAsync<T> = (callback: PlatformEventHandler<T>) => Promise<UnsubscriberAsync>;
export type JsonObjectLike = {
	[key: string]: unknown;
};
export type JsonArrayLike = unknown[];
export type JsonDocumentLike = JsonObjectLike | JsonArrayLike;
/**
 * Options for DocumentCombiner objects
 *
 * - `copyDocuments`: If true, this instance will perform a deep copy of all provided documents before
 *   composing the output. If false, then changes made to provided documents after they are
 *   contributed will be reflected in the next time output is composed.
 * - `ignoreDuplicateProperties`: If true, then duplicate properties are skipped if they are seen in
 *   contributed documents. If false, then throw when duplicate properties are seen in contributed
 *   documents.
 */
export type DocumentCombinerOptions = {
	copyDocuments: boolean;
	ignoreDuplicateProperties: boolean;
};
/**
 * Base class for any code that wants to compose JSON documents (primarily in the form of JS objects
 * or arrays) together into a single output document.
 */
export declare class DocumentCombiner {
	protected baseDocument: JsonDocumentLike;
	protected readonly contributions: Map<string, JsonDocumentLike>;
	protected latestOutput: JsonDocumentLike | undefined;
	protected readonly options: DocumentCombinerOptions;
	private readonly onDidRebuildEmitter;
	/** Event that emits to announce that the document has been rebuilt and the output has been updated */
	readonly onDidRebuild: PlatformEvent<undefined>;
	/**
	 * Create a DocumentCombiner instance
	 *
	 * @param baseDocument This is the first document that will be used when composing the output
	 * @param options Options used by this object when combining documents
	 */
	protected constructor(baseDocument: JsonDocumentLike, options: DocumentCombinerOptions);
	/**
	 * Update the starting document for composition process
	 *
	 * @param baseDocument Base JSON document/JS object that all other documents are added to
	 * @returns Recalculated output document given the new starting state and existing other documents
	 */
	updateBaseDocument(baseDocument: JsonDocumentLike): JsonDocumentLike | undefined;
	/**
	 * Add or update one of the contribution documents for the composition process
	 *
	 * Note: the order in which contribution documents are added can be considered indeterminate as it
	 * depends on the order in which `Map.forEach` iterates over the contributions. However, the order
	 * matters when merging two arrays into one. Also, when `options.ignoreDuplicateProperties` is is
	 * `true`, the order also matters when adding the same property to an object that is already
	 * provided previously. Please let us know if you have trouble because of indeterminate
	 * contribution ordering.
	 *
	 * @param documentName Name of the contributed document to combine
	 * @param document Content of the contributed document to combine
	 * @returns Recalculated output document given the new or updated contribution and existing other
	 *   documents
	 */
	addOrUpdateContribution(documentName: string, document: JsonDocumentLike): JsonDocumentLike | undefined;
	/**
	 * Delete one of the contribution documents for the composition process
	 *
	 * @param documentName Name of the contributed document to delete
	 * @returns Recalculated output document given the remaining other documents
	 */
	deleteContribution(documentName: string): JsonDocumentLike | undefined;
	/**
	 * Delete all present contribution documents for the composition process and return to the base
	 * document
	 *
	 * @returns Recalculated output document consisting only of the base document
	 */
	deleteAllContributions(): JsonDocumentLike | undefined;
	/**
	 * Run the document composition process given the starting document and all contributions. Throws
	 * if the output document fails to validate properly.
	 *
	 * @returns Recalculated output document given the starting and contributed documents
	 */
	rebuild(): JsonDocumentLike | undefined;
	/**
	 * Transform the starting document that is given to the combiner. This transformation occurs after
	 * validating the base document and before combining any contributions.
	 *
	 * WARNING: If you do not create the combiner with option `copyDocuments: true` or clone inside
	 * this method, this method will directly modify the `baseDocument` passed in.
	 *
	 * @param baseDocument Initial input document. Already validated via `validateBaseDocument`
	 * @returns Transformed base document
	 */
	protected transformBaseDocumentAfterValidation(baseDocument: JsonDocumentLike): JsonDocumentLike;
	/**
	 * Transform the contributed document associated with `documentName`. This transformation occurs
	 * after validating the contributed document and before combining with other documents.
	 *
	 * WARNING: If you do not create the combiner with option `copyDocuments: true` or clone inside
	 * this method, this method will directly modify the contributed `document` passed in.
	 *
	 * @param documentName Name of the contributed document to combine
	 * @param document Content of the contributed document to combine. Already validated via
	 *   `validateContribution`
	 * @returns Transformed contributed document
	 */
	protected transformContributionAfterValidation(documentName: string, document: JsonDocumentLike): JsonDocumentLike;
	/**
	 * Throw an error if the provided document is not a valid starting document.
	 *
	 * @param baseDocument Base JSON document/JS object that all other documents are added to
	 */
	protected validateBaseDocument(baseDocument: JsonDocumentLike): void;
	/**
	 * Throw an error if the provided document is not a valid contribution document.
	 *
	 * @param documentName Name of the contributed document to combine
	 * @param document Content of the contributed document to combine
	 */
	protected validateContribution(documentName: string, document: JsonDocumentLike): void;
	/**
	 * Throw an error if the provided output is not valid.
	 *
	 * @param output Output document that could potentially be returned to callers
	 */
	protected validateOutput(output: JsonDocumentLike): void;
	/**
	 * Transform the document that is the composition of the base document and all contribution
	 * documents. This is the last step that will be run prior to validation via `validateOutput`
	 * before `this.latestOutput` is updated to the new output.
	 *
	 * @param finalOutput Final output document that could potentially be returned to callers. "Final"
	 *   means no further contribution documents will be merged.
	 */
	protected transformFinalOutputBeforeValidation(finalOutput: JsonDocumentLike): JsonDocumentLike;
}
/** Class that tracks how long it has taken the last N events to occur */
export declare class EventRollingTimeCounter {
	/** The ring buffer to store times */
	private readonly ringBuffer;
	/** The size of the ring buffer */
	private readonly bufferSize;
	/** The next location where a time will be written */
	private writerIndex;
	/** The location where the first time in the buffer will be read */
	private readerIndex;
	/** The most recent difference in time between the newest and oldest events */
	private lastTimeDifference;
	/** How many instances in total have been recorded */
	private totalInstanceCount;
	/**
	 * Create a new instance of the InstanceTimeCounter class
	 *
	 * @param bufferSize - Maximum number of instances to track
	 */
	constructor(bufferSize: number);
	/** Get the total number of instances that have been recorded */
	get totalInstances(): number;
	/** Add a new time measurement for an instance of an event */
	recordInstance(): void;
	/**
	 * Check if the time between the last N events is less than the provided threshold
	 *
	 * @param minRollingTimeMs - Minimum time that must have passed when the last N events occurred
	 * @returns - True if the threshold is violated, false otherwise
	 */
	hasViolatedThreshold(minRollingTimeMs: number): boolean;
}
/**
 * Class that allows calling asynchronous functions multiple times at once while only running one at
 * a time.
 *
 * @example
 *
 * ```typescript
 * const mutex = new Mutex();
 *
 * mutex.runExclusive(async () => {
 *   // Do some asynchronous stuff
 *   console.log('These run one-at-a-time');
 * });
 *
 * mutex.runExclusive(async () => {
 *   // Do some asynchronous stuff
 *   console.log('These run one-at-a-time');
 * });
 * ```
 *
 * See [`async-mutex`](https://www.npmjs.com/package/async-mutex) for more information.
 */
export declare class Mutex extends AsyncMutex {
}
/** Map of {@link Mutex}es that automatically (lazily) generates a new {@link Mutex} for any new key */
export declare class MutexMap {
	private mutexesByID;
	get(mutexID: string): Mutex;
}
export declare class NonValidatingDocumentCombiner extends DocumentCombiner {
	constructor(baseDocument: JsonDocumentLike, options: DocumentCombinerOptions);
	get output(): JsonDocumentLike | undefined;
}
/** Enables language-sensitive number formatting. Wraps Intl.NumberFormat */
export declare class NumberFormat {
	private numberFormatter;
	constructor(locales?: string | string[], options?: Intl.NumberFormatOptions);
	/**
	 * Formats a number according to the locale and formatting options of this NumberFormat object
	 *
	 * @param value Number or BigInt to format
	 * @returns String representing the given number formatted according to the locale and formatting
	 *   options of this NumberFormat object
	 */
	format(value: number | bigint): string;
	/**
	 * Formats a range of numbers according to the locale and formatting options of this NumberFormat
	 * object
	 *
	 * @param startRange Number or bigint representing the start of the range
	 * @param endRange Number or bigint representing the end of the range
	 * @returns String representing the given range of numbers formatted according to the locale and
	 *   formatting options of this NumberFormat object
	 */
	formatRange(startRange: number | bigint, endRange: number | bigint): string;
	/**
	 * Returns an array of objects containing the locale-specific tokens from which it is possible to
	 * build custom strings while preserving the locale-specific parts.
	 *
	 * @param startRange Number or bigint representing start of the range
	 * @param endRange Number or bigint representing end of the range
	 * @returns Array of NumberRangeFormatPart objects containing the formatted range of numbers in
	 *   parts
	 */
	formatRangeToParts(startRange: number | bigint, endRange: number | bigint): Intl.NumberRangeFormatPart[];
	/**
	 * Allows locale-aware formatting of strings produced by this NumberFormat object
	 *
	 * @param value Number or bigint to format
	 * @returns Array of NumberFormatPart objects containing the formatted number in parts
	 */
	formatToParts(value: number | bigint): Intl.NumberFormatPart[];
	/**
	 * Returns a new object with properties reflecting the locale and number formatting options
	 * computed during initialization of this NumberFormat object
	 *
	 * @returns ResolvedNumberFormatOptions object
	 */
	resolvedOptions(): Intl.ResolvedNumberFormatOptions;
}
/** Require a `dispose` function */
export interface Dispose {
	/** Release resources and notify dependent services when tearing down an object */
	dispose: UnsubscriberAsync;
}
/** Require an `onDidDispose` event */
export interface OnDidDispose {
	/** Event that emits when `dispose` is called on an object */
	onDidDispose: PlatformEvent<void>;
}
/**
 * Indicates than an object cannot have an `onDidDispose` event. Also allows an object to include a
 * `dispose` function.
 */
export interface CannotHaveOnDidDispose {
	/** Release resources and notify dependent services when tearing down an object */
	dispose?: UnsubscriberAsync;
	/** Event that emits when `dispose` is called on an object */
	onDidDispose?: undefined;
}
/** Allow onDidDispose to exist on the type if it was previously disallowed by CannotHaveOnDidDispose */
export type CanHaveOnDidDispose<T extends CannotHaveOnDidDispose> = Omit<T, "onDidDispose">;
/**
 * Event manager - accepts subscriptions to an event and runs the subscription callbacks when the
 * event is emitted Use eventEmitter.event(callback) to subscribe to the event. Use
 * eventEmitter.emit(event) to run the subscriptions. Generally, this EventEmitter should be
 * private, and its event should be public. That way, the emitter is not publicized, but anyone can
 * subscribe to the event.
 */
export declare class PlatformEventEmitter<T> implements Dispose {
	/**
	 * Subscribes a function to run when this event is emitted.
	 *
	 * @param callback Function to run with the event when it is emitted
	 * @returns Unsubscriber function to run to stop calling the passed-in function when the event is
	 *   emitted
	 * @alias event
	 */
	subscribe: PlatformEvent<T>;
	/** All callback functions that will run when this event is emitted. Lazy loaded */
	private subscriptions?;
	/** Event for listeners to subscribe to. Lazy loaded */
	private lazyEvent?;
	/** Whether this emitter has been disposed */
	private isDisposed;
	/**
	 * Event for listeners to subscribe to. Subscribes a function to run when this event is emitted.
	 * Use like `const unsubscriber = event(callback)`
	 *
	 * @param callback Function to run with the event when it is emitted
	 * @returns Unsubscriber function to run to stop calling the passed-in function when the event is
	 *   emitted
	 */
	get event(): PlatformEvent<T>;
	/** Disposes of this event, preparing it to release from memory */
	dispose: () => Promise<boolean>;
	/**
	 * Runs the subscriptions for the event
	 *
	 * @param event Event data to provide to subscribed callbacks
	 */
	emit: (event: T) => void;
	/**
	 * Function that runs the subscriptions for the event. Added here so children can override emit
	 * and still call the base functionality. See NetworkEventEmitter.emit for example
	 */
	protected emitFn(event: T): void;
	/** Check to make sure this emitter is not disposed. Throw if it is */
	protected assertNotDisposed(): void;
	/**
	 * Disposes of this event, preparing it to release from memory. Added here so children can
	 * override emit and still call the base functionality.
	 */
	protected disposeFn(): Promise<boolean>;
}
/**
 * Class that allows you to chain promises for a given key. This is useful when:
 *
 * 1. You need to run promises from synchronous code and don't need to look at the results.
 * 2. The promises to run, or at least precisely when to run them, are not known in advance.
 * 3. The promises need to be run sequentially, waiting for the previous one to finish.
 *
 * An example of when this can be helpful is inside of React components. Component code is mostly
 * synchronous, but you may need to run some asynchronous code. You can't use `await` inside of
 * React component code in many situations, so you can use this class to chain promises together.
 *
 * When promises are added to the map with a key, they will run in the order they were added to the
 * map for that key. If a promise rejects, a warning will be logged and the chain will continue. If
 * a promise is added while another promise in the map for that key is running, the new promise will
 * be chained to the existing one.
 */
export declare class PromiseChainingMap<TKey = string> {
	private readonly map;
	private readonly logger;
	/**
	 * Creates a new PromiseChainingMap
	 *
	 * @param logger Object with a `warn` method that will be called when a promise rejects. This
	 *   defaults to `console`.
	 */
	constructor(logger?: {
		warn: (message: string) => void;
	});
	/**
	 * Adds a promise function to the map for a given key. If a promise is already running for the
	 * key, the new promise will be chained to the existing one. Once all promises for a key have
	 * settled, the map will be cleared for that key.
	 *
	 * @param key Unique key to identify a distinct promise chain
	 * @param promiseFunction Function that returns a promise to add to the chain
	 */
	addPromiseFunction(key: TKey, promiseFunction: () => Promise<unknown>): void;
	/**
	 * Gets the current promise chain for the given key. This is mostly useful for testing. Normally
	 * you should just call {@link addPromiseFunction} and let the map handle the rest.
	 *
	 * @param key Unique key to identify a distinct promise chain
	 * @returns The current promise chain for the key
	 */
	get(key: TKey): Promise<unknown> | undefined;
	/**
	 * Configures a promise chain to be removed from the map for the given key after all the promises
	 * have settled
	 *
	 * @param key Unique key to identify a distinct promise chain
	 */
	private cleanupPromiseChain;
}
/** Simple collection for UnsubscriberAsync objects that also provides an easy way to run them. */
export declare class UnsubscriberAsyncList {
	private name;
	readonly unsubscribers: Set<Unsubscriber | UnsubscriberAsync>;
	constructor(name?: string);
	/**
	 * Add unsubscribers to the list. Note that duplicates are not added twice.
	 *
	 * @param unsubscribers - Objects that were returned from a registration process.
	 */
	add(...unsubscribers: (UnsubscriberAsync | Unsubscriber | Dispose)[]): void;
	/**
	 * Run all unsubscribers added to this list and then clear the list.
	 *
	 * @returns `true` if all unsubscribers succeeded, `false` otherwise.
	 */
	runAllUnsubscribers(): Promise<boolean>;
}
export declare const PLATFORM_ERROR_VERSION = 1;
/**
 * PlatformError is an error type with stronger typing of properties than {@link Error}. It is used
 * to represent errors that are returned by the platform.
 *
 * You can create a new PlatformError object using {@link newPlatformError}. You can check if a value
 * is a PlatformError object using {@link isPlatformError}.
 */
export type PlatformError = {
	/**
	 * The underlying cause of the error, if any. Normally this will be copied from an {@link Error}
	 * object passed to {@link newPlatformError}. If a non-Error object is passed to
	 * {@link newPlatformError}, it will be stored here.
	 */
	cause?: unknown;
	/**
	 * A descriptive message explaining the error. Normally this will be copied from an {@link Error}
	 * object passed to {@link newPlatformError}. If a string is passed to {@link newPlatformError}, it
	 * will be stored here.
	 */
	message: string;
	/** The version of the PlatformError type. */
	platformErrorVersion: number;
	/**
	 * The stack trace of the error, if available. Normally this will be copied from an {@link Error}
	 * object passed to {@link newPlatformError}.
	 */
	stack?: string;
};
/**
 * Creates a new PlatformError object. If no argument is provided, a PlatformError object with an
 * empty `message` is returned.
 *
 * @param error The error message as a string, an Error object, or a value to assign to the `cause`
 *   property of the returned PlatformError object
 * @returns A new PlatformError object
 */
export declare function newPlatformError(error?: unknown): PlatformError;
/**
 * Checks if the provided value is a PlatformError object.
 *
 * @param error The value to check
 * @returns `true` if the value is a PlatformError object, otherwise `false`
 */
export declare function isPlatformError(error: unknown): error is PlatformError;
export interface BookInfo {
	shortName: string;
	fullNames: string[];
	chapters: number;
}
/**
 * Represents a "node" in the JSON used to present Scripture in the editor, with a path that is
 * relative to the start of a verse.
 */
export type ScriptureNode = SerializedVerseRef & {
	jsonPath: string;
};
/** Represents a specific character offset in the text of a textual Scripture node (in the editor.) */
export type ScriptureTextAnchor = ScriptureNode & {
	offset: number;
};
/**
 * Represents a range of text in the Scripture editor. The start and end node are expected to be in
 * the same book.
 */
export type ScriptureSelection = {
	start: ScriptureNode | ScriptureTextAnchor;
	end?: ScriptureNode | ScriptureTextAnchor;
};
/**
 * An identifier corresponding to a Scripture reference shared by a group of Scripture reference
 * consumers.
 *
 * For example, a few web views that share a Scroll Group Id would all change Scripture Reference
 * together.
 *
 * These are generally expected to be non-negative numbers (starting at 0).
 */
export type ScrollGroupId = number;
/** Collection of functions, objects, and types that are used as helpers in other services. */
export declare function newGuid(): string;
/**
 * Determine whether the object is a string
 *
 * @param o Object to determine if it is a string
 * @returns True if the object is a string; false otherwise
 */
export declare function isString(o: unknown): o is string;
/**
 * If deepClone isn't used when copying properties between objects, you may be left with dangling
 * references between the source and target of property copying operations.
 *
 * @param obj Object to clone
 * @returns Duplicate copy of `obj` without any references back to the original one
 */
export declare function deepClone<T>(obj: T): T;
/**
 * Get a function that reduces calls to the function passed in
 *
 * @param fn The function to debounce
 * @param delay How much delay in milliseconds after the most recent call to the debounced function
 *   to call the function
 * @returns Function that, when called, only calls the function passed in at maximum every delay ms
 */
export declare function debounce<T extends (...args: any[]) => void>(fn: T, delay?: number): T;
/**
 * Groups each item in the array of items into a map according to the keySelector
 *
 * @param items Array of items to group by
 * @param keySelector Function to run on each item to get the key for the group to which it belongs
 * @param valueSelector Function to run on each item to get the value it should have in the group
 *   (like map function). If not provided, uses the item itself
 * @returns Map of keys to groups of values corresponding to each item
 */
export declare function groupBy<T, K>(items: T[], keySelector: (item: T) => K): Map<K, Array<T>>;
export declare function groupBy<T, K, V>(items: T[], keySelector: (item: T) => K, valueSelector: (item: T, key: K) => V): Map<K, Array<V>>;
/**
 * Function to get an error message from the object (useful for getting error message in a catch
 * block)
 *
 * @example `try {...} catch (e) { logger.info(getErrorMessage(e)) }`
 *
 * @param error Error object whose message to get
 * @returns Message of the error - if object has message, returns message. Otherwise tries to
 *   stringify
 */
export declare function getErrorMessage(error: unknown): string;
/** Asynchronously waits for the specified number of milliseconds. (wraps setTimeout in a promise) */
export declare function wait(ms: number): Promise<void>;
/**
 * Runs the specified function and will timeout if it takes longer than the specified wait time
 *
 * @param fn The function to run
 * @param maxWaitTimeInMS The maximum amount of time to wait for the function to resolve
 * @returns Promise that resolves to the resolved value of the function or undefined if it ran
 *   longer than the specified wait time
 */
export declare function waitForDuration<TResult>(fn: () => Promise<TResult>, maxWaitTimeInMS: number): Promise<Awaited<TResult> | undefined>;
/**
 * Get all functions on an object and its prototype chain (so we don't miss any class methods or any
 * object methods). Note that the functions on the final item in the prototype chain (i.e., Object)
 * are skipped to avoid including functions like `__defineGetter__`, `__defineSetter__`, `toString`,
 * etc.
 *
 * @param obj Object whose functions to get
 * @param _objId Optional ID of the object to use for debug logging
 * @returns Array of all function names on an object
 */
export declare function getAllObjectFunctionNames(obj: {
	[property: string]: unknown;
}, _objId?: string): Set<string>;
/**
 * Creates a synchronous proxy for an asynchronous object. The proxy allows calling methods on an
 * object that is asynchronously fetched using a provided asynchronous function.
 *
 * @param getObject - A function that returns a promise resolving to the object whose asynchronous
 *   methods to call.
 * @param objectToProxy - An optional object that is the object that is proxied. If a property is
 *   accessed that does exist on this object, it will be returned. If a property is accessed that
 *   does not exist on this object, it will be considered to be an asynchronous method called on the
 *   object returned from getObject.
 * @returns A synchronous proxy for the asynchronous object.
 */
export declare function createSyncProxyForAsyncObject<T extends object>(getObject: (args?: unknown[]) => Promise<T>, objectToProxy?: Partial<T>): T;
/**
 * Indicates if the exception or error message provided appears to be from ParatextData.dll
 * indicating that Paratext is blocking internet access.
 *
 * @param errorMessage Error message or exception to check
 * @returns `true` if the message indicates Paratext is blocking internet access, `false` otherwise
 */
export declare function isErrorMessageAboutParatextBlockingInternetAccess(errorMessage: unknown): boolean;
/**
 * Indicates if the exception or error message provided appears to be from ParatextData.dll
 * indicating that an authorization failure occurred regarding registry credentials.
 *
 * @param errorMessage Error message or exception to check
 * @returns `true` if the message indicates an auth failure, `false` otherwise
 */
export declare function isErrorMessageAboutRegistryAuthFailure(errorMessage: unknown): boolean;
/** Within type T, recursively change all properties to be optional */
export type DeepPartial<T> = T extends object ? {
	[P in keyof T]?: DeepPartial<T[P]>;
} : T;
/** Within type T, recursively change properties that were of type A to be of type B */
export type ReplaceType<T, A, B> = T extends A ? B : T extends object ? {
	[K in keyof T]: ReplaceType<T[K], A, B>;
} : T;
/**
 * Converts a union type to an intersection type (`|` to `&`).
 *
 * Note: this utility type is for use on object types. It may fail on other types.
 *
 * @example
 *
 * ```typescript
 * type TypeOne = { one: string };
 * type TypeTwo = { two: number };
 * type TypeThree = { three: string };
 *
 * type TypeNums = { one: TypeOne; two: TypeTwo; three: TypeThree };
 * const numNames = ['one', 'two'] as const;
 * type TypeNumNames = typeof numNames;
 *
 * // Same as `TypeOne | TypeTwo`
 * // `{ one: string } | { two: number }`
 * type TypeOneTwoUnion = TypeNums[TypeNumNames[number]];
 *
 * // Same as `TypeOne & TypeTwo`
 * // `{ one: string; two: number }`
 * type TypeOneTwoIntersection = UnionToIntersection<TypeOneTwoUnion>;
 * ```
 */
export type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;
/** Identifier for a string that will be localized in a menu based on the user's UI language */
export type LocalizeKey = `%${string}%`;
/** Name of some UI element (i.e., tab, column, group, menu item) or some PAPI object (i.e., command) */
export type ReferencedItem = `${string}.${string}`;
export type OrderedItem = {
	/** Relative order of this item compared to other items in the same parent/scope (sorted ascending) */
	order: number;
};
export type OrderedExtensibleContainer = OrderedItem & {
	/** Determines whether other items can be added to this after it has been defined */
	isExtensible?: boolean;
};
/** Group of menu items that belongs in a column */
export type MenuGroupDetailsInColumn = OrderedExtensibleContainer & {
	/** ID of column in which this group resides */
	column: ReferencedItem;
};
/** Group of menu items that belongs in a submenu */
export type MenuGroupDetailsInSubMenu = OrderedExtensibleContainer & {
	/** ID of menu item hosting the submenu in which this group resides */
	menuItem: ReferencedItem;
};
/** Column that includes header text in a menu */
export type MenuColumnWithHeader = OrderedExtensibleContainer & {
	/** Key that represents the text of the header text of the column */
	label: LocalizeKey;
};
export type MenuItemBase = OrderedItem & {
	/** Menu group to which this menu item belongs */
	group: ReferencedItem;
	/** Key that represents the text of this menu item to display */
	label: LocalizeKey;
	/** Key that represents words the platform should reference when users are searching for menu items */
	searchTerms?: LocalizeKey;
	/** Key that represents the text to display if a mouse pointer hovers over the menu item */
	tooltip?: LocalizeKey;
	/** Additional information provided by developers to help people who perform localization */
	localizeNotes: string;
};
/** Menu item that hosts a submenu */
export type MenuItemContainingSubmenu = MenuItemBase & {
	/** ID for this menu item that holds a submenu */
	id: ReferencedItem;
};
/** Menu item that runs a command */
export type MenuItemContainingCommand = MenuItemBase & {
	/** Name of the PAPI command to run when this menu item is selected. */
	command: ReferencedItem;
	/**
	 * Uri path to the icon to display after the menu text. Ex:
	 * `papi-extension://helloWorld/assets/icon.png`
	 */
	iconPathAfter?: string;
	/**
	 * Uri path to the icon to display before the menu text. Ex:
	 * `papi-extension://helloWorld/assets/icon.png`
	 */
	iconPathBefore?: string;
};
/**
 * Group of menu items that can be combined with other groups to form a single context menu/submenu.
 * Groups are separated using a line within the menu/submenu.
 */
export type GroupsInSingleColumnMenu = {
	/** Named menu group */
	[property: ReferencedItem]: OrderedExtensibleContainer | MenuGroupDetailsInSubMenu;
};
/**
 * Group of menu items that can be combined with other groups to form a single menu/submenu within a
 * multi-column menu. Groups are separated using a line within the menu/submenu.
 */
export type GroupsInMultiColumnMenu = {
	/** Named menu group */
	[property: ReferencedItem]: MenuGroupDetailsInColumn | MenuGroupDetailsInSubMenu;
};
/** Group of columns that can be combined with other columns to form a multi-column menu */
export type ColumnsWithHeaders = {
	/** Named column of a menu */
	[property: ReferencedItem]: MenuColumnWithHeader;
	/** Defines whether columns can be added to this multi-column menu */
	isExtensible?: boolean;
};
/** Menu that contains a column without a header */
export type SingleColumnMenu = {
	/** Groups that belong in this menu */
	groups: GroupsInSingleColumnMenu;
	/** List of menu items that belong in this menu */
	items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];
};
/** Menu that contains multiple columns with headers */
export type MultiColumnMenu = {
	/** Columns that belong in this menu */
	columns: ColumnsWithHeaders;
	/** Groups that belong in this menu */
	groups: GroupsInMultiColumnMenu;
	/** List of menu items that belong in this menu */
	items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];
};
/** Menus for one single web view */
export type WebViewMenu = {
	/** Indicates whether the platform default menus should be included for this webview */
	includeDefaults: boolean | undefined;
	/** Menu that opens when you click on the top left corner of a tab */
	topMenu: MultiColumnMenu | undefined;
	/** Menu that opens when you right click on the main body/area of a tab */
	contextMenu: SingleColumnMenu | undefined;
};
/** Menus for all web views */
export type WebViewMenus = {
	/** Named web view */
	[property: ReferencedItem]: WebViewMenu;
};
/** Platform.Bible menus before they are localized */
export type PlatformMenus = {
	/** Top level menu for the application */
	mainMenu: MultiColumnMenu;
	/** Menus that apply per web view in the application */
	webViewMenus: WebViewMenus;
	/** Default context menu for web views that don't specify their own */
	defaultWebViewContextMenu: SingleColumnMenu;
	/** Default top menu for web views that don't specify their own */
	defaultWebViewTopMenu: MultiColumnMenu;
};
/**
 * Type that converts any menu type before it is localized to what it is after it is localized. This
 * can be applied to any menu type as needed.
 */
export type Localized<T> = ReplaceType<ReplaceType<T, LocalizeKey, string>, ReferencedItem, string>;
/** JSON schema object that aligns with the PlatformMenus type */
export declare const menuDocumentSchema: {
	title: string;
	type: string;
	properties: {
		mainMenu: {
			description: string;
			$ref: string;
		};
		defaultWebViewTopMenu: {
			description: string;
			$ref: string;
		};
		defaultWebViewContextMenu: {
			description: string;
			$ref: string;
		};
		webViewMenus: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
	};
	required: string[];
	additionalProperties: boolean;
	$defs: {
		localizeKey: {
			description: string;
			type: string;
			pattern: string;
		};
		referencedItem: {
			description: string;
			type: string;
			pattern: string;
		};
		columnsWithHeaders: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					description: string;
					type: string;
					properties: {
						label: {
							description: string;
							$ref: string;
						};
						localizeNotes: {
							description: string;
							type: string;
						};
						order: {
							description: string;
							type: string;
						};
						isExtensible: {
							description: string;
							type: string;
						};
					};
					required: string[];
					additionalProperties: boolean;
				};
			};
			properties: {
				isExtensible: {
					description: string;
					type: string;
				};
			};
		};
		menuGroups: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					description: string;
					type: string;
					oneOf: ({
						properties: {
							column: {
								description: string;
								$ref: string;
							};
							order: {
								description: string;
								type: string;
							};
							isExtensible: {
								description: string;
								type: string;
							};
							menuItem?: undefined;
						};
						required: string[];
						additionalProperties: boolean;
					} | {
						properties: {
							menuItem: {
								description: string;
								$ref: string;
							};
							order: {
								description: string;
								type: string;
							};
							isExtensible: {
								description: string;
								type: string;
							};
							column?: undefined;
						};
						required: string[];
						additionalProperties: boolean;
					})[];
				};
			};
			additionalProperties: boolean;
		};
		menuItem: {
			description: string;
			type: string;
			oneOf: ({
				properties: {
					id: {
						description: string;
						$ref: string;
					};
					command?: undefined;
					iconPathBefore?: undefined;
					iconPathAfter?: undefined;
				};
				required: string[];
			} | {
				properties: {
					command: {
						description: string;
						$ref: string;
					};
					iconPathBefore: {
						description: string;
						type: string;
					};
					iconPathAfter: {
						description: string;
						type: string;
					};
					id?: undefined;
				};
				required: string[];
			})[];
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				tooltip: {
					description: string;
					$ref: string;
				};
				searchTerms: {
					description: string;
					$ref: string;
				};
				localizeNotes: {
					description: string;
					type: string;
				};
				group: {
					description: string;
					$ref: string;
				};
				order: {
					description: string;
					type: string;
				};
			};
			required: string[];
			unevaluatedProperties: boolean;
		};
		groupsAndItems: {
			description: string;
			type: string;
			properties: {
				groups: {
					description: string;
					$ref: string;
				};
				items: {
					description: string;
					type: string;
					items: {
						$ref: string;
					};
					uniqueItems: boolean;
				};
			};
			required: string[];
		};
		singleColumnMenu: {
			description: string;
			type: string;
			allOf: {
				$ref: string;
			}[];
			unevaluatedProperties: boolean;
		};
		multiColumnMenu: {
			description: string;
			type: string;
			allOf: ({
				$ref: string;
				properties?: undefined;
				required?: undefined;
			} | {
				properties: {
					columns: {
						description: string;
						$ref: string;
					};
				};
				required: string[];
				$ref?: undefined;
			})[];
			unevaluatedProperties: boolean;
		};
		menusForOneWebView: {
			description: string;
			type: string;
			properties: {
				includeDefaults: {
					description: string;
					type: string;
				};
				topMenu: {
					description: string;
					$ref: string;
				};
				contextMenu: {
					description: string;
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
	};
};
export declare const FIRST_SCR_BOOK_NUM = 1;
export declare const LAST_SCR_BOOK_NUM: number;
export declare const FIRST_SCR_CHAPTER_NUM = 1;
export declare const FIRST_SCR_VERSE_NUM = 1;
export declare const defaultScrRef: SerializedVerseRef;
export declare const getChaptersForBook: (bookNum: number) => number;
export declare const offsetBook: (scrRef: SerializedVerseRef, offset: number) => SerializedVerseRef;
export declare const offsetChapter: (scrRef: SerializedVerseRef, offset: number) => SerializedVerseRef;
export declare const offsetVerse: (scrRef: SerializedVerseRef, offset: number) => SerializedVerseRef;
/**
 * https://github.com/ubsicap/Paratext/blob/master/ParatextData/SILScriptureExtensions.cs#L72
 *
 * Convert book number to a localized Id (a short description of the book). This should be used
 * whenever a book ID (short code) is shown to the user. It is primarily needed for people who do
 * not read Roman script well and need to have books identified in a alternate script (e.g. Chinese
 * or Russian)
 *
 * @param bookNumber
 * @param localizationLanguage In BCP 47 format
 * @param getLocalizedString Function that provides the localized versions of the book ids and names
 *   asynchronously.
 * @returns
 */
export declare function getLocalizedIdFromBookNumber(bookNumber: number, localizationLanguage: string, getLocalizedString: (item: {
	localizeKey: string;
	languagesToSearch?: string[];
}) => Promise<string>): Promise<string>;
/**
 * Get the Scripture reference as an easily comparable/sortable integer, without considering the
 * verse.
 *
 * @param scrRef The Scripture reference.
 * @returns An integer where the first three digits represent the book, the next three represent the
 *   chapter and the last three represent the verse.
 */
export declare function scrRefToBBBCCC(scrRef: SerializedVerseRef): number;
/**
 * Get the Scripture reference as an easily comparable/sortable integer.
 *
 * @param scrRef The Scripture reference.
 * @returns An integer where the first three digits represent the book, the next three represent the
 *   chapter and the last three represent the verse.
 */
export declare function scrRefToBBBCCCVVV(scrRef: SerializedVerseRef): number;
/**
 * Compares two Scripture references canonically.
 *
 * @param scrRef1 The first Scripture reference to compare.
 * @param scrRef2 The second Scripture reference to compare.
 * @returns A number indicating the result of the comparison: - Negative value if scrRef1 precedes
 *   scrRef2 in sorting order. - Zero if scrRef1 and scrRef2 are equivalent in sorting order. -
 *   Positive value if scrRef1 follows scrRef2 in sorting order.
 */
export declare function compareScrRefs(scrRef1: SerializedVerseRef, scrRef2: SerializedVerseRef): number;
/** Get the localized string key for a given scroll group Id (or no scroll group if `undefined`) */
export declare function getLocalizeKeyForScrollGroupId(scrollGroupId: ScrollGroupId | undefined | "undefined"): LocalizeKey;
/**
 * Gets a list of localized string keys for provided scroll group Ids. Uses
 * {@link getLocalizeKeyForScrollGroupId} internally
 *
 * @example
 *
 * ```typescript
 * getLocalizeKeysForScrollGroupIds([undefined, 0, 1, 2, 3, 4]);
 * // Gives localized string keys for the provided scroll group ids in an array
 * ```
 *
 * @param scrollGroupIds Scroll group ids to include
 * @returns List of localized string keys for scroll group Ids
 */
export declare function getLocalizeKeysForScrollGroupIds(scrollGroupIds: (ScrollGroupId | undefined)[]): `%${string}%`[];
/**
 * Formats a Scripture reference.
 *
 * @param scrRef The Scripture reference to format.
 * @param optionOrLocalizedBookName Either 'id' (the default) to format using the "standard" (as
 *   defined by SIL/UBS) 3-letter book ID, 'English' to format using the English book name spelled
 *   out, or some other string (e.g., a localized book name, vernacular abbreviation, FCBH book id,
 *   etc.) to use.
 * @param chapterVerseSeparator The character used to separate the chapter number from the verse
 *   number. Default is a colon (:). Note: More than one character is allowed.
 * @param bookChapterSeparator The character used to separate the book from the chapter number.
 *   Default is a single space. Note: More than one character is allowed.
 * @returns The formatted reference.
 */
export declare function formatScrRef(scrRef: SerializedVerseRef, optionOrLocalizedBookName?: "id" | "English" | string, chapterVerseSeparator?: string, bookChapterSeparator?: string): string;
/**
 * Converts all control characters, carriage returns, and tabs into spaces and then strips duplicate
 * spaces.
 *
 * This is mainly intended for use with individual Scripture strings in USFM, USX, USJ, etc. format.
 * It is not intended to implement the [USFM white space definition or reduction
 * rules](https://docs.usfm.bible/usfm/3.1/whitespace.html) but strictly follows Paratext 9's white
 * space rules. It is generally best suited to normalizing spaces within a Scripture marker as it
 * removes all newlines.
 *
 * This function is a direct translation of `UsfmToken.RegularizeSpaces` from `ParatextData.dll`
 */
export declare function normalizeScriptureSpaces(str: string): string;
/**
 * Determines if the USJ documents or markers (and all contents) are equivalent after regularizing
 * spaces according to the way `ParatextData.dll` does.
 *
 * Note that this will not work properly if there ever exist any properties of USJ document or USJ
 * markers other than `content` that are complex objects like arrays or objects as the properties
 * are shallow equaled.
 */
export declare function areUsjContentsEqualExceptWhitespace(a: Usj | undefined, b: Usj | undefined): boolean;
/** USJ content node type for a chapter */
export declare const CHAPTER_TYPE = "chapter";
/** USJ content node type for a verse */
export declare const VERSE_TYPE = "verse";
/** Represents a book, chapter, verse, and offset */
export type VerseRefOffset = {
	verseRef: SerializedVerseRef;
	offset: number;
};
/** This could actually have more content clauses at the end, but TS types are limited */
export type ContentJsonPath = "" | `$` | `$.content[${number}]` | `$.content[${number}].content[${number}]` | `$.content[${number}].content[${number}].content[${number}]` | `$.content[${number}].content[${number}].content[${number}].content[${number}]`;
/** Node within a USJ object, an offset within that node, and a JSONPath query to the node */
export type UsjContentLocation = {
	node: MarkerContent;
	offset: number;
	jsonPath: ContentJsonPath;
};
/** Utilities for reading from and writing to `Usj` objects */
export interface IUsjReaderWriter {
	/**
	 * Return a copy of text following a given starting point
	 *
	 * @param start Point where text extraction will start
	 * @param desiredLength Length of text to extract from this USJ data
	 */
	extractText(start: UsjContentLocation, desiredLength: number): string;
	/**
	 * Return a copy of text between two points
	 *
	 * @param start Point where text extraction will start
	 * @param end Point where text extraction will end
	 * @param maxLength Maximum length of string to return (defaults to 100)
	 * @returns Text between the two points, capped at length `maxLength`
	 */
	extractTextBetweenPoints(start: UsjContentLocation, end: UsjContentLocation, maxLength: number): string;
	/**
	 * Given a starting point, find the next location in this USJ data that matches the given text
	 *
	 * @param start Point where the search for `text` will start
	 * @param text Text to find
	 * @param maxTextLengthToSearch Maximum length of text to search before stopping (default is 1000)
	 * @returns Object containing the USJ node where `text` begins (it might be split across nodes),
	 *   offset within that node that indicates where `text` begins, and a JSONPath string that
	 *   indicates the location of the of USJ node within `usj`. Note that if the USJ node returned is
	 *   an object, it is the same object that is within this USJ data. So if you change it, you are
	 *   changing this USJ data.
	 */
	findNextLocationOfMatchingText(start: UsjContentLocation, text: string, maxTextLengthToSearch: number): UsjContentLocation | undefined;
	/** Find the first value matching the given JSONPath query within this USJ data */
	findSingleValue<T>(jsonPathQuery: string): T | undefined;
	/** Find the parent of the first value matching the given JSONPath query within this USJ data */
	findParent<T>(jsonPathQuery: string): T | undefined;
	/**
	 * Convert a JSONPath query into a SerializedVerseRef and offset
	 *
	 * @param jsonPathQuery JSONPath search expression that indicates a node within this USJ data. If
	 *   the expression matches more than one node, then only the first node found is considered.
	 * @param bookId 3 letter ID of the book being searched (must be defined in this USJ data if not
	 *   provided here)
	 * @returns SerializedVerseRef and offset that represents the location within this USJ data
	 *   indicated by `jsonPathQuery`
	 */
	jsonPathToVerseRefAndOffset(jsonPathQuery: string, bookId?: string): VerseRefOffset;
	/** Build a JSONPath query that uniquely identifies the given node with this USJ data. */
	nodeToJsonPath(node: MarkerObject): ContentJsonPath;
	/**
	 * Determine the SerializedVerseRef and offset that correspond to the location of a node somewhere
	 * within this USJ data
	 *
	 * @param bookId ID of the book represented by this USJ data
	 * @param node JSON object representing the location of the SerializedVerseRef and offset
	 * @param nodeParent JSON object that owns the `content` array that includes `node`. If
	 *   'undefined' is provided then the `UsjReaderWriter` will attempt to lookup the parent of
	 *   `node`. The lookup will always fail and throw an error if `node` is a string.
	 * @returns SerializedVerseRef and offset representing the location of `node`, if one could be
	 *   found
	 */
	nodeToVerseRefAndOffset(bookId: string, node: MarkerContent, nodeParent: MarkerObject | MarkerContent[] | undefined): {
		verseRef: SerializedVerseRef;
		offset: number;
	} | undefined;
	/**
	 * Remove all nodes from this USJ data that match a given search function.
	 *
	 * @param searchFunction Function that returns `true` if the given node should be removed
	 * @returns Number of nodes removed
	 */
	removeContentNodes(searchFunction: (potentiallyMatchingNode: MarkerContent) => boolean): number;
	/**
	 * Inform this UsjReaderWriter that the underlying USJ object changed. This is needed to clear
	 * caches used when querying.
	 */
	usjChanged(): void;
	/**
	 * Convert a verse ref + offset into a node + offset within this USJ data and a JSONPath query
	 *
	 * @param verseRef Indicates the book, chapter, and verse of interest to find
	 * @param verseRefOffset Specific location within verse text (defaults to 0)
	 * @returns Object containing the USJ node indicated by `verseRef` and `verseRefOffset`, offset
	 *   within that node that matches the `verseRefOffset`, and a JSONPath string that indicates the
	 *   location of the of USJ node within this USJ data. Note that if the USJ node returned is an
	 *   object, it is the same object that is within this USJ data. So if you change it, you are
	 *   changing this USJ data.
	 */
	verseRefToUsjContentLocation(verseRef: SerializedVerseRef, verseRefOffset: number): UsjContentLocation;
}
/**
 * This function mirrors the `at` function from the JavaScript Standard String object. It handles
 * Unicode code points instead of UTF-16 character codes.
 *
 * Finds the Unicode code point at the given index.
 *
 * @param string String to index
 * @param index Position of the character to be returned in range of -length(string) to
 *   length(string)
 * @returns New string consisting of the Unicode code point located at the specified offset,
 *   undefined if index is out of bounds
 */
export declare function at(string: string, index: number): string | undefined;
/**
 * This function mirrors the `charAt` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns a new string consisting of the single unicode code point at the given index.
 *
 * @param string String to index
 * @param index Position of the string character to be returned, in the range of 0 to
 *   length(string)-1
 * @returns New string consisting of the Unicode code point located at the specified offset, empty
 *   string if index is out of bounds
 */
export declare function charAt(string: string, index: number): string;
/**
 * This function mirrors the `codePointAt` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns a non-negative integer that is the Unicode code point value of the character starting at
 * the given index.
 *
 * @param string String to index
 * @param index Position of the string character to be returned, in the range of 0 to
 *   length(string)-1
 * @returns Non-negative integer representing the code point value of the character at the given
 *   index, or undefined if there is no element at that position
 */
export declare function codePointAt(string: string, index: number): number | undefined;
/**
 * This function mirrors the `endsWith` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Determines whether a string ends with the characters of this string.
 *
 * @param string String to search through
 * @param searchString Characters to search for at the end of the string
 * @param endPosition End position where searchString is expected to be found. Default is
 *   `length(string)`
 * @returns True if it ends with searchString, false if it does not
 */
export declare function endsWith(string: string, searchString: string, endPosition?: number): boolean;
/**
 * Formats a string into an array of objects (adjacent strings are concatenated in one array entry),
 * replacing `{replacer key}` with the value in the `replacers` at that replacer key (or multiple
 * replacer values if there are multiple in the string). Will also remove \ before curly braces if
 * curly braces are escaped with a backslash in order to preserve the curly braces. E.g. 'Hi, this
 * is {name}! I like `\{curly braces\}`! would become Hi, this is Jim! I like {curly braces}!
 *
 * If the key in unescaped braces is not found, returns the key without the braces. Empty unescaped
 * curly braces will just return a string without the braces e.g. ('I am {Nemo}', { 'name': 'Jim'})
 * would return 'I am Nemo'.
 *
 * Note: React elements can be used as replacer values.
 *
 * @example
 *
 * ```tsx
 * <p>
 *   {formatReplacementStringToArray('Hi {other}! I am {name}.', {
 *     other: 'Billy',
 *     name: <span className="tw-text-red-500">Jim</span>,
 *   })}
 * </p>
 * ```
 *
 * @example
 *
 * ```typescript
 * formatReplacementStringToArray(
 *   'Hi, this is {name}! I like \{curly braces\}! I have a {carInfo} car. My favorite food is {food}.',
 *   { name: ['Bill'], carInfo: { year: 2015, color: 'blue' } }
 * );
 *
 * =>
 *
 * ['Hi, this is ', ['Bill'], '! I like {curly braces}! I have a ', { year: 2015, color: 'blue' }, ' car. My favorite food is food.']
 * ```
 *
 * @param str String to format and break out into an array of objects
 * @param replacers Object whose keys are replacer keys and whose values are the values with which
 *   to replace `{replacer key}`s found in the string to format. If the replacer value is a string,
 *   it will be concatenated into existing strings in the array. Otherwise, the replacer value will
 *   be added as a new entry in the array
 * @returns Array of formatted strings and replaced objects
 */
export declare function formatReplacementStringToArray<T = unknown>(str: string, replacers: {
	[key: string | number]: T;
} | object): (string | T)[];
/**
 * Formats a string, replacing `{replacer key}` with the value in the `replacers` at that replacer
 * key (or multiple replacer values if there are multiple in the string). Will also remove \ before
 * curly braces if curly braces are escaped with a backslash in order to preserve the curly braces.
 * E.g. 'Hi, this is {name}! I like `\{curly braces\}`! would become Hi, this is Jim! I like {curly
 * braces}!
 *
 * If the key in unescaped braces is not found, returns the key without the braces. Empty unescaped
 * curly braces will just return a string without the braces e.g. ('I am {Nemo}', { 'name': 'Jim'})
 * would return 'I am Nemo'.
 *
 * @example
 *
 * ```typescript
 * formatReplacementString(
 *   'Hi, this is {name}! I like \{curly braces\}! I have a {carColor} car. My favorite food is {food}.',
 *   { name: 'Bill', carColor: 'blue' }
 * );
 *
 * =>
 *
 * 'Hi, this is Bill! I like {curly braces}! I have a blue car. My favorite food is food.'
 * ```
 *
 * @param str String to format
 * @param replacers Object whose keys are replacer keys and whose values are the values with which
 *   to replace `{replacer key}`s found in the string to format. Will be coerced to strings using
 *   `${replacerValue}`
 * @returns Formatted string
 */
export declare function formatReplacementString(str: string, replacers: {
	[key: string | number]: string | unknown;
} | object): string;
/**
 * This function mirrors the `includes` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Performs a case-sensitive search to determine if searchString is found in string.
 *
 * @param string String to search through
 * @param searchString String to search for
 * @param position Position within the string to start searching for searchString. Default is `0`
 * @returns True if search string is found, false if it is not
 */
export declare function includes(string: string, searchString: string, position?: number): boolean;
/**
 * This function mirrors the `indexOf` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns the index of the first occurrence of a given string.
 *
 * @param string String to search through
 * @param searchString The string to search for
 * @param position Start of searching. Default is `0`
 * @returns Index of the first occurrence of a given string
 */
export declare function indexOf(string: string, searchString: string, position?: number | undefined): number;
/**
 * This function mirrors the `lastIndexOf` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Searches this string and returns the index of the last occurrence of the specified substring.
 *
 * @param string String to search through
 * @param searchString Substring to search for
 * @param position The index at which to begin searching. If omitted, the search begins at the end
 *   of the string. Default is `undefined`
 * @returns Index of the last occurrence of searchString found, or -1 if not found.
 */
export declare function lastIndexOf(string: string, searchString: string, position?: number): number;
/**
 * This function mirrors the `length` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes. Since `length` appears to be a
 * reserved keyword, the function was renamed to `stringLength`
 *
 * Returns the length of a string.
 *
 * @param string String to return the length for
 * @returns Number that is length of the starting string
 */
export declare function stringLength(string: string): number;
/**
 * This function mirrors the `normalize` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns the Unicode Normalization Form of this string.
 *
 * @param string The starting string
 * @param form Form specifying the Unicode Normalization Form. Default is `'NFC'`
 * @returns A string containing the Unicode Normalization Form of the given string.
 */
export declare function normalize(string: string, form: "NFC" | "NFD" | "NFKC" | "NFKD" | "none"): string;
/**
 * Compares two strings using an ordinal comparison approach based on the specified collation
 * options. This function uses the built-in `localeCompare` method with the 'en' locale and the
 * provided collation options to compare the strings.
 *
 * @param string1 The first string to compare.
 * @param string2 The second string to compare.
 * @param options Optional. The collation options used for comparison.
 * @returns A number indicating the result of the comparison: - Negative value if string1 precedes
 *   string2 in sorting order. - Zero if string1 and string2 are equivalent in sorting order. -
 *   Positive value if string1 follows string2 in sorting order.
 */
export declare function ordinalCompare(string1: string, string2: string, options?: Intl.CollatorOptions): number;
/**
 * This function mirrors the `padEnd` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Pads this string with another string (multiple times, if needed) until the resulting string
 * reaches the given length. The padding is applied from the end of this string.
 *
 * @param string String to add padding too
 * @param targetLength The length of the resulting string once the starting string has been padded.
 *   If value is less than or equal to length(string), then string is returned as is.
 * @param padString The string to pad the current string with. If padString is too long to stay
 *   within targetLength, it will be truncated. Default is `" "`
 * @returns String with appropriate padding at the end
 */
export declare function padEnd(string: string, targetLength: number, padString?: string): string;
/**
 * This function mirrors the `padStart` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Pads this string with another string (multiple times, if needed) until the resulting string
 * reaches the given length. The padding is applied from the start of this string.
 *
 * @param string String to add padding too
 * @param targetLength The length of the resulting string once the starting string has been padded.
 *   If value is less than or equal to length(string), then string is returned as is.
 * @param padString The string to pad the current string with. If padString is too long to stay
 *   within the targetLength, it will be truncated from the end. Default is `" "`
 * @returns String with of specified targetLength with padString applied from the start
 */
export declare function padStart(string: string, targetLength: number, padString?: string): string;
/**
 * This function mirrors the `slice` function from the JavaScript Standard String object. It handles
 * Unicode code points instead of UTF-16 character codes.
 *
 * Extracts a section of this string and returns it as a new string, without modifying the original
 * string.
 *
 * @param string The starting string
 * @param indexStart The index of the first character to include in the returned substring.
 * @param indexEnd The index of the first character to exclude from the returned substring.
 * @returns A new string containing the extracted section of the string.
 */
export declare function slice(string: string, indexStart: number, indexEnd?: number): string;
/**
 * This function mirrors the `split` function from the JavaScript Standard String object. It handles
 * Unicode code points instead of UTF-16 character codes.
 *
 * Takes a pattern and divides the string into an ordered list of substrings by searching for the
 * pattern, puts these substrings into an array, and returns the array.
 *
 * @param string The string to split
 * @param separator The pattern describing where each split should occur
 * @param splitLimit Limit on the number of substrings to be included in the array. Splits the
 *   string at each occurrence of specified separator, but stops when limit entries have been placed
 *   in the array.
 * @returns An array of strings, split at each point where separator occurs in the starting string.
 *   Returns undefined if separator is not found in string.
 */
export declare function split(string: string, separator: string | RegExp, splitLimit?: number): string[];
/**
 * This function mirrors the `startsWith` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Determines whether the string begins with the characters of a specified string, returning true or
 * false as appropriate.
 *
 * @param string String to search through
 * @param searchString The characters to be searched for at the start of this string.
 * @param position The start position at which searchString is expected to be found (the index of
 *   searchString's first character). Default is `0`
 * @returns True if the given characters are found at the beginning of the string, including when
 *   searchString is an empty string; otherwise, false.
 */
export declare function startsWith(string: string, searchString: string, position?: number): boolean;
/**
 * This function mirrors the `substring` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns a substring by providing start and end position.
 *
 * @param string String to be divided
 * @param begin Start position
 * @param end End position. Default is `End of string`
 * @returns Substring from starting string
 */
export declare function substring(string: string, begin: number, end?: number): string;
/**
 * This function mirrors the `toArray` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Converts a string to an array of string characters.
 *
 * @param string String to convert to array
 * @returns An array of characters from the starting string
 */
export declare function toArray(string: string): string[];
/** Determine whether the string is a `LocalizeKey` meant to be localized in Platform.Bible. */
export declare function isLocalizeKey(str: string): str is LocalizeKey;
/**
 * Escape RegExp special characters.
 *
 * You can also use this to escape a string that is inserted into the middle of a regex, for
 * example, into a character class.
 *
 * All credit to [`escape-string-regexp`](https://www.npmjs.com/package/escape-string-regexp) - this
 * function is simply copied directly from there to allow a common js export
 *
 * @example
 *
 *     import escapeStringRegexp from 'platform-bible-utils';
 *
 *     const escapedString = escapeStringRegexp('How much $ for a ?');
 *     //=> 'How much \\$ for a \\?'
 *
 *     new RegExp(escapedString);
 */
export declare function escapeStringRegexp(string: string): string;
/**
 * Transforms a string or an array of strings into an array of regular expressions, ensuring that
 * the result is always an array.
 *
 * This function accepts a value that may be a single string, an array of strings, or `undefined`.
 * It then:
 *
 * - Converts each string into a `RegExp` object.
 * - If the input is an array containing nested arrays, it converts each string in the nested arrays
 *   into `RegExp` objects.
 * - Ensures that the result is always an array of `RegExp` objects or arrays of `RegExp` objects.
 *
 * @param stringStringMaybeArray - The value to be transformed, which can be a single string, an
 *   array of strings or arrays of strings, or `undefined`.
 * @returns An array of `RegExp` objects or arrays of `RegExp` objects. If the input is `undefined`,
 *   an empty array is returned.
 */
export declare function transformAndEnsureRegExpRegExpArray(stringStringMaybeArray: string | (string | string[])[] | undefined): (RegExp | RegExp[])[];
/**
 * Transforms a string or an array of strings into an array of regular expressions.
 *
 * This function accepts a value that may be a single string, an array of strings, or `undefined`.
 * It then:
 *
 * - Converts each string into a `RegExp` object.
 * - Ensures that the result is always an array of `RegExp` objects.
 *
 * @param stringMaybeArray - The value to be transformed, which can be a single string, an array of
 *   strings, or `undefined`.
 * @returns An array of `RegExp` objects. If the input is `undefined`, an empty array is returned.
 */
export declare function transformAndEnsureRegExpArray(stringMaybeArray: string | string[] | undefined): RegExp[];
/**
 * Determines whether a string contains one or more white space characters and no other characters.
 *
 * This implementation uses [dotnet's `Char.IsWhiteSpace` definition of white
 * space](https://learn.microsoft.com/en-us/dotnet/api/system.char.iswhitespace?view=net-9.0):
 *
 * ```ts
 * /^[\u000C\u000A\u000D\u0009\u000B\u0020\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\u0085]+$/.test(
 *   ch,
 * );
 * ```
 *
 * Note: This differs from
 * [`/\s/.test(ch)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes#:~:text=Matches%20a%20single%20white%20space%20character%2C%20including%20space)
 * (usually considered the determiner of what is white space in JavaScript) in that it does not
 * include ZWNBSP (U+FEFF) but rather includes NEXT LINE (U+0085)
 *
 * @param ch Single character or a string of characters
 * @returns `true` if the string consists of one or more white space characters and no other
 *   characters, `false` otherwise
 */
export declare function isWhiteSpace(ch: string): boolean;
/**
 * Converts PascalCase or camelCase string to kebab-case. To detect upper- and lower-case
 * characters, uses `.toUpperCase` and `.toLowerCase` to be locale-independent.
 *
 * Current implementation supports only UTF-16.
 *
 * Thanks to ChatGPT https://chatgpt.com/share/67c8aa44-e054-800c-8068-e1e6630081f7
 */
export declare function toKebabCase(input: string): string;
/**
 * Check that two objects are deeply equal, comparing members of each object and such
 *
 * @param a The first object to compare
 * @param b The second object to compare
 *
 *   WARNING: Objects like arrays from different iframes have different constructor function
 *   references even if they do the same thing, so this deep equality comparison fails objects that
 *   look the same but have different constructors because different constructors could produce
 *   false positives in [a few specific
 *   situations](https://github.com/planttheidea/fast-equals/blob/a41afc0a240ad5a472e47b53791e9be017f52281/src/comparator.ts#L96).
 *   This means that two objects like arrays from different iframes that look the same will fail
 *   this check. Please use some other means to check deep equality in those situations.
 *
 *   Note: This deep equality check considers `undefined` values on keys of objects NOT to be equal to
 *   not specifying the key at all. For example, `{ stuff: 3, things: undefined }` and `{ stuff: 3
 *   }` are not considered equal in this case
 *
 *   - For more information and examples, see [this
 *       CodeSandbox](https://codesandbox.io/s/deepequallibrarycomparison-4g4kk4?file=/src/index.mjs).
 *
 * @returns True if a and b are deeply equal; false otherwise
 */
export declare function deepEqual(a: unknown, b: unknown): boolean;
/**
 * Check if one object is a subset of the other object. "Subset" means that all properties of one
 * object are present in the other object, and if they are present that all values of those
 * properties are deeply equal. Sub-objects are also checked to be subsets of the corresponding
 * sub-object in the other object.
 *
 * @example ObjB is a subset of objA given these objects:
 *
 * ```ts
 * objA = { name: 'Alice', age: 30, address: { city: 'Seattle', state: 'Washington' } };
 * objB = { name: 'Alice', address: { city: 'Seattle' } };
 * ```
 *
 * It is important to note that only arrays of primitives (i.e., booleans, numbers, strings) are
 * supported. In particular, objects in arrays will not be checked for deep equality. Also, presence
 * in an array is all this checks, not the number of times that an item appears in an array. `[1,
 * 1]` is a subset of `[1]`.
 *
 * @param objectWithAllProperties Object to be checked if it is a superset of
 *   `objectWithPartialProperties`
 * @param objectWithPartialProperties Object to be checked if it is a subset of
 *   `objectWithAllProperties`
 * @returns True if `objectWithAllProperties` contains all the properties of
 *   `objectWithPartialProperties` and all values of those properties are deeply equal
 */
export declare function isSubset(objectWithAllProperties: unknown, objectWithPartialProperties: unknown): boolean;
/**
 * Converts a JavaScript value to a JSON string, changing `undefined` properties in the JavaScript
 * object to `null` properties in the JSON string.
 *
 * WARNING: `null` values will become `undefined` values after passing through {@link serialize} then
 * {@link deserialize}. For example, `{ a: 1, b: undefined, c: null }` will become `{ a: 1, b:
 * undefined, c: undefined }`. If you are passing around user data that needs to retain `null`
 * values, you should wrap them yourself in a string before using this function. Alternatively, you
 * can write your own replacer that will preserve `null` in a way that you can recover later.
 *
 * @param value A JavaScript value, usually an object or array, to be converted.
 * @param replacer A function that transforms the results. Note that all `undefined` values returned
 *   by the replacer will be further transformed into `null` in the JSON string.
 * @param space Adds indentation, white space, and line break characters to the return-value JSON
 *   text to make it easier to read. See the `space` parameter of `JSON.stringify` for more
 *   details.
 */
export declare function serialize(value: unknown, replacer?: (this: unknown, key: string, value: unknown) => unknown, space?: string | number): string;
/**
 * Converts a JSON string into a value, converting all `null` properties from JSON into `undefined`
 * in the returned JavaScript value/object.
 *
 * WARNING: `null` values will become `undefined` values after passing through {@link serialize} then
 * {@link deserialize}. For example, `{ a: 1, b: undefined, c: null }` will become `{ a: 1, b:
 * undefined, c: undefined }`. If you are passing around user data that needs to retain `null`
 * values, you should wrap them yourself in a string before using this function. Alternatively, you
 * can write your own replacer that will preserve `null` in a way that you can recover later.
 *
 * @param value A valid JSON string.
 * @param reviver A function that transforms the results. This function is called for each member of
 *   the object. If a member contains nested objects, the nested objects are transformed before the
 *   parent object is. Note that `null` values are converted into `undefined` values after the
 *   reviver has run.
 */
export declare function deserialize(value: string, reviver?: (this: unknown, key: string, value: unknown) => unknown): any;
/**
 * Check to see if the value is serializable without losing information
 *
 * @param value Value to test
 * @returns True if serializable; false otherwise
 *
 *   Note: the values `undefined` and `null` are serializable (on their own or in an array), but
 *   `null` values get transformed into `undefined` when serializing/deserializing.
 *
 *   WARNING: This is inefficient right now as it stringifies, parses, stringifies, and === the value.
 *   Please only use this if you need to
 *
 *   DISCLAIMER: this does not successfully detect that values are not serializable in some cases:
 *
 *   - Losses of removed properties like functions and `Map`s
 *   - Class instances (not deserializable into class instances without special code)
 *
 *   We intend to improve this in the future if it becomes important to do so. See [`JSON.stringify`
 *   documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description)
 *   for more information.
 */
export declare function isSerializable(value: unknown): boolean;
/**
 * HTML Encodes the provided string. Thanks to ChatGPT
 *
 * @param str String to HTML encode
 * @returns HTML-encoded string
 */
export declare const htmlEncode: (str: string) => string;
/**
 * Retrieves the current locale of the user's environment.
 *
 * @returns A string representing the current locale. If the locale cannot be determined, the
 *   function returns an empty string.
 */
export declare function getCurrentLocale(): string;
/**
 * Formats a number according to the locale and formatting options of this NumberFormat object
 *
 * @example FormatBytes(1024) => "1 KB"
 *
 * @example FormatBytes(1024, 0) => "1 KB"
 *
 * @param fileSize Number to format
 * @param decimals Number of decimal places to round to
 * @returns String representing the given number formatted according to the locale and formatting
 *   options of this NumberFormat object
 */
export declare function formatBytes(fileSize: number, decimals?: number): string;
/**
 * Ensures that the given input is returned as an array.
 *
 * This function takes a value that might be a single item, an array, or `undefined` and returns it
 * as an array:
 *
 * - If the input is `undefined`, an empty array is returned.
 * - If the input is already an array, it is returned as-is.
 * - If the input is a single item, it is wrapped in an array.
 *
 * @typeParam T - The type of the elements in the array.
 * @param maybeArray - The value that may be a single item, an array, or `undefined`.
 * @returns An array containing the input value(s). If the input is `undefined`, an empty array is
 *   returned.
 */
export declare function ensureArray<T>(maybeArray: T | T[] | undefined): T[];
/**
 * Get a localized string representation of the time between two dates
 *
 * @example
 *
 * `since` = 3 Aug 2024 8:00 AM
 *
 * `to` = 5 Aug 2024 8:000 AM
 *
 * Returns: "two days ago"
 *
 * @param since "Destination" time. time against which to get the time span.
 * @param to "Starting" time. Time span will be formatted relative to `to`. Defaults to `new Date()`
 * @returns Time span in words from `to` to `since`
 */
export declare function formatTimeSpan(relativeTimeFormatter: Intl.RelativeTimeFormat, since: Date, to?: Date): string;
/** Localized string value associated with this key */
export type LocalizedStringValue = string;
/** The data an extension provides to inform Platform.Bible of the localized strings it provides. */
export interface LocalizedStringDataContribution {
	[k: string]: unknown;
	metadata?: StringsMetadata;
	localizedStrings?: {
		[k: string]: LanguageStrings;
	};
}
/**
 * Map whose keys are localized string keys and whose values provide additional non-locale-specific
 * information about the localized string key
 */
export interface StringsMetadata {
	[k: LocalizeKey]: StringMetadata;
}
/** Additional non-locale-specific information about a localized string key */
export interface StringMetadata {
	[k: string]: unknown;
	/**
	 * Localized string key from which to get this value if one does not exist in the specified
	 * language. If a new key/value pair needs to be made to replace an existing one, this could help
	 * smooth over the transition if the meanings are close enough
	 *
	 * You can use Paratext 9 Localized String Keys here. Be sure to escape any % signs with a
	 * backslash `\`.
	 */
	fallbackKey?: LocalizeKey;
	/**
	 * Additional information provided by developers in English to help the translator to know how to
	 * translate this localized string accurately
	 */
	notes?: string;
}
/**
 * Map whose keys are localized string keys and whose values provide information about how to
 * localize strings for the localized string key
 */
export interface LanguageStrings {
	[k: LocalizeKey]: LocalizedStringValue;
}
/** JSON schema object that aligns with the LocalizedStringDataContribution type */
export declare const localizedStringsDocumentSchema: {
	$schema: string;
	title: string;
	description: string;
	type: string;
	properties: {
		metadata: {
			$ref: string;
		};
		localizedStrings: {
			type: string;
			additionalProperties: {
				$ref: string;
			};
		};
	};
	$defs: {
		languageStrings: {
			description: string;
			type: string;
			patternProperties: {
				"^%[\\w\\-\\.]+%$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		localizedStringValue: {
			description: string;
			type: string;
		};
		stringsMetadata: {
			description: string;
			type: string;
			patternProperties: {
				"^%[\\w\\-\\.]+%$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		stringMetadata: {
			description: string;
			type: string;
			properties: {
				fallbackKey: {
					description: string;
					type: string;
					pattern: string;
					tsType: string;
				};
				notes: {
					description: string;
					type: string;
				};
			};
		};
		localizeKey: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
	};
};
export type ResourceType = "ScriptureResource" | "EnhancedResource" | "XmlResource" | "SourceLanguageResource";
export type DblResourceData = {
	dblEntryUid: string;
	displayName: string;
	fullName: string;
	bestLanguageName: string;
	type: ResourceType;
	size: number;
	installed: boolean;
	updateAvailable: boolean;
	projectId: string;
};
/** The data an extension provides to inform Platform.Bible of the settings it provides */
export type SettingsContribution = SettingsGroup | SettingsGroup[];
/** A description of an extension's setting entry */
export type Setting = ExtensionControlledSetting;
/** Setting definition that is validated by the extension. */
export type ExtensionControlledSetting = SettingBase & ModifierExtensionControlled;
/** Base information needed to describe a setting entry */
export type SettingBase = StateBase & {
	[k: string]: unknown;
	/** LocalizeKey that displays in the settings dialog as the setting name */
	label: LocalizeKey;
	/** LocalizeKey that displays in the settings dialog to describe the setting */
	description?: LocalizeKey;
};
/** The data an extension provides to inform Platform.Bible of the project settings it provides */
export type ProjectSettingsContribution = ProjectSettingsGroup | ProjectSettingsGroup[];
/** A description of an extension's setting entry */
export type ProjectSetting = ExtensionControlledProjectSetting;
/** Setting definition that is validated by the extension. */
export type ExtensionControlledProjectSetting = ProjectSettingBase & ModifierExtensionControlled;
/** Base information needed to describe a project setting entry */
export type ProjectSettingBase = SettingBase & ModifierProject;
/** A description of an extension's user state entry */
export type UserState = ExtensionControlledState;
/** State definition that is validated by the extension. */
export type ExtensionControlledState = StateBase & ModifierExtensionControlled;
/** Group of related settings definitions */
export interface SettingsGroup {
	[k: string]: unknown;
	/** LocalizeKey that displays in the settings dialog as the group name */
	label: LocalizeKey;
	/** LocalizeKey that displays in the settings dialog to describe the group */
	description?: LocalizeKey;
	properties: SettingProperties;
}
/** Object whose keys are setting IDs and whose values are settings objects */
export interface SettingProperties {
	[k: ReferencedItem]: Setting;
}
/** Base information needed to describe a state entry */
export interface StateBase {
	[k: string]: unknown;
	/** Default value for the state/setting */
	default: unknown;
	/**
	 * A state/setting ID whose value to set to this state/setting's starting value the first time
	 * this state/setting is loaded
	 */
	derivesFrom?: ReferencedItem;
}
/**
 * Modifies state/setting type to be extension-controlled. "Extension-controlled" means the
 * extension provides the component and the validator for the state/setting, so the state/setting is
 * controlled by the extension.
 */
export interface ModifierExtensionControlled {
	[k: string]: unknown;
	platformType?: undefined;
	type?: undefined;
}
/** Group of related settings definitions */
export interface ProjectSettingsGroup {
	[k: string]: unknown;
	/** LocalizeKey that displays in the project settings dialog as the group name */
	label: LocalizeKey;
	/** LocalizeKey that displays in the project settings dialog to describe the group */
	description?: LocalizeKey;
	properties: ProjectSettingProperties;
}
/** Object whose keys are setting IDs and whose values are settings objects */
export interface ProjectSettingProperties {
	[k: ReferencedItem]: ProjectSetting;
}
export interface ModifierProject {
	/**
	 * String representation of `RegExp` pattern(s) to match against projects' `projectInterface`s
	 * (using the
	 * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) to determine if they should be included.
	 *
	 * If this is one string, it will be matched against `projectInterface`s. If this is an array,
	 * each entry is handled based on its type (at least one entry must match for this filter
	 * condition to pass):
	 *
	 * - If the entry is a string, it will be matched against each `projectInterface`. If any match, the
	 *   project will pass this filter condition
	 * - If the entry is an array of strings, each will be matched against each `projectInterface`. If
	 *   every string matches against at least one `projectInterface`, the project will pass this
	 *   filter condition
	 *
	 * In other words, each entry in the first-level array is `OR`'ed together. Each entry in
	 * second-level arrays (arrays within the first-level array) are `AND`'ed together.
	 *
	 * Defaults to all {@link ProjectInterfaces}, so all projects that do not match
	 * `excludeProjectInterfaces` will be included
	 *
	 * @example
	 *
	 * ```typescript
	 * includeProjectInterfaces: ['one', ['two', 'three']];
	 * ```
	 *
	 * This filter condition will succeed on projects whose `projectInterface`s fulfill at least one
	 * of the following conditions (At least one entry in the array must match):
	 *
	 * - Include `one`
	 * - Include both `two` and `three`.
	 */
	includeProjectInterfaces?: undefined | string | (string | string[])[];
	/**
	 * String representation of `RegExp` pattern(s) to match against projects' `projectInterface`s
	 * (using the
	 * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) to determine if they should absolutely not be included even if they match with
	 * `includeProjectInterfaces`.
	 *
	 * If this is one string, it will be matched against `projectInterface`s. If this is an array,
	 * each entry is handled based on its type (at least one entry must match for this filter
	 * condition to exclude the project):
	 *
	 * - If the entry is a string, it will be matched against each `projectInterface`. If any match, the
	 *   project will pass this filter condition and exclude the project
	 * - If the entry is an array of strings, each will be matched against each `projectInterface`. If
	 *   every string matches against at least one `projectInterface`, the project will pass this
	 *   filter condition and exclude the project
	 *
	 * In other words, each entry in the first-level array is `OR`'ed together. Each entry in
	 * second-level arrays (arrays within the first-level array) are `AND`'ed together.
	 *
	 * Defaults to no {@link ProjectInterfaces}, so all projects that match `includeProjectInterfaces`
	 * will be included
	 *
	 * @example
	 *
	 * ```typescript
	 * excludeProjectInterfaces: ['one', ['two', 'three']];
	 * ```
	 *
	 * This filter condition will succeed and exclude projects whose `projectInterface`s fulfill at
	 * least one of the following conditions (At least one entry in the array must match):
	 *
	 * - Include `one`
	 * - Include both `two` and `three`.
	 */
	excludeProjectInterfaces?: undefined | string | (string | string[])[];
	/**
	 * String representation of `RegExp` pattern(s) to match against the Project Data Provider Factory
	 * Ids that provided each project's metadata (using the
	 * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) to determine if the projects should be included.
	 *
	 * Defaults to all Project Data Provider Factory Ids, so all projects that do not match
	 * `excludePdpFactoryIds` will be included
	 */
	includePdpFactoryIds?: undefined | string | string[];
	/**
	 * String representation of `RegExp` pattern(s) to match against the Project Data Provider Factory
	 * Ids that provided each project's metadata (using the
	 * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) to determine if the projects should absolutely not be included even if they match
	 * with `includeProjectInterfaces`.
	 *
	 * Defaults to none, so all projects that match `includePdpFactoryIds` will be included
	 */
	excludePdpFactoryIds?: undefined | string | string[];
}
/** The data an extension provides to inform Platform.Bible of the user state it provides */
export interface UserStateContribution {
	[k: ReferencedItem]: UserState;
}
/** The data an extension provides to inform Platform.Bible of the project state it provides */
export interface ProjectStateContribution {
	[k: ReferencedItem]: UserState;
}
/** JSON schema object that aligns with the ProjectSettingsContribution type */
export declare const projectSettingsDocumentSchema: {
	$schema: string;
	title: string;
	description: string;
	anyOf: ({
		$ref: string;
		type?: undefined;
		items?: undefined;
	} | {
		type: string;
		items: {
			$ref: string;
		};
		$ref?: undefined;
	})[];
	$defs: {
		projectSettingsContribution: {
			description: string;
			anyOf: ({
				$ref: string;
				type?: undefined;
				items?: undefined;
			} | {
				type: string;
				items: {
					$ref: string;
				};
				$ref?: undefined;
			})[];
		};
		projectSettingsGroup: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				description: {
					description: string;
					$ref: string;
				};
				properties: {
					$ref: string;
				};
			};
			required: string[];
		};
		projectSettingProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		projectSetting: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledProjectSetting: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		projectSettingBase: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		modifierProject: {
			description: string;
			type: string;
			properties: {
				includeProjectInterfaces: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							anyOf: ({
								type: string;
								items?: undefined;
							} | {
								type: string;
								items: {
									type: string;
								};
							})[];
						};
					})[];
				};
				excludeProjectInterfaces: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							anyOf: ({
								type: string;
								items?: undefined;
							} | {
								type: string;
								items: {
									type: string;
								};
							})[];
						};
					})[];
				};
				includePdpFactoryIds: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							type: string;
						};
					})[];
				};
				excludePdpFactoryIds: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							type: string;
						};
					})[];
				};
			};
		};
		settingsContribution: {
			description: string;
			anyOf: ({
				$ref: string;
				type?: undefined;
				items?: undefined;
			} | {
				type: string;
				items: {
					$ref: string;
				};
				$ref?: undefined;
			})[];
		};
		settingsGroup: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				description: {
					description: string;
					$ref: string;
				};
				properties: {
					$ref: string;
				};
			};
			required: string[];
		};
		settingProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w-]+\\.[\\w-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		setting: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledSetting: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		settingBase: {
			description: string;
			allOf: ({
				$ref: string;
				type?: undefined;
				properties?: undefined;
				required?: undefined;
			} | {
				type: string;
				properties: {
					label: {
						description: string;
						$ref: string;
					};
					description: {
						description: string;
						$ref: string;
					};
				};
				required: string[];
				$ref?: undefined;
			})[];
		};
		projectStateContribution: {
			description: string;
			$ref: string;
		};
		userStateContribution: {
			description: string;
			$ref: string;
		};
		userStateProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		userState: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledState: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		modifierExtensionControlled: {
			description: string;
			not: {
				anyOf: {
					type: string;
					required: string[];
				}[];
			};
		};
		stateBase: {
			description: string;
			type: string;
			properties: {
				default: {
					description: string;
					type: string;
				};
				derivesFrom: {
					description: string;
					$ref: string;
				};
			};
			required: string[];
		};
		localizeKey: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
		id: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
	};
};
/** JSON schema object that aligns with the {@link SettingsContribution} type */
export declare const settingsDocumentSchema: {
	$schema: string;
	title: string;
	description: string;
	anyOf: ({
		$ref: string;
		type?: undefined;
		items?: undefined;
	} | {
		type: string;
		items: {
			$ref: string;
		};
		$ref?: undefined;
	})[];
	$defs: {
		projectSettingsContribution: {
			description: string;
			anyOf: ({
				$ref: string;
				type?: undefined;
				items?: undefined;
			} | {
				type: string;
				items: {
					$ref: string;
				};
				$ref?: undefined;
			})[];
		};
		projectSettingsGroup: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				description: {
					description: string;
					$ref: string;
				};
				properties: {
					$ref: string;
				};
			};
			required: string[];
		};
		projectSettingProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		projectSetting: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledProjectSetting: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		projectSettingBase: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		modifierProject: {
			description: string;
			type: string;
			properties: {
				includeProjectInterfaces: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							anyOf: ({
								type: string;
								items?: undefined;
							} | {
								type: string;
								items: {
									type: string;
								};
							})[];
						};
					})[];
				};
				excludeProjectInterfaces: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							anyOf: ({
								type: string;
								items?: undefined;
							} | {
								type: string;
								items: {
									type: string;
								};
							})[];
						};
					})[];
				};
				includePdpFactoryIds: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							type: string;
						};
					})[];
				};
				excludePdpFactoryIds: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							type: string;
						};
					})[];
				};
			};
		};
		settingsContribution: {
			description: string;
			anyOf: ({
				$ref: string;
				type?: undefined;
				items?: undefined;
			} | {
				type: string;
				items: {
					$ref: string;
				};
				$ref?: undefined;
			})[];
		};
		settingsGroup: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				description: {
					description: string;
					$ref: string;
				};
				properties: {
					$ref: string;
				};
			};
			required: string[];
		};
		settingProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w-]+\\.[\\w-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		setting: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledSetting: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		settingBase: {
			description: string;
			allOf: ({
				$ref: string;
				type?: undefined;
				properties?: undefined;
				required?: undefined;
			} | {
				type: string;
				properties: {
					label: {
						description: string;
						$ref: string;
					};
					description: {
						description: string;
						$ref: string;
					};
				};
				required: string[];
				$ref?: undefined;
			})[];
		};
		projectStateContribution: {
			description: string;
			$ref: string;
		};
		userStateContribution: {
			description: string;
			$ref: string;
		};
		userStateProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		userState: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledState: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		modifierExtensionControlled: {
			description: string;
			not: {
				anyOf: {
					type: string;
					required: string[];
				}[];
			};
		};
		stateBase: {
			description: string;
			type: string;
			properties: {
				default: {
					description: string;
					type: string;
				};
				derivesFrom: {
					description: string;
					$ref: string;
				};
			};
			required: string[];
		};
		localizeKey: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
		id: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
	};
};
/** Represents USJ formatted scripture with helpful utilities for working with it */
export declare class UsjReaderWriter implements IUsjReaderWriter {
	private readonly usj;
	private parentMapInternal;
	constructor(usj: Usj);
	usjChanged(): void;
	findSingleValue<T>(jsonPathQuery: string): T | undefined;
	findParent<T>(jsonPathQuery: string): T | undefined;
	private findBookId;
	private findChapterNode;
	private static createParentMapInternal;
	/** Viewing a Usj object as a tree, build a map to walk up the tree */
	private createUsjParentMap;
	/** Create the parent map if it doesn't already exist and return it */
	private get parentMap();
	/** Return the working stack applicable to the given node */
	private createWorkingStack;
	private static convertWorkingStackToJsonPath;
	private convertJsonPathToWorkingStack;
	/**
	 * Given the starting point of a tree to consider (`node`), find the rightmost MarkerObject from
	 * the array of `content`. In the following example, this would be "J".
	 *
	 *         A        <- Consider "A" to be `node`
	 *     / / | \ \
	 *     B C D E F    <- Consider these to be MarkerObjects inside the `content` array owned by "A"
	 *     |  / \  |
	 *     G H   I J    <- Consider these to be MarkerObjects inside their parents `content` arrays
	 *
	 * If "F" did not exist in this example, then "E" would be returned. If "E" and "F" didn't exist,
	 * then "I" would be returned.
	 *
	 * The general idea here is that we are looking for the MarkerObject in Usj that is immediately
	 * adjacent to whatever `node`'s next sibling is in `parent`'s `content` array.
	 */
	private static findRightMostDescendantMarkerObject;
	private static findNextMatchingNodeUsingWorkingStack;
	/**
	 * Walk through a USJ node tree depth-first, left-to-right to find the first node that matches
	 * criteria specified by `searchFunction` (i.e., the first node where `searchFunction` returns
	 * `true`)
	 */
	private findNextMatchingNode;
	nodeToJsonPath(node: MarkerObject): ContentJsonPath;
	/** Find the chapter and verse that apply to a given USJ node */
	private findVerseRefForNode;
	nodeToVerseRefAndOffset(bookId: string, node: MarkerContent, nodeParent: MarkerObject | MarkerContent[] | undefined): {
		verseRef: SerializedVerseRef;
		offset: number;
	} | undefined;
	jsonPathToVerseRefAndOffset(jsonPathQuery: string, bookId?: string): VerseRefOffset;
	verseRefToUsjContentLocation(verseRef: SerializedVerseRef, verseRefOffset?: number): UsjContentLocation;
	findNextLocationOfMatchingText(startingPoint: UsjContentLocation, text: string, maxTextLengthToSearch?: number): UsjContentLocation | undefined;
	extractText(start: UsjContentLocation, desiredLength: number): string;
	extractTextBetweenPoints(start: UsjContentLocation, end: UsjContentLocation, maxLength?: number): string;
	private static removeContentNodesFromArray;
	removeContentNodes(searchFunction: (potentiallyMatchingNode: MarkerContent) => boolean): number;
}

export {};
