// Generated by dts-bundle-generator v9.3.1

import { Mutex as AsyncMutex } from 'async-mutex';
import { ReactElement } from 'react';

/** This class provides a convenient way for one task to wait on a variable that another task sets. */
export declare class AsyncVariable<T> {
	private readonly variableName;
	private readonly promiseToValue;
	private resolver;
	private rejecter;
	/**
	 * Creates an instance of the class
	 *
	 * @param variableName Name to use when logging about this variable
	 * @param rejectIfNotSettledWithinMS Milliseconds to wait before verifying if the promise was
	 *   settled (resolved or rejected); will reject if it has not settled by that time. Use -1 if you
	 *   do not want a timeout at all.
	 */
	constructor(variableName: string, rejectIfNotSettledWithinMS?: number);
	/**
	 * Get this variable's promise to a value. This always returns the same promise even after the
	 * value has been resolved or rejected.
	 *
	 * @returns The promise for the value to be set
	 */
	get promise(): Promise<T>;
	/**
	 * A simple way to see if this variable's promise was resolved or rejected already
	 *
	 * @returns Whether the variable was already resolved or rejected
	 */
	get hasSettled(): boolean;
	/**
	 * Resolve this variable's promise to the given value
	 *
	 * @param value This variable's promise will resolve to this value
	 * @param throwIfAlreadySettled Determines whether to throw if the variable was already resolved
	 *   or rejected
	 */
	resolveToValue(value: T, throwIfAlreadySettled?: boolean): void;
	/**
	 * Reject this variable's promise for the value with the given reason
	 *
	 * @param reason This variable's promise will be rejected with this reason
	 * @param throwIfAlreadySettled Determines whether to throw if the variable was already resolved
	 *   or rejected
	 */
	rejectWithReason(reason: string, throwIfAlreadySettled?: boolean): void;
	/** Prevent any further updates to this variable */
	private complete;
}
/** Enables language-sensitive string comparison. Wraps Intl.Collator */
export declare class Collator {
	private collator;
	constructor(locales?: string | string[], options?: Intl.CollatorOptions);
	/**
	 * Compares two strings according to the sort order of this Collator object
	 *
	 * @param string1 String to compare
	 * @param string2 String to compare
	 * @returns A number indicating how string1 and string2 compare to each other according to the
	 *   sort order of this Collator object. Negative value if string1 comes before string2. Positive
	 *   value if string1 comes after string2. 0 if they are considered equal.
	 */
	compare(string1: string, string2: string): number;
	/**
	 * Returns a new object with properties reflecting the locale and collation options computed
	 * during initialization of this collator object.
	 *
	 * @returns ResolvedCollatorOptions object
	 */
	resolvedOptions(): Intl.ResolvedCollatorOptions;
}
/** Enables language-sensitive data and time formatting. Wraps Intl.DateTimeFormat */
export declare class DateTimeFormat {
	private dateTimeFormatter;
	constructor(locales?: string | string[], options?: Intl.DateTimeFormatOptions);
	/**
	 * Formats a date according to the locale and formatting option for this DateTimeFormat object
	 *
	 * @param date The date to format
	 * @returns String representing the given date formatted according to the locale and formatting
	 *   options of this DateTimeFormat object
	 */
	format(date: Date): string;
	/**
	 * Formats a date range in the most concise way based on the locales and options provided when
	 * instantiating this DateTimeFormat object
	 *
	 * @param startDate Date object representing start of the date range
	 * @param endDate Date object representing the end of the date range
	 * @returns String representing the given date range formatted according to the locale and
	 *   formatting options of this DateTimeFormat object
	 */
	formatRange(startDate: Date, endDate: Date): string;
	/**
	 * Returns an array of locale-specific tokens representing each part of the formatted date range
	 * produced by this DateTimeFormat object
	 *
	 * @param startDate Date object representing start of the date range
	 * @param endDate Date object representing the end of the date range
	 * @returns Array of DateTimeRangeFormatPart objects
	 */
	formatRangeToParts(startDate: Date, endDate: Date): Intl.DateTimeRangeFormatPart[];
	/**
	 * Allows locale-aware formatting of strings produced by this DateTimeFormat object
	 *
	 * @param date The date to format
	 * @returns Array of DateTimeFormatPart objects
	 */
	formatToParts(date: Date): Intl.DateTimeFormatPart[];
	/**
	 * Returns a new object with properties reflecting the locale and date and time formatting options
	 * computed during initialization of this DateTimeFormat object
	 *
	 * @returns ResolvedDateTimeFormatOptions object
	 */
	resolvedOptions(): Intl.ResolvedDateTimeFormatOptions;
}
/** Function to run to dispose of something. Returns true if successfully unsubscribed */
export type Unsubscriber = () => boolean;
/**
 * Returns an Unsubscriber function that combines all the unsubscribers passed in.
 *
 * @param unsubscribers All unsubscribers to aggregate into one unsubscriber
 * @returns Function that unsubscribes from all passed in unsubscribers when run
 */
export declare const aggregateUnsubscribers: (unsubscribers: Unsubscriber[]) => Unsubscriber;
/**
 * Function to run to dispose of something that runs asynchronously. The promise resolves to true if
 * successfully unsubscribed
 */
export type UnsubscriberAsync = () => Promise<boolean>;
/**
 * Returns an UnsubscriberAsync function that combines all the unsubscribers passed in.
 *
 * @param unsubscribers - All unsubscribers to aggregate into one unsubscriber.
 * @returns Function that unsubscribes from all passed in unsubscribers when run
 */
export declare const aggregateUnsubscriberAsyncs: (unsubscribers: (UnsubscriberAsync | Unsubscriber)[]) => UnsubscriberAsync;
/** Callback function that accepts an event and should run when an event is emitted */
export type PlatformEventHandler<T> = (event: T) => void;
/**
 * Function that subscribes the provided callback to run when this event is emitted.
 *
 * @param callback Function to run with the event when it is emitted
 * @returns Unsubscriber function to run to stop calling the passed-in function when the event is
 *   emitted
 */
export type PlatformEvent<T> = (callback: PlatformEventHandler<T>) => Unsubscriber;
/**
 * A PapiEvent that subscribes asynchronously and resolves an asynchronous unsubscriber.
 *
 * Note: The callback itself is not asynchronous.
 */
export type PlatformEventAsync<T> = (callback: PlatformEventHandler<T>) => Promise<UnsubscriberAsync>;
export type JsonObjectLike = {
	[key: string]: unknown;
};
export type JsonArrayLike = unknown[];
export type JsonDocumentLike = JsonObjectLike | JsonArrayLike;
/**
 * Options for DocumentCombiner objects
 *
 * - `copyDocuments`: If true, this instance will perform a deep copy of all provided documents before
 *   composing the output. If false, then changes made to provided documents after they are
 *   contributed will be reflected in the next time output is composed.
 * - `ignoreDuplicateProperties`: If true, then duplicate properties are skipped if they are seen in
 *   contributed documents. If false, then throw when duplicate properties are seen in contributed
 *   documents.
 */
export type DocumentCombinerOptions = {
	copyDocuments: boolean;
	ignoreDuplicateProperties: boolean;
};
/**
 * Base class for any code that wants to compose JSON documents (primarily in the form of JS objects
 * or arrays) together into a single output document.
 */
export declare class DocumentCombiner {
	protected baseDocument: JsonDocumentLike;
	protected readonly contributions: Map<string, JsonDocumentLike>;
	protected latestOutput: JsonDocumentLike | undefined;
	protected readonly options: DocumentCombinerOptions;
	private readonly onDidRebuildEmitter;
	/** Event that emits to announce that the document has been rebuilt and the output has been updated */
	readonly onDidRebuild: PlatformEvent<undefined>;
	/**
	 * Create a DocumentCombiner instance
	 *
	 * @param baseDocument This is the first document that will be used when composing the output
	 * @param options Options used by this object when combining documents
	 */
	protected constructor(baseDocument: JsonDocumentLike, options: DocumentCombinerOptions);
	/**
	 * Update the starting document for composition process
	 *
	 * @param baseDocument Base JSON document/JS object that all other documents are added to
	 * @returns Recalculated output document given the new starting state and existing other documents
	 */
	updateBaseDocument(baseDocument: JsonDocumentLike): JsonDocumentLike | undefined;
	/**
	 * Add or update one of the contribution documents for the composition process
	 *
	 * Note: the order in which contribution documents are added can be considered to be indeterminate
	 * as it is currently ordered by however `Map.forEach` provides the contributions. The order
	 * matters when merging two arrays into one. Also, when `options.ignoreDuplicateProperties` is
	 * `true`, the order also matters when adding the same property to an object that is already
	 * provided previously. Please let us know if you have trouble because of indeterminate
	 * contribution ordering.
	 *
	 * @param documentName Name of the contributed document to combine
	 * @param document Content of the contributed document to combine
	 * @returns Recalculated output document given the new or updated contribution and existing other
	 *   documents
	 */
	addOrUpdateContribution(documentName: string, document: JsonDocumentLike): JsonDocumentLike | undefined;
	/**
	 * Delete one of the contribution documents for the composition process
	 *
	 * @param documentName Name of the contributed document to delete
	 * @returns Recalculated output document given the remaining other documents
	 */
	deleteContribution(documentName: string): JsonDocumentLike | undefined;
	/**
	 * Delete all present contribution documents for the composition process and return to the base
	 * document
	 *
	 * @returns Recalculated output document consisting only of the base document
	 */
	deleteAllContributions(): JsonDocumentLike | undefined;
	/**
	 * Run the document composition process given the starting document and all contributions. Throws
	 * if the output document fails to validate properly.
	 *
	 * @returns Recalculated output document given the starting and contributed documents
	 */
	rebuild(): JsonDocumentLike | undefined;
	/**
	 * Transform the starting document that is given to the combiner. This transformation occurs after
	 * validating the base document and before combining any contributions.
	 *
	 * WARNING: If you do not create the combiner with option `copyDocuments: true` or clone inside
	 * this method, this method will directly modify the `baseDocument` passed in.
	 *
	 * @param baseDocument Initial input document. Already validated via `validateBaseDocument`
	 * @returns Transformed base document
	 */
	protected transformBaseDocumentAfterValidation(baseDocument: JsonDocumentLike): JsonDocumentLike;
	/**
	 * Transform the contributed document associated with `documentName`. This transformation occurs
	 * after validating the contributed document and before combining with other documents.
	 *
	 * WARNING: If you do not create the combiner with option `copyDocuments: true` or clone inside
	 * this method, this method will directly modify the contributed `document` passed in.
	 *
	 * @param documentName Name of the contributed document to combine
	 * @param document Content of the contributed document to combine. Already validated via
	 *   `validateContribution`
	 * @returns Transformed contributed document
	 */
	protected transformContributionAfterValidation(documentName: string, document: JsonDocumentLike): JsonDocumentLike;
	/**
	 * Throw an error if the provided document is not a valid starting document.
	 *
	 * @param baseDocument Base JSON document/JS object that all other documents are added to
	 */
	protected validateBaseDocument(baseDocument: JsonDocumentLike): void;
	/**
	 * Throw an error if the provided document is not a valid contribution document.
	 *
	 * @param documentName Name of the contributed document to combine
	 * @param document Content of the contributed document to combine
	 */
	protected validateContribution(documentName: string, document: JsonDocumentLike): void;
	/**
	 * Throw an error if the provided output is not valid.
	 *
	 * @param output Output document that could potentially be returned to callers
	 */
	protected validateOutput(output: JsonDocumentLike): void;
	/**
	 * Transform the document that is the composition of the base document and all contribution
	 * documents. This is the last step that will be run prior to validation via `validateOutput`
	 * before `this.latestOutput` is updated to the new output.
	 *
	 * @param finalOutput Final output document that could potentially be returned to callers. "Final"
	 *   means no further contribution documents will be merged.
	 */
	protected transformFinalOutputBeforeValidation(finalOutput: JsonDocumentLike): JsonDocumentLike;
}
/**
 * Class that allows calling asynchronous functions multiple times at once while only running one at
 * a time.
 *
 * @example
 *
 * ```typescript
 * const mutex = new Mutex();
 *
 * mutex.runExclusive(async () => {
 *   // Do some asynchronous stuff
 *   console.log('These run one-at-a-time');
 * });
 *
 * mutex.runExclusive(async () => {
 *   // Do some asynchronous stuff
 *   console.log('These run one-at-a-time');
 * });
 * ```
 *
 * See [`async-mutex`](https://www.npmjs.com/package/async-mutex) for more information.
 */
export declare class Mutex extends AsyncMutex {
}
/** Map of {@link Mutex}es that automatically (lazily) generates a new {@link Mutex} for any new key */
export declare class MutexMap {
	private mutexesByID;
	get(mutexID: string): Mutex;
}
export declare class NonValidatingDocumentCombiner extends DocumentCombiner {
	constructor(baseDocument: JsonDocumentLike, options: DocumentCombinerOptions);
	get output(): JsonDocumentLike | undefined;
}
/** Enables language-sensitive number formatting. Wraps Intl.NumberFormat */
export declare class NumberFormat {
	private numberFormatter;
	constructor(locales?: string | string[], options?: Intl.NumberFormatOptions);
	/**
	 * Formats a number according to the locale and formatting options of this NumberFormat object
	 *
	 * @param value Number or BigInt to format
	 * @returns String representing the given number formatted according to the locale and formatting
	 *   options of this NumberFormat object
	 */
	format(value: number | bigint): string;
	/**
	 * Formats a range of numbers according to the locale and formatting options of this NumberFormat
	 * object
	 *
	 * @param startRange Number or bigint representing the start of the range
	 * @param endRange Number or bigint representing the end of the range
	 * @returns String representing the given range of numbers formatted according to the locale and
	 *   formatting options of this NumberFormat object
	 */
	formatRange(startRange: number | bigint, endRange: number | bigint): string;
	/**
	 * Returns an array of objects containing the locale-specific tokens from which it is possible to
	 * build custom strings while preserving the locale-specific parts.
	 *
	 * @param startRange Number or bigint representing start of the range
	 * @param endRange Number or bigint representing end of the range
	 * @returns Array of NumberRangeFormatPart objects containing the formatted range of numbers in
	 *   parts
	 */
	formatRangeToParts(startRange: number | bigint, endRange: number | bigint): Intl.NumberRangeFormatPart[];
	/**
	 * Allows locale-aware formatting of strings produced by this NumberFormat object
	 *
	 * @param value Number or bigint to format
	 * @returns Array of NumberFormatPart objects containing the formatted number in parts
	 */
	formatToParts(value: number | bigint): Intl.NumberFormatPart[];
	/**
	 * Returns a new object with properties reflecting the locale and number formatting options
	 * computed during initialization of this NumberFormat object
	 *
	 * @returns ResolvedNumberFormatOptions object
	 */
	resolvedOptions(): Intl.ResolvedNumberFormatOptions;
}
/** Require a `dispose` function */
export interface Dispose {
	/** Release resources and notify dependent services when tearing down an object */
	dispose: UnsubscriberAsync;
}
/** Require an `onDidDispose` event */
export interface OnDidDispose {
	/** Event that emits when `dispose` is called on an object */
	onDidDispose: PlatformEvent<void>;
}
/**
 * Indicates than an object cannot have an `onDidDispose` event. Also allows an object to include a
 * `dispose` function.
 */
export interface CannotHaveOnDidDispose {
	/** Release resources and notify dependent services when tearing down an object */
	dispose?: UnsubscriberAsync;
	/** Event that emits when `dispose` is called on an object */
	onDidDispose?: undefined;
}
/** Allow onDidDispose to exist on the type if it was previously disallowed by CannotHaveOnDidDispose */
export type CanHaveOnDidDispose<T extends CannotHaveOnDidDispose> = Omit<T, "onDidDispose">;
/**
 * Event manager - accepts subscriptions to an event and runs the subscription callbacks when the
 * event is emitted Use eventEmitter.event(callback) to subscribe to the event. Use
 * eventEmitter.emit(event) to run the subscriptions. Generally, this EventEmitter should be
 * private, and its event should be public. That way, the emitter is not publicized, but anyone can
 * subscribe to the event.
 */
export declare class PlatformEventEmitter<T> implements Dispose {
	/**
	 * Subscribes a function to run when this event is emitted.
	 *
	 * @param callback Function to run with the event when it is emitted
	 * @returns Unsubscriber function to run to stop calling the passed-in function when the event is
	 *   emitted
	 * @alias event
	 */
	subscribe: PlatformEvent<T>;
	/** All callback functions that will run when this event is emitted. Lazy loaded */
	private subscriptions?;
	/** Event for listeners to subscribe to. Lazy loaded */
	private lazyEvent?;
	/** Whether this emitter has been disposed */
	private isDisposed;
	/**
	 * Event for listeners to subscribe to. Subscribes a function to run when this event is emitted.
	 * Use like `const unsubscriber = event(callback)`
	 *
	 * @param callback Function to run with the event when it is emitted
	 * @returns Unsubscriber function to run to stop calling the passed-in function when the event is
	 *   emitted
	 */
	get event(): PlatformEvent<T>;
	/** Disposes of this event, preparing it to release from memory */
	dispose: () => Promise<boolean>;
	/**
	 * Runs the subscriptions for the event
	 *
	 * @param event Event data to provide to subscribed callbacks
	 */
	emit: (event: T) => void;
	/**
	 * Function that runs the subscriptions for the event. Added here so children can override emit
	 * and still call the base functionality. See NetworkEventEmitter.emit for example
	 */
	protected emitFn(event: T): void;
	/** Check to make sure this emitter is not disposed. Throw if it is */
	protected assertNotDisposed(): void;
	/**
	 * Disposes of this event, preparing it to release from memory. Added here so children can
	 * override emit and still call the base functionality.
	 */
	protected disposeFn(): Promise<boolean>;
}
/** Simple collection for UnsubscriberAsync objects that also provides an easy way to run them. */
export declare class UnsubscriberAsyncList {
	private name;
	readonly unsubscribers: Set<Unsubscriber | UnsubscriberAsync>;
	constructor(name?: string);
	/**
	 * Add unsubscribers to the list. Note that duplicates are not added twice.
	 *
	 * @param unsubscribers - Objects that were returned from a registration process.
	 */
	add(...unsubscribers: (UnsubscriberAsync | Unsubscriber | Dispose)[]): void;
	/**
	 * Run all unsubscribers added to this list and then clear the list.
	 *
	 * @returns `true` if all unsubscribers succeeded, `false` otherwise.
	 */
	runAllUnsubscribers(): Promise<boolean>;
}
export interface ScriptureReference {
	bookNum: number;
	chapterNum: number;
	verseNum: number;
}
export interface BookInfo {
	shortName: string;
	fullNames: string[];
	chapters: number;
}
export type ScriptureNode = ScriptureReference & {
	jsonPath: string;
};
export type ScriptureTextAnchor = ScriptureNode & {
	offset: number;
};
export type ScriptureSelection = {
	start: ScriptureNode | ScriptureTextAnchor;
	end?: ScriptureNode | ScriptureTextAnchor;
};
export type ScriptureCheckDefinition = {
	id: string;
	displayName: string;
};
export declare const FIRST_SCR_BOOK_NUM = 1;
export declare const LAST_SCR_BOOK_NUM: number;
export declare const FIRST_SCR_CHAPTER_NUM = 1;
export declare const FIRST_SCR_VERSE_NUM = 1;
export declare const getChaptersForBook: (bookNum: number) => number;
export declare const offsetBook: (scrRef: ScriptureReference, offset: number) => ScriptureReference;
export declare const offsetChapter: (scrRef: ScriptureReference, offset: number) => ScriptureReference;
export declare const offsetVerse: (scrRef: ScriptureReference, offset: number) => ScriptureReference;
/**
 * https://github.com/ubsicap/Paratext/blob/master/ParatextData/SILScriptureExtensions.cs#L72
 *
 * Convert book number to a localized Id (a short description of the book). This should be used
 * whenever a book ID (short code) is shown to the user. It is primarily needed for people who do
 * not read Roman script well and need to have books identified in a alternate script (e.g. Chinese
 * or Russian)
 *
 * @param bookNumber
 * @param localizationLanguage In BCP 47 format
 * @param getLocalizedString Function that provides the localized versions of the book ids and names
 *   asynchronously.
 * @returns
 */
export declare function getLocalizedIdFromBookNumber(bookNumber: number, localizationLanguage: string, getLocalizedString: (item: {
	localizeKey: string;
	languagesToSearch?: string[];
}) => Promise<string>): Promise<string>;
/**
 * Compares two Scripture references canonically.
 *
 * @param scrRef1 The first Scripture reference to compare.
 * @param scrRef2 The second Scripture reference to compare.
 * @returns A number indicating the result of the comparison: - Negative value if scrRef1 precedes
 *   scrRef2 in sorting order. - Zero if scrRef1 and scrRef2 are equivalent in sorting order. -
 *   Positive value if scrRef1 follows scrRef2 in sorting order.
 */
export declare function compare(scrRef1: ScriptureReference, scrRef2: ScriptureReference): number;
/**
 * Formats a Scripture reference.
 *
 * @param scrRef The Scripture reference to format.
 * @param optionOrLocalizedBookName Either 'id' (the default) to format using the "standard" (as
 *   defined by SIL/UBS) 3-letter book ID, 'English' to format using the English book name spelled
 *   out, or some other string (e.g., a localized book name, vernacular abbreviation, FCBH book id,
 *   etc.) to use.
 * @param chapterVerseSeparator The character used to separate the chapter number from the verse
 *   number. Default is a colon (:). Note: More than one character is allowed.
 * @param bookChapterSeparator The character used to separate the book from the chapter number.
 *   Default is a single space. Note: More than one character is allowed.
 * @returns The formatted reference.
 */
export declare function format(scrRef: ScriptureReference, optionOrLocalizedBookName?: "id" | "English" | string, chapterVerseSeparator?: string, bookChapterSeparator?: string): string;
/** Collection of functions, objects, and types that are used as helpers in other services. */
export declare function newGuid(): string;
/**
 * Determine whether the object is a string
 *
 * @param o Object to determine if it is a string
 * @returns True if the object is a string; false otherwise
 */
export declare function isString(o: unknown): o is string;
/**
 * If deepClone isn't used when copying properties between objects, you may be left with dangling
 * references between the source and target of property copying operations.
 *
 * @param obj Object to clone
 * @returns Duplicate copy of `obj` without any references back to the original one
 */
export declare function deepClone<T>(obj: T): T;
/**
 * Get a function that reduces calls to the function passed in
 *
 * @param fn The function to debounce
 * @param delay How much delay in milliseconds after the most recent call to the debounced function
 *   to call the function
 * @returns Function that, when called, only calls the function passed in at maximum every delay ms
 */
export declare function debounce<T extends (...args: any[]) => void>(fn: T, delay?: number): T;
/**
 * Groups each item in the array of items into a map according to the keySelector
 *
 * @param items Array of items to group by
 * @param keySelector Function to run on each item to get the key for the group to which it belongs
 * @param valueSelector Function to run on each item to get the value it should have in the group
 *   (like map function). If not provided, uses the item itself
 * @returns Map of keys to groups of values corresponding to each item
 */
export declare function groupBy<T, K>(items: T[], keySelector: (item: T) => K): Map<K, Array<T>>;
export declare function groupBy<T, K, V>(items: T[], keySelector: (item: T) => K, valueSelector: (item: T, key: K) => V): Map<K, Array<V>>;
/**
 * Function to get an error message from the object (useful for getting error message in a catch
 * block)
 *
 * @example `try {...} catch (e) { logger.info(getErrorMessage(e)) }`
 *
 * @param error Error object whose message to get
 * @returns Message of the error - if object has message, returns message. Otherwise tries to
 *   stringify
 */
export declare function getErrorMessage(error: unknown): string;
/** Asynchronously waits for the specified number of milliseconds. (wraps setTimeout in a promise) */
export declare function wait(ms: number): Promise<void>;
/**
 * Runs the specified function and will timeout if it takes longer than the specified wait time
 *
 * @param fn The function to run
 * @param maxWaitTimeInMS The maximum amount of time to wait for the function to resolve
 * @returns Promise that resolves to the resolved value of the function or undefined if it ran
 *   longer than the specified wait time
 */
export declare function waitForDuration<TResult>(fn: () => Promise<TResult>, maxWaitTimeInMS: number): Promise<Awaited<TResult> | undefined>;
/**
 * Get all functions on an object and its prototype chain (so we don't miss any class methods or any
 * object methods). Note that the functions on the final item in the prototype chain (i.e., Object)
 * are skipped to avoid including functions like `__defineGetter__`, `__defineSetter__`, `toString`,
 * etc.
 *
 * @param obj Object whose functions to get
 * @param objId Optional ID of the object to use for debug logging
 * @returns Array of all function names on an object
 */
export declare function getAllObjectFunctionNames(obj: {
	[property: string]: unknown;
}, objId?: string): Set<string>;
/**
 * Creates a synchronous proxy for an asynchronous object. The proxy allows calling methods on an
 * object that is asynchronously fetched using a provided asynchronous function.
 *
 * @param getObject - A function that returns a promise resolving to the object whose asynchronous
 *   methods to call.
 * @param objectToProxy - An optional object that is the object that is proxied. If a property is
 *   accessed that does exist on this object, it will be returned. If a property is accessed that
 *   does not exist on this object, it will be considered to be an asynchronous method called on the
 *   object returned from getObject.
 * @returns A synchronous proxy for the asynchronous object.
 */
export declare function createSyncProxyForAsyncObject<T extends object>(getObject: (args?: unknown[]) => Promise<T>, objectToProxy?: Partial<T>): T;
/** Within type T, recursively change all properties to be optional */
export type DeepPartial<T> = T extends object ? {
	[P in keyof T]?: DeepPartial<T[P]>;
} : T;
/** Within type T, recursively change properties that were of type A to be of type B */
export type ReplaceType<T, A, B> = T extends A ? B : T extends object ? {
	[K in keyof T]: ReplaceType<T[K], A, B>;
} : T;
/**
 * Converts a union type to an intersection type (`|` to `&`).
 *
 * Note: this utility type is for use on object types. It may fail on other types.
 *
 * @example
 *
 * ```typescript
 * type TypeOne = { one: string };
 * type TypeTwo = { two: number };
 * type TypeThree = { three: string };
 *
 * type TypeNums = { one: TypeOne; two: TypeTwo; three: TypeThree };
 * const numNames = ['one', 'two'] as const;
 * type TypeNumNames = typeof numNames;
 *
 * // Same as `TypeOne | TypeTwo`
 * // `{ one: string } | { two: number }`
 * type TypeOneTwoUnion = TypeNums[TypeNumNames[number]];
 *
 * // Same as `TypeOne & TypeTwo`
 * // `{ one: string; two: number }`
 * type TypeOneTwoIntersection = UnionToIntersection<TypeOneTwoUnion>;
 * ```
 */
export type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;
/** Identifier for a string that will be localized in a menu based on the user's UI language */
export type LocalizeKey = `%${string}%`;
/** Name of some UI element (i.e., tab, column, group, menu item) or some PAPI object (i.e., command) */
export type ReferencedItem = `${string}.${string}`;
export type OrderedItem = {
	/** Relative order of this item compared to other items in the same parent/scope (sorted ascending) */
	order: number;
};
export type OrderedExtensibleContainer = OrderedItem & {
	/** Determines whether other items can be added to this after it has been defined */
	isExtensible?: boolean;
};
/** Group of menu items that belongs in a column */
export type MenuGroupDetailsInColumn = OrderedExtensibleContainer & {
	/** ID of column in which this group resides */
	column: ReferencedItem;
};
/** Group of menu items that belongs in a submenu */
export type MenuGroupDetailsInSubMenu = OrderedExtensibleContainer & {
	/** ID of menu item hosting the submenu in which this group resides */
	menuItem: ReferencedItem;
};
/** Column that includes header text in a menu */
export type MenuColumnWithHeader = OrderedExtensibleContainer & {
	/** Key that represents the text of the header text of the column */
	label: LocalizeKey;
};
export type MenuItemBase = OrderedItem & {
	/** Menu group to which this menu item belongs */
	group: ReferencedItem;
	/** Key that represents the text of this menu item to display */
	label: LocalizeKey;
	/** Key that represents words the platform should reference when users are searching for menu items */
	searchTerms?: LocalizeKey;
	/** Key that represents the text to display if a mouse pointer hovers over the menu item */
	tooltip?: LocalizeKey;
	/** Additional information provided by developers to help people who perform localization */
	localizeNotes: string;
};
/** Menu item that hosts a submenu */
export type MenuItemContainingSubmenu = MenuItemBase & {
	/** ID for this menu item that holds a submenu */
	id: ReferencedItem;
};
/** Menu item that runs a command */
export type MenuItemContainingCommand = MenuItemBase & {
	/** Name of the PAPI command to run when this menu item is selected. */
	command: ReferencedItem;
	/** Path to the icon to display after the menu text */
	iconPathAfter?: string;
	/** Path to the icon to display before the menu text */
	iconPathBefore?: string;
};
/**
 * Group of menu items that can be combined with other groups to form a single context menu/submenu.
 * Groups are separated using a line within the menu/submenu.
 */
export type GroupsInSingleColumnMenu = {
	/** Named menu group */
	[property: ReferencedItem]: OrderedExtensibleContainer | MenuGroupDetailsInSubMenu;
};
/**
 * Group of menu items that can be combined with other groups to form a single menu/submenu within a
 * multi-column menu. Groups are separated using a line within the menu/submenu.
 */
export type GroupsInMultiColumnMenu = {
	/** Named menu group */
	[property: ReferencedItem]: MenuGroupDetailsInColumn | MenuGroupDetailsInSubMenu;
};
/** Group of columns that can be combined with other columns to form a multi-column menu */
export type ColumnsWithHeaders = {
	/** Named column of a menu */
	[property: ReferencedItem]: MenuColumnWithHeader;
	/** Defines whether columns can be added to this multi-column menu */
	isExtensible?: boolean;
};
/** Menu that contains a column without a header */
export type SingleColumnMenu = {
	/** Groups that belong in this menu */
	groups: GroupsInSingleColumnMenu;
	/** List of menu items that belong in this menu */
	items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];
};
/** Menu that contains multiple columns with headers */
export type MultiColumnMenu = {
	/** Columns that belong in this menu */
	columns: ColumnsWithHeaders;
	/** Groups that belong in this menu */
	groups: GroupsInMultiColumnMenu;
	/** List of menu items that belong in this menu */
	items: (MenuItemContainingCommand | MenuItemContainingSubmenu)[];
};
/** Menus for one single web view */
export type WebViewMenu = {
	/** Indicates whether the platform default menus should be included for this webview */
	includeDefaults: boolean | undefined;
	/** Menu that opens when you click on the top left corner of a tab */
	topMenu: MultiColumnMenu | undefined;
	/** Menu that opens when you right click on the main body/area of a tab */
	contextMenu: SingleColumnMenu | undefined;
};
/** Menus for all web views */
export type WebViewMenus = {
	/** Named web view */
	[property: ReferencedItem]: WebViewMenu;
};
/** Platform.Bible menus before they are localized */
export type PlatformMenus = {
	/** Top level menu for the application */
	mainMenu: MultiColumnMenu;
	/** Menus that apply per web view in the application */
	webViewMenus: WebViewMenus;
	/** Default context menu for web views that don't specify their own */
	defaultWebViewContextMenu: SingleColumnMenu;
	/** Default top menu for web views that don't specify their own */
	defaultWebViewTopMenu: MultiColumnMenu;
};
/**
 * Type that converts any menu type before it is localized to what it is after it is localized. This
 * can be applied to any menu type as needed.
 */
export type Localized<T> = ReplaceType<ReplaceType<T, LocalizeKey, string>, ReferencedItem, string>;
/** JSON schema object that aligns with the PlatformMenus type */
export declare const menuDocumentSchema: {
	title: string;
	type: string;
	properties: {
		mainMenu: {
			description: string;
			$ref: string;
		};
		defaultWebViewTopMenu: {
			description: string;
			$ref: string;
		};
		defaultWebViewContextMenu: {
			description: string;
			$ref: string;
		};
		webViewMenus: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
	};
	required: string[];
	additionalProperties: boolean;
	$defs: {
		localizeKey: {
			description: string;
			type: string;
			pattern: string;
		};
		referencedItem: {
			description: string;
			type: string;
			pattern: string;
		};
		columnsWithHeaders: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					description: string;
					type: string;
					properties: {
						label: {
							description: string;
							$ref: string;
						};
						localizeNotes: {
							description: string;
							type: string;
						};
						order: {
							description: string;
							type: string;
						};
						isExtensible: {
							description: string;
							type: string;
						};
					};
					required: string[];
					additionalProperties: boolean;
				};
			};
			properties: {
				isExtensible: {
					description: string;
					type: string;
				};
			};
		};
		menuGroups: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					description: string;
					type: string;
					oneOf: ({
						properties: {
							column: {
								description: string;
								$ref: string;
							};
							order: {
								description: string;
								type: string;
							};
							isExtensible: {
								description: string;
								type: string;
							};
							menuItem?: undefined;
						};
						required: string[];
						additionalProperties: boolean;
					} | {
						properties: {
							menuItem: {
								description: string;
								$ref: string;
							};
							order: {
								description: string;
								type: string;
							};
							isExtensible: {
								description: string;
								type: string;
							};
							column?: undefined;
						};
						required: string[];
						additionalProperties: boolean;
					})[];
				};
			};
			additionalProperties: boolean;
		};
		menuItem: {
			description: string;
			type: string;
			oneOf: ({
				properties: {
					id: {
						description: string;
						$ref: string;
					};
					command?: undefined;
					iconPathBefore?: undefined;
					iconPathAfter?: undefined;
				};
				required: string[];
			} | {
				properties: {
					command: {
						description: string;
						$ref: string;
					};
					iconPathBefore: {
						description: string;
						type: string;
					};
					iconPathAfter: {
						description: string;
						type: string;
					};
					id?: undefined;
				};
				required: string[];
			})[];
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				tooltip: {
					description: string;
					$ref: string;
				};
				searchTerms: {
					description: string;
					$ref: string;
				};
				localizeNotes: {
					description: string;
					type: string;
				};
				group: {
					description: string;
					$ref: string;
				};
				order: {
					description: string;
					type: string;
				};
			};
			required: string[];
			unevaluatedProperties: boolean;
		};
		groupsAndItems: {
			description: string;
			type: string;
			properties: {
				groups: {
					description: string;
					$ref: string;
				};
				items: {
					description: string;
					type: string;
					items: {
						$ref: string;
					};
					uniqueItems: boolean;
				};
			};
			required: string[];
		};
		singleColumnMenu: {
			description: string;
			type: string;
			allOf: {
				$ref: string;
			}[];
			unevaluatedProperties: boolean;
		};
		multiColumnMenu: {
			description: string;
			type: string;
			allOf: ({
				$ref: string;
				properties?: undefined;
				required?: undefined;
			} | {
				properties: {
					columns: {
						description: string;
						$ref: string;
					};
				};
				required: string[];
				$ref?: undefined;
			})[];
			unevaluatedProperties: boolean;
		};
		menusForOneWebView: {
			description: string;
			type: string;
			properties: {
				includeDefaults: {
					description: string;
					type: string;
				};
				topMenu: {
					description: string;
					$ref: string;
				};
				contextMenu: {
					description: string;
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
	};
};
/**
 * This function mirrors the `at` function from the JavaScript Standard String object. It handles
 * Unicode code points instead of UTF-16 character codes.
 *
 * Finds the Unicode code point at the given index.
 *
 * @param string String to index
 * @param index Position of the character to be returned in range of -length(string) to
 *   length(string)
 * @returns New string consisting of the Unicode code point located at the specified offset,
 *   undefined if index is out of bounds
 */
export declare function at(string: string, index: number): string | undefined;
/**
 * This function mirrors the `charAt` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns a new string consisting of the single unicode code point at the given index.
 *
 * @param string String to index
 * @param index Position of the string character to be returned, in the range of 0 to
 *   length(string)-1
 * @returns New string consisting of the Unicode code point located at the specified offset, empty
 *   string if index is out of bounds
 */
export declare function charAt(string: string, index: number): string;
/**
 * This function mirrors the `codePointAt` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns a non-negative integer that is the Unicode code point value of the character starting at
 * the given index.
 *
 * @param string String to index
 * @param index Position of the string character to be returned, in the range of 0 to
 *   length(string)-1
 * @returns Non-negative integer representing the code point value of the character at the given
 *   index, or undefined if there is no element at that position
 */
export declare function codePointAt(string: string, index: number): number | undefined;
/**
 * This function mirrors the `endsWith` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Determines whether a string ends with the characters of this string.
 *
 * @param string String to search through
 * @param searchString Characters to search for at the end of the string
 * @param endPosition End position where searchString is expected to be found. Default is
 *   `length(string)`
 * @returns True if it ends with searchString, false if it does not
 */
export declare function endsWith(string: string, searchString: string, endPosition?: number): boolean;
/**
 * Formats a string, replacing {localization key} with the localization (or multiple localizations
 * if there are multiple in the string). Will also remove \ before curly braces if curly braces are
 * escaped with a backslash in order to preserve the curly braces. E.g. 'Hi, this is {name}! I like
 * `\{curly braces\}`! would become Hi, this is Jim! I like {curly braces}!
 *
 * If the key in unescaped braces is not found, just return the key without the braces. Empty
 * unescaped curly braces will just return a string without the braces e.g. ('I am {Nemo}', {
 * 'name': 'Jim'}) would return 'I am Nemo'.
 *
 * @param str String to format
 * @returns Formatted string
 */
export declare function formatReplacementString(str: string, replacers: {
	[key: string]: string;
}): string;
/**
 * This function mirrors the `includes` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Performs a case-sensitive search to determine if searchString is found in string.
 *
 * @param string String to search through
 * @param searchString String to search for
 * @param position Position within the string to start searching for searchString. Default is `0`
 * @returns True if search string is found, false if it is not
 */
export declare function includes(string: string, searchString: string, position?: number): boolean;
/**
 * This function mirrors the `indexOf` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns the index of the first occurrence of a given string.
 *
 * @param string String to search through
 * @param searchString The string to search for
 * @param position Start of searching. Default is `0`
 * @returns Index of the first occurrence of a given string
 */
export declare function indexOf(string: string, searchString: string, position?: number | undefined): number;
/**
 * This function mirrors the `lastIndexOf` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Searches this string and returns the index of the last occurrence of the specified substring.
 *
 * @param string String to search through
 * @param searchString Substring to search for
 * @param position The index at which to begin searching. If omitted, the search begins at the end
 *   of the string. Default is `undefined`
 * @returns Index of the last occurrence of searchString found, or -1 if not found.
 */
export declare function lastIndexOf(string: string, searchString: string, position?: number): number;
/**
 * This function mirrors the `length` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes. Since `length` appears to be a
 * reserved keyword, the function was renamed to `stringLength`
 *
 * Returns the length of a string.
 *
 * @param string String to return the length for
 * @returns Number that is length of the starting string
 */
export declare function stringLength(string: string): number;
/**
 * This function mirrors the `normalize` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns the Unicode Normalization Form of this string.
 *
 * @param string The starting string
 * @param form Form specifying the Unicode Normalization Form. Default is `'NFC'`
 * @returns A string containing the Unicode Normalization Form of the given string.
 */
export declare function normalize(string: string, form: "NFC" | "NFD" | "NFKC" | "NFKD" | "none"): string;
/**
 * Compares two strings using an ordinal comparison approach based on the specified collation
 * options. This function uses the built-in `localeCompare` method with the 'en' locale and the
 * provided collation options to compare the strings.
 *
 * @param string1 The first string to compare.
 * @param string2 The second string to compare.
 * @param options Optional. The collation options used for comparison.
 * @returns A number indicating the result of the comparison: - Negative value if string1 precedes
 *   string2 in sorting order. - Zero if string1 and string2 are equivalent in sorting order. -
 *   Positive value if string1 follows string2 in sorting order.
 */
export declare function ordinalCompare(string1: string, string2: string, options?: Intl.CollatorOptions): number;
/**
 * This function mirrors the `padEnd` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Pads this string with another string (multiple times, if needed) until the resulting string
 * reaches the given length. The padding is applied from the end of this string.
 *
 * @param string String to add padding too
 * @param targetLength The length of the resulting string once the starting string has been padded.
 *   If value is less than or equal to length(string), then string is returned as is.
 * @param padString The string to pad the current string with. If padString is too long to stay
 *   within targetLength, it will be truncated. Default is `" "`
 * @returns String with appropriate padding at the end
 */
export declare function padEnd(string: string, targetLength: number, padString?: string): string;
/**
 * This function mirrors the `padStart` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Pads this string with another string (multiple times, if needed) until the resulting string
 * reaches the given length. The padding is applied from the start of this string.
 *
 * @param string String to add padding too
 * @param targetLength The length of the resulting string once the starting string has been padded.
 *   If value is less than or equal to length(string), then string is returned as is.
 * @param padString The string to pad the current string with. If padString is too long to stay
 *   within the targetLength, it will be truncated from the end. Default is `" "`
 * @returns String with of specified targetLength with padString applied from the start
 */
export declare function padStart(string: string, targetLength: number, padString?: string): string;
/**
 * This function mirrors the `slice` function from the JavaScript Standard String object. It handles
 * Unicode code points instead of UTF-16 character codes.
 *
 * Extracts a section of this string and returns it as a new string, without modifying the original
 * string.
 *
 * @param string The starting string
 * @param indexStart The index of the first character to include in the returned substring.
 * @param indexEnd The index of the first character to exclude from the returned substring.
 * @returns A new string containing the extracted section of the string.
 */
export declare function slice(string: string, indexStart: number, indexEnd?: number): string;
/**
 * This function mirrors the `split` function from the JavaScript Standard String object. It handles
 * Unicode code points instead of UTF-16 character codes.
 *
 * Takes a pattern and divides the string into an ordered list of substrings by searching for the
 * pattern, puts these substrings into an array, and returns the array.
 *
 * @param string The string to split
 * @param separator The pattern describing where each split should occur
 * @param splitLimit Limit on the number of substrings to be included in the array. Splits the
 *   string at each occurrence of specified separator, but stops when limit entries have been placed
 *   in the array.
 * @returns An array of strings, split at each point where separator occurs in the starting string.
 *   Returns undefined if separator is not found in string.
 */
export declare function split(string: string, separator: string | RegExp, splitLimit?: number): string[];
/**
 * This function mirrors the `startsWith` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Determines whether the string begins with the characters of a specified string, returning true or
 * false as appropriate.
 *
 * @param string String to search through
 * @param searchString The characters to be searched for at the start of this string.
 * @param position The start position at which searchString is expected to be found (the index of
 *   searchString's first character). Default is `0`
 * @returns True if the given characters are found at the beginning of the string, including when
 *   searchString is an empty string; otherwise, false.
 */
export declare function startsWith(string: string, searchString: string, position?: number): boolean;
/**
 * This function mirrors the `substring` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Returns a substring by providing start and end position.
 *
 * @param string String to be divided
 * @param begin Start position
 * @param end End position. Default is `End of string`
 * @returns Substring from starting string
 */
export declare function substring(string: string, begin: number, end?: number): string;
/**
 * This function mirrors the `toArray` function from the JavaScript Standard String object. It
 * handles Unicode code points instead of UTF-16 character codes.
 *
 * Converts a string to an array of string characters.
 *
 * @param string String to convert to array
 * @returns An array of characters from the starting string
 */
export declare function toArray(string: string): string[];
/** Determine whether the string is a `LocalizeKey` meant to be localized in Platform.Bible. */
export declare function isLocalizeKey(str: string): str is LocalizeKey;
/**
 * Escape RegExp special characters.
 *
 * You can also use this to escape a string that is inserted into the middle of a regex, for
 * example, into a character class.
 *
 * All credit to [`escape-string-regexp`](https://www.npmjs.com/package/escape-string-regexp) - this
 * function is simply copied directly from there to allow a common js export
 *
 * @example
 *
 *     import escapeStringRegexp from 'platform-bible-utils';
 *
 *     const escapedString = escapeStringRegexp('How much $ for a ?');
 *     //=> 'How much \\$ for a \\?'
 *
 *     new RegExp(escapedString);
 */
export declare function escapeStringRegexp(string: string): string;
/**
 * Check that two objects are deeply equal, comparing members of each object and such
 *
 * @param a The first object to compare
 * @param b The second object to compare
 *
 *   WARNING: Objects like arrays from different iframes have different constructor function
 *   references even if they do the same thing, so this deep equality comparison fails objects that
 *   look the same but have different constructors because different constructors could produce
 *   false positives in [a few specific
 *   situations](https://github.com/planttheidea/fast-equals/blob/a41afc0a240ad5a472e47b53791e9be017f52281/src/comparator.ts#L96).
 *   This means that two objects like arrays from different iframes that look the same will fail
 *   this check. Please use some other means to check deep equality in those situations.
 *
 *   Note: This deep equality check considers `undefined` values on keys of objects NOT to be equal to
 *   not specifying the key at all. For example, `{ stuff: 3, things: undefined }` and `{ stuff: 3
 *   }` are not considered equal in this case
 *
 *   - For more information and examples, see [this
 *       CodeSandbox](https://codesandbox.io/s/deepequallibrarycomparison-4g4kk4?file=/src/index.mjs).
 *
 * @returns True if a and b are deeply equal; false otherwise
 */
export function deepEqual(a: unknown, b: unknown): boolean;
/**
 * Check if one object is a subset of the other object. "Subset" means that all properties of one
 * object are present in the other object, and if they are present that all values of those
 * properties are deeply equal. Sub-objects are also checked to be subsets of the corresponding
 * sub-object in the other object.
 *
 * @example ObjB is a subset of objA given these objects:
 *
 * ```ts
 * objA = { name: 'Alice', age: 30, address: { city: 'Seattle', state: 'Washington' } };
 * objB = { name: 'Alice', address: { city: 'Seattle' } };
 * ```
 *
 * It is important to note that only arrays of primitives (i.e., booleans, numbers, strings) are
 * supported. In particular, objects in arrays will not be checked for deep equality. Also, presence
 * in an array is all this checks, not the number of times that an item appears in an array. `[1,
 * 1]` is a subset of `[1]`.
 *
 * @param objectWithAllProperties Object to be checked if it is a superset of
 *   `objectWithPartialProperties`
 * @param objectWithPartialProperties Object to be checked if it is a subset of
 *   `objectWithAllProperties`
 * @returns True if `objectWithAllProperties` contains all the properties of
 *   `objectWithPartialProperties` and all values of those properties are deeply equal
 */
export function isSubset(objectWithAllProperties: unknown, objectWithPartialProperties: unknown): boolean;
/**
 * Converts a JavaScript value to a JSON string, changing `undefined` properties in the JavaScript
 * object to `null` properties in the JSON string.
 *
 * WARNING: `null` values will become `undefined` values after passing through {@link serialize} then
 * {@link deserialize}. For example, `{ a: 1, b: undefined, c: null }` will become `{ a: 1, b:
 * undefined, c: undefined }`. If you are passing around user data that needs to retain `null`
 * values, you should wrap them yourself in a string before using this function. Alternatively, you
 * can write your own replacer that will preserve `null` in a way that you can recover later.
 *
 * @param value A JavaScript value, usually an object or array, to be converted.
 * @param replacer A function that transforms the results. Note that all `undefined` values returned
 *   by the replacer will be further transformed into `null` in the JSON string.
 * @param space Adds indentation, white space, and line break characters to the return-value JSON
 *   text to make it easier to read. See the `space` parameter of `JSON.stringify` for more
 *   details.
 */
export declare function serialize(value: unknown, replacer?: (this: unknown, key: string, value: unknown) => unknown, space?: string | number): string;
/**
 * Converts a JSON string into a value, converting all `null` properties from JSON into `undefined`
 * in the returned JavaScript value/object.
 *
 * WARNING: `null` values will become `undefined` values after passing through {@link serialize} then
 * {@link deserialize}. For example, `{ a: 1, b: undefined, c: null }` will become `{ a: 1, b:
 * undefined, c: undefined }`. If you are passing around user data that needs to retain `null`
 * values, you should wrap them yourself in a string before using this function. Alternatively, you
 * can write your own replacer that will preserve `null` in a way that you can recover later.
 *
 * @param value A valid JSON string.
 * @param reviver A function that transforms the results. This function is called for each member of
 *   the object. If a member contains nested objects, the nested objects are transformed before the
 *   parent object is. Note that `null` values are converted into `undefined` values after the
 *   reviver has run.
 */
export declare function deserialize(value: string, reviver?: (this: unknown, key: string, value: unknown) => unknown): any;
/**
 * Check to see if the value is serializable without losing information
 *
 * @param value Value to test
 * @returns True if serializable; false otherwise
 *
 *   Note: the values `undefined` and `null` are serializable (on their own or in an array), but
 *   `null` values get transformed into `undefined` when serializing/deserializing.
 *
 *   WARNING: This is inefficient right now as it stringifies, parses, stringifies, and === the value.
 *   Please only use this if you need to
 *
 *   DISCLAIMER: this does not successfully detect that values are not serializable in some cases:
 *
 *   - Losses of removed properties like functions and `Map`s
 *   - Class instances (not deserializable into class instances without special code)
 *
 *   We intend to improve this in the future if it becomes important to do so. See [`JSON.stringify`
 *   documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description)
 *   for more information.
 */
export declare function isSerializable(value: unknown): boolean;
/**
 * HTML Encodes the provided string. Thanks to ChatGPT
 *
 * @param str String to HTML encode
 * @returns HTML-encoded string
 */
export declare const htmlEncode: (str: string) => string;
/**
 * Retrieves the current locale of the user's environment.
 *
 * @returns A string representing the current locale. If the locale cannot be determined, the
 *   function returns an empty string.
 */
export function getCurrentLocale(): string;
export type ScriptureItemDetail = ScriptureSelection & {
	detail: string | ReactElement;
};
/** Localized string value associated with this key */
export type LocalizedStringValue = string;
/** The data an extension provides to inform Platform.Bible of the localized strings it provides. */
export interface LocalizedStringDataContribution {
	[k: string]: unknown;
	metadata?: StringsMetadata;
	localizedStrings?: {
		[k: string]: LanguageStrings;
	};
}
/**
 * Map whose keys are localized string keys and whose values provide additional non-locale-specific
 * information about the localized string key
 */
export interface StringsMetadata {
	[k: LocalizeKey]: StringMetadata;
}
/** Additional non-locale-specific information about a localized string key */
export interface StringMetadata {
	[k: string]: unknown;
	/**
	 * Localized string key from which to get this value if one does not exist in the specified
	 * language. If a new key/value pair needs to be made to replace an existing one, this could help
	 * smooth over the transition if the meanings are close enough
	 */
	fallbackKey?: LocalizeKey;
	/**
	 * Additional information provided by developers in English to help the translator to know how to
	 * translate this localized string accurately
	 */
	notes?: string;
}
/**
 * Map whose keys are localized string keys and whose values provide information about how to
 * localize strings for the localized string key
 */
export interface LanguageStrings {
	[k: LocalizeKey]: LocalizedStringValue;
}
/** JSON schema object that aligns with the LocalizedStringDataContribution type */
export declare const localizedStringsDocumentSchema: {
	$schema: string;
	title: string;
	description: string;
	type: string;
	properties: {
		metadata: {
			$ref: string;
		};
		localizedStrings: {
			type: string;
			additionalProperties: {
				$ref: string;
			};
		};
	};
	$defs: {
		languageStrings: {
			description: string;
			type: string;
			patternProperties: {
				"^%[\\w\\-\\.]+%$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		localizedStringValue: {
			description: string;
			type: string;
		};
		stringsMetadata: {
			description: string;
			type: string;
			patternProperties: {
				"^%[\\w\\-\\.]+%$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		stringMetadata: {
			description: string;
			type: string;
			properties: {
				fallbackKey: {
					description: string;
					$ref: string;
				};
				notes: {
					description: string;
					type: string;
				};
			};
		};
		localizeKey: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
	};
};
/** The data an extension provides to inform Platform.Bible of the settings it provides */
export type SettingsContribution = SettingsGroup | SettingsGroup[];
/** A description of an extension's setting entry */
export type Setting = ExtensionControlledSetting;
/** Setting definition that is validated by the extension. */
export type ExtensionControlledSetting = SettingBase & ModifierExtensionControlled;
/** Base information needed to describe a setting entry */
export type SettingBase = StateBase & {
	[k: string]: unknown;
	/** LocalizeKey that displays in the settings dialog as the setting name */
	label: LocalizeKey;
	/** LocalizeKey that displays in the settings dialog to describe the setting */
	description?: LocalizeKey;
};
/** The data an extension provides to inform Platform.Bible of the project settings it provides */
export type ProjectSettingsContribution = ProjectSettingsGroup | ProjectSettingsGroup[];
/** A description of an extension's setting entry */
export type ProjectSetting = ExtensionControlledProjectSetting;
/** Setting definition that is validated by the extension. */
export type ExtensionControlledProjectSetting = ProjectSettingBase & ModifierExtensionControlled;
/** Base information needed to describe a project setting entry */
export type ProjectSettingBase = SettingBase & ModifierProject;
/** A description of an extension's user state entry */
export type UserState = ExtensionControlledState;
/** State definition that is validated by the extension. */
export type ExtensionControlledState = StateBase & ModifierExtensionControlled;
/** Group of related settings definitions */
export interface SettingsGroup {
	[k: string]: unknown;
	/** LocalizeKey that displays in the settings dialog as the group name */
	label: LocalizeKey;
	/** LocalizeKey that displays in the settings dialog to describe the group */
	description?: LocalizeKey;
	properties: SettingProperties;
}
/** Object whose keys are setting IDs and whose values are settings objects */
export interface SettingProperties {
	[k: ReferencedItem]: Setting;
}
/** Base information needed to describe a state entry */
export interface StateBase {
	[k: string]: unknown;
	/** Default value for the state/setting */
	default: unknown;
	/**
	 * A state/setting ID whose value to set to this state/setting's starting value the first time
	 * this state/setting is loaded
	 */
	derivesFrom?: ReferencedItem;
}
/**
 * Modifies state/setting type to be extension-controlled. "Extension-controlled" means the
 * extension provides the component and the validator for the state/setting, so the state/setting is
 * controlled by the extension.
 */
export interface ModifierExtensionControlled {
	[k: string]: unknown;
	platformType?: undefined;
	type?: undefined;
}
/** Group of related settings definitions */
export interface ProjectSettingsGroup {
	[k: string]: unknown;
	/** LocalizeKey that displays in the project settings dialog as the group name */
	label: LocalizeKey;
	/** LocalizeKey that displays in the project settings dialog to describe the group */
	description?: LocalizeKey;
	properties: ProjectSettingProperties;
}
/** Object whose keys are setting IDs and whose values are settings objects */
export interface ProjectSettingProperties {
	[k: ReferencedItem]: ProjectSetting;
}
export interface ModifierProject {
	/**
	 * String representation of `RegExp` pattern(s) to match against projects' `projectInterface`s
	 * (using the
	 * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) to determine if they should be included.
	 *
	 * If this is one string, it will be matched against `projectInterface`s. If this is an array,
	 * each entry is handled based on its type (at least one entry must match for this filter
	 * condition to pass):
	 *
	 * - If the entry is a string, it will be matched against each `projectInterface`. If any match, the
	 *   project will pass this filter condition
	 * - If the entry is an array of strings, each will be matched against each `projectInterface`. If
	 *   every string matches against at least one `projectInterface`, the project will pass this
	 *   filter condition
	 *
	 * In other words, each entry in the first-level array is `OR`'ed together. Each entry in
	 * second-level arrays (arrays within the first-level array) are `AND`'ed together.
	 *
	 * Defaults to all {@link ProjectInterfaces}, so all projects that do not match
	 * `excludeProjectInterfaces` will be included
	 *
	 * @example
	 *
	 * ```typescript
	 * includeProjectInterfaces: ['one', ['two', 'three']];
	 * ```
	 *
	 * This filter condition will succeed on projects whose `projectInterface`s fulfill at least one
	 * of the following conditions (At least one entry in the array must match):
	 *
	 * - Include `one`
	 * - Include both `two` and `three`.
	 */
	includeProjectInterfaces?: undefined | string | (string | string[])[];
	/**
	 * String representation of `RegExp` pattern(s) to match against projects' `projectInterface`s
	 * (using the
	 * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) to determine if they should absolutely not be included even if they match with
	 * `includeProjectInterfaces`.
	 *
	 * If this is one string, it will be matched against `projectInterface`s. If this is an array,
	 * each entry is handled based on its type (at least one entry must match for this filter
	 * condition to exclude the project):
	 *
	 * - If the entry is a string, it will be matched against each `projectInterface`. If any match, the
	 *   project will pass this filter condition and exclude the project
	 * - If the entry is an array of strings, each will be matched against each `projectInterface`. If
	 *   every string matches against at least one `projectInterface`, the project will pass this
	 *   filter condition and exclude the project
	 *
	 * In other words, each entry in the first-level array is `OR`'ed together. Each entry in
	 * second-level arrays (arrays within the first-level array) are `AND`'ed together.
	 *
	 * Defaults to no {@link ProjectInterfaces}, so all projects that match `includeProjectInterfaces`
	 * will be included
	 *
	 * @example
	 *
	 * ```typescript
	 * excludeProjectInterfaces: ['one', ['two', 'three']];
	 * ```
	 *
	 * This filter condition will succeed and exclude projects whose `projectInterface`s fulfill at
	 * least one of the following conditions (At least one entry in the array must match):
	 *
	 * - Include `one`
	 * - Include both `two` and `three`.
	 */
	excludeProjectInterfaces?: undefined | string | (string | string[])[];
	/**
	 * String representation of `RegExp` pattern(s) to match against the Project Data Provider Factory
	 * Ids that provided each project's metadata (using the
	 * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) to determine if the projects should be included.
	 *
	 * Defaults to all Project Data Provider Factory Ids, so all projects that do not match
	 * `excludePdpFactoryIds` will be included
	 */
	includePdpFactoryIds?: undefined | string | string[];
	/**
	 * String representation of `RegExp` pattern(s) to match against the Project Data Provider Factory
	 * Ids that provided each project's metadata (using the
	 * [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)
	 * function) to determine if the projects should absolutely not be included even if they match
	 * with `includeProjectInterfaces`.
	 *
	 * Defaults to none, so all projects that match `includePdpFactoryIds` will be included
	 */
	excludePdpFactoryIds?: undefined | string | string[];
}
/** The data an extension provides to inform Platform.Bible of the user state it provides */
export interface UserStateContribution {
	[k: ReferencedItem]: UserState;
}
/** The data an extension provides to inform Platform.Bible of the project state it provides */
export interface ProjectStateContribution {
	[k: ReferencedItem]: UserState;
}
/** JSON schema object that aligns with the ProjectSettingsContribution type */
export declare const projectSettingsDocumentSchema: {
	$schema: string;
	title: string;
	description: string;
	anyOf: ({
		$ref: string;
		type?: undefined;
		items?: undefined;
	} | {
		type: string;
		items: {
			$ref: string;
		};
		$ref?: undefined;
	})[];
	$defs: {
		projectSettingsContribution: {
			description: string;
			anyOf: ({
				$ref: string;
				type?: undefined;
				items?: undefined;
			} | {
				type: string;
				items: {
					$ref: string;
				};
				$ref?: undefined;
			})[];
		};
		projectSettingsGroup: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				description: {
					description: string;
					$ref: string;
				};
				properties: {
					$ref: string;
				};
			};
			required: string[];
		};
		projectSettingProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		projectSetting: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledProjectSetting: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		projectSettingBase: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		modifierProject: {
			description: string;
			type: string;
			properties: {
				includeProjectInterfaces: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							anyOf: ({
								type: string;
								items?: undefined;
							} | {
								type: string;
								items: {
									type: string;
								};
							})[];
						};
					})[];
				};
				excludeProjectInterfaces: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							anyOf: ({
								type: string;
								items?: undefined;
							} | {
								type: string;
								items: {
									type: string;
								};
							})[];
						};
					})[];
				};
				includePdpFactoryIds: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							type: string;
						};
					})[];
				};
				excludePdpFactoryIds: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							type: string;
						};
					})[];
				};
			};
		};
		settingsContribution: {
			description: string;
			anyOf: ({
				$ref: string;
				type?: undefined;
				items?: undefined;
			} | {
				type: string;
				items: {
					$ref: string;
				};
				$ref?: undefined;
			})[];
		};
		settingsGroup: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				description: {
					description: string;
					$ref: string;
				};
				properties: {
					$ref: string;
				};
			};
			required: string[];
		};
		settingProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w-]+\\.[\\w-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		setting: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledSetting: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		settingBase: {
			description: string;
			allOf: ({
				$ref: string;
				type?: undefined;
				properties?: undefined;
				required?: undefined;
			} | {
				type: string;
				properties: {
					label: {
						description: string;
						$ref: string;
					};
					description: {
						description: string;
						$ref: string;
					};
				};
				required: string[];
				$ref?: undefined;
			})[];
		};
		projectStateContribution: {
			description: string;
			$ref: string;
		};
		userStateContribution: {
			description: string;
			$ref: string;
		};
		userStateProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		userState: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledState: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		modifierExtensionControlled: {
			description: string;
			not: {
				anyOf: {
					type: string;
					required: string[];
				}[];
			};
		};
		stateBase: {
			description: string;
			type: string;
			properties: {
				default: {
					description: string;
					type: string;
				};
				derivesFrom: {
					description: string;
					$ref: string;
				};
			};
			required: string[];
		};
		localizeKey: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
		id: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
	};
};
/** JSON schema object that aligns with the {@link SettingsContribution} type */
export declare const settingsDocumentSchema: {
	$schema: string;
	title: string;
	description: string;
	anyOf: ({
		$ref: string;
		type?: undefined;
		items?: undefined;
	} | {
		type: string;
		items: {
			$ref: string;
		};
		$ref?: undefined;
	})[];
	$defs: {
		projectSettingsContribution: {
			description: string;
			anyOf: ({
				$ref: string;
				type?: undefined;
				items?: undefined;
			} | {
				type: string;
				items: {
					$ref: string;
				};
				$ref?: undefined;
			})[];
		};
		projectSettingsGroup: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				description: {
					description: string;
					$ref: string;
				};
				properties: {
					$ref: string;
				};
			};
			required: string[];
		};
		projectSettingProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		projectSetting: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledProjectSetting: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		projectSettingBase: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		modifierProject: {
			description: string;
			type: string;
			properties: {
				includeProjectInterfaces: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							anyOf: ({
								type: string;
								items?: undefined;
							} | {
								type: string;
								items: {
									type: string;
								};
							})[];
						};
					})[];
				};
				excludeProjectInterfaces: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							anyOf: ({
								type: string;
								items?: undefined;
							} | {
								type: string;
								items: {
									type: string;
								};
							})[];
						};
					})[];
				};
				includePdpFactoryIds: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							type: string;
						};
					})[];
				};
				excludePdpFactoryIds: {
					description: string;
					anyOf: ({
						type: string;
						items?: undefined;
					} | {
						type: string;
						items: {
							type: string;
						};
					})[];
				};
			};
		};
		settingsContribution: {
			description: string;
			anyOf: ({
				$ref: string;
				type?: undefined;
				items?: undefined;
			} | {
				type: string;
				items: {
					$ref: string;
				};
				$ref?: undefined;
			})[];
		};
		settingsGroup: {
			description: string;
			type: string;
			properties: {
				label: {
					description: string;
					$ref: string;
				};
				description: {
					description: string;
					$ref: string;
				};
				properties: {
					$ref: string;
				};
			};
			required: string[];
		};
		settingProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w-]+\\.[\\w-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		setting: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledSetting: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		settingBase: {
			description: string;
			allOf: ({
				$ref: string;
				type?: undefined;
				properties?: undefined;
				required?: undefined;
			} | {
				type: string;
				properties: {
					label: {
						description: string;
						$ref: string;
					};
					description: {
						description: string;
						$ref: string;
					};
				};
				required: string[];
				$ref?: undefined;
			})[];
		};
		projectStateContribution: {
			description: string;
			$ref: string;
		};
		userStateContribution: {
			description: string;
			$ref: string;
		};
		userStateProperties: {
			description: string;
			type: string;
			patternProperties: {
				"^[\\w\\-]+\\.[\\w\\-]+$": {
					$ref: string;
				};
			};
			additionalProperties: boolean;
		};
		userState: {
			description: string;
			anyOf: {
				$ref: string;
			}[];
		};
		extensionControlledState: {
			description: string;
			allOf: {
				$ref: string;
			}[];
		};
		modifierExtensionControlled: {
			description: string;
			not: {
				anyOf: {
					type: string;
					required: string[];
				}[];
			};
		};
		stateBase: {
			description: string;
			type: string;
			properties: {
				default: {
					description: string;
					type: string;
				};
				derivesFrom: {
					description: string;
					$ref: string;
				};
			};
			required: string[];
		};
		localizeKey: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
		id: {
			description: string;
			type: string;
			pattern: string;
			tsType: string;
		};
	};
};

export {};
