(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(global, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ansi-styles/index.js":
/*!*******************************************!*\
  !*** ./node_modules/ansi-styles/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = __webpack_require__(/*! color-convert */ "./node_modules/color-convert/index.js");
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});


/***/ }),

/***/ "./node_modules/chalk/source/index.js":
/*!********************************************!*\
  !*** ./node_modules/chalk/source/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ansiStyles = __webpack_require__(/*! ansi-styles */ "./node_modules/ansi-styles/index.js");
const {stdout: stdoutColor, stderr: stderrColor} = __webpack_require__(/*! supports-color */ "./node_modules/supports-color/index.js");
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = __webpack_require__(/*! ./util */ "./node_modules/chalk/source/util.js");

const {isArray} = Array;

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => {
		if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
			// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
			return applyStyle(builder, chalkTag(builder, ...arguments_));
		}

		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!isArray(firstString) || !isArray(firstString.raw)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = __webpack_require__(/*! ./templates */ "./node_modules/chalk/source/templates.js");
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

module.exports = chalk;


/***/ }),

/***/ "./node_modules/chalk/source/templates.js":
/*!************************************************!*\
  !*** ./node_modules/chalk/source/templates.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";

const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}

		if (!(styleName in current)) {
			throw new Error(`Unknown Chalk style: ${styleName}`);
		}

		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}

	return current;
}

module.exports = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMessage);
	}

	return chunks.join('');
};


/***/ }),

/***/ "./node_modules/chalk/source/util.js":
/*!*******************************************!*\
  !*** ./node_modules/chalk/source/util.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


const stringReplaceAll = (string, substring, replacer) => {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

module.exports = {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
};


/***/ }),

/***/ "./node_modules/color-convert/conversions.js":
/*!***************************************************!*\
  !*** ./node_modules/color-convert/conversions.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* MIT license */
/* eslint-disable no-mixed-operators */
const cssKeywords = __webpack_require__(/*! color-name */ "./node_modules/color-name/index.js");

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

module.exports = convert;

// Hide .channels and .labels properties
for (const model of Object.keys(convert)) {
	if (!('channels' in convert[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert[model].labels.length !== convert[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert[model];
	delete convert[model].channels;
	delete convert[model].labels;
	Object.defineProperty(convert[model], 'channels', {value: channels});
	Object.defineProperty(convert[model], 'labels', {value: labels});
}

convert.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	const xyz = convert.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hsv = convert.gray.hsl;

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ "./node_modules/color-convert/index.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(/*! ./conversions */ "./node_modules/color-convert/conversions.js");
const route = __webpack_require__(/*! ./route */ "./node_modules/color-convert/route.js");

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ "./node_modules/color-convert/route.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/route.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(/*! ./conversions */ "./node_modules/color-convert/conversions.js");

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ "./node_modules/color-name/index.js":
/*!******************************************!*\
  !*** ./node_modules/color-name/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ "./node_modules/electron-log/src/core/Logger.js":
/*!******************************************************!*\
  !*** ./node_modules/electron-log/src/core/Logger.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const scopeFactory = __webpack_require__(/*! ./scope */ "./node_modules/electron-log/src/core/scope.js");

/**
 * @property {Function} error
 * @property {Function} warn
 * @property {Function} info
 * @property {Function} verbose
 * @property {Function} debug
 * @property {Function} silly
 */
class Logger {
  static instances = {};

  errorHandler = null;
  eventLogger = null;
  functions = {};
  hooks = [];
  isDev = false;
  levels = null;
  logId = null;
  scope = null;
  transports = {};
  variables = {};

  constructor({
    allowUnknownLevel = false,
    errorHandler,
    eventLogger,
    initializeFn,
    isDev = false,
    levels = ['error', 'warn', 'info', 'verbose', 'debug', 'silly'],
    logId,
    transportFactories = {},
    variables,
  } = {}) {
    this.addLevel = this.addLevel.bind(this);
    this.create = this.create.bind(this);
    this.logData = this.logData.bind(this);
    this.processMessage = this.processMessage.bind(this);

    this.allowUnknownLevel = allowUnknownLevel;
    this.initializeFn = initializeFn;
    this.isDev = isDev;
    this.levels = levels;
    this.logId = logId;
    this.transportFactories = transportFactories;
    this.variables = variables || {};
    this.scope = scopeFactory(this);

    this.addLevel('log', false);
    for (const name of this.levels) {
      this.addLevel(name, false);
    }

    this.errorHandler = errorHandler;
    errorHandler?.setOptions({ logFn: this.error });

    this.eventLogger = eventLogger;
    eventLogger?.setOptions({ logger: this });

    for (const [name, factory] of Object.entries(transportFactories)) {
      this.transports[name] = factory(this);
    }

    Logger.instances[logId] = this;
  }

  static getInstance({ logId }) {
    return this.instances[logId] || this.instances.default;
  }

  addLevel(level, index = this.levels.length) {
    if (index !== false) {
      this.levels.splice(index, 0, level);
    }

    this[level] = (...args) => this.logData(args, { level });
    this.functions[level] = this[level];
  }

  catchErrors(options) {
    this.processMessage(
      {
        data: ['log.catchErrors is deprecated. Use log.errorHandler instead'],
        level: 'warn',
      },
      { transports: ['console'] },
    );
    return this.errorHandler.startCatching(options);
  }

  create(options) {
    if (typeof options === 'string') {
      options = { logId: options };
    }

    return new Logger({
      ...options,
      errorHandler: this.errorHandler,
      initializeFn: this.initializeFn,
      isDev: this.isDev,
      transportFactories: this.transportFactories,
      variables: { ...this.variables },
    });
  }

  compareLevels(passLevel, checkLevel, levels = this.levels) {
    const pass = levels.indexOf(passLevel);
    const check = levels.indexOf(checkLevel);
    if (check === -1 || pass === -1) {
      return true;
    }

    return check <= pass;
  }

  initialize(options = {}) {
    this.initializeFn({ logger: this, ...options });
  }

  logData(data, options = {}) {
    this.processMessage({ data, ...options });
  }

  processMessage(message, { transports = this.transports } = {}) {
    if (message.cmd === 'errorHandler') {
      this.errorHandler.handle(message.error, {
        errorName: message.errorName,
        processType: 'renderer',
        showDialog: Boolean(message.showDialog),
      });
      return;
    }

    let level = message.level;
    if (!this.allowUnknownLevel) {
      level = this.levels.includes(message.level) ? message.level : 'info';
    }

    const normalizedMessage = {
      date: new Date(),
      ...message,
      level,
      variables: {
        ...this.variables,
        ...message.variables,
      },
    };

    for (const [transName, transFn] of this.transportEntries(transports)) {
      if (typeof transFn !== 'function' || transFn.level === false) {
        continue;
      }

      if (!this.compareLevels(transFn.level, message.level)) {
        continue;
      }

      try {
        // eslint-disable-next-line arrow-body-style
        const transformedMsg = this.hooks.reduce((msg, hook) => {
          return msg ? hook(msg, transFn, transName) : msg;
        }, normalizedMessage);

        if (transformedMsg) {
          transFn({ ...transformedMsg, data: [...transformedMsg.data] });
        }
      } catch (e) {
        this.processInternalErrorFn(e);
      }
    }
  }

  processInternalErrorFn(_e) {
    // Do nothing by default
  }

  transportEntries(transports = this.transports) {
    const transportArray = Array.isArray(transports)
      ? transports
      : Object.entries(transports);

    return transportArray
      .map((item) => {
        switch (typeof item) {
          case 'string':
            return this.transports[item] ? [item, this.transports[item]] : null;
          case 'function':
            return [item.name, item];
          default:
            return Array.isArray(item) ? item : null;
        }
      })
      .filter(Boolean);
  }
}

module.exports = Logger;


/***/ }),

/***/ "./node_modules/electron-log/src/core/scope.js":
/*!*****************************************************!*\
  !*** ./node_modules/electron-log/src/core/scope.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


module.exports = scopeFactory;

function scopeFactory(logger) {
  return Object.defineProperties(scope, {
    defaultLabel: { value: '', writable: true },
    labelPadding: { value: true, writable: true },
    maxLabelLength: { value: 0, writable: true },
    labelLength: {
      get() {
        switch (typeof scope.labelPadding) {
          case 'boolean': return scope.labelPadding ? scope.maxLabelLength : 0;
          case 'number': return scope.labelPadding;
          default: return 0;
        }
      },
    },
  });

  function scope(label) {
    scope.maxLabelLength = Math.max(scope.maxLabelLength, label.length);

    const newScope = {};
    for (const level of [...logger.levels, 'log']) {
      newScope[level] = (...d) => logger.logData(d, { level, scope: label });
    }
    return newScope;
  }
}


/***/ }),

/***/ "./node_modules/electron-log/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/electron-log/src/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint-disable global-require */

const isRenderer = typeof process === 'undefined'
  || ( false || "browser" === 'worker');

if (isRenderer) {
  // Makes sense when contextIsolation/sandbox disabled
  __webpack_require__(/*! ./renderer/electron-log-preload */ "./node_modules/electron-log/src/renderer/electron-log-preload.js");
  module.exports = __webpack_require__(/*! ./renderer */ "./node_modules/electron-log/src/renderer/index.js");
} else {
  module.exports = __webpack_require__(/*! ./main */ "./node_modules/electron-log/src/main/index.js");
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/ErrorHandler.js":
/*!************************************************************!*\
  !*** ./node_modules/electron-log/src/main/ErrorHandler.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const electronApi = __webpack_require__(/*! ./electronApi */ "./node_modules/electron-log/src/main/electronApi.js");

class ErrorHandler {
  isActive = false;
  logFn = null;
  onError = null;
  showDialog = true;

  constructor({ logFn = null, onError = null, showDialog = true } = {}) {
    this.createIssue = this.createIssue.bind(this);
    this.handleError = this.handleError.bind(this);
    this.handleRejection = this.handleRejection.bind(this);
    this.setOptions({ logFn, onError, showDialog });
    this.startCatching = this.startCatching.bind(this);
    this.stopCatching = this.stopCatching.bind(this);
  }

  handle(error, {
    logFn = this.logFn,
    onError = this.onError,
    processType = 'browser',
    showDialog = this.showDialog,
    errorName = '',
  } = {}) {
    error = normalizeError(error);

    try {
      if (typeof onError === 'function') {
        const versions = electronApi.getVersions();
        const createIssue = this.createIssue;
        const result = onError({
          createIssue,
          error,
          errorName,
          processType,
          versions,
        });
        if (result === false) {
          return;
        }
      }

      errorName ? logFn(errorName, error) : logFn(error);

      if (showDialog && !errorName.includes('rejection')) {
        electronApi.showErrorBox(
          `A JavaScript error occurred in the ${processType} process`,
          error.stack,
        );
      }
    } catch {
      console.error(error); // eslint-disable-line no-console
    }
  }

  setOptions({ logFn, onError, showDialog }) {
    if (typeof logFn === 'function') {
      this.logFn = logFn;
    }

    if (typeof onError === 'function') {
      this.onError = onError;
    }

    if (typeof showDialog === 'boolean') {
      this.showDialog = showDialog;
    }
  }

  startCatching({ onError, showDialog } = {}) {
    if (this.isActive) {
      return;
    }

    this.isActive = true;
    this.setOptions({ onError, showDialog });
    process.on('uncaughtException', this.handleError);
    process.on('unhandledRejection', this.handleRejection);
  }

  stopCatching() {
    this.isActive = false;
    process.removeListener('uncaughtException', this.handleError);
    process.removeListener('unhandledRejection', this.handleRejection);
  }

  createIssue(pageUrl, queryParams) {
    electronApi.openUrl(
      `${pageUrl}?${new URLSearchParams(queryParams).toString()}`,
    );
  }

  handleError(error) {
    this.handle(error, { errorName: 'Unhandled' });
  }

  handleRejection(reason) {
    const error = reason instanceof Error
      ? reason
      : new Error(JSON.stringify(reason));
    this.handle(error, { errorName: 'Unhandled rejection' });
  }
}

function normalizeError(e) {
  if (e instanceof Error) {
    return e;
  }

  if (e && typeof e === 'object') {
    if (e.message) {
      return Object.assign(new Error(e.message), e);
    }
    try {
      return new Error(JSON.stringify(e));
    } catch (serErr) {
      return new Error(`Couldn't normalize error ${String(e)}: ${serErr}`);
    }
  }

  return new Error(`Can't normalize error ${String(e)}`);
}

module.exports = ErrorHandler;


/***/ }),

/***/ "./node_modules/electron-log/src/main/EventLogger.js":
/*!***********************************************************!*\
  !*** ./node_modules/electron-log/src/main/EventLogger.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const electronApi = __webpack_require__(/*! ./electronApi */ "./node_modules/electron-log/src/main/electronApi.js");

class EventLogger {
  disposers = [];
  format = '{eventSource}#{eventName}:';
  formatters = {
    app: {
      'certificate-error': ({ args }) => {
        return this.arrayToObject(args.slice(1, 4), [
          'url',
          'error',
          'certificate',
        ]);
      },
      'child-process-gone': ({ args }) => {
        return args.length === 1 ? args[0] : args;
      },
      'render-process-gone': ({ args: [webContents, details] }) => {
        return details && typeof details === 'object'
          ? { ...details, ...this.getWebContentsDetails(webContents) }
          : [];
      },
    },

    webContents: {
      'console-message': ({ args: [level, message, line, sourceId] }) => {
        // 0: debug, 1: info, 2: warning, 3: error
        if (level < 3) {
          return undefined;
        }

        return { message, source: `${sourceId}:${line}` };
      },
      'did-fail-load': ({ args }) => {
        return this.arrayToObject(args, [
          'errorCode',
          'errorDescription',
          'validatedURL',
          'isMainFrame',
          'frameProcessId',
          'frameRoutingId',
        ]);
      },
      'did-fail-provisional-load': ({ args }) => {
        return this.arrayToObject(args, [
          'errorCode',
          'errorDescription',
          'validatedURL',
          'isMainFrame',
          'frameProcessId',
          'frameRoutingId',
        ]);
      },
      'plugin-crashed': ({ args }) => {
        return this.arrayToObject(args, ['name', 'version']);
      },
      'preload-error': ({ args }) => {
        return this.arrayToObject(args, ['preloadPath', 'error']);
      },
    },
  };

  events = {
    app: {
      'certificate-error': true,
      'child-process-gone': true,
      'render-process-gone': true,
    },

    webContents: {
      // 'console-message': true,
      'did-fail-load': true,
      'did-fail-provisional-load': true,
      'plugin-crashed': true,
      'preload-error': true,
      'unresponsive': true,
    },
  };

  level = 'error';
  scope = '';

  constructor(options = {}) {
    this.setOptions(options);
  }

  setOptions({ events, level, logger, format, formatters, scope }) {
    if (typeof events === 'object') {
      this.events = events;
    }

    if (typeof level === 'string') {
      this.level = level;
    }

    if (typeof logger === 'object') {
      this.logger = logger;
    }

    if (typeof format === 'string' || typeof format === 'function') {
      this.format = format;
    }

    if (typeof formatters === 'object') {
      this.formatters = formatters;
    }

    if (typeof scope === 'string') {
      this.scope = scope;
    }
  }

  startLogging(options = {}) {
    this.setOptions(options);

    this.disposeListeners();

    for (const eventName of this.getEventNames(this.events.app)) {
      this.disposers.push(
        electronApi.onAppEvent(eventName, (...handlerArgs) => {
          this.handleEvent({ eventSource: 'app', eventName, handlerArgs });
        }),
      );
    }

    for (const eventName of this.getEventNames(this.events.webContents)) {
      this.disposers.push(
        electronApi.onEveryWebContentsEvent(eventName, (...handlerArgs) => {
          this.handleEvent(
            { eventSource: 'webContents', eventName, handlerArgs },
          );
        }),
      );
    }
  }

  stopLogging() {
    this.disposeListeners();
  }

  arrayToObject(array, fieldNames) {
    const obj = {};

    fieldNames.forEach((fieldName, index) => {
      obj[fieldName] = array[index];
    });

    if (array.length > fieldNames.length) {
      obj.unknownArgs = array.slice(fieldNames.length);
    }

    return obj;
  }

  disposeListeners() {
    this.disposers.forEach((disposer) => disposer());
    this.disposers = [];
  }

  formatEventLog({ eventName, eventSource, handlerArgs }) {
    const [event, ...args] = handlerArgs;
    if (typeof this.format === 'function') {
      return this.format({ args, event, eventName, eventSource });
    }

    const formatter = this.formatters[eventSource]?.[eventName];
    let formattedArgs = args;
    if (typeof formatter === 'function') {
      formattedArgs = formatter({ args, event, eventName, eventSource });
    }

    if (!formattedArgs) {
      return undefined;
    }

    const eventData = {};

    if (Array.isArray(formattedArgs)) {
      eventData.args = formattedArgs;
    } else if (typeof formattedArgs === 'object') {
      Object.assign(eventData, formattedArgs);
    }

    if (eventSource === 'webContents') {
      Object.assign(eventData, this.getWebContentsDetails(event?.sender));
    }

    const title = this.format
      .replace('{eventSource}', eventSource === 'app' ? 'App' : 'WebContents')
      .replace('{eventName}', eventName);

    return [title, eventData];
  }

  getEventNames(eventMap) {
    if (!eventMap || typeof eventMap !== 'object') {
      return [];
    }

    return Object.entries(eventMap)
      .filter(([_, listen]) => listen)
      .map(([eventName]) => eventName);
  }

  getWebContentsDetails(webContents) {
    if (!webContents?.loadURL) {
      return {};
    }

    try {
      return {
        webContents: {
          id: webContents.id,
          url: webContents.getURL(),
        },
      };
    } catch {
      return {};
    }
  }

  handleEvent({ eventName, eventSource, handlerArgs }) {
    const log = this.formatEventLog({ eventName, eventSource, handlerArgs });
    if (log) {
      const logFns = this.scope ? this.logger.scope(this.scope) : this.logger;
      logFns?.[this.level]?.(...log);
    }
  }
}

module.exports = EventLogger;


/***/ }),

/***/ "./node_modules/electron-log/src/main/electronApi.js":
/*!***********************************************************!*\
  !*** ./node_modules/electron-log/src/main/electronApi.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const os = __webpack_require__(/*! os */ "os");
const path = __webpack_require__(/*! path */ "path");

/** @type {Electron.Main} */
let electron;
try {
  // eslint-disable-next-line global-require,import/no-extraneous-dependencies
  electron = __webpack_require__(/*! electron */ "electron");
} catch {
  electron = null;
}

module.exports = {
  getAppUserDataPath() {
    return getPath('userData');
  },

  getName,

  getPath,

  getVersion,

  getVersions() {
    return {
      app: `${getName()} ${getVersion()}`,
      electron: `Electron ${process.versions.electron}`,
      os: getOsVersion(),
    };
  },

  isDev() {
    const app = getApp();

    if (app?.isPackaged !== undefined) {
      return !app.isPackaged;
    }

    if (typeof process.execPath === 'string') {
      const execFileName = path.basename(process.execPath).toLowerCase();
      return execFileName.startsWith('electron');
    }

    return  true
      || 0;
  },

  isElectron() {
    return Boolean(process.versions.electron);
  },

  onAppEvent(eventName, handler) {
    electron?.app?.on(eventName, handler);

    return () => {
      electron?.app?.off(eventName, handler);
    };
  },

  onAppReady(handler) {
    if (electron?.app?.isReady()) {
      handler();
    } else if (electron?.app?.once) {
      electron?.app?.once('ready', handler);
    } else {
      handler();
    }
  },

  onEveryWebContentsEvent(eventName, handler) {
    electron?.webContents?.getAllWebContents().forEach((webContents) => {
      webContents.on(eventName, handler);
    });

    electron?.app?.on('web-contents-created', onWebContentsCreated);

    return () => {
      electron?.webContents?.getAllWebContents().forEach((webContents) => {
        webContents.off(eventName, handler);
      });

      electron?.app?.off('web-contents-created', onWebContentsCreated);
    };

    function onWebContentsCreated(_, webContents) {
      webContents.on(eventName, handler);
    }
  },

  /**
   * Listen to async messages sent from opposite process
   * @param {string} channel
   * @param {function} listener
   */
  onIpc(channel, listener) {
    getIpc()?.on(channel, listener);
  },

  onIpcInvoke(channel, listener) {
    getIpc()?.handle?.(channel, listener);
  },

  /**
   * @param {string} url
   * @param {Function} [logFunction]
   */
  openUrl(url, logFunction = console.error) { // eslint-disable-line no-console
    getElectronModule('shell')?.openExternal(url).catch(logFunction);
  },

  setPreloadFileForSessions({
    filePath,
    includeFutureSession = true,
    getSessions = () => [electron?.session?.defaultSession],
  }) {
    for (const session of getSessions().filter(Boolean)) {
      setPreload(session);
    }

    if (includeFutureSession) {
      electron?.app?.on('session-created', (session) => {
        setPreload(session);
      });
    }

    /**
     * @param {Session} session
     */
    function setPreload(session) {
      session.setPreloads([...session.getPreloads(), filePath]);
    }
  },

  /**
   * Sent a message to opposite process
   * @param {string} channel
   * @param {any} message
   */
  sendIpc(channel, message) {
    if (true) {
      sendIpcToRenderer(channel, message);
    } else {}
  },

  showErrorBox(title, message) {
    const dialog = getElectronModule('dialog');
    if (!dialog) return;

    dialog.showErrorBox(title, message);
  },
};

function getApp() {
  return getElectronModule('app');
}

function getName() {
  const app = getApp();
  if (!app) return null;

  return 'name' in app ? app.name : app.getName();
}

function getElectronModule(name) {
  return electron?.[name] || null;
}

function getIpc() {
  if ( true && electron?.ipcMain) {
    return electron.ipcMain;
  }

  if (false) {}

  return null;
}

function getVersion() {
  const app = getApp();
  if (!app) return null;

  return 'version' in app ? app.version : app.getVersion();
}

function getOsVersion() {
  let osName = os.type().replace('_', ' ');
  let osVersion = os.release();

  if (osName === 'Darwin') {
    osName = 'macOS';
    osVersion = getMacOsVersion();
  }

  return `${osName} ${osVersion}`;
}

function getMacOsVersion() {
  const release = Number(os.release().split('.')[0]);
  if (release <= 19) {
    return `10.${release - 4}`;
  }

  return release - 9;
}

function getPath(name) {
  const app = getApp();
  if (!app) return null;

  try {
    return app.getPath(name);
  } catch (e) {
    return null;
  }
}

function sendIpcToMain(channel, message) {
  getIpc()?.send(channel, message);
}

function sendIpcToRenderer(channel, message) {
  electron?.BrowserWindow?.getAllWindows().forEach((wnd) => {
    if (wnd.webContents?.isDestroyed() === false) {
      wnd.webContents.send(channel, message);
    }
  });
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/electron-log/src/main/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const electronApi = __webpack_require__(/*! ./electronApi */ "./node_modules/electron-log/src/main/electronApi.js");
const { initialize } = __webpack_require__(/*! ./initialize */ "./node_modules/electron-log/src/main/initialize.js");
const transportConsole = __webpack_require__(/*! ./transports/console */ "./node_modules/electron-log/src/main/transports/console.js");
const transportFile = __webpack_require__(/*! ./transports/file */ "./node_modules/electron-log/src/main/transports/file/index.js");
const transportRemote = __webpack_require__(/*! ./transports/remote */ "./node_modules/electron-log/src/main/transports/remote.js");
const Logger = __webpack_require__(/*! ../core/Logger */ "./node_modules/electron-log/src/core/Logger.js");
const ErrorHandler = __webpack_require__(/*! ./ErrorHandler */ "./node_modules/electron-log/src/main/ErrorHandler.js");
const EventLogger = __webpack_require__(/*! ./EventLogger */ "./node_modules/electron-log/src/main/EventLogger.js");

const defaultLogger = new Logger({
  errorHandler: new ErrorHandler(),
  eventLogger: new EventLogger(),
  initializeFn: initialize,
  isDev: electronApi.isDev(),
  logId: 'default',
  transportFactories: {
    console: transportConsole,
    file: transportFile,
    remote: transportRemote,
  },
  variables: {
    processType: 'main',
  },
});

defaultLogger.processInternalErrorFn = (e) => {
  defaultLogger.transports.console.writeFn({
    message: {
      data: ['Unhandled electron-log error', e],
      level: 'error',
    },
  });
};

module.exports = defaultLogger;
module.exports.Logger = Logger;
module.exports["default"] = module.exports;

electronApi.onIpc('__ELECTRON_LOG__', (_, message) => {
  if (message.scope) {
    Logger.getInstance(message).scope(message.scope);
  }

  const date = new Date(message.date);
  processMessage({
    ...message,
    date: date.getTime() ? date : new Date(),
  });
});

electronApi.onIpcInvoke('__ELECTRON_LOG__', (_, { cmd = '', logId }) => {
  switch (cmd) {
    case 'getOptions': {
      const logger = Logger.getInstance({ logId });
      return {
        levels: logger.levels,
        logId,
      };
    }

    default: {
      processMessage({ data: [`Unknown cmd '${cmd}'`], level: 'error' });
      return {};
    }
  }
});

function processMessage(message) {
  Logger.getInstance(message)?.processMessage(message);
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/initialize.js":
/*!**********************************************************!*\
  !*** ./node_modules/electron-log/src/main/initialize.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const os = __webpack_require__(/*! os */ "os");
const path = __webpack_require__(/*! path */ "path");
const electronApi = __webpack_require__(/*! ./electronApi */ "./node_modules/electron-log/src/main/electronApi.js");
const preloadInitializeFn = __webpack_require__(/*! ../renderer/electron-log-preload */ "./node_modules/electron-log/src/renderer/electron-log-preload.js");

module.exports = {
  initialize({
    getSessions,
    includeFutureSession,
    logger,
    preload = true,
    spyRendererConsole = false,
  }) {
    electronApi.onAppReady(() => {
      try {
        if (preload) {
          initializePreload({
            getSessions,
            includeFutureSession,
            preloadOption: preload,
          });
        }

        if (spyRendererConsole) {
          initializeSpyRendererConsole({ logger });
        }
      } catch (err) {
        logger.warn(err);
      }
    });
  },
};

function initializePreload({
  getSessions,
  includeFutureSession,
  preloadOption,
}) {
  let preloadPath = typeof preloadOption === 'string'
    ? preloadOption
    : path.resolve(__dirname, '../renderer/electron-log-preload.js');

  if (!fs.existsSync(preloadPath)) {
    preloadPath = path.join(
      electronApi.getAppUserDataPath() || os.tmpdir(),
      'electron-log-preload.js',
    );
    const preloadCode = `
      try {
        (${preloadInitializeFn.toString()})(require('electron'));
      } catch(e) {
        console.error(e);
      }
    `;
    fs.writeFileSync(preloadPath, preloadCode, 'utf8');
  }

  electronApi.setPreloadFileForSessions({
    filePath: preloadPath,
    includeFutureSession,
    getSessions,
  });
}

function initializeSpyRendererConsole({ logger }) {
  const levels = ['verbose', 'info', 'warning', 'error'];
  electronApi.onEveryWebContentsEvent(
    'console-message',
    (event, level, message) => {
      logger.processMessage({
        data: [message],
        level: levels[level],
        variables: { processType: 'renderer' },
      });
    },
  );
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/transforms/format.js":
/*!*****************************************************************!*\
  !*** ./node_modules/electron-log/src/main/transforms/format.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { transform } = __webpack_require__(/*! ./transform */ "./node_modules/electron-log/src/main/transforms/transform.js");

module.exports = {
  concatFirstStringElements,
  formatScope,
  formatText,
  formatVariables,
  timeZoneFromOffset,

  format({ message, logger, transport, data = message?.data }) {
    switch (typeof transport.format) {
      case 'string': {
        return transform({
          message,
          logger,
          transforms: [formatVariables, formatScope, formatText],
          transport,
          initialData: [transport.format, ...data],
        });
      }

      case 'function': {
        return transport.format({
          data,
          level: message?.level || 'info',
          logger,
          message,
          transport,
        });
      }

      default: {
        return data;
      }
    }
  },
};

/**
 * The first argument of console.log may contain a template. In the library
 * the first element is a string related to transports.console.format. So
 * this function concatenates first two elements to make templates like %d
 * work
 * @param {*[]} data
 * @return {*[]}
 */
function concatFirstStringElements({ data }) {
  if (typeof data[0] !== 'string' || typeof data[1] !== 'string') {
    return data;
  }

  if (data[0].match(/%[1cdfiOos]/)) {
    return data;
  }

  return [`${data[0]} ${data[1]}`, ...data.slice(2)];
}

function timeZoneFromOffset(minutesOffset) {
  const minutesPositive = Math.abs(minutesOffset);
  const sign = minutesOffset >= 0 ? '-' : '+';
  const hours = Math.floor(minutesPositive / 60).toString().padStart(2, '0');
  const minutes = (minutesPositive % 60).toString().padStart(2, '0');
  return `${sign}${hours}:${minutes}`;
}

function formatScope({ data, logger, message }) {
  const { defaultLabel, labelLength } = logger?.scope || {};
  const template = data[0];
  let label = message.scope;

  if (!label) {
    label = defaultLabel;
  }

  let scopeText;
  if (label === '') {
    scopeText = labelLength > 0 ? ''.padEnd(labelLength + 3) : '';
  } else if (typeof label === 'string') {
    scopeText = ` (${label})`.padEnd(labelLength + 3);
  } else {
    scopeText = '';
  }

  data[0] = template.replace('{scope}', scopeText);
  return data;
}

function formatVariables({ data, message }) {
  let template = data[0];
  if (typeof template !== 'string') {
    return data;
  }

  // Add additional space to the end of {level}] template to align messages
  template = template.replace('{level}]', `${message.level}]`.padEnd(6, ' '));

  const date = message.date || new Date();
  data[0] = template
    .replace(/\{(\w+)}/g, (substring, name) => {
      switch (name) {
        case 'level': return message.level || 'info';
        case 'logId': return message.logId;

        case 'y': return date.getFullYear().toString(10);
        case 'm': return (date.getMonth() + 1).toString(10).padStart(2, '0');
        case 'd': return date.getDate().toString(10).padStart(2, '0');
        case 'h': return date.getHours().toString(10).padStart(2, '0');
        case 'i': return date.getMinutes().toString(10).padStart(2, '0');
        case 's': return date.getSeconds().toString(10).padStart(2, '0');
        case 'ms': return date.getMilliseconds().toString(10).padStart(3, '0');
        case 'z': return timeZoneFromOffset(date.getTimezoneOffset());
        case 'iso': return date.toISOString();

        default: {
          return message.variables?.[name] || substring;
        }
      }
    })
    .trim();

  return data;
}

function formatText({ data }) {
  const template = data[0];
  if (typeof template !== 'string') {
    return data;
  }

  const textTplPosition = template.lastIndexOf('{text}');
  if (textTplPosition === template.length - 6) {
    data[0] = template.replace(/\s?{text}/, '');
    if (data[0] === '') {
      data.shift();
    }

    return data;
  }

  const templatePieces = template.split('{text}');
  let result = [];

  if (templatePieces[0] !== '') {
    result.push(templatePieces[0]);
  }

  result = result.concat(data.slice(1));

  if (templatePieces[1] !== '') {
    result.push(templatePieces[1]);
  }

  return result;
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/transforms/object.js":
/*!*****************************************************************!*\
  !*** ./node_modules/electron-log/src/main/transforms/object.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! util */ "util");

module.exports = {
  serialize,

  maxDepth({ data, transport, depth = transport?.depth ?? 6 }) {
    if (!data) {
      return data;
    }

    if (depth < 1) {
      if (Array.isArray(data)) return '[array]';
      if (typeof data === 'object' && data) return '[object]';

      return data;
    }

    if (Array.isArray(data)) {
      return data.map((child) => module.exports.maxDepth({
        data: child,
        depth: depth - 1,
      }));
    }

    if (typeof data !== 'object') {
      return data;
    }

    if (data && typeof data.toISOString === 'function') {
      return data;
    }

    // noinspection PointlessBooleanExpressionJS
    if (data === null) {
      return null;
    }

    if (data instanceof Error) {
      return data;
    }

    const newJson = {};
    for (const i in data) {
      if (!Object.prototype.hasOwnProperty.call(data, i)) continue;
      newJson[i] = module.exports.maxDepth({
        data: data[i],
        depth: depth - 1,
      });
    }

    return newJson;
  },

  toJSON({ data }) {
    return JSON.parse(JSON.stringify(data, createSerializer()));
  },

  toString({ data, transport }) {
    const inspectOptions = transport?.inspectOptions || {};

    const simplifiedData = data.map((item) => {
      if (item === undefined) {
        return undefined;
      }

      try {
        const str = JSON.stringify(item, createSerializer(), '  ');
        return str === undefined ? undefined : JSON.parse(str);
      } catch (e) {
        // There are some rare cases when an item can't be simplified.
        // In that case, it's fine to pass it to util.format directly.
        return item;
      }
    });

    return util.formatWithOptions(inspectOptions, ...simplifiedData);
  },
};

/**
 * @param {object} options?
 * @param {boolean} options.serializeMapAndSet?
 * @return {function}
 */
function createSerializer(options = {}) {
  const seen = new WeakSet();

  return function (key, value) {
    if (typeof value === 'object' && value !== null) {
      if (seen.has(value)) {
        return undefined;
      }

      seen.add(value);
    }

    return serialize(key, value, options);
  };
}

/**
 * @param {string} key
 * @param {any} value
 * @param {object} options?
 * @return {any}
 */
function serialize(key, value, options = {}) {
  const serializeMapAndSet = options?.serializeMapAndSet !== false;

  if (value instanceof Error) {
    return value.stack;
  }

  if (!value) {
    return value;
  }

  if (typeof value === 'function') {
    return `[function] ${value.toString()}`;
  }

  if (serializeMapAndSet && value instanceof Map && Object.fromEntries) {
    return Object.fromEntries(value);
  }

  if (serializeMapAndSet && value instanceof Set && Array.from) {
    return Array.from(value);
  }

  return value;
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/transforms/style.js":
/*!****************************************************************!*\
  !*** ./node_modules/electron-log/src/main/transforms/style.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  transformStyles,

  applyAnsiStyles({ data }) {
    return transformStyles(data, styleToAnsi, resetAnsiStyle);
  },

  removeStyles({ data }) {
    return transformStyles(data, () => '');
  },
};

const ANSI_COLORS = {
  unset: '\x1b[0m',
  black: '\x1b[30m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
};

function styleToAnsi(style) {
  const color = style.replace(/color:\s*(\w+).*/, '$1').toLowerCase();
  return ANSI_COLORS[color] || '';
}

function resetAnsiStyle(string) {
  return string + ANSI_COLORS.unset;
}

function transformStyles(data, onStyleFound, onStyleApplied) {
  const foundStyles = {};

  return data.reduce((result, item, index, array) => {
    if (foundStyles[index]) {
      return result;
    }

    if (typeof item === 'string') {
      let valueIndex = index;
      let styleApplied = false;

      item = item.replace(/%[1cdfiOos]/g, (match) => {
        valueIndex += 1;

        if (match !== '%c') {
          return match;
        }

        const style = array[valueIndex];
        if (typeof style === 'string') {
          foundStyles[valueIndex] = true;
          styleApplied = true;
          return onStyleFound(style, item);
        }

        return match;
      });

      if (styleApplied && onStyleApplied) {
        item = onStyleApplied(item);
      }
    }

    result.push(item);
    return result;
  }, []);
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/transforms/transform.js":
/*!********************************************************************!*\
  !*** ./node_modules/electron-log/src/main/transforms/transform.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


module.exports = { transform };

function transform({
  logger,
  message,
  transport,

  initialData = message?.data || [],
  transforms = transport?.transforms,
}) {
  return transforms.reduce((data, trans) => {
    if (typeof trans === 'function') {
      return trans({ data, logger, message, transport });
    }

    return data;
  }, initialData);
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/transports/console.js":
/*!******************************************************************!*\
  !*** ./node_modules/electron-log/src/main/transports/console.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint-disable no-console */

const { concatFirstStringElements, format } = __webpack_require__(/*! ../transforms/format */ "./node_modules/electron-log/src/main/transforms/format.js");
const { maxDepth, toJSON } = __webpack_require__(/*! ../transforms/object */ "./node_modules/electron-log/src/main/transforms/object.js");
const { applyAnsiStyles, removeStyles } = __webpack_require__(/*! ../transforms/style */ "./node_modules/electron-log/src/main/transforms/style.js");
const { transform } = __webpack_require__(/*! ../transforms/transform */ "./node_modules/electron-log/src/main/transforms/transform.js");

const consoleMethods = {
  error: console.error,
  warn: console.warn,
  info: console.info,
  verbose: console.info,
  debug: console.debug,
  silly: console.debug,
  log: console.log,
};

module.exports = consoleTransportFactory;

const separator = process.platform === 'win32' ? '>' : 'â€º';
const DEFAULT_FORMAT = `%c{h}:{i}:{s}.{ms}{scope}%c ${separator} {text}`;

Object.assign(consoleTransportFactory, {
  DEFAULT_FORMAT,
});

function consoleTransportFactory(logger) {
  return Object.assign(transport, {
    format: DEFAULT_FORMAT,
    level: 'silly',
    transforms: [
      addTemplateColors,
      format,
      formatStyles,
      concatFirstStringElements,
      maxDepth,
      toJSON,
    ],
    useStyles: process.env.FORCE_STYLES,

    writeFn({ message }) {
      const consoleLogFn = consoleMethods[message.level] || consoleMethods.info;
      consoleLogFn(...message.data);
    },
  });

  function transport(message) {
    const data = transform({ logger, message, transport });
    transport.writeFn({
      message: { ...message, data },
    });
  }
}

function addTemplateColors({ data, message, transport }) {
  if (transport.format !== DEFAULT_FORMAT) {
    return data;
  }

  return [`color:${levelToStyle(message.level)}`, 'color:unset', ...data];
}

function canUseStyles(useStyleValue, level) {
  if (typeof useStyleValue === 'boolean') {
    return useStyleValue;
  }

  const useStderr = level === 'error' || level === 'warn';
  const stream = useStderr ? process.stderr : process.stdout;
  return stream && stream.isTTY;
}

function formatStyles(args) {
  const { message, transport } = args;
  const useStyles = canUseStyles(transport.useStyles, message.level);
  const nextTransform = useStyles ? applyAnsiStyles : removeStyles;
  return nextTransform(args);
}

function levelToStyle(level) {
  const map = { error: 'red', warn: 'yellow', info: 'cyan', default: 'unset' };
  return map[level] || map.default;
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/transports/file/File.js":
/*!********************************************************************!*\
  !*** ./node_modules/electron-log/src/main/transports/file/File.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events");
const fs = __webpack_require__(/*! fs */ "fs");
const os = __webpack_require__(/*! os */ "os");

class File extends EventEmitter {
  asyncWriteQueue = [];
  bytesWritten = 0;
  hasActiveAsyncWriting = false;
  path = null;
  initialSize = undefined;
  writeOptions = null;
  writeAsync = false;

  constructor({
    path,
    writeOptions = { encoding: 'utf8', flag: 'a', mode: 0o666 },
    writeAsync = false,
  }) {
    super();

    this.path = path;
    this.writeOptions = writeOptions;
    this.writeAsync = writeAsync;
  }

  get size() {
    return this.getSize();
  }

  clear() {
    try {
      fs.writeFileSync(this.path, '', {
        mode: this.writeOptions.mode,
        flag: 'w',
      });
      this.reset();
      return true;
    } catch (e) {
      if (e.code === 'ENOENT') {
        return true;
      }

      this.emit('error', e, this);
      return false;
    }
  }

  crop(bytesAfter) {
    try {
      const content = readFileSyncFromEnd(this.path, bytesAfter || 4096);
      this.clear();
      this.writeLine(`[log cropped]${os.EOL}${content}`);
    } catch (e) {
      this.emit(
        'error',
        new Error(`Couldn't crop file ${this.path}. ${e.message}`),
        this,
      );
    }
  }

  getSize() {
    if (this.initialSize === undefined) {
      try {
        const stats = fs.statSync(this.path);
        this.initialSize = stats.size;
      } catch (e) {
        this.initialSize = 0;
      }
    }

    return this.initialSize + this.bytesWritten;
  }

  increaseBytesWrittenCounter(text) {
    this.bytesWritten += Buffer.byteLength(text, this.writeOptions.encoding);
  }

  isNull() {
    return false;
  }

  nextAsyncWrite() {
    const file = this;

    if (this.hasActiveAsyncWriting || this.asyncWriteQueue.length === 0) {
      return;
    }

    const text = this.asyncWriteQueue.join('');
    this.asyncWriteQueue = [];
    this.hasActiveAsyncWriting = true;

    fs.writeFile(this.path, text, this.writeOptions, (e) => {
      file.hasActiveAsyncWriting = false;

      if (e) {
        file.emit(
          'error',
          new Error(`Couldn't write to ${file.path}. ${e.message}`),
          this,
        );
      } else {
        file.increaseBytesWrittenCounter(text);
      }

      file.nextAsyncWrite();
    });
  }

  reset() {
    this.initialSize = undefined;
    this.bytesWritten = 0;
  }

  toString() {
    return this.path;
  }

  writeLine(text) {
    text += os.EOL;

    if (this.writeAsync) {
      this.asyncWriteQueue.push(text);
      this.nextAsyncWrite();
      return;
    }

    try {
      fs.writeFileSync(this.path, text, this.writeOptions);
      this.increaseBytesWrittenCounter(text);
    } catch (e) {
      this.emit(
        'error',
        new Error(`Couldn't write to ${this.path}. ${e.message}`),
        this,
      );
    }
  }
}

module.exports = File;

function readFileSyncFromEnd(filePath, bytesCount) {
  const buffer = Buffer.alloc(bytesCount);
  const stats = fs.statSync(filePath);

  const readLength = Math.min(stats.size, bytesCount);
  const offset = Math.max(0, stats.size - bytesCount);

  const fd = fs.openSync(filePath, 'r');
  const totalBytes = fs.readSync(fd, buffer, 0, readLength, offset);
  fs.closeSync(fd);

  return buffer.toString('utf8', 0, totalBytes);
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/transports/file/FileRegistry.js":
/*!****************************************************************************!*\
  !*** ./node_modules/electron-log/src/main/transports/file/FileRegistry.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events");
const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const File = __webpack_require__(/*! ./File */ "./node_modules/electron-log/src/main/transports/file/File.js");
const NullFile = __webpack_require__(/*! ./NullFile */ "./node_modules/electron-log/src/main/transports/file/NullFile.js");

class FileRegistry extends EventEmitter {
  store = {};

  constructor() {
    super();
    this.emitError = this.emitError.bind(this);
  }

  /**
   * Provide a File object corresponding to the filePath
   * @param {string} filePath
   * @param {WriteOptions} [writeOptions]
   * @param {boolean} [writeAsync]
   * @return {File}
   */
  provide({ filePath, writeOptions, writeAsync = false }) {
    let file;
    try {
      filePath = path.resolve(filePath);

      if (this.store[filePath]) {
        return this.store[filePath];
      }

      file = this.createFile({ filePath, writeOptions, writeAsync });
    } catch (e) {
      file = new NullFile({ path: filePath });
      this.emitError(e, file);
    }

    file.on('error', this.emitError);
    this.store[filePath] = file;
    return file;
  }

  /**
   * @param {string} filePath
   * @param {WriteOptions} writeOptions
   * @param {boolean} async
   * @return {File}
   * @private
   */
  createFile({ filePath, writeOptions, writeAsync }) {
    this.testFileWriting(filePath);
    return new File({ path: filePath, writeOptions, writeAsync });
  }

  /**
   * @param {Error} error
   * @param {File} file
   * @private
   */
  emitError(error, file) {
    this.emit('error', error, file);
  }

  /**
   * @param {string} filePath
   * @private
   */
  testFileWriting(filePath) {
    fs.mkdirSync(path.dirname(filePath), { recursive: true });
    fs.writeFileSync(filePath, '', { flag: 'a' });
  }
}

module.exports = FileRegistry;


/***/ }),

/***/ "./node_modules/electron-log/src/main/transports/file/NullFile.js":
/*!************************************************************************!*\
  !*** ./node_modules/electron-log/src/main/transports/file/NullFile.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const File = __webpack_require__(/*! ./File */ "./node_modules/electron-log/src/main/transports/file/File.js");

class NullFile extends File {
  clear() {

  }

  crop() {

  }

  getSize() {
    return 0;
  }

  isNull() {
    return true;
  }

  writeLine() {

  }
}

module.exports = NullFile;


/***/ }),

/***/ "./node_modules/electron-log/src/main/transports/file/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/electron-log/src/main/transports/file/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const os = __webpack_require__(/*! os */ "os");
const FileRegistry = __webpack_require__(/*! ./FileRegistry */ "./node_modules/electron-log/src/main/transports/file/FileRegistry.js");
const variables = __webpack_require__(/*! ./variables */ "./node_modules/electron-log/src/main/transports/file/variables.js");
const { transform } = __webpack_require__(/*! ../../transforms/transform */ "./node_modules/electron-log/src/main/transforms/transform.js");
const { removeStyles } = __webpack_require__(/*! ../../transforms/style */ "./node_modules/electron-log/src/main/transforms/style.js");
const { format } = __webpack_require__(/*! ../../transforms/format */ "./node_modules/electron-log/src/main/transforms/format.js");
const { toString } = __webpack_require__(/*! ../../transforms/object */ "./node_modules/electron-log/src/main/transforms/object.js");

module.exports = fileTransportFactory;

// Shared between multiple file transport instances
const globalRegistry = new FileRegistry();

function fileTransportFactory(logger, registry = globalRegistry) {
  /** @type {PathVariables} */
  let pathVariables;

  if (registry.listenerCount('error') < 1) {
    registry.on('error', (e, file) => {
      logConsole(`Can't write to ${file}`, e);
    });
  }

  return Object.assign(transport, {
    fileName: getDefaultFileName(logger.variables.processType),
    format: '[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}]{scope} {text}',
    getFile,
    inspectOptions: { depth: 5 },
    level: 'silly',
    maxSize: 1024 ** 2,
    readAllLogs,
    sync: true,
    transforms: [removeStyles, format, toString],
    writeOptions: { flag: 'a', mode: 0o666, encoding: 'utf8' },

    archiveLogFn(file) {
      const oldPath = file.toString();
      const inf = path.parse(oldPath);
      try {
        fs.renameSync(oldPath, path.join(inf.dir, `${inf.name}.old${inf.ext}`));
      } catch (e) {
        logConsole('Could not rotate log', e);
        const quarterOfMaxSize = Math.round(transport.maxSize / 4);
        file.crop(Math.min(quarterOfMaxSize, 256 * 1024));
      }
    },

    resolvePathFn(vars) {
      return path.join(vars.libraryDefaultDir, vars.fileName);
    },
  });

  function transport(message) {
    const file = getFile(message);

    const needLogRotation = transport.maxSize > 0
      && file.size > transport.maxSize;

    if (needLogRotation) {
      transport.archiveLogFn(file);
      file.reset();
    }

    const content = transform({ logger, message, transport });
    file.writeLine(content);
  }

  function initializeOnFirstAccess() {
    if (pathVariables) {
      return;
    }

    // Make a shallow copy of pathVariables to keep getters intact
    pathVariables = Object.create(
      Object.prototype,
      {
        ...Object.getOwnPropertyDescriptors(
          variables.getPathVariables(process.platform),
        ),
        fileName: {
          get() {
            return transport.fileName;
          },
          enumerable: true,
        },
      },
    );

    if (typeof transport.archiveLog === 'function') {
      transport.archiveLogFn = transport.archiveLog;
      logConsole('archiveLog is deprecated. Use archiveLogFn instead');
    }

    if (typeof transport.resolvePath === 'function') {
      transport.resolvePathFn = transport.resolvePath;
      logConsole('resolvePath is deprecated. Use resolvePathFn instead');
    }
  }

  function logConsole(message, error = null, level = 'error') {
    const data = [`electron-log.transports.file: ${message}`];

    if (error) {
      data.push(error);
    }

    logger.transports.console({ data, date: new Date(), level });
  }

  function getFile(msg) {
    initializeOnFirstAccess();

    const filePath = transport.resolvePathFn(pathVariables, msg);
    return registry.provide({
      filePath,
      writeAsync: !transport.sync,
      writeOptions: transport.writeOptions,
    });
  }

  function readAllLogs({ fileFilter = (f) => f.endsWith('.log') } = {}) {
    const logsPath = path.dirname(transport.resolvePathFn(pathVariables));

    return fs.readdirSync(logsPath)
      .map((fileName) => path.join(logsPath, fileName))
      .filter(fileFilter)
      .map((logPath) => {
        try {
          return {
            path: logPath,
            lines: fs.readFileSync(logPath, 'utf8').split(os.EOL),
          };
        } catch {
          return null;
        }
      })
      .filter(Boolean);
  }
}

function getDefaultFileName(processType = "browser") {
  switch (processType) {
    case 'renderer': return 'renderer.log';
    case 'worker': return 'worker.log';
    default: return 'main.log';
  }
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/transports/file/packageJson.js":
/*!***************************************************************************!*\
  !*** ./node_modules/electron-log/src/main/transports/file/packageJson.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint-disable consistent-return */

const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");

module.exports = {
  readPackageJson,
  tryReadJsonAt,
};

/**
 * @return {{ name?: string, version?: string}}
 */
function readPackageJson() {
  return tryReadJsonAt(__webpack_require__.c[__webpack_require__.s] && __webpack_require__.c[__webpack_require__.s].filename)
    || tryReadJsonAt(extractPathFromArgs())
    || tryReadJsonAt(process.resourcesPath, 'app.asar')
    || tryReadJsonAt(process.resourcesPath, 'app')
    || tryReadJsonAt(process.cwd())
    || { name: null, version: null };
}

/**
 * @param {...string} searchPaths
 * @return {{ name?: string, version?: string } | null}
 */
function tryReadJsonAt(...searchPaths) {
  if (!searchPaths[0]) {
    return null;
  }

  try {
    const searchPath = path.join(...searchPaths);
    const fileName = findUp('package.json', searchPath);
    if (!fileName) {
      return null;
    }

    const json = JSON.parse(fs.readFileSync(fileName, 'utf8'));
    const name = json.productName || json.name;
    if (!name || name.toLowerCase() === 'electron') {
      return null;
    }

    if (json.productName || json.name) {
      return {
        name,
        version: json.version,
      };
    }
  } catch (e) {
    return null;
  }
}

/**
 * @param {string} fileName
 * @param {string} [cwd]
 * @return {string | null}
 */
function findUp(fileName, cwd) {
  let currentPath = cwd;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const parsedPath = path.parse(currentPath);
    const root = parsedPath.root;
    const dir = parsedPath.dir;

    if (fs.existsSync(path.join(currentPath, fileName))) {
      return path.resolve(path.join(currentPath, fileName));
    }

    if (currentPath === root) {
      return null;
    }

    currentPath = dir;
  }
}

/**
 * Get app path from --user-data-dir cmd arg, passed to a renderer process
 * @return {string|null}
 */
function extractPathFromArgs() {
  const matchedArgs = process.argv.filter((arg) => {
    return arg.indexOf('--user-data-dir=') === 0;
  });

  if (matchedArgs.length === 0 || typeof matchedArgs[0] !== 'string') {
    return null;
  }

  const userDataDir = matchedArgs[0];
  return userDataDir.replace('--user-data-dir=', '');
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/transports/file/variables.js":
/*!*************************************************************************!*\
  !*** ./node_modules/electron-log/src/main/transports/file/variables.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const os = __webpack_require__(/*! os */ "os");
const path = __webpack_require__(/*! path */ "path");
const electronApi = __webpack_require__(/*! ../../electronApi */ "./node_modules/electron-log/src/main/electronApi.js");
const packageJson = __webpack_require__(/*! ./packageJson */ "./node_modules/electron-log/src/main/transports/file/packageJson.js");

module.exports = {
  getAppData,
  getLibraryDefaultDir,
  getLibraryTemplate,
  getNameAndVersion,
  getPathVariables,
  getUserData,
};

function getAppData(platform) {
  const appData = electronApi.getPath('appData');
  if (appData) {
    return appData;
  }

  const home = getHome();

  switch (platform) {
    case 'darwin': {
      return path.join(home, 'Library/Application Support');
    }

    case 'win32': {
      return process.env.APPDATA || path.join(home, 'AppData/Roaming');
    }

    default: {
      return process.env.XDG_CONFIG_HOME || path.join(home, '.config');
    }
  }
}

function getHome() {
  return os.homedir ? os.homedir() : process.env.HOME;
}

function getLibraryDefaultDir(platform, appName) {
  if (platform === 'darwin') {
    return path.join(getHome(), 'Library/Logs', appName);
  }

  return path.join(getUserData(platform, appName), 'logs');
}

function getLibraryTemplate(platform) {
  if (platform === 'darwin') {
    return path.join(getHome(), 'Library/Logs', '{appName}');
  }

  return path.join(getAppData(platform), '{appName}', 'logs');
}

function getNameAndVersion() {
  let name = electronApi.getName() || '';
  let version = electronApi.getVersion();

  if (name.toLowerCase() === 'electron') {
    name = '';
    version = '';
  }

  if (name && version) {
    return { name, version };
  }

  const packageValues = packageJson.readPackageJson();
  if (!name) {
    name = packageValues.name;
  }

  if (!version) {
    version = packageValues.version;
  }

  if (!name) {
    // Fallback, otherwise file transport can't be initialized
    name = 'Electron';
  }

  return { name, version };
}

/**
 * @param {string} platform
 * @return {PathVariables}
 */
function getPathVariables(platform) {
  const nameAndVersion = getNameAndVersion();
  const appName = nameAndVersion.name;
  const appVersion = nameAndVersion.version;

  return {
    appData: getAppData(platform),
    appName,
    appVersion,
    get electronDefaultDir() {
      return electronApi.getPath('logs');
    },
    home: getHome(),
    libraryDefaultDir: getLibraryDefaultDir(platform, appName),
    libraryTemplate: getLibraryTemplate(platform),
    temp: electronApi.getPath('temp') || os.tmpdir(),
    userData: getUserData(platform, appName),
  };
}

function getUserData(platform, appName) {
  if (electronApi.getName() !== appName) {
    return path.join(getAppData(platform), appName);
  }

  return electronApi.getPath('userData')
    || path.join(getAppData(platform), appName);
}


/***/ }),

/***/ "./node_modules/electron-log/src/main/transports/remote.js":
/*!*****************************************************************!*\
  !*** ./node_modules/electron-log/src/main/transports/remote.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const http = __webpack_require__(/*! http */ "http");
const https = __webpack_require__(/*! https */ "https");
const { transform } = __webpack_require__(/*! ../transforms/transform */ "./node_modules/electron-log/src/main/transforms/transform.js");
const { removeStyles } = __webpack_require__(/*! ../transforms/style */ "./node_modules/electron-log/src/main/transforms/style.js");
const { toJSON, maxDepth } = __webpack_require__(/*! ../transforms/object */ "./node_modules/electron-log/src/main/transforms/object.js");

module.exports = remoteTransportFactory;

function remoteTransportFactory(logger) {
  return Object.assign(transport, {
    client: { name: 'electron-application' },
    depth: 6,
    level: false,
    requestOptions: {},
    transforms: [removeStyles, toJSON, maxDepth],

    makeBodyFn({ message }) {
      return JSON.stringify({
        client: transport.client,
        data: message.data,
        date: message.date.getTime(),
        level: message.level,
        scope: message.scope,
        variables: message.variables,
      });
    },

    processErrorFn({ error }) {
      logger.processMessage(
        {
          data: [`electron-log: can't POST ${transport.url}`, error],
          level: 'warn',
        },
        { transports: ['console', 'file'] },
      );
    },

    sendRequestFn({ serverUrl, requestOptions, body }) {
      const httpTransport = serverUrl.startsWith('https:') ? https : http;

      const request = httpTransport.request(serverUrl, {
        method: 'POST',
        ...requestOptions,
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': body.length,
          ...requestOptions.headers,
        },
      });

      request.write(body);
      request.end();

      return request;
    },
  });

  function transport(message) {
    if (!transport.url) {
      return;
    }

    const body = transport.makeBodyFn({
      logger,
      message: { ...message, data: transform({ logger, message, transport }) },
      transport,
    });

    const request = transport.sendRequestFn({
      serverUrl: transport.url,
      requestOptions: transport.requestOptions,
      body: Buffer.from(body, 'utf8'),
    });

    request.on('error', (error) => transport.processErrorFn({
      error,
      logger,
      message,
      request,
      transport,
    }));
  }
}


/***/ }),

/***/ "./node_modules/electron-log/src/renderer/electron-log-preload.js":
/*!************************************************************************!*\
  !*** ./node_modules/electron-log/src/renderer/electron-log-preload.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let electron = {};

try {
  // eslint-disable-next-line global-require,import/no-extraneous-dependencies
  electron = __webpack_require__(/*! electron */ "electron");
} catch (e) {
  // require isn't available, not from a preload script
}

if (electron.ipcRenderer) {
  initialize(electron);
}

if (true) {
  module.exports = initialize;
}

/**
 * @param {Electron.ContextBridge} contextBridge
 * @param {Electron.IpcRenderer} ipcRenderer
 */
function initialize({ contextBridge, ipcRenderer }) {
  if (!ipcRenderer) {
    return;
  }

  ipcRenderer.on('__ELECTRON_LOG_IPC__', (_, message) => {
    window.postMessage({ cmd: 'message', ...message });
  });

  ipcRenderer
    .invoke('__ELECTRON_LOG__', { cmd: 'getOptions' })
    // eslint-disable-next-line no-console
    .catch((e) => console.error(new Error(
      'electron-log isn\'t initialized in the main process. '
      + `Please call log.initialize() before. ${e.message}`,
    )));

  const electronLog = {
    sendToMain(message) {
      try {
        ipcRenderer.send('__ELECTRON_LOG__', message);
      } catch (e) {
        // eslint-disable-next-line no-console
        console.error('electronLog.sendToMain ', e, 'data:', message);

        ipcRenderer.send('__ELECTRON_LOG__', {
          cmd: 'errorHandler',
          error: { message: e?.message, stack: e?.stack },
          errorName: 'sendToMain',
        });
      }
    },

    log(...data) {
      electronLog.sendToMain({ data, level: 'info' });
    },
  };

  for (const level of ['error', 'warn', 'info', 'verbose', 'debug', 'silly']) {
    electronLog[level] = (...data) => electronLog.sendToMain({
      data,
      level,
    });
  }

  if (contextBridge && process.contextIsolated) {
    try {
      contextBridge.exposeInMainWorld('__electronLog', electronLog);
    } catch {
      // Sometimes this files can be included twice
    }
  }

  if (typeof window === 'object') {
    window.__electronLog = electronLog;
  } else {
    // noinspection JSConstantReassignment
    __electronLog = electronLog;
  }
}


/***/ }),

/***/ "./node_modules/electron-log/src/renderer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/electron-log/src/renderer/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Logger = __webpack_require__(/*! ../core/Logger */ "./node_modules/electron-log/src/core/Logger.js");
const RendererErrorHandler = __webpack_require__(/*! ./lib/RendererErrorHandler */ "./node_modules/electron-log/src/renderer/lib/RendererErrorHandler.js");
const transportConsole = __webpack_require__(/*! ./lib/transports/console */ "./node_modules/electron-log/src/renderer/lib/transports/console.js");
const transportIpc = __webpack_require__(/*! ./lib/transports/ipc */ "./node_modules/electron-log/src/renderer/lib/transports/ipc.js");

module.exports = createLogger();
module.exports.Logger = Logger;
module.exports["default"] = module.exports;

function createLogger() {
  const logger = new Logger({
    allowUnknownLevel: true,
    errorHandler: new RendererErrorHandler(),
    initializeFn: () => {},
    logId: 'default',
    transportFactories: {
      console: transportConsole,
      ipc: transportIpc,
    },
    variables: {
      processType: 'renderer',
    },
  });

  logger.errorHandler.setOptions({
    logFn({ error, errorName, showDialog }) {
      logger.transports.console({
        data: [errorName, error].filter(Boolean),
        level: 'error',
      });
      logger.transports.ipc({
        cmd: 'errorHandler',
        error: {
          cause: error?.cause,
          code: error?.code,
          name: error?.name,
          message: error?.message,
          stack: error?.stack,
        },
        errorName,
        logId: logger.logId,
        showDialog,
      });
    },
  });

  if (typeof window === 'object') {
    window.addEventListener('message', (event) => {
      const { cmd, logId, ...message } = event.data || {};
      const instance = Logger.getInstance({ logId });

      if (cmd === 'message') {
        instance.processMessage(message, { transports: ['console'] });
      }
    });
  }

  // To support custom levels
  return new Proxy(logger, {
    get(target, prop) {
      if (typeof target[prop] !== 'undefined') {
        return target[prop];
      }

      return (...data) => logger.logData(data, { level: prop });
    },
  });
}


/***/ }),

/***/ "./node_modules/electron-log/src/renderer/lib/RendererErrorHandler.js":
/*!****************************************************************************!*\
  !*** ./node_modules/electron-log/src/renderer/lib/RendererErrorHandler.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


// eslint-disable-next-line no-console
const consoleError = console.error;

class RendererErrorHandler {
  logFn = null;
  onError = null;
  showDialog = false;
  preventDefault = true;

  constructor({ logFn = null } = {}) {
    this.handleError = this.handleError.bind(this);
    this.handleRejection = this.handleRejection.bind(this);
    this.startCatching = this.startCatching.bind(this);
    this.logFn = logFn;
  }

  handle(error, {
    logFn = this.logFn,
    errorName = '',
    onError = this.onError,
    showDialog = this.showDialog,
  } = {}) {
    try {
      if (onError?.({ error, errorName, processType: 'renderer' }) !== false) {
        logFn({ error, errorName, showDialog });
      }
    } catch {
      consoleError(error);
    }
  }

  setOptions({ logFn, onError, preventDefault, showDialog }) {
    if (typeof logFn === 'function') {
      this.logFn = logFn;
    }

    if (typeof onError === 'function') {
      this.onError = onError;
    }

    if (typeof preventDefault === 'boolean') {
      this.preventDefault = preventDefault;
    }

    if (typeof showDialog === 'boolean') {
      this.showDialog = showDialog;
    }
  }

  startCatching({ onError, showDialog } = {}) {
    if (this.isActive) {
      return;
    }

    this.isActive = true;
    this.setOptions({ onError, showDialog });

    window.addEventListener('error', (event) => {
      this.preventDefault && event.preventDefault?.();
      this.handleError(event.error || event);
    });
    window.addEventListener('unhandledrejection', (event) => {
      this.preventDefault && event.preventDefault?.();
      this.handleRejection(event.reason || event);
    });
  }

  handleError(error) {
    this.handle(error, { errorName: 'Unhandled' });
  }

  handleRejection(reason) {
    const error = reason instanceof Error
      ? reason
      : new Error(JSON.stringify(reason));
    this.handle(error, { errorName: 'Unhandled rejection' });
  }
}

module.exports = RendererErrorHandler;


/***/ }),

/***/ "./node_modules/electron-log/src/renderer/lib/transports/console.js":
/*!**************************************************************************!*\
  !*** ./node_modules/electron-log/src/renderer/lib/transports/console.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";


/* eslint-disable no-console */

module.exports = consoleTransportRendererFactory;

const consoleMethods = {
  error: console.error,
  warn: console.warn,
  info: console.info,
  verbose: console.info,
  debug: console.debug,
  silly: console.debug,
  log: console.log,
};

function consoleTransportRendererFactory(logger) {
  return Object.assign(transport, {
    format: '{h}:{i}:{s}.{ms}{scope} â€º {text}',

    formatDataFn({
      data = [],
      date = new Date(),
      format = transport.format,
      logId = logger.logId,
      scope = logger.scopeName,
      ...message
    }) {
      if (typeof format === 'function') {
        return format({ ...message, data, date, logId, scope });
      }

      if (typeof format !== 'string') {
        return data;
      }

      data.unshift(format);

      // Concatenate first two data items to support printf-like templates
      if (typeof data[1] === 'string' && data[1].match(/%[1cdfiOos]/)) {
        data = [`${data[0]} ${data[1]}`, ...data.slice(2)];
      }

      data[0] = data[0]
        .replace(/\{(\w+)}/g, (substring, name) => {
          switch (name) {
            case 'level': return message.level;
            case 'logId': return logId;
            case 'scope': return scope ? ` (${scope})` : '';
            case 'text': return '';

            case 'y': return date.getFullYear().toString(10);
            case 'm': return (date.getMonth() + 1).toString(10)
              .padStart(2, '0');
            case 'd': return date.getDate().toString(10).padStart(2, '0');
            case 'h': return date.getHours().toString(10).padStart(2, '0');
            case 'i': return date.getMinutes().toString(10).padStart(2, '0');
            case 's': return date.getSeconds().toString(10).padStart(2, '0');
            case 'ms': return date.getMilliseconds().toString(10)
              .padStart(3, '0');
            case 'iso': return date.toISOString();

            default: {
              return message.variables?.[name] || substring;
            }
          }
        })
        .trim();

      return data;
    },

    writeFn({ message: { level, data } }) {
      const consoleLogFn = consoleMethods[level] || consoleMethods.info;

      // make an empty call stack
      setTimeout(() => consoleLogFn(...data));
    },

  });

  function transport(message) {
    transport.writeFn({
      message: { ...message, data: transport.formatDataFn(message) },
    });
  }
}


/***/ }),

/***/ "./node_modules/electron-log/src/renderer/lib/transports/ipc.js":
/*!**********************************************************************!*\
  !*** ./node_modules/electron-log/src/renderer/lib/transports/ipc.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


module.exports = ipcTransportRendererFactory;

const RESTRICTED_TYPES = new Set([Promise, WeakMap, WeakSet]);

function ipcTransportRendererFactory(logger) {
  return Object.assign(transport, {
    depth: 5,

    serializeFn(data, { depth = 5, seen = new WeakSet() } = {}) {
      if (depth < 1) {
        return `[${typeof data}]`;
      }

      if (seen.has(data)) {
        return data;
      }

      if (['function', 'symbol'].includes(typeof data)) {
        return data.toString();
      }

      // Primitive types (including null and undefined)
      if (Object(data) !== data) {
        return data;
      }

      // Object types

      if (RESTRICTED_TYPES.has(data.constructor)) {
        return `[${data.constructor.name}]`;
      }

      if (Array.isArray(data)) {
        return data.map((item) => transport.serializeFn(
          item,
          { depth: depth - 1, seen },
        ));
      }

      if (data instanceof Error) {
        return data.stack;
      }

      if (data instanceof Map) {
        return new Map(
          Array
            .from(data)
            .map(([key, value]) => [
              transport.serializeFn(key, { depth: depth - 1, seen }),
              transport.serializeFn(value, { depth: depth - 1, seen }),
            ]),
        );
      }

      if (data instanceof Set) {
        return new Set(
          Array.from(data).map(
            (val) => transport.serializeFn(val, { depth: depth - 1, seen }),
          ),
        );
      }

      seen.add(data);

      return Object.fromEntries(
        Object.entries(data).map(
          ([key, value]) => [
            key,
            transport.serializeFn(value, { depth: depth - 1, seen }),
          ],
        ),
      );
    },
  });

  function transport(message) {
    if (!window.__electronLog) {
      logger.processMessage(
        {
          data: ['electron-log: logger isn\'t initialized in the main process'],
          level: 'error',
        },
        { transports: ['console'] },
      );
      return;
    }

    try {
      __electronLog.sendToMain(transport.serializeFn(message, {
        depth: transport.depth,
      }));
    } catch (e) {
      logger.transports.console({
        data: ['electronLog.transports.ipc', e, 'data:', message.data],
        level: 'error',
      });
    }
  }
}


/***/ }),

/***/ "./node_modules/electron-window-state/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/electron-window-state/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(/*! path */ "path");
const electron = __webpack_require__(/*! electron */ "electron");
const jsonfile = __webpack_require__(/*! jsonfile */ "./node_modules/jsonfile/index.js");
const mkdirp = __webpack_require__(/*! mkdirp */ "./node_modules/mkdirp/index.js");

module.exports = function (options) {
  const app = electron.app || electron.remote.app;
  const screen = electron.screen || electron.remote.screen;
  let state;
  let winRef;
  let stateChangeTimer;
  const eventHandlingDelay = 100;
  const config = Object.assign({
    file: 'window-state.json',
    path: app.getPath('userData'),
    maximize: true,
    fullScreen: true
  }, options);
  const fullStoreFileName = path.join(config.path, config.file);

  function isNormal(win) {
    return !win.isMaximized() && !win.isMinimized() && !win.isFullScreen();
  }

  function hasBounds() {
    return state &&
      Number.isInteger(state.x) &&
      Number.isInteger(state.y) &&
      Number.isInteger(state.width) && state.width > 0 &&
      Number.isInteger(state.height) && state.height > 0;
  }

  function resetStateToDefault() {
    const displayBounds = screen.getPrimaryDisplay().bounds;

    // Reset state to default values on the primary display
    state = {
      width: config.defaultWidth || 800,
      height: config.defaultHeight || 600,
      x: 0,
      y: 0,
      displayBounds
    };
  }

  function windowWithinBounds(bounds) {
    return (
      state.x >= bounds.x &&
      state.y >= bounds.y &&
      state.x + state.width <= bounds.x + bounds.width &&
      state.y + state.height <= bounds.y + bounds.height
    );
  }

  function ensureWindowVisibleOnSomeDisplay() {
    const visible = screen.getAllDisplays().some(display => {
      return windowWithinBounds(display.bounds);
    });

    if (!visible) {
      // Window is partially or fully not visible now.
      // Reset it to safe defaults.
      return resetStateToDefault();
    }
  }

  function validateState() {
    const isValid = state && (hasBounds() || state.isMaximized || state.isFullScreen);
    if (!isValid) {
      state = null;
      return;
    }

    if (hasBounds() && state.displayBounds) {
      ensureWindowVisibleOnSomeDisplay();
    }
  }

  function updateState(win) {
    win = win || winRef;
    if (!win) {
      return;
    }
    // Don't throw an error when window was closed
    try {
      const winBounds = win.getBounds();
      if (isNormal(win)) {
        state.x = winBounds.x;
        state.y = winBounds.y;
        state.width = winBounds.width;
        state.height = winBounds.height;
      }
      state.isMaximized = win.isMaximized();
      state.isFullScreen = win.isFullScreen();
      state.displayBounds = screen.getDisplayMatching(winBounds).bounds;
    } catch (err) {}
  }

  function saveState(win) {
    // Update window state only if it was provided
    if (win) {
      updateState(win);
    }

    // Save state
    try {
      mkdirp.sync(path.dirname(fullStoreFileName));
      jsonfile.writeFileSync(fullStoreFileName, state);
    } catch (err) {
      // Don't care
    }
  }

  function stateChangeHandler() {
    // Handles both 'resize' and 'move'
    clearTimeout(stateChangeTimer);
    stateChangeTimer = setTimeout(updateState, eventHandlingDelay);
  }

  function closeHandler() {
    updateState();
  }

  function closedHandler() {
    // Unregister listeners and save state
    unmanage();
    saveState();
  }

  function manage(win) {
    if (config.maximize && state.isMaximized) {
      win.maximize();
    }
    if (config.fullScreen && state.isFullScreen) {
      win.setFullScreen(true);
    }
    win.on('resize', stateChangeHandler);
    win.on('move', stateChangeHandler);
    win.on('close', closeHandler);
    win.on('closed', closedHandler);
    winRef = win;
  }

  function unmanage() {
    if (winRef) {
      winRef.removeListener('resize', stateChangeHandler);
      winRef.removeListener('move', stateChangeHandler);
      clearTimeout(stateChangeTimer);
      winRef.removeListener('close', closeHandler);
      winRef.removeListener('closed', closedHandler);
      winRef = null;
    }
  }

  // Load previous state
  try {
    state = jsonfile.readFileSync(fullStoreFileName);
  } catch (err) {
    // Don't care
  }

  // Check state validity
  validateState();

  // Set state fallback values
  state = Object.assign({
    width: config.defaultWidth || 800,
    height: config.defaultHeight || 600
  }, state);

  return {
    get x() { return state.x; },
    get y() { return state.y; },
    get width() { return state.width; },
    get height() { return state.height; },
    get displayBounds() { return state.displayBounds; },
    get isMaximized() { return state.isMaximized; },
    get isFullScreen() { return state.isFullScreen; },
    saveState,
    unmanage,
    manage,
    resetStateToDefault
  };
};


/***/ }),

/***/ "./node_modules/graceful-fs/clone.js":
/*!*******************************************!*\
  !*** ./node_modules/graceful-fs/clone.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


module.exports = clone

var getPrototypeOf = Object.getPrototypeOf || function (obj) {
  return obj.__proto__
}

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: getPrototypeOf(obj) }
  else
    var copy = Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}


/***/ }),

/***/ "./node_modules/graceful-fs/graceful-fs.js":
/*!*************************************************!*\
  !*** ./node_modules/graceful-fs/graceful-fs.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(/*! fs */ "fs")
var polyfills = __webpack_require__(/*! ./polyfills.js */ "./node_modules/graceful-fs/polyfills.js")
var legacy = __webpack_require__(/*! ./legacy-streams.js */ "./node_modules/graceful-fs/legacy-streams.js")
var clone = __webpack_require__(/*! ./clone.js */ "./node_modules/graceful-fs/clone.js")

var util = __webpack_require__(/*! util */ "util")

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue
var previousSymbol

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue')
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous')
} else {
  gracefulQueue = '___graceful-fs.queue'
  previousSymbol = '___graceful-fs.previous'
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  })
}

var debug = noop
if (util.debuglog)
  debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

// Once time initialization
if (!fs[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = global[gracefulQueue] || []
  publishQueue(fs, queue)

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          resetQueue()
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    })
    return close
  })(fs.close)

  fs.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs, arguments)
      resetQueue()
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    })
    return closeSync
  })(fs.closeSync)

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs[gracefulQueue])
      __webpack_require__(/*! assert */ "assert").equal(fs[gracefulQueue].length, 0)
    })
  }
}

if (!global[gracefulQueue]) {
  publishQueue(global, fs[gracefulQueue]);
}

module.exports = patch(clone(fs))
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs)
    fs.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch

  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb, startTime) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb, startTime) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb, startTime) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$copyFile = fs.copyFile
  if (fs$copyFile)
    fs.copyFile = copyFile
  function copyFile (src, dest, flags, cb) {
    if (typeof flags === 'function') {
      cb = flags
      flags = 0
    }
    return go$copyFile(src, dest, flags, cb)

    function go$copyFile (src, dest, flags, cb, startTime) {
      return fs$copyFile(src, dest, flags, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  var noReaddirOptionVersions = /^v[0-5]\./
  function readdir (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    var go$readdir = noReaddirOptionVersions.test(process.version)
      ? function go$readdir (path, options, cb, startTime) {
        return fs$readdir(path, fs$readdirCallback(
          path, options, cb, startTime
        ))
      }
      : function go$readdir (path, options, cb, startTime) {
        return fs$readdir(path, options, fs$readdirCallback(
          path, options, cb, startTime
        ))
      }

    return go$readdir(path, options, cb)

    function fs$readdirCallback (path, options, cb, startTime) {
      return function (err, files) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([
            go$readdir,
            [path, options, cb],
            err,
            startTime || Date.now(),
            Date.now()
          ])
        else {
          if (files && files.sort)
            files.sort()

          if (typeof cb === 'function')
            cb.call(this, err, files)
        }
      }
    }
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype)
    ReadStream.prototype.open = ReadStream$open
  }

  var fs$WriteStream = fs.WriteStream
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype)
    WriteStream.prototype.open = WriteStream$open
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  // legacy names
  var FileReadStream = ReadStream
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  var FileWriteStream = WriteStream
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb, startTime) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  fs[gracefulQueue].push(elem)
  retry()
}

// keep track of the timeout between retry() calls
var retryTimer

// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue () {
  var now = Date.now()
  for (var i = 0; i < fs[gracefulQueue].length; ++i) {
    // entries that are only a length of 2 are from an older version, don't
    // bother modifying those since they'll be retried anyway.
    if (fs[gracefulQueue][i].length > 2) {
      fs[gracefulQueue][i][3] = now // startTime
      fs[gracefulQueue][i][4] = now // lastTime
    }
  }
  // call retry to make sure we're actively processing the queue
  retry()
}

function retry () {
  // clear the timer and remove it to help prevent unintended concurrency
  clearTimeout(retryTimer)
  retryTimer = undefined

  if (fs[gracefulQueue].length === 0)
    return

  var elem = fs[gracefulQueue].shift()
  var fn = elem[0]
  var args = elem[1]
  // these items may be unset if they were added by an older graceful-fs
  var err = elem[2]
  var startTime = elem[3]
  var lastTime = elem[4]

  // if we don't have a startTime we have no way of knowing if we've waited
  // long enough, so go ahead and retry this item now
  if (startTime === undefined) {
    debug('RETRY', fn.name, args)
    fn.apply(null, args)
  } else if (Date.now() - startTime >= 60000) {
    // it's been more than 60 seconds total, bail now
    debug('TIMEOUT', fn.name, args)
    var cb = args.pop()
    if (typeof cb === 'function')
      cb.call(null, err)
  } else {
    // the amount of time between the last attempt and right now
    var sinceAttempt = Date.now() - lastTime
    // the amount of time between when we first tried, and when we last tried
    // rounded up to at least 1
    var sinceStart = Math.max(lastTime - startTime, 1)
    // backoff. wait longer than the total time we've been retrying, but only
    // up to a maximum of 100ms
    var desiredDelay = Math.min(sinceStart * 1.2, 100)
    // it's been long enough since the last retry, do it again
    if (sinceAttempt >= desiredDelay) {
      debug('RETRY', fn.name, args)
      fn.apply(null, args.concat([startTime]))
    } else {
      // if we can't do this job yet, push it to the end of the queue
      // and let the next iteration check again
      fs[gracefulQueue].push(elem)
    }
  }

  // schedule our next run if one isn't already scheduled
  if (retryTimer === undefined) {
    retryTimer = setTimeout(retry, 0)
  }
}


/***/ }),

/***/ "./node_modules/graceful-fs/legacy-streams.js":
/*!****************************************************!*\
  !*** ./node_modules/graceful-fs/legacy-streams.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = (__webpack_require__(/*! stream */ "stream").Stream)

module.exports = legacy

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}


/***/ }),

/***/ "./node_modules/graceful-fs/polyfills.js":
/*!***********************************************!*\
  !*** ./node_modules/graceful-fs/polyfills.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constants = __webpack_require__(/*! constants */ "constants")

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
}
try {
  process.cwd()
} catch (er) {}

// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
  var chdir = process.chdir
  process.chdir = function (d) {
    cwd = null
    chdir.call(process, d)
  }
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)
}

module.exports = patch

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs)
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs)
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (fs.chmod && !fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchmodSync = function () {}
  }
  if (fs.chown && !fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchownSync = function () {}
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = typeof fs.rename !== 'function' ? fs.rename
    : (function (fs$rename) {
      function rename (from, to, cb) {
        var start = Date.now()
        var backoff = 0;
        fs$rename(from, to, function CB (er) {
          if (er
              && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY")
              && Date.now() - start < 60000) {
            setTimeout(function() {
              fs.stat(to, function (stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er)
              })
            }, backoff)
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb) cb(er)
        })
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename)
      return rename
    })(fs.rename)
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = typeof fs.read !== 'function' ? fs.read
  : (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)
    return read
  })(fs.read)

  fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync
  : (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          continue
        }
        throw er
      }
    }
  }})(fs.readSync)

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err)
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2)
          })
        })
      })
    }

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true
      var ret
      try {
        ret = fs.fchmodSync(fd, mode)
        threw = false
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd)
          } catch (er) {}
        } else {
          fs.closeSync(fd)
        }
      }
      return ret
    }
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er)
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2)
            })
          })
        })
      }

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK)
        var ret
        var threw = true
        try {
          ret = fs.futimesSync(fd, at, mt)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }

    } else if (fs.futimes) {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
      fs.lutimesSync = function () {}
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000
          if (stats.gid < 0) stats.gid += 0x100000000
        }
        if (cb) cb.apply(this, arguments)
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target)
      if (stats) {
        if (stats.uid < 0) stats.uid += 0x100000000
        if (stats.gid < 0) stats.gid += 0x100000000
      }
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}


/***/ }),

/***/ "./node_modules/has-flag/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-flag/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ "./node_modules/http-status-codes/build/es/status-codes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/http-status-codes/build/es/status-codes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StatusCodes: () => (/* binding */ StatusCodes)
/* harmony export */ });
// Generated file. Do not edit
var StatusCodes;
(function (StatusCodes) {
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.2.1
     *
     * This interim response indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.
     */
    StatusCodes[StatusCodes["CONTINUE"] = 100] = "CONTINUE";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.2.2
     *
     * This code is sent in response to an Upgrade request header by the client, and indicates the protocol the server is switching too.
     */
    StatusCodes[StatusCodes["SWITCHING_PROTOCOLS"] = 101] = "SWITCHING_PROTOCOLS";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.1
     *
     * This code indicates that the server has received and is processing the request, but no response is available yet.
     */
    StatusCodes[StatusCodes["PROCESSING"] = 102] = "PROCESSING";
    /**
     * Official Documentation @ https://www.rfc-editor.org/rfc/rfc8297#page-3
     *
     * This code indicates to the client that the server is likely to send a final response with the header fields included in the informational response.
     */
    StatusCodes[StatusCodes["EARLY_HINTS"] = 103] = "EARLY_HINTS";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.1
     *
     * The request has succeeded. The meaning of a success varies depending on the HTTP method:
     * GET: The resource has been fetched and is transmitted in the message body.
     * HEAD: The entity headers are in the message body.
     * POST: The resource describing the result of the action is transmitted in the message body.
     * TRACE: The message body contains the request message as received by the server
     */
    StatusCodes[StatusCodes["OK"] = 200] = "OK";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.2
     *
     * The request has succeeded and a new resource has been created as a result of it. This is typically the response sent after a PUT request.
     */
    StatusCodes[StatusCodes["CREATED"] = 201] = "CREATED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.3
     *
     * The request has been received but not yet acted upon. It is non-committal, meaning that there is no way in HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.
     */
    StatusCodes[StatusCodes["ACCEPTED"] = 202] = "ACCEPTED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.4
     *
     * This response code means returned meta-information set is not exact set as available from the origin server, but collected from a local or a third party copy. Except this condition, 200 OK response should be preferred instead of this response.
     */
    StatusCodes[StatusCodes["NON_AUTHORITATIVE_INFORMATION"] = 203] = "NON_AUTHORITATIVE_INFORMATION";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.5
     *
     * There is no content to send for this request, but the headers may be useful. The user-agent may update its cached headers for this resource with the new ones.
     */
    StatusCodes[StatusCodes["NO_CONTENT"] = 204] = "NO_CONTENT";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.6
     *
     * This response code is sent after accomplishing request to tell user agent reset document view which sent this request.
     */
    StatusCodes[StatusCodes["RESET_CONTENT"] = 205] = "RESET_CONTENT";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7233#section-4.1
     *
     * This response code is used because of range header sent by the client to separate download into multiple streams.
     */
    StatusCodes[StatusCodes["PARTIAL_CONTENT"] = 206] = "PARTIAL_CONTENT";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.2
     *
     * A Multi-Status response conveys information about multiple resources in situations where multiple status codes might be appropriate.
     */
    StatusCodes[StatusCodes["MULTI_STATUS"] = 207] = "MULTI_STATUS";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.1
     *
     * The request has more than one possible responses. User-agent or user should choose one of them. There is no standardized way to choose one of the responses.
     */
    StatusCodes[StatusCodes["MULTIPLE_CHOICES"] = 300] = "MULTIPLE_CHOICES";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.2
     *
     * This response code means that URI of requested resource has been changed. Probably, new URI would be given in the response.
     */
    StatusCodes[StatusCodes["MOVED_PERMANENTLY"] = 301] = "MOVED_PERMANENTLY";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.3
     *
     * This response code means that URI of requested resource has been changed temporarily. New changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.
     */
    StatusCodes[StatusCodes["MOVED_TEMPORARILY"] = 302] = "MOVED_TEMPORARILY";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.4
     *
     * Server sent this response to directing client to get requested resource to another URI with an GET request.
     */
    StatusCodes[StatusCodes["SEE_OTHER"] = 303] = "SEE_OTHER";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7232#section-4.1
     *
     * This is used for caching purposes. It is telling to client that response has not been modified. So, client can continue to use same cached version of response.
     */
    StatusCodes[StatusCodes["NOT_MODIFIED"] = 304] = "NOT_MODIFIED";
    /**
     * @deprecated
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.6
     *
     * Was defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.
     */
    StatusCodes[StatusCodes["USE_PROXY"] = 305] = "USE_PROXY";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.7
     *
     * Server sent this response to directing client to get requested resource to another URI with same method that used prior request. This has the same semantic than the 302 Found HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.
     */
    StatusCodes[StatusCodes["TEMPORARY_REDIRECT"] = 307] = "TEMPORARY_REDIRECT";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7538#section-3
     *
     * This means that the resource is now permanently located at another URI, specified by the Location: HTTP Response header. This has the same semantics as the 301 Moved Permanently HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.
     */
    StatusCodes[StatusCodes["PERMANENT_REDIRECT"] = 308] = "PERMANENT_REDIRECT";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.1
     *
     * This response means that server could not understand the request due to invalid syntax.
     */
    StatusCodes[StatusCodes["BAD_REQUEST"] = 400] = "BAD_REQUEST";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7235#section-3.1
     *
     * Although the HTTP standard specifies "unauthorized", semantically this response means "unauthenticated". That is, the client must authenticate itself to get the requested response.
     */
    StatusCodes[StatusCodes["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.2
     *
     * This response code is reserved for future use. Initial aim for creating this code was using it for digital payment systems however this is not used currently.
     */
    StatusCodes[StatusCodes["PAYMENT_REQUIRED"] = 402] = "PAYMENT_REQUIRED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.3
     *
     * The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.
     */
    StatusCodes[StatusCodes["FORBIDDEN"] = 403] = "FORBIDDEN";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.4
     *
     * The server can not find requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurence on the web.
     */
    StatusCodes[StatusCodes["NOT_FOUND"] = 404] = "NOT_FOUND";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.5
     *
     * The request method is known by the server but has been disabled and cannot be used. For example, an API may forbid DELETE-ing a resource. The two mandatory methods, GET and HEAD, must never be disabled and should not return this error code.
     */
    StatusCodes[StatusCodes["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.6
     *
     * This response is sent when the web server, after performing server-driven content negotiation, doesn't find any content following the criteria given by the user agent.
     */
    StatusCodes[StatusCodes["NOT_ACCEPTABLE"] = 406] = "NOT_ACCEPTABLE";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7235#section-3.2
     *
     * This is similar to 401 but authentication is needed to be done by a proxy.
     */
    StatusCodes[StatusCodes["PROXY_AUTHENTICATION_REQUIRED"] = 407] = "PROXY_AUTHENTICATION_REQUIRED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.7
     *
     * This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message.
     */
    StatusCodes[StatusCodes["REQUEST_TIMEOUT"] = 408] = "REQUEST_TIMEOUT";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.8
     *
     * This response is sent when a request conflicts with the current state of the server.
     */
    StatusCodes[StatusCodes["CONFLICT"] = 409] = "CONFLICT";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.9
     *
     * This response would be sent when the requested content has been permenantly deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for "limited-time, promotional services". APIs should not feel compelled to indicate resources that have been deleted with this status code.
     */
    StatusCodes[StatusCodes["GONE"] = 410] = "GONE";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.10
     *
     * The server rejected the request because the Content-Length header field is not defined and the server requires it.
     */
    StatusCodes[StatusCodes["LENGTH_REQUIRED"] = 411] = "LENGTH_REQUIRED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7232#section-4.2
     *
     * The client has indicated preconditions in its headers which the server does not meet.
     */
    StatusCodes[StatusCodes["PRECONDITION_FAILED"] = 412] = "PRECONDITION_FAILED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.11
     *
     * Request entity is larger than limits defined by server; the server might close the connection or return an Retry-After header field.
     */
    StatusCodes[StatusCodes["REQUEST_TOO_LONG"] = 413] = "REQUEST_TOO_LONG";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.12
     *
     * The URI requested by the client is longer than the server is willing to interpret.
     */
    StatusCodes[StatusCodes["REQUEST_URI_TOO_LONG"] = 414] = "REQUEST_URI_TOO_LONG";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.13
     *
     * The media format of the requested data is not supported by the server, so the server is rejecting the request.
     */
    StatusCodes[StatusCodes["UNSUPPORTED_MEDIA_TYPE"] = 415] = "UNSUPPORTED_MEDIA_TYPE";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7233#section-4.4
     *
     * The range specified by the Range header field in the request can't be fulfilled; it's possible that the range is outside the size of the target URI's data.
     */
    StatusCodes[StatusCodes["REQUESTED_RANGE_NOT_SATISFIABLE"] = 416] = "REQUESTED_RANGE_NOT_SATISFIABLE";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.14
     *
     * This response code means the expectation indicated by the Expect request header field can't be met by the server.
     */
    StatusCodes[StatusCodes["EXPECTATION_FAILED"] = 417] = "EXPECTATION_FAILED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2324#section-2.3.2
     *
     * Any attempt to brew coffee with a teapot should result in the error code "418 I'm a teapot". The resulting entity body MAY be short and stout.
     */
    StatusCodes[StatusCodes["IM_A_TEAPOT"] = 418] = "IM_A_TEAPOT";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.6
     *
     * The 507 (Insufficient Storage) status code means the method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request. This condition is considered to be temporary. If the request which received this status code was the result of a user action, the request MUST NOT be repeated until it is requested by a separate user action.
     */
    StatusCodes[StatusCodes["INSUFFICIENT_SPACE_ON_RESOURCE"] = 419] = "INSUFFICIENT_SPACE_ON_RESOURCE";
    /**
     * @deprecated
     * Official Documentation @ https://tools.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-webdav-protocol-06.txt
     *
     * A deprecated response used by the Spring Framework when a method has failed.
     */
    StatusCodes[StatusCodes["METHOD_FAILURE"] = 420] = "METHOD_FAILURE";
    /**
     * Official Documentation @ https://datatracker.ietf.org/doc/html/rfc7540#section-9.1.2
     *
     * Defined in the specification of HTTP/2 to indicate that a server is not able to produce a response for the combination of scheme and authority that are included in the request URI.
     */
    StatusCodes[StatusCodes["MISDIRECTED_REQUEST"] = 421] = "MISDIRECTED_REQUEST";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.3
     *
     * The request was well-formed but was unable to be followed due to semantic errors.
     */
    StatusCodes[StatusCodes["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.4
     *
     * The resource that is being accessed is locked.
     */
    StatusCodes[StatusCodes["LOCKED"] = 423] = "LOCKED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.5
     *
     * The request failed due to failure of a previous request.
     */
    StatusCodes[StatusCodes["FAILED_DEPENDENCY"] = 424] = "FAILED_DEPENDENCY";
    /**
     * Official Documentation @ https://datatracker.ietf.org/doc/html/rfc7231#section-6.5.15
     *
     * The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.
     */
    StatusCodes[StatusCodes["UPGRADE_REQUIRED"] = 426] = "UPGRADE_REQUIRED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-3
     *
     * The origin server requires the request to be conditional. Intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.
     */
    StatusCodes[StatusCodes["PRECONDITION_REQUIRED"] = 428] = "PRECONDITION_REQUIRED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-4
     *
     * The user has sent too many requests in a given amount of time ("rate limiting").
     */
    StatusCodes[StatusCodes["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-5
     *
     * The server is unwilling to process the request because its header fields are too large. The request MAY be resubmitted after reducing the size of the request header fields.
     */
    StatusCodes[StatusCodes["REQUEST_HEADER_FIELDS_TOO_LARGE"] = 431] = "REQUEST_HEADER_FIELDS_TOO_LARGE";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7725
     *
     * The user-agent requested a resource that cannot legally be provided, such as a web page censored by a government.
     */
    StatusCodes[StatusCodes["UNAVAILABLE_FOR_LEGAL_REASONS"] = 451] = "UNAVAILABLE_FOR_LEGAL_REASONS";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.1
     *
     * The server encountered an unexpected condition that prevented it from fulfilling the request.
     */
    StatusCodes[StatusCodes["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.2
     *
     * The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are GET and HEAD.
     */
    StatusCodes[StatusCodes["NOT_IMPLEMENTED"] = 501] = "NOT_IMPLEMENTED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.3
     *
     * This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.
     */
    StatusCodes[StatusCodes["BAD_GATEWAY"] = 502] = "BAD_GATEWAY";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.4
     *
     * The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This responses should be used for temporary conditions and the Retry-After: HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.
     */
    StatusCodes[StatusCodes["SERVICE_UNAVAILABLE"] = 503] = "SERVICE_UNAVAILABLE";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.5
     *
     * This error response is given when the server is acting as a gateway and cannot get a response in time.
     */
    StatusCodes[StatusCodes["GATEWAY_TIMEOUT"] = 504] = "GATEWAY_TIMEOUT";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.6
     *
     * The HTTP version used in the request is not supported by the server.
     */
    StatusCodes[StatusCodes["HTTP_VERSION_NOT_SUPPORTED"] = 505] = "HTTP_VERSION_NOT_SUPPORTED";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.6
     *
     * The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.
     */
    StatusCodes[StatusCodes["INSUFFICIENT_STORAGE"] = 507] = "INSUFFICIENT_STORAGE";
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-6
     *
     * The 511 status code indicates that the client needs to authenticate to gain network access.
     */
    StatusCodes[StatusCodes["NETWORK_AUTHENTICATION_REQUIRED"] = 511] = "NETWORK_AUTHENTICATION_REQUIRED";
})(StatusCodes || (StatusCodes = {}));


/***/ }),

/***/ "./node_modules/imurmurhash/imurmurhash.js":
/*!*************************************************!*\
  !*** ./node_modules/imurmurhash/imurmurhash.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * @preserve
 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
 *
 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
 * @see http://github.com/homebrewing/brauhaus-diff
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 */
(function(){
    var cache;

    // Call this function without `new` to use the cached object (good for
    // single-threaded environments), or with `new` to create a new object.
    //
    // @param {string} key A UTF-16 or ASCII string
    // @param {number} seed An optional positive integer
    // @return {object} A MurmurHash3 object for incremental hashing
    function MurmurHash3(key, seed) {
        var m = this instanceof MurmurHash3 ? this : cache;
        m.reset(seed)
        if (typeof key === 'string' && key.length > 0) {
            m.hash(key);
        }

        if (m !== this) {
            return m;
        }
    };

    // Incrementally add a string to this hash
    //
    // @param {string} key A UTF-16 or ASCII string
    // @return {object} this
    MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;

        len = key.length;
        this.len += len;

        k1 = this.k1;
        i = 0;
        switch (this.rem) {
            case 0: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) : 0;
            case 1: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 8 : 0;
            case 2: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 16 : 0;
            case 3:
                k1 ^= len > i ? (key.charCodeAt(i) & 0xff) << 24 : 0;
                k1 ^= len > i ? (key.charCodeAt(i++) & 0xff00) >> 8 : 0;
        }

        this.rem = (len + this.rem) & 3; // & 3 is same as % 4
        len -= this.rem;
        if (len > 0) {
            h1 = this.h1;
            while (1) {
                k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;
                k1 = (k1 << 15) | (k1 >>> 17);
                k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;

                h1 ^= k1;
                h1 = (h1 << 13) | (h1 >>> 19);
                h1 = (h1 * 5 + 0xe6546b64) & 0xffffffff;

                if (i >= len) {
                    break;
                }

                k1 = ((key.charCodeAt(i++) & 0xffff)) ^
                     ((key.charCodeAt(i++) & 0xffff) << 8) ^
                     ((key.charCodeAt(i++) & 0xffff) << 16);
                top = key.charCodeAt(i++);
                k1 ^= ((top & 0xff) << 24) ^
                      ((top & 0xff00) >> 8);
            }

            k1 = 0;
            switch (this.rem) {
                case 3: k1 ^= (key.charCodeAt(i + 2) & 0xffff) << 16;
                case 2: k1 ^= (key.charCodeAt(i + 1) & 0xffff) << 8;
                case 1: k1 ^= (key.charCodeAt(i) & 0xffff);
            }

            this.h1 = h1;
        }

        this.k1 = k1;
        return this;
    };

    // Get the result of this hash
    //
    // @return {number} The 32-bit hash
    MurmurHash3.prototype.result = function() {
        var k1, h1;
        
        k1 = this.k1;
        h1 = this.h1;

        if (k1 > 0) {
            k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;
            k1 = (k1 << 15) | (k1 >>> 17);
            k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;
            h1 ^= k1;
        }

        h1 ^= this.len;

        h1 ^= h1 >>> 16;
        h1 = (h1 * 0xca6b + (h1 & 0xffff) * 0x85eb0000) & 0xffffffff;
        h1 ^= h1 >>> 13;
        h1 = (h1 * 0xae35 + (h1 & 0xffff) * 0xc2b20000) & 0xffffffff;
        h1 ^= h1 >>> 16;

        return h1 >>> 0;
    };

    // Reset the hash object for reuse
    //
    // @param {number} seed An optional positive integer
    MurmurHash3.prototype.reset = function(seed) {
        this.h1 = typeof seed === 'number' ? seed : 0;
        this.rem = this.k1 = this.len = 0;
        return this;
    };

    // A cached object to use. This can be safely used if you're in a single-
    // threaded environment, otherwise you need to create new hashes to use.
    cache = new MurmurHash3();

    if (true) {
        module.exports = MurmurHash3;
    } else {}
}());


/***/ }),

/***/ "./node_modules/json-rpc-2.0/dist/client.js":
/*!**************************************************!*\
  !*** ./node_modules/json-rpc-2.0/dist/client.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JSONRPCClient = void 0;
var models_1 = __webpack_require__(/*! ./models */ "./node_modules/json-rpc-2.0/dist/models.js");
var internal_1 = __webpack_require__(/*! ./internal */ "./node_modules/json-rpc-2.0/dist/internal.js");
var JSONRPCClient = /** @class */ (function () {
    function JSONRPCClient(_send, createID) {
        this._send = _send;
        this.createID = createID;
        this.idToResolveMap = new Map();
        this.id = 0;
    }
    JSONRPCClient.prototype._createID = function () {
        if (this.createID) {
            return this.createID();
        }
        else {
            return ++this.id;
        }
    };
    JSONRPCClient.prototype.timeout = function (delay, overrideCreateJSONRPCErrorResponse) {
        var _this = this;
        if (overrideCreateJSONRPCErrorResponse === void 0) { overrideCreateJSONRPCErrorResponse = function (id) {
            return (0, models_1.createJSONRPCErrorResponse)(id, internal_1.DefaultErrorCode, "Request timeout");
        }; }
        var timeoutRequest = function (ids, request) {
            var timeoutID = setTimeout(function () {
                ids.forEach(function (id) {
                    var resolve = _this.idToResolveMap.get(id);
                    if (resolve) {
                        _this.idToResolveMap.delete(id);
                        resolve(overrideCreateJSONRPCErrorResponse(id));
                    }
                });
            }, delay);
            return request().then(function (result) {
                clearTimeout(timeoutID);
                return result;
            }, function (error) {
                clearTimeout(timeoutID);
                return Promise.reject(error);
            });
        };
        var requestAdvanced = function (request, clientParams) {
            var ids = (!Array.isArray(request) ? [request] : request)
                .map(function (request) { return request.id; })
                .filter(isDefinedAndNonNull);
            return timeoutRequest(ids, function () {
                return _this.requestAdvanced(request, clientParams);
            });
        };
        return {
            request: function (method, params, clientParams) {
                var id = _this._createID();
                return timeoutRequest([id], function () {
                    return _this.requestWithID(method, params, clientParams, id);
                });
            },
            requestAdvanced: function (request, clientParams) { return requestAdvanced(request, clientParams); },
        };
    };
    JSONRPCClient.prototype.request = function (method, params, clientParams) {
        return this.requestWithID(method, params, clientParams, this._createID());
    };
    JSONRPCClient.prototype.requestWithID = function (method, params, clientParams, id) {
        return __awaiter(this, void 0, void 0, function () {
            var request, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        request = (0, models_1.createJSONRPCRequest)(id, method, params);
                        return [4 /*yield*/, this.requestAdvanced(request, clientParams)];
                    case 1:
                        response = _a.sent();
                        if (response.result !== undefined && !response.error) {
                            return [2 /*return*/, response.result];
                        }
                        else if (response.result === undefined && response.error) {
                            return [2 /*return*/, Promise.reject(new models_1.JSONRPCErrorException(response.error.message, response.error.code, response.error.data))];
                        }
                        else {
                            return [2 /*return*/, Promise.reject(new Error("An unexpected error occurred"))];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    JSONRPCClient.prototype.requestAdvanced = function (requests, clientParams) {
        var _this = this;
        var areRequestsOriginallyArray = Array.isArray(requests);
        if (!Array.isArray(requests)) {
            requests = [requests];
        }
        var requestsWithID = requests.filter(function (request) {
            return isDefinedAndNonNull(request.id);
        });
        var promises = requestsWithID.map(function (request) {
            return new Promise(function (resolve) { return _this.idToResolveMap.set(request.id, resolve); });
        });
        var promise = Promise.all(promises).then(function (responses) {
            if (areRequestsOriginallyArray || !responses.length) {
                return responses;
            }
            else {
                return responses[0];
            }
        });
        return this.send(areRequestsOriginallyArray ? requests : requests[0], clientParams).then(function () { return promise; }, function (error) {
            requestsWithID.forEach(function (request) {
                _this.receive((0, models_1.createJSONRPCErrorResponse)(request.id, internal_1.DefaultErrorCode, (error && error.message) || "Failed to send a request"));
            });
            return promise;
        });
    };
    JSONRPCClient.prototype.notify = function (method, params, clientParams) {
        var request = (0, models_1.createJSONRPCNotification)(method, params);
        this.send(request, clientParams).then(undefined, function () { return undefined; });
    };
    JSONRPCClient.prototype.send = function (payload, clientParams) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._send(payload, clientParams)];
            });
        });
    };
    JSONRPCClient.prototype.rejectAllPendingRequests = function (message) {
        this.idToResolveMap.forEach(function (resolve, id) {
            return resolve((0, models_1.createJSONRPCErrorResponse)(id, internal_1.DefaultErrorCode, message));
        });
        this.idToResolveMap.clear();
    };
    JSONRPCClient.prototype.receive = function (responses) {
        var _this = this;
        if (!Array.isArray(responses)) {
            responses = [responses];
        }
        responses.forEach(function (response) {
            var resolve = _this.idToResolveMap.get(response.id);
            if (resolve) {
                _this.idToResolveMap.delete(response.id);
                resolve(response);
            }
        });
    };
    return JSONRPCClient;
}());
exports.JSONRPCClient = JSONRPCClient;
var isDefinedAndNonNull = function (value) {
    return value !== undefined && value !== null;
};


/***/ }),

/***/ "./node_modules/json-rpc-2.0/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/json-rpc-2.0/dist/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./client */ "./node_modules/json-rpc-2.0/dist/client.js"), exports);
__exportStar(__webpack_require__(/*! ./interfaces */ "./node_modules/json-rpc-2.0/dist/interfaces.js"), exports);
__exportStar(__webpack_require__(/*! ./models */ "./node_modules/json-rpc-2.0/dist/models.js"), exports);
__exportStar(__webpack_require__(/*! ./server */ "./node_modules/json-rpc-2.0/dist/server.js"), exports);
__exportStar(__webpack_require__(/*! ./server-and-client */ "./node_modules/json-rpc-2.0/dist/server-and-client.js"), exports);


/***/ }),

/***/ "./node_modules/json-rpc-2.0/dist/interfaces.js":
/*!******************************************************!*\
  !*** ./node_modules/json-rpc-2.0/dist/interfaces.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/json-rpc-2.0/dist/internal.js":
/*!****************************************************!*\
  !*** ./node_modules/json-rpc-2.0/dist/internal.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultErrorCode = void 0;
exports.DefaultErrorCode = 0;


/***/ }),

/***/ "./node_modules/json-rpc-2.0/dist/models.js":
/*!**************************************************!*\
  !*** ./node_modules/json-rpc-2.0/dist/models.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createJSONRPCNotification = exports.createJSONRPCRequest = exports.createJSONRPCSuccessResponse = exports.createJSONRPCErrorResponse = exports.JSONRPCErrorCode = exports.JSONRPCErrorException = exports.isJSONRPCResponses = exports.isJSONRPCResponse = exports.isJSONRPCRequests = exports.isJSONRPCRequest = exports.isJSONRPCID = exports.JSONRPC = void 0;
exports.JSONRPC = "2.0";
var isJSONRPCID = function (id) {
    return typeof id === "string" || typeof id === "number" || id === null;
};
exports.isJSONRPCID = isJSONRPCID;
var isJSONRPCRequest = function (payload) {
    return (payload.jsonrpc === exports.JSONRPC &&
        payload.method !== undefined &&
        payload.result === undefined &&
        payload.error === undefined);
};
exports.isJSONRPCRequest = isJSONRPCRequest;
var isJSONRPCRequests = function (payload) {
    return Array.isArray(payload) && payload.every(exports.isJSONRPCRequest);
};
exports.isJSONRPCRequests = isJSONRPCRequests;
var isJSONRPCResponse = function (payload) {
    return (payload.jsonrpc === exports.JSONRPC &&
        payload.id !== undefined &&
        (payload.result !== undefined || payload.error !== undefined));
};
exports.isJSONRPCResponse = isJSONRPCResponse;
var isJSONRPCResponses = function (payload) {
    return Array.isArray(payload) && payload.every(exports.isJSONRPCResponse);
};
exports.isJSONRPCResponses = isJSONRPCResponses;
var createJSONRPCError = function (code, message, data) {
    var error = { code: code, message: message };
    if (data != null) {
        error.data = data;
    }
    return error;
};
var JSONRPCErrorException = /** @class */ (function (_super) {
    __extends(JSONRPCErrorException, _super);
    function JSONRPCErrorException(message, code, data) {
        var _this = _super.call(this, message) || this;
        // Manually set the prototype to fix TypeScript issue:
        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, JSONRPCErrorException.prototype);
        _this.code = code;
        _this.data = data;
        return _this;
    }
    JSONRPCErrorException.prototype.toObject = function () {
        return createJSONRPCError(this.code, this.message, this.data);
    };
    return JSONRPCErrorException;
}(Error));
exports.JSONRPCErrorException = JSONRPCErrorException;
var JSONRPCErrorCode;
(function (JSONRPCErrorCode) {
    JSONRPCErrorCode[JSONRPCErrorCode["ParseError"] = -32700] = "ParseError";
    JSONRPCErrorCode[JSONRPCErrorCode["InvalidRequest"] = -32600] = "InvalidRequest";
    JSONRPCErrorCode[JSONRPCErrorCode["MethodNotFound"] = -32601] = "MethodNotFound";
    JSONRPCErrorCode[JSONRPCErrorCode["InvalidParams"] = -32602] = "InvalidParams";
    JSONRPCErrorCode[JSONRPCErrorCode["InternalError"] = -32603] = "InternalError";
})(JSONRPCErrorCode = exports.JSONRPCErrorCode || (exports.JSONRPCErrorCode = {}));
var createJSONRPCErrorResponse = function (id, code, message, data) {
    return {
        jsonrpc: exports.JSONRPC,
        id: id,
        error: createJSONRPCError(code, message, data),
    };
};
exports.createJSONRPCErrorResponse = createJSONRPCErrorResponse;
var createJSONRPCSuccessResponse = function (id, result) {
    return {
        jsonrpc: exports.JSONRPC,
        id: id,
        result: result !== null && result !== void 0 ? result : null,
    };
};
exports.createJSONRPCSuccessResponse = createJSONRPCSuccessResponse;
var createJSONRPCRequest = function (id, method, params) {
    return {
        jsonrpc: exports.JSONRPC,
        id: id,
        method: method,
        params: params,
    };
};
exports.createJSONRPCRequest = createJSONRPCRequest;
var createJSONRPCNotification = function (method, params) {
    return {
        jsonrpc: exports.JSONRPC,
        method: method,
        params: params,
    };
};
exports.createJSONRPCNotification = createJSONRPCNotification;


/***/ }),

/***/ "./node_modules/json-rpc-2.0/dist/server-and-client.js":
/*!*************************************************************!*\
  !*** ./node_modules/json-rpc-2.0/dist/server-and-client.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JSONRPCServerAndClient = void 0;
var models_1 = __webpack_require__(/*! ./models */ "./node_modules/json-rpc-2.0/dist/models.js");
var JSONRPCServerAndClient = /** @class */ (function () {
    function JSONRPCServerAndClient(server, client, options) {
        if (options === void 0) { options = {}; }
        var _a;
        this.server = server;
        this.client = client;
        this.errorListener = (_a = options.errorListener) !== null && _a !== void 0 ? _a : console.warn;
    }
    JSONRPCServerAndClient.prototype.applyServerMiddleware = function () {
        var _a;
        var middlewares = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
        }
        (_a = this.server).applyMiddleware.apply(_a, middlewares);
    };
    JSONRPCServerAndClient.prototype.hasMethod = function (name) {
        return this.server.hasMethod(name);
    };
    JSONRPCServerAndClient.prototype.addMethod = function (name, method) {
        this.server.addMethod(name, method);
    };
    JSONRPCServerAndClient.prototype.addMethodAdvanced = function (name, method) {
        this.server.addMethodAdvanced(name, method);
    };
    JSONRPCServerAndClient.prototype.removeMethod = function (name) {
        this.server.removeMethod(name);
    };
    JSONRPCServerAndClient.prototype.timeout = function (delay) {
        return this.client.timeout(delay);
    };
    JSONRPCServerAndClient.prototype.request = function (method, params, clientParams) {
        return this.client.request(method, params, clientParams);
    };
    JSONRPCServerAndClient.prototype.requestAdvanced = function (jsonRPCRequest, clientParams) {
        return this.client.requestAdvanced(jsonRPCRequest, clientParams);
    };
    JSONRPCServerAndClient.prototype.notify = function (method, params, clientParams) {
        this.client.notify(method, params, clientParams);
    };
    JSONRPCServerAndClient.prototype.rejectAllPendingRequests = function (message) {
        this.client.rejectAllPendingRequests(message);
    };
    JSONRPCServerAndClient.prototype.receiveAndSend = function (payload, serverParams, clientParams) {
        return __awaiter(this, void 0, void 0, function () {
            var response, message;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!((0, models_1.isJSONRPCResponse)(payload) || (0, models_1.isJSONRPCResponses)(payload))) return [3 /*break*/, 1];
                        this.client.receive(payload);
                        return [3 /*break*/, 4];
                    case 1:
                        if (!((0, models_1.isJSONRPCRequest)(payload) || (0, models_1.isJSONRPCRequests)(payload))) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.server.receive(payload, serverParams)];
                    case 2:
                        response = _a.sent();
                        if (response) {
                            return [2 /*return*/, this.client.send(response, clientParams)];
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        message = "Received an invalid JSON-RPC message";
                        this.errorListener(message, payload);
                        return [2 /*return*/, Promise.reject(new Error(message))];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    return JSONRPCServerAndClient;
}());
exports.JSONRPCServerAndClient = JSONRPCServerAndClient;


/***/ }),

/***/ "./node_modules/json-rpc-2.0/dist/server.js":
/*!**************************************************!*\
  !*** ./node_modules/json-rpc-2.0/dist/server.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JSONRPCServer = void 0;
var models_1 = __webpack_require__(/*! ./models */ "./node_modules/json-rpc-2.0/dist/models.js");
var internal_1 = __webpack_require__(/*! ./internal */ "./node_modules/json-rpc-2.0/dist/internal.js");
var createParseErrorResponse = function () {
    return (0, models_1.createJSONRPCErrorResponse)(null, models_1.JSONRPCErrorCode.ParseError, "Parse error");
};
var createInvalidRequestResponse = function (request) {
    return (0, models_1.createJSONRPCErrorResponse)((0, models_1.isJSONRPCID)(request.id) ? request.id : null, models_1.JSONRPCErrorCode.InvalidRequest, "Invalid Request");
};
var createMethodNotFoundResponse = function (id) {
    return (0, models_1.createJSONRPCErrorResponse)(id, models_1.JSONRPCErrorCode.MethodNotFound, "Method not found");
};
var JSONRPCServer = /** @class */ (function () {
    function JSONRPCServer(options) {
        if (options === void 0) { options = {}; }
        var _a;
        this.mapErrorToJSONRPCErrorResponse = defaultMapErrorToJSONRPCErrorResponse;
        this.nameToMethodDictionary = {};
        this.middleware = null;
        this.errorListener = (_a = options.errorListener) !== null && _a !== void 0 ? _a : console.warn;
    }
    JSONRPCServer.prototype.hasMethod = function (name) {
        return !!this.nameToMethodDictionary[name];
    };
    JSONRPCServer.prototype.addMethod = function (name, method) {
        this.addMethodAdvanced(name, this.toJSONRPCMethod(method));
    };
    JSONRPCServer.prototype.removeMethod = function (name) {
        delete this.nameToMethodDictionary[name];
    };
    JSONRPCServer.prototype.toJSONRPCMethod = function (method) {
        return function (request, serverParams) {
            var response = method(request.params, serverParams);
            return Promise.resolve(response).then(function (result) {
                return mapResultToJSONRPCResponse(request.id, result);
            });
        };
    };
    JSONRPCServer.prototype.addMethodAdvanced = function (name, method) {
        var _a;
        this.nameToMethodDictionary = __assign(__assign({}, this.nameToMethodDictionary), (_a = {}, _a[name] = method, _a));
    };
    JSONRPCServer.prototype.receiveJSON = function (json, serverParams) {
        var request = this.tryParseRequestJSON(json);
        if (request) {
            return this.receive(request, serverParams);
        }
        else {
            return Promise.resolve(createParseErrorResponse());
        }
    };
    JSONRPCServer.prototype.tryParseRequestJSON = function (json) {
        try {
            return JSON.parse(json);
        }
        catch (_a) {
            return null;
        }
    };
    JSONRPCServer.prototype.receive = function (request, serverParams) {
        if (Array.isArray(request)) {
            return this.receiveMultiple(request, serverParams);
        }
        else {
            return this.receiveSingle(request, serverParams);
        }
    };
    JSONRPCServer.prototype.receiveMultiple = function (requests, serverParams) {
        return __awaiter(this, void 0, void 0, function () {
            var responses;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(requests.map(function (request) { return _this.receiveSingle(request, serverParams); }))];
                    case 1:
                        responses = (_a.sent()).filter(isNonNull);
                        if (responses.length === 1) {
                            return [2 /*return*/, responses[0]];
                        }
                        else if (responses.length) {
                            return [2 /*return*/, responses];
                        }
                        else {
                            return [2 /*return*/, null];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    JSONRPCServer.prototype.receiveSingle = function (request, serverParams) {
        return __awaiter(this, void 0, void 0, function () {
            var method, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = this.nameToMethodDictionary[request.method];
                        if (!!(0, models_1.isJSONRPCRequest)(request)) return [3 /*break*/, 1];
                        return [2 /*return*/, createInvalidRequestResponse(request)];
                    case 1: return [4 /*yield*/, this.callMethod(method, request, serverParams)];
                    case 2:
                        response = _a.sent();
                        return [2 /*return*/, mapResponse(request, response)];
                }
            });
        });
    };
    JSONRPCServer.prototype.applyMiddleware = function () {
        var middlewares = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
        }
        if (this.middleware) {
            this.middleware = this.combineMiddlewares(__spreadArray([
                this.middleware
            ], middlewares, true));
        }
        else {
            this.middleware = this.combineMiddlewares(middlewares);
        }
    };
    JSONRPCServer.prototype.combineMiddlewares = function (middlewares) {
        if (!middlewares.length) {
            return null;
        }
        else {
            return middlewares.reduce(this.middlewareReducer);
        }
    };
    JSONRPCServer.prototype.middlewareReducer = function (prevMiddleware, nextMiddleware) {
        return function (next, request, serverParams) {
            return prevMiddleware(function (request, serverParams) { return nextMiddleware(next, request, serverParams); }, request, serverParams);
        };
    };
    JSONRPCServer.prototype.callMethod = function (method, request, serverParams) {
        var _this = this;
        var callMethod = function (request, serverParams) {
            if (method) {
                return method(request, serverParams);
            }
            else if (request.id !== undefined) {
                return Promise.resolve(createMethodNotFoundResponse(request.id));
            }
            else {
                return Promise.resolve(null);
            }
        };
        var onError = function (error) {
            _this.errorListener("An unexpected error occurred while executing \"".concat(request.method, "\" JSON-RPC method:"), error);
            return Promise.resolve(_this.mapErrorToJSONRPCErrorResponseIfNecessary(request.id, error));
        };
        try {
            return (this.middleware || noopMiddleware)(callMethod, request, serverParams).then(undefined, onError);
        }
        catch (error) {
            return onError(error);
        }
    };
    JSONRPCServer.prototype.mapErrorToJSONRPCErrorResponseIfNecessary = function (id, error) {
        if (id !== undefined) {
            return this.mapErrorToJSONRPCErrorResponse(id, error);
        }
        else {
            return null;
        }
    };
    return JSONRPCServer;
}());
exports.JSONRPCServer = JSONRPCServer;
var isNonNull = function (value) { return value !== null; };
var noopMiddleware = function (next, request, serverParams) { return next(request, serverParams); };
var mapResultToJSONRPCResponse = function (id, result) {
    if (id !== undefined) {
        return (0, models_1.createJSONRPCSuccessResponse)(id, result);
    }
    else {
        return null;
    }
};
var defaultMapErrorToJSONRPCErrorResponse = function (id, error) {
    var _a;
    var message = (_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : "An unexpected error occurred";
    var code = internal_1.DefaultErrorCode;
    var data;
    if (error instanceof models_1.JSONRPCErrorException) {
        code = error.code;
        data = error.data;
    }
    return (0, models_1.createJSONRPCErrorResponse)(id, code, message, data);
};
var mapResponse = function (request, response) {
    if (response) {
        return response;
    }
    else if (request.id !== undefined) {
        return (0, models_1.createJSONRPCErrorResponse)(request.id, models_1.JSONRPCErrorCode.InternalError, "Internal error");
    }
    else {
        return null;
    }
};


/***/ }),

/***/ "./node_modules/jsonfile/index.js":
/*!****************************************!*\
  !*** ./node_modules/jsonfile/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _fs
try {
  _fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
} catch (_) {
  _fs = __webpack_require__(/*! fs */ "fs")
}

function readFile (file, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }

  if (typeof options === 'string') {
    options = {encoding: options}
  }

  options = options || {}
  var fs = options.fs || _fs

  var shouldThrow = true
  if ('throws' in options) {
    shouldThrow = options.throws
  }

  fs.readFile(file, options, function (err, data) {
    if (err) return callback(err)

    data = stripBom(data)

    var obj
    try {
      obj = JSON.parse(data, options ? options.reviver : null)
    } catch (err2) {
      if (shouldThrow) {
        err2.message = file + ': ' + err2.message
        return callback(err2)
      } else {
        return callback(null, null)
      }
    }

    callback(null, obj)
  })
}

function readFileSync (file, options) {
  options = options || {}
  if (typeof options === 'string') {
    options = {encoding: options}
  }

  var fs = options.fs || _fs

  var shouldThrow = true
  if ('throws' in options) {
    shouldThrow = options.throws
  }

  try {
    var content = fs.readFileSync(file, options)
    content = stripBom(content)
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = file + ': ' + err.message
      throw err
    } else {
      return null
    }
  }
}

function stringify (obj, options) {
  var spaces
  var EOL = '\n'
  if (typeof options === 'object' && options !== null) {
    if (options.spaces) {
      spaces = options.spaces
    }
    if (options.EOL) {
      EOL = options.EOL
    }
  }

  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)

  return str.replace(/\n/g, EOL) + EOL
}

function writeFile (file, obj, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }
  options = options || {}
  var fs = options.fs || _fs

  var str = ''
  try {
    str = stringify(obj, options)
  } catch (err) {
    // Need to return whether a callback was passed or not
    if (callback) callback(err, null)
    return
  }

  fs.writeFile(file, str, options, callback)
}

function writeFileSync (file, obj, options) {
  options = options || {}
  var fs = options.fs || _fs

  var str = stringify(obj, options)
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}

function stripBom (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8')
  content = content.replace(/^\uFEFF/, '')
  return content
}

var jsonfile = {
  readFile: readFile,
  readFileSync: readFileSync,
  writeFile: writeFile,
  writeFileSync: writeFileSync
}

module.exports = jsonfile


/***/ }),

/***/ "./node_modules/memoize-one/dist/memoize-one.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/memoize-one/dist/memoize-one.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ memoizeOne)
/* harmony export */ });
var safeIsNaN = Number.isNaN ||
    function ponyfill(value) {
        return typeof value === 'number' && value !== value;
    };
function isEqual(first, second) {
    if (first === second) {
        return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
        return true;
    }
    return false;
}
function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (!isEqual(newInputs[i], lastInputs[i])) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var cache = null;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {
            return cache.lastResult;
        }
        var lastResult = resultFn.apply(this, newArgs);
        cache = {
            lastResult: lastResult,
            lastArgs: newArgs,
            lastThis: this,
        };
        return lastResult;
    }
    memoized.clear = function clear() {
        cache = null;
    };
    return memoized;
}




/***/ }),

/***/ "./node_modules/mkdirp/index.js":
/*!**************************************!*\
  !*** ./node_modules/mkdirp/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(/*! path */ "path");
var fs = __webpack_require__(/*! fs */ "fs");
var _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777
    }
    if (!made) made = null;
    
    var cb = f || /* istanbul ignore next */ function () {};
    p = path.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                /* istanbul ignore if */
                if (path.dirname(p) === p) return cb(er);
                mkdirP(path.dirname(p), opts, function (er, made) {
                    /* istanbul ignore if */
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) /* istanbul ignore next */ {
                    throw err0;
                }
                /* istanbul ignore if */
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};


/***/ }),

/***/ "./node_modules/node-localstorage/LocalStorage.js":
/*!********************************************************!*\
  !*** ./node_modules/node-localstorage/LocalStorage.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 2.7.0
(function() {
  var JSONStorage, KEY_FOR_EMPTY_STRING, LocalStorage, MetaKey, QUOTA_EXCEEDED_ERR, StorageEvent, _emptyDirectory, _escapeKey, _rm, createMap, events, fs, path, writeSync;

  path = __webpack_require__(/*! path */ "path");

  fs = __webpack_require__(/*! fs */ "fs");

  events = __webpack_require__(/*! events */ "events");

  writeSync = (__webpack_require__(/*! write-file-atomic */ "./node_modules/write-file-atomic/lib/index.js").sync);

  KEY_FOR_EMPTY_STRING = '---.EMPTY_STRING.---'; // Chose something that no one is likely to ever use

  _emptyDirectory = function(target) {
    var i, len, p, ref, results;
    ref = fs.readdirSync(target);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      p = ref[i];
      results.push(_rm(path.join(target, p)));
    }
    return results;
  };

  _rm = function(target) {
    if (fs.statSync(target).isDirectory()) {
      _emptyDirectory(target);
      return fs.rmdirSync(target);
    } else {
      return fs.unlinkSync(target);
    }
  };

  _escapeKey = function(key) {
    var newKey;
    if (key === '') {
      newKey = KEY_FOR_EMPTY_STRING;
    } else {
      newKey = `${key}`;
    }
    return newKey;
  };

  QUOTA_EXCEEDED_ERR = class QUOTA_EXCEEDED_ERR extends Error {
    constructor(message = 'Unknown error.') {
      super();
      this.message = message;
      if (Error.captureStackTrace != null) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = this.constructor.name;
    }

    toString() {
      return `${this.name}: ${this.message}`;
    }

  };

  StorageEvent = class StorageEvent {
    constructor(key1, oldValue1, newValue1, url, storageArea = 'localStorage') {
      this.key = key1;
      this.oldValue = oldValue1;
      this.newValue = newValue1;
      this.url = url;
      this.storageArea = storageArea;
    }

  };

  MetaKey = class MetaKey { // MetaKey contains key and size
    constructor(key1, index1) {
      this.key = key1;
      this.index = index1;
      if (!(this instanceof MetaKey)) {
        return new MetaKey(this.key, this.index);
      }
    }

  };

  createMap = function() { // createMap contains Metakeys as properties
    var Map;
    Map = function() {};
    Map.prototype = Object.create(null);
    return new Map();
  };

  LocalStorage = (function() {
    var instanceMap;

    class LocalStorage extends events.EventEmitter {
      constructor(_location, quota = 5 * 1024 * 1024) {
        var handler;
        super();
        this._location = _location;
        this.quota = quota;
        // super(_location, quota)
        // @_location = _location
        // @quota = quota
        if (!(this instanceof LocalStorage)) {
          return new LocalStorage(this._location, this.quota);
        }
        this._location = path.resolve(this._location);
        if (instanceMap[this._location] != null) {
          return instanceMap[this._location];
        }
        this.length = 0; // !TODO: Maybe change this to a property with __defineProperty__
        this._bytesInUse = 0;
        this._keys = [];
        this._metaKeyMap = createMap();
        this._eventUrl = "pid:" + process.pid;
        this._init();
        this._QUOTA_EXCEEDED_ERR = QUOTA_EXCEEDED_ERR;
        if (typeof Proxy !== "undefined" && Proxy !== null) {
          handler = {
            set: (receiver, key, value) => {
              if (this[key] != null) {
                this[key] = value;
              } else {
                this.setItem(key, value);
              }
              return true;
            },
            get: (receiver, key) => {
              if (this[key] != null) {
                return this[key];
              } else {
                return this.getItem(key);
              }
            },
            ownKeys: (target) => {
              return this._keys.map(function(k) {
                if (k === KEY_FOR_EMPTY_STRING) {
                  return '';
                } else {
                  return k;
                }
              });
            },
            getOwnPropertyDescriptor: (target, key) => {
              return {
                value: this[key],
                enumerable: true,
                configurable: true
              };
            }
          };
          instanceMap[this._location] = new Proxy(this, handler);
          return instanceMap[this._location];
        }
        // else it'll return this
        instanceMap[this._location] = this;
        return instanceMap[this._location];
      }

      _init() {
        var e, stat;
        try {
          stat = fs.statSync(this._location);
          if ((stat != null) && !stat.isDirectory()) {
            throw new Error(`A file exists at the location '${this._location}' when trying to create/open localStorage`);
          }
          // At this point, it exists and is definitely a directory. So read it.
          this._sync();
        } catch (error) {
          e = error;
          // If it errors, that might mean it didn't exist, so try to create it
          if (e.code !== "ENOENT") {
            throw e;
          }
          try {
            fs.mkdirSync(this._location, {
              recursive: true
            });
          } catch (error) {
            e = error;
            if (e.code !== "EEXIST") {
              throw e;
            }
          }
        }
      }

      _sync() {
        var _MetaKey, _decodedKey, _keys, i, index, k, len, stat;
        this._bytesInUse = 0;
        this.length = 0;
        _keys = fs.readdirSync(this._location);
        for (index = i = 0, len = _keys.length; i < len; index = ++i) {
          k = _keys[index];
          _decodedKey = decodeURIComponent(k);
          this._keys.push(_decodedKey);
          _MetaKey = new MetaKey(k, index);
          this._metaKeyMap[_decodedKey] = _MetaKey;
          stat = this._getStat(k);
          if ((stat != null ? stat.size : void 0) != null) {
            _MetaKey.size = stat.size;
            this._bytesInUse += stat.size;
          }
        }
        return this.length = _keys.length;
      }

      setItem(key, value) {
        var encodedKey, evnt, existsBeforeSet, filename, hasListeners, metaKey, oldLength, oldValue, valueString, valueStringLength;
        hasListeners = this.listenerCount('storage');
        oldValue = null;
        if (hasListeners) {
          oldValue = this.getItem(key);
        }
        key = _escapeKey(key);
        encodedKey = encodeURIComponent(key).replace(/[!'()]/g, escape).replace(/\*/g, "%2A");
        filename = path.join(this._location, encodedKey);
        valueString = `${value}`;
        valueStringLength = valueString.length;
        metaKey = this._metaKeyMap[key];
        existsBeforeSet = !!metaKey;
        if (existsBeforeSet) {
          oldLength = metaKey.size;
        } else {
          oldLength = 0;
        }
        if (this._bytesInUse - oldLength + valueStringLength > this.quota) {
          throw new QUOTA_EXCEEDED_ERR();
        }
        writeSync(filename, valueString, {
          encoding: 'utf8'
        });
        if (!existsBeforeSet) {
          metaKey = new MetaKey(encodedKey, (this._keys.push(key)) - 1);
          metaKey.size = valueStringLength;
          this._metaKeyMap[key] = metaKey;
          this.length += 1;
          this._bytesInUse += valueStringLength;
        }
        if (hasListeners) {
          evnt = new StorageEvent(key, oldValue, value, this._eventUrl);
          return this.emit('storage', evnt);
        }
      }

      getItem(key) {
        var filename, metaKey;
        key = _escapeKey(key);
        metaKey = this._metaKeyMap[key];
        if (!!metaKey) {
          filename = path.join(this._location, metaKey.key);
          return fs.readFileSync(filename, 'utf8');
        } else {
          return null;
        }
      }

      _getStat(key) {
        var filename;
        key = _escapeKey(key);
        filename = path.join(this._location, encodeURIComponent(key));
        try {
          return fs.statSync(filename);
        } catch (error) {
          return null;
        }
      }

      removeItem(key) {
        var evnt, filename, hasListeners, k, meta, metaKey, oldValue, ref, v;
        key = _escapeKey(key);
        metaKey = this._metaKeyMap[key];
        if (!!metaKey) {
          hasListeners = this.listenerCount('storage');
          oldValue = null;
          if (hasListeners) {
            oldValue = this.getItem(key);
          }
          delete this._metaKeyMap[key];
          this.length -= 1;
          this._bytesInUse -= metaKey.size;
          filename = path.join(this._location, metaKey.key);
          this._keys.splice(metaKey.index, 1);
          ref = this._metaKeyMap;
          for (k in ref) {
            v = ref[k];
            meta = this._metaKeyMap[k];
            if (meta.index > metaKey.index) {
              meta.index -= 1;
            }
          }
          _rm(filename);
          if (hasListeners) {
            evnt = new StorageEvent(key, oldValue, null, this._eventUrl);
            return this.emit('storage', evnt);
          }
        }
      }

      key(n) {
        var rawKey;
        rawKey = this._keys[n];
        if (rawKey === KEY_FOR_EMPTY_STRING) {
          return '';
        } else {
          return rawKey;
        }
      }

      clear() {
        var evnt;
        _emptyDirectory(this._location);
        this._metaKeyMap = createMap();
        this._keys = [];
        this.length = 0;
        this._bytesInUse = 0;
        if (this.listenerCount('storage')) {
          evnt = new StorageEvent(null, null, null, this._eventUrl);
          return this.emit('storage', evnt);
        }
      }

      _getBytesInUse() {
        return this._bytesInUse;
      }

      _deleteLocation() {
        delete instanceMap[this._location];
        _rm(this._location);
        this._metaKeyMap = {};
        this._keys = [];
        this.length = 0;
        return this._bytesInUse = 0;
      }

    };

    instanceMap = {};

    return LocalStorage;

  }).call(this);

  JSONStorage = class JSONStorage extends LocalStorage {
    setItem(key, value) {
      var newValue;
      newValue = JSON.stringify(value);
      return super.setItem(key, newValue);
    }

    getItem(key) {
      return JSON.parse(super.getItem(key));
    }

  };

  exports.LocalStorage = LocalStorage;

  exports.JSONStorage = JSONStorage;

  exports.QUOTA_EXCEEDED_ERR = QUOTA_EXCEEDED_ERR;

}).call(this);


/***/ }),

/***/ "./node_modules/supports-color/index.js":
/*!**********************************************!*\
  !*** ./node_modules/supports-color/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const tty = __webpack_require__(/*! tty */ "tty");
const hasFlag = __webpack_require__(/*! has-flag */ "./node_modules/has-flag/index.js");

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ "./src/main/global-this.model.ts":
/*!***************************************!*\
  !*** ./src/main/global-this.model.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_polyfills_local_storage_polyfill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @node/polyfills/local-storage.polyfill */ "./src/node/polyfills/local-storage.polyfill.ts");
/* harmony import */ var _shared_global_this_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/global-this.model */ "./src/shared/global-this.model.ts");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @node/utils/command-line.util */ "./src/node/utils/command-line.util.ts");
/* harmony import */ var _node_utils_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @node/utils/util */ "./src/node/utils/util.ts");
/**
 * Module to set up globalThis and polyfills in main
 *
 * TODO: consider making this a normal exporting module so it's not using globalThis and using
 * NormalModuleReplacementPlugin to make sure the right one gets imported per process. Idea from
 * Bergi at https://stackoverflow.com/a/69982121 See
 * https://webpack.js.org/plugins/normal-module-replacement-plugin/
 */






// #region globalThis setup
globalThis.processType = _shared_global_this_model__WEBPACK_IMPORTED_MODULE_2__.ProcessType.Main;
globalThis.isPackaged = electron__WEBPACK_IMPORTED_MODULE_3__.app.isPackaged;
globalThis.resourcesPath = electron__WEBPACK_IMPORTED_MODULE_3__.app.isPackaged ? process.resourcesPath : path__WEBPACK_IMPORTED_MODULE_0___default().join(__dirname, '../../');
globalThis.logLevel =
    // Assert the extracted type.
    // eslint-disable-next-line no-type-assertion/no-type-assertion
    (0,_node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_4__.getCommandLineArgument)(_node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_4__.COMMAND_LINE_ARGS.LogLevel) ??
        (globalThis.isPackaged ? 'info' : 'debug');
globalThis.isNoisyDevModeEnabled = (0,_node_utils_util__WEBPACK_IMPORTED_MODULE_5__.isNoisyDevModeEnvVariableSet)();
// #endregion
// #region polyfills
(0,_node_polyfills_local_storage_polyfill__WEBPACK_IMPORTED_MODULE_1__.polyfillLocalStorage)();
// #endregion


/***/ }),

/***/ "./src/main/main.ts":
/*!**************************!*\
  !*** ./src/main/main.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ "os");
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var electron_window_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! electron-window-state */ "./node_modules/electron-window-state/index.js");
/* harmony import */ var electron_window_state__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(electron_window_state__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _main_global_this_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @main/global-this.model */ "./src/main/global-this.model.ts");
/* harmony import */ var _main_services_dotnet_data_provider_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @main/services/dotnet-data-provider.service */ "./src/main/services/dotnet-data-provider.service.ts");
/* harmony import */ var _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @shared/services/logger.service */ "./src/shared/services/logger.service.ts");
/* harmony import */ var _shared_services_network_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @shared/services/network.service */ "./src/shared/services/network.service.ts");
/* harmony import */ var _shared_services_command_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @shared/services/command.service */ "./src/shared/services/command.service.ts");
/* harmony import */ var _node_utils_util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @node/utils/util */ "./src/node/utils/util.ts");
/* harmony import */ var _main_services_extension_host_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @main/services/extension-host.service */ "./src/main/services/extension-host.service.ts");
/* harmony import */ var _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @shared/services/network-object.service */ "./src/shared/services/network-object.service.ts");
/* harmony import */ var _main_services_extension_asset_protocol_service__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @main/services/extension-asset-protocol.service */ "./src/main/services/extension-asset-protocol.service.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");
/* harmony import */ var _shared_services_project_data_provider_service__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @shared/services/project-data-provider.service */ "./src/shared/services/project-data-provider.service.ts");
/* harmony import */ var _main_services_network_object_status_service_host__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @main/services/network-object-status.service-host */ "./src/main/services/network-object-status.service-host.ts");
/* harmony import */ var _shared_data_platform_data__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @shared/data/platform.data */ "./src/shared/data/platform.data.ts");
/* harmony import */ var _main_services_project_lookup_service_host__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @main/services/project-lookup.service-host */ "./src/main/services/project-lookup.service-host.ts");
/* harmony import */ var _shared_models_project_data_provider_model__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @shared/models/project-data-provider.model */ "./src/shared/models/project-data-provider.model.ts");
/* harmony import */ var _shared_data_rpc_model__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @shared/data/rpc.model */ "./src/shared/data/rpc.model.ts");
/* harmony import */ var _node_services_extension_service_model__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @node/services/extension.service-model */ "./src/node/services/extension.service-model.ts");
/* harmony import */ var _main_services_data_protection_service_host__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @main/services/data-protection.service-host */ "./src/main/services/data-protection.service-host.ts");
/* harmony import */ var _main_platform_macos_menubar_util__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @main/platform-macos-menubar.util */ "./src/main/platform-macos-menubar.util.ts");
/* harmony import */ var _main_services_app_service_host__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @main/services/app.service-host */ "./src/main/services/app.service-host.ts");
/* harmony import */ var _shared_services_settings_service__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @shared/services/settings.service */ "./src/shared/services/settings.service.ts");
/**
 * This module executes inside of electron's main process. You can start electron renderer process
 * from here and communicate with the other processes through IPC.
 *
 * When running `npm run build` or `npm run build:main`, this file is compiled to `./src/main.js`
 * using webpack. This gives us some performance wins.
 */



// Removed until we have a release. See https://github.com/paranext/paranext-core/issues/83
/* import { autoUpdater } from 'electron-updater'; */






















// #region Prevent multiple instances of the app. This needs to stay at the top of the app!
// Prevent multiple instances because an instance launched after the first is likely a URL redirect
// to our protocol client. We handle URI redirects below in `second-instance`
/** Whether this is the first instance of this application. */
const isFirstInstance = electron__WEBPACK_IMPORTED_MODULE_2__.app.requestSingleInstanceLock();
if (!isFirstInstance) {
    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.info(`Application launched but not first instance. Exiting. This probably means the application just handled a URL. process.argv: ${process.argv}`);
    electron__WEBPACK_IMPORTED_MODULE_2__.app.exit();
}
// #endregion
const PROCESS_CLOSE_TIME_OUT = 2000;
/**
 * If this is `true`, we will restart soon. Not just using `isClosing` because we need to make sure
 * we only run `relaunch` once which has a slightly different use case than `isClosing`
 */
let willRestart = false;
// Add unhandled exception and rejection handlers
process.on('uncaughtException', (error) => {
    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.error(`Unhandled exception in main process: ${(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_13__.getErrorMessage)(error)}`);
});
process.on('unhandledRejection', (reason) => {
    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.error(`Unhandled promise rejection in main process, reason: ${(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_13__.getErrorMessage)(reason)}`);
});
/**
 * Open a link in the browser following the restrictions we put in place in Platform.Bible
 *
 * Make sure not to allow just any link. See
 * https://benjamin-altpeter.de/shell-openexternal-dangers/
 */
async function openExternal(url) {
    if (!url.startsWith('https://') && !url.startsWith(`${_main_services_app_service_host__WEBPACK_IMPORTED_MODULE_23__.APP_URI_SCHEME}://`))
        throw new Error(`External URL must start with 'https://' or '${_main_services_app_service_host__WEBPACK_IMPORTED_MODULE_23__.APP_URI_SCHEME}://: ${url}`);
    try {
        await electron__WEBPACK_IMPORTED_MODULE_2__.shell.openExternal(url);
    }
    catch (e) {
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.warn((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_13__.getErrorMessage)(e));
        throw e;
    }
    return true;
}
async function main() {
    // The network service relies on nothing else, and other things rely on it, so start it first
    await _shared_services_network_service__WEBPACK_IMPORTED_MODULE_7__.initialize();
    // The network object status service relies on seeing everything else start up later
    await (0,_main_services_network_object_status_service_host__WEBPACK_IMPORTED_MODULE_15__.startNetworkObjectStatusService)();
    // The project lookup service relies on the network object status service
    await (0,_main_services_project_lookup_service_host__WEBPACK_IMPORTED_MODULE_17__.startProjectLookupService)();
    // The .NET data provider relies on the network service and nothing else
    _main_services_dotnet_data_provider_service__WEBPACK_IMPORTED_MODULE_5__.dotnetDataProvider.start();
    // TODO (maybe): Wait for signal from the .NET data provider process that it is ready
    // Need to start the data protection service before starting the extension host because extensions
    // use it
    await (0,_main_services_data_protection_service_host__WEBPACK_IMPORTED_MODULE_21__.startDataProtectionService)();
    // Need to start the app service before starting the extension host because extensions use it
    await (0,_main_services_app_service_host__WEBPACK_IMPORTED_MODULE_23__.startAppService)();
    // The extension host service relies on the network service.
    // Extensions inside the extension host might rely on the .NET data provider and each other
    // Some extensions inside the extension host rely on the renderer to accept 'getWebView' commands.
    // The renderer relies on the extension host, so something has to break the dependency loop.
    // For now, the dependency loop is broken by retrying 'getWebView' in a loop for a while.
    await _main_services_extension_host_service__WEBPACK_IMPORTED_MODULE_10__.extensionHostService.start();
    // TODO (maybe): Wait for signal from the extension host process that it is ready (except 'getWebView')
    // We could then wait for the renderer to be ready and signal the extension host
    // Keep a global reference of the window object. If you don't, the window will
    // be closed automatically when the JavaScript object is garbage collected.
    let mainWindow;
    // #region Set up the protocol client to receive navigation to this app's URI scheme
    // Launch the portable app if we're in it; otherwise use the normal path
    const launchPath = process.env.PORTABLE_EXECUTABLE_FILE || process.execPath;
    const args = process.argv.slice(1);
    function handleUri(uri) {
        if (mainWindow) {
            if (mainWindow.isMinimized())
                mainWindow.restore();
            mainWindow.focus();
        }
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.debug(`Main is handling uri ${uri}`);
        // need to use `new URL` instead of `URL.parse` because Node<22.1.0 doesn't have it. Can change
        // when we get there
        let url;
        try {
            url = new URL(uri);
        }
        catch (e) {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.debug(`Main received uri ${uri} but could not parse it. If this does not look like a uri, that probably means the user tried to open the application again. This is likely not a problem. ${e}`);
            return;
        }
        if (url.protocol !== `${_main_services_app_service_host__WEBPACK_IMPORTED_MODULE_23__.APP_URI_SCHEME}:`) {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.warn(`Main received uri ${uri} but protocol does not match ${_main_services_app_service_host__WEBPACK_IMPORTED_MODULE_23__.APP_URI_SCHEME}`);
            return;
        }
        (async () => {
            try {
                await _shared_services_network_service__WEBPACK_IMPORTED_MODULE_7__.request(_node_services_extension_service_model__WEBPACK_IMPORTED_MODULE_20__.HANDLE_URI_REQUEST_TYPE, uri);
            }
            catch (e) {
                _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.warn(`Main sent request for extension service to handle uri ${uri}, but it threw. ${e}`);
            }
        })();
    }
    // Resolve the path to this file if we're running the electron app itself and passing in this file
    // Note that this condition (`process.defaultApp`) is not quite the same as whether we're
    // packaged, so we're not using `globalThis.isPackaged` here.
    if (process.defaultApp && args.length > 2)
        args[2] = path__WEBPACK_IMPORTED_MODULE_1___default().resolve(args[2]);
    electron__WEBPACK_IMPORTED_MODULE_2__.app.setAsDefaultProtocolClient(_main_services_app_service_host__WEBPACK_IMPORTED_MODULE_23__.APP_URI_SCHEME, launchPath, args);
    if (process.platform === 'darwin') {
        // Use OSX's event to handle navigation
        electron__WEBPACK_IMPORTED_MODULE_2__.app.on('open-url', (_event, url) => handleUri(url));
    }
    else {
        // Non-OSX attempts to launch a second instance to handle navigation; detect and handle
        // accordingly
        electron__WEBPACK_IMPORTED_MODULE_2__.app.on('second-instance', (_event, commandLine) => {
            // Handle the URL
            const uri = commandLine[commandLine.length - 1];
            handleUri(uri);
        });
    }
    // #endregion
    // #region Start the renderer
    // Removed until we have a release. See https://github.com/paranext/paranext-core/issues/83
    /* class AppUpdater {
    constructor() {
      autoUpdater.logger = logger;
      autoUpdater.checkForUpdatesAndNotify();
    }
  } */
    if (false) {}
    const isDebug =  true || 0;
    if (isDebug) {
        const electronDebug = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_electron-debug_index_js"), __webpack_require__.e("node_modules_electron-debug_sync_recursive")]).then(__webpack_require__.t.bind(__webpack_require__, /*! electron-debug */ "./node_modules/electron-debug/index.js", 23));
        electronDebug.default();
    }
    /** Install extensions into the Chromium renderer process */
    async function installExtensions() {
        const installer = await __webpack_require__.e(/*! import() */ "vendors-node_modules_electron-devtools-installer_dist_index_js").then(__webpack_require__.bind(__webpack_require__, /*! electron-devtools-installer */ "./node_modules/electron-devtools-installer/dist/index.js"));
        const forceDownload = !!process.env.UPGRADE_EXTENSIONS;
        const extensions = [installer.REACT_DEVELOPER_TOOLS];
        return installer.default(extensions, forceDownload).catch(_shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.info);
    }
    function getAssetPath(...paths) {
        return path__WEBPACK_IMPORTED_MODULE_1___default().join(globalThis.resourcesPath, 'assets', ...paths);
    }
    /** Sets up the electron BrowserWindow renderer process */
    const createWindow = async () => {
        if (isDebug) {
            await installExtensions();
        }
        // Load the previous state with fallback to defaults
        const mainWindowState = electron_window_state__WEBPACK_IMPORTED_MODULE_3___default()({
            defaultWidth: 1024,
            defaultHeight: 728,
        });
        mainWindow = new electron__WEBPACK_IMPORTED_MODULE_2__.BrowserWindow({
            show: true,
            x: mainWindowState.x,
            y: mainWindowState.y,
            width: mainWindowState.width,
            height: mainWindowState.height,
            minWidth: 800, // TODO: Remove this temporary enforcement when https://paratextstudio.atlassian.net/browse/PT-2333 is implemented
            icon: getAssetPath('icon.png'),
            // TODO: Re-check linux support with Electron 34, see https://discord.com/channels/1064938364597436416/1344329166786527232
            ...(process.platform !== 'linux' ? { titleBarStyle: 'hidden' } : {}),
            // re-add window controls
            // TODO: Re-check linux support with Electron 34, see https://discord.com/channels/1064938364597436416/1344329166786527232
            ...(process.platform !== 'darwin' && process.platform !== 'linux'
                ? {
                    titleBarOverlay: {
                        height: 47,
                        color: 'hsla(0, 0%, 100%, 0)', // transparent button background until hovered
                    },
                }
                : {}),
            webPreferences: {
                preload: electron__WEBPACK_IMPORTED_MODULE_2__.app.isPackaged
                    ? path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, 'preload.js')
                    : path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, '../../.erb/dll/preload.js'),
            },
        });
        // Set our custom protocol handler to load assets from extensions
        _main_services_extension_asset_protocol_service__WEBPACK_IMPORTED_MODULE_12__.extensionAssetProtocolService.initialize();
        // Register listeners on the window, so the state is updated automatically
        // (the listeners will be removed when the window is closed)
        // and restore the maximized or full screen state
        mainWindowState.manage(mainWindow);
        // Add several listeners to the main window to log events
        mainWindow.webContents.on('unresponsive', () => _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.warn('mainWindow unresponsive'));
        mainWindow.webContents.on('responsive', () => _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.warn('mainWindow responsive'));
        mainWindow.webContents.on('render-process-gone', (_, details) => _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.warn(`mainWindow render process gone: ${JSON.stringify(details)}`));
        mainWindow.webContents.on(
        // @ts-expect-error - TS seems confused, as this matches the d.ts file and the docs
        'did-fail-load', (_event, errorCode, errorDescription, validatedURL, isMainFrame) => {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.warn(`mainWindow failed to load "${validatedURL}" with error "${errorDescription}" (${errorCode}). isMainFrame: ${isMainFrame}`);
        });
        mainWindow.on('ready-to-show', () => {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.info('mainWindow is ready to show');
            if (!mainWindow)
                throw new Error('"mainWindow" is not defined');
            if (process.env.START_MINIMIZED) {
                mainWindow.minimize();
            }
            else {
                mainWindow.show();
            }
        });
        mainWindow.on('closed', () => {
            mainWindow = undefined;
        });
        if (process.platform === 'darwin') {
            (async () => {
                try {
                    await (0,_main_platform_macos_menubar_util__WEBPACK_IMPORTED_MODULE_22__.subscribeCurrentMacosMenubar)();
                }
                catch (error) {
                    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.info(`Failed to build the macOS menubar ${error}`);
                }
            })();
        }
        // This sets the menu on Windows and Linux
        // 'null' to interact with external API
        // eslint-disable-next-line no-null/no-null
        mainWindow.setMenu(null);
        // Open urls in the user's browser
        // Note that webviews can get to this handler with window.open and anchor tags with
        // target="_blank". Please revise web-view.service-host.ts as necessary if you make changes here
        mainWindow.webContents.setWindowOpenHandler((handlerDetails) => {
            // Only allow https urls
            (async () => {
                try {
                    openExternal(handlerDetails.url);
                }
                catch (e) {
                    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.warn(`mainWindow could not open external url "${handlerDetails.url}" from windowOpenHandler. ${e}`);
                }
            })();
            return { action: 'deny' };
        });
        // If the URL doesn't load, we might need to show something to the user
        const urlToLoad = `${(0,_node_utils_util__WEBPACK_IMPORTED_MODULE_9__.resolveHtmlPath)('index.html')}${globalThis.isNoisyDevModeEnabled ? _shared_data_platform_data__WEBPACK_IMPORTED_MODULE_16__.DEV_MODE_RENDERER_INDICATOR : ''}`;
        mainWindow.loadURL(urlToLoad).catch((e) => {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.error(`mainWindow could not load URL "${urlToLoad}". ${(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_13__.getErrorMessage)(e)}`);
        });
        // Remove this if your app does not use auto updates
        // eslint-disable-next-line
        // Removed until we have a release. See https://github.com/paranext/paranext-core/issues/83
        // new AppUpdater();
    };
    electron__WEBPACK_IMPORTED_MODULE_2__.app.on('window-all-closed', () => {
        // Respect the OSX convention of having the application in memory even
        // after all windows have been closed
        if (process.platform !== 'darwin') {
            electron__WEBPACK_IMPORTED_MODULE_2__.app.quit();
        }
    });
    let isClosing = false;
    electron__WEBPACK_IMPORTED_MODULE_2__.app.on('will-quit', async (e) => {
        if (!isClosing) {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.info('Main process is quitting');
            // Prevent closing before graceful shutdown is complete.
            // Also, in the future, this should allow a "are you sure?" dialog to display.
            e.preventDefault();
            isClosing = true;
            _shared_services_network_service__WEBPACK_IMPORTED_MODULE_7__.shutdown();
            await Promise.all([
                _main_services_dotnet_data_provider_service__WEBPACK_IMPORTED_MODULE_5__.dotnetDataProvider.waitForClose(PROCESS_CLOSE_TIME_OUT),
                _main_services_extension_host_service__WEBPACK_IMPORTED_MODULE_10__.extensionHostService.waitForClose(PROCESS_CLOSE_TIME_OUT),
            ]);
            // In development, the dotnet watcher was killed so we have to wait here.
            if (true)
                await (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_13__.wait)(500);
            electron__WEBPACK_IMPORTED_MODULE_2__.app.quit();
        }
        else {
            _main_services_dotnet_data_provider_service__WEBPACK_IMPORTED_MODULE_5__.dotnetDataProvider.kill();
            _main_services_extension_host_service__WEBPACK_IMPORTED_MODULE_10__.extensionHostService.kill();
        }
    });
    electron__WEBPACK_IMPORTED_MODULE_2__.app
        .whenReady()
        // eslint-disable-next-line promise/always-return
        .then(() => {
        // Set up ipc handlers
        electron__WEBPACK_IMPORTED_MODULE_2__.ipcMain.handle('electronAPI:env.test', (_event, message) => `From main.ts: test ${message}`);
        createWindow();
        electron__WEBPACK_IMPORTED_MODULE_2__.app.on('activate', () => {
            // On macOS it's common to re-create a window in the app when the
            // dock icon is clicked and there are no other windows open.
            if (!mainWindow)
                createWindow();
        });
        return undefined;
    })
        .catch((e) => _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.error(`Error in app.whenReady: ${(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_13__.getErrorMessage)(e)}`));
    // #endregion
    // #region Ensure the request timeout has been set
    // settingsService updates the request timeout during initialization, so using the service in any
    // way ensures the timeout is set
    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.debug(`Request timeout is ${await _shared_services_settings_service__WEBPACK_IMPORTED_MODULE_24__.settingsService.get('platform.requestTimeout')} sec`);
    // #endregion
    // #region Register commands
    // `main.ts`'s command handler declarations are in `papi-shared-types.ts` so papi-dts sees them
    _shared_services_command_service__WEBPACK_IMPORTED_MODULE_8__.registerCommand('platform.restartExtensionHost', restartExtensionHost, {
        method: {
            summary: 'Restart the extension host which reloads and reinitializes TS/JS extensions',
            params: [],
            result: {
                name: 'return value',
                schema: { type: 'null' },
            },
        },
    });
    _shared_services_command_service__WEBPACK_IMPORTED_MODULE_8__.registerCommand('platform.quit', async () => {
        electron__WEBPACK_IMPORTED_MODULE_2__.app.quit();
    }, {
        method: {
            summary: 'Close the platform, including all processes started by it',
            params: [],
            result: {
                name: 'return value',
                schema: { type: 'null' },
            },
        },
    });
    _shared_services_command_service__WEBPACK_IMPORTED_MODULE_8__.registerCommand('platform.restart', async () => {
        // Only set up to restart once. This could accidentally be called twice if `app.quit` is
        // canceled or if someone requested to restart multiple times in the few seconds it takes
        // `app.quit` to run because of the `will-quit` event
        if (!willRestart) {
            willRestart = true;
            electron__WEBPACK_IMPORTED_MODULE_2__.app.relaunch({
                // If in portable app, relaunch properly. If not, take default action. Thanks to Araxeus at
                // https://github.com/electron-userland/electron-builder/issues/4110#issuecomment-1050149429
                execPath: process.env.PORTABLE_EXECUTABLE_FILE,
            });
        }
        electron__WEBPACK_IMPORTED_MODULE_2__.app.quit();
    }, {
        method: {
            summary: 'Restart the platform, including all processes started by it',
            params: [],
            result: {
                name: 'return value',
                schema: { type: 'null' },
            },
        },
    });
    _shared_services_command_service__WEBPACK_IMPORTED_MODULE_8__.registerCommand('platform.getOSPlatform', async () => {
        return os__WEBPACK_IMPORTED_MODULE_0___default().platform();
    }, {
        method: {
            summary: 'Get the os platform ("win32", "darwin", "linux")',
            params: [],
            result: {
                name: 'return value',
                schema: { type: 'null' },
            },
        },
    });
    _shared_services_command_service__WEBPACK_IMPORTED_MODULE_8__.registerCommand('platform.isFullScreen', async () => {
        return false; // TODO implement;
    }, {
        method: {
            summary: 'If platform runs in full screen mode',
            params: [],
            result: {
                name: 'return value',
                schema: { type: 'null' },
            },
        },
    });
    const liveDocsUrl = 'https://playground.open-rpc.org/?transport=websocket&schemaUrl=ws%3A%2F%2Flocalhost%3A8876%0A&uiSchema[appBar][ui:splitView]=false&uiSchema[appBar][ui:input]=false&uiSchema[appBar][ui:examplesDropdown]=false&uiSchema[appBar][ui:transports]=false&uiSchema[appBar][ui:darkMode]=true&uiSchema[appBar][ui:title]=PAPI';
    _shared_services_command_service__WEBPACK_IMPORTED_MODULE_8__.registerCommand('platform.openDeveloperDocumentationUrl', async () => {
        await openExternal(liveDocsUrl);
    }, {
        method: {
            summary: 'Open the OpenRPC documentation in a browser',
            params: [],
            result: {
                name: 'return value',
                schema: { type: 'null' },
            },
        },
    });
    _shared_services_command_service__WEBPACK_IMPORTED_MODULE_8__.registerCommand('platform.openWindow', async (url) => {
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.debug(`Main opening window with url from command: ${url}`);
        await openExternal(url);
    }, {
        method: {
            summary: "Open a link in the user's default browser",
            params: [
                {
                    name: 'url',
                    required: true,
                    summary: 'The url to open',
                    schema: { type: 'string' },
                },
            ],
            result: {
                name: 'return value',
                schema: { type: 'null' },
            },
        },
    });
    // #endregion
    // #region Noisy dev tests
    if (globalThis.isNoisyDevModeEnabled) {
        // Register commands only for testing purposes
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const testCommandHandlers = {
            'test.echo': async (message) => {
                return message;
            },
            'test.echoExtensionHost': async (message) => {
                await _shared_services_command_service__WEBPACK_IMPORTED_MODULE_8__.sendCommand('test.addMany', 3, 5, 7, 1, 4);
                return message;
            },
            'test.throwError': async (message) => {
                throw new Error(`Test Error thrown in throwError command: ${message}`);
            },
        };
        Object.entries(testCommandHandlers).forEach(([commandName, handler]) => {
            // Re-assert type after passing through `forEach`.
            // eslint-disable-next-line no-type-assertion/no-type-assertion
            _shared_services_command_service__WEBPACK_IMPORTED_MODULE_8__.registerCommand(commandName, handler);
        });
        // Call a test command registered elsewhere
        setTimeout(async () => {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.debug(`Add Many (from EH): ${await _shared_services_command_service__WEBPACK_IMPORTED_MODULE_8__.sendCommand('test.addMany', 2, 5, 9, 7)}`);
        }, 20000);
        // Register a test network object
        const testMain = {
            doStuff: (stuff) => {
                const result = `testMain did stuff: ${stuff}!`;
                _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.debug(result);
                return result;
            },
            dispose: () => {
                _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.debug('testMain.dispose() ran in testMain');
                return Promise.resolve(true);
            },
        };
        const testMainDisposer = await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_11__.networkObjectService.set('testMain', testMain);
        testMain.doStuff('main things');
        testMainDisposer.onDidDispose(() => {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.debug('testMain disposed in main message #1');
        });
        testMainDisposer.onDidDispose(() => {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.debug('testMain disposed in main message #2');
        });
        setTimeout(testMainDisposer.dispose, 20000);
        // Create a test network object registered elsewhere
        setTimeout(async () => {
            let testExtensionHost = await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_11__.networkObjectService.get('testExtensionHost');
            if (testExtensionHost) {
                _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.debug(`get verse: ${await testExtensionHost.getVerse()}`);
                testExtensionHost.onDidDispose(() => {
                    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.debug('testExtensionHost disposed in main');
                    testExtensionHost = undefined;
                });
            }
            else
                _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.error('Could not get testExtensionHost from main');
        }, 5000);
        // Dump all the network objects after things have settled a bit
        setTimeout(async () => {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.info(`Available network request types after 30 seconds: ${(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_13__.serialize)(
            // eslint-disable-next-line no-type-assertion/no-type-assertion
            await _shared_services_network_service__WEBPACK_IMPORTED_MODULE_7__.request(_shared_data_rpc_model__WEBPACK_IMPORTED_MODULE_19__.GET_METHODS, {}))}`);
        }, 30000);
        // Get a data provider and do something with it
        setTimeout(async () => {
            const usxPdp = await (0,_shared_services_project_data_provider_service__WEBPACK_IMPORTED_MODULE_14__.get)('platformScripture.USX_Chapter', '32664dc3288a28df2e2bb75ded887fc8f17a15fb');
            const verse = await usxPdp.getChapterUSX({ book: 'JHN', chapterNum: 1, verseNum: 1 });
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.info(`Got PDP data: ${verse}`);
            if (verse !== undefined)
                await usxPdp.setChapterUSX({ book: 'JHN', chapterNum: 1, verseNum: 1 }, verse);
            const basePdp = await (0,_shared_services_project_data_provider_service__WEBPACK_IMPORTED_MODULE_14__.get)(_shared_models_project_data_provider_model__WEBPACK_IMPORTED_MODULE_18__.PROJECT_INTERFACE_PLATFORM_BASE, '32664dc3288a28df2e2bb75ded887fc8f17a15fb');
            basePdp.setExtensionData({ extensionName: 'foo', dataQualifier: 'fooData' }, 'This is the data from extension foo');
        }, 20000);
    }
    // #endregion
}
async function restartExtensionHost() {
    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.info('Restarting extension host');
    await _main_services_extension_host_service__WEBPACK_IMPORTED_MODULE_10__.extensionHostService.restart(PROCESS_CLOSE_TIME_OUT);
}
(async () => {
    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.info(`Starting ${_main_services_app_service_host__WEBPACK_IMPORTED_MODULE_23__.APP_NAME} version ${_main_services_app_service_host__WEBPACK_IMPORTED_MODULE_23__.APP_VERSION}`);
    await main();
})().catch(_shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.error);


/***/ }),

/***/ "./src/main/platform-macos-menubar.data.ts":
/*!*************************************************!*\
  !*** ./src/main/platform-macos-menubar.data.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   macosMenubarObject: () => (/* binding */ macosMenubarObject)
/* harmony export */ });
// Cannot contribute this as is in main.ts, need to convert labels and tooltips to localized strings and remove order property
const macosMenubarObject = [
    {
        role: 'appMenu',
        id: 'macosMenubar.appMenu',
        submenu: [
            {
                label: '%mainMenu_hideProductName%',
                role: 'hide',
                id: 'hide',
                order: 3,
                isLabelFormatString: true,
            },
            { role: 'hideOthers', id: 'hideOthers', order: 4 },
            {
                label: '%mainMenu_quitProductName%',
                role: 'quit',
                id: 'quit',
                order: 5,
                isLabelFormatString: true,
            },
        ],
    },
    {
        label: '%mainMenu_file%',
        role: 'fileMenu',
        id: 'macosMenubar.fileMenu',
        submenu: [{ role: 'close', id: 'close', order: 8 }],
    },
    {
        label: '%mainMenu_edit%',
        role: 'editMenu',
        id: 'macosMenubar.editMenu',
    },
    {
        label: '%mainMenu_view%',
        role: 'viewMenu',
        id: 'macosMenubar.viewMenu',
    },
    {
        label: '%mainMenu_tab%',
        id: 'macosMenubar.tabMenu',
    },
    {
        label: '%mainMenu_text%',
        id: 'macosMenubar.textMenu',
    },
    {
        label: '%mainMenu_layout%',
        id: 'macosMenubar.layoutMenu',
    },
    {
        label: '%mainMenu_window%',
        role: 'windowMenu',
        id: 'macosMenubar.windowMenu',
    },
    {
        label: '%mainMenu_help%',
        role: 'help',
        id: 'macosMenubar.helpMenu',
        submenu: [],
    },
];


/***/ }),

/***/ "./src/main/platform-macos-menubar.util.ts":
/*!*************************************************!*\
  !*** ./src/main/platform-macos-menubar.util.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   subscribeCurrentMacosMenubar: () => (/* binding */ subscribeCurrentMacosMenubar)
/* harmony export */ });
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");
/* harmony import */ var _main_platform_macos_menubar_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @main/platform-macos-menubar.data */ "./src/main/platform-macos-menubar.data.ts");
/* harmony import */ var _shared_services_menu_data_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/services/menu-data.service */ "./src/shared/services/menu-data.service.ts");
/* harmony import */ var _shared_services_localization_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @shared/services/localization.service */ "./src/shared/services/localization.service.ts");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @shared/services/logger.service */ "./src/shared/services/logger.service.ts");
/* harmony import */ var _shared_data_platform_bible_menu_commands__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @shared/data/platform-bible-menu.commands */ "./src/shared/data/platform-bible-menu.commands.ts");







/**
 * Subscribe to changes in the main menu data and update the macOS menubar accordingly.
 *
 * After subscribing, whenever the main menu data changes, this function will be called with the new
 * menu data. The new menu data will be translated and combined correctly into the structure
 * expected by the Electron Menu API, and then the macOS menubar will be updated with the new menu
 * structure.
 *
 * If there is an error during the translation and combination process, the default macOS menubar
 * will be used instead.
 */
async function subscribeCurrentMacosMenubar() {
    await _shared_services_menu_data_service__WEBPACK_IMPORTED_MODULE_2__.menuDataService.subscribeUnlocalizedMainMenu(undefined, async (menuContent) => {
        let currentMacosMenubarTemplate;
        try {
            currentMacosMenubarTemplate = await translatePlatformMenuItemsAndCombine(menuContent);
        }
        catch (error) {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_5__.logger.error('Failed to get current platform menus. Falling back to default macOS menubar.', error);
            currentMacosMenubarTemplate = await fallbackToDefaultMacosMenubar();
        }
        try {
            const coreMacosMenubar = electron__WEBPACK_IMPORTED_MODULE_4__.Menu.buildFromTemplate(currentMacosMenubarTemplate);
            electron__WEBPACK_IMPORTED_MODULE_4__.Menu.setApplicationMenu(coreMacosMenubar);
        }
        catch (error) {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_5__.logger.error('Failed to build current macOS menubar', error);
        }
    });
}
function sortMenuAndRemoveAddedProps(localizedMacosMenubar) {
    localizedMacosMenubar.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
    localizedMacosMenubar.forEach((menu) => {
        if (Array.isArray(menu.submenu)) {
            menu.submenu.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
            // Remove the `order` property from submenu items
            menu.submenu.forEach((item) => {
                delete item.order;
                delete item.isLabelFormatString;
                // If the submenu item has its own submenu, sort it recursively
                if (Array.isArray(item.submenu)) {
                    item.submenu.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
                    item.submenu.forEach((subItem) => delete subItem.order);
                }
            });
        }
        // Remove the `order` property from the top-level menu
        delete menu.order;
    });
    // The only difference between MenuItemConstructorOptions[] and LocalizedMacosMenubar is the `order` property
    // eslint-disable-next-line no-type-assertion/no-type-assertion
    return localizedMacosMenubar;
}
/** Returns the default macOS menubar after localizing and formatting it correctly. */
async function fallbackToDefaultMacosMenubar() {
    return sortMenuAndRemoveAddedProps(await localizeMacosMenubar(_main_platform_macos_menubar_data__WEBPACK_IMPORTED_MODULE_1__.macosMenubarObject));
}
async function localizeMacosMenubar(macosMenubar) {
    const localizeKeys = ['%product_name%'];
    macosMenubar.forEach((menu) => {
        if (menu.label)
            localizeKeys.push(menu.label);
        if (menu.toolTip)
            localizeKeys.push(menu.toolTip);
        menu.submenu?.forEach((item) => {
            if (item.label)
                localizeKeys.push(item.label);
            if (item.toolTip)
                localizeKeys.push(item.toolTip);
        });
    });
    const newStrings = await _shared_services_localization_service__WEBPACK_IMPORTED_MODULE_3__.localizationService.getLocalizedStrings({ localizeKeys });
    return macosMenubar.map((menu) => ({
        ...menu,
        label: menu.label ? newStrings[menu.label] : menu.label,
        toolTip: menu.toolTip ? newStrings[menu.toolTip] : menu.toolTip,
        submenu: menu.submenu?.map((item) => ({
            ...item,
            label: (() => {
                if (!item.label)
                    return item.label;
                if (item.isLabelFormatString) {
                    return (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_0__.formatReplacementString)(newStrings[item.label], newStrings);
                }
                return newStrings[item.label];
            })(),
            toolTip: item.toolTip ? newStrings[item.toolTip] : item.toolTip,
        })),
    }));
}
const getSubMenuKeyForId = (groups, id) => {
    return Object.entries(groups).find(([, value]) => 'menuItem' in value && value.menuItem === id)?.[0];
};
function getMenubarColumnContent(groups, items, columnOrSubMenuKey) {
    if (!columnOrSubMenuKey)
        return [];
    // Object.entries() turns groups into an array of key value pairs. After we filter and map the items, it is a LocalizedMacosMenubar object.
    // eslint-disable-next-line no-type-assertion/no-type-assertion
    return Object.entries(groups)
        .filter(([key, group]) => ('column' in group && group.column === columnOrSubMenuKey) || key === columnOrSubMenuKey)
        .flatMap(([groupKey]) => items
        .filter((item) => item.group === groupKey)
        .map((item) => 'command' in item
        ? {
            label: item.label,
            click: () => (0,_shared_data_platform_bible_menu_commands__WEBPACK_IMPORTED_MODULE_6__.handleMenuCommand)({ label: item.label, command: item.command }),
            order: item.order,
        }
        : {
            label: item.label,
            submenu: getMenubarColumnContent(groups, items, getSubMenuKeyForId(groups, item.id)),
        }));
}
async function translatePlatformMenuItemsAndCombine(currentPlatformMainMenu) {
    // Convert the platform-specific main menu into the correct format
    // eslint-disable-next-line no-type-assertion/no-type-assertion
    const platformMainMenuContent = Object.entries(currentPlatformMainMenu.columns)
        .filter(([, column]) => typeof column === 'object')
        .map(([columnKey, columnData]) => ({
        label: typeof columnData === 'object' ? columnData.label : '',
        order: typeof columnData === 'object' ? columnData.order : 0,
        submenu: getMenubarColumnContent(currentPlatformMainMenu.groups, currentPlatformMainMenu.items, columnKey).filter((menuItem) => menuItem.label !== '%mainMenu_exit%'), // Remove duplicate 'Exit' here
    }));
    const combinedMenubar = [..._main_platform_macos_menubar_data__WEBPACK_IMPORTED_MODULE_1__.macosMenubarObject];
    platformMainMenuContent.forEach((column) => {
        if (!column.submenu || !Array.isArray(column.submenu))
            return;
        const appMenu = combinedMenubar.find((menu) => menu.id === 'macosMenubar.appMenu');
        // Move 'Platform' menu items to macOS generated app menu and remove duplicate app menu
        if (column.label === '%product_shortName%' && appMenu) {
            appMenu.submenu?.push(...column.submenu);
            column.submenu = [];
            column.label = '%%'; // If there is no label, this menu item won't show up
            return;
        }
        const existingMenu = combinedMenubar.find((menu) => menu.label?.toLowerCase() === column.label?.toLowerCase() ||
            menu.role?.toLowerCase() === column.label?.toLowerCase());
        if (existingMenu) {
            existingMenu.submenu = column.submenu;
        }
        else {
            combinedMenubar.push(column);
        }
    });
    const localizedMenu = await localizeMacosMenubar(combinedMenubar);
    return sortMenuAndRemoveAddedProps(localizedMenu);
}


/***/ }),

/***/ "./src/main/services/app.service-host.ts":
/*!***********************************************!*\
  !*** ./src/main/services/app.service-host.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   APP_NAME: () => (/* binding */ APP_NAME),
/* harmony export */   APP_URI_SCHEME: () => (/* binding */ APP_URI_SCHEME),
/* harmony export */   APP_VERSION: () => (/* binding */ APP_VERSION),
/* harmony export */   startAppService: () => (/* binding */ startAppService)
/* harmony export */ });
/* harmony import */ var _shared_services_app_service_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/services/app.service-model */ "./src/shared/services/app.service-model.ts");
/* harmony import */ var _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/services/network-object.service */ "./src/shared/services/network-object.service.ts");
/* harmony import */ var _release_app_package_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../release/app/package.json */ "./release/app/package.json");
/* harmony import */ var _release_app_buildInfo_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../release/app/buildInfo.json */ "./release/app/buildInfo.json");




/** Same as {@link AppInfo.name} */
const APP_NAME = _release_app_package_json__WEBPACK_IMPORTED_MODULE_2__.name;
// Construct the app version according to the SemVer specification (pre-release ID already included)
const { build } = _release_app_buildInfo_json__WEBPACK_IMPORTED_MODULE_3__;
/** Same as {@link AppInfo.version} */
const APP_VERSION = `${_release_app_package_json__WEBPACK_IMPORTED_MODULE_2__.version}${build ? `+${build}` : ''}`;
/** Same as {@link AppInfo.uriScheme} */
const APP_URI_SCHEME = APP_NAME;
const APP_INFO = Object.freeze({
    name: APP_NAME,
    version: APP_VERSION,
    uriScheme: APP_URI_SCHEME,
});
async function getAppInfo() {
    return APP_INFO;
}
const appService = {
    getAppInfo,
};
/**
 * Register the network object that backs this service
 *
 * To use this service, you should use `app.service.ts`
 */
async function startAppService() {
    await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_1__.networkObjectService.set(_shared_services_app_service_model__WEBPACK_IMPORTED_MODULE_0__.appServiceNetworkObjectName, appService);
}


/***/ }),

/***/ "./src/main/services/data-protection.service-host.ts":
/*!***********************************************************!*\
  !*** ./src/main/services/data-protection.service-host.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startDataProtectionService: () => (/* binding */ startDataProtectionService)
/* harmony export */ });
/* harmony import */ var _shared_models_data_protection_service_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/models/data-protection.service-model */ "./src/shared/models/data-protection.service-model.ts");
/* harmony import */ var _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/services/network-object.service */ "./src/shared/services/network-object.service.ts");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_2__);



/** If encryption is not available, return reason why. If encryption is available, return `undefined` */
function getReasonEncryptionIsNotAvailable() {
    if (process.platform === 'linux' && electron__WEBPACK_IMPORTED_MODULE_2__.safeStorage.getSelectedStorageBackend() === 'basic_text')
        return 'safeStorage did not find a keyring service it could use for encryption. Please install a supported service. See https://github.com/paranext/paranext/wiki/How-to-set-up-Platform.Bible-on-Linux#install-a-keyring-service for more information';
    if (!electron__WEBPACK_IMPORTED_MODULE_2__.safeStorage.isEncryptionAvailable()) {
        return 'safeStorage.isEncryptionAvailable returned false';
    }
    return undefined;
}
/** If encryption is not available, throw */
function validateEncryptionAvailable() {
    const reason = getReasonEncryptionIsNotAvailable();
    if (reason) {
        throw new Error(reason);
    }
}
async function isEncryptionAvailable() {
    return getReasonEncryptionIsNotAvailable() === undefined;
}
async function encryptString(text) {
    validateEncryptionAvailable();
    const buffer = electron__WEBPACK_IMPORTED_MODULE_2__.safeStorage.encryptString(text);
    return buffer.toString('base64');
}
async function decryptString(encryptedText) {
    validateEncryptionAvailable();
    const buffer = Buffer.from(encryptedText, 'base64');
    return electron__WEBPACK_IMPORTED_MODULE_2__.safeStorage.decryptString(buffer);
}
const dataProtectionService = {
    isEncryptionAvailable,
    encryptString,
    decryptString,
};
/** Register the network object that backs this service */
async function startDataProtectionService() {
    await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_1__.networkObjectService.set(_shared_models_data_protection_service_model__WEBPACK_IMPORTED_MODULE_0__.dataProtectionServiceNetworkObjectName, dataProtectionService);
}


/***/ }),

/***/ "./src/main/services/dotnet-data-provider.service.ts":
/*!***********************************************************!*\
  !*** ./src/main/services/dotnet-data-provider.service.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   dotnetDataProvider: () => (/* binding */ dotnetDataProvider)
/* harmony export */ });
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ "child_process");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/services/logger.service */ "./src/shared/services/logger.service.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");




/** Pretty name for the process this service manages. Used in logs */
const DOTNET_DATA_PROVIDER_NAME = 'dotnet data provider';
let dotnet;
let resolveClose;
const closePromise = new Promise((resolve) => {
    resolveClose = resolve;
});
// log functions for inside the data provider process
function logProcessError(message) {
    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__.logger.error((0,_shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__.formatLog)(message?.toString() || '', DOTNET_DATA_PROVIDER_NAME, 'error'));
}
function logProcessInfo(message) {
    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__.logger.info((0,_shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__.formatLog)(message?.toString() || '', DOTNET_DATA_PROVIDER_NAME));
}
/** Hard kills the Dotnet Data Provider. */
// TODO: add a more elegant shutdown to avoid this if we possibly can
function killDotnetDataProvider() {
    if (!dotnet)
        return;
    if (dotnet.kill()) {
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__.logger.info('killed dotnet data provider');
    }
    else {
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__.logger.error('dotnet data provider was not stopped! Investigate other .kill() options');
    }
    dotnet?.stderr?.removeListener('data', logProcessError);
    dotnet?.stdout?.removeListener('data', logProcessInfo);
    dotnet = undefined;
}
async function waitForDotnetDataProvider(maxWaitTimeInMS) {
    const didClose = await (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__.waitForDuration)(async () => {
        await closePromise;
        return true;
    }, maxWaitTimeInMS);
    if (!didClose)
        killDotnetDataProvider();
}
/** Starts the Dotnet Data Provider if it isn't already running. */
function startDotnetDataProvider() {
    if (dotnet)
        return;
    // default values for development
    let command = 'dotnet';
    let args = ['watch', '--project', 'c-sharp/ParanextDataProvider.csproj'];
    let options;
    if (globalThis.isPackaged) {
        const dotnetPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.resourcesPath, 'dotnet');
        if (process.platform === 'win32') {
            command = path__WEBPACK_IMPORTED_MODULE_1___default().join(dotnetPath, 'ParanextDataProvider.exe');
            args = [];
        }
        else {
            command = path__WEBPACK_IMPORTED_MODULE_1___default().join(dotnetPath, 'ParanextDataProvider');
            args = [];
        }
        options = { cwd: dotnetPath };
    }
    dotnet = (0,child_process__WEBPACK_IMPORTED_MODULE_0__.spawn)(command, args, options);
    dotnet.stdout.on('data', logProcessInfo);
    dotnet.stderr.on('data', logProcessError);
    dotnet.once('exit', (code, signal) => {
        if (signal) {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__.logger.info(`'exit' event: dotnet data provider terminated with signal ${signal}`);
        }
        else {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__.logger.info(`'exit' event: dotnet data provider exited with code ${code}`);
        }
        dotnet?.stderr?.removeListener('data', logProcessError);
        dotnet?.stdout?.removeListener('data', logProcessInfo);
        dotnet = undefined;
        resolveClose();
    });
    dotnet.once('close', (code, signal) => {
        // In production, this handles the closing of the data provider. However, in development,
        // this is handling the closing of the dotnet watcher.
        if (signal) {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__.logger.info(`'close' event: dotnet data provider terminated with signal ${signal}`);
        }
        else {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__.logger.info(`'close' event: dotnet data provider exited with code ${code}`);
        }
        dotnet?.stderr?.removeListener('data', logProcessError);
        dotnet?.stdout?.removeListener('data', logProcessInfo);
        dotnet = undefined;
        resolveClose();
    });
}
const dotnetDataProvider = {
    start: startDotnetDataProvider,
    kill: killDotnetDataProvider,
    waitForClose: waitForDotnetDataProvider,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dotnetDataProvider);


/***/ }),

/***/ "./src/main/services/extension-asset-protocol.service.ts":
/*!***************************************************************!*\
  !*** ./src/main/services/extension-asset-protocol.service.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   extensionAssetProtocolService: () => (/* binding */ extensionAssetProtocolService)
/* harmony export */ });
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var http_status_codes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! http-status-codes */ "./node_modules/http-status-codes/build/es/status-codes.js");
/* harmony import */ var _shared_services_extension_asset_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/services/extension-asset.service */ "./src/shared/services/extension-asset.service.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");




/** Here some of the most common MIME types that we expect to handle */
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
// An example of a more complete list: https://www.freeformatter.com/mime-types-list.html
const knownMimeTypes = {
    '.bmp': 'image/bmp',
    '.css': 'text/css',
    '.csv': 'text/csv',
    '.gif': 'image/gif',
    '.htm': 'text/html',
    '.html': 'text/html',
    '.ico': 'image/vnd.microsoft.icon',
    '.jpeg': 'image/jpeg',
    '.jpg': 'image/jpeg',
    '.js': 'text/javascript',
    '.json': 'application/json',
    '.mjs': 'text/javascript',
    '.mp3': 'audio/mpeg',
    '.mp4': 'video/mp4',
    '.mpeg': 'video/mpeg',
    '.png': 'image/png',
    '.svg': 'image/svg+xml',
    '.txt': 'text/plain',
    '.wav': 'audio/wav',
};
/** Lookup the MIME type to pass back to the renderer */
function getMimeTypeForFileName(fileName) {
    const dotIndex = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.lastIndexOf)(fileName, '.');
    if (dotIndex > 0) {
        const fileType = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.substring)(fileName, dotIndex);
        // Assert key type confirmed in check.
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        if (fileType in knownMimeTypes)
            return knownMimeTypes[fileType];
    }
    // Default if we don't find something else
    return 'application/octet-stream';
}
/** Create an HTTP response to pass back to the renderer */
function errorResponse(url, httpErrorNumber) {
    return new Response(`Failed to load resource: ${url}`, {
        status: httpErrorNumber,
        headers: {
            'Content-Type': 'text/plain',
        },
    });
}
const protocolName = 'papi-extension';
/** Promise that resolves when this service is finished initializing */
let initializePromise;
/** Register the protocol handler for extension asset loading */
const initialize = () => {
    if (initializePromise)
        return initializePromise;
    initializePromise = (async () => {
        electron__WEBPACK_IMPORTED_MODULE_0__.protocol.handle(protocolName, async (request) => {
            // Ideas to consider:
            // 1) Check the referer for localhost to block arbitrary internet content from getting extension assets.
            // 2) Use request headers to pass along the extension name so extension code doesn't have to embed its name in URLs.
            // Remove "papi-extension://" from the front of the URL
            const uri = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.substring)(request.url, (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.stringLength)(`${protocolName}://`));
            // There have to be at least 2 parts to the URI divided by a slash
            if (!(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.includes)(uri, '/')) {
                return errorResponse(request.url, http_status_codes__WEBPACK_IMPORTED_MODULE_3__.StatusCodes.BAD_REQUEST);
            }
            const slash = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.indexOf)(uri, '/');
            let extension = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.substring)(uri, 0, slash);
            let asset = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.substring)(uri, slash + 1);
            if (!extension || !asset) {
                return errorResponse(request.url, http_status_codes__WEBPACK_IMPORTED_MODULE_3__.StatusCodes.BAD_REQUEST);
            }
            // It's possible the extension and/or asset were encoded because they have characters not
            // allowed in URLs. So let's decode both of them before passing them to the extension host.
            extension = decodeURIComponent(extension);
            asset = decodeURIComponent(asset);
            if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.stringLength)(extension) > 100 || (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.stringLength)(asset) > 100) {
                return errorResponse(request.url, http_status_codes__WEBPACK_IMPORTED_MODULE_3__.StatusCodes.BAD_REQUEST);
            }
            // Actually get the data
            const base64Data = await _shared_services_extension_asset_service__WEBPACK_IMPORTED_MODULE_1__.extensionAssetService.getExtensionAsset(extension, asset);
            if (!base64Data) {
                return errorResponse(request.url, http_status_codes__WEBPACK_IMPORTED_MODULE_3__.StatusCodes.NOT_FOUND);
            }
            // Pass back the data to the renderer
            return new Response(Buffer.from(base64Data, 'base64'), {
                status: http_status_codes__WEBPACK_IMPORTED_MODULE_3__.StatusCodes.OK,
                headers: {
                    'Content-Type': getMimeTypeForFileName(asset),
                },
            });
        });
    })();
    return initializePromise;
};
/**
 * Initialize a handler for protocol strings like the following:
 *
 * - `papi-extension://extension-name/assets/asset.xyz` -> load "asset.xyz" from "assets" directory in
 *   "extension-name"
 * - `papi-extension://extension-name/assets/subdirectory/asset.xyz` -> load "asset.xyz" from
 *   "assets/subdirectory" directory in "extension-name"
 */
const extensionAssetProtocolService = {
    initialize,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (extensionAssetProtocolService);


/***/ }),

/***/ "./src/main/services/extension-host.service.ts":
/*!*****************************************************!*\
  !*** ./src/main/services/extension-host.service.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   extensionHostService: () => (/* binding */ extensionHostService)
/* harmony export */ });
/* harmony import */ var _node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @node/utils/command-line.util */ "./src/node/utils/command-line.util.ts");
/* harmony import */ var _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/services/logger.service */ "./src/shared/services/logger.service.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! child_process */ "child_process");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fs/promises */ "fs/promises");
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _node_models_interprocess_messages_model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @node/models/interprocess-messages.model */ "./src/node/models/interprocess-messages.model.ts");
/** Service that runs the extension-host process from the main file */








/** Pretty name for the process this service manages. Used in logs */
const EXTENSION_HOST_NAME = 'extension host';
let processInstanceCounter = 0;
// Resolves to the current process instance counter value for debug logging purposes
let processLifetimeVariable;
let extensionHost;
function createNewProcessLifetimeVariable() {
    if (processLifetimeVariable)
        throw new Error('Previous instance of the extension host process was not cleaned up');
    processInstanceCounter += 1;
    processLifetimeVariable = new platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.AsyncVariable(`extension host shutting down #${processInstanceCounter.toString()}`, -1);
}
function resolveProcessLifetimeVariable() {
    if (!processLifetimeVariable)
        throw new Error('Extension host process tracking was not properly initialized');
    processLifetimeVariable.resolveToValue(processInstanceCounter);
    processLifetimeVariable = undefined;
}
// log functions for inside the extension host process
function logProcessError(message) {
    let msg = message?.toString() ?? '';
    if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.includes)(msg, _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.WARN_TAG)) {
        msg = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.split)(msg, _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.WARN_TAG).join('');
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.warn((0,_shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.formatLog)(msg, EXTENSION_HOST_NAME, 'warning'));
    }
    else
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.error((0,_shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.formatLog)(msg, EXTENSION_HOST_NAME, 'error'));
}
function logProcessInfo(message) {
    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.info((0,_shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.formatLog)(message?.toString() ?? '', EXTENSION_HOST_NAME));
}
async function waitForExtensionHost(maxWaitTimeInMS) {
    let didExit = await (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.waitForDuration)(async () => {
        if (!processLifetimeVariable) {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.warn('Extension host process lifetime variable was not initialized');
            return false;
        }
        // This does nothing in development because nodemon is in the way, but the hard kill will work
        extensionHost?.send(_node_models_interprocess_messages_model__WEBPACK_IMPORTED_MODULE_7__.gracefulShutdownMessage, (error) => {
            if (error)
                _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.warn(`Error sending graceful shutdown message: ${error}`);
        });
        await processLifetimeVariable.promise;
        return true;
    }, maxWaitTimeInMS / 2);
    if (!didExit)
        hardKillExtensionHost();
    // Give the hard "kill" time to complete before returning so we don't restart too soon
    didExit = await (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.waitForDuration)(async () => {
        if (processLifetimeVariable)
            await processLifetimeVariable.promise;
        return true;
    }, maxWaitTimeInMS / 2);
    if (!didExit)
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.warn(`Extension host did not exit within ${maxWaitTimeInMS.toString()} ms`);
}
async function restartExtensionHost(maxWaitTimeInMS) {
    if (globalThis.isPackaged) {
        await waitForExtensionHost(maxWaitTimeInMS);
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.debug('Extension host closed, restarting now');
        return startExtensionHost();
    }
    // Tells nodemon to restart the process https://github.com/remy/nodemon/blob/HEAD/doc/events.md#using-nodemon-as-child-process
    extensionHost?.send('restart');
}
function hardKillExtensionHost() {
    if (!extensionHost)
        return;
    // On POSIX systems, SIGKILL should immediately terminate the process by the OS.
    // On Windows the signal is ignored. Node.js tries to hard kill the process in some other way.
    if (extensionHost.kill('SIGKILL')) {
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.info('signal sent to kill extension host process');
    }
    else {
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.error('extension host process was not stopped! Investigate other .kill() options');
    }
    extensionHost?.stderr?.removeListener('data', logProcessError);
    extensionHost?.stdout?.removeListener('data', logProcessInfo);
    extensionHost = undefined;
}
/**
 * Returns an array of the command-line arguments to forward from main (when launching paranext) to
 * the extension host process.
 */
function getCommandLineArgumentsToForward() {
    // Pass through the relevant command-line arguments to the extension host
    return [
        ...(0,_node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__.getCommandLineArgumentsGroup)(_node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__.COMMAND_LINE_ARGS.Extensions, true),
        ...(0,_node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__.getCommandLineArgumentsGroup)(_node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__.COMMAND_LINE_ARGS.ExtensionsDir, true),
    ];
}
/**
 * Read the contents of a JSON file.
 *
 * @param filePath - A path to a file. If a URL is provided, it must use the file: protocol. If a
 *   FileHandle is provided, the underlying file will not be closed automatically.
 * @returns The JSON file contents.
 * @see https://stackoverflow.com/questions/70601733/dynamic-import-with-json-file-doesnt-work-typescript
 */
async function readJsonFile(filePath) {
    const file = await (0,fs_promises__WEBPACK_IMPORTED_MODULE_5__.readFile)(filePath, 'utf8');
    return JSON.parse(file);
}
/** Starts the extension host process if it isn't already running. */
async function startExtensionHost() {
    if (extensionHost)
        return;
    createNewProcessLifetimeVariable();
    // In production, fork a new process for the extension host
    // In development, spawn nodemon to watch the extension-host
    /** Arguments that will be passed to the extension host no matter how we start the process */
    const sharedArgs = [
        _node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__.commandLineArgumentsAliases[_node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__.COMMAND_LINE_ARGS.ResourcesPath][0],
        globalThis.resourcesPath,
        _node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__.commandLineArgumentsAliases[_node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__.COMMAND_LINE_ARGS.LogLevel][0],
        globalThis.logLevel,
        ...getCommandLineArgumentsToForward(),
    ];
    if (electron__WEBPACK_IMPORTED_MODULE_4__.app.isPackaged) {
        extensionHost = (0,child_process__WEBPACK_IMPORTED_MODULE_3__.fork)(path__WEBPACK_IMPORTED_MODULE_6___default().join(__dirname, '../extension-host/extension-host.js'), [
            _node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__.commandLineArgumentsAliases[_node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__.COMMAND_LINE_ARGS.Packaged][0],
            ...(process.env.PORTABLE_EXECUTABLE_FILE
                ? [_node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__.commandLineArgumentsAliases[_node_utils_command_line_util__WEBPACK_IMPORTED_MODULE_0__.COMMAND_LINE_ARGS.Portable][0]]
                : []),
            ...sharedArgs,
        ], {
            stdio: ['ignore', 'pipe', 'pipe', 'ipc'],
        });
    }
    else {
        // If we are in development, get the nodemon watch config so we can pass it in along with the
        // external extension directories.
        // For this dev-only code, it is useful to be able to get the nodemon.json file.
        const nodemonConfig = await readJsonFile(path__WEBPACK_IMPORTED_MODULE_6___default().join(globalThis.resourcesPath, 'nodemon.json'));
        const nodemonWatchPaths = nodemonConfig?.watch ? nodemonConfig.watch : [];
        extensionHost = (0,child_process__WEBPACK_IMPORTED_MODULE_3__.spawn)('node', [
            'node_modules/nodemon/bin/nodemon.js',
            // Provide the nodemon config paths and command-line argument extension paths as watch
            // directories for nodemon
            ...nodemonWatchPaths.flatMap((watchPath) => ['--watch', watchPath]),
            '--transpile-only',
            './src/extension-host/extension-host.ts',
            '--',
            ...sharedArgs,
        ], {
            stdio: ['ignore', 'pipe', 'pipe', 'ipc'],
            env: { ...process.env, NODE_ENV: 'development' },
        });
    }
    if (!extensionHost.stderr || !extensionHost.stdout)
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.error("Could not connect to extension host's stderr or stdout! You will not see extension host console logs here.");
    else {
        extensionHost.stderr.on('data', logProcessError);
        extensionHost.stdout.on('data', logProcessInfo);
    }
    extensionHost.once('exit', (code, signal) => {
        if (signal) {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.info(`'exit' event: extension host process terminated with signal ${signal}`);
        }
        else {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.info(`'exit' event: extension host process exited with code ${code}`);
        }
        extensionHost?.stderr?.removeListener('data', logProcessError);
        extensionHost?.stdout?.removeListener('data', logProcessInfo);
        extensionHost = undefined;
        resolveProcessLifetimeVariable();
    });
}
/** Service that runs the extension-host process from the main file */
const extensionHostService = {
    start: startExtensionHost,
    kill: hardKillExtensionHost,
    waitForClose: waitForExtensionHost,
    restart: restartExtensionHost,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (extensionHostService);


/***/ }),

/***/ "./src/main/services/network-object-status.service-host.ts":
/*!*****************************************************************!*\
  !*** ./src/main/services/network-object-status.service-host.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startNetworkObjectStatusService: () => (/* binding */ startNetworkObjectStatusService)
/* harmony export */ });
/* harmony import */ var _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/services/logger.service */ "./src/shared/services/logger.service.ts");
/* harmony import */ var _shared_models_network_object_status_service_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/models/network-object-status.service-model */ "./src/shared/models/network-object-status.service-model.ts");
/* harmony import */ var _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/services/network-object.service */ "./src/shared/services/network-object.service.ts");



// We are assuming these events get hooked up before any network objects get registered. That allows
// us to start from a clean map. If somehow network objects can be registered before we hook up
// the events, then we have to figure out a way to insert pre-existing objects into the map in a way
// that avoids race conditions with the events that fire around the same time.
const networkObjectIDsToDetails = new Map();
(0,_shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_2__.onDidCreateNetworkObject)((networkObjectDetails) => {
    if (networkObjectIDsToDetails.has(networkObjectDetails.id))
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Re-saving network object details for ${networkObjectDetails.id}`);
    networkObjectIDsToDetails.set(networkObjectDetails.id, networkObjectDetails);
});
(0,_shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_2__.onDidDisposeNetworkObject)((networkObjectId) => {
    if (!networkObjectIDsToDetails.delete(networkObjectId))
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Notification of disposed object ${networkObjectId} that was previously unknown`);
});
// Making this async to align with the service model even though it could really be synchronous
async function getAllNetworkObjectDetails() {
    const allNetworkObjectDetails = {};
    networkObjectIDsToDetails.forEach((value, key) => {
        allNetworkObjectDetails[key] = value;
    });
    return Promise.resolve(allNetworkObjectDetails);
}
const networkObjectStatusService = {
    getAllNetworkObjectDetails,
};
/** Register the network object that backs the network object status service */
async function startNetworkObjectStatusService() {
    await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_2__.networkObjectService.set(_shared_models_network_object_status_service_model__WEBPACK_IMPORTED_MODULE_1__.networkObjectStatusServiceNetworkObjectName, networkObjectStatusService);
}


/***/ }),

/***/ "./src/main/services/project-lookup.service-host.ts":
/*!**********************************************************!*\
  !*** ./src/main/services/project-lookup.service-host.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startProjectLookupService: () => (/* binding */ startProjectLookupService)
/* harmony export */ });
/* harmony import */ var _shared_models_project_lookup_service_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/models/project-lookup.service-model */ "./src/shared/models/project-lookup.service-model.ts");
/* harmony import */ var _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/services/network-object.service */ "./src/shared/services/network-object.service.ts");


const projectLookupService = _shared_models_project_lookup_service_model__WEBPACK_IMPORTED_MODULE_0__.projectLookupServiceBase;
/**
 * Register the network object that mirrors the locally-run project lookup service exposed on the
 * PAPI websocket.
 *
 * This service runs fully locally from `project-lookup.service.ts`. This is here to provide
 * lookup-related services to other processes on the PAPI websocket
 */
// To use this service, you should use `project-lookup.service.ts`.
async function startProjectLookupService() {
    await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_1__.networkObjectService.set(_shared_models_project_lookup_service_model__WEBPACK_IMPORTED_MODULE_0__.NETWORK_OBJECT_NAME_PROJECT_LOOKUP_SERVICE, projectLookupService, undefined, undefined, {
        summary: 'Provides metadata for projects known by the platform',
        methods: [
            {
                name: 'getMetadataForAllProjects',
                summary: 'Provide metadata for all projects that have PDP factories',
                description: 'Note: If there are multiple PDPs available whose metadata matches the conditions provided by the parameters, their project metadata will all be combined, so all available `projectInterface`s provided by the PDP Factory with the matching ID (or all PDP Factories if no ID is specified) for the project will be returned.',
                params: [
                    {
                        name: 'options',
                        required: false,
                        summary: 'Options for specifying filters for the project metadata retrieved. If a PDP Factory ID does not match the filter, it will not be contacted at all for this function call. As a result, a PDP factory that intends to layer over other PDP factories **must** specify its ID in `options.excludePdpFactoryIds` to avoid an infinite loop of calling this function.',
                        schema: {
                            $ref: '#/components/schemas/ProjectMetadataFilterOptions',
                        },
                    },
                ],
                result: {
                    name: 'return value',
                    schema: {
                        type: 'array',
                        items: {
                            $ref: '#/components/schemas/ProjectMetadata',
                        },
                    },
                },
            },
        ],
        components: {
            schemas: {
                ProjectMetadata: {
                    type: 'object',
                    properties: {
                        id: {
                            type: 'string',
                            description: 'ID of the project (must be unique and case insensitive)',
                        },
                        projectInterfaces: {
                            type: 'array',
                            description: 'All `projectInterface`s (aka standardized sets of methods on a PDP) that Project Data Providers for this project support. Indicates what sort of project data should be available on this project.',
                            items: { type: 'string' },
                        },
                        pdpFactoryInfo: {
                            type: 'object',
                            description: 'Information about the PDP Factories associated with the project.',
                        },
                    },
                },
                ProjectMetadataFilterOptions: {
                    type: 'object',
                    properties: {
                        includePdpFactoryIds: {
                            type: 'array',
                            items: {
                                type: 'string',
                            },
                            description: 'List of PDP Factory Ids to include in the metadata retrieval.',
                        },
                        excludePdpFactoryIds: {
                            type: 'array',
                            items: {
                                type: 'string',
                            },
                            description: 'List of PDP Factory Ids to exclude from the metadata retrieval.',
                        },
                        projectIds: {
                            type: 'array',
                            items: {
                                type: 'string',
                            },
                            description: 'List of project Ids to filter the metadata retrieval.',
                        },
                    },
                    additionalProperties: false,
                    description: 'Options for specifying filters for the project metadata retrieved.',
                },
            },
        },
    });
}


/***/ }),

/***/ "./src/node/models/interprocess-messages.model.ts":
/*!********************************************************!*\
  !*** ./src/node/models/interprocess-messages.model.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gracefulShutdownMessage: () => (/* binding */ gracefulShutdownMessage),
/* harmony export */   heartbeatMessage: () => (/* binding */ heartbeatMessage)
/* harmony export */ });
const gracefulShutdownMessage = 'gracefulShutdown';
const heartbeatMessage = 'heartbeat';


/***/ }),

/***/ "./src/node/polyfills/local-storage.polyfill.ts":
/*!******************************************************!*\
  !*** ./src/node/polyfills/local-storage.polyfill.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   polyfillLocalStorage: () => (/* binding */ polyfillLocalStorage)
/* harmony export */ });
/* harmony import */ var _node_utils_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @node/utils/util */ "./src/node/utils/util.ts");
/* harmony import */ var node_localstorage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-localstorage */ "./node_modules/node-localstorage/LocalStorage.js");
/* harmony import */ var node_localstorage__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_localstorage__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);



/** Polyfills LocalStorage into node so you can use localstorage just like in a browser */
const polyfillLocalStorage = () => {
    // Polyfill logic needs null
    // eslint-disable-next-line no-null/no-null
    if (typeof localStorage === 'undefined' || localStorage === null) {
        global.localStorage = new node_localstorage__WEBPACK_IMPORTED_MODULE_1__.LocalStorage(path__WEBPACK_IMPORTED_MODULE_2___default().join((0,_node_utils_util__WEBPACK_IMPORTED_MODULE_0__.getAppDir)(), `local-storage/${globalThis.processType}/`));
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (polyfillLocalStorage);


/***/ }),

/***/ "./src/node/services/extension.service-model.ts":
/*!******************************************************!*\
  !*** ./src/node/services/extension.service-model.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CATEGORY_EXTENSION_SERVICE: () => (/* binding */ CATEGORY_EXTENSION_SERVICE),
/* harmony export */   HANDLE_URI_REQUEST_TYPE: () => (/* binding */ HANDLE_URI_REQUEST_TYPE)
/* harmony export */ });
/* harmony import */ var _shared_utils_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/utils/util */ "./src/shared/utils/util.ts");

/** Prefix on requests that indicates that the request is related to extension service operations */
const CATEGORY_EXTENSION_SERVICE = 'extensionService';
/** Serialized request type for request sent from main to extension service to handle a uri redirect */
const HANDLE_URI_REQUEST_TYPE = (0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_0__.serializeRequestType)(CATEGORY_EXTENSION_SERVICE, 'handleUri');


/***/ }),

/***/ "./src/node/utils/command-line.util.ts":
/*!*********************************************!*\
  !*** ./src/node/utils/command-line.util.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COMMAND_LINE_ARGS: () => (/* binding */ COMMAND_LINE_ARGS),
/* harmony export */   commandLineArgumentsAliases: () => (/* binding */ commandLineArgumentsAliases),
/* harmony export */   findNextCommandLineArgumentIndex: () => (/* binding */ findNextCommandLineArgumentIndex),
/* harmony export */   getCommandLineArgument: () => (/* binding */ getCommandLineArgument),
/* harmony export */   getCommandLineArgumentsGroup: () => (/* binding */ getCommandLineArgumentsGroup),
/* harmony export */   getCommandLineSwitch: () => (/* binding */ getCommandLineSwitch)
/* harmony export */ });
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");

/**
 * Command Line Arguments
 *
 * - Extensions - Command-line argument that specifies extra individual extension folders
 * - ExtensionsDir - Command-line argument that specifies extra extension directories in which to
 *   check all contained folders for extensions
 * - LogLevel - Command-line argument that specifies log level to use Options: 'error' | 'warn' |
 *   'info' | 'verbose' | 'debug'
 * - ResourcesPath - Command-line argument that specifies the path to the resources folder
 * - Packaged - Command-line switch that specifies if the application is packaged. Only on
 *   extension-host
 * - Portable - Command-line switch that specifies if the application is a windows portable app. Only
 *   on extension-host
 */
var COMMAND_LINE_ARGS;
(function (COMMAND_LINE_ARGS) {
    COMMAND_LINE_ARGS["Extensions"] = "extensions";
    COMMAND_LINE_ARGS["ExtensionsDir"] = "extensions_dir";
    COMMAND_LINE_ARGS["LogLevel"] = "log_level";
    COMMAND_LINE_ARGS["ResourcesPath"] = "resources_path";
    COMMAND_LINE_ARGS["Packaged"] = "packaged";
    COMMAND_LINE_ARGS["Portable"] = "portable";
})(COMMAND_LINE_ARGS || (COMMAND_LINE_ARGS = {}));
/**
 * Aliases for each command line argument mapped from argument type to an array of aliases for that
 * argument type
 */
const commandLineArgumentsAliases = {
    [COMMAND_LINE_ARGS.Extensions]: ['--extensions', '--extension', '-e'],
    [COMMAND_LINE_ARGS.ExtensionsDir]: ['--extensionDirs', '--extensionDir', '-d'],
    [COMMAND_LINE_ARGS.LogLevel]: ['--logLevels', '--logLevel', '-l'],
    [COMMAND_LINE_ARGS.ResourcesPath]: ['--resourcesPath', '--resourcePath', '-r'],
    [COMMAND_LINE_ARGS.Packaged]: ['--packaged', '--isPackaged', '-p'],
    [COMMAND_LINE_ARGS.Portable]: ['--portable'],
};
/** Get the index of the next command-line argument after the startIndex */
function findNextCommandLineArgumentIndex(currentArgIndex) {
    let endOfExtensionsIndex = process.argv.length;
    for (let i = currentArgIndex + 1; i < process.argv.length; i++)
        if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_0__.startsWith)(process.argv[i], '-')) {
            endOfExtensionsIndex = i;
            break;
        }
    return endOfExtensionsIndex;
}
/**
 * Get a command-line argument's group of arguments. If no arguments are in its group, return
 * nothing
 *
 * @param argName Name(s) of the command-line argument to search for
 * @param shouldIncludeArgName Whether to include `argName` at the start of the returned array
 * @returns Array of strings of the command-line args in this command-line argument group
 *
 *   Ex: '--things ben chuck jerry'
 *
 *   - `getCommandLineArgumentsGroup('--things')` returns `['ben', 'chuck', 'jerry']`
 *   - `getCommandLineArgumentsGroup('--things', true)` returns `['--things', 'ben', 'chuck', 'jerry']`
 *
 *   Ex: '--things --stuff ben chuck jerry'
 *
 *   - `getCommandLineArgumentsGroup('--things')` returns `[]`
 *   - `getCommandLineArgumentsGroup('--things', true)` returns `['--things']`
 *
 *   Ex: '--stuff ben chuck jerry'
 *
 *   - `getCommandLineArgumentsGroup('--things')` returns `[]`
 *   - `getCommandLineArgumentsGroup('--things', true)` returns `[]`
 */
function getCommandLineArgumentsGroup(argName, shouldIncludeArgName = false) {
    const argNames = commandLineArgumentsAliases[argName];
    const argumentsGroup = [];
    argNames
        .filter((n) => process.argv.indexOf(n) >= 0)
        .forEach((arg) => {
        const argIndex = process.argv.indexOf(arg);
        const baseArray = shouldIncludeArgName ? [arg] : [];
        argumentsGroup.push(...(process.argv.length > argIndex + 1
            ? [
                ...baseArray,
                ...process.argv.slice(argIndex + 1, findNextCommandLineArgumentIndex(argIndex)),
            ]
            : baseArray));
    });
    return argumentsGroup;
}
/**
 * Get a command-line argument's argument. If the argument is not present, return `undefined`
 *
 * @param argName Name and aliases of the command-line argument to search for
 * @returns String of the command-line arg provided
 *
 *   Ex: '--thing ben'
 *
 *   - `getCommandLineArgument('--thing')` returns `'ben'`
 */
function getCommandLineArgument(argName) {
    // TODO: If argName has two hyphens, check for single hyphen and first char + capitals if
    // two-hyphen version does not exist. eg --extensionDirs -> -ed
    const argNames = commandLineArgumentsAliases[argName];
    const argIndices = argNames.map((name) => process.argv.indexOf(name));
    const argIndex = argIndices.find((index) => 
    // Will be negative if not found
    index >= 0 &&
        //  Ensuring it is not the last argument (the arg name was found, but there is no actual argument provided)
        index < process.argv.length - 1 &&
        // If the next word is also an arg name, there was no actual argument provided
        findNextCommandLineArgumentIndex(index) !== index + 1);
    if (argIndex === undefined)
        return undefined;
    return process.argv[argIndex + 1];
}
/**
 * Determine whether a command-line argument name is present
 *
 * (a switch is a command-line argument without a value - just a boolean)
 *
 * @param argName Name of the switch to look for
 * @returns True if present, false otherwise
 *
 *   Ex: '--thing --stuff bologna'
 *
 *   - `getCommandLineSwitch('--thing')` returns `true`
 */
function getCommandLineSwitch(argName) {
    const argNames = commandLineArgumentsAliases[argName];
    return argNames.some((alias) => process.argv.includes(alias));
}


/***/ }),

/***/ "./src/node/utils/util.ts":
/*!********************************!*\
  !*** ./src/node/utils/util.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FILE_PROTOCOL: () => (/* binding */ FILE_PROTOCOL),
/* harmony export */   RESOURCES_PROTOCOL: () => (/* binding */ RESOURCES_PROTOCOL),
/* harmony export */   getAppDir: () => (/* binding */ getAppDir),
/* harmony export */   getPathFromUri: () => (/* binding */ getPathFromUri),
/* harmony export */   isNoisyDevModeEnvVariableSet: () => (/* binding */ isNoisyDevModeEnvVariableSet),
/* harmony export */   joinUriPaths: () => (/* binding */ joinUriPaths),
/* harmony export */   resolveHtmlPath: () => (/* binding */ resolveHtmlPath)
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "url");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! os */ "os");
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");
/** Utilities useful for node processes */





// FOR SCHEME DOCUMENTATION, SEE Uri JSDOC
const APP_SCHEME = 'app';
const CACHE_SCHEME = 'cache';
const CACHE_DIR_NAME = CACHE_SCHEME;
const DATA_SCHEME = 'data';
const DATA_DIR_NAME = DATA_SCHEME;
const RESOURCES_SCHEME = 'resources';
const FILE_SCHEME = 'file';
const PROTOCOL_PART = '://';
const FILE_PROTOCOL = `${FILE_SCHEME}${PROTOCOL_PART}`;
const RESOURCES_PROTOCOL = `${RESOURCES_SCHEME}${PROTOCOL_PART}`;
function resolveHtmlPath(htmlFileName) {
    if (true) {
        const port = process.env.PORT || 1212;
        const url = new url__WEBPACK_IMPORTED_MODULE_0__.URL(`http://localhost:${port}`);
        url.pathname = htmlFileName;
        return url.href;
    }
    return `${FILE_PROTOCOL}${path__WEBPACK_IMPORTED_MODULE_1___default().resolve(__dirname, '../renderer/', htmlFileName)}`;
}
/**
 * Gets the platform-specific user Platform.Bible folder for this application
 *
 * When running in development: `<repo_directory>/dev-appdata`
 *
 * When packaged: `<user_home_directory>/.platform.bible`
 */
const getAppDir = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__["default"])(() => {
    return globalThis.isPackaged
        ? path__WEBPACK_IMPORTED_MODULE_1___default().join(os__WEBPACK_IMPORTED_MODULE_2___default().homedir(), '/.platform.bible')
        : path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, '../../../dev-appdata');
});
// FOR SCHEME DOCUMENTATION, SEE Uri JSDOC
/** Get a mapping from scheme to the absolute path to that scheme. */
// TODO: this is currently lazy-loaded because globalThis doesn't get populated until after this
// file is imported. Fix this to be a normal object after fixing globalThis import dependencies.
const getSchemePaths = (0,memoize_one__WEBPACK_IMPORTED_MODULE_4__["default"])(() => {
    const appDir = getAppDir();
    return {
        [APP_SCHEME]: appDir,
        [CACHE_SCHEME]: path__WEBPACK_IMPORTED_MODULE_1___default().join(appDir, CACHE_DIR_NAME),
        [DATA_SCHEME]: path__WEBPACK_IMPORTED_MODULE_1___default().join(appDir, DATA_DIR_NAME),
        [RESOURCES_SCHEME]: globalThis.resourcesPath,
        [FILE_SCHEME]: '',
    };
});
/** Parse a URI from a string into its original parts. */
// TODO: Make URI an actual class. Will be challenging when passing through WebSocket
function getPathInfoFromUri(uri) {
    // Add app scheme to the uri if it doesn't have one
    const fullUri = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__.includes)(uri, PROTOCOL_PART) ? uri : `${APP_SCHEME}${PROTOCOL_PART}${uri}`;
    const [scheme, uriPath] = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__.split)(fullUri, PROTOCOL_PART);
    return {
        scheme,
        uriPath,
    };
}
/**
 * Resolves the uri to a path
 *
 * @param uri The uri to resolve
 * @returns Real path to the uri supplied
 */
function getPathFromUri(uri) {
    const { scheme, uriPath } = getPathInfoFromUri(uri);
    return path__WEBPACK_IMPORTED_MODULE_1___default().join(getSchemePaths()[scheme], uriPath);
}
/**
 * Combines the uri passed in with the paths passed in to make one uri
 *
 * @param uri Uri to start from
 * @param paths Paths to combine into the uri
 * @returns One uri that combines the uri and the paths in left-to-right order
 */
function joinUriPaths(uri, ...paths) {
    const { scheme, uriPath } = getPathInfoFromUri(uri);
    return `${scheme}${PROTOCOL_PART}${path__WEBPACK_IMPORTED_MODULE_1___default().join(uriPath, ...paths)}`;
}
/**
 * Determines if running in noisy dev mode
 *
 * @returns True if the process is running in noisy dev mode, false otherwise
 */
const isNoisyDevModeEnvVariableSet = () => !!process.env.DEV_NOISY && process.env.DEV_NOISY === 'true';


/***/ }),

/***/ "./src/shared/data/platform-bible-menu.commands.ts":
/*!*********************************************************!*\
  !*** ./src/shared/data/platform-bible-menu.commands.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   handleMenuCommand: () => (/* binding */ handleMenuCommand)
/* harmony export */ });
/* harmony import */ var _shared_services_command_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/services/command.service */ "./src/shared/services/command.service.ts");
/* harmony import */ var _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/services/logger.service */ "./src/shared/services/logger.service.ts");


/**
 * Run a command from a menu
 *
 * @param command Info about the command to run
 * @param tabId The id of the dock layout tab on which the menu command is being run (if the tab is
 *   a web view, this is the same as the web view id) or `undefined` if run from the top menu
 */
function handleMenuCommand(command, tabId) {
    switch (command.command) {
        case 'platform.openProjectDialog':
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.info(`Open Project Dialog. tabId: ${tabId}`);
            break;
        case 'platform.openDownloadUpdateProjectDialog':
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.info(`Download/Update Project Dialog. tabId: ${tabId}`);
            break;
        case 'platform.downloadAndInstallResources':
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.info(`TODO: display UI to select resources. tabId: ${tabId}`);
            break;
        case 'platform.openTextCollection':
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.info(`TODO: display text collection modal. tabId: ${tabId}`);
            break;
        case 'platform.visitSupportPage':
            (async () => {
                try {
                    // Assert the more specific type.
                    // eslint-disable-next-line no-type-assertion/no-type-assertion
                    await _shared_services_command_service__WEBPACK_IMPORTED_MODULE_0__.sendCommand('platform.openWindow', 'https://support.bible');
                }
                catch (e) {
                    throw new Error(`handleMenuCommand error: command: ${command.command}, tabId: ${tabId}. ${e}`);
                }
            })();
            break;
        case 'platform.about':
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.info(`TODO: display about. tabId: ${tabId}`);
            break;
        default:
            (async () => {
                try {
                    // Assert the more specific type.
                    // eslint-disable-next-line no-type-assertion/no-type-assertion
                    await _shared_services_command_service__WEBPACK_IMPORTED_MODULE_0__.sendCommand(command.command, tabId);
                }
                catch (e) {
                    throw new Error(`handleMenuCommand error: command: ${command.command}, tabId: ${tabId}. ${e}`);
                }
            })();
    }
}


/***/ }),

/***/ "./src/shared/data/platform.data.ts":
/*!******************************************!*\
  !*** ./src/shared/data/platform.data.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEV_MODE_RENDERER_INDICATOR: () => (/* binding */ DEV_MODE_RENDERER_INDICATOR),
/* harmony export */   PLATFORM_NAMESPACE: () => (/* binding */ PLATFORM_NAMESPACE)
/* harmony export */ });
/**
 * Namespace to use for features like commands, settings, etc. on the PAPI that are provided by
 * Platform.Bible core
 */
const PLATFORM_NAMESPACE = 'platform';
/** Query string passed to the renderer when starting if it should enable noisy dev mode */
const DEV_MODE_RENDERER_INDICATOR = '?noisyDevMode';


/***/ }),

/***/ "./src/shared/data/rpc.model.ts":
/*!**************************************!*\
  !*** ./src/shared/data/rpc.model.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CATEGORY_COMMAND: () => (/* binding */ CATEGORY_COMMAND),
/* harmony export */   ConnectionStatus: () => (/* binding */ ConnectionStatus),
/* harmony export */   GET_METHODS: () => (/* binding */ GET_METHODS),
/* harmony export */   REGISTER_METHOD: () => (/* binding */ REGISTER_METHOD),
/* harmony export */   UNREGISTER_METHOD: () => (/* binding */ UNREGISTER_METHOD),
/* harmony export */   WEBSOCKET_PORT: () => (/* binding */ WEBSOCKET_PORT),
/* harmony export */   createErrorResponse: () => (/* binding */ createErrorResponse),
/* harmony export */   createRequest: () => (/* binding */ createRequest),
/* harmony export */   createSuccessResponse: () => (/* binding */ createSuccessResponse),
/* harmony export */   deserializeMessage: () => (/* binding */ deserializeMessage),
/* harmony export */   fixupResponse: () => (/* binding */ fixupResponse),
/* harmony export */   requestWithRetry: () => (/* binding */ requestWithRetry),
/* harmony export */   sendPayloadToWebSocket: () => (/* binding */ sendPayloadToWebSocket)
/* harmony export */ });
/* harmony import */ var _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/services/logger.service */ "./src/shared/services/logger.service.ts");
/* harmony import */ var json_rpc_2_0__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! json-rpc-2.0 */ "./node_modules/json-rpc-2.0/dist/index.js");
/* harmony import */ var json_rpc_2_0__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(json_rpc_2_0__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");



/** Port to use for the WebSocket */
const WEBSOCKET_PORT = 8876;
/** How many times to try sending a request before giving up if the request is not yet registered */
const MAX_REQUEST_ATTEMPTS = 10;
/** How long in ms to wait between request attempts if the request is not yet registered */
const REQUEST_ATTEMPT_WAIT_TIME_MS = 1000;
/**
 * Whether an RPC object is setting up or has finished setting up its connection and is ready to
 * communicate on the network
 */
var ConnectionStatus;
(function (ConnectionStatus) {
    /** Not connected to the network */
    ConnectionStatus[ConnectionStatus["Disconnected"] = 0] = "Disconnected";
    /** Attempting to connect to the network */
    ConnectionStatus[ConnectionStatus["Connecting"] = 1] = "Connecting";
    /** Finished setting up its connection */
    ConnectionStatus[ConnectionStatus["Connected"] = 2] = "Connected";
})(ConnectionStatus || (ConnectionStatus = {}));
/**
 * Create a JSONRPCRequest message
 *
 * @param requestType Indicates what to do with the request
 * @param requestParams Parameters to pass along when the request is processed
 * @param requestId Unique ID for this connection of this request
 * @returns JSONRPCRequest message that can be serialized and sent over a connection
 */
function createRequest(requestType, requestParams, requestId) {
    return { jsonrpc: json_rpc_2_0__WEBPACK_IMPORTED_MODULE_1__.JSONRPC, id: requestId, method: requestType, params: requestParams };
}
/**
 * Create a JSONRPCSuccessResponse message
 *
 * @param contents Data to return to the requester when the request succeeds
 * @param requestId ID of the request that this response is intended to address. If no ID was
 *   provided, don't pass a value to this parameter.
 * @returns JSONRPCSuccessResponse message that can be serialized and sent over a connection
 */
function createSuccessResponse(contents, requestId = 0) {
    return { jsonrpc: json_rpc_2_0__WEBPACK_IMPORTED_MODULE_1__.JSONRPC, id: requestId, result: contents };
}
/**
 * Create a JSONRPCErrorResponse message
 *
 * @param errorMessage Text to provide to the requester about why this request failed
 * @param errorCode JSONRPCErrorCode value that best aligns with the purpose of the failure
 * @param requestId ID of the request that this response is intended to address. If no ID was
 *   provided, don't pass a value to this parameter.
 * @returns JSONRPCErrorResponse message that can be serialized and sent over a connection
 */
function createErrorResponse(errorMessage, errorCode = json_rpc_2_0__WEBPACK_IMPORTED_MODULE_1__.JSONRPCErrorCode.InternalError, requestId = 0) {
    return { jsonrpc: json_rpc_2_0__WEBPACK_IMPORTED_MODULE_1__.JSONRPC, id: requestId, error: { code: errorCode, message: errorMessage } };
}
/** Serialize a payload, if needed, and send it over the provided WebSocket */
function sendPayloadToWebSocket(ws, payload) {
    if (!ws)
        throw new Error(`Tried to send payload while not connected`);
    if (typeof payload === 'string' ||
        payload instanceof ArrayBuffer ||
        payload instanceof Blob ||
        ArrayBuffer.isView(payload)) {
        ws.send(payload);
    }
    else {
        ws.send((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.serialize)(payload));
    }
}
/**
 * Deserialize a payload from the network and return it as a JSONRPC message or array of messages.
 * Note that all `null` values from the payload will be converted into `undefined` values except for
 * `result` values in JSONRPCSuccessResponse messages. A `null` value as the response to a request
 * must not be converted to `undefined` per the JSONRPC protocol.
 *
 * After a request has been processed by the protocol stack, call `fixupResponse` to restore
 * `undefined` responses.
 */
function deserializeMessage(payload) {
    const message = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.deserialize)(payload);
    const messageType = typeof message;
    if (messageType !== 'object')
        return message;
    if (Array.isArray(message)) {
        message.forEach((msg) => {
            // Required by the protocol since we convert "undefined" to "null" in "deserialize"
            // eslint-disable-next-line no-null/no-null
            if (typeof msg === 'object' && 'result' in msg && msg.result === undefined)
                msg.result = null;
        });
    }
    else if ('result' in message && message.result === undefined)
        // Required by the protocol since we convert "undefined" to "null" in "deserialize"
        // eslint-disable-next-line no-null/no-null
        message.result = null;
    return message;
}
/**
 * Convert `null` results back to `undefined` once we're out of the protocol stack.
 *
 * This works in tandem with `deserializeMessage` to properly handle `null` values in JSONRPC
 * messages.
 */
function fixupResponse(response) {
    // Convert "null" back to "undefined" before it flows back out to callers
    // eslint-disable-next-line no-null/no-null
    if ('result' in response && response.result === null)
        response.result = undefined;
    return response;
}
/**
 * Runs the request callback and retries a number of times if `requestCallback` resolves to a method
 * not found error
 *
 * @param requestCallback Function to run to send a JSON-RPC request. Should return a JSONRPC error
 *   with code {@link JSONRPCErrorCode.MethodNotFound} if it fails to find the method
 * @param name Name of the handler running this request for logging purposes
 * @param requestType Type of request for logging purposes
 * @returns The response from the request including the method not found error if it times out
 */
async function requestWithRetry(requestCallback, name, requestType) {
    // https://github.com/paranext/paranext-core/issues/51
    // If the request type doesn't have a registered handler yet, retry a few times to help with race
    // conditions. This approach is hacky but works well enough for now.
    for (let attemptsRemaining = MAX_REQUEST_ATTEMPTS; attemptsRemaining > 0; attemptsRemaining--) {
        // Intentionally awaiting inside for loop so we attempt once at a time
        // eslint-disable-next-line no-await-in-loop
        const response = await requestCallback();
        if (!response.error || response.error.code !== json_rpc_2_0__WEBPACK_IMPORTED_MODULE_1__.JSONRPCErrorCode.MethodNotFound)
            return response;
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_0__.logger.debug(`RPC handler ${name} could not find a request handler for requestType ${requestType} on attempt ${MAX_REQUEST_ATTEMPTS - attemptsRemaining + 1} of ${MAX_REQUEST_ATTEMPTS}. ${attemptsRemaining === 1 ? 'Giving up.' : 'Retrying...'}`);
        // No need to wait again after the last attempt fails. Return the error response
        if (attemptsRemaining === 1)
            return response;
        // Intentionally awaiting inside for loop so we wait a bit before retrying
        // eslint-disable-next-line no-await-in-loop
        await (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.wait)(REQUEST_ATTEMPT_WAIT_TIME_MS);
    }
    throw new Error(`RPC handler ${name} did not return a response after retrying to find request handler for requestType ${requestType}. This should never happen. Please investigate`);
}
/**
 * Register a method on the network so that requests of the given type are routed to your request
 * handler.
 */
const REGISTER_METHOD = 'network:registerMethod';
/**
 * Unregister a method on the network so that requests of the given type are no longer routed to
 * your request handler.
 */
const UNREGISTER_METHOD = 'network:unregisterMethod';
/**
 * Get all methods that are currently registered on the network. Required to be 'rpc.discover' by
 * the OpenRPC specification.
 */
const GET_METHODS = 'rpc.discover';
/** Prefix on requests that indicates that the request is a command */
const CATEGORY_COMMAND = 'command';


/***/ }),

/***/ "./src/shared/global-this.model.ts":
/*!*****************************************!*\
  !*** ./src/shared/global-this.model.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProcessType: () => (/* binding */ ProcessType)
/* harmony export */ });
/* eslint-enable */
/** Type of Paranext process */
var ProcessType;
(function (ProcessType) {
    ProcessType["Main"] = "main";
    ProcessType["Renderer"] = "renderer";
    ProcessType["ExtensionHost"] = "extension-host";
})(ProcessType || (ProcessType = {}));


/***/ }),

/***/ "./src/shared/models/data-protection.service-model.ts":
/*!************************************************************!*\
  !*** ./src/shared/models/data-protection.service-model.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dataProtectionServiceNetworkObjectName: () => (/* binding */ dataProtectionServiceNetworkObjectName)
/* harmony export */ });
const dataProtectionServiceNetworkObjectName = 'DataProtectionService';


/***/ }),

/***/ "./src/shared/models/data-provider-engine.model.ts":
/*!*********************************************************!*\
  !*** ./src/shared/models/data-provider-engine.model.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataProviderEngine: () => (/* binding */ DataProviderEngine)
/* harmony export */ });
/**
 * JSDOC SOURCE DataProviderEngine
 *
 * Abstract class that provides a placeholder `notifyUpdate` for data provider engine classes. If a
 * data provider engine class extends this class, it doesn't have to specify its own `notifyUpdate`
 * function in order to use `notifyUpdate`.
 *
 * @see {@link IDataProviderEngine} for more information on extending this class.
 */
class DataProviderEngine {
    // This is just a placeholder and will be layered over by papi. We don't need it to do anything
    // @ts-expect-error ts(6133) `updateInstructions` is not used in this method, but we don't care
    // because we want inheriting classes to be able to get this method with Intellisense without
    // an underscore that indicates to TypeScript that we aren't using the parameter
    // eslint-disable-next-line @typescript-eslint/class-methods-use-this, @typescript-eslint/no-unused-vars
    notifyUpdate(updateInstructions) { }
}


/***/ }),

/***/ "./src/shared/models/data-provider.model.ts":
/*!**************************************************!*\
  !*** ./src/shared/models/data-provider.model.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDataProviderDataTypeFromFunctionName: () => (/* binding */ getDataProviderDataTypeFromFunctionName)
/* harmony export */ });
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");

/** The functions that a data provider has for each data type */
const dataProviderFunctionPrefixes = ['set', 'get', 'subscribe'];
/**
 * Get the data type for a data provider function based on its name
 *
 * @param fnName Name of data provider function e.g. `getVerse`
 * @returns Data type for that data provider function e.g. `Verse`
 */
function getDataProviderDataTypeFromFunctionName(fnName) {
    const fnPrefix = dataProviderFunctionPrefixes.find((prefix) => (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_0__.startsWith)(fnName, prefix));
    if (!fnPrefix)
        throw new Error(`${fnName} is not a data provider data type function`);
    // Assert the expected return type.
    // eslint-disable-next-line no-type-assertion/no-type-assertion
    return (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_0__.substring)(fnName, (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_0__.stringLength)(fnPrefix));
}


/***/ }),

/***/ "./src/shared/models/network-object-status.service-model.ts":
/*!******************************************************************!*\
  !*** ./src/shared/models/network-object-status.service-model.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   networkObjectStatusServiceNetworkObjectName: () => (/* binding */ networkObjectStatusServiceNetworkObjectName)
/* harmony export */ });
const networkObjectStatusServiceNetworkObjectName = 'NetworkObjectStatusService';


/***/ }),

/***/ "./src/shared/models/notification.service-model.ts":
/*!*********************************************************!*\
  !*** ./src/shared/models/notification.service-model.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NotificationServiceNetworkObjectName: () => (/* binding */ NotificationServiceNetworkObjectName)
/* harmony export */ });
const NotificationServiceNetworkObjectName = 'NotificationService';


/***/ }),

/***/ "./src/shared/models/openrpc.model.ts":
/*!********************************************!*\
  !*** ./src/shared/models/openrpc.model.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createEmptyOpenRpc: () => (/* binding */ createEmptyOpenRpc),
/* harmony export */   getEmptyMethodDocs: () => (/* binding */ getEmptyMethodDocs)
/* harmony export */ });
/* harmony import */ var _shared_data_rpc_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/data/rpc.model */ "./src/shared/data/rpc.model.ts");
/* eslint-disable @typescript-eslint/no-explicit-any */

/** Create an object of type {@link OpenRpc} to hold documentation for PAPI websocket methods */
function createEmptyOpenRpc(papiVersion) {
    return {
        openrpc: '1.2.6',
        info: {
            version: papiVersion,
            title: 'Live PAPI documentation',
            description: 'All methods currently registered with PAPI. They change dynamically as methods are registered and unregistered. This page does not automatically refresh to show any changes.\n\nSee additional helpful documentation for [extension developers](https://github.com/paranext/paranext-extension-template/wiki).',
            contact: {
                name: 'Platform.Bible Team',
                url: 'https://discord.gg/tzw22PUEAY',
            },
            license: {
                name: 'MIT',
                url: 'https://github.com/paranext/paranext-core/blob/main/LICENSE',
            },
        },
        servers: [
            {
                name: 'Platform.Bible and Paratext 10 Studio Wiki',
                url: 'https://github.com/paranext/paranext-core/wiki/Platform.Bible-and-Paratext-10-Studio',
            },
            {
                name: 'TypeScript docs for PAPI React components, general library components, and API calls',
                url: 'https://paranext.github.io/paranext-core/',
            },
            {
                name: 'PAPI websocket',
                url: `ws://localhost:${_shared_data_rpc_model__WEBPACK_IMPORTED_MODULE_0__.WEBSOCKET_PORT}`,
            },
        ],
        methods: [],
        components: {},
    };
}
const emptyDocs = {
    summary: '',
    description: 'No documentation provided',
    params: [],
    result: {
        name: 'return value',
        schema: {},
    },
};
Object.freeze(emptyDocs);
Object.freeze(emptyDocs.params);
Object.freeze(emptyDocs.result);
// @ts-expect-error 2339 - TS doesn't understand that 'schema' is part of 'result'
Object.freeze(emptyDocs.result.schema);
/**
 * Get an empty {@link OpenRpc} method document object. Useful for populating documentation for
 * methods that didn't have their own documentation provided.
 */
function getEmptyMethodDocs() {
    return emptyDocs;
}


/***/ }),

/***/ "./src/shared/models/papi-network-event-emitter.model.ts":
/*!***************************************************************!*\
  !*** ./src/shared/models/papi-network-event-emitter.model.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PapiNetworkEventEmitter: () => (/* binding */ PapiNetworkEventEmitter),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");

/**
 * Networked version of EventEmitter - accepts subscriptions to an event and runs the subscription
 * callbacks when the event is emitted. Events on NetworkEventEmitters can be emitted across
 * processes. They are coordinated between processes by their type. Use eventEmitter.event(callback)
 * to subscribe to the event. Use eventEmitter.emit(event) to run the subscriptions. Generally, this
 * EventEmitter should be private, and its event should be public. That way, the emitter is not
 * publicized, but anyone can subscribe to the event.
 *
 * WARNING: Do not use this class directly outside of NetworkService, or it will not do what you
 * expect. Use NetworkService.createNetworkEventEmitter.
 *
 * WARNING: You cannot emit events with complex types on the network.
 */
class PapiNetworkEventEmitter extends platform_bible_utils__WEBPACK_IMPORTED_MODULE_0__.PlatformEventEmitter {
    networkSubscriber;
    networkDisposer;
    /**
     * Creates a NetworkEventEmitter
     *
     * @param networkSubscriber Callback that accepts the event and emits it to other processes
     * @param networkDisposer Callback that unlinks this emitter from the network
     */
    constructor(
    /** Callback that sends the event to other processes on the network when it is emitted */
    networkSubscriber, 
    /** Callback that runs when the emitter is disposed - should handle unlinking from the network */
    networkDisposer) {
        super();
        this.networkSubscriber = networkSubscriber;
        this.networkDisposer = networkDisposer;
    }
    emit = (event) => {
        this.assertNotDisposed();
        if (this.networkSubscriber)
            this.networkSubscriber(event);
        this.emitLocal(event);
    };
    /**
     * Runs only the subscriptions for the event that are on this process. Does not send over network
     *
     * @param event Event data to provide to subscribed callbacks
     */
    emitLocal(event) {
        this.assertNotDisposed();
        super.emitFn(event);
    }
    dispose = () => {
        const retVal = super.disposeFn();
        // TODO: Do we need to set networkSubscriber to undefined? Had to remove readonly from it to do this
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        this.networkSubscriber = undefined;
        this.networkDisposer();
        return retVal;
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PapiNetworkEventEmitter);


/***/ }),

/***/ "./src/shared/models/project-data-provider-factory.interface.ts":
/*!**********************************************************************!*\
  !*** ./src/shared/models/project-data-provider-factory.interface.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PDP_FACTORY_OBJECT_TYPE: () => (/* binding */ PDP_FACTORY_OBJECT_TYPE)
/* harmony export */ });
const PDP_FACTORY_OBJECT_TYPE = 'pdpFactory';


/***/ }),

/***/ "./src/shared/models/project-data-provider.model.ts":
/*!**********************************************************!*\
  !*** ./src/shared/models/project-data-provider.model.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PROJECT_INTERFACE_PLATFORM_BASE: () => (/* binding */ PROJECT_INTERFACE_PLATFORM_BASE)
/* harmony export */ });
/**
 * The name of the `projectInterface` representing the essential methods every Base Project Data
 * Provider must implement
 */
const PROJECT_INTERFACE_PLATFORM_BASE = 'platform.base';


/***/ }),

/***/ "./src/shared/models/project-lookup.service-model.ts":
/*!***********************************************************!*\
  !*** ./src/shared/models/project-lookup.service-model.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NETWORK_OBJECT_NAME_PROJECT_LOOKUP_SERVICE: () => (/* binding */ NETWORK_OBJECT_NAME_PROJECT_LOOKUP_SERVICE),
/* harmony export */   areProjectInterfacesIncluded: () => (/* binding */ areProjectInterfacesIncluded),
/* harmony export */   getPDPFactoryIdFromNetworkObjectName: () => (/* binding */ getPDPFactoryIdFromNetworkObjectName),
/* harmony export */   getPDPFactoryNetworkObjectNameFromId: () => (/* binding */ getPDPFactoryNetworkObjectNameFromId),
/* harmony export */   projectLookupServiceBase: () => (/* binding */ projectLookupServiceBase),
/* harmony export */   testingProjectLookupService: () => (/* binding */ testingProjectLookupService)
/* harmony export */ });
/* harmony import */ var _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/services/network-object.service */ "./src/shared/services/network-object.service.ts");
/* harmony import */ var _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/services/logger.service */ "./src/shared/services/logger.service.ts");
/* harmony import */ var _shared_services_network_object_status_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/services/network-object-status.service */ "./src/shared/services/network-object-status.service.ts");
/* harmony import */ var _shared_models_project_data_provider_factory_interface__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @shared/models/project-data-provider-factory.interface */ "./src/shared/models/project-data-provider-factory.interface.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");





const NETWORK_OBJECT_NAME_PROJECT_LOOKUP_SERVICE = 'ProjectLookupService';
// #region Project data provider factory utilities
/**
 * Suffix on network objects that indicates that the network object is a project data provider
 * factory
 */
const PDP_FACTORY_LABEL = '-pdpf';
/**
 * Transform the well-known pdp factory id into an id for its network object to use
 *
 * @param pdpFactoryId Id extensions use to identify this pdp factory
 * @returns Id for then network object for this pdp factory
 */
function getPDPFactoryNetworkObjectNameFromId(pdpFactoryId) {
    return (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.endsWith)(pdpFactoryId, PDP_FACTORY_LABEL)
        ? pdpFactoryId
        : `${pdpFactoryId}${PDP_FACTORY_LABEL}`;
}
/**
 * Transform a network object id for a pdp factory into its well-known pdp factory id
 *
 * @param pdpFactoryNetworkObjectName Id for then network object for this pdp factory
 * @returns Id extensions use to identify this pdp factory
 */
function getPDPFactoryIdFromNetworkObjectName(pdpFactoryNetworkObjectName) {
    return (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.endsWith)(pdpFactoryNetworkObjectName, PDP_FACTORY_LABEL)
        ? (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.slice)(pdpFactoryNetworkObjectName, 0, -PDP_FACTORY_LABEL.length)
        : pdpFactoryNetworkObjectName;
}
/** Local object of functions to run locally on each process as part of the project lookup service */
const projectLookupServiceBase = {
    async getMetadataForAllProjects(options = {}) {
        return internalGetMetadataWithRetries(options);
    },
    async getMetadataForProject(projectId, projectInterface, pdpFactoryId) {
        // Wait for an appropriate PDP factory to be registered
        const timeoutInMS = 20 * 1000;
        if (pdpFactoryId) {
            try {
                await _shared_services_network_object_status_service__WEBPACK_IMPORTED_MODULE_2__.networkObjectStatusService.waitForNetworkObject({
                    objectType: _shared_models_project_data_provider_factory_interface__WEBPACK_IMPORTED_MODULE_3__.PDP_FACTORY_OBJECT_TYPE,
                    id: getPDPFactoryNetworkObjectNameFromId(pdpFactoryId),
                }, timeoutInMS);
            }
            catch (e) {
                throw new Error(`getMetadataForProject wait for PDPF ${pdpFactoryId} threw! ${e}`);
            }
        }
        else if (projectInterface) {
            try {
                await _shared_services_network_object_status_service__WEBPACK_IMPORTED_MODULE_2__.networkObjectStatusService.waitForNetworkObject({
                    objectType: _shared_models_project_data_provider_factory_interface__WEBPACK_IMPORTED_MODULE_3__.PDP_FACTORY_OBJECT_TYPE,
                    attributes: { projectInterfaces: [projectInterface] },
                }, timeoutInMS);
            }
            catch (e) {
                throw new Error(`getMetadataForProject wait for PDPF with ${projectInterface} threw! ${e}`);
            }
        }
        else {
            try {
                await _shared_services_network_object_status_service__WEBPACK_IMPORTED_MODULE_2__.networkObjectStatusService.waitForNetworkObject({ objectType: _shared_models_project_data_provider_factory_interface__WEBPACK_IMPORTED_MODULE_3__.PDP_FACTORY_OBJECT_TYPE }, timeoutInMS);
            }
            catch (e) {
                throw new Error(`getMetadataForProject wait for any PDPF threw! ${e}`);
            }
        }
        const metadata = await internalGetMetadataWithRetries(transformGetMetadataForProjectParametersToFilter(projectId, projectInterface, pdpFactoryId));
        // Get the most minimal match to the projectInterface in question. Hopefully this will give us the
        // PDP that most closely matches the projectInterfaces to avoid unnecessary redirects through
        // layered PDPs
        if (metadata && metadata.length > 0)
            return metadata[0];
        throw new Error(`No project found with ID ${projectId}${projectInterface ? ` and project interface ${projectInterface}` : ''}${pdpFactoryId ? ` from ${pdpFactoryId}` : ''}`);
    },
    areProjectIdsEqual,
    filterProjectsMetadata(projectsMetadata, options) {
        if (!options)
            return [...projectsMetadata];
        if (!options.excludeProjectIds &&
            !options.includeProjectIds &&
            !options.includeProjectInterfaces &&
            !options.excludeProjectInterfaces &&
            !options.includePdpFactoryIds &&
            !options.excludePdpFactoryIds)
            return [...projectsMetadata];
        const { excludeProjectIds, includeProjectIds, includeProjectInterfaces, excludeProjectInterfaces, includePdpFactoryIds, excludePdpFactoryIds, } = ensurePopulatedMetadataFilter(options);
        return projectsMetadata.filter((projectMetadata) => {
            // If the project ID isn't in the filters, it's out
            if (!isProjectIdIncluded(projectMetadata.id, includeProjectIds, excludeProjectIds))
                return false;
            // If the `projectInterface`s don't match the filters, it's out
            if (!areProjectInterfacesIncluded(projectMetadata.projectInterfaces, includeProjectInterfaces, excludeProjectInterfaces))
                return false;
            // If the pdp factory info doesn't match the filters, it's out
            const pdpFactoryIds = Object.keys(projectMetadata.pdpFactoryInfo);
            if (!arePdpFactoryIdsIncluded(pdpFactoryIds, includePdpFactoryIds, excludePdpFactoryIds))
                return false;
            return true;
        });
    },
    mergeMetadataFilters(metadataFilter1, metadataFilter2) {
        const mergedFilter = {};
        if (metadataFilter1?.includeProjectIds || metadataFilter2?.includeProjectIds)
            mergedFilter.includeProjectIds = [
                ...new Set([
                    ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(metadataFilter1?.includeProjectIds),
                    ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(metadataFilter2?.includeProjectIds),
                ]),
            ];
        if (metadataFilter1?.excludeProjectIds || metadataFilter2?.excludeProjectIds)
            mergedFilter.excludeProjectIds = [
                ...new Set([
                    ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(metadataFilter1?.excludeProjectIds),
                    ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(metadataFilter2?.excludeProjectIds),
                ]),
            ];
        if (metadataFilter1?.includeProjectInterfaces || metadataFilter2?.includeProjectInterfaces)
            mergedFilter.includeProjectInterfaces = [
                ...new Set([
                    ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(metadataFilter1?.includeProjectInterfaces),
                    ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(metadataFilter2?.includeProjectInterfaces),
                ]),
            ];
        if (metadataFilter1?.excludeProjectInterfaces || metadataFilter2?.excludeProjectInterfaces)
            mergedFilter.excludeProjectInterfaces = [
                ...new Set([
                    ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(metadataFilter1?.excludeProjectInterfaces),
                    ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(metadataFilter2?.excludeProjectInterfaces),
                ]),
            ];
        if (metadataFilter1?.includePdpFactoryIds || metadataFilter2?.includePdpFactoryIds)
            mergedFilter.includePdpFactoryIds = [
                ...new Set([
                    ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(metadataFilter1?.includePdpFactoryIds),
                    ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(metadataFilter2?.includePdpFactoryIds),
                ]),
            ];
        if (metadataFilter1?.excludePdpFactoryIds || metadataFilter2?.excludePdpFactoryIds)
            mergedFilter.excludePdpFactoryIds = [
                ...new Set([
                    ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(metadataFilter1?.excludePdpFactoryIds),
                    ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(metadataFilter2?.excludePdpFactoryIds),
                ]),
            ];
        return mergedFilter;
    },
    getMinimalMatchPdpFactoryId(projectMetadata, projectInterface) {
        const minimalMatch = Object.entries(projectMetadata.pdpFactoryInfo).reduce((previousPdpfInfoEntry, nextPdpfInfoEntry) => nextPdpfInfoEntry[1]?.projectInterfaces.includes(projectInterface) &&
            compareProjectDataProviderFactoryMetadataInfoMinimalMatch(previousPdpfInfoEntry[1], nextPdpfInfoEntry[1]) > 0
            ? nextPdpfInfoEntry
            : previousPdpfInfoEntry, ['', undefined]);
        return minimalMatch[0] && minimalMatch[1] ? minimalMatch[0] : undefined;
    },
};
// #endregion
// #region Project Lookup Service utility functions
/**
 * How long since start of the current process to count as time that the PDPFs possibly still
 * haven't all started up
 */
const LOAD_TIME_GRACE_PERIOD_MS = 30 * 1000;
/**
 * How long to wait in-between attempts to get project metadata during the time since the current
 * process started
 */
const GRACE_PERIOD_WAIT_TIME_MS = 1 * 1000;
/**
 * Gets project metadata from PDPFs filtered down by various filtering options
 *
 * Note: If there are multiple PDPs available whose metadata matches the conditions provided by the
 * parameters, their project metadata will all be combined, so all available `projectInterface`s
 * provided by the PDP Factory with the matching id (or all PDP Factories if no id is specified) for
 * the project will be returned. If you need `projectInterface`s supported by specific PDP
 * Factories, you can access it at {@link ProjectMetadata.pdpFactoryInfo}.
 */
async function internalGetMetadata(options = {}) {
    const { excludeProjectIds, includeProjectIds, includeProjectInterfaces, excludeProjectInterfaces, includePdpFactoryIds, excludePdpFactoryIds, } = ensurePopulatedMetadataFilter(options);
    // Get all registered PDP factories and filter down to just the included ones
    const networkObjects = await _shared_services_network_object_status_service__WEBPACK_IMPORTED_MODULE_2__.networkObjectStatusService.getAllNetworkObjectDetails();
    const pdpFactoryIds = Object.keys(networkObjects)
        .filter((pdpfNetworkObjectName) => {
        const details = networkObjects[pdpfNetworkObjectName];
        if (details.objectType === _shared_models_project_data_provider_factory_interface__WEBPACK_IMPORTED_MODULE_3__.PDP_FACTORY_OBJECT_TYPE &&
            // If a pdp factory id was specified, only get metadata from that pdp factory id.
            // This means the ProjectMetadata could be partial in some sense because not all projectInterfaces
            // available for that project will be in the ProjectMetadata
            arePdpFactoryIdsIncluded([getPDPFactoryIdFromNetworkObjectName(pdpfNetworkObjectName)], includePdpFactoryIds, excludePdpFactoryIds))
            return true;
        return false;
    })
        .map(getPDPFactoryIdFromNetworkObjectName);
    // For each PDP factory, get all available projects
    const allProjectsMetadata = new Map();
    await Promise.all(pdpFactoryIds.map(async (pdpFactoryId) => {
        const pdpFactory = await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_0__.networkObjectService.get(getPDPFactoryNetworkObjectNameFromId(pdpFactoryId));
        // Get all projects from the PDP factory, and pass in the include/exclude PDP factory ids to
        // make sure two layering PDPFs don't get into an infinite loop together. Each layering PDP
        // factory should call all other pdp factories matching this filter merged with its own
        // filter. We need to pass these but not the other filter properties because we can filter the
        // other properties later in this function (and doing so gives us the full metadata for each
        // project), but we cannot filter these properties for any layering PDP factory we're calling
        const projectsMetadata = await pdpFactory?.getAvailableProjects({
            includePdpFactoryIds: options.includePdpFactoryIds,
            // Add this pdp factory id onto the excluded PDP factory IDs to be sure the Layering PDPF
            // doesn't get into an infinite loop with itself. Then it should pass these back into this
            // function to pass to other layering PDPFs so they don't call each other infinitely
            excludePdpFactoryIds: [
                ...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(options.excludePdpFactoryIds),
                (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.escapeStringRegexp)(pdpFactoryId),
            ],
        });
        if (projectsMetadata) {
            const clonedProjectsMetadata = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.deepClone)(projectsMetadata);
            clonedProjectsMetadata.forEach((md) => {
                // The metadata that comes in from PDPs could have extra pdpFactoryInfo on it, but we
                // want to build it ourselves. So we want to delete it when it comes in
                // eslint-disable-next-line no-type-assertion/no-type-assertion
                delete md
                    .pdpFactoryInfo;
                // Type assert to add the factory info to the object
                // eslint-disable-next-line no-type-assertion/no-type-assertion
                const enrichedMd = allProjectsMetadata.get(md.id) ?? md;
                if (!enrichedMd.pdpFactoryInfo)
                    enrichedMd.pdpFactoryInfo = {};
                if (pdpFactoryId in enrichedMd.pdpFactoryInfo) {
                    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.warn(`Project ${md.id} already has metadata from pdp factory ${pdpFactoryId}. Skipping additional metadata: ${JSON.stringify(md)}`);
                    return;
                }
                // Filter out metadata with the wrong project id
                if (!isProjectIdIncluded(md.id, includeProjectIds, excludeProjectIds))
                    return;
                // Wait to filter metadata by `projectInterface` because we want to return ProjectMetadata
                // for a project including all available `projectInterface`s, not just `projectInterface`s
                // provided by PDPFs that provide that `projectInterface`
                // This project metadata passes project id and pdpf id! Merge it into the existing metadata
                // Put the factory info on
                enrichedMd.pdpFactoryInfo[pdpFactoryId] = {
                    projectInterfaces: [...md.projectInterfaces],
                };
                // If there is metadata already in the map, add the new `projectInterface`s
                if (allProjectsMetadata.has(md.id)) {
                    md.projectInterfaces.forEach((newProjectInterface) => {
                        if (!enrichedMd.projectInterfaces.includes(newProjectInterface))
                            enrichedMd.projectInterfaces.push(newProjectInterface);
                    });
                }
                else
                    allProjectsMetadata.set(md.id, enrichedMd);
            });
        }
    }));
    let allProjectsMetadataArray = Array.from(allProjectsMetadata.values());
    // Filter out metadata without the right `projectInterface`
    if (includeProjectInterfaces.length > 0 || excludeProjectInterfaces.length > 0) {
        allProjectsMetadataArray = allProjectsMetadataArray.filter((projectMetadata) => areProjectInterfacesIncluded(projectMetadata.projectInterfaces, includeProjectInterfaces, excludeProjectInterfaces));
    }
    return allProjectsMetadataArray;
}
/**
 * Gets project metadata from PDPFs filtered down by various filtering options. If this process
 * started recently and this finds no project metadata, waits a bit and tries again because it may
 * be that not all PDPFs have started yet.
 *
 * Note: If there are multiple PDPs available whose metadata matches the conditions provided by the
 * parameters, their project metadata will all be combined, so all available `projectInterface`s
 * provided by the PDP Factory with the matching id (or all PDP Factories if no id is specified) for
 * the project will be returned. If you need `projectInterface`s supported by specific PDP
 * Factories, you can access it at {@link ProjectMetadata.pdpFactoryInfo}.
 */
async function internalGetMetadataWithRetries(options = {}) {
    let allProjectsMetadataArray = await internalGetMetadata(options);
    // If we're in the first little while of the process, there's a chance not all the PDPFs have
    // loaded. Let's wait a bit and try again if we got no matching project metadata
    let retryTimes = 0;
    while (allProjectsMetadataArray.length === 0 && performance.now() < LOAD_TIME_GRACE_PERIOD_MS) {
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.debug(`Did not find any project metadata around ${performance.now()} for ${JSON.stringify(options)}. Will retry`);
        // Intentionally stopping this method execution to wait some time
        // eslint-disable-next-line no-await-in-loop
        await (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.wait)(GRACE_PERIOD_WAIT_TIME_MS);
        // Intentionally stopping this method execution to try getting project metadata again
        // eslint-disable-next-line no-await-in-loop
        allProjectsMetadataArray = await internalGetMetadata(options);
        retryTimes += 1;
        if (allProjectsMetadataArray.length > 0)
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.debug(`Finally found project metadata on retry ${retryTimes} around ${performance.now()} for ${JSON.stringify(options)}! ${JSON.stringify(allProjectsMetadataArray)}`);
    }
    if (allProjectsMetadataArray.length === 0) {
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_1__.logger.warn(`Did not find any project metadata${retryTimes > 0 ? ` on retry ${retryTimes}` : ''} for ${JSON.stringify(options)} after the grace period. If you expected to find projects for these filters, this probably indicates a problem. Maybe not all PDPFs loaded in time.`);
    }
    return allProjectsMetadataArray;
}
function transformGetMetadataForProjectParametersToFilter(projectId, projectInterface, pdpFactoryId) {
    // Escape `projectInterface` and `pdpFactoryId` because we don't want regexp matching. These
    // fields should match exactly
    return {
        includeProjectIds: projectId,
        includeProjectInterfaces: projectInterface
            ? (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.escapeStringRegexp)(projectInterface)
            : projectInterface,
        includePdpFactoryIds: pdpFactoryId ? (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.escapeStringRegexp)(pdpFactoryId) : pdpFactoryId,
    };
}
// #endregion
// #region Smaller project utilities
function ensurePopulatedMetadataFilter(options) {
    const { excludeProjectIds, includeProjectIds, includeProjectInterfaces, excludeProjectInterfaces, includePdpFactoryIds, excludePdpFactoryIds, } = options;
    // Get array of excludeProjectIds
    const excludeProjectIdsArray = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(excludeProjectIds);
    // Get array of includeProjectIds
    const includeProjectIdsArray = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.ensureArray)(includeProjectIds);
    // Get array of excludeProjectInterfaces RegExps
    const excludeProjectInterfacesRegExps = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.transformAndEnsureRegExpRegExpArray)(excludeProjectInterfaces);
    // Get array of includeProjectInterfaces RegExps
    const includeProjectInterfacesRegExps = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.transformAndEnsureRegExpRegExpArray)(includeProjectInterfaces);
    // Get array of includePdpFactoryIds RegExps
    const includePdpFactoryIdsRegExps = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.transformAndEnsureRegExpArray)(includePdpFactoryIds);
    // Get array of excludePdpFactoryIds RegExps
    const excludePdpFactoryIdsRegExps = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_4__.transformAndEnsureRegExpArray)(excludePdpFactoryIds);
    return {
        excludeProjectIds: excludeProjectIdsArray,
        includeProjectIds: includeProjectIdsArray,
        includeProjectInterfaces: includeProjectInterfacesRegExps,
        excludeProjectInterfaces: excludeProjectInterfacesRegExps,
        includePdpFactoryIds: includePdpFactoryIdsRegExps,
        excludePdpFactoryIds: excludePdpFactoryIdsRegExps,
    };
}
function areProjectIdsEqual(projectIdA, projectIdB) {
    return projectIdA.localeCompare(projectIdB, undefined, { sensitivity: 'accent' }) === 0;
}
function isProjectIdIncluded(projectId, includeProjectIds, excludeProjectIds) {
    // If the project ID is excluded, it's out
    if (excludeProjectIds.length > 0 &&
        excludeProjectIds.some((excludeProjectId) => areProjectIdsEqual(excludeProjectId, projectId)))
        return false;
    // If the project ID is not included, it's out
    if (includeProjectIds.length > 0 &&
        !includeProjectIds.some((includeProjectId) => areProjectIdsEqual(includeProjectId, projectId)))
        return false;
    return true;
}
/**
 * Determines whether the given project interfaces are included based on specified inclusion and
 * exclusion rules.
 *
 * This function checks if a set of project interfaces meets the criteria defined by regular
 * expressions for inclusion and exclusion.
 *
 * - A project interface is excluded if it matches any of the provided exclusion patterns.
 * - A project interface is included only if it matches at least one of the provided inclusion
 *   patterns.
 *
 * @param projectInterfaces - An array of project interfaces to evaluate against the inclusion and
 *   exclusion patterns.
 * @param includeProjectInterfaces - An array of regular expressions or arrays of regular
 *   expressions defining which interfaces should be included.
 * @param excludeProjectInterfaces - An array of regular expressions or arrays of regular
 *   expressions defining which interfaces should be excluded.
 * @returns A boolean value indicating whether the project interfaces satisfy the inclusion and
 *   exclusion criteria.
 */
function areProjectInterfacesIncluded(projectInterfaces, includeProjectInterfaces, excludeProjectInterfaces) {
    // If the project interface is excluded, it's out
    if (excludeProjectInterfaces.length > 0 &&
        excludeProjectInterfaces.some((excludeRegExp) => Array.isArray(excludeRegExp)
            ? excludeRegExp.every((subExcludeRegExp) => projectInterfaces.some((projectInterface) => subExcludeRegExp.test(projectInterface)))
            : projectInterfaces.some((projectInterface) => excludeRegExp.test(projectInterface))))
        return false;
    // If the project interface isn't included, it's out
    if (includeProjectInterfaces.length > 0 &&
        !includeProjectInterfaces.some((includeRegExp) => Array.isArray(includeRegExp)
            ? includeRegExp.every((subIncludeRegExp) => projectInterfaces.some((projectInterface) => subIncludeRegExp.test(projectInterface)))
            : projectInterfaces.some((projectInterface) => includeRegExp.test(projectInterface))))
        return false;
    return true;
}
/** All works with the well-known PDP factory ids, not the network object names */
function arePdpFactoryIdsIncluded(pdpFactoryIds, includePdpFactoryIds, excludePdpFactoryIds) {
    // If any of the PDP Factory Id are excluded, it's out
    if (excludePdpFactoryIds.length > 0 &&
        excludePdpFactoryIds.some((excludeRegExp) => pdpFactoryIds.some((pdpFactoryId) => excludeRegExp.test(pdpFactoryId))))
        return false;
    // If none of the PDP Factory Ids are included, it's out
    if (includePdpFactoryIds.length > 0 &&
        (pdpFactoryIds.length === 0 ||
            !includePdpFactoryIds.some((includeRegExp) => pdpFactoryIds.some((pdpFactoryId) => includeRegExp.test(pdpFactoryId)))))
        return false;
    return true;
}
/**
 * Compare function (for array sorting and such) that compares two PDPF Metadata infos by most
 * minimal match to the `projectInterface` in question.
 *
 * Hopefully this will allow us to get the PDP that most closely matches the `projectInterface`s to
 * avoid unnecessary redirects through layered PDPs
 *
 * @param pdpFMetadataInfoA First ProjectDataProviderFactoryMetadataInfo to compare
 * @param pdpFMetadataInfoB Second ProjectDataProviderFactoryMetadataInfo to compare
 * @returns -1 if a is less than b, 0 if equal, and 1 otherwise
 */
function compareProjectDataProviderFactoryMetadataInfoMinimalMatch(pdpFMetadataInfoA, pdpFMetadataInfoB) {
    if (!pdpFMetadataInfoA) {
        if (!pdpFMetadataInfoB)
            return 0;
        return 1;
    }
    if (!pdpFMetadataInfoB) {
        return -1;
    }
    // Note: we could convert these arrays to sets first to ensure no duplicates to make sure
    // these comparisons are accurate, but let's just say extension developers should write them
    // with no duplicates until we have a reason to say something else
    const lengthA = pdpFMetadataInfoA.projectInterfaces.length;
    const lengthB = pdpFMetadataInfoB.projectInterfaces.length;
    // If one only has the original interface or is smaller than the other, it should be first
    if (lengthA === 1 || lengthA < lengthB)
        return -1;
    if (lengthB === 1 || lengthB < lengthA)
        return 1;
    // Otherwise they are pretty much the same as far as we can tell
    return 0;
}
// #endregion
// #region testing
/** This is an internal-only export for testing purposes and should not be used in development */
const testingProjectLookupService = {
    internalGetMetadata,
    compareProjectDataProviderFactoryMetadataInfoMinimalMatch,
    transformGetMetadataForProjectParametersToFilter,
    LOAD_TIME_GRACE_PERIOD_MS,
};
// #endregion


/***/ }),

/***/ "./src/shared/services/app.service-model.ts":
/*!**************************************************!*\
  !*** ./src/shared/services/app.service-model.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appServiceNetworkObjectName: () => (/* binding */ appServiceNetworkObjectName)
/* harmony export */ });
const appServiceNetworkObjectName = 'AppService';


/***/ }),

/***/ "./src/shared/services/command.service.ts":
/*!************************************************!*\
  !*** ./src/shared/services/command.service.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSendCommandFunction: () => (/* binding */ createSendCommandFunction),
/* harmony export */   registerCommand: () => (/* binding */ registerCommand),
/* harmony export */   sendCommand: () => (/* binding */ sendCommand)
/* harmony export */ });
/* harmony import */ var _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/services/network.service */ "./src/shared/services/network.service.ts");
/* harmony import */ var _shared_utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/utils/util */ "./src/shared/utils/util.ts");
/* harmony import */ var _shared_data_rpc_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/data/rpc.model */ "./src/shared/data/rpc.model.ts");
/**
 * Handles registering, sending, and receiving commands with the Paratext backend in a unified
 * format. Exposed on papi
 */



/**
 * Register a command on the papi to be handled here
 *
 * @param commandName Command name to register for handling here
 *
 *   - Note: Command names must consist of two string separated by at least one period. We recommend one
 *       period and lower camel case in case we expand the api in the future to allow dot notation.
 *
 * @param handler Function to run when the command is invoked
 * @returns Promise that resolves if the command successfully registered and unsubscriber function
 *   to run to stop the passed-in function from handling commands
 */
const registerCommand = (commandName, handler, commandDocs) => {
    return _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__.registerRequestHandler((0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_1__.serializeRequestType)(_shared_data_rpc_model__WEBPACK_IMPORTED_MODULE_2__.CATEGORY_COMMAND, commandName), handler, commandDocs);
};
/** Send a command to the backend. */
const sendCommand = async (commandName, ...args) => {
    // This type assertion is needed when the return type is unknown or when it's not Awaited<...>.
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion, no-type-assertion/no-type-assertion
    return _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__.request((0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_1__.serializeRequestType)(_shared_data_rpc_model__WEBPACK_IMPORTED_MODULE_2__.CATEGORY_COMMAND, commandName), ...args);
};
/**
 * Creates a function that is a command function with a baked commandName. This is also nice because
 * you get TypeScript type support using this function.
 *
 * @param commandName Command name for command function
 * @returns Function to call with arguments of command that sends the command and resolves with the
 *   result of the command
 */
const createSendCommandFunction = (commandName) => {
    return async (...args) => sendCommand(commandName, ...args);
};


/***/ }),

/***/ "./src/shared/services/data-provider.service.ts":
/*!******************************************************!*\
  !*** ./src/shared/services/data-provider.service.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dataProviderService: () => (/* binding */ dataProviderService),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getByType: () => (/* binding */ getByType),
/* harmony export */   registerEngineByType: () => (/* binding */ registerEngineByType)
/* harmony export */ });
/* harmony import */ var _shared_models_data_provider_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/models/data-provider.model */ "./src/shared/models/data-provider.model.ts");
/* harmony import */ var _shared_models_data_provider_engine_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/models/data-provider-engine.model */ "./src/shared/models/data-provider-engine.model.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");
/* harmony import */ var _shared_services_network_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @shared/services/network.service */ "./src/shared/services/network.service.ts");
/* harmony import */ var _shared_utils_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @shared/utils/util */ "./src/shared/utils/util.ts");
/* harmony import */ var _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @shared/services/network-object.service */ "./src/shared/services/network-object.service.ts");
/* harmony import */ var _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @shared/services/logger.service */ "./src/shared/services/logger.service.ts");
/* harmony import */ var _shared_services_notification_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @shared/services/notification.service */ "./src/shared/services/notification.service.ts");
/** Handles registering data providers and serving data around the papi. Exposed on the papi. */








/** Suffix on network objects that indicates that the network object is a data provider */
const DATA_PROVIDER_LABEL = 'data';
/** Event type for data provider update event */
const ON_DID_UPDATE = 'onDidUpdate';
/**
 * An object reference that is a placeholder for updates for data provider subscribers. We want to
 * make absolutely sure updates that come in are sent to subscribers, so we use this object
 * reference to tell if we have never had an update before.
 */
const SUBSCRIBE_PLACEHOLDER = {};
/**
 * Gets the id for the data provider network object with the given name Don't add the suffix to the
 * provider name if it's already there to avoid duplication
 */
const getDataProviderObjectId = (providerName) => {
    return (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.endsWith)(providerName, `-${DATA_PROVIDER_LABEL}`)
        ? providerName
        : `${providerName}-${DATA_PROVIDER_LABEL}`;
};
/** Whether this service has finished setting up */
let isInitialized = false;
/** Promise that resolves when this service is finished initializing */
let initializePromise;
/** Sets up the service. Only runs once and always returns the same promise after that */
const initialize = () => {
    if (initializePromise)
        return initializePromise;
    initializePromise = (async () => {
        if (isInitialized)
            return;
        await _shared_services_network_service__WEBPACK_IMPORTED_MODULE_3__.initialize();
        isInitialized = true;
    })();
    return initializePromise;
};
/**
 * JSDOC SOURCE DataProviderServiceHasKnown
 *
 * Indicate if we are aware of an existing data provider with the given name. If a data provider
 * with the given name is somewhere else on the network, this function won't tell you about it
 * unless something else in the existing process is subscribed to it.
 */
function hasKnown(providerName) {
    return _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_5__.networkObjectService.hasKnown(getDataProviderObjectId(providerName));
}
function constructErrorNotification(exception) {
    const retVal = {
        severity: 'error',
        message: '',
        clickCommandLabel: '%general_open%',
        // TS doesn't realize this is a valid command handler key since it is defined in an extension
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        clickCommand: 'paratextRegistration.showParatextRegistration',
    };
    if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.isErrorMessageAboutParatextBlockingInternetAccess)(exception)) {
        retVal.message = '%data_loading_error_paratextData_internet_disabled%';
    }
    else if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.isErrorMessageAboutRegistryAuthFailure)(exception)) {
        retVal.message = '%data_loading_error_paratextData_auth_failure%';
    }
    else {
        return undefined;
    }
    return retVal;
}
/**
 * Creates a subscribe function for a data provider to allow subscribing to updates on the data
 *
 * @param dataProviderPromise Promise to the data provider's network object
 * @param onDidUpdate The event to listen to for updates on the data
 * @param dataType The name of the functions to use (ex: `dataProvider.subscribeBook` ->
 *   `dataProvider.getBook`)
 * @returns Subscribe function for a data provider
 */
function createDataProviderSubscriber(dataProviderPromise, onDidUpdate, dataType) {
    return async (selector, callback, options) => {
        // We need an untyped version of the DP so we can use string-template-mapped-type properties
        // on it even though the strings that get templated are one of many possibilities. It seems
        // TypeScript is unable to distinguish that `DataTypeNames<DataProviderTypes[DataProviderName]>`
        // is one specific set of names of data types
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        const dataProviderUntyped = (await dataProviderPromise);
        // Default options
        const subscriberOptions = {
            retrieveDataImmediately: true,
            whichUpdates: 'deeply-equal',
            ...options,
        };
        const { retrieveDataImmediately, whichUpdates } = subscriberOptions;
        // Keep track of whether we should call the callback when we receive a result or if they have already unsubscribed
        // Important because a promise could resolve after they have unsubscribed
        let isSubscribed = true;
        /**
         * The most recent data before the newest update. Used for deep comparison checks to prevent
         * useless updates
         */
        // Start this out as a placeholder so updates definitely run the callback (including if the data is undefined or an empty object)
        // TODO: create a cache for the data provider that holds data returned per selector and shares that cache here
        let dataPrevious = SUBSCRIBE_PLACEHOLDER;
        // Create a layer over the provided callback that lets us know if we received an update so we don't run the callback with old data after updating
        /**
         * Whether we have already received an update event, meaning our initial `get` will return old
         * data
         */
        let receivedUpdate = false;
        const callbackWithUpdate = async (updateEventResult) => {
            // If we're already unsubscribed somehow, don't want to run this
            if (!isSubscribed)
                return;
            if (updateEventResult !== '*' &&
                (!Array.isArray(updateEventResult) || !updateEventResult.includes(dataType)))
                // The update does not apply to this data type. Ignore
                return;
            try {
                // The update is relevant to this data type, so continue with this subscription
                // Get the data at our selector when we receive notification that the data updated
                // TODO: Implement selector events so we can receive the new data with the update instead of reaching back out for it
                // TypeScript seems to be unable to figure out these `get${dataType}` types when we wrap
                // DataProviderInternal in NetworkObject to make IDataProvider, so we have to do all this work
                // to specify the specific types
                /* eslint-disable no-type-assertion/no-type-assertion */
                const data = await dataProviderUntyped[`get${dataType}`
                // Sadly DataProviderGetter<DataProviderTypes[DataProviderName][typeof dataType]> doesn't
                // work here. See comment in function signature for more info
                ](selector);
                /* eslint-enable */
                // Take note that we have received an update so we don't run the callback with the old data below in the `retrieveDataImmediately` code
                receivedUpdate = true;
                // If we unsubscribed while we were awaiting the promise to get data, don't do anything
                if (!isSubscribed)
                    return;
                // Only update if we should listen to all updates, if the old data is the default placeholder data, or the data is not deeply equal
                if (whichUpdates === '*' ||
                    dataPrevious === SUBSCRIBE_PLACEHOLDER ||
                    !(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(dataPrevious, data)) {
                    dataPrevious = data;
                    callback(data);
                }
            }
            catch (e) {
                const selectorDetails = JSON.stringify(selector) ?? '<undefined>';
                _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.warn(`Tried to retrieve data after an update event for ${dataType} with selector ${selectorDetails.substring(0, 120)}, but it threw. ${(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(e)}`);
                callback((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.newPlatformError)(e));
                const notification = constructErrorNotification(e);
                if (notification)
                    _shared_services_notification_service__WEBPACK_IMPORTED_MODULE_7__.notificationService.send(notification);
            }
        };
        const unsubscribe = onDidUpdate(callbackWithUpdate);
        // If the subscriber wants to get the data as soon as possible in addition to running the callback on updates, get the data
        if (retrieveDataImmediately) {
            (async () => {
                try {
                    // Get the data to run the callback immediately so it has the data
                    // TypeScript seems to be unable to figure out these `get${dataType}` types when we wrap
                    // DataProviderInternal in NetworkObject to make IDataProvider, so we have to do all this work
                    // to specify the specific types
                    /* eslint-disable no-type-assertion/no-type-assertion */
                    const data = await dataProviderUntyped[`get${dataType}`
                    // Sadly DataProviderGetter<DataProviderTypes[DataProviderName][typeof dataType]> doesn't
                    // work here. See comment in function signature for more info
                    ](selector);
                    /* eslint-enable */
                    // Only run the callback with this updated data if we have not already received an update so we don't accidentally overwrite the newly updated data with old data
                    // And don't run the callback if we have already unsubscribed
                    if (!receivedUpdate && isSubscribed) {
                        receivedUpdate = true;
                        dataPrevious = data;
                        callback(data);
                    }
                }
                catch (e) {
                    const selectorDetails = JSON.stringify(selector) ?? '<undefined>';
                    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.warn(`Tried to retrieve data immediately for ${dataType} with selector ${selectorDetails.substring(0, 120)}, but it threw. ${(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(e)}`);
                    callback((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.newPlatformError)(e));
                    const notification = constructErrorNotification(e);
                    if (notification)
                        _shared_services_notification_service__WEBPACK_IMPORTED_MODULE_7__.notificationService.send(notification);
                }
            })();
        }
        // Forcing the unsubscribe to be asynchronous to support selector events in the future
        return async () => {
            const didSuccessfullyUnsubscribe = unsubscribe();
            if (didSuccessfullyUnsubscribe)
                isSubscribed = false;
            return didSuccessfullyUnsubscribe;
        };
    };
}
/**
 * Creates a data provider proxy with `subscribe<data_type>` functions. Runs locally and remote
 *
 * @param dataProviderEngine Engine to make the data provider proxy over if local. `undefined` if
 *   remote
 * @param dataProviderPromise Promise to the data provider's network object
 * @param onDidUpdate The event to listen to for updates on the data
 * @returns Data provider proxy with `subscribe<data_type>` functions
 */
function createDataProviderProxy(dataProviderEngine, dataProviderPromise, onDidUpdate) {
    // Object whose methods to run first when the data provider's method is called if they exist here
    // before falling back to the dataProviderEngine's methods. Caches subscribe functions and bound
    // data provider engine methods.
    // TODO: update network objects so remote objects know when methods do not exist, then make IDataProvider.set optional
    const dataProviderInternal = {};
    // Create a proxy that runs the data provider method if it exists or runs the engine method
    // otherwise.
    // Type assert the data provider engine proxy because it is a DataProviderInternal.
    // eslint-disable-next-line no-type-assertion/no-type-assertion
    const dataProvider = new Proxy(dataProviderEngine ??
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        dataProviderInternal, {
        get(obj, prop) {
            // Pass promises through. Assert type of `prop` to index `obj`.
            // eslint-disable-next-line no-type-assertion/no-type-assertion
            if (prop === 'then')
                return obj[prop];
            // Do not let anyone but the data provider engine send updates
            if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(prop) && prop === 'notifyUpdate')
                throw new Error('Cannot run notifyUpdate outside of data provider engine');
            // If the data provider already has the method, run it
            if (prop in dataProviderInternal)
                // Assert type of `prop` to index `dataProviderInternal`.
                // eslint-disable-next-line no-type-assertion/no-type-assertion
                return dataProviderInternal[prop];
            /** Figure out the method that will go on the data provider to run */
            // Any because we want this method to be any method on the data provider type
            let newDataProviderMethod;
            // If they want a subscriber, build a subscribe function specific to the data type used
            if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(prop) && (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.startsWith)(prop, 'subscribe')) {
                const dataType = (0,_shared_models_data_provider_model__WEBPACK_IMPORTED_MODULE_0__.getDataProviderDataTypeFromFunctionName)(prop);
                // Subscribe to run the callback when data changes. Also immediately calls callback with the current value
                newDataProviderMethod = createDataProviderSubscriber(dataProviderPromise, onDidUpdate, dataType);
            }
            // If it's not a subscribe and the data provider engine is provided (meaning this proxy is
            // being created for a local data provider), try to get the engine method
            else if (dataProviderEngine) {
                // Otherwise, get the engine method and bind it
                // There isn't indexing on IDataProviderEngine so normal objects could be used,
                // but now members can't be accessed by indexing in DataProviderService
                // TODO: fix it so it is indexable but can have specific members
                newDataProviderMethod =
                    /* eslint-disable @typescript-eslint/no-explicit-any, no-type-assertion/no-type-assertion */
                    obj[prop]?.bind(dataProviderEngine);
                /* eslint-enable */
            }
            // Save the bound engine method on the data provider to be run later
            if (newDataProviderMethod) {
                // There isn't indexing on IDataProviderEngine so normal objects could be used,
                // but now members can't be accessed by indexing in DataProviderService
                // TODO: fix it so it is indexable but can have specific members
                // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-type-assertion/no-type-assertion
                dataProviderInternal[prop] = newDataProviderMethod;
            }
            return newDataProviderMethod;
        },
        set(obj, prop, value) {
            // We create `subscribe<data_type>` and `notifyUpdate` for extensions, and
            // `subscribe<data_type>` uses `get<data_type>` internally, so those 3 properties can't
            // change after the data provider has been created or bad things will happen.
            // Locally the data provider engine has getters and the data provider service creates the
            // subscribers and notifyUpdate.
            // Remotely this proxy creates subscribers, there is no need for notifyUpdate, and the
            // network object service sets getters as network request functions through this proxy.
            // These request functions should not have to change after they're set for the first time.
            if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(prop) &&
                ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.startsWith)(prop, 'get') || (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.startsWith)(prop, 'subscribe') || prop === 'notifyUpdate') &&
                (prop in obj || prop in dataProviderInternal))
                return false;
            // If we cached a property previously, purge the cache for that property since it is changing.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-type-assertion/no-type-assertion
            if (dataProviderInternal[prop])
                delete dataProviderInternal[prop];
            // Actually set the provided property
            Reflect.set(obj, prop, value);
            return true;
        },
        has(obj, prop) {
            if (prop in dataProviderInternal)
                return true;
            // This proxy provides subscribe methods, so make sure they seem to exist
            if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(prop) && (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.startsWith)(prop, 'subscribe'))
                return true;
            return prop in obj;
        },
    });
    return dataProvider;
}
/**
 * Maps from update instructions returned from `notifyUpdate` or a `set<data_type>` function to an
 * update event to send over the network to inform subscribers to update their data
 *
 * @param updateInstructions Update instructions to reformat into an update event
 * @param dataType The data type of the update instructions (e.g. 'Verse' if update instructions
 *   came from `setVerse`) or `undefined` if being mapped for `notifyUpdate`, which doesn't have a
 *   data type
 * @returns Update event information to send in the `onDidUpdate` event emitter to tell subscribers
 *   to update
 */
function mapUpdateInstructionsToUpdateEvent(updateInstructions, dataType) {
    // If they want to update all data types, let them do it
    if (updateInstructions === '*')
        return updateInstructions;
    // If the update instructions are a string other than '*' (hopefully one of the data types), send
    // an update specifically for that data type
    if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(updateInstructions))
        return [updateInstructions];
    if (Array.isArray(updateInstructions)) {
        // If the update instructions are a non-empty array, send it
        if (updateInstructions.length > 0)
            return updateInstructions;
        // If the update instructions are an empty array, don't update (count as falsy)
        return false;
    }
    // If the update instructions are truthy but neither an array or a string or '*', it means we should just send an update for its own data type
    // However, we don't have a data type if we're mapping for `notifyUpdate`, so just return '*' to update everything.
    if (updateInstructions)
        return dataType !== undefined ? [dataType] : '*';
    // If the update instructions are falsy, do not update
    return false;
}
// We don't care what type the decorated object is. Just want to set some function metadata
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function ignore(target, member) {
    if (typeof target === 'function') {
        target.isIgnored = true;
        return;
    }
    if (!member)
        return;
    target[member].isIgnored = true;
}
// We don't care what type the decorated object is. Just want to set some function metadata
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function doNotNotify(target, member) {
    if (typeof target === 'function') {
        target.doNotNotify = true;
        return;
    }
    if (!member)
        return;
    target[member].doNotNotify = true;
}
/**
 * JSDOC SOURCE DataProviderServiceDecorators
 *
 * A collection of decorators to be used with the data provider service
 *
 * @example To use the `ignore` a decorator on a class's method:
 *
 * ```typescript
 * class MyDataProviderEngine {
 * ï¼ papi.dataProviders.decorators.ignore
 * async getInternal() {}
 * }
 * ```
 *
 * WARNING: Do not copy and paste this example. The `@` symbol does not render correctly in JSDoc
 * code blocks, so a different unicode character was used. Please use a normal `@` when using a
 * decorator.
 */
const decorators = {
    /** JSDOC DESTINATION DataProviderServiceDecoratorsIgnore */
    ignore,
    /** JSDOC DESTINATION DataProviderServiceDecoratorsDoNotNotify */
    doNotNotify,
};
/**
 * Wrap a data provider engine to create a data provider that handles subscriptions for it.
 *
 * Note: This should only run locally when you have the data provider engine. The remote data
 * provider is pretty much just a network object
 *
 * WARNING: this function mutates the provided object. Its `notifyUpdate` and `set<data_type>`
 * methods are layered over to facilitate data provider subscriptions.
 *
 * @param dataProviderEngine Provider engine that handles setting and getting data as well as
 *   informing which listeners should get what updates
 * @param dataProviderPromise Promise to the data provider's network object
 * @param onDidUpdateEmitter Event emitter to use for informing subscribers of updates. The event
 *   just returns what set returns (should be true according to IDataProviderEngine)
 * @returns Data provider layering over the provided data provider engine
 */
function buildDataProvider(dataProviderEngine, dataProviderPromise, onDidUpdateEmitter) {
    // We need an untyped version of the DPE so we can get and set string-template-mapped-type
    // properties on it even though the strings that get templated are one of many possibilities.
    // It seems TypeScript is unable to distinguish that
    // `DataTypeNames<DataProviderTypes[DataProviderName]>` is one specific set of names of data types
    // eslint-disable-next-line no-type-assertion/no-type-assertion
    const dataProviderEngineUntyped = dataProviderEngine;
    // Figure out the available get/set methods' data types
    const dataTypes = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.groupBy)([...(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.getAllObjectFunctionNames)(dataProviderEngine)], (fnName) => {
        // If the function was decorated with @ignore, do not consider it a special function
        if (dataProviderEngineUntyped[fnName].isIgnored)
            return 'other';
        if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.startsWith)(fnName, 'get'))
            return 'get';
        if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.startsWith)(fnName, 'set'))
            return 'set';
        return 'other';
    }, (fnName, fnType) => {
        // If it's not a get or a set, just return an empty string. We aren't planning to use this
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        if (fnType === 'other')
            return '';
        // Grab the data type out of the function names
        return (0,_shared_models_data_provider_model__WEBPACK_IMPORTED_MODULE_0__.getDataProviderDataTypeFromFunctionName)(fnName);
    });
    // Validate that the data provider engine has matching get and set functions
    if (dataTypes.get('get')?.length !== dataTypes.get('set')?.length ||
        dataTypes.get('get')?.some((getDataType) => !dataTypes.get('set')?.includes(getDataType)))
        throw new Error('Data provider engine does not have matching get and set functions!');
    // Layer over data provider engine methods to give it control over emitting updates
    // Layer over the data provider engine's notifyUpdate with one that actually emits an update
    // or if the dpe doesn't have notifyUpdate, give it one
    const dpeNotifyUpdate = dataProviderEngine.notifyUpdate
        ? dataProviderEngine.notifyUpdate.bind(dataProviderEngine)
        : undefined;
    dataProviderEngine.notifyUpdate = (updateInstructions = true, ...args) => {
        // emit an update if updateInstructions indicate to do so
        const updateEventResult = mapUpdateInstructionsToUpdateEvent(updateInstructions, undefined);
        // Run the data provider engine's original `notifyUpdate` with the update result before we send the update
        if (dpeNotifyUpdate)
            dpeNotifyUpdate(updateEventResult, ...args);
        if (updateEventResult)
            onDidUpdateEmitter.emit(updateEventResult);
    };
    // Layer over the data provider engine's set methods with set methods that actually emit an update
    // if they return true
    dataTypes.get('set')?.forEach((dataType) => {
        // If the function was decorated with @doNotNotify, do not overwrite it to automatically emit an update
        if (dataProviderEngineUntyped[`set${dataType}`] &&
            // We don't care about types. We just want to check the decorator
            // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-type-assertion/no-type-assertion
            !dataProviderEngineUntyped[`set${dataType}`].doNotNotify) {
            /* eslint-disable no-type-assertion/no-type-assertion */
            /** Saved bound version of the data provider engine's set so we can call it from here */
            const dpeSet = dataProviderEngineUntyped[`set${dataType}`].bind(dataProviderEngine);
            /** Layered set that emits an update event after running the engine's set */
            dataProviderEngineUntyped[`set${dataType}`] =
                /* eslint-enable */
                async (...args) => {
                    const dpeSetResult = await dpeSet(...args);
                    const updateEventResult = mapUpdateInstructionsToUpdateEvent(dpeSetResult, dataType);
                    if (updateEventResult)
                        onDidUpdateEmitter.emit(updateEventResult);
                    return dpeSetResult;
                };
        }
    });
    // Layer over the data provider engine's dispose method to make sure its update emitter is
    // disposed when it is disposed.
    (0,_shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_5__.overrideDispose)(dataProviderEngine, async () => onDidUpdateEmitter.dispose());
    return createDataProviderProxy(dataProviderEngine, dataProviderPromise, onDidUpdateEmitter.event);
}
/**
 * JSDOC SOURCE DataProviderServiceRegisterEngine
 *
 * Creates a data provider to be shared on the network layering over the provided data provider
 * engine.
 *
 * @param providerName Name this data provider should be called on the network
 * @param dataProviderEngine The object to layer over with a new data provider object
 * @param dataProviderType String to send in a network event to clarify what type of data provider
 *   is represented by this engine. For generic data providers, the default value of `dataProvider`
 *   can be used. For data provider types that have multiple instances (e.g., project data
 *   providers), a unique type name should be used to distinguish from generic data providers.
 * @param dataProviderAttributes Optional object that will be sent in a network event to provide
 *   additional metadata about the data provider represented by this engine.
 *
 *   WARNING: registering a dataProviderEngine mutates the provided object. Its `notifyUpdate` and
 *   `set` methods are layered over to facilitate data provider subscriptions.
 * @returns The data provider including control over disposing of it. Note that this data provider
 *   is a new object distinct from the data provider engine passed in.
 */
async function registerEngine(providerName, dataProviderEngine, dataProviderType = 'dataProvider', dataProviderAttributes = undefined) {
    await initialize();
    if (hasKnown(providerName))
        throw new Error(`Data provider with name ${providerName} is already registered`);
    // We are good to go! Create the data provider
    // Get the object id for this data provider name
    const dataProviderObjectId = getDataProviderObjectId(providerName);
    /**
     * Variable to hold a promise to the final data provider's network object so the local object can
     * reference the network object in its functions
     */
    const dataProviderVariable = new platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.AsyncVariable(`DataProvider-${providerName}`);
    // Create a networked update event
    const onDidUpdateEmitter = _shared_services_network_service__WEBPACK_IMPORTED_MODULE_3__.createNetworkEventEmitter((0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_4__.serializeRequestType)(dataProviderObjectId, ON_DID_UPDATE));
    // Build the data provider
    const dataProviderInternal = buildDataProvider(dataProviderEngine, dataProviderVariable.promise, onDidUpdateEmitter);
    // Set up the data provider to be a network object so other processes can use it
    // Now that we are using shared interface types for data providers, `networkObjectService.set` is
    // messing up all the string template types when it runs it through `DisposableNetworkObject`
    // which has `Omit`. So we need to pass through `unknown` to get to the correct type
    // eslint-disable-next-line no-type-assertion/no-type-assertion
    const disposableDataProvider = (await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_5__.networkObjectService.set(dataProviderObjectId, dataProviderInternal, dataProviderType, dataProviderAttributes));
    // Get the local network object proxy for the data provider so the provider can't be disposed
    // outside the service that registered the provider engine. Assert type without NetworkObject.
    // eslint-disable-next-line no-type-assertion/no-type-assertion
    const dataProvider = (await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_5__.networkObjectService.get(dataProviderObjectId));
    // Update the dataProviderVariable so the internal data provider (specifically its subscribe
    // function) can access the dataProvider appropriately
    if (dataProvider)
        dataProviderVariable.resolveToValue(dataProvider);
    else
        throw Error(`Unable to get network object for data provider: ${dataProviderObjectId}`);
    return disposableDataProvider;
}
/**
 * Creates a data provider to be shared on the network layering over the provided data provider
 * engine.
 *
 * @type `TDataTypes` - The data provider data types served by the data provider to create.
 *
 *   This is not exposed on the papi as it is a helper function to enable other services to layer over
 *   this service and create their own subsets of data providers with other types than
 *   `DataProviders` types using this function and {@link getByType}
 * @param providerName Name this data provider should be called on the network
 * @param dataProviderEngine The object to layer over with a new data provider object
 * @param dataProviderType String to send in a network event to clarify what type of data provider
 *   is represented by this engine. For generic data providers, the default value of `dataProvider`
 *   can be used. For data provider types that have multiple instances (e.g., project data
 *   providers), a unique type name should be used to distinguish from generic data providers.
 * @param dataProviderAttributes Optional object that will be sent in a network event to provide
 *   additional metadata about the data provider represented by this engine.
 *
 *   WARNING: registering a dataProviderEngine mutates the provided object. Its `notifyUpdate` and
 *   `set` methods are layered over to facilitate data provider subscriptions.
 * @returns The data provider including control over disposing of it. Note that this data provider
 *   is a new object distinct from the data provider engine passed in.
 */
// Seems TypeScript doesn't like using a generic string to index DataProviderDataTypes
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function registerEngineByType(providerName, dataProviderEngine, dataProviderType = 'dataProvider', dataProviderAttributes = undefined) {
    // All the types on this function and `registerEngine` are just TypeScript helpers. They do not
    // serve us well in this particular case, so we're ignoring the types and using our own since we
    // are making other kinds of data providers that are not in `DataProviders`
    /* eslint-disable no-type-assertion/no-type-assertion, @typescript-eslint/no-explicit-any */
    return registerEngine(providerName, dataProviderEngine, dataProviderType, dataProviderAttributes);
    /* eslint-enable no-type-assertion/no-type-assertion, @typescript-eslint/no-explicit-any */
}
/**
 * Create a mock local data provider object for connecting to the remote data provider. This object
 * has the properties on the local data provider object that are not strictly network object
 * functions that just send requests across the network. For example, this object has all the
 * `subscribe${dataType}` functions on it since those run code on the local process.
 *
 * @param dataProviderObjectId Network object id corresponding to this data provider
 * @param dataProviderContainer Container that holds a reference to the data provider so this
 *   subscribe function can reference the data provider
 * @returns Local data provider object that represents a remote data provider
 */
// This generic type should be DataProviderInternal because we are making part of a local/internal data provider
function createLocalDataProviderToProxy(dataProviderObjectId, dataProviderPromise) {
    // Create a networked update event
    const onDidUpdate = _shared_services_network_service__WEBPACK_IMPORTED_MODULE_3__.getNetworkEvent((0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_4__.serializeRequestType)(dataProviderObjectId, ON_DID_UPDATE));
    return createDataProviderProxy(undefined, dataProviderPromise, onDidUpdate);
}
/**
 * JSDOC SOURCE DataProviderServiceGet
 *
 * Get a data provider that has previously been set up
 *
 * @param providerName Name of the desired data provider
 * @returns The data provider with the given name if one exists, undefined otherwise
 */
async function get(providerName) {
    await initialize();
    // Get the object id for this data provider name
    const dataProviderObjectId = getDataProviderObjectId(providerName);
    // Get the network object for this data provider. Assert to specified generic type.
    /* eslint-disable no-type-assertion/no-type-assertion */
    const dataProvider = (await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_5__.networkObjectService.get(dataProviderObjectId, createLocalDataProviderToProxy));
    /* eslint-enable */
    if (!dataProvider) {
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_6__.logger.info(`No data provider found with name = ${providerName}`);
        return undefined;
    }
    return dataProvider;
}
/**
 * Get a data provider that has previously been set up
 *
 * @type `T` - The type of data provider to get. Use `IDataProvider<TDataProviderDataTypes>`,
 *   specifying your own types, or provide a custom data provider type
 *
 *   This is not exposed on the papi as it is a helper function to enable other services to layer over
 *   this service and create their own subsets of data providers with other types than
 *   `DataProviders` types using this function and {@link registerEngineByType}
 * @param providerName Name of the desired data provider
 * @returns The data provider with the given name if one exists, undefined otherwise
 */
// Seems TypeScript doesn't like using a generic string to index DataProviderDataTypes
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function getByType(providerName) {
    // All the types on this function and `get` are just TypeScript helpers. They do not serve us well
    // in this particular case, so we're ignoring the types and using our own since we are getting
    // other kinds of data providers that are not in `DataProviders`
    // eslint-disable-next-line no-type-assertion/no-type-assertion, @typescript-eslint/no-explicit-any
    return get(providerName);
}
/**
 * JSDOC SOURCE dataProviderService
 *
 * Service that allows extensions to send and receive data to/from other extensions
 */
const dataProviderService = {
    hasKnown,
    registerEngine,
    get,
    decorators,
    DataProviderEngine: _shared_models_data_provider_engine_model__WEBPACK_IMPORTED_MODULE_1__.DataProviderEngine,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dataProviderService);


/***/ }),

/***/ "./src/shared/services/extension-asset.service.ts":
/*!********************************************************!*\
  !*** ./src/shared/services/extension-asset.service.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CATEGORY_EXTENSION_ASSET: () => (/* binding */ CATEGORY_EXTENSION_ASSET),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   extensionAssetService: () => (/* binding */ extensionAssetService)
/* harmony export */ });
/* harmony import */ var _shared_utils_internal_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/utils/internal-util */ "./src/shared/utils/internal-util.ts");
/* harmony import */ var _shared_services_network_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/services/network.service */ "./src/shared/services/network.service.ts");
/* harmony import */ var _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/services/logger.service */ "./src/shared/services/logger.service.ts");
/* harmony import */ var _shared_utils_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @shared/utils/util */ "./src/shared/utils/util.ts");




let getAsset;
let isInitialized = false;
let initializePromise;
/** Prefix on requests that indicates that the request is on the extension asset service */
const CATEGORY_EXTENSION_ASSET = 'extensionAsset';
/** Name for request to get an extension asset */
const GET_EXTENSION_ASSET_REQUEST = 'getExtensionAsset';
/**
 * Load an asset from the given extension's installation directory
 *
 * @param extensionName Name of the extension
 * @param assetName Name of the asset including any path information
 * @returns Base 64 encoded value of the asset if it exists, otherwise undefined
 */
const getExtensionAsset = async (extensionName, assetName) => {
    if ((0,_shared_utils_internal_util__WEBPACK_IMPORTED_MODULE_0__.isExtensionHost)()) {
        try {
            return (await getAsset(extensionName, assetName)).toString('base64');
        }
        catch (error) {
            _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_2__.logger.error(`Could not get asset "${assetName}" from "${extensionName}": ${error}`);
            return undefined;
        }
    }
    else {
        return _shared_services_network_service__WEBPACK_IMPORTED_MODULE_1__.request((0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_3__.serializeRequestType)(CATEGORY_EXTENSION_ASSET, GET_EXTENSION_ASSET_REQUEST), extensionName, assetName);
    }
};
/** This should only be called by the extension host. */
const initialize = async () => {
    if (initializePromise)
        return initializePromise;
    if (!(0,_shared_utils_internal_util__WEBPACK_IMPORTED_MODULE_0__.isExtensionHost)())
        return undefined;
    initializePromise = (async () => {
        if (isInitialized)
            return;
        getAsset = (await Promise.resolve().then(function webpackMissingModule() { var e = new Error("Cannot find module '@extension-host/services/asset-retrieval.service'"); e.code = 'MODULE_NOT_FOUND'; throw e; })).default;
        const requestType = (0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_3__.serializeRequestType)(CATEGORY_EXTENSION_ASSET, GET_EXTENSION_ASSET_REQUEST);
        await _shared_services_network_service__WEBPACK_IMPORTED_MODULE_1__.registerRequestHandler(requestType, async (extensionName, assetName) => {
            return getExtensionAsset(extensionName, assetName);
        }, {
            method: {
                summary: 'Get an asset from an extension',
                params: [
                    {
                        name: 'extensionName',
                        required: true,
                        summary: 'Name of the extension to get the asset from',
                        schema: { type: 'string' },
                    },
                    {
                        name: 'assetName',
                        required: true,
                        summary: 'Name of the asset to get',
                        schema: { type: 'string' },
                    },
                ],
                result: {
                    name: 'return value',
                    summary: 'Base64 encoded asset if it exists',
                    schema: { oneOf: [{ type: 'string' }, { type: 'null' }] },
                },
            },
        });
        isInitialized = true;
    })();
    return initializePromise;
};
const extensionAssetService = {
    initialize,
    getExtensionAsset,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (extensionAssetService);


/***/ }),

/***/ "./src/shared/services/localization.service-model.ts":
/*!***********************************************************!*\
  !*** ./src/shared/services/localization.service-model.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   localizationServiceObjectToProxy: () => (/* binding */ localizationServiceObjectToProxy),
/* harmony export */   localizationServiceProviderName: () => (/* binding */ localizationServiceProviderName)
/* harmony export */ });
/** JSDOC DESTINATION localizationServiceProviderName */
const localizationServiceProviderName = 'platform.localizationDataServiceDataProvider';
const localizationServiceObjectToProxy = Object.freeze({
    /**
     * JSDOC SOURCE localizationServiceProviderName
     *
     * This name is used to register the localization data provider on the papi. You can use this name
     * to find the data provider when accessing it using the useData hook
     */
    dataProviderName: localizationServiceProviderName,
});


/***/ }),

/***/ "./src/shared/services/localization.service.ts":
/*!*****************************************************!*\
  !*** ./src/shared/services/localization.service.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   localizationService: () => (/* binding */ localizationService)
/* harmony export */ });
/* harmony import */ var _shared_services_data_provider_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/services/data-provider.service */ "./src/shared/services/data-provider.service.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");
/* harmony import */ var _shared_services_localization_service_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/services/localization.service-model */ "./src/shared/services/localization.service-model.ts");



let dataProvider;
let initializationPromise;
async function initialize() {
    if (!initializationPromise) {
        initializationPromise = new Promise((resolve, reject) => {
            const executor = async () => {
                try {
                    const provider = await _shared_services_data_provider_service__WEBPACK_IMPORTED_MODULE_0__.dataProviderService.get(_shared_services_localization_service_model__WEBPACK_IMPORTED_MODULE_2__.localizationServiceProviderName);
                    if (!provider)
                        throw new Error('Localization service undefined');
                    dataProvider = provider;
                    resolve();
                }
                catch (error) {
                    reject(error);
                }
            };
            executor();
        });
    }
    return initializationPromise;
}
const localizationService = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.createSyncProxyForAsyncObject)(async () => {
    await initialize();
    return dataProvider;
}, {
    ..._shared_services_localization_service_model__WEBPACK_IMPORTED_MODULE_2__.localizationServiceObjectToProxy,
    getLocalizedIdFromBookNumber(bookNum, localizationLanguage) {
        return (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.getLocalizedIdFromBookNumber)(bookNum, localizationLanguage, ({ localizeKey, ...options }) => localizationService.getLocalizedString({
            ...options,
            localizeKey: `%${localizeKey}%`,
        }));
    },
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localizationService);


/***/ }),

/***/ "./src/shared/services/logger.service.ts":
/*!***********************************************!*\
  !*** ./src/shared/services/logger.service.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WARN_TAG: () => (/* binding */ WARN_TAG),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   formatLog: () => (/* binding */ formatLog),
/* harmony export */   logger: () => (/* binding */ logger)
/* harmony export */ });
/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chalk */ "./node_modules/chalk/source/index.js");
/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(chalk__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var electron_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! electron-log */ "./node_modules/electron-log/src/index.js");
/* harmony import */ var electron_log__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(electron_log__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _shared_utils_internal_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/utils/internal-util */ "./src/shared/utils/internal-util.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");




const WARN_TAG = '<WARN>';
/**
 * Destructure a line from an Error object
 *
 * @param errorLine Single line from an Error object string
 * @returns Object containing the function name, file name, line number, and column number from the
 *   line of the Error object string. If the line couldn't be parsed, then undefined.
 */
function parseErrorLine(errorLine) {
    // A few example lines to parse:
    // "    at functionName (filename.js:15:27)"
    // "at /home/username/paranext-core/src/shared/services/logger.service.ts:119:22"
    // "     at Timeout.i [as _onTimeout] (/home/username/paranext-core/extensions/dist/evil/evil.js:1:591)"
    const regex = /at[\s+]?([\w .[\]<>]+)?\s+\(?(.*?):(\d+):(\d+)\)?$/;
    const matches = errorLine.match(regex);
    // This console log is helpful if you need to see why some Error line isn't parsing as expected
    // eslint-disable-next-line no-console
    // console.log(`**** LINE: ${errorLine}\nResulting filename: ${matches?.at(2)}`);
    if (matches && matches.length === 5) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [_, functionName, fileName, lineNumber, columnNumber] = matches;
        return {
            functionName,
            fileName,
            lineNumber: parseInt(lineNumber, 10),
            columnNumber: parseInt(columnNumber, 10),
        };
    }
    if (matches && matches.length === 4) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [_, fileName, lineNumber, columnNumber] = matches;
        return {
            functionName: '',
            fileName,
            lineNumber: parseInt(lineNumber, 10),
            columnNumber: parseInt(columnNumber, 10),
        };
    }
    return undefined;
}
/**
 * Examine the call stack and return a parsed string containing the function name, file name, line
 * number, and column number where the call to the logger was made.
 *
 * @returns String that is suitable to attach to log output to indicate who what code wants to log
 */
function identifyCaller() {
    const { stack } = new Error();
    if (!stack)
        return undefined;
    let details;
    const lines = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__.split)(stack, '\n');
    // Start at 3 to skip the "Error" line, this function's stack frame, and this function's caller
    for (let lineNumber = 3; lineNumber < lines.length; lineNumber += 1) {
        // Skip over all logging library frames to get to the real call
        if (!(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__.includes)(lines[lineNumber], 'node_modules') && !(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__.includes)(lines[lineNumber], 'node:')) {
            details = parseErrorLine(lines[lineNumber]);
            if (details)
                break;
        }
    }
    if (!details)
        return '';
    const functionName = details.functionName ? `${details.functionName} ` : '';
    const filePath = process.platform === 'win32' ? details.fileName : `file://${details.fileName}`;
    return `[at ${functionName}${filePath}:${details.lineNumber}:${details.columnNumber}]`;
}
/**
 * Format a string of a service message
 *
 * @param message Message from the service
 * @param serviceName Name of the service to show in the log
 * @param tag Optional tag at the end of the service name
 * @returns Formatted string of a service message
 */
function formatLog(message, serviceName, tag = '') {
    // Remove the new line at the end of every message coming from stdout from other processes
    const messageTrimmed = message.trimEnd();
    const openTag = `[${serviceName}${tag ? ' ' : ''}${tag}]`;
    if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__.includes)(messageTrimmed, '\n')) {
        const closeTag = `[/${serviceName}${tag ? ' ' : ''}${tag}]`;
        // Multi-line
        return `\n${openTag}\n${messageTrimmed}\n${closeTag}`;
    }
    return `${openTag} ${messageTrimmed}`;
}
/** Abstract and shim the logger */
if ((0,_shared_utils_internal_util__WEBPACK_IMPORTED_MODULE_2__.isClient)()) {
    (electron_log__WEBPACK_IMPORTED_MODULE_1___default().transports).console.level = globalThis.logLevel;
    if ((0,_shared_utils_internal_util__WEBPACK_IMPORTED_MODULE_2__.isRenderer)())
        // On the renderer, insert formatting before sending
        electron_log__WEBPACK_IMPORTED_MODULE_1___default().hooks.push((message) => {
            const caller = identifyCaller();
            return {
                ...message,
                data: message.data.map((logLine) => formatLog(caller ? `${logLine} ${caller}` : `${logLine}`, (0,_shared_utils_internal_util__WEBPACK_IMPORTED_MODULE_2__.getProcessType)(), 
                // Renderer sends back with log level of log. Not sure why it's not in the type
                // eslint-disable-next-line no-type-assertion/no-type-assertion
                message.level === 'log' ? undefined : message.level)),
            };
        });
    else if ((0,_shared_utils_internal_util__WEBPACK_IMPORTED_MODULE_2__.isExtensionHost)())
        // Add a tag for warnings so we can recognize them outside the process.
        electron_log__WEBPACK_IMPORTED_MODULE_1___default().hooks.push((message) => {
            const caller = identifyCaller();
            const lineEnd = caller ? ` ${caller}` : '';
            return {
                ...message,
                data: message.data.map((logLine) => message.level === 'warn' ? `${WARN_TAG}${logLine}${lineEnd}` : `${logLine}${lineEnd}`),
            };
        });
    else {
        // eslint-disable-next-line no-console
        console.warn(chalk__WEBPACK_IMPORTED_MODULE_0___default().yellow(`Unexpected process type: ${globalThis.processType}`));
    }
}
else {
    electron_log__WEBPACK_IMPORTED_MODULE_1___default().initialize();
    (electron_log__WEBPACK_IMPORTED_MODULE_1___default().transports).console.level = globalThis.logLevel;
    (electron_log__WEBPACK_IMPORTED_MODULE_1___default().transports).console.format = '{h}:{i}:{s} {text}';
    (electron_log__WEBPACK_IMPORTED_MODULE_1___default().transports).console.writeFn = ({ message: msg }) => {
        let message = `${msg.data}`;
        // If we're piping through a log message from another service, don't add another file path
        // Messages from other services all start with "[service name]"
        if (!/\[[\w ]+\]/.test(message)) {
            const caller = identifyCaller();
            message = caller ? `${message} ${caller}` : `${message}`;
        }
        /* eslint-disable no-console */
        switch (msg.level) {
            case 'info':
                console.log(message);
                break;
            case 'warn':
                console.log(chalk__WEBPACK_IMPORTED_MODULE_0___default().yellow(message));
                break;
            case 'error':
                console.log(chalk__WEBPACK_IMPORTED_MODULE_0___default().red(message));
                break;
            default:
                console.log(message);
                break;
        }
        /* eslint-enable */
    };
    (electron_log__WEBPACK_IMPORTED_MODULE_1___default().transports).file.level = globalThis.logLevel;
}
/**
 * JSDOC SOURCE logger
 *
 * All extensions and services should use this logger to provide a unified output of logs
 */
const logger = (electron_log__WEBPACK_IMPORTED_MODULE_1___default());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (logger);


/***/ }),

/***/ "./src/shared/services/menu-data.service-model.ts":
/*!********************************************************!*\
  !*** ./src/shared/services/menu-data.service-model.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   menuDataServiceObjectToProxy: () => (/* binding */ menuDataServiceObjectToProxy),
/* harmony export */   menuDataServiceProviderName: () => (/* binding */ menuDataServiceProviderName)
/* harmony export */ });
/** JSDOC DESTINATION menuDataServiceProviderName */
const menuDataServiceProviderName = 'platform.menuDataServiceDataProvider';
const menuDataServiceObjectToProxy = Object.freeze({
    /**
     * JSDOC SOURCE menuDataServiceProviderName
     *
     * This name is used to register the menu data data provider on the papi. You can use this name to
     * find the data provider when accessing it using the useData hook
     */
    dataProviderName: menuDataServiceProviderName,
});


/***/ }),

/***/ "./src/shared/services/menu-data.service.ts":
/*!**************************************************!*\
  !*** ./src/shared/services/menu-data.service.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   menuDataService: () => (/* binding */ menuDataService)
/* harmony export */ });
/* harmony import */ var _shared_services_data_provider_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/services/data-provider.service */ "./src/shared/services/data-provider.service.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");
/* harmony import */ var _shared_services_menu_data_service_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/services/menu-data.service-model */ "./src/shared/services/menu-data.service-model.ts");



let dataProvider;
let initializationPromise;
async function initialize() {
    if (!initializationPromise) {
        initializationPromise = new Promise((resolve, reject) => {
            const executor = async () => {
                try {
                    const provider = await _shared_services_data_provider_service__WEBPACK_IMPORTED_MODULE_0__.dataProviderService.get(_shared_services_menu_data_service_model__WEBPACK_IMPORTED_MODULE_2__.menuDataServiceProviderName);
                    if (!provider)
                        throw new Error('Menu data service undefined');
                    dataProvider = provider;
                    resolve();
                }
                catch (error) {
                    reject(error);
                }
            };
            executor();
        });
    }
    return initializationPromise;
}
const menuDataService = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.createSyncProxyForAsyncObject)(async () => {
    await initialize();
    return dataProvider;
}, _shared_services_menu_data_service_model__WEBPACK_IMPORTED_MODULE_2__.menuDataServiceObjectToProxy);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (menuDataService);


/***/ }),

/***/ "./src/shared/services/network-object-status.service.ts":
/*!**************************************************************!*\
  !*** ./src/shared/services/network-object-status.service.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   networkObjectStatusService: () => (/* binding */ networkObjectStatusService)
/* harmony export */ });
/* harmony import */ var _shared_models_network_object_status_service_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/models/network-object-status.service-model */ "./src/shared/models/network-object-status.service-model.ts");
/* harmony import */ var _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/services/network-object.service */ "./src/shared/services/network-object.service.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");



let networkObject;
let initializationPromise;
async function initialize() {
    if (!initializationPromise) {
        initializationPromise = new Promise((resolve, reject) => {
            const executor = async () => {
                try {
                    const localNetworkObjectStatusService = await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_1__.networkObjectService.get(_shared_models_network_object_status_service_model__WEBPACK_IMPORTED_MODULE_0__.networkObjectStatusServiceNetworkObjectName);
                    if (!localNetworkObjectStatusService)
                        throw new Error(`${_shared_models_network_object_status_service_model__WEBPACK_IMPORTED_MODULE_0__.networkObjectStatusServiceNetworkObjectName} is not available as a network object`);
                    networkObject = localNetworkObjectStatusService;
                    resolve();
                }
                catch (error) {
                    reject(error);
                }
            };
            executor();
        });
    }
    return initializationPromise;
}
// If we ever want to be more clever, we could just keep a local (to this process) cache of the
// active network objects. If we do that, we'll have to deal with initial race conditions around
// getting a network object disposed message in this process before handling the snapshot from
// the service host that includes the (now disposed) network object. Just asking the remote service
// is less error prone, but slower, whenever we get a request for the latest network objects.
async function getAllNetworkObjectDetails() {
    await initialize();
    return networkObject.getAllNetworkObjectDetails();
}
// Ideally we would use this inside the network object service to be event-based instead of polling
// while waiting for network objects to be created. That would create a circular dependency between
// this service and the network object service, though, which is most easily resolved by merging
// this code into the network object service. That service is pretty big as it is, so to optimize
// for code understandability we'll just leave it as-is and poll inside the network object service
// `get` for now. Other services will have to call this directly if they want to be event based.
async function waitForNetworkObject(objectDetailsToMatch, timeoutInMS) {
    const asyncVar = new platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.AsyncVariable(`wait-for-net-obj with details ${JSON.stringify(objectDetailsToMatch)}`, timeoutInMS ?? -1);
    try {
        // Watch the stream of incoming network objects before getting a snapshot to avoid race conditions
        const unsub = (0,_shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_1__.onDidCreateNetworkObject)((networkObjectDetails) => {
            if (!asyncVar.hasSettled && (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.isSubset)(networkObjectDetails, objectDetailsToMatch)) {
                asyncVar.resolveToValue(networkObjectDetails, false);
            }
            if (asyncVar.hasSettled) {
                unsub();
            }
        });
        // Now check if the needed network object has already been created
        const existingNetworkObjectDetails = await getAllNetworkObjectDetails();
        if (!asyncVar.hasSettled) {
            const match = Object.values(existingNetworkObjectDetails).find((networkObjectDetails) => (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.isSubset)(networkObjectDetails, objectDetailsToMatch));
            if (match) {
                asyncVar.resolveToValue(match, false);
            }
        }
    }
    catch (e) {
        const message = `waitForNetworkObject failed for details ${JSON.stringify(objectDetailsToMatch)}! ${e}`;
        asyncVar.rejectWithReason(message, true);
        throw e;
    }
    return asyncVar.promise;
}
/**
 * JSDOC SOURCE networkObjectStatusService
 *
 * Provides functions related to the set of available network objects
 */
const networkObjectStatusService = {
    getAllNetworkObjectDetails,
    waitForNetworkObject,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (networkObjectStatusService);


/***/ }),

/***/ "./src/shared/services/network-object.service.ts":
/*!*******************************************************!*\
  !*** ./src/shared/services/network-object.service.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   minimalNetworkObjectService: () => (/* binding */ minimalNetworkObjectService),
/* harmony export */   networkObjectService: () => (/* binding */ networkObjectService),
/* harmony export */   onDidCreateNetworkObject: () => (/* binding */ onDidCreateNetworkObject),
/* harmony export */   onDidDisposeNetworkObject: () => (/* binding */ onDidDisposeNetworkObject),
/* harmony export */   overrideDispose: () => (/* binding */ overrideDispose)
/* harmony export */ });
/* harmony import */ var _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/services/network.service */ "./src/shared/services/network.service.ts");
/* harmony import */ var _shared_utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/utils/util */ "./src/shared/utils/util.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");
/* harmony import */ var _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @shared/services/logger.service */ "./src/shared/services/logger.service.ts");
/* harmony import */ var _shared_models_openrpc_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @shared/models/openrpc.model */ "./src/shared/models/openrpc.model.ts");
// #region imports





// #endregion
// #region initialize
/** Whether this service has finished setting up */
let isInitialized = false;
/** Promise that resolves when this service is finished initializing */
let initializePromise;
/** Sets up the service. Only runs once and always returns the same promise after that */
const initialize = () => {
    if (initializePromise)
        return initializePromise;
    initializePromise = (async () => {
        if (isInitialized)
            return;
        // TODO: Might be best to make a singleton or something
        await _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__.initialize();
        isInitialized = true;
    })();
    return initializePromise;
};
// #endregion
// #region Helpers for talking to the network about objects
/** Prefix on requests that indicates that the request is related to a network object */
const CATEGORY_NETWORK_OBJECT = 'object';
/**
 * Gets a request type for network requests for the specified network object ID and function name
 * (if provided)
 */
const getNetworkObjectRequestType = (id, functionName) => (0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_1__.serializeRequestType)(CATEGORY_NETWORK_OBJECT, `${id}${functionName ? `.${functionName}` : ''}`);
/**
 * Determine if a network object with the specified ID exists remotely (does not check locally)
 *
 * @param id ID of the network object - all processes must use this ID to look up this network
 *   object
 * @param retry Whether or not the network service should retry failed requests several times
 * @returns Empty array if there is a remote network object with this ID, undefined otherwise. TODO:
 *   return array of all eligible functions
 */
const getRemoteNetworkObjectFunctions = async (id) => {
    try {
        return await _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__.request(getNetworkObjectRequestType(id));
    }
    catch (e) {
        // No processes are registered to handle this get request, meaning a network object with this ID does not exist
        // TODO: check the message and throw the error if it is not the right message?
        return undefined;
    }
};
/** This service stores both local and remote network objects together */
var NetworkObjectRegistrationType;
(function (NetworkObjectRegistrationType) {
    NetworkObjectRegistrationType["Local"] = "local";
    NetworkObjectRegistrationType["Remote"] = "remote";
})(NetworkObjectRegistrationType || (NetworkObjectRegistrationType = {}));
/** Map of ID to network object */
const networkObjectRegistrations = new Map();
/**
 * Search locally known network objects for the given ID. Don't look on the network for more
 * objects.
 *
 * @returns Whether we know of an existing network object with the provided ID already on the
 *   network
 */
const hasKnown = (id) => networkObjectRegistrations.has(id);
/**
 * Emitter for when a network object is created. Includes the list of functions exposed by the
 * network object.
 */
const onDidCreateNetworkObjectEmitter = _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__.createNetworkEventEmitter((0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_1__.serializeRequestType)(CATEGORY_NETWORK_OBJECT, 'onDidCreateNetworkObject'));
/**
 * Event that fires when a new object has been created on the network (locally or remotely). The
 * event contains information about the new network object.
 */
const onDidCreateNetworkObject = onDidCreateNetworkObjectEmitter.event;
/**
 * Emitter for when a network object is disposed. Provides the ID so that the local emitter specific
 * to that object can be run.
 *
 * Only run on local network object registration! Processes should only dispose their own network
 * objects
 */
const onDidDisposeNetworkObjectEmitter = _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__.createNetworkEventEmitter((0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_1__.serializeRequestType)(CATEGORY_NETWORK_OBJECT, 'onDidDisposeNetworkObject'));
/** Event that fires with a network object ID when that object is disposed locally or remotely */
const onDidDisposeNetworkObject = onDidDisposeNetworkObjectEmitter.event;
/** Runs to dispose of local and remote network objects when we receive events telling us to do so */
onDidDisposeNetworkObject((id) => {
    const networkObjectRegistration = networkObjectRegistrations.get(id);
    if (networkObjectRegistration) {
        // Alert users of this specific network object that it was disposed
        networkObjectRegistration.onDidDisposeEmitter.emit();
        // Dispose of the network object registration itself
        networkObjectRegistration.onDidDisposeEmitter.dispose();
        // Dispose of the proxy
        networkObjectRegistration.revokeProxy();
        // Dispose of the network object registration
        networkObjectRegistrations.delete(id);
    }
});
// #endregion
// #region Helpers for get and set
// We need this to protect simultaneous calls to get and/or set the same network objects
const getterMutexMap = new platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.MutexMap();
const setterMutexMap = new platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.MutexMap();
/** This proxy enables calling functions on a network object that exists in a different process */
const createRemoteProxy = (id, base) => Proxy.revocable(base ?? {}, {
    get: (target, key) => {
        // Block access to constructors and dispose
        if (key === 'constructor' || key === 'dispose')
            return undefined;
        // Assert type of `key` to index `target`.
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        if (key === 'then' || key in target)
            return target[key];
        // If the prop requested is a symbol, that doesn't work over the network. Reject
        if (!(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(key))
            return undefined;
        // Don't create remote proxies for events
        if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.startsWith)(key, 'on'))
            return undefined;
        // If the local network object doesn't have the property, build a request for it
        const requestFunction = (...args) => _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__.request(getNetworkObjectRequestType(id, key), ...args);
        // Save the new request function as the actual function on the object so we don't have to
        // create this function multiple times.
        // TODO: Try making a separate array of lazy loaded request functions instead of putting them
        // on the object and thereby reducing the usefulness of revokeProxy
        // Took the indexing off of NetworkableObject so normal objects could be used,
        // but now members can't be accessed by indexing in NetworkObjectService
        // TODO: fix it so it is indexable but can have specific members
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-type-assertion/no-type-assertion
        target[key] = requestFunction;
        return requestFunction;
    },
    set(obj, prop, value) {
        // If we cached a property previously, purge the cache for that property since it is changing.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-type-assertion/no-type-assertion
        if (obj[prop])
            delete obj[prop];
        // Actually set the provided property
        Reflect.set(obj, prop, value);
        return true;
    },
});
/**
 * This proxy enables calling functions on a network object that exists in the same process, but is
 * owned by some other service. We only give the actual network object to the owning service.
 */
const createLocalProxy = (objectBeingSet) => Proxy.revocable(objectBeingSet, {
    get: (target, key) => {
        // Block access to constructors and dispose
        if (key === 'constructor' || key === 'dispose')
            return undefined;
        // Don't proxy events except "onDidDispose" since that's the only way for callers to
        // register functions to run when the object is going away
        if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(key) && (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.startsWith)(key, 'on') && key !== 'onDidDispose')
            return undefined;
        return Reflect.get(target, key, objectBeingSet);
    },
});
/** Construct details about an object that is becoming a network object */
function createNetworkObjectDetails(id, objectType, objectToShare, objectAttributes) {
    const objectFunctionNames = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.getAllObjectFunctionNames)(objectToShare, id);
    // Remove functions we don't allow to be called remotely on network objects
    objectFunctionNames.delete('constructor');
    objectFunctionNames.delete('dispose');
    objectFunctionNames.forEach((functionName) => {
        // If we come up with some better way to identify events, we can remove this and related checks
        if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.startsWith)(functionName, 'on'))
            objectFunctionNames.delete(functionName);
    });
    return {
        id,
        objectType,
        functionNames: [...objectFunctionNames].sort(),
        attributes: objectAttributes,
    };
}
/** Set an `onDidDispose` property on the object to mutate. Throw if one already exists. */
const overrideOnDidDispose = (objectId, objectToMutate, newOnDidDispose) => {
    if (objectToMutate.onDidDispose) {
        throw new Error(`You can't register "${objectId}" as a network object since it already has an onDidDispose property`);
    }
    objectToMutate.onDidDispose = newOnDidDispose;
};
/** If `dispose` already exists on `objectToMutate`, we will call it in addition to `newDispose` */
function overrideDispose(objectToMutate, newDispose) {
    if (objectToMutate.dispose) {
        const oldDispose = objectToMutate.dispose.bind(objectToMutate);
        objectToMutate.dispose = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.aggregateUnsubscriberAsyncs)([oldDispose, newDispose]);
    }
    else {
        objectToMutate.dispose = newDispose;
    }
}
// #endregion
// #region get
/**
 * Get a network object that has previously been set up to be shared on the network. A network
 * object is a proxy to an object living somewhere else that local code can use.
 *
 * Running this function twice with the same inputs yields the same network object.
 *
 * @param id ID of the network object - all processes must use this ID to look up this network
 *   object
 * @param createLocalObjectToProxy Function that creates an object that the network object proxy
 *   will be based upon. The object this function creates cannot have an `onDidDispose` property.
 *   This function is useful for setting up network events on a network object.
 * @returns A promise for the network object with specified ID if one exists, undefined otherwise
 */
const get = async (id, createLocalObjectToProxy) => {
    await initialize();
    // Don't allow simultaneous gets to run for the same network object
    const lock = getterMutexMap.get(id);
    return lock.runExclusive(async () => {
        // If we already have this network object, return it
        const networkObjectRegistration = networkObjectRegistrations.get(id);
        if (networkObjectRegistration)
            // Assert to specified generic type.
            // eslint-disable-next-line no-type-assertion/no-type-assertion
            return networkObjectRegistration.networkObject;
        // We don't already have this network object. See if it exists somewhere else.
        const networkObjectFunctions = await getRemoteNetworkObjectFunctions(id);
        if (!networkObjectFunctions)
            return undefined;
        // Before we create a remote proxy, see if there was a race condition for a local proxy.
        // It is possible we called `get`, then while awaiting the network response something else in
        // this process called `set` on the object we were looking for.
        const networkObjectRegistrationSecondChance = networkObjectRegistrations.get(id);
        if (networkObjectRegistrationSecondChance)
            // Assert to specified generic type.
            // eslint-disable-next-line no-type-assertion/no-type-assertion
            return networkObjectRegistrationSecondChance.networkObject;
        // At this point, the object exists remotely but does not yet exist locally.
        // The base object created below might need a reference to the final network object. Since the
        // network object doesn't exist yet, create an async variable now and fill it in after the
        // network object is created.
        const networkObjectVariable = new platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.AsyncVariable(`NetworkObject-${id}`);
        // Create the base object that will be proxied for remote calls.
        // If a property exists on the base object, we use it and won't look for it on the remote object.
        // If a property does not exist on the base object, it is assumed to exist on the remote object.
        const baseObject = createLocalObjectToProxy
            ? // Assert to specified generic type.
                // eslint-disable-next-line no-type-assertion/no-type-assertion
                createLocalObjectToProxy(id, networkObjectVariable.promise)
            : {};
        // Create a proxy with functions that will send requests to the remote object
        const remoteProxy = createRemoteProxy(id, baseObject);
        // Setup onDidDispose so that services will know when the proxy is dead
        const eventEmitter = new platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.PlatformEventEmitter();
        overrideOnDidDispose(id, remoteProxy.proxy, eventEmitter.event);
        // The network object is finished! Rename it so we know it is finished.
        // Assert to specified generic type.
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        const networkObject = remoteProxy.proxy;
        // Save the network object for future lookups
        networkObjectRegistrations.set(id, {
            registrationType: NetworkObjectRegistrationType.Remote,
            onDidDisposeEmitter: eventEmitter,
            networkObject,
            revokeProxy: remoteProxy.revoke,
        });
        // Resolve the promise to the network object so promise holders can complete their work
        networkObjectVariable.resolveToValue(networkObject);
        return networkObject;
    });
};
// #endregion
// #region set
/**
 * Set up an object to be shared on the network.
 *
 * @param id ID of the object to share on the network. All processes must use this ID to look it up.
 * @param objectToShare The object to set up as a network object. It will have an event named
 *   `onDidDispose` added to its properties. An error will be thrown if the object already had an
 *   `onDidDispose` property on it. If the object already contained a `dispose` function, a new
 *   `dispose` function will be set that calls the existing function (amongst other things). If the
 *   object did not already define a `dispose` function, one will be added.
 *
 *   WARNING: setting a network object mutates the provided object.
 * @returns `objectToShare` modified to be a network object
 */
const set = async (id, objectToShare, objectType = 'object', objectAttributes = undefined, objectDocumentation = {}) => {
    await initialize();
    // Don't allow simultaneous sets to run for the same network object
    const lock = setterMutexMap.get(id);
    return lock.runExclusive(async () => {
        // Check to see if we already know there is a network object with this ID.
        if (hasKnown(id))
            throw new Error(`Network object with id ${id} is already registered`);
        // Check if there is a network object with this ID remotely by trying to register it
        const unsubPromises = [
            _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__.registerRequestHandler(getNetworkObjectRequestType(id), () => Promise.resolve(true), {
                method: {
                    summary: objectDocumentation.summary ?? '',
                    description: objectDocumentation.description ?? '',
                    params: [],
                    result: {
                        name: 'return value',
                        summary: 'Does the network object exist?',
                        required: true,
                        schema: {
                            type: 'boolean',
                        },
                    },
                },
                components: objectDocumentation.components,
            }),
        ];
        // Also check if we can register all of the network object's functions
        const netObjDetails = createNetworkObjectDetails(id, objectType, 
        // NetworkableObject isn't specific enough and changing it is painful
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        objectToShare, objectAttributes);
        netObjDetails.functionNames.forEach((functionName) => {
            const requestType = getNetworkObjectRequestType(id, functionName);
            const methodDocs = objectDocumentation.methods?.find((method) => method.name === functionName) ??
                (0,_shared_models_openrpc_model__WEBPACK_IMPORTED_MODULE_4__.getEmptyMethodDocs)();
            const unsub = _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__.registerRequestHandler(requestType, 
            // Assert as any to allow indexing on the function name
            // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-type-assertion/no-type-assertion
            (...args) => Promise.resolve(objectToShare[functionName](...args)), { method: methodDocs });
            unsubPromises.push(unsub);
        });
        // Await all of the registrations finishing, successful or not
        const registrationResponses = await Promise.allSettled(unsubPromises);
        const didSuccessfullyRegister = registrationResponses.every((response) => response.status === 'fulfilled');
        if (!didSuccessfullyRegister) {
            // Clean up by unregistering any successful request handlers
            const rejectedRequestHandlerReasons = [];
            await Promise.all(registrationResponses.map(async (response, registrationIndex) => {
                if (response.status === 'fulfilled')
                    // Run the unsubscriber for this registration
                    (await unsubPromises[registrationIndex])();
                // Collect the reasons for failure so we can throw a useful error
                else
                    rejectedRequestHandlerReasons.push(response.reason);
            }));
            throw new Error(`Unable to register network object with id ${id}:\n\t${rejectedRequestHandlerReasons.join('\n\t')}`);
        }
        // At this point, the network object has been registered
        // Create a proxy object that blocks functions like "dispose" for others in the same process
        const localProxy = createLocalProxy(objectToShare);
        // Setup onDidDispose so that services will know when the proxy is dead
        const onDidDisposeLocalEmitter = new platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.PlatformEventEmitter();
        overrideOnDidDispose(id, objectToShare, onDidDisposeLocalEmitter.event);
        // Override dispose on the object passed in to clean up the network object
        overrideDispose(objectToShare, async () => {
            // Unsubscribe all requests for this network object
            const unsubscribers = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.aggregateUnsubscriberAsyncs)(await Promise.all(unsubPromises));
            if (!(await unsubscribers())) {
                _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_3__.logger.error(`Failed to unsubscribe all requests for ${id}`);
                return false;
            }
            // Send an event notifying everyone that this network object is no longer available
            // The event listener removes the network object from the registration map
            onDidDisposeNetworkObjectEmitter.emit(id);
            return true;
        });
        // Set the network object locally
        networkObjectRegistrations.set(id, {
            registrationType: NetworkObjectRegistrationType.Local,
            onDidDisposeEmitter: onDidDisposeLocalEmitter,
            // Assert to specified generic type.
            // eslint-disable-next-line no-type-assertion/no-type-assertion
            networkObject: localProxy.proxy,
            revokeProxy: localProxy.revoke,
        });
        // Notify that the network object was successfully registered
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_3__.logger.debug(`Network object registered: ${(0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.serialize)(netObjDetails)}`);
        onDidCreateNetworkObjectEmitter.emit(netObjDetails);
        // Override objectToShare's type's force-undefined onDidDispose to DisposableNetworkObject's
        // onDidDispose type because it had an onDidDispose added in overrideOnDidDispose.
        // Assert to specified generic type.
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        return objectToShare;
    });
};
/**
 * JSDOC SOURCE networkObjectService
 *
 * Network objects are distributed objects within PAPI for TS/JS objects. @see
 * https://en.wikipedia.org/wiki/Distributed_object
 *
 * Objects registered via {@link networkObjectService.set} are retrievable using
 * {@link networkObjectService.get}.
 *
 * Function calls made on network objects retrieved via {@link networkObjectService.get} are proxied
 * and sent to the original objects registered via {@link networkObjectService.set}. All functions on
 * the registered object are proxied except for constructors, `dispose`, and functions starting with
 * `on` since those should be events (which are not intended to be proxied) based on our naming
 * convention. If you don't want a function to be proxied, don't make it a property of the
 * registered object.
 *
 * Functions on a network object will be called asynchronously by other processes regardless of
 * whether the functions are synchronous or asynchronous, so it is best to make them all
 * asynchronous. All shared functions' arguments and return values must be serializable to be called
 * across processes.
 *
 * When a service registers an object via {@link networkObjectService.set}, it is the responsibility
 * of that service, and only that service, to call `dispose` on that object when it is no longer
 * intended to be shared with other services.
 *
 * When an object is disposed by calling `dispose`, all functions registered with the `onDidDispose`
 * event handler will be called. After an object is disposed, calls to its functions will no longer
 * be proxied to the original object.
 */
const networkObjectService = {
    initialize,
    hasKnown,
    get,
    set,
    onDidCreateNetworkObject,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (networkObjectService);
// This is only intended for use on PAPI
/** JSDOC DESTINATION networkObjectService */
const minimalNetworkObjectService = {
    get,
    set,
    onDidCreateNetworkObject,
};


/***/ }),

/***/ "./src/shared/services/network.service.ts":
/*!************************************************!*\
  !*** ./src/shared/services/network.service.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createNetworkEventEmitter: () => (/* binding */ createNetworkEventEmitter),
/* harmony export */   createRequestFunction: () => (/* binding */ createRequestFunction),
/* harmony export */   getNetworkEvent: () => (/* binding */ getNetworkEvent),
/* harmony export */   initialize: () => (/* binding */ initialize),
/* harmony export */   papiNetworkService: () => (/* binding */ papiNetworkService),
/* harmony export */   registerRequestHandler: () => (/* binding */ registerRequestHandler),
/* harmony export */   request: () => (/* binding */ request),
/* harmony export */   setRequestTimeout: () => (/* binding */ setRequestTimeout),
/* harmony export */   shutdown: () => (/* binding */ shutdown)
/* harmony export */ });
/* harmony import */ var _shared_data_rpc_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/data/rpc.model */ "./src/shared/data/rpc.model.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");
/* harmony import */ var _shared_utils_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/utils/util */ "./src/shared/utils/util.ts");
/* harmony import */ var _shared_models_papi_network_event_emitter_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @shared/models/papi-network-event-emitter.model */ "./src/shared/models/papi-network-event-emitter.model.ts");
/* harmony import */ var _shared_services_rpc_handler_factory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @shared/services/rpc-handler.factory */ "./src/shared/services/rpc-handler.factory.ts");
/* harmony import */ var _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @shared/services/logger.service */ "./src/shared/services/logger.service.ts");
/**
 * Handles requests, responses, subscriptions, etc. to the backend. Likely shouldn't need/want to
 * expose this whole service on papi, but there are a few things that are exposed via
 * papiNetworkService
 */






// #region Local event handling
/**
 * Map from event type to the emitter for that type as well as if that emitter is "registered" aka
 * one reference to that emitter has been provided somewhere such that that event can be emitted
 * from that one place. NetworkEventEmitter types should not occur multiple times so extensions
 * cannot emit events they shouldn't, so we have a quick and easy no sharing in process rule in
 * createNetworkEventEmitter.
 */
// TODO: sync these between processes
const eventEmittersByEventType = new Map();
/**
 * Emits the appropriate network event on this process according to the event type
 *
 * @param eventType Type of event to handle
 * @param event The event data to emit
 */
const handleEventFromNetwork = (eventType, event) => {
    eventEmittersByEventType.get(eventType)?.emitter.emitLocal(event);
};
// #endregion
// #region Service initialization and shutdown
const connectionMutex = new platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.Mutex();
let jsonRpc;
async function initialize() {
    if (jsonRpc)
        return;
    await connectionMutex.runExclusive(async () => {
        if (jsonRpc)
            return;
        try {
            jsonRpc = await (0,_shared_services_rpc_handler_factory__WEBPACK_IMPORTED_MODULE_4__.createRpcHandler)();
        }
        catch (e) {
            throw new Error(`ConnectionService: Failed to create NetworkConnector object: ${e}`);
        }
        const connected = await jsonRpc.connect(handleEventFromNetwork);
        if (!connected)
            throw new Error(`Unable to connect protocol handler`);
    });
}
/** Closes the network services gracefully */
const shutdown = async () => {
    if (!jsonRpc)
        return;
    await connectionMutex.runExclusive(async () => {
        if (!jsonRpc)
            return;
        await jsonRpc.disconnect();
        await Promise.all([...eventEmittersByEventType.values()].map(async (emitter) => {
            await emitter.emitter.dispose();
        }));
        eventEmittersByEventType.clear();
        jsonRpc = undefined;
    });
};
// #endregion
// #region Request handling
// This is a hard coded default that will be replaced with a settings value after it loads
let requestTimeoutMs = 30000;
// Unfortunately we can't just call the settings service to read the timeout. That's because the
// settings service depends on the network service (indirectly). Creating a circular dependency
// between the two services would be bad. So we use a hard coded default and then let something else
// set the timeout after the network service and settings service are both initialized.
/** Set the number of seconds that network requests in this process should wait before timing out */
function setRequestTimeout(timeoutSeconds) {
    if (timeoutSeconds < 0)
        throw new Error(`Invalid request timeout ${timeoutSeconds}: must be a non-negative number`);
    requestTimeoutMs = timeoutSeconds * 1000; // convert to milliseconds
    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_5__.logger.info(`[${globalThis.processType}] Request timeout set to ${requestTimeoutMs}ms`);
}
/** Inspect a value to see if we should process it as a JSONRPCResponse of some sort */
function isJsonRpcResponse(response) {
    return !!response && typeof response === 'object' && 'jsonrpc' in response;
}
/** Ensure the command name consists of two strings separated by at least one period */
function validateCommandFormatting(commandName) {
    if (!commandName)
        throw new Error(`Invalid command name ${commandName}: must be a non-empty string`);
    const periodIndex = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.indexOf)(commandName, '.');
    if (periodIndex < 0)
        throw new Error(`Invalid command name ${commandName}: must have at least one period`);
    if (periodIndex === 0)
        throw new Error(`Invalid command name ${commandName}: must have non-empty string before a period`);
    if (periodIndex >= (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.stringLength)(commandName) - 1)
        throw new Error(`Invalid command name ${commandName}: must have a non-empty string after a period`);
}
/** Check to make sure the request follows any request registration rules */
function validateRequestTypeFormatting(requestType) {
    // This request type doesn't conform to the normal format but is required by OpenRPC
    if (requestType.toString() === _shared_data_rpc_model__WEBPACK_IMPORTED_MODULE_0__.GET_METHODS)
        return;
    const { category, directive } = (0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_2__.deserializeRequestType)(requestType);
    if (category === _shared_data_rpc_model__WEBPACK_IMPORTED_MODULE_0__.CATEGORY_COMMAND) {
        validateCommandFormatting(directive);
    }
}
/**
 * Send a request on the network and resolve the response contents.
 *
 * @param requestType The type of request
 * @param args Arguments to send in the request (put in request.contents)
 * @returns Promise that resolves with the response message
 */
const request = async (requestType, ...args) => {
    validateRequestTypeFormatting(requestType);
    await initialize();
    if (!jsonRpc)
        throw new Error('RPC handler not set');
    let timeoutOccurred = false;
    let response;
    // If the request takes longer than the configured timeout, throw an error
    if (requestTimeoutMs > 0) {
        await Promise.race([
            (async () => {
                try {
                    response = (0,_shared_data_rpc_model__WEBPACK_IMPORTED_MODULE_0__.fixupResponse)(await jsonRpc.request(requestType, args));
                }
                catch (e) {
                    response = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.newPlatformError)(e);
                }
            })(),
            new Promise((resolve) => {
                setTimeout(() => {
                    timeoutOccurred = true;
                    resolve();
                }, requestTimeoutMs);
            }),
        ]);
    }
    // There is no timeout so we can run the request normally
    else {
        try {
            response = (0,_shared_data_rpc_model__WEBPACK_IMPORTED_MODULE_0__.fixupResponse)(await jsonRpc.request(requestType, args));
        }
        catch (e) {
            response = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.newPlatformError)(e);
        }
    }
    if (isJsonRpcResponse(response)) {
        if (!response.error)
            return response.result;
        response = `JSON-RPC Request error (${response.error.code}): ${response.error.message}`;
    }
    else if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.isPlatformError)(response)) {
        _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_5__.logger.debug(response.message);
        throw response;
    }
    else {
        response = timeoutOccurred
            ? `JSON-RPC Request timed out: ${requestType} ${JSON.stringify(args)}`
            : `Invalid JSON-RPC Response: ${JSON.stringify(response)}`;
    }
    _shared_services_logger_service__WEBPACK_IMPORTED_MODULE_5__.logger.debug(response);
    throw (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.newPlatformError)(response);
};
/**
 * Register a local request handler to run on requests.
 *
 * @param requestType The type of request on which to register the handler
 * @param handler Function to register to run on requests
 * @returns Promise that resolves if the request successfully registered and unsubscriber function
 *   to run to stop the passed-in function from handling requests
 */
async function registerRequestHandler(requestType, requestHandler, requestDocs) {
    await initialize();
    if (!jsonRpc)
        throw new Error('RPC handler not set');
    const success = await jsonRpc.registerMethod(requestType, requestHandler, requestDocs);
    if (!success)
        throw new Error(`Could not register request handler for ${requestType}`);
    return async () => {
        if (!jsonRpc)
            return false;
        return jsonRpc.unregisterMethod(requestType);
    };
}
/**
 * Creates a function that is a request function with a baked requestType. This is also nice because
 * you get TypeScript type support using this function.
 *
 * @param requestType RequestType for request function
 * @returns Function to call with arguments of request that performs the request and resolves with
 *   the response contents
 */
const createRequestFunction = (requestType) => {
    return async (...args) => request(requestType, ...args);
};
// #endregion
// #region Event handling
/**
 * Sends an event to other connections. Does NOT run the local event subscriptions as they should be
 * run by NetworkEventEmitter after sending on network.
 *
 * @param eventType Unique network event type for coordinating between connections
 * @param event Event to emit on the network
 */
const emitEventOnNetwork = async (eventType, event) => {
    await initialize();
    if (!jsonRpc)
        throw new Error('RPC handler not set');
    jsonRpc.emitEventOnNetwork(eventType, event);
};
const createNetworkEventEmitterInternal = (eventType, registerEmitter) => {
    let emitterRecord = eventEmittersByEventType.get(eventType);
    if (!emitterRecord) {
        emitterRecord = {
            // Match the collection type
            // eslint-disable-next-line no-type-assertion/no-type-assertion
            emitter: new _shared_models_papi_network_event_emitter_model__WEBPACK_IMPORTED_MODULE_3__.PapiNetworkEventEmitter((event) => emitEventOnNetwork(eventType, event), () => eventEmittersByEventType.delete(eventType)),
            isRegistered: false,
        };
        eventEmittersByEventType.set(eventType, emitterRecord);
    }
    if (registerEmitter) {
        if (emitterRecord.isRegistered)
            throw new Error(`type ${eventType} is already registered to a network event emitter`);
        emitterRecord.isRegistered = true;
    }
    // Assert as emitter with an unknown type
    // eslint-disable-next-line no-type-assertion/no-type-assertion
    return emitterRecord.emitter;
};
/**
 * Creates an event emitter that works properly over the network. Other connections receive this
 * event when it is emitted.
 *
 * WARNING: You can only create a network event emitter once per eventType to prevent hijacked event
 * emitters.
 *
 * @param eventType Unique network event type for coordinating between connections
 * @returns Event emitter whose event works between connections
 */
const createNetworkEventEmitter = (eventType) => createNetworkEventEmitterInternal(eventType, true);
/**
 * Gets the network event with the specified type. Creates the emitter if it does not exist
 *
 * @param eventType Unique network event type for coordinating between connections
 * @returns Event for the event type that runs the callback provided when the event is emitted
 */
const getNetworkEvent = (eventType) => {
    // Return event with the generic type.
    // eslint-disable-next-line no-type-assertion/no-type-assertion
    return createNetworkEventEmitterInternal(eventType, false).event;
};
/**
 * JSDOC SOURCE papiNetworkService
 *
 * Service that provides a way to send and receive network events
 */
const papiNetworkService = {
    createNetworkEventEmitter,
    getNetworkEvent,
};


/***/ }),

/***/ "./src/shared/services/notification.service.ts":
/*!*****************************************************!*\
  !*** ./src/shared/services/notification.service.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   notificationService: () => (/* binding */ notificationService)
/* harmony export */ });
/* harmony import */ var _shared_models_notification_service_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/models/notification.service-model */ "./src/shared/models/notification.service-model.ts");
/* harmony import */ var _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/services/network-object.service */ "./src/shared/services/network-object.service.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");



let networkObject;
let initializationPromise;
async function initialize() {
    if (!initializationPromise) {
        initializationPromise = new Promise((resolve, reject) => {
            const executor = async () => {
                try {
                    const localNotificationService = await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_1__.networkObjectService.get(_shared_models_notification_service_model__WEBPACK_IMPORTED_MODULE_0__.NotificationServiceNetworkObjectName);
                    if (!localNotificationService)
                        throw new Error(`${_shared_models_notification_service_model__WEBPACK_IMPORTED_MODULE_0__.NotificationServiceNetworkObjectName} is not available as a network object`);
                    networkObject = localNotificationService;
                    resolve();
                }
                catch (error) {
                    reject(error);
                }
            };
            executor();
        });
    }
    return initializationPromise;
}
/**
 * JSDOC SOURCE notificationService
 *
 * Service that sends notifications to users in the UI
 */
const notificationService = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_2__.createSyncProxyForAsyncObject)(async () => {
    await initialize();
    return networkObject;
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (notificationService);


/***/ }),

/***/ "./src/shared/services/project-data-provider.service.ts":
/*!**************************************************************!*\
  !*** ./src/shared/services/project-data-provider.service.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   papiBackendProjectDataProviderService: () => (/* binding */ papiBackendProjectDataProviderService),
/* harmony export */   papiFrontendProjectDataProviderService: () => (/* binding */ papiFrontendProjectDataProviderService),
/* harmony export */   registerProjectDataProviderEngineFactory: () => (/* binding */ registerProjectDataProviderEngineFactory)
/* harmony export */ });
/* harmony import */ var _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/services/network-object.service */ "./src/shared/services/network-object.service.ts");
/* harmony import */ var _shared_services_data_provider_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/services/data-provider.service */ "./src/shared/services/data-provider.service.ts");
/* harmony import */ var _shared_utils_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/utils/util */ "./src/shared/utils/util.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");
/* harmony import */ var _shared_models_project_data_provider_factory_interface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @shared/models/project-data-provider-factory.interface */ "./src/shared/models/project-data-provider-factory.interface.ts");
/* harmony import */ var _shared_services_project_lookup_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @shared/services/project-lookup.service */ "./src/shared/services/project-lookup.service.ts");
/* harmony import */ var _shared_models_project_data_provider_model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @shared/models/project-data-provider.model */ "./src/shared/models/project-data-provider.model.ts");
/* harmony import */ var _shared_models_project_lookup_service_model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @shared/models/project-lookup.service-model */ "./src/shared/models/project-lookup.service-model.ts");








/**
 * Class that creates Project Data Providers of a specific set of `projectInterface`s. Layers over
 * extension-provided {@link IProjectDataProviderEngineFactory}. Internal only
 */
class ProjectDataProviderFactory {
    pdpIdsMutexMap = new platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__.MutexMap();
    pdpIds = new Map();
    pdpFactoryId;
    projectInterfaces;
    pdpCleanupList;
    pdpEngineFactory;
    /**
     * Create a new PDP factory that is used to create PDPs
     *
     * @param projectInterfaces All the `projectInterface`s this PDP factory's PDPs can support
     * @param pdpEngineFactory Object that can create the engines for PDPs
     */
    constructor(pdpFactoryId, projectInterfaces, pdpEngineFactory) {
        this.pdpFactoryId = pdpFactoryId;
        this.projectInterfaces = projectInterfaces;
        this.pdpCleanupList = new platform_bible_utils__WEBPACK_IMPORTED_MODULE_3__.UnsubscriberAsyncList(`PDP Factory for ${projectInterfaces}`);
        this.pdpEngineFactory = pdpEngineFactory;
    }
    getAvailableProjects(layeringFilters) {
        return this.pdpEngineFactory.getAvailableProjects(layeringFilters);
    }
    /** Disposes of all PDPs that were created by this PDP Factory */
    async dispose() {
        this.pdpIds.clear();
        return this.pdpCleanupList.runAllUnsubscribers();
    }
    /** Returns the registered network object name of a PDP for the given project ID */
    async getProjectDataProviderId(projectId) {
        const key = projectId;
        // Don't allow simultaneous gets to run for the same project data provider id as an easy way to
        // make sure we don't create multiple of the same PDP
        const lock = this.pdpIdsMutexMap.get(key);
        return lock.runExclusive(async () => {
            let pdpId = this.pdpIds.get(key);
            if (!pdpId) {
                pdpId = await this.registerProjectDataProvider(await this.pdpEngineFactory.createProjectDataProviderEngine(projectId), projectId);
                if (!pdpId)
                    throw new Error(`Could not register project data provider for ${projectId}`);
                this.pdpIds.set(key, pdpId);
            }
            return pdpId;
        });
    }
    /** Convert the PDP engine into a PDP using the data provider service */
    async registerProjectDataProvider(projectDataProviderEngine, projectId) {
        // Check to make sure new Base PDPs fulfill the requirements of the `platform.base` `projectInterface`
        if (this.projectInterfaces.includes(_shared_models_project_data_provider_model__WEBPACK_IMPORTED_MODULE_6__.PROJECT_INTERFACE_PLATFORM_BASE) &&
            (!('getExtensionData' in projectDataProviderEngine) ||
                !('getSetting' in projectDataProviderEngine)))
            throw new Error(`\`BaseProjectDataProviderEngine\` with project id ${projectId} created by PDP Factory with id ${this.pdpFactoryId} must implement \`${_shared_models_project_data_provider_model__WEBPACK_IMPORTED_MODULE_6__.PROJECT_INTERFACE_PLATFORM_BASE}\` \`projectInterface\`. See \`IBaseProjectDataProvider\` for more information`);
        // ENHANCEMENT: Re-add a check for new PDPs to make sure there is some PDP somewhere that
        // fulfills `platform.base`
        const pdpId = `${(0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_2__.newNonce)()}-pdp`;
        const pdp = await (0,_shared_services_data_provider_service__WEBPACK_IMPORTED_MODULE_1__.registerEngineByType)(pdpId, projectDataProviderEngine, 'pdp', {
            projectId,
            projectInterfaces: this.projectInterfaces,
        });
        this.pdpCleanupList.add(pdp);
        return pdpId;
    }
}
/**
 * Add a new Project Data Provider Factory to PAPI that uses the given engine.
 *
 * @param pdpFactoryId Unique id for this PDP factory
 * @param projectInterfaces The standardized sets of methods (`projectInterface`s) supported by the
 *   Project Data Provider Engines produced by this factory. Indicates what sort of project data
 *   should be available on the PDPEs created by this factory.
 * @param pdpEngineFactory Used in a ProjectDataProviderFactory to create ProjectDataProviders
 * @returns Promise that resolves to a disposable object when the registration operation completes
 */
async function registerProjectDataProviderEngineFactory(pdpFactoryId, projectInterfaces, pdpEngineFactory) {
    const factoryNetworkObjectId = (0,_shared_models_project_lookup_service_model__WEBPACK_IMPORTED_MODULE_7__.getPDPFactoryNetworkObjectNameFromId)(pdpFactoryId);
    const factory = new ProjectDataProviderFactory(pdpFactoryId, projectInterfaces, pdpEngineFactory);
    return _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_0__.networkObjectService.set(factoryNetworkObjectId, factory, _shared_models_project_data_provider_factory_interface__WEBPACK_IMPORTED_MODULE_4__.PDP_FACTORY_OBJECT_TYPE, { projectInterfaces });
}
/**
 * Get a Project Data Provider for the given project ID.
 *
 * @example
 *
 * ```typescript
 * const pdp = await get('platformScripture.USFM_Verse', 'ProjectID12345');
 * pdp.getVerseUSFM({ book: 'JHN', chapterNum: 1, verseNum: 1 });
 * ```
 *
 * @param projectInterface `projectInterface` that the project to load must support. The TypeScript
 *   type for the returned project data provider will have the project data provider interface type
 *   associated with this `projectInterface`. If the project does not implement this
 *   `projectInterface` (according to its metadata), an error will be thrown.
 * @param projectId ID for the project to load
 * @param pdpFactoryId Optional ID of the PDP factory from which to get the project data provider if
 *   the PDP factory supports this project id and project interface. If not provided, then look in
 *   all available PDP factories for the given project ID.
 * @returns Project data provider with types that are associated with the given `projectInterface`
 * @throws If did not find a project data provider for the project id that supports the requested
 *   `projectInterface` (and from the requested PDP factory if specified)
 */
async function get(projectInterface, projectId, pdpFactoryId) {
    const metadata = await _shared_services_project_lookup_service__WEBPACK_IMPORTED_MODULE_5__.projectLookupService.getMetadataForProject(projectId, projectInterface, pdpFactoryId);
    const minimalMatchPdpFactoryId = _shared_services_project_lookup_service__WEBPACK_IMPORTED_MODULE_5__.projectLookupService.getMinimalMatchPdpFactoryId(metadata, projectInterface);
    if (!minimalMatchPdpFactoryId)
        throw new Error(`pdpService.get(${projectInterface}, ${projectId}, ${pdpFactoryId}): Somehow there was a project with the id and provided projectInterface, but could not find a PDPF that provided the projectInterface. This should not happen.`);
    const pdpFactory = await _shared_services_network_object_service__WEBPACK_IMPORTED_MODULE_0__.networkObjectService.get((0,_shared_models_project_lookup_service_model__WEBPACK_IMPORTED_MODULE_7__.getPDPFactoryNetworkObjectNameFromId)(minimalMatchPdpFactoryId));
    if (!pdpFactory)
        throw new Error(`pdpService.get(${projectInterface}, ${projectId}, ${pdpFactoryId}): Cannot get project data providers with projectInterface ${projectInterface}: Could not get pdpf with id ${minimalMatchPdpFactoryId}`);
    const pdpId = await pdpFactory.getProjectDataProviderId(projectId);
    const pdp = await (0,_shared_services_data_provider_service__WEBPACK_IMPORTED_MODULE_1__.getByType)(pdpId);
    if (!pdp)
        throw new Error(`pdpService.get(${projectInterface}, ${projectId}, ${pdpFactoryId}): Cannot get project data provider for project ID ${projectId}`);
    return pdp;
}
/**
 * JSDOC SOURCE papiBackendProjectDataProviderService
 *
 * Service that registers and gets project data providers
 */
const papiBackendProjectDataProviderService = {
    registerProjectDataProviderEngineFactory,
    get,
};
/**
 * JSDOC SOURCE papiFrontendProjectDataProviderService
 *
 * Service that gets project data providers
 */
const papiFrontendProjectDataProviderService = {
    get,
};


/***/ }),

/***/ "./src/shared/services/project-lookup.service.ts":
/*!*******************************************************!*\
  !*** ./src/shared/services/project-lookup.service.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   projectLookupService: () => (/* binding */ projectLookupService)
/* harmony export */ });
/* harmony import */ var _shared_models_project_lookup_service_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/models/project-lookup.service-model */ "./src/shared/models/project-lookup.service-model.ts");

const projectLookupService = _shared_models_project_lookup_service_model__WEBPACK_IMPORTED_MODULE_0__.projectLookupServiceBase;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (projectLookupService);


/***/ }),

/***/ "./src/shared/services/rpc-handler.factory.ts":
/*!****************************************************!*\
  !*** ./src/shared/services/rpc-handler.factory.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createRpcHandler: () => (/* binding */ createRpcHandler)
/* harmony export */ });
/* harmony import */ var _shared_utils_internal_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/utils/internal-util */ "./src/shared/utils/internal-util.ts");

/** Creates a server or client RPC handler depending on if we're in main or some other process */
const createRpcHandler = async () => {
    if ((0,_shared_utils_internal_util__WEBPACK_IMPORTED_MODULE_0__.isClient)()) {
        const RpcClient = (await Promise.resolve().then(function webpackMissingModule() { var e = new Error("Cannot find module '@client/services/rpc-client'"); e.code = 'MODULE_NOT_FOUND'; throw e; })).default;
        return new RpcClient();
    }
    const RpcWebSocketListener = (await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_ws_wrapper_mjs"), __webpack_require__.e("src_main_services_rpc-websocket-listener_ts")]).then(__webpack_require__.bind(__webpack_require__, /*! @main/services/rpc-websocket-listener */ "./src/main/services/rpc-websocket-listener.ts"))).default;
    return new RpcWebSocketListener();
};


/***/ }),

/***/ "./src/shared/services/settings.service-model.ts":
/*!*******************************************************!*\
  !*** ./src/shared/services/settings.service-model.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CATEGORY_EXTENSION_SETTING_VALIDATOR: () => (/* binding */ CATEGORY_EXTENSION_SETTING_VALIDATOR),
/* harmony export */   settingsServiceDataProviderName: () => (/* binding */ settingsServiceDataProviderName),
/* harmony export */   settingsServiceObjectToProxy: () => (/* binding */ settingsServiceObjectToProxy)
/* harmony export */ });
/* harmony import */ var _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/services/network.service */ "./src/shared/services/network.service.ts");
/* harmony import */ var _shared_utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/utils/util */ "./src/shared/utils/util.ts");


/** Name prefix for registered commands that call settings validators */
const CATEGORY_EXTENSION_SETTING_VALIDATOR = 'extensionSettingValidator';
/** JSDOC DESTINATION settingsServiceDataProviderName */
const settingsServiceDataProviderName = 'platform.settingsServiceDataProvider';
const settingsServiceObjectToProxy = Object.freeze({
    /**
     * JSDOC SOURCE settingsServiceDataProviderName
     *
     * This name is used to register the settings service data provider on the papi. You can use this
     * name to find the data provider when accessing it using the useData hook
     */
    dataProviderName: settingsServiceDataProviderName,
    /**
     * JSDOC SOURCE settingsServiceRegisterValidator
     *
     * Registers a function that validates whether a new setting value is allowed to be set.
     *
     * @param key The string id of the setting to validate
     * @param validator Function to call to validate the new setting value
     * @returns Unsubscriber that should be called whenever the providing extension is deactivated
     */
    registerValidator: async (key, validator) => {
        return _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__.registerRequestHandler((0,_shared_utils_util__WEBPACK_IMPORTED_MODULE_1__.serializeRequestType)(CATEGORY_EXTENSION_SETTING_VALIDATOR, key), validator, {
            method: {
                summary: `Validate whether a given value is allowed for setting "${key}"`,
                params: [
                    {
                        name: 'newValue',
                        required: true,
                        summary: 'The new value to validate',
                        schema: {
                            oneOf: [
                                { type: 'object' },
                                { type: 'string' },
                                { type: 'number' },
                                { type: 'boolean' },
                                { type: 'array' },
                            ],
                        },
                    },
                    {
                        name: 'currentValue',
                        required: true,
                        summary: 'The current value of the setting',
                        schema: {
                            oneOf: [
                                { type: 'object' },
                                { type: 'string' },
                                { type: 'number' },
                                { type: 'boolean' },
                                { type: 'array' },
                            ],
                        },
                    },
                    {
                        name: 'allChanges',
                        required: true,
                        summary: 'All changes to the settings',
                        schema: {
                            oneOf: [
                                { type: 'object' },
                                { type: 'string' },
                                { type: 'number' },
                                { type: 'boolean' },
                                { type: 'array' },
                            ],
                        },
                    },
                ],
                result: {
                    name: 'return value',
                    summary: 'Whether the new setting value is valid',
                    schema: { type: 'boolean' },
                },
            },
        });
    },
});


/***/ }),

/***/ "./src/shared/services/settings.service.ts":
/*!*************************************************!*\
  !*** ./src/shared/services/settings.service.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   settingsService: () => (/* binding */ settingsService)
/* harmony export */ });
/* harmony import */ var _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/services/network.service */ "./src/shared/services/network.service.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");
/* harmony import */ var _shared_services_data_provider_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/services/data-provider.service */ "./src/shared/services/data-provider.service.ts");
/* harmony import */ var _settings_service_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings.service-model */ "./src/shared/services/settings.service-model.ts");




let dataProvider;
let initializationPromise;
async function initialize() {
    if (!initializationPromise) {
        initializationPromise = new Promise((resolve, reject) => {
            const executor = async () => {
                try {
                    const provider = await _shared_services_data_provider_service__WEBPACK_IMPORTED_MODULE_2__.dataProviderService.get(_settings_service_model__WEBPACK_IMPORTED_MODULE_3__.settingsServiceDataProviderName);
                    if (!provider)
                        throw new Error('Settings service undefined');
                    dataProvider = provider;
                    // Inject the network timeout into every JS process once the settings service is available
                    // We can't pull from within the network service as it would create a dependency loop
                    dataProvider.subscribe('platform.requestTimeout', (newTimeout) => _shared_services_network_service__WEBPACK_IMPORTED_MODULE_0__.setRequestTimeout(newTimeout));
                    resolve();
                }
                catch (error) {
                    reject(error);
                }
            };
            executor();
        });
    }
    return initializationPromise;
}
const settingsService = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.createSyncProxyForAsyncObject)(async () => {
    await initialize();
    return dataProvider;
}, _settings_service_model__WEBPACK_IMPORTED_MODULE_3__.settingsServiceObjectToProxy);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (settingsService);


/***/ }),

/***/ "./src/shared/utils/internal-util.ts":
/*!*******************************************!*\
  !*** ./src/shared/utils/internal-util.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getProcessType: () => (/* binding */ getProcessType),
/* harmony export */   isClient: () => (/* binding */ isClient),
/* harmony export */   isExtensionHost: () => (/* binding */ isExtensionHost),
/* harmony export */   isRenderer: () => (/* binding */ isRenderer),
/* harmony export */   isServer: () => (/* binding */ isServer)
/* harmony export */ });
/* harmony import */ var _shared_global_this_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/global-this.model */ "./src/shared/global-this.model.ts");
/** Utility functions specific to the internal technologies we are using. */

/**
 * Determine if running on a client process (renderer, extension-host) or on the server.
 *
 * @returns Returns true if running on a client, false otherwise
 */
const isClient = () => globalThis.processType !== _shared_global_this_model__WEBPACK_IMPORTED_MODULE_0__.ProcessType.Main;
/**
 * Determine if running on the server process (main)
 *
 * @returns Returns true if running on the server, false otherwise
 */
const isServer = () => !isClient();
/**
 * Determine if running on the renderer process
 *
 * @returns Returns true if running on the renderer, false otherwise
 */
const isRenderer = () => globalThis.processType === _shared_global_this_model__WEBPACK_IMPORTED_MODULE_0__.ProcessType.Renderer;
/**
 * Determine if running on the extension host
 *
 * @returns Returns true if running on the extension host, false otherwise
 */
const isExtensionHost = () => globalThis.processType === _shared_global_this_model__WEBPACK_IMPORTED_MODULE_0__.ProcessType.ExtensionHost;
/**
 * Gets which kind of process this is (main, renderer, extension-host)
 *
 * @returns ProcessType for this process
 */
const getProcessType = () => globalThis.processType;


/***/ }),

/***/ "./src/shared/utils/util.ts":
/*!**********************************!*\
  !*** ./src/shared/utils/util.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MODULE_SIMILAR_APIS: () => (/* binding */ MODULE_SIMILAR_APIS),
/* harmony export */   bindClassMethods: () => (/* binding */ bindClassMethods),
/* harmony export */   deserializeRequestType: () => (/* binding */ deserializeRequestType),
/* harmony export */   getModuleSimilarApiMessage: () => (/* binding */ getModuleSimilarApiMessage),
/* harmony export */   newNonce: () => (/* binding */ newNonce),
/* harmony export */   serializeRequestType: () => (/* binding */ serializeRequestType)
/* harmony export */ });
/* harmony import */ var _shared_global_this_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/global-this.model */ "./src/shared/global-this.model.ts");
/* harmony import */ var platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! platform-bible-utils */ "./lib/platform-bible-utils/dist/index.js");


const NONCE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
const NONCE_CHARS_LENGTH = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.stringLength)(NONCE_CHARS);
/**
 * Create a nonce that is at least 128 bits long and should be (is not currently) cryptographically
 * random. See nonce spec at https://w3c.github.io/webappsec-csp/#security-nonces
 *
 * WARNING: THIS IS NOT CURRENTLY CRYPTOGRAPHICALLY SECURE! TODO: Make this cryptographically
 * random! Use some polymorphic library that works in all contexts?
 * https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues only works in browser
 */
function newNonce() {
    let nonce = '';
    for (let i = 0; i < 32; i++)
        nonce += (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.charAt)(NONCE_CHARS, Math.floor(Math.random() * NONCE_CHARS_LENGTH));
    return nonce;
}
// #region Module loading
/**
 * Modules that someone might try to require in their extensions that we have similar apis for. When
 * an extension requires these modules, an error throws that lets them know about our similar api.
 */
const MODULE_SIMILAR_APIS = Object.freeze({
    http: 'fetch',
    https: 'fetch',
    fs: {
        [_shared_global_this_model__WEBPACK_IMPORTED_MODULE_0__.ProcessType.Renderer]: 'the papi-extension: protocol',
        [_shared_global_this_model__WEBPACK_IMPORTED_MODULE_0__.ProcessType.ExtensionHost]: 'papi.storage',
    },
    child_process: 'createProcess (requires requesting in elevatedPrivileges)',
});
/**
 * Get a message that says the module import was rejected and to try a similar api if available.
 *
 * @param moduleName Name of `require`d module that was rejected
 * @returns String that says the import was rejected and a similar api to try
 */
function getModuleSimilarApiMessage(moduleName) {
    const similarApi = MODULE_SIMILAR_APIS[moduleName] || MODULE_SIMILAR_APIS[`node:${moduleName}`];
    let similarApiName;
    if (similarApi)
        if ((0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(similarApi)) {
            similarApiName = similarApi;
        }
        else {
            similarApiName = similarApi[globalThis.processType] || similarApi.default;
        }
    return `Rejected require('${moduleName}'). Try${similarApiName ? ` using ${similarApiName} or` : ''} bundling the module into your code with a build tool like webpack`;
}
// #endregion
// #region Serialization and deserialization functions
/** Separator between parts of a serialized request */
const REQUEST_TYPE_SEPARATOR = ':';
/**
 * Create a request message requestType string from a category and a directive
 *
 * @param category The general category of request
 * @param directive Specific identifier for this type of request
 * @returns Full requestType for use in network calls
 */
function serializeRequestType(category, directive) {
    if (!category)
        throw new Error('serializeRequestType: "category" is not defined or empty.');
    if (!directive)
        throw new Error('serializeRequestType: "directive" is not defined or empty.');
    return `${category}${REQUEST_TYPE_SEPARATOR}${directive}`;
}
/** Split a request message requestType string into its parts */
function deserializeRequestType(requestType) {
    if (!requestType)
        throw new Error('deserializeRequestType: must be a non-empty string');
    const colonIndex = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.indexOf)(requestType, REQUEST_TYPE_SEPARATOR);
    if (colonIndex <= 0 || colonIndex >= (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.stringLength)(requestType) - 1)
        throw new Error(`deserializeRequestType: Must have two parts divided by a ${REQUEST_TYPE_SEPARATOR} (${requestType})`);
    const category = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.substring)(requestType, 0, colonIndex);
    const directive = (0,platform_bible_utils__WEBPACK_IMPORTED_MODULE_1__.substring)(requestType, colonIndex + 1);
    return { category, directive };
}
// #endregion
/**
 * Allow an object to bind all its class-defined functions to itself to ensure all references to
 * "this" in its functions refer to the object rather than the caller of the function. For example,
 * if a function on the class is provided to a callback, if "this" isn't bound to the object then
 * "this" will refer to the entity running the callback.
 */
function bindClassMethods() {
    const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(this));
    methods.forEach((method) => {
        // Allow indexing to work for this object
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-type-assertion/no-type-assertion
        const thisAsAny = this;
        if (typeof thisAsAny[method] === 'function') {
            thisAsAny[method] = thisAsAny[method].bind(this);
        }
    });
}


/***/ }),

/***/ "./node_modules/write-file-atomic/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/write-file-atomic/lib/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = writeFile
module.exports.sync = writeFileSync
module.exports._getTmpname = getTmpname // for testing
module.exports._cleanupOnExit = cleanupOnExit

const fs = __webpack_require__(/*! fs */ "fs")
const MurmurHash3 = __webpack_require__(/*! imurmurhash */ "./node_modules/imurmurhash/imurmurhash.js")
const { onExit } = __webpack_require__(/*! signal-exit */ "./node_modules/write-file-atomic/node_modules/signal-exit/dist/cjs/index.js")
const path = __webpack_require__(/*! path */ "path")
const { promisify } = __webpack_require__(/*! util */ "util")
const activeFiles = {}

// if we run inside of a worker_thread, `process.pid` is not unique
/* istanbul ignore next */
const threadId = (function getId () {
  try {
    const workerThreads = __webpack_require__(/*! worker_threads */ "worker_threads")

    /// if we are in main thread, this is set to `0`
    return workerThreads.threadId
  } catch (e) {
    // worker_threads are not available, fallback to 0
    return 0
  }
})()

let invocations = 0
function getTmpname (filename) {
  return filename + '.' +
    MurmurHash3(__filename)
      .hash(String(process.pid))
      .hash(String(threadId))
      .hash(String(++invocations))
      .result()
}

function cleanupOnExit (tmpfile) {
  return () => {
    try {
      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile)
    } catch {
      // ignore errors
    }
  }
}

function serializeActiveFile (absoluteName) {
  return new Promise(resolve => {
    // make a queue if it doesn't already exist
    if (!activeFiles[absoluteName]) {
      activeFiles[absoluteName] = []
    }

    activeFiles[absoluteName].push(resolve) // add this job to the queue
    if (activeFiles[absoluteName].length === 1) {
      resolve()
    } // kick off the first one
  })
}

// https://github.com/isaacs/node-graceful-fs/blob/master/polyfills.js#L315-L342
function isChownErrOk (err) {
  if (err.code === 'ENOSYS') {
    return true
  }

  const nonroot = !process.getuid || process.getuid() !== 0
  if (nonroot) {
    if (err.code === 'EINVAL' || err.code === 'EPERM') {
      return true
    }
  }

  return false
}

async function writeFileAsync (filename, data, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options }
  }

  let fd
  let tmpfile
  /* istanbul ignore next -- The closure only gets called when onExit triggers */
  const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile))
  const absoluteName = path.resolve(filename)

  try {
    await serializeActiveFile(absoluteName)
    const truename = await promisify(fs.realpath)(filename).catch(() => filename)
    tmpfile = getTmpname(truename)

    if (!options.mode || !options.chown) {
      // Either mode or chown is not explicitly set
      // Default behavior is to copy it from original file
      const stats = await promisify(fs.stat)(truename).catch(() => {})
      if (stats) {
        if (options.mode == null) {
          options.mode = stats.mode
        }

        if (options.chown == null && process.getuid) {
          options.chown = { uid: stats.uid, gid: stats.gid }
        }
      }
    }

    fd = await promisify(fs.open)(tmpfile, 'w', options.mode)
    if (options.tmpfileCreated) {
      await options.tmpfileCreated(tmpfile)
    }
    if (ArrayBuffer.isView(data)) {
      await promisify(fs.write)(fd, data, 0, data.length, 0)
    } else if (data != null) {
      await promisify(fs.write)(fd, String(data), 0, String(options.encoding || 'utf8'))
    }

    if (options.fsync !== false) {
      await promisify(fs.fsync)(fd)
    }

    await promisify(fs.close)(fd)
    fd = null

    if (options.chown) {
      await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid).catch(err => {
        if (!isChownErrOk(err)) {
          throw err
        }
      })
    }

    if (options.mode) {
      await promisify(fs.chmod)(tmpfile, options.mode).catch(err => {
        if (!isChownErrOk(err)) {
          throw err
        }
      })
    }

    await promisify(fs.rename)(tmpfile, truename)
  } finally {
    if (fd) {
      await promisify(fs.close)(fd).catch(
        /* istanbul ignore next */
        () => {}
      )
    }
    removeOnExitHandler()
    await promisify(fs.unlink)(tmpfile).catch(() => {})
    activeFiles[absoluteName].shift() // remove the element added by serializeSameFile
    if (activeFiles[absoluteName].length > 0) {
      activeFiles[absoluteName][0]() // start next job if one is pending
    } else {
      delete activeFiles[absoluteName]
    }
  }
}

async function writeFile (filename, data, options, callback) {
  if (options instanceof Function) {
    callback = options
    options = {}
  }

  const promise = writeFileAsync(filename, data, options)
  if (callback) {
    try {
      const result = await promise
      return callback(result)
    } catch (err) {
      return callback(err)
    }
  }

  return promise
}

function writeFileSync (filename, data, options) {
  if (typeof options === 'string') {
    options = { encoding: options }
  } else if (!options) {
    options = {}
  }
  try {
    filename = fs.realpathSync(filename)
  } catch (ex) {
    // it's ok, it'll happen on a not yet existing file
  }
  const tmpfile = getTmpname(filename)

  if (!options.mode || !options.chown) {
    // Either mode or chown is not explicitly set
    // Default behavior is to copy it from original file
    try {
      const stats = fs.statSync(filename)
      options = Object.assign({}, options)
      if (!options.mode) {
        options.mode = stats.mode
      }
      if (!options.chown && process.getuid) {
        options.chown = { uid: stats.uid, gid: stats.gid }
      }
    } catch (ex) {
      // ignore stat errors
    }
  }

  let fd
  const cleanup = cleanupOnExit(tmpfile)
  const removeOnExitHandler = onExit(cleanup)

  let threw = true
  try {
    fd = fs.openSync(tmpfile, 'w', options.mode || 0o666)
    if (options.tmpfileCreated) {
      options.tmpfileCreated(tmpfile)
    }
    if (ArrayBuffer.isView(data)) {
      fs.writeSync(fd, data, 0, data.length, 0)
    } else if (data != null) {
      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'))
    }
    if (options.fsync !== false) {
      fs.fsyncSync(fd)
    }

    fs.closeSync(fd)
    fd = null

    if (options.chown) {
      try {
        fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)
      } catch (err) {
        if (!isChownErrOk(err)) {
          throw err
        }
      }
    }

    if (options.mode) {
      try {
        fs.chmodSync(tmpfile, options.mode)
      } catch (err) {
        if (!isChownErrOk(err)) {
          throw err
        }
      }
    }

    fs.renameSync(tmpfile, filename)
    threw = false
  } finally {
    if (fd) {
      try {
        fs.closeSync(fd)
      } catch (ex) {
        // ignore close errors at this stage, error may have closed fd already.
      }
    }
    removeOnExitHandler()
    if (threw) {
      cleanup()
    }
  }
}


/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "electron":
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("electron");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "fs/promises":
/*!******************************!*\
  !*** external "fs/promises" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("fs/promises");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "vm":
/*!*********************!*\
  !*** external "vm" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("vm");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("worker_threads");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "./node_modules/write-file-atomic/node_modules/signal-exit/dist/cjs/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/write-file-atomic/node_modules/signal-exit/dist/cjs/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unload = exports.load = exports.onExit = exports.signals = void 0;
// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
const signals_js_1 = __webpack_require__(/*! ./signals.js */ "./node_modules/write-file-atomic/node_modules/signal-exit/dist/cjs/signals.js");
Object.defineProperty(exports, "signals", ({ enumerable: true, get: function () { return signals_js_1.signals; } }));
const processOk = (process) => !!process &&
    typeof process === 'object' &&
    typeof process.removeListener === 'function' &&
    typeof process.emit === 'function' &&
    typeof process.reallyExit === 'function' &&
    typeof process.listeners === 'function' &&
    typeof process.kill === 'function' &&
    typeof process.pid === 'number' &&
    typeof process.on === 'function';
const kExitEmitter = Symbol.for('signal-exit emitter');
const global = globalThis;
const ObjectDefineProperty = Object.defineProperty.bind(Object);
// teeny special purpose ee
class Emitter {
    emitted = {
        afterExit: false,
        exit: false,
    };
    listeners = {
        afterExit: [],
        exit: [],
    };
    count = 0;
    id = Math.random();
    constructor() {
        if (global[kExitEmitter]) {
            return global[kExitEmitter];
        }
        ObjectDefineProperty(global, kExitEmitter, {
            value: this,
            writable: false,
            enumerable: false,
            configurable: false,
        });
    }
    on(ev, fn) {
        this.listeners[ev].push(fn);
    }
    removeListener(ev, fn) {
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        /* c8 ignore start */
        if (i === -1) {
            return;
        }
        /* c8 ignore stop */
        if (i === 0 && list.length === 1) {
            list.length = 0;
        }
        else {
            list.splice(i, 1);
        }
    }
    emit(ev, code, signal) {
        if (this.emitted[ev]) {
            return false;
        }
        this.emitted[ev] = true;
        let ret = false;
        for (const fn of this.listeners[ev]) {
            ret = fn(code, signal) === true || ret;
        }
        if (ev === 'exit') {
            ret = this.emit('afterExit', code, signal) || ret;
        }
        return ret;
    }
}
class SignalExitBase {
}
const signalExitWrap = (handler) => {
    return {
        onExit(cb, opts) {
            return handler.onExit(cb, opts);
        },
        load() {
            return handler.load();
        },
        unload() {
            return handler.unload();
        },
    };
};
class SignalExitFallback extends SignalExitBase {
    onExit() {
        return () => { };
    }
    load() { }
    unload() { }
}
class SignalExit extends SignalExitBase {
    // "SIGHUP" throws an `ENOSYS` error on Windows,
    // so use a supported signal instead
    /* c8 ignore start */
    #hupSig = process.platform === 'win32' ? 'SIGINT' : 'SIGHUP';
    /* c8 ignore stop */
    #emitter = new Emitter();
    #process;
    #originalProcessEmit;
    #originalProcessReallyExit;
    #sigListeners = {};
    #loaded = false;
    constructor(process) {
        super();
        this.#process = process;
        // { <signal>: <listener fn>, ... }
        this.#sigListeners = {};
        for (const sig of signals_js_1.signals) {
            this.#sigListeners[sig] = () => {
                // If there are no other listeners, an exit is coming!
                // Simplest way: remove us and then re-send the signal.
                // We know that this will kill the process, so we can
                // safely emit now.
                const listeners = this.#process.listeners(sig);
                let { count } = this.#emitter;
                // This is a workaround for the fact that signal-exit v3 and signal
                // exit v4 are not aware of each other, and each will attempt to let
                // the other handle it, so neither of them do. To correct this, we
                // detect if we're the only handler *except* for previous versions
                // of signal-exit, and increment by the count of listeners it has
                // created.
                /* c8 ignore start */
                const p = process;
                if (typeof p.__signal_exit_emitter__ === 'object' &&
                    typeof p.__signal_exit_emitter__.count === 'number') {
                    count += p.__signal_exit_emitter__.count;
                }
                /* c8 ignore stop */
                if (listeners.length === count) {
                    this.unload();
                    const ret = this.#emitter.emit('exit', null, sig);
                    /* c8 ignore start */
                    const s = sig === 'SIGHUP' ? this.#hupSig : sig;
                    if (!ret)
                        process.kill(process.pid, s);
                    /* c8 ignore stop */
                }
            };
        }
        this.#originalProcessReallyExit = process.reallyExit;
        this.#originalProcessEmit = process.emit;
    }
    onExit(cb, opts) {
        /* c8 ignore start */
        if (!processOk(this.#process)) {
            return () => { };
        }
        /* c8 ignore stop */
        if (this.#loaded === false) {
            this.load();
        }
        const ev = opts?.alwaysLast ? 'afterExit' : 'exit';
        this.#emitter.on(ev, cb);
        return () => {
            this.#emitter.removeListener(ev, cb);
            if (this.#emitter.listeners['exit'].length === 0 &&
                this.#emitter.listeners['afterExit'].length === 0) {
                this.unload();
            }
        };
    }
    load() {
        if (this.#loaded) {
            return;
        }
        this.#loaded = true;
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        this.#emitter.count += 1;
        for (const sig of signals_js_1.signals) {
            try {
                const fn = this.#sigListeners[sig];
                if (fn)
                    this.#process.on(sig, fn);
            }
            catch (_) { }
        }
        this.#process.emit = (ev, ...a) => {
            return this.#processEmit(ev, ...a);
        };
        this.#process.reallyExit = (code) => {
            return this.#processReallyExit(code);
        };
    }
    unload() {
        if (!this.#loaded) {
            return;
        }
        this.#loaded = false;
        signals_js_1.signals.forEach(sig => {
            const listener = this.#sigListeners[sig];
            /* c8 ignore start */
            if (!listener) {
                throw new Error('Listener not defined for signal: ' + sig);
            }
            /* c8 ignore stop */
            try {
                this.#process.removeListener(sig, listener);
                /* c8 ignore start */
            }
            catch (_) { }
            /* c8 ignore stop */
        });
        this.#process.emit = this.#originalProcessEmit;
        this.#process.reallyExit = this.#originalProcessReallyExit;
        this.#emitter.count -= 1;
    }
    #processReallyExit(code) {
        /* c8 ignore start */
        if (!processOk(this.#process)) {
            return 0;
        }
        this.#process.exitCode = code || 0;
        /* c8 ignore stop */
        this.#emitter.emit('exit', this.#process.exitCode, null);
        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
    }
    #processEmit(ev, ...args) {
        const og = this.#originalProcessEmit;
        if (ev === 'exit' && processOk(this.#process)) {
            if (typeof args[0] === 'number') {
                this.#process.exitCode = args[0];
                /* c8 ignore start */
            }
            /* c8 ignore start */
            const ret = og.call(this.#process, ev, ...args);
            /* c8 ignore start */
            this.#emitter.emit('exit', this.#process.exitCode, null);
            /* c8 ignore stop */
            return ret;
        }
        else {
            return og.call(this.#process, ev, ...args);
        }
    }
}
const process = globalThis.process;
// wrap so that we call the method on the actual handler, without
// exporting it directly.
_a = signalExitWrap(processOk(process) ? new SignalExit(process) : new SignalExitFallback()), 
/**
 * Called when the process is exiting, whether via signal, explicit
 * exit, or running out of stuff to do.
 *
 * If the global process object is not suitable for instrumentation,
 * then this will be a no-op.
 *
 * Returns a function that may be used to unload signal-exit.
 */
exports.onExit = _a.onExit, 
/**
 * Load the listeners.  Likely you never need to call this, unless
 * doing a rather deep integration with signal-exit functionality.
 * Mostly exposed for the benefit of testing.
 *
 * @internal
 */
exports.load = _a.load, 
/**
 * Unload the listeners.  Likely you never need to call this, unless
 * doing a rather deep integration with signal-exit functionality.
 * Mostly exposed for the benefit of testing.
 *
 * @internal
 */
exports.unload = _a.unload;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/write-file-atomic/node_modules/signal-exit/dist/cjs/signals.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/write-file-atomic/node_modules/signal-exit/dist/cjs/signals.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signals = void 0;
/**
 * This is not the set of all possible signals.
 *
 * It IS, however, the set of all signals that trigger
 * an exit on either Linux or BSD systems.  Linux is a
 * superset of the signal names supported on BSD, and
 * the unknown signals just fail to register, so we can
 * catch that easily enough.
 *
 * Windows signals are a different set, since there are
 * signals that terminate Windows processes, but don't
 * terminate (or don't even exist) on Posix systems.
 *
 * Don't bother with SIGKILL.  It's uncatchable, which
 * means that we can't fire any callbacks anyway.
 *
 * If a user does happen to register a handler on a non-
 * fatal signal like SIGWINCH or something, and then
 * exit, it'll end up firing `process.emit('exit')`, so
 * the handler will be fired anyway.
 *
 * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
 * artificially, inherently leave the process in a
 * state from which it is not safe to try and enter JS
 * listeners.
 */
exports.signals = [];
exports.signals.push('SIGHUP', 'SIGINT', 'SIGTERM');
if (process.platform !== 'win32') {
    exports.signals.push('SIGALRM', 'SIGABRT', 'SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT'
    // should detect profiler and enable/disable accordingly.
    // see #21
    // 'SIGPROF'
    );
}
if (process.platform === 'linux') {
    exports.signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT');
}
//# sourceMappingURL=signals.js.map

/***/ }),

/***/ "./node_modules/async-mutex/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/async-mutex/index.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E_ALREADY_LOCKED: () => (/* binding */ E_ALREADY_LOCKED),
/* harmony export */   E_CANCELED: () => (/* binding */ E_CANCELED),
/* harmony export */   E_TIMEOUT: () => (/* binding */ E_TIMEOUT),
/* harmony export */   Mutex: () => (/* binding */ Mutex),
/* harmony export */   Semaphore: () => (/* binding */ Semaphore),
/* harmony export */   tryAcquire: () => (/* binding */ tryAcquire),
/* harmony export */   withTimeout: () => (/* binding */ withTimeout)
/* harmony export */ });
const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');
const E_ALREADY_LOCKED = new Error('mutex already locked');
const E_CANCELED = new Error('request for lock canceled');

var __awaiter$2 = ( false) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Semaphore {
    constructor(_value, _cancelError = E_CANCELED) {
        this._value = _value;
        this._cancelError = _cancelError;
        this._queue = [];
        this._weightedWaiters = [];
    }
    acquire(weight = 1, priority = 0) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        return new Promise((resolve, reject) => {
            const task = { resolve, reject, weight, priority };
            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
            if (i === -1 && weight <= this._value) {
                // Needs immediate dispatch, skip the queue
                this._dispatchItem(task);
            }
            else {
                this._queue.splice(i + 1, 0, task);
            }
        });
    }
    runExclusive(callback_1) {
        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
            const [value, release] = yield this.acquire(weight, priority);
            try {
                return yield callback(value);
            }
            finally {
                release();
            }
        });
    }
    waitForUnlock(weight = 1, priority = 0) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        if (this._couldLockImmediately(weight, priority)) {
            return Promise.resolve();
        }
        else {
            return new Promise((resolve) => {
                if (!this._weightedWaiters[weight - 1])
                    this._weightedWaiters[weight - 1] = [];
                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });
            });
        }
    }
    isLocked() {
        return this._value <= 0;
    }
    getValue() {
        return this._value;
    }
    setValue(value) {
        this._value = value;
        this._dispatchQueue();
    }
    release(weight = 1) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        this._value += weight;
        this._dispatchQueue();
    }
    cancel() {
        this._queue.forEach((entry) => entry.reject(this._cancelError));
        this._queue = [];
    }
    _dispatchQueue() {
        this._drainUnlockWaiters();
        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
            this._dispatchItem(this._queue.shift());
            this._drainUnlockWaiters();
        }
    }
    _dispatchItem(item) {
        const previousValue = this._value;
        this._value -= item.weight;
        item.resolve([previousValue, this._newReleaser(item.weight)]);
    }
    _newReleaser(weight) {
        let called = false;
        return () => {
            if (called)
                return;
            called = true;
            this.release(weight);
        };
    }
    _drainUnlockWaiters() {
        if (this._queue.length === 0) {
            for (let weight = this._value; weight > 0; weight--) {
                const waiters = this._weightedWaiters[weight - 1];
                if (!waiters)
                    continue;
                waiters.forEach((waiter) => waiter.resolve());
                this._weightedWaiters[weight - 1] = [];
            }
        }
        else {
            const queuedPriority = this._queue[0].priority;
            for (let weight = this._value; weight > 0; weight--) {
                const waiters = this._weightedWaiters[weight - 1];
                if (!waiters)
                    continue;
                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
                (i === -1 ? waiters : waiters.splice(0, i))
                    .forEach((waiter => waiter.resolve()));
            }
        }
    }
    _couldLockImmediately(weight, priority) {
        return (this._queue.length === 0 || this._queue[0].priority < priority) &&
            weight <= this._value;
    }
}
function insertSorted(a, v) {
    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
    a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
    for (let i = a.length - 1; i >= 0; i--) {
        if (predicate(a[i])) {
            return i;
        }
    }
    return -1;
}

var __awaiter$1 = ( false) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Mutex {
    constructor(cancelError) {
        this._semaphore = new Semaphore(1, cancelError);
    }
    acquire() {
        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
            const [, releaser] = yield this._semaphore.acquire(1, priority);
            return releaser;
        });
    }
    runExclusive(callback, priority = 0) {
        return this._semaphore.runExclusive(() => callback(), 1, priority);
    }
    isLocked() {
        return this._semaphore.isLocked();
    }
    waitForUnlock(priority = 0) {
        return this._semaphore.waitForUnlock(1, priority);
    }
    release() {
        if (this._semaphore.isLocked())
            this._semaphore.release();
    }
    cancel() {
        return this._semaphore.cancel();
    }
}

var __awaiter = ( false) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {
    return {
        acquire: (weightOrPriority, priority) => {
            let weight;
            if (isSemaphore(sync)) {
                weight = weightOrPriority;
            }
            else {
                weight = undefined;
                priority = weightOrPriority;
            }
            if (weight !== undefined && weight <= 0) {
                throw new Error(`invalid weight ${weight}: must be positive`);
            }
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let isTimeout = false;
                const handle = setTimeout(() => {
                    isTimeout = true;
                    reject(timeoutError);
                }, timeout);
                try {
                    const ticket = yield (isSemaphore(sync)
                        ? sync.acquire(weight, priority)
                        : sync.acquire(priority));
                    if (isTimeout) {
                        const release = Array.isArray(ticket) ? ticket[1] : ticket;
                        release();
                    }
                    else {
                        clearTimeout(handle);
                        resolve(ticket);
                    }
                }
                catch (e) {
                    if (!isTimeout) {
                        clearTimeout(handle);
                        reject(e);
                    }
                }
            }));
        },
        runExclusive(callback, weight, priority) {
            return __awaiter(this, void 0, void 0, function* () {
                let release = () => undefined;
                try {
                    const ticket = yield this.acquire(weight, priority);
                    if (Array.isArray(ticket)) {
                        release = ticket[1];
                        return yield callback(ticket[0]);
                    }
                    else {
                        release = ticket;
                        return yield callback();
                    }
                }
                finally {
                    release();
                }
            });
        },
        release(weight) {
            sync.release(weight);
        },
        cancel() {
            return sync.cancel();
        },
        waitForUnlock: (weightOrPriority, priority) => {
            let weight;
            if (isSemaphore(sync)) {
                weight = weightOrPriority;
            }
            else {
                weight = undefined;
                priority = weightOrPriority;
            }
            if (weight !== undefined && weight <= 0) {
                throw new Error(`invalid weight ${weight}: must be positive`);
            }
            return new Promise((resolve, reject) => {
                const handle = setTimeout(() => reject(timeoutError), timeout);
                (isSemaphore(sync)
                    ? sync.waitForUnlock(weight, priority)
                    : sync.waitForUnlock(priority)).then(() => {
                    clearTimeout(handle);
                    resolve();
                });
            });
        },
        isLocked: () => sync.isLocked(),
        getValue: () => sync.getValue(),
        setValue: (value) => sync.setValue(value),
    };
}
function isSemaphore(sync) {
    return sync.getValue !== undefined;
}

// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types
function tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return withTimeout(sync, 0, alreadyAcquiredError);
}




/***/ }),

/***/ "./node_modules/jsonpath-plus/dist/index-node-esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/jsonpath-plus/dist/index-node-esm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JSONPath: () => (/* binding */ JSONPath)
/* harmony export */ });
/* harmony import */ var vm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vm */ "vm");


/**
 * @implements {IHooks}
 */
class Hooks {
  /**
   * @callback HookCallback
   * @this {*|Jsep} this
   * @param {Jsep} env
   * @returns: void
   */
  /**
   * Adds the given callback to the list of callbacks for the given hook.
   *
   * The callback will be invoked when the hook it is registered for is run.
   *
   * One callback function can be registered to multiple hooks and the same hook multiple times.
   *
   * @param {string|object} name The name of the hook, or an object of callbacks keyed by name
   * @param {HookCallback|boolean} callback The callback function which is given environment variables.
   * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)
   * @public
   */
  add(name, callback, first) {
    if (typeof arguments[0] != 'string') {
      // Multiple hook callbacks, keyed by name
      for (let name in arguments[0]) {
        this.add(name, arguments[0][name], arguments[1]);
      }
    } else {
      (Array.isArray(name) ? name : [name]).forEach(function (name) {
        this[name] = this[name] || [];
        if (callback) {
          this[name][first ? 'unshift' : 'push'](callback);
        }
      }, this);
    }
  }

  /**
   * Runs a hook invoking all registered callbacks with the given environment variables.
   *
   * Callbacks will be invoked synchronously and in the order in which they were registered.
   *
   * @param {string} name The name of the hook.
   * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
   * @public
   */
  run(name, env) {
    this[name] = this[name] || [];
    this[name].forEach(function (callback) {
      callback.call(env && env.context ? env.context : env, env);
    });
  }
}

/**
 * @implements {IPlugins}
 */
class Plugins {
  constructor(jsep) {
    this.jsep = jsep;
    this.registered = {};
  }

  /**
   * @callback PluginSetup
   * @this {Jsep} jsep
   * @returns: void
   */
  /**
   * Adds the given plugin(s) to the registry
   *
   * @param {object} plugins
   * @param {string} plugins.name The name of the plugin
   * @param {PluginSetup} plugins.init The init function
   * @public
   */
  register(...plugins) {
    plugins.forEach(plugin => {
      if (typeof plugin !== 'object' || !plugin.name || !plugin.init) {
        throw new Error('Invalid JSEP plugin format');
      }
      if (this.registered[plugin.name]) {
        // already registered. Ignore.
        return;
      }
      plugin.init(this.jsep);
      this.registered[plugin.name] = plugin;
    });
  }
}

//     JavaScript Expression Parser (JSEP) 1.4.0

class Jsep {
  /**
   * @returns {string}
   */
  static get version() {
    // To be filled in by the template
    return '1.4.0';
  }

  /**
   * @returns {string}
   */
  static toString() {
    return 'JavaScript Expression Parser (JSEP) v' + Jsep.version;
  }
  // ==================== CONFIG ================================
  /**
   * @method addUnaryOp
   * @param {string} op_name The name of the unary op to add
   * @returns {Jsep}
   */
  static addUnaryOp(op_name) {
    Jsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len);
    Jsep.unary_ops[op_name] = 1;
    return Jsep;
  }

  /**
   * @method jsep.addBinaryOp
   * @param {string} op_name The name of the binary op to add
   * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence
   * @param {boolean} [isRightAssociative=false] whether operator is right-associative
   * @returns {Jsep}
   */
  static addBinaryOp(op_name, precedence, isRightAssociative) {
    Jsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len);
    Jsep.binary_ops[op_name] = precedence;
    if (isRightAssociative) {
      Jsep.right_associative.add(op_name);
    } else {
      Jsep.right_associative.delete(op_name);
    }
    return Jsep;
  }

  /**
   * @method addIdentifierChar
   * @param {string} char The additional character to treat as a valid part of an identifier
   * @returns {Jsep}
   */
  static addIdentifierChar(char) {
    Jsep.additional_identifier_chars.add(char);
    return Jsep;
  }

  /**
   * @method addLiteral
   * @param {string} literal_name The name of the literal to add
   * @param {*} literal_value The value of the literal
   * @returns {Jsep}
   */
  static addLiteral(literal_name, literal_value) {
    Jsep.literals[literal_name] = literal_value;
    return Jsep;
  }

  /**
   * @method removeUnaryOp
   * @param {string} op_name The name of the unary op to remove
   * @returns {Jsep}
   */
  static removeUnaryOp(op_name) {
    delete Jsep.unary_ops[op_name];
    if (op_name.length === Jsep.max_unop_len) {
      Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);
    }
    return Jsep;
  }

  /**
   * @method removeAllUnaryOps
   * @returns {Jsep}
   */
  static removeAllUnaryOps() {
    Jsep.unary_ops = {};
    Jsep.max_unop_len = 0;
    return Jsep;
  }

  /**
   * @method removeIdentifierChar
   * @param {string} char The additional character to stop treating as a valid part of an identifier
   * @returns {Jsep}
   */
  static removeIdentifierChar(char) {
    Jsep.additional_identifier_chars.delete(char);
    return Jsep;
  }

  /**
   * @method removeBinaryOp
   * @param {string} op_name The name of the binary op to remove
   * @returns {Jsep}
   */
  static removeBinaryOp(op_name) {
    delete Jsep.binary_ops[op_name];
    if (op_name.length === Jsep.max_binop_len) {
      Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);
    }
    Jsep.right_associative.delete(op_name);
    return Jsep;
  }

  /**
   * @method removeAllBinaryOps
   * @returns {Jsep}
   */
  static removeAllBinaryOps() {
    Jsep.binary_ops = {};
    Jsep.max_binop_len = 0;
    return Jsep;
  }

  /**
   * @method removeLiteral
   * @param {string} literal_name The name of the literal to remove
   * @returns {Jsep}
   */
  static removeLiteral(literal_name) {
    delete Jsep.literals[literal_name];
    return Jsep;
  }

  /**
   * @method removeAllLiterals
   * @returns {Jsep}
   */
  static removeAllLiterals() {
    Jsep.literals = {};
    return Jsep;
  }
  // ==================== END CONFIG ============================

  /**
   * @returns {string}
   */
  get char() {
    return this.expr.charAt(this.index);
  }

  /**
   * @returns {number}
   */
  get code() {
    return this.expr.charCodeAt(this.index);
  }
  /**
   * @param {string} expr a string with the passed in express
   * @returns Jsep
   */
  constructor(expr) {
    // `index` stores the character number we are currently at
    // All of the gobbles below will modify `index` as we move along
    this.expr = expr;
    this.index = 0;
  }

  /**
   * static top-level parser
   * @returns {jsep.Expression}
   */
  static parse(expr) {
    return new Jsep(expr).parse();
  }

  /**
   * Get the longest key length of any object
   * @param {object} obj
   * @returns {number}
   */
  static getMaxKeyLen(obj) {
    return Math.max(0, ...Object.keys(obj).map(k => k.length));
  }

  /**
   * `ch` is a character code in the next three functions
   * @param {number} ch
   * @returns {boolean}
   */
  static isDecimalDigit(ch) {
    return ch >= 48 && ch <= 57; // 0...9
  }

  /**
   * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.
   * @param {string} op_val
   * @returns {number}
   */
  static binaryPrecedence(op_val) {
    return Jsep.binary_ops[op_val] || 0;
  }

  /**
   * Looks for start of identifier
   * @param {number} ch
   * @returns {boolean}
   */
  static isIdentifierStart(ch) {
    return ch >= 65 && ch <= 90 ||
    // A...Z
    ch >= 97 && ch <= 122 ||
    // a...z
    ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)] ||
    // any non-ASCII that is not an operator
    Jsep.additional_identifier_chars.has(String.fromCharCode(ch)); // additional characters
  }

  /**
   * @param {number} ch
   * @returns {boolean}
   */
  static isIdentifierPart(ch) {
    return Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch);
  }

  /**
   * throw error at index of the expression
   * @param {string} message
   * @throws
   */
  throwError(message) {
    const error = new Error(message + ' at character ' + this.index);
    error.index = this.index;
    error.description = message;
    throw error;
  }

  /**
   * Run a given hook
   * @param {string} name
   * @param {jsep.Expression|false} [node]
   * @returns {?jsep.Expression}
   */
  runHook(name, node) {
    if (Jsep.hooks[name]) {
      const env = {
        context: this,
        node
      };
      Jsep.hooks.run(name, env);
      return env.node;
    }
    return node;
  }

  /**
   * Runs a given hook until one returns a node
   * @param {string} name
   * @returns {?jsep.Expression}
   */
  searchHook(name) {
    if (Jsep.hooks[name]) {
      const env = {
        context: this
      };
      Jsep.hooks[name].find(function (callback) {
        callback.call(env.context, env);
        return env.node;
      });
      return env.node;
    }
  }

  /**
   * Push `index` up to the next non-space character
   */
  gobbleSpaces() {
    let ch = this.code;
    // Whitespace
    while (ch === Jsep.SPACE_CODE || ch === Jsep.TAB_CODE || ch === Jsep.LF_CODE || ch === Jsep.CR_CODE) {
      ch = this.expr.charCodeAt(++this.index);
    }
    this.runHook('gobble-spaces');
  }

  /**
   * Top-level method to parse all expressions and returns compound or single node
   * @returns {jsep.Expression}
   */
  parse() {
    this.runHook('before-all');
    const nodes = this.gobbleExpressions();

    // If there's only one expression just try returning the expression
    const node = nodes.length === 1 ? nodes[0] : {
      type: Jsep.COMPOUND,
      body: nodes
    };
    return this.runHook('after-all', node);
  }

  /**
   * top-level parser (but can be reused within as well)
   * @param {number} [untilICode]
   * @returns {jsep.Expression[]}
   */
  gobbleExpressions(untilICode) {
    let nodes = [],
      ch_i,
      node;
    while (this.index < this.expr.length) {
      ch_i = this.code;

      // Expressions can be separated by semicolons, commas, or just inferred without any
      // separators
      if (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {
        this.index++; // ignore separators
      } else {
        // Try to gobble each expression individually
        if (node = this.gobbleExpression()) {
          nodes.push(node);
          // If we weren't able to find a binary expression and are out of room, then
          // the expression passed in probably has too much
        } else if (this.index < this.expr.length) {
          if (ch_i === untilICode) {
            break;
          }
          this.throwError('Unexpected "' + this.char + '"');
        }
      }
    }
    return nodes;
  }

  /**
   * The main parsing function.
   * @returns {?jsep.Expression}
   */
  gobbleExpression() {
    const node = this.searchHook('gobble-expression') || this.gobbleBinaryExpression();
    this.gobbleSpaces();
    return this.runHook('after-expression', node);
  }

  /**
   * Search for the operation portion of the string (e.g. `+`, `===`)
   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
   * and move down from 3 to 2 to 1 character until a matching binary operation is found
   * then, return that binary operation
   * @returns {string|boolean}
   */
  gobbleBinaryOp() {
    this.gobbleSpaces();
    let to_check = this.expr.substr(this.index, Jsep.max_binop_len);
    let tc_len = to_check.length;
    while (tc_len > 0) {
      // Don't accept a binary op when it is an identifier.
      // Binary ops that start with a identifier-valid character must be followed
      // by a non identifier-part valid character
      if (Jsep.binary_ops.hasOwnProperty(to_check) && (!Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
        this.index += tc_len;
        return to_check;
      }
      to_check = to_check.substr(0, --tc_len);
    }
    return false;
  }

  /**
   * This function is responsible for gobbling an individual expression,
   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
   * @returns {?jsep.BinaryExpression}
   */
  gobbleBinaryExpression() {
    let node, biop, prec, stack, biop_info, left, right, i, cur_biop;

    // First, try to get the leftmost thing
    // Then, check to see if there's a binary operator operating on that leftmost thing
    // Don't gobbleBinaryOp without a left-hand-side
    left = this.gobbleToken();
    if (!left) {
      return left;
    }
    biop = this.gobbleBinaryOp();

    // If there wasn't a binary operator, just return the leftmost node
    if (!biop) {
      return left;
    }

    // Otherwise, we need to start a stack to properly place the binary operations in their
    // precedence structure
    biop_info = {
      value: biop,
      prec: Jsep.binaryPrecedence(biop),
      right_a: Jsep.right_associative.has(biop)
    };
    right = this.gobbleToken();
    if (!right) {
      this.throwError("Expected expression after " + biop);
    }
    stack = [left, biop_info, right];

    // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)
    while (biop = this.gobbleBinaryOp()) {
      prec = Jsep.binaryPrecedence(biop);
      if (prec === 0) {
        this.index -= biop.length;
        break;
      }
      biop_info = {
        value: biop,
        prec,
        right_a: Jsep.right_associative.has(biop)
      };
      cur_biop = biop;

      // Reduce: make a binary expression from the three topmost entries.
      const comparePrev = prev => biop_info.right_a && prev.right_a ? prec > prev.prec : prec <= prev.prec;
      while (stack.length > 2 && comparePrev(stack[stack.length - 2])) {
        right = stack.pop();
        biop = stack.pop().value;
        left = stack.pop();
        node = {
          type: Jsep.BINARY_EXP,
          operator: biop,
          left,
          right
        };
        stack.push(node);
      }
      node = this.gobbleToken();
      if (!node) {
        this.throwError("Expected expression after " + cur_biop);
      }
      stack.push(biop_info, node);
    }
    i = stack.length - 1;
    node = stack[i];
    while (i > 1) {
      node = {
        type: Jsep.BINARY_EXP,
        operator: stack[i - 1].value,
        left: stack[i - 2],
        right: node
      };
      i -= 2;
    }
    return node;
  }

  /**
   * An individual part of a binary expression:
   * e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
   * @returns {boolean|jsep.Expression}
   */
  gobbleToken() {
    let ch, to_check, tc_len, node;
    this.gobbleSpaces();
    node = this.searchHook('gobble-token');
    if (node) {
      return this.runHook('after-token', node);
    }
    ch = this.code;
    if (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {
      // Char code 46 is a dot `.` which can start off a numeric literal
      return this.gobbleNumericLiteral();
    }
    if (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {
      // Single or double quotes
      node = this.gobbleStringLiteral();
    } else if (ch === Jsep.OBRACK_CODE) {
      node = this.gobbleArray();
    } else {
      to_check = this.expr.substr(this.index, Jsep.max_unop_len);
      tc_len = to_check.length;
      while (tc_len > 0) {
        // Don't accept an unary op when it is an identifier.
        // Unary ops that start with a identifier-valid character must be followed
        // by a non identifier-part valid character
        if (Jsep.unary_ops.hasOwnProperty(to_check) && (!Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
          this.index += tc_len;
          const argument = this.gobbleToken();
          if (!argument) {
            this.throwError('missing unaryOp argument');
          }
          return this.runHook('after-token', {
            type: Jsep.UNARY_EXP,
            operator: to_check,
            argument,
            prefix: true
          });
        }
        to_check = to_check.substr(0, --tc_len);
      }
      if (Jsep.isIdentifierStart(ch)) {
        node = this.gobbleIdentifier();
        if (Jsep.literals.hasOwnProperty(node.name)) {
          node = {
            type: Jsep.LITERAL,
            value: Jsep.literals[node.name],
            raw: node.name
          };
        } else if (node.name === Jsep.this_str) {
          node = {
            type: Jsep.THIS_EXP
          };
        }
      } else if (ch === Jsep.OPAREN_CODE) {
        // open parenthesis
        node = this.gobbleGroup();
      }
    }
    if (!node) {
      return this.runHook('after-token', false);
    }
    node = this.gobbleTokenProperty(node);
    return this.runHook('after-token', node);
  }

  /**
   * Gobble properties of of identifiers/strings/arrays/groups.
   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`
   * It also gobbles function calls:
   * e.g. `Math.acos(obj.angle)`
   * @param {jsep.Expression} node
   * @returns {jsep.Expression}
   */
  gobbleTokenProperty(node) {
    this.gobbleSpaces();
    let ch = this.code;
    while (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {
      let optional;
      if (ch === Jsep.QUMARK_CODE) {
        if (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {
          break;
        }
        optional = true;
        this.index += 2;
        this.gobbleSpaces();
        ch = this.code;
      }
      this.index++;
      if (ch === Jsep.OBRACK_CODE) {
        node = {
          type: Jsep.MEMBER_EXP,
          computed: true,
          object: node,
          property: this.gobbleExpression()
        };
        if (!node.property) {
          this.throwError('Unexpected "' + this.char + '"');
        }
        this.gobbleSpaces();
        ch = this.code;
        if (ch !== Jsep.CBRACK_CODE) {
          this.throwError('Unclosed [');
        }
        this.index++;
      } else if (ch === Jsep.OPAREN_CODE) {
        // A function call is being made; gobble all the arguments
        node = {
          type: Jsep.CALL_EXP,
          'arguments': this.gobbleArguments(Jsep.CPAREN_CODE),
          callee: node
        };
      } else if (ch === Jsep.PERIOD_CODE || optional) {
        if (optional) {
          this.index--;
        }
        this.gobbleSpaces();
        node = {
          type: Jsep.MEMBER_EXP,
          computed: false,
          object: node,
          property: this.gobbleIdentifier()
        };
      }
      if (optional) {
        node.optional = true;
      } // else leave undefined for compatibility with esprima

      this.gobbleSpaces();
      ch = this.code;
    }
    return node;
  }

  /**
   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
   * keep track of everything in the numeric literal and then calling `parseFloat` on that string
   * @returns {jsep.Literal}
   */
  gobbleNumericLiteral() {
    let number = '',
      ch,
      chCode;
    while (Jsep.isDecimalDigit(this.code)) {
      number += this.expr.charAt(this.index++);
    }
    if (this.code === Jsep.PERIOD_CODE) {
      // can start with a decimal marker
      number += this.expr.charAt(this.index++);
      while (Jsep.isDecimalDigit(this.code)) {
        number += this.expr.charAt(this.index++);
      }
    }
    ch = this.char;
    if (ch === 'e' || ch === 'E') {
      // exponent marker
      number += this.expr.charAt(this.index++);
      ch = this.char;
      if (ch === '+' || ch === '-') {
        // exponent sign
        number += this.expr.charAt(this.index++);
      }
      while (Jsep.isDecimalDigit(this.code)) {
        // exponent itself
        number += this.expr.charAt(this.index++);
      }
      if (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1))) {
        this.throwError('Expected exponent (' + number + this.char + ')');
      }
    }
    chCode = this.code;

    // Check to make sure this isn't a variable name that start with a number (123abc)
    if (Jsep.isIdentifierStart(chCode)) {
      this.throwError('Variable names cannot start with a number (' + number + this.char + ')');
    } else if (chCode === Jsep.PERIOD_CODE || number.length === 1 && number.charCodeAt(0) === Jsep.PERIOD_CODE) {
      this.throwError('Unexpected period');
    }
    return {
      type: Jsep.LITERAL,
      value: parseFloat(number),
      raw: number
    };
  }

  /**
   * Parses a string literal, staring with single or double quotes with basic support for escape codes
   * e.g. `"hello world"`, `'this is\nJSEP'`
   * @returns {jsep.Literal}
   */
  gobbleStringLiteral() {
    let str = '';
    const startIndex = this.index;
    const quote = this.expr.charAt(this.index++);
    let closed = false;
    while (this.index < this.expr.length) {
      let ch = this.expr.charAt(this.index++);
      if (ch === quote) {
        closed = true;
        break;
      } else if (ch === '\\') {
        // Check for all of the common escape codes
        ch = this.expr.charAt(this.index++);
        switch (ch) {
          case 'n':
            str += '\n';
            break;
          case 'r':
            str += '\r';
            break;
          case 't':
            str += '\t';
            break;
          case 'b':
            str += '\b';
            break;
          case 'f':
            str += '\f';
            break;
          case 'v':
            str += '\x0B';
            break;
          default:
            str += ch;
        }
      } else {
        str += ch;
      }
    }
    if (!closed) {
      this.throwError('Unclosed quote after "' + str + '"');
    }
    return {
      type: Jsep.LITERAL,
      value: str,
      raw: this.expr.substring(startIndex, this.index)
    };
  }

  /**
   * Gobbles only identifiers
   * e.g.: `foo`, `_value`, `$x1`
   * Also, this function checks if that identifier is a literal:
   * (e.g. `true`, `false`, `null`) or `this`
   * @returns {jsep.Identifier}
   */
  gobbleIdentifier() {
    let ch = this.code,
      start = this.index;
    if (Jsep.isIdentifierStart(ch)) {
      this.index++;
    } else {
      this.throwError('Unexpected ' + this.char);
    }
    while (this.index < this.expr.length) {
      ch = this.code;
      if (Jsep.isIdentifierPart(ch)) {
        this.index++;
      } else {
        break;
      }
    }
    return {
      type: Jsep.IDENTIFIER,
      name: this.expr.slice(start, this.index)
    };
  }

  /**
   * Gobbles a list of arguments within the context of a function call
   * or array literal. This function also assumes that the opening character
   * `(` or `[` has already been gobbled, and gobbles expressions and commas
   * until the terminator character `)` or `]` is encountered.
   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
   * @param {number} termination
   * @returns {jsep.Expression[]}
   */
  gobbleArguments(termination) {
    const args = [];
    let closed = false;
    let separator_count = 0;
    while (this.index < this.expr.length) {
      this.gobbleSpaces();
      let ch_i = this.code;
      if (ch_i === termination) {
        // done parsing
        closed = true;
        this.index++;
        if (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length) {
          this.throwError('Unexpected token ' + String.fromCharCode(termination));
        }
        break;
      } else if (ch_i === Jsep.COMMA_CODE) {
        // between expressions
        this.index++;
        separator_count++;
        if (separator_count !== args.length) {
          // missing argument
          if (termination === Jsep.CPAREN_CODE) {
            this.throwError('Unexpected token ,');
          } else if (termination === Jsep.CBRACK_CODE) {
            for (let arg = args.length; arg < separator_count; arg++) {
              args.push(null);
            }
          }
        }
      } else if (args.length !== separator_count && separator_count !== 0) {
        // NOTE: `&& separator_count !== 0` allows for either all commas, or all spaces as arguments
        this.throwError('Expected comma');
      } else {
        const node = this.gobbleExpression();
        if (!node || node.type === Jsep.COMPOUND) {
          this.throwError('Expected comma');
        }
        args.push(node);
      }
    }
    if (!closed) {
      this.throwError('Expected ' + String.fromCharCode(termination));
    }
    return args;
  }

  /**
   * Responsible for parsing a group of things within parentheses `()`
   * that have no identifier in front (so not a function call)
   * This function assumes that it needs to gobble the opening parenthesis
   * and then tries to gobble everything within that parenthesis, assuming
   * that the next thing it should see is the close parenthesis. If not,
   * then the expression probably doesn't have a `)`
   * @returns {boolean|jsep.Expression}
   */
  gobbleGroup() {
    this.index++;
    let nodes = this.gobbleExpressions(Jsep.CPAREN_CODE);
    if (this.code === Jsep.CPAREN_CODE) {
      this.index++;
      if (nodes.length === 1) {
        return nodes[0];
      } else if (!nodes.length) {
        return false;
      } else {
        return {
          type: Jsep.SEQUENCE_EXP,
          expressions: nodes
        };
      }
    } else {
      this.throwError('Unclosed (');
    }
  }

  /**
   * Responsible for parsing Array literals `[1, 2, 3]`
   * This function assumes that it needs to gobble the opening bracket
   * and then tries to gobble the expressions as arguments.
   * @returns {jsep.ArrayExpression}
   */
  gobbleArray() {
    this.index++;
    return {
      type: Jsep.ARRAY_EXP,
      elements: this.gobbleArguments(Jsep.CBRACK_CODE)
    };
  }
}

// Static fields:
const hooks = new Hooks();
Object.assign(Jsep, {
  hooks,
  plugins: new Plugins(Jsep),
  // Node Types
  // ----------
  // This is the full set of types that any JSEP node can be.
  // Store them here to save space when minified
  COMPOUND: 'Compound',
  SEQUENCE_EXP: 'SequenceExpression',
  IDENTIFIER: 'Identifier',
  MEMBER_EXP: 'MemberExpression',
  LITERAL: 'Literal',
  THIS_EXP: 'ThisExpression',
  CALL_EXP: 'CallExpression',
  UNARY_EXP: 'UnaryExpression',
  BINARY_EXP: 'BinaryExpression',
  ARRAY_EXP: 'ArrayExpression',
  TAB_CODE: 9,
  LF_CODE: 10,
  CR_CODE: 13,
  SPACE_CODE: 32,
  PERIOD_CODE: 46,
  // '.'
  COMMA_CODE: 44,
  // ','
  SQUOTE_CODE: 39,
  // single quote
  DQUOTE_CODE: 34,
  // double quotes
  OPAREN_CODE: 40,
  // (
  CPAREN_CODE: 41,
  // )
  OBRACK_CODE: 91,
  // [
  CBRACK_CODE: 93,
  // ]
  QUMARK_CODE: 63,
  // ?
  SEMCOL_CODE: 59,
  // ;
  COLON_CODE: 58,
  // :

  // Operations
  // ----------
  // Use a quickly-accessible map to store all of the unary operators
  // Values are set to `1` (it really doesn't matter)
  unary_ops: {
    '-': 1,
    '!': 1,
    '~': 1,
    '+': 1
  },
  // Also use a map for the binary operations but set their values to their
  // binary precedence for quick reference (higher number = higher precedence)
  // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
  binary_ops: {
    '||': 1,
    '??': 1,
    '&&': 2,
    '|': 3,
    '^': 4,
    '&': 5,
    '==': 6,
    '!=': 6,
    '===': 6,
    '!==': 6,
    '<': 7,
    '>': 7,
    '<=': 7,
    '>=': 7,
    '<<': 8,
    '>>': 8,
    '>>>': 8,
    '+': 9,
    '-': 9,
    '*': 10,
    '/': 10,
    '%': 10,
    '**': 11
  },
  // sets specific binary_ops as right-associative
  right_associative: new Set(['**']),
  // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)
  additional_identifier_chars: new Set(['$', '_']),
  // Literals
  // ----------
  // Store the values to return for the various literals we may encounter
  literals: {
    'true': true,
    'false': false,
    'null': null
  },
  // Except for `this`, which is special. This could be changed to something like `'self'` as well
  this_str: 'this'
});
Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);
Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);

// Backward Compatibility:
const jsep = expr => new Jsep(expr).parse();
const stdClassProps = Object.getOwnPropertyNames(class Test {});
Object.getOwnPropertyNames(Jsep).filter(prop => !stdClassProps.includes(prop) && jsep[prop] === undefined).forEach(m => {
  jsep[m] = Jsep[m];
});
jsep.Jsep = Jsep; // allows for const { Jsep } = require('jsep');

const CONDITIONAL_EXP = 'ConditionalExpression';
var ternary = {
  name: 'ternary',
  init(jsep) {
    // Ternary expression: test ? consequent : alternate
    jsep.hooks.add('after-expression', function gobbleTernary(env) {
      if (env.node && this.code === jsep.QUMARK_CODE) {
        this.index++;
        const test = env.node;
        const consequent = this.gobbleExpression();
        if (!consequent) {
          this.throwError('Expected expression');
        }
        this.gobbleSpaces();
        if (this.code === jsep.COLON_CODE) {
          this.index++;
          const alternate = this.gobbleExpression();
          if (!alternate) {
            this.throwError('Expected expression');
          }
          env.node = {
            type: CONDITIONAL_EXP,
            test,
            consequent,
            alternate
          };

          // check for operators of higher priority than ternary (i.e. assignment)
          // jsep sets || at 1, and assignment at 0.9, and conditional should be between them
          if (test.operator && jsep.binary_ops[test.operator] <= 0.9) {
            let newTest = test;
            while (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {
              newTest = newTest.right;
            }
            env.node.test = newTest.right;
            newTest.right = env.node;
            env.node = test;
          }
        } else {
          this.throwError('Expected :');
        }
      }
    });
  }
};

// Add default plugins:

jsep.plugins.register(ternary);

const FSLASH_CODE = 47; // '/'
const BSLASH_CODE = 92; // '\\'

var index = {
  name: 'regex',
  init(jsep) {
    // Regex literal: /abc123/ig
    jsep.hooks.add('gobble-token', function gobbleRegexLiteral(env) {
      if (this.code === FSLASH_CODE) {
        const patternIndex = ++this.index;
        let inCharSet = false;
        while (this.index < this.expr.length) {
          if (this.code === FSLASH_CODE && !inCharSet) {
            const pattern = this.expr.slice(patternIndex, this.index);
            let flags = '';
            while (++this.index < this.expr.length) {
              const code = this.code;
              if (code >= 97 && code <= 122 // a...z
              || code >= 65 && code <= 90 // A...Z
              || code >= 48 && code <= 57) {
                // 0-9
                flags += this.char;
              } else {
                break;
              }
            }
            let value;
            try {
              value = new RegExp(pattern, flags);
            } catch (e) {
              this.throwError(e.message);
            }
            env.node = {
              type: jsep.LITERAL,
              value,
              raw: this.expr.slice(patternIndex - 1, this.index)
            };

            // allow . [] and () after regex: /regex/.test(a)
            env.node = this.gobbleTokenProperty(env.node);
            return env.node;
          }
          if (this.code === jsep.OBRACK_CODE) {
            inCharSet = true;
          } else if (inCharSet && this.code === jsep.CBRACK_CODE) {
            inCharSet = false;
          }
          this.index += this.code === BSLASH_CODE ? 2 : 1;
        }
        this.throwError('Unclosed Regex');
      }
    });
  }
};

const PLUS_CODE = 43; // +
const MINUS_CODE = 45; // -

const plugin = {
  name: 'assignment',
  assignmentOperators: new Set(['=', '*=', '**=', '/=', '%=', '+=', '-=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '||=', '&&=', '??=']),
  updateOperators: [PLUS_CODE, MINUS_CODE],
  assignmentPrecedence: 0.9,
  init(jsep) {
    const updateNodeTypes = [jsep.IDENTIFIER, jsep.MEMBER_EXP];
    plugin.assignmentOperators.forEach(op => jsep.addBinaryOp(op, plugin.assignmentPrecedence, true));
    jsep.hooks.add('gobble-token', function gobbleUpdatePrefix(env) {
      const code = this.code;
      if (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {
        this.index += 2;
        env.node = {
          type: 'UpdateExpression',
          operator: code === PLUS_CODE ? '++' : '--',
          argument: this.gobbleTokenProperty(this.gobbleIdentifier()),
          prefix: true
        };
        if (!env.node.argument || !updateNodeTypes.includes(env.node.argument.type)) {
          this.throwError(`Unexpected ${env.node.operator}`);
        }
      }
    });
    jsep.hooks.add('after-token', function gobbleUpdatePostfix(env) {
      if (env.node) {
        const code = this.code;
        if (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {
          if (!updateNodeTypes.includes(env.node.type)) {
            this.throwError(`Unexpected ${env.node.operator}`);
          }
          this.index += 2;
          env.node = {
            type: 'UpdateExpression',
            operator: code === PLUS_CODE ? '++' : '--',
            argument: env.node,
            prefix: false
          };
        }
      }
    });
    jsep.hooks.add('after-expression', function gobbleAssignment(env) {
      if (env.node) {
        // Note: Binaries can be chained in a single expression to respect
        // operator precedence (i.e. a = b = 1 + 2 + 3)
        // Update all binary assignment nodes in the tree
        updateBinariesToAssignments(env.node);
      }
    });
    function updateBinariesToAssignments(node) {
      if (plugin.assignmentOperators.has(node.operator)) {
        node.type = 'AssignmentExpression';
        updateBinariesToAssignments(node.left);
        updateBinariesToAssignments(node.right);
      } else if (!node.operator) {
        Object.values(node).forEach(val => {
          if (val && typeof val === 'object') {
            updateBinariesToAssignments(val);
          }
        });
      }
    }
  }
};

/* eslint-disable no-bitwise -- Convenient */

// register plugins
jsep.plugins.register(index, plugin);
jsep.addUnaryOp('typeof');
jsep.addLiteral('null', null);
jsep.addLiteral('undefined', undefined);
const BLOCKED_PROTO_PROPERTIES = new Set(['constructor', '__proto__', '__defineGetter__', '__defineSetter__']);
const SafeEval = {
  /**
   * @param {jsep.Expression} ast
   * @param {Record<string, any>} subs
   */
  evalAst(ast, subs) {
    switch (ast.type) {
      case 'BinaryExpression':
      case 'LogicalExpression':
        return SafeEval.evalBinaryExpression(ast, subs);
      case 'Compound':
        return SafeEval.evalCompound(ast, subs);
      case 'ConditionalExpression':
        return SafeEval.evalConditionalExpression(ast, subs);
      case 'Identifier':
        return SafeEval.evalIdentifier(ast, subs);
      case 'Literal':
        return SafeEval.evalLiteral(ast, subs);
      case 'MemberExpression':
        return SafeEval.evalMemberExpression(ast, subs);
      case 'UnaryExpression':
        return SafeEval.evalUnaryExpression(ast, subs);
      case 'ArrayExpression':
        return SafeEval.evalArrayExpression(ast, subs);
      case 'CallExpression':
        return SafeEval.evalCallExpression(ast, subs);
      case 'AssignmentExpression':
        return SafeEval.evalAssignmentExpression(ast, subs);
      default:
        throw SyntaxError('Unexpected expression', ast);
    }
  },
  evalBinaryExpression(ast, subs) {
    const result = {
      '||': (a, b) => a || b(),
      '&&': (a, b) => a && b(),
      '|': (a, b) => a | b(),
      '^': (a, b) => a ^ b(),
      '&': (a, b) => a & b(),
      // eslint-disable-next-line eqeqeq -- API
      '==': (a, b) => a == b(),
      // eslint-disable-next-line eqeqeq -- API
      '!=': (a, b) => a != b(),
      '===': (a, b) => a === b(),
      '!==': (a, b) => a !== b(),
      '<': (a, b) => a < b(),
      '>': (a, b) => a > b(),
      '<=': (a, b) => a <= b(),
      '>=': (a, b) => a >= b(),
      '<<': (a, b) => a << b(),
      '>>': (a, b) => a >> b(),
      '>>>': (a, b) => a >>> b(),
      '+': (a, b) => a + b(),
      '-': (a, b) => a - b(),
      '*': (a, b) => a * b(),
      '/': (a, b) => a / b(),
      '%': (a, b) => a % b()
    }[ast.operator](SafeEval.evalAst(ast.left, subs), () => SafeEval.evalAst(ast.right, subs));
    return result;
  },
  evalCompound(ast, subs) {
    let last;
    for (let i = 0; i < ast.body.length; i++) {
      if (ast.body[i].type === 'Identifier' && ['var', 'let', 'const'].includes(ast.body[i].name) && ast.body[i + 1] && ast.body[i + 1].type === 'AssignmentExpression') {
        // var x=2; is detected as
        // [{Identifier var}, {AssignmentExpression x=2}]
        // eslint-disable-next-line @stylistic/max-len -- Long
        // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient
        i += 1;
      }
      const expr = ast.body[i];
      last = SafeEval.evalAst(expr, subs);
    }
    return last;
  },
  evalConditionalExpression(ast, subs) {
    if (SafeEval.evalAst(ast.test, subs)) {
      return SafeEval.evalAst(ast.consequent, subs);
    }
    return SafeEval.evalAst(ast.alternate, subs);
  },
  evalIdentifier(ast, subs) {
    if (Object.hasOwn(subs, ast.name)) {
      return subs[ast.name];
    }
    throw ReferenceError(`${ast.name} is not defined`);
  },
  evalLiteral(ast) {
    return ast.value;
  },
  evalMemberExpression(ast, subs) {
    const prop = String(
    // NOTE: `String(value)` throws error when
    // value has overwritten the toString method to return non-string
    // i.e. `value = {toString: () => []}`
    ast.computed ? SafeEval.evalAst(ast.property) // `object[property]`
    : ast.property.name // `object.property` property is Identifier
    );
    const obj = SafeEval.evalAst(ast.object, subs);
    if (obj === undefined || obj === null) {
      throw TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);
    }
    if (!Object.hasOwn(obj, prop) && BLOCKED_PROTO_PROPERTIES.has(prop)) {
      throw TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);
    }
    const result = obj[prop];
    if (typeof result === 'function') {
      return result.bind(obj); // arrow functions aren't affected by bind.
    }
    return result;
  },
  evalUnaryExpression(ast, subs) {
    const result = {
      '-': a => -SafeEval.evalAst(a, subs),
      '!': a => !SafeEval.evalAst(a, subs),
      '~': a => ~SafeEval.evalAst(a, subs),
      // eslint-disable-next-line no-implicit-coercion -- API
      '+': a => +SafeEval.evalAst(a, subs),
      typeof: a => typeof SafeEval.evalAst(a, subs)
    }[ast.operator](ast.argument);
    return result;
  },
  evalArrayExpression(ast, subs) {
    return ast.elements.map(el => SafeEval.evalAst(el, subs));
  },
  evalCallExpression(ast, subs) {
    const args = ast.arguments.map(arg => SafeEval.evalAst(arg, subs));
    const func = SafeEval.evalAst(ast.callee, subs);
    // if (func === Function) {
    //     throw new Error('Function constructor is disabled');
    // }
    return func(...args);
  },
  evalAssignmentExpression(ast, subs) {
    if (ast.left.type !== 'Identifier') {
      throw SyntaxError('Invalid left-hand side in assignment');
    }
    const id = ast.left.name;
    const value = SafeEval.evalAst(ast.right, subs);
    subs[id] = value;
    return subs[id];
  }
};

/**
 * A replacement for NodeJS' VM.Script which is also {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP | Content Security Policy} friendly.
 */
class SafeScript {
  /**
   * @param {string} expr Expression to evaluate
   */
  constructor(expr) {
    this.code = expr;
    this.ast = jsep(this.code);
  }

  /**
   * @param {object} context Object whose items will be added
   *   to evaluation
   * @returns {EvaluatedResult} Result of evaluated code
   */
  runInNewContext(context) {
    // `Object.create(null)` creates a prototypeless object
    const keyMap = Object.assign(Object.create(null), context);
    return SafeEval.evalAst(this.ast, keyMap);
  }
}

/* eslint-disable camelcase -- Convenient for escaping */


/**
 * @typedef {null|boolean|number|string|object|GenericArray} JSONObject
 */

/**
 * @typedef {any} AnyItem
 */

/**
 * @typedef {any} AnyResult
 */

/**
 * Copies array and then pushes item into it.
 * @param {GenericArray} arr Array to copy and into which to push
 * @param {AnyItem} item Array item to add (to end)
 * @returns {GenericArray} Copy of the original array
 */
function push(arr, item) {
  arr = arr.slice();
  arr.push(item);
  return arr;
}
/**
 * Copies array and then unshifts item into it.
 * @param {AnyItem} item Array item to add (to beginning)
 * @param {GenericArray} arr Array to copy and into which to unshift
 * @returns {GenericArray} Copy of the original array
 */
function unshift(item, arr) {
  arr = arr.slice();
  arr.unshift(item);
  return arr;
}

/**
 * Caught when JSONPath is used without `new` but rethrown if with `new`
 * @extends Error
 */
class NewError extends Error {
  /**
   * @param {AnyResult} value The evaluated scalar value
   */
  constructor(value) {
    super('JSONPath should not be called with "new" (it prevents return ' + 'of (unwrapped) scalar values)');
    this.avoidNew = true;
    this.value = value;
    this.name = 'NewError';
  }
}

/**
* @typedef {object} ReturnObject
* @property {string} path
* @property {JSONObject} value
* @property {object|GenericArray} parent
* @property {string} parentProperty
*/

/**
* @callback JSONPathCallback
* @param {string|object} preferredOutput
* @param {"value"|"property"} type
* @param {ReturnObject} fullRetObj
* @returns {void}
*/

/**
* @callback OtherTypeCallback
* @param {JSONObject} val
* @param {string} path
* @param {object|GenericArray} parent
* @param {string} parentPropName
* @returns {boolean}
*/

/**
 * @typedef {any} ContextItem
 */

/**
 * @typedef {any} EvaluatedResult
 */

/**
* @callback EvalCallback
* @param {string} code
* @param {ContextItem} context
* @returns {EvaluatedResult}
*/

/**
 * @typedef {typeof SafeScript} EvalClass
 */

/**
 * @typedef {object} JSONPathOptions
 * @property {JSON} json
 * @property {string|string[]} path
 * @property {"value"|"path"|"pointer"|"parent"|"parentProperty"|
 *   "all"} [resultType="value"]
 * @property {boolean} [flatten=false]
 * @property {boolean} [wrap=true]
 * @property {object} [sandbox={}]
 * @property {EvalCallback|EvalClass|'safe'|'native'|
 *   boolean} [eval = 'safe']
 * @property {object|GenericArray|null} [parent=null]
 * @property {string|null} [parentProperty=null]
 * @property {JSONPathCallback} [callback]
 * @property {OtherTypeCallback} [otherTypeCallback] Defaults to
 *   function which throws on encountering `@other`
 * @property {boolean} [autostart=true]
 */

/**
 * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`
 * @param {string} [expr] JSON path to evaluate
 * @param {JSON} [obj] JSON object to evaluate against
 * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload
 *     per `resultType`, 2) `"value"|"property"`, 3) Full returned object with
 *     all payloads
 * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end
 *   of one's query, this will be invoked with the value of the item, its
 *   path, its parent, and its parent's property name, and it should return
 *   a boolean indicating whether the supplied value belongs to the "other"
 *   type or not (or it may handle transformations and return `false`).
 * @returns {JSONPath}
 * @class
 */
function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
  // eslint-disable-next-line no-restricted-syntax -- Allow for pseudo-class
  if (!(this instanceof JSONPath)) {
    try {
      return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
    } catch (e) {
      if (!e.avoidNew) {
        throw e;
      }
      return e.value;
    }
  }
  if (typeof opts === 'string') {
    otherTypeCallback = callback;
    callback = obj;
    obj = expr;
    expr = opts;
    opts = null;
  }
  const optObj = opts && typeof opts === 'object';
  opts = opts || {};
  this.json = opts.json || obj;
  this.path = opts.path || expr;
  this.resultType = opts.resultType || 'value';
  this.flatten = opts.flatten || false;
  this.wrap = Object.hasOwn(opts, 'wrap') ? opts.wrap : true;
  this.sandbox = opts.sandbox || {};
  this.eval = opts.eval === undefined ? 'safe' : opts.eval;
  this.ignoreEvalErrors = typeof opts.ignoreEvalErrors === 'undefined' ? false : opts.ignoreEvalErrors;
  this.parent = opts.parent || null;
  this.parentProperty = opts.parentProperty || null;
  this.callback = opts.callback || callback || null;
  this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {
    throw new TypeError('You must supply an otherTypeCallback callback option ' + 'with the @other() operator.');
  };
  if (opts.autostart !== false) {
    const args = {
      path: optObj ? opts.path : expr
    };
    if (!optObj) {
      args.json = obj;
    } else if ('json' in opts) {
      args.json = opts.json;
    }
    const ret = this.evaluate(args);
    if (!ret || typeof ret !== 'object') {
      throw new NewError(ret);
    }
    return ret;
  }
}

// PUBLIC METHODS
JSONPath.prototype.evaluate = function (expr, json, callback, otherTypeCallback) {
  let currParent = this.parent,
    currParentProperty = this.parentProperty;
  let {
    flatten,
    wrap
  } = this;
  this.currResultType = this.resultType;
  this.currEval = this.eval;
  this.currSandbox = this.sandbox;
  callback = callback || this.callback;
  this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;
  json = json || this.json;
  expr = expr || this.path;
  if (expr && typeof expr === 'object' && !Array.isArray(expr)) {
    if (!expr.path && expr.path !== '') {
      throw new TypeError('You must supply a "path" property when providing an object ' + 'argument to JSONPath.evaluate().');
    }
    if (!Object.hasOwn(expr, 'json')) {
      throw new TypeError('You must supply a "json" property when providing an object ' + 'argument to JSONPath.evaluate().');
    }
    ({
      json
    } = expr);
    flatten = Object.hasOwn(expr, 'flatten') ? expr.flatten : flatten;
    this.currResultType = Object.hasOwn(expr, 'resultType') ? expr.resultType : this.currResultType;
    this.currSandbox = Object.hasOwn(expr, 'sandbox') ? expr.sandbox : this.currSandbox;
    wrap = Object.hasOwn(expr, 'wrap') ? expr.wrap : wrap;
    this.currEval = Object.hasOwn(expr, 'eval') ? expr.eval : this.currEval;
    callback = Object.hasOwn(expr, 'callback') ? expr.callback : callback;
    this.currOtherTypeCallback = Object.hasOwn(expr, 'otherTypeCallback') ? expr.otherTypeCallback : this.currOtherTypeCallback;
    currParent = Object.hasOwn(expr, 'parent') ? expr.parent : currParent;
    currParentProperty = Object.hasOwn(expr, 'parentProperty') ? expr.parentProperty : currParentProperty;
    expr = expr.path;
  }
  currParent = currParent || null;
  currParentProperty = currParentProperty || null;
  if (Array.isArray(expr)) {
    expr = JSONPath.toPathString(expr);
  }
  if (!expr && expr !== '' || !json) {
    return undefined;
  }
  const exprList = JSONPath.toPathArray(expr);
  if (exprList[0] === '$' && exprList.length > 1) {
    exprList.shift();
  }
  this._hasParentSelector = null;
  const result = this._trace(exprList, json, ['$'], currParent, currParentProperty, callback).filter(function (ea) {
    return ea && !ea.isParentSelector;
  });
  if (!result.length) {
    return wrap ? [] : undefined;
  }
  if (!wrap && result.length === 1 && !result[0].hasArrExpr) {
    return this._getPreferredOutput(result[0]);
  }
  return result.reduce((rslt, ea) => {
    const valOrPath = this._getPreferredOutput(ea);
    if (flatten && Array.isArray(valOrPath)) {
      rslt = rslt.concat(valOrPath);
    } else {
      rslt.push(valOrPath);
    }
    return rslt;
  }, []);
};

// PRIVATE METHODS

JSONPath.prototype._getPreferredOutput = function (ea) {
  const resultType = this.currResultType;
  switch (resultType) {
    case 'all':
      {
        const path = Array.isArray(ea.path) ? ea.path : JSONPath.toPathArray(ea.path);
        ea.pointer = JSONPath.toPointer(path);
        ea.path = typeof ea.path === 'string' ? ea.path : JSONPath.toPathString(ea.path);
        return ea;
      }
    case 'value':
    case 'parent':
    case 'parentProperty':
      return ea[resultType];
    case 'path':
      return JSONPath.toPathString(ea[resultType]);
    case 'pointer':
      return JSONPath.toPointer(ea.path);
    default:
      throw new TypeError('Unknown result type');
  }
};
JSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {
  if (callback) {
    const preferredOutput = this._getPreferredOutput(fullRetObj);
    fullRetObj.path = typeof fullRetObj.path === 'string' ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path);
    // eslint-disable-next-line n/callback-return -- No need to return
    callback(preferredOutput, type, fullRetObj);
  }
};

/**
 *
 * @param {string} expr
 * @param {JSONObject} val
 * @param {string} path
 * @param {object|GenericArray} parent
 * @param {string} parentPropName
 * @param {JSONPathCallback} callback
 * @param {boolean} hasArrExpr
 * @param {boolean} literalPriority
 * @returns {ReturnObject|ReturnObject[]}
 */
JSONPath.prototype._trace = function (expr, val, path, parent, parentPropName, callback, hasArrExpr, literalPriority) {
  // No expr to follow? return path and value as the result of
  //  this trace branch
  let retObj;
  if (!expr.length) {
    retObj = {
      path,
      value: val,
      parent,
      parentProperty: parentPropName,
      hasArrExpr
    };
    this._handleCallback(retObj, callback, 'value');
    return retObj;
  }
  const loc = expr[0],
    x = expr.slice(1);

  // We need to gather the return value of recursive trace calls in order to
  // do the parent sel computation.
  const ret = [];
  /**
   *
   * @param {ReturnObject|ReturnObject[]} elems
   * @returns {void}
   */
  function addRet(elems) {
    if (Array.isArray(elems)) {
      // This was causing excessive stack size in Node (with or
      //  without Babel) against our performance test:
      //  `ret.push(...elems);`
      elems.forEach(t => {
        ret.push(t);
      });
    } else {
      ret.push(elems);
    }
  }
  if ((typeof loc !== 'string' || literalPriority) && val && Object.hasOwn(val, loc)) {
    // simple case--directly follow property
    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr));
    // eslint-disable-next-line unicorn/prefer-switch -- Part of larger `if`
  } else if (loc === '*') {
    // all child properties
    this._walk(val, m => {
      addRet(this._trace(x, val[m], push(path, m), val, m, callback, true, true));
    });
  } else if (loc === '..') {
    // all descendent parent properties
    // Check remaining expression with val's immediate children
    addRet(this._trace(x, val, path, parent, parentPropName, callback, hasArrExpr));
    this._walk(val, m => {
      // We don't join m and x here because we only want parents,
      //   not scalar values
      if (typeof val[m] === 'object') {
        // Keep going with recursive descent on val's
        //   object children
        addRet(this._trace(expr.slice(), val[m], push(path, m), val, m, callback, true));
      }
    });
    // The parent sel computation is handled in the frame above using the
    // ancestor object of val
  } else if (loc === '^') {
    // This is not a final endpoint, so we do not invoke the callback here
    this._hasParentSelector = true;
    return {
      path: path.slice(0, -1),
      expr: x,
      isParentSelector: true
    };
  } else if (loc === '~') {
    // property name
    retObj = {
      path: push(path, loc),
      value: parentPropName,
      parent,
      parentProperty: null
    };
    this._handleCallback(retObj, callback, 'property');
    return retObj;
  } else if (loc === '$') {
    // root only
    addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));
  } else if (/^(-?\d*):(-?\d*):?(\d*)$/u.test(loc)) {
    // [start:end:step]  Python slice syntax
    addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));
  } else if (loc.indexOf('?(') === 0) {
    // [?(expr)] (filtering)
    if (this.currEval === false) {
      throw new Error('Eval [?(expr)] prevented in JSONPath expression.');
    }
    const safeLoc = loc.replace(/^\?\((.*?)\)$/u, '$1');
    // check for a nested filter expression
    const nested = /@.?([^?]*)[['](\??\(.*?\))(?!.\)\])[\]']/gu.exec(safeLoc);
    if (nested) {
      // find if there are matches in the nested expression
      // add them to the result set if there is at least one match
      this._walk(val, m => {
        const npath = [nested[2]];
        const nvalue = nested[1] ? val[m][nested[1]] : val[m];
        const filterResults = this._trace(npath, nvalue, path, parent, parentPropName, callback, true);
        if (filterResults.length > 0) {
          addRet(this._trace(x, val[m], push(path, m), val, m, callback, true));
        }
      });
    } else {
      this._walk(val, m => {
        if (this._eval(safeLoc, val[m], m, path, parent, parentPropName)) {
          addRet(this._trace(x, val[m], push(path, m), val, m, callback, true));
        }
      });
    }
  } else if (loc[0] === '(') {
    // [(expr)] (dynamic property/index)
    if (this.currEval === false) {
      throw new Error('Eval [(expr)] prevented in JSONPath expression.');
    }
    // As this will resolve to a property name (but we don't know it
    //  yet), property and parent information is relative to the
    //  parent of the property to which this expression will resolve
    addRet(this._trace(unshift(this._eval(loc, val, path.at(-1), path.slice(0, -1), parent, parentPropName), x), val, path, parent, parentPropName, callback, hasArrExpr));
  } else if (loc[0] === '@') {
    // value type: @boolean(), etc.
    let addType = false;
    const valueType = loc.slice(1, -2);
    switch (valueType) {
      case 'scalar':
        if (!val || !['object', 'function'].includes(typeof val)) {
          addType = true;
        }
        break;
      case 'boolean':
      case 'string':
      case 'undefined':
      case 'function':
        if (typeof val === valueType) {
          addType = true;
        }
        break;
      case 'integer':
        if (Number.isFinite(val) && !(val % 1)) {
          addType = true;
        }
        break;
      case 'number':
        if (Number.isFinite(val)) {
          addType = true;
        }
        break;
      case 'nonFinite':
        if (typeof val === 'number' && !Number.isFinite(val)) {
          addType = true;
        }
        break;
      case 'object':
        if (val && typeof val === valueType) {
          addType = true;
        }
        break;
      case 'array':
        if (Array.isArray(val)) {
          addType = true;
        }
        break;
      case 'other':
        addType = this.currOtherTypeCallback(val, path, parent, parentPropName);
        break;
      case 'null':
        if (val === null) {
          addType = true;
        }
        break;
      /* c8 ignore next 2 */
      default:
        throw new TypeError('Unknown value type ' + valueType);
    }
    if (addType) {
      retObj = {
        path,
        value: val,
        parent,
        parentProperty: parentPropName
      };
      this._handleCallback(retObj, callback, 'value');
      return retObj;
    }
    // `-escaped property
  } else if (loc[0] === '`' && val && Object.hasOwn(val, loc.slice(1))) {
    const locProp = loc.slice(1);
    addRet(this._trace(x, val[locProp], push(path, locProp), val, locProp, callback, hasArrExpr, true));
  } else if (loc.includes(',')) {
    // [name1,name2,...]
    const parts = loc.split(',');
    for (const part of parts) {
      addRet(this._trace(unshift(part, x), val, path, parent, parentPropName, callback, true));
    }
    // simple case--directly follow property
  } else if (!literalPriority && val && Object.hasOwn(val, loc)) {
    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr, true));
  }

  // We check the resulting values for parent selections. For parent
  // selections we discard the value object and continue the trace with the
  // current val object
  if (this._hasParentSelector) {
    for (let t = 0; t < ret.length; t++) {
      const rett = ret[t];
      if (rett && rett.isParentSelector) {
        const tmp = this._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);
        if (Array.isArray(tmp)) {
          ret[t] = tmp[0];
          const tl = tmp.length;
          for (let tt = 1; tt < tl; tt++) {
            // eslint-disable-next-line @stylistic/max-len -- Long
            // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient
            t++;
            ret.splice(t, 0, tmp[tt]);
          }
        } else {
          ret[t] = tmp;
        }
      }
    }
  }
  return ret;
};
JSONPath.prototype._walk = function (val, f) {
  if (Array.isArray(val)) {
    const n = val.length;
    for (let i = 0; i < n; i++) {
      f(i);
    }
  } else if (val && typeof val === 'object') {
    Object.keys(val).forEach(m => {
      f(m);
    });
  }
};
JSONPath.prototype._slice = function (loc, expr, val, path, parent, parentPropName, callback) {
  if (!Array.isArray(val)) {
    return undefined;
  }
  const len = val.length,
    parts = loc.split(':'),
    step = parts[2] && Number.parseInt(parts[2]) || 1;
  let start = parts[0] && Number.parseInt(parts[0]) || 0,
    end = parts[1] && Number.parseInt(parts[1]) || len;
  start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);
  end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);
  const ret = [];
  for (let i = start; i < end; i += step) {
    const tmp = this._trace(unshift(i, expr), val, path, parent, parentPropName, callback, true);
    // Should only be possible to be an array here since first part of
    //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,
    //     nor begin with `@` (as could return objects)
    // This was causing excessive stack size in Node (with or
    //  without Babel) against our performance test: `ret.push(...tmp);`
    tmp.forEach(t => {
      ret.push(t);
    });
  }
  return ret;
};
JSONPath.prototype._eval = function (code, _v, _vname, path, parent, parentPropName) {
  this.currSandbox._$_parentProperty = parentPropName;
  this.currSandbox._$_parent = parent;
  this.currSandbox._$_property = _vname;
  this.currSandbox._$_root = this.json;
  this.currSandbox._$_v = _v;
  const containsPath = code.includes('@path');
  if (containsPath) {
    this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));
  }
  const scriptCacheKey = this.currEval + 'Script:' + code;
  if (!JSONPath.cache[scriptCacheKey]) {
    let script = code.replaceAll('@parentProperty', '_$_parentProperty').replaceAll('@parent', '_$_parent').replaceAll('@property', '_$_property').replaceAll('@root', '_$_root').replaceAll(/@([.\s)[])/gu, '_$_v$1');
    if (containsPath) {
      script = script.replaceAll('@path', '_$_path');
    }
    if (this.currEval === 'safe' || this.currEval === true || this.currEval === undefined) {
      JSONPath.cache[scriptCacheKey] = new this.safeVm.Script(script);
    } else if (this.currEval === 'native') {
      JSONPath.cache[scriptCacheKey] = new this.vm.Script(script);
    } else if (typeof this.currEval === 'function' && this.currEval.prototype && Object.hasOwn(this.currEval.prototype, 'runInNewContext')) {
      const CurrEval = this.currEval;
      JSONPath.cache[scriptCacheKey] = new CurrEval(script);
    } else if (typeof this.currEval === 'function') {
      JSONPath.cache[scriptCacheKey] = {
        runInNewContext: context => this.currEval(script, context)
      };
    } else {
      throw new TypeError(`Unknown "eval" property "${this.currEval}"`);
    }
  }
  try {
    return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);
  } catch (e) {
    if (this.ignoreEvalErrors) {
      return false;
    }
    throw new Error('jsonPath: ' + e.message + ': ' + code);
  }
};

// PUBLIC CLASS PROPERTIES AND METHODS

// Could store the cache object itself
JSONPath.cache = {};

/**
 * @param {string[]} pathArr Array to convert
 * @returns {string} The path string
 */
JSONPath.toPathString = function (pathArr) {
  const x = pathArr,
    n = x.length;
  let p = '$';
  for (let i = 1; i < n; i++) {
    if (!/^(~|\^|@.*?\(\))$/u.test(x[i])) {
      p += /^[0-9*]+$/u.test(x[i]) ? '[' + x[i] + ']' : "['" + x[i] + "']";
    }
  }
  return p;
};

/**
 * @param {string} pointer JSON Path
 * @returns {string} JSON Pointer
 */
JSONPath.toPointer = function (pointer) {
  const x = pointer,
    n = x.length;
  let p = '';
  for (let i = 1; i < n; i++) {
    if (!/^(~|\^|@.*?\(\))$/u.test(x[i])) {
      p += '/' + x[i].toString().replaceAll('~', '~0').replaceAll('/', '~1');
    }
  }
  return p;
};

/**
 * @param {string} expr Expression to convert
 * @returns {string[]}
 */
JSONPath.toPathArray = function (expr) {
  const {
    cache
  } = JSONPath;
  if (cache[expr]) {
    return cache[expr].concat();
  }
  const subx = [];
  const normalized = expr
  // Properties
  .replaceAll(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/gu, ';$&;')
  // Parenthetical evaluations (filtering and otherwise), directly
  //   within brackets or single quotes
  .replaceAll(/[['](\??\(.*?\))[\]'](?!.\])/gu, function ($0, $1) {
    return '[#' + (subx.push($1) - 1) + ']';
  })
  // Escape periods and tildes within properties
  .replaceAll(/\[['"]([^'\]]*)['"]\]/gu, function ($0, prop) {
    return "['" + prop.replaceAll('.', '%@%').replaceAll('~', '%%@@%%') + "']";
  })
  // Properties operator
  .replaceAll('~', ';~;')
  // Split by property boundaries
  .replaceAll(/['"]?\.['"]?(?![^[]*\])|\[['"]?/gu, ';')
  // Reinsert periods within properties
  .replaceAll('%@%', '.')
  // Reinsert tildes within properties
  .replaceAll('%%@@%%', '~')
  // Parent
  .replaceAll(/(?:;)?(\^+)(?:;)?/gu, function ($0, ups) {
    return ';' + ups.split('').join(';') + ';';
  })
  // Descendents
  .replaceAll(/;;;|;;/gu, ';..;')
  // Remove trailing
  .replaceAll(/;$|'?\]|'$/gu, '');
  const exprList = normalized.split(';').map(function (exp) {
    const match = exp.match(/#(\d+)/u);
    return !match || !match[1] ? exp : subx[match[1]];
  });
  cache[expr] = exprList;
  return cache[expr].concat();
};
JSONPath.prototype.safeVm = {
  Script: SafeScript
};

JSONPath.prototype.vm = vm__WEBPACK_IMPORTED_MODULE_0__;




/***/ }),

/***/ "./lib/platform-bible-utils/dist/index.js":
/*!************************************************!*\
  !*** ./lib/platform-bible-utils/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncVariable: () => (/* binding */ Pu),
/* harmony export */   CHAPTER_TYPE: () => (/* binding */ Mt),
/* harmony export */   Collator: () => (/* binding */ Lu),
/* harmony export */   DateTimeFormat: () => (/* binding */ Wr),
/* harmony export */   DocumentCombiner: () => (/* binding */ tn),
/* harmony export */   EventRollingTimeCounter: () => (/* binding */ zu),
/* harmony export */   FIRST_SCR_BOOK_NUM: () => (/* binding */ Rn),
/* harmony export */   FIRST_SCR_CHAPTER_NUM: () => (/* binding */ Pn),
/* harmony export */   FIRST_SCR_VERSE_NUM: () => (/* binding */ Ln),
/* harmony export */   LAST_SCR_BOOK_NUM: () => (/* binding */ _n),
/* harmony export */   Mutex: () => (/* binding */ nn),
/* harmony export */   MutexMap: () => (/* binding */ Hu),
/* harmony export */   NonValidatingDocumentCombiner: () => (/* binding */ Ju),
/* harmony export */   NumberFormat: () => (/* binding */ un),
/* harmony export */   PLATFORM_ERROR_VERSION: () => (/* binding */ It),
/* harmony export */   PlatformEventEmitter: () => (/* binding */ Kr),
/* harmony export */   PromiseChainingMap: () => (/* binding */ Xu),
/* harmony export */   UnsubscriberAsyncList: () => (/* binding */ Yu),
/* harmony export */   UsjReaderWriter: () => (/* binding */ Ee),
/* harmony export */   VERSE_TYPE: () => (/* binding */ Bt),
/* harmony export */   aggregateUnsubscriberAsyncs: () => (/* binding */ Ni),
/* harmony export */   aggregateUnsubscribers: () => (/* binding */ Ai),
/* harmony export */   areUsjContentsEqualExceptWhitespace: () => (/* binding */ vi),
/* harmony export */   at: () => (/* binding */ xt),
/* harmony export */   charAt: () => (/* binding */ Et),
/* harmony export */   codePointAt: () => (/* binding */ Zu),
/* harmony export */   compareScrRefs: () => (/* binding */ Ei),
/* harmony export */   createSyncProxyForAsyncObject: () => (/* binding */ $u),
/* harmony export */   debounce: () => (/* binding */ ku),
/* harmony export */   deepClone: () => (/* binding */ wt),
/* harmony export */   deepEqual: () => (/* binding */ Cu),
/* harmony export */   defaultScrRef: () => (/* binding */ li),
/* harmony export */   deserialize: () => (/* binding */ Tu),
/* harmony export */   endsWith: () => (/* binding */ Tn),
/* harmony export */   ensureArray: () => (/* binding */ qr),
/* harmony export */   escapeStringRegexp: () => (/* binding */ oi),
/* harmony export */   formatBytes: () => (/* binding */ Ti),
/* harmony export */   formatReplacementString: () => (/* binding */ ei),
/* harmony export */   formatReplacementStringToArray: () => (/* binding */ Sn),
/* harmony export */   formatScrRef: () => (/* binding */ Di),
/* harmony export */   formatTimeSpan: () => (/* binding */ wi),
/* harmony export */   getAllObjectFunctionNames: () => (/* binding */ ju),
/* harmony export */   getChaptersForBook: () => (/* binding */ Fn),
/* harmony export */   getCurrentLocale: () => (/* binding */ yi),
/* harmony export */   getErrorMessage: () => (/* binding */ Or),
/* harmony export */   getLocalizeKeyForScrollGroupId: () => (/* binding */ kn),
/* harmony export */   getLocalizeKeysForScrollGroupIds: () => (/* binding */ gi),
/* harmony export */   getLocalizedIdFromBookNumber: () => (/* binding */ di),
/* harmony export */   groupBy: () => (/* binding */ qu),
/* harmony export */   htmlEncode: () => (/* binding */ Ci),
/* harmony export */   includes: () => (/* binding */ On),
/* harmony export */   indexOf: () => (/* binding */ St),
/* harmony export */   isErrorMessageAboutParatextBlockingInternetAccess: () => (/* binding */ Vu),
/* harmony export */   isErrorMessageAboutRegistryAuthFailure: () => (/* binding */ Gu),
/* harmony export */   isLocalizeKey: () => (/* binding */ ii),
/* harmony export */   isPlatformError: () => (/* binding */ Ku),
/* harmony export */   isSerializable: () => (/* binding */ bi),
/* harmony export */   isString: () => (/* binding */ Me),
/* harmony export */   isSubset: () => (/* binding */ yu),
/* harmony export */   isWhiteSpace: () => (/* binding */ mt),
/* harmony export */   lastIndexOf: () => (/* binding */ In),
/* harmony export */   localizedStringsDocumentSchema: () => (/* binding */ xu),
/* harmony export */   menuDocumentSchema: () => (/* binding */ Mu),
/* harmony export */   newGuid: () => (/* binding */ Fu),
/* harmony export */   newPlatformError: () => (/* binding */ Wu),
/* harmony export */   normalize: () => (/* binding */ ti),
/* harmony export */   normalizeScriptureSpaces: () => (/* binding */ Er),
/* harmony export */   offsetBook: () => (/* binding */ fi),
/* harmony export */   offsetChapter: () => (/* binding */ pi),
/* harmony export */   offsetVerse: () => (/* binding */ hi),
/* harmony export */   ordinalCompare: () => (/* binding */ ri),
/* harmony export */   padEnd: () => (/* binding */ ni),
/* harmony export */   padStart: () => (/* binding */ ui),
/* harmony export */   projectSettingsDocumentSchema: () => (/* binding */ Ou),
/* harmony export */   scrRefToBBBCCC: () => (/* binding */ mi),
/* harmony export */   scrRefToBBBCCCVVV: () => (/* binding */ dr),
/* harmony export */   serialize: () => (/* binding */ Sr),
/* harmony export */   settingsDocumentSchema: () => (/* binding */ Iu),
/* harmony export */   slice: () => (/* binding */ pr),
/* harmony export */   split: () => (/* binding */ hr),
/* harmony export */   startsWith: () => (/* binding */ Ur),
/* harmony export */   stringLength: () => (/* binding */ ce),
/* harmony export */   substring: () => (/* binding */ ut),
/* harmony export */   toArray: () => (/* binding */ xn),
/* harmony export */   toKebabCase: () => (/* binding */ ci),
/* harmony export */   transformAndEnsureRegExpArray: () => (/* binding */ si),
/* harmony export */   transformAndEnsureRegExpRegExpArray: () => (/* binding */ ai),
/* harmony export */   wait: () => (/* binding */ en),
/* harmony export */   waitForDuration: () => (/* binding */ Uu)
/* harmony export */ });
/* harmony import */ var async_mutex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! async-mutex */ "./node_modules/async-mutex/index.mjs");
/* harmony import */ var jsonpath_plus__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsonpath-plus */ "./node_modules/jsonpath-plus/dist/index-node-esm.js");
var Jr = Object.defineProperty;
var Xr = (t, e, n) => e in t ? Jr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var W = (t, e, n) => Xr(t, typeof e != "symbol" ? e + "" : e, n);


class Pu {
    /**
     * Creates an instance of the class
     *
     * @param variableName Name to use when logging about this variable
     * @param rejectIfNotSettledWithinMS Milliseconds to wait before verifying if the promise was
     *   settled (resolved or rejected); will reject if it has not settled by that time. Use -1 if you
     *   do not want a timeout at all. Defaults to 10000 ms
     */
    constructor(e, n = 1e4) {
        W(this, "variableName");
        W(this, "promiseToValue");
        W(this, "resolver");
        W(this, "rejecter");
        this.variableName = e, this.promiseToValue = new Promise((i, o) => {
            this.resolver = i, this.rejecter = o;
        }), n > 0 && setTimeout(() => {
            this.rejecter && (this.rejecter(`Timeout reached when waiting for ${this.variableName} to settle`), this.complete());
        }, n), Object.seal(this);
    }
    /**
     * Get this variable's promise to a value. This always returns the same promise even after the
     * value has been resolved or rejected.
     *
     * @returns The promise for the value to be set
     */
    get promise() {
        return this.promiseToValue;
    }
    /**
     * A simple way to see if this variable's promise was resolved or rejected already
     *
     * @returns Whether the variable was already resolved or rejected
     */
    get hasSettled() {
        return Object.isFrozen(this);
    }
    /**
     * Resolve this variable's promise to the given value
     *
     * @param value This variable's promise will resolve to this value
     * @param throwIfAlreadySettled Determines whether to throw if the variable was already resolved
     *   or rejected. Defaults to `false`
     */
    resolveToValue(e, n = !1) {
        if (this.resolver)
            console.debug(`${this.variableName} is being resolved now`), this.resolver(e), this.complete();
        else {
            if (n)
                throw Error(`${this.variableName} was already settled`);
            console.debug(`Ignoring subsequent resolution of ${this.variableName}`);
        }
    }
    /**
     * Reject this variable's promise for the value with the given reason
     *
     * @param reason This variable's promise will be rejected with this reason
     * @param throwIfAlreadySettled Determines whether to throw if the variable was already resolved
     *   or rejected. Defaults to `false`
     */
    rejectWithReason(e, n = !1) {
        if (this.rejecter)
            console.debug(`${this.variableName} is being rejected now`), this.rejecter(e), this.complete();
        else {
            if (n)
                throw Error(`${this.variableName} was already settled`);
            console.debug(`Ignoring subsequent rejection of ${this.variableName}`);
        }
    }
    /** Prevent any further updates to this variable */
    complete() {
        this.resolver = void 0, this.rejecter = void 0, Object.freeze(this);
    }
}
class Lu {
    constructor(e, n) {
        W(this, "collator");
        this.collator = new Intl.Collator(e, n);
    }
    /**
     * Compares two strings according to the sort order of this Collator object
     *
     * @param string1 String to compare
     * @param string2 String to compare
     * @returns A number indicating how string1 and string2 compare to each other according to the
     *   sort order of this Collator object. Negative value if string1 comes before string2. Positive
     *   value if string1 comes after string2. 0 if they are considered equal.
     */
    compare(e, n) {
        return this.collator.compare(e, n);
    }
    /**
     * Returns a new object with properties reflecting the locale and collation options computed
     * during initialization of this collator object.
     *
     * @returns ResolvedCollatorOptions object
     */
    resolvedOptions() {
        return this.collator.resolvedOptions();
    }
}
class Wr {
    constructor(e, n) {
        W(this, "dateTimeFormatter");
        this.dateTimeFormatter = new Intl.DateTimeFormat(e, n);
    }
    /**
     * Formats a date according to the locale and formatting option for this DateTimeFormat object
     *
     * @param date The date to format
     * @returns String representing the given date formatted according to the locale and formatting
     *   options of this DateTimeFormat object
     */
    format(e) {
        return this.dateTimeFormatter.format(e);
    }
    /**
     * Formats a date range in the most concise way based on the locales and options provided when
     * instantiating this DateTimeFormat object
     *
     * @param startDate Date object representing start of the date range
     * @param endDate Date object representing the end of the date range
     * @returns String representing the given date range formatted according to the locale and
     *   formatting options of this DateTimeFormat object
     */
    formatRange(e, n) {
        return this.dateTimeFormatter.formatRange(e, n);
    }
    /**
     * Returns an array of locale-specific tokens representing each part of the formatted date range
     * produced by this DateTimeFormat object
     *
     * @param startDate Date object representing start of the date range
     * @param endDate Date object representing the end of the date range
     * @returns Array of DateTimeRangeFormatPart objects
     */
    formatRangeToParts(e, n) {
        return this.dateTimeFormatter.formatRangeToParts(e, n);
    }
    /**
     * Allows locale-aware formatting of strings produced by this DateTimeFormat object
     *
     * @param date The date to format
     * @returns Array of DateTimeFormatPart objects
     */
    formatToParts(e) {
        return this.dateTimeFormatter.formatToParts(e);
    }
    /**
     * Returns a new object with properties reflecting the locale and date and time formatting options
     * computed during initialization of this DateTimeFormat object
     *
     * @returns ResolvedDateTimeFormatOptions object
     */
    resolvedOptions() {
        return this.dateTimeFormatter.resolvedOptions();
    }
}
class Kr {
    constructor() {
        /**
         * Subscribes a function to run when this event is emitted.
         *
         * @param callback Function to run with the event when it is emitted
         * @returns Unsubscriber function to run to stop calling the passed-in function when the event is
         *   emitted
         * @alias event
         */
        W(this, "subscribe", this.event);
        /** All callback functions that will run when this event is emitted. Lazy loaded */
        W(this, "subscriptions");
        /** Event for listeners to subscribe to. Lazy loaded */
        W(this, "lazyEvent");
        /** Whether this emitter has been disposed */
        W(this, "isDisposed", !1);
        /** Disposes of this event, preparing it to release from memory */
        W(this, "dispose", () => this.disposeFn());
        /**
         * Runs the subscriptions for the event
         *
         * @param event Event data to provide to subscribed callbacks
         */
        W(this, "emit", (e) => {
            this.emitFn(e);
        });
    }
    /**
     * Event for listeners to subscribe to. Subscribes a function to run when this event is emitted.
     * Use like `const unsubscriber = event(callback)`
     *
     * @param callback Function to run with the event when it is emitted
     * @returns Unsubscriber function to run to stop calling the passed-in function when the event is
     *   emitted
     */
    get event() {
        return this.assertNotDisposed(), this.lazyEvent || (this.lazyEvent = (e) => {
            if (!e || typeof e != "function")
                throw new Error("Event handler callback must be a function!");
            return this.subscriptions || (this.subscriptions = []), this.subscriptions.push(e), () => {
                if (!this.subscriptions)
                    return !1;
                const n = this.subscriptions.indexOf(e);
                return n < 0 ? !1 : (this.subscriptions.splice(n, 1), !0);
            };
        }), this.lazyEvent;
    }
    /**
     * Function that runs the subscriptions for the event. Added here so children can override emit
     * and still call the base functionality. See NetworkEventEmitter.emit for example
     */
    emitFn(e) {
        this.assertNotDisposed(), [...this.subscriptions ?? []].forEach((i) => i(e));
    }
    /** Check to make sure this emitter is not disposed. Throw if it is */
    assertNotDisposed() {
        if (this.isDisposed)
            throw new Error("Emitter is disposed");
    }
    /**
     * Disposes of this event, preparing it to release from memory. Added here so children can
     * override emit and still call the base functionality.
     */
    disposeFn() {
        return this.assertNotDisposed(), this.isDisposed = !0, this.subscriptions = void 0, this.lazyEvent = void 0, Promise.resolve(!0);
    }
}
function Fu() {
    return "00-0-4-1-000".replace(/[^-]/g, (t) => (
    // @ts-expect-error ts(2363) this works fine
    // eslint-disable-next-line no-bitwise
    ((Math.random() + ~~t) * 65536 >> t).toString(16).padStart(4, "0")));
}
function Me(t) {
    return typeof t == "string" || t instanceof String;
}
function wt(t) {
    return JSON.parse(JSON.stringify(t));
}
function ku(t, e = 300) {
    if (Me(t))
        throw new Error("Tried to debounce a string! Could be XSS");
    let n;
    return (...i) => {
        clearTimeout(n), n = setTimeout(() => t(...i), e);
    };
}
function qu(t, e, n) {
    const i = /* @__PURE__ */ new Map();
    return t.forEach((o) => {
        const a = e(o), h = i.get(a), p = n ? n(o, a) : o;
        h ? h.push(p) : i.set(a, [p]);
    }), i;
}
function Qr(t) {
    return typeof t == "object" && // We're potentially dealing with objects we didn't create, so they might contain `null`
        // eslint-disable-next-line no-null/no-null
        t !== null && "message" in t && // Type assert `error` to check it's `message`.
        // eslint-disable-next-line no-type-assertion/no-type-assertion
        typeof t.message == "string";
}
function Zr(t) {
    if (Qr(t))
        return t;
    try {
        return new Error(JSON.stringify(t));
    }
    catch {
        return new Error(String(t));
    }
}
function Or(t) {
    return Zr(t).message;
}
function en(t) {
    return new Promise((e) => setTimeout(e, t));
}
function Uu(t, e) {
    const n = en(e).then(() => {
    });
    return Promise.any([n, t()]);
}
function ju(t, e = "obj") {
    const n = /* @__PURE__ */ new Set();
    Object.getOwnPropertyNames(t).forEach((o) => {
        try {
            typeof t[o] == "function" && n.add(o);
        }
        catch {
        }
    });
    let i = Object.getPrototypeOf(t);
    for (; i && Object.getPrototypeOf(i);)
        Object.getOwnPropertyNames(i).forEach((o) => {
            try {
                typeof t[o] == "function" && n.add(o);
            }
            catch {
            }
        }), i = Object.getPrototypeOf(i);
    return n;
}
function $u(t, e = {}) {
    return new Proxy(e, {
        get(n, i) {
            return i in n ? n[i] : async (...o) => (await t())[i](...o);
        }
    });
}
function Vu(t) {
    const e = "Bug in Paratext caused attempted access to Internet. Request has been blocked.";
    return Me(t) ? t.includes(e) : Or(t).includes(e);
}
function Gu(t) {
    const e = "401 Unauthorized error while getting shared projects.", n = "User registration is not valid. Cannot retrieve resources from DBL.", i = Me(t) ? t : Or(t);
    return i.includes(e) || i.includes(n);
}
class tn {
    /**
     * Create a DocumentCombiner instance
     *
     * @param baseDocument This is the first document that will be used when composing the output
     * @param options Options used by this object when combining documents
     */
    constructor(e, n) {
        W(this, "baseDocument");
        W(this, "contributions", /* @__PURE__ */ new Map());
        W(this, "latestOutput");
        W(this, "options");
        W(this, "onDidRebuildEmitter", new Kr());
        /** Event that emits to announce that the document has been rebuilt and the output has been updated */
        // Need `onDidRebuildEmitter` to be instantiated before this line
        // eslint-disable-next-line @typescript-eslint/member-ordering
        W(this, "onDidRebuild", this.onDidRebuildEmitter.subscribe);
        this.baseDocument = e, this.options = n, this.updateBaseDocument(e);
    }
    /**
     * Update the starting document for composition process
     *
     * @param baseDocument Base JSON document/JS object that all other documents are added to
     * @returns Recalculated output document given the new starting state and existing other documents
     */
    updateBaseDocument(e) {
        return this.validateBaseDocument(e), this.baseDocument = this.options.copyDocuments ? wt(e) : e, this.baseDocument = this.transformBaseDocumentAfterValidation(this.baseDocument), this.rebuild();
    }
    /**
     * Add or update one of the contribution documents for the composition process
     *
     * Note: the order in which contribution documents are added can be considered indeterminate as it
     * depends on the order in which `Map.forEach` iterates over the contributions. However, the order
     * matters when merging two arrays into one. Also, when `options.ignoreDuplicateProperties` is is
     * `true`, the order also matters when adding the same property to an object that is already
     * provided previously. Please let us know if you have trouble because of indeterminate
     * contribution ordering.
     *
     * @param documentName Name of the contributed document to combine
     * @param document Content of the contributed document to combine
     * @returns Recalculated output document given the new or updated contribution and existing other
     *   documents
     */
    addOrUpdateContribution(e, n) {
        this.validateContribution(e, n);
        const i = this.contributions.get(e);
        let o = this.options.copyDocuments && n ? wt(n) : n;
        o = this.transformContributionAfterValidation(e, o), this.contributions.set(e, o);
        try {
            return this.rebuild();
        }
        catch (a) {
            throw i ? this.contributions.set(e, i) : this.contributions.delete(e), new Error(`Error when setting the document named ${e}: ${a}`);
        }
    }
    /**
     * Delete one of the contribution documents for the composition process
     *
     * @param documentName Name of the contributed document to delete
     * @returns Recalculated output document given the remaining other documents
     */
    deleteContribution(e) {
        const n = this.contributions.get(e);
        if (!n)
            throw new Error(`${e} does not exist`);
        this.contributions.delete(e);
        try {
            return this.rebuild();
        }
        catch (i) {
            throw this.contributions.set(e, n), new Error(`Error when deleting the document named ${e}: ${i}`);
        }
    }
    /**
     * Delete all present contribution documents for the composition process and return to the base
     * document
     *
     * @returns Recalculated output document consisting only of the base document
     */
    deleteAllContributions() {
        if (this.contributions.size <= 0)
            return this.latestOutput;
        const e = [...this.contributions.entries()];
        e.forEach(([n]) => this.contributions.delete(n));
        try {
            return this.rebuild();
        }
        catch (n) {
            throw e.forEach(([i, o]) => this.contributions.set(i, o)), new Error(`Error when deleting all contributions: ${n}`);
        }
    }
    /**
     * Run the document composition process given the starting document and all contributions. Throws
     * if the output document fails to validate properly.
     *
     * @returns Recalculated output document given the starting and contributed documents
     */
    rebuild() {
        if (this.contributions.size === 0) {
            let n = wt(this.baseDocument);
            return n = this.transformFinalOutputBeforeValidation(n), this.validateOutput(n), this.latestOutput = n, this.onDidRebuildEmitter.emit(void 0), this.latestOutput;
        }
        let e = this.baseDocument;
        return this.contributions.forEach((n) => {
            e = rn(e, n, this.options.ignoreDuplicateProperties), this.validateOutput(e);
        }), e = this.transformFinalOutputBeforeValidation(e), this.validateOutput(e), this.latestOutput = e, this.onDidRebuildEmitter.emit(void 0), this.latestOutput;
    }
    /**
     * Transform the starting document that is given to the combiner. This transformation occurs after
     * validating the base document and before combining any contributions.
     *
     * WARNING: If you do not create the combiner with option `copyDocuments: true` or clone inside
     * this method, this method will directly modify the `baseDocument` passed in.
     *
     * @param baseDocument Initial input document. Already validated via `validateBaseDocument`
     * @returns Transformed base document
     */
    // We just don't need `this` here. This is basically a no-op function that is available to child
    // classes to override
    // eslint-disable-next-line @typescript-eslint/class-methods-use-this
    transformBaseDocumentAfterValidation(e) {
        return e;
    }
    /**
     * Transform the contributed document associated with `documentName`. This transformation occurs
     * after validating the contributed document and before combining with other documents.
     *
     * WARNING: If you do not create the combiner with option `copyDocuments: true` or clone inside
     * this method, this method will directly modify the contributed `document` passed in.
     *
     * @param documentName Name of the contributed document to combine
     * @param document Content of the contributed document to combine. Already validated via
     *   `validateContribution`
     * @returns Transformed contributed document
     */
    // We just don't need `this` here. This is basically a no-op function that is available to child
    // classes to override
    // eslint-disable-next-line @typescript-eslint/class-methods-use-this
    transformContributionAfterValidation(e, n) {
        return n;
    }
    /**
     * Throw an error if the provided document is not a valid starting document.
     *
     * @param baseDocument Base JSON document/JS object that all other documents are added to
     */
    // no-op intended to be overridden by child classes. Can't be static
    // @ts-expect-error ts(6133) parameter doesn't need to be used but still needs the right name
    // eslint-disable-next-line @typescript-eslint/class-methods-use-this, @typescript-eslint/no-unused-vars
    validateBaseDocument(e) {
    }
    /**
     * Throw an error if the provided document is not a valid contribution document.
     *
     * @param documentName Name of the contributed document to combine
     * @param document Content of the contributed document to combine
     */
    // no-op intended to be overridden by child classes. Can't be static
    // @ts-expect-error ts(6133) parameter doesn't need to be used but still needs the right name
    // eslint-disable-next-line @typescript-eslint/class-methods-use-this, @typescript-eslint/no-unused-vars
    validateContribution(e, n) {
    }
    /**
     * Throw an error if the provided output is not valid.
     *
     * @param output Output document that could potentially be returned to callers
     */
    // no-op intended to be overridden by child classes. Can't be static
    // @ts-expect-error ts(6133) parameter doesn't need to be used but still needs the right name
    // eslint-disable-next-line @typescript-eslint/class-methods-use-this, @typescript-eslint/no-unused-vars
    validateOutput(e) {
    }
    /**
     * Transform the document that is the composition of the base document and all contribution
     * documents. This is the last step that will be run prior to validation via `validateOutput`
     * before `this.latestOutput` is updated to the new output.
     *
     * @param finalOutput Final output document that could potentially be returned to callers. "Final"
     *   means no further contribution documents will be merged.
     */
    // no-op intended to be overridden by child classes. Can't be static
    // eslint-disable-next-line @typescript-eslint/class-methods-use-this
    transformFinalOutputBeforeValidation(e) {
        return e;
    }
}
function Kt(...t) {
    let e = !0;
    return t.forEach((n) => {
        (!n || typeof n != "object" || Array.isArray(n)) && (e = !1);
    }), e;
}
function Qt(...t) {
    let e = !0;
    return t.forEach((n) => {
        (!n || typeof n != "object" || !Array.isArray(n)) && (e = !1);
    }), e;
}
function rn(t, e, n) {
    const i = wt(t);
    return e ? Ir(i, wt(e), n) : i;
}
function Ir(t, e, n) {
    if (!e)
        return t;
    if (Kt(t, e)) {
        const i = t, o = e;
        Object.keys(o).forEach((a) => {
            if (Object.hasOwn(i, a)) {
                if (Kt(i[a], o[a]))
                    i[a] = Ir(
                    // We know these are objects from the `if` check
                    /* eslint-disable no-type-assertion/no-type-assertion */
                    i[a], o[a], n
                    /* eslint-enable no-type-assertion/no-type-assertion */
                    );
                else if (Qt(i[a], o[a]))
                    i[a] = i[a].concat(o[a]);
                else if (!n)
                    throw new Error(`Cannot merge objects: key "${a}" already exists in the target object`);
            }
            else
                i[a] = o[a];
        });
    }
    else
        Qt(t, e) && t.push(...e);
    return t;
}
class zu {
    /**
     * Create a new instance of the InstanceTimeCounter class
     *
     * @param bufferSize - Maximum number of instances to track
     */
    constructor(e) {
        /** The ring buffer to store times */
        W(this, "ringBuffer");
        /** The size of the ring buffer */
        W(this, "bufferSize");
        /** The next location where a time will be written */
        W(this, "writerIndex");
        /** The location where the first time in the buffer will be read */
        W(this, "readerIndex");
        /** The most recent difference in time between the newest and oldest events */
        W(this, "lastTimeDifference");
        /** How many instances in total have been recorded */
        W(this, "totalInstanceCount");
        this.bufferSize = e, this.ringBuffer = new Array(e).fill(0), this.writerIndex = 0, this.readerIndex = 0, this.lastTimeDifference = 0, this.totalInstanceCount = 0;
    }
    /** Get the total number of instances that have been recorded */
    get totalInstances() {
        return this.totalInstanceCount;
    }
    /** Add a new time measurement for an instance of an event */
    recordInstance() {
        this.totalInstanceCount += 1;
        const e = performance.now();
        this.lastTimeDifference = e - this.ringBuffer[this.readerIndex], this.ringBuffer[this.writerIndex] = e, this.writerIndex += 1, this.writerIndex >= this.bufferSize && (this.writerIndex %= this.bufferSize), this.writerIndex === this.readerIndex && (this.readerIndex += 1, this.readerIndex >= this.bufferSize && (this.readerIndex %= this.bufferSize));
    }
    /**
     * Check if the time between the last N events is less than the provided threshold
     *
     * @param minRollingTimeMs - Minimum time that must have passed when the last N events occurred
     * @returns - True if the threshold is violated, false otherwise
     */
    hasViolatedThreshold(e) {
        return this.totalInstanceCount >= this.bufferSize && this.lastTimeDifference < e;
    }
}
class nn extends async_mutex__WEBPACK_IMPORTED_MODULE_0__.Mutex {
}
class Hu {
    constructor() {
        W(this, "mutexesByID", /* @__PURE__ */ new Map());
    }
    get(e) {
        let n = this.mutexesByID.get(e);
        return n || (n = new nn(), this.mutexesByID.set(e, n), n);
    }
}
class Ju extends tn {
    // Making the protected base constructor public
    // eslint-disable-next-line @typescript-eslint/no-useless-constructor
    constructor(e, n) {
        super(e, n);
    }
    get output() {
        return this.latestOutput;
    }
}
class un {
    constructor(e, n) {
        W(this, "numberFormatter");
        this.numberFormatter = new Intl.NumberFormat(e, n);
    }
    /**
     * Formats a number according to the locale and formatting options of this NumberFormat object
     *
     * @param value Number or BigInt to format
     * @returns String representing the given number formatted according to the locale and formatting
     *   options of this NumberFormat object
     */
    format(e) {
        return this.numberFormatter.format(e);
    }
    /**
     * Formats a range of numbers according to the locale and formatting options of this NumberFormat
     * object
     *
     * @param startRange Number or bigint representing the start of the range
     * @param endRange Number or bigint representing the end of the range
     * @returns String representing the given range of numbers formatted according to the locale and
     *   formatting options of this NumberFormat object
     */
    formatRange(e, n) {
        return this.numberFormatter.formatRange(e, n);
    }
    /**
     * Returns an array of objects containing the locale-specific tokens from which it is possible to
     * build custom strings while preserving the locale-specific parts.
     *
     * @param startRange Number or bigint representing start of the range
     * @param endRange Number or bigint representing end of the range
     * @returns Array of NumberRangeFormatPart objects containing the formatted range of numbers in
     *   parts
     */
    formatRangeToParts(e, n) {
        return this.numberFormatter.formatRangeToParts(e, n);
    }
    /**
     * Allows locale-aware formatting of strings produced by this NumberFormat object
     *
     * @param value Number or bigint to format
     * @returns Array of NumberFormatPart objects containing the formatted number in parts
     */
    formatToParts(e) {
        return this.numberFormatter.formatToParts(e);
    }
    /**
     * Returns a new object with properties reflecting the locale and number formatting options
     * computed during initialization of this NumberFormat object
     *
     * @returns ResolvedNumberFormatOptions object
     */
    resolvedOptions() {
        return this.numberFormatter.resolvedOptions();
    }
}
const on = Promise.resolve();
class Xu {
    /**
     * Creates a new PromiseChainingMap
     *
     * @param logger Object with a `warn` method that will be called when a promise rejects. This
     *   defaults to `console`.
     */
    constructor(e = console) {
        W(this, "map", /* @__PURE__ */ new Map());
        W(this, "logger");
        this.logger = e;
    }
    /**
     * Adds a promise function to the map for a given key. If a promise is already running for the
     * key, the new promise will be chained to the existing one. Once all promises for a key have
     * settled, the map will be cleared for that key.
     *
     * @param key Unique key to identify a distinct promise chain
     * @param promiseFunction Function that returns a promise to add to the chain
     */
    addPromiseFunction(e, n) {
        const i = this.map.get(e);
        this.map.set(e, i ? i.then(n) : n()), this.cleanupPromiseChain(e);
    }
    /**
     * Gets the current promise chain for the given key. This is mostly useful for testing. Normally
     * you should just call {@link addPromiseFunction} and let the map handle the rest.
     *
     * @param key Unique key to identify a distinct promise chain
     * @returns The current promise chain for the key
     */
    get(e) {
        return this.map.get(e);
    }
    /**
     * Configures a promise chain to be removed from the map for the given key after all the promises
     * have settled
     *
     * @param key Unique key to identify a distinct promise chain
     */
    cleanupPromiseChain(e) {
        const n = this.map.get(e);
        if (!n)
            return;
        const i = { promise: on }, o = n.catch((a) => this.logger.warn(`Error in promise for ${e}: ${a.message}`)).finally(() => {
            this.map.get(e) === i.promise && this.map.delete(e);
        });
        i.promise = o, this.map.set(e, o);
    }
}
class Yu {
    constructor(e = "Anonymous") {
        W(this, "unsubscribers", /* @__PURE__ */ new Set());
        this.name = e;
    }
    /**
     * Add unsubscribers to the list. Note that duplicates are not added twice.
     *
     * @param unsubscribers - Objects that were returned from a registration process.
     */
    add(...e) {
        e.forEach((n) => {
            "dispose" in n ? this.unsubscribers.add(n.dispose.bind(n)) : this.unsubscribers.add(n);
        });
    }
    /**
     * Run all unsubscribers added to this list and then clear the list.
     *
     * @returns `true` if all unsubscribers succeeded, `false` otherwise.
     */
    async runAllUnsubscribers() {
        const e = [...this.unsubscribers].map((i) => i()), n = await Promise.all(e);
        return this.unsubscribers.clear(), n.every((i, o) => (i || console.error(`UnsubscriberAsyncList ${this.name}: Unsubscriber at index ${o} failed!`), i));
    }
}
const It = 1;
function Wu(t) {
    if (!t)
        return { message: "", platformErrorVersion: It };
    if (Me(t))
        return { message: t, platformErrorVersion: It };
    if (typeof t == "object" && "message" in t && typeof t.message == "string") {
        const e = {
            message: t.message,
            platformErrorVersion: It
        };
        return Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)), Object.defineProperty(e, "message", { enumerable: !0 }), "stack" in e && Object.defineProperty(e, "stack", { enumerable: !0 }), "cause" in e && Object.defineProperty(e, "cause", { enumerable: !0 }), e;
    }
    return { cause: t, message: "", platformErrorVersion: It };
}
function Ku(t) {
    return !!t && typeof t == "object" && "platformErrorVersion" in t;
}
var an = Object.defineProperty, sn = (t, e, n) => e in t ? an(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, z = (t, e, n) => sn(t, typeof e != "symbol" ? e + "" : e, n);
const it = [
    "GEN",
    "EXO",
    "LEV",
    "NUM",
    "DEU",
    "JOS",
    "JDG",
    "RUT",
    "1SA",
    "2SA",
    // 10
    "1KI",
    "2KI",
    "1CH",
    "2CH",
    "EZR",
    "NEH",
    "EST",
    "JOB",
    "PSA",
    "PRO",
    // 20
    "ECC",
    "SNG",
    "ISA",
    "JER",
    "LAM",
    "EZK",
    "DAN",
    "HOS",
    "JOL",
    "AMO",
    // 30
    "OBA",
    "JON",
    "MIC",
    "NAM",
    "HAB",
    "ZEP",
    "HAG",
    "ZEC",
    "MAL",
    "MAT",
    // 40
    "MRK",
    "LUK",
    "JHN",
    "ACT",
    "ROM",
    "1CO",
    "2CO",
    "GAL",
    "EPH",
    "PHP",
    // 50
    "COL",
    "1TH",
    "2TH",
    "1TI",
    "2TI",
    "TIT",
    "PHM",
    "HEB",
    "JAS",
    "1PE",
    // 60
    "2PE",
    "1JN",
    "2JN",
    "3JN",
    "JUD",
    "REV",
    "TOB",
    "JDT",
    "ESG",
    "WIS",
    // 70
    "SIR",
    "BAR",
    "LJE",
    "S3Y",
    "SUS",
    "BEL",
    "1MA",
    "2MA",
    "3MA",
    "4MA",
    // 80
    "1ES",
    "2ES",
    "MAN",
    "PS2",
    "ODA",
    "PSS",
    "JSA",
    // actual variant text for JOS, now in LXA text
    "JDB",
    // actual variant text for JDG, now in LXA text
    "TBS",
    // actual variant text for TOB, now in LXA text
    "SST",
    // actual variant text for SUS, now in LXA text // 90
    "DNT",
    // actual variant text for DAN, now in LXA text
    "BLT",
    // actual variant text for BEL, now in LXA text
    "XXA",
    "XXB",
    "XXC",
    "XXD",
    "XXE",
    "XXF",
    "XXG",
    "FRT",
    // 100
    "BAK",
    "OTH",
    "3ES",
    // Used previously but really should be 2ES
    "EZA",
    // Used to be called 4ES, but not actually in any known project
    "5EZ",
    // Used to be called 5ES, but not actually in any known project
    "6EZ",
    // Used to be called 6ES, but not actually in any known project
    "INT",
    "CNC",
    "GLO",
    "TDX",
    // 110
    "NDX",
    "DAG",
    "PS3",
    "2BA",
    "LBA",
    "JUB",
    "ENO",
    "1MQ",
    "2MQ",
    "3MQ",
    // 120
    "REP",
    "4BA",
    "LAO"
], $t = [
    "XXA",
    "XXB",
    "XXC",
    "XXD",
    "XXE",
    "XXF",
    "XXG",
    "FRT",
    "BAK",
    "OTH",
    "INT",
    "CNC",
    "GLO",
    "TDX",
    "NDX"
], xr = [
    "Genesis",
    "Exodus",
    "Leviticus",
    "Numbers",
    "Deuteronomy",
    "Joshua",
    "Judges",
    "Ruth",
    "1 Samuel",
    "2 Samuel",
    "1 Kings",
    "2 Kings",
    "1 Chronicles",
    "2 Chronicles",
    "Ezra",
    "Nehemiah",
    "Esther (Hebrew)",
    "Job",
    "Psalms",
    "Proverbs",
    "Ecclesiastes",
    "Song of Songs",
    "Isaiah",
    "Jeremiah",
    "Lamentations",
    "Ezekiel",
    "Daniel (Hebrew)",
    "Hosea",
    "Joel",
    "Amos",
    "Obadiah",
    "Jonah",
    "Micah",
    "Nahum",
    "Habakkuk",
    "Zephaniah",
    "Haggai",
    "Zechariah",
    "Malachi",
    "Matthew",
    "Mark",
    "Luke",
    "John",
    "Acts",
    "Romans",
    "1 Corinthians",
    "2 Corinthians",
    "Galatians",
    "Ephesians",
    "Philippians",
    "Colossians",
    "1 Thessalonians",
    "2 Thessalonians",
    "1 Timothy",
    "2 Timothy",
    "Titus",
    "Philemon",
    "Hebrews",
    "James",
    "1 Peter",
    "2 Peter",
    "1 John",
    "2 John",
    "3 John",
    "Jude",
    "Revelation",
    "Tobit",
    "Judith",
    "Esther Greek",
    "Wisdom of Solomon",
    "Sirach (Ecclesiasticus)",
    "Baruch",
    "Letter of Jeremiah",
    "Song of 3 Young Men",
    "Susanna",
    "Bel and the Dragon",
    "1 Maccabees",
    "2 Maccabees",
    "3 Maccabees",
    "4 Maccabees",
    "1 Esdras (Greek)",
    "2 Esdras (Latin)",
    "Prayer of Manasseh",
    "Psalm 151",
    "Odes",
    "Psalms of Solomon",
    // WARNING, if you change the spelling of the *obsolete* tag be sure to update
    // IsObsolete routine
    "Joshua A. *obsolete*",
    "Judges B. *obsolete*",
    "Tobit S. *obsolete*",
    "Susanna Th. *obsolete*",
    "Daniel Th. *obsolete*",
    "Bel Th. *obsolete*",
    "Extra A",
    "Extra B",
    "Extra C",
    "Extra D",
    "Extra E",
    "Extra F",
    "Extra G",
    "Front Matter",
    "Back Matter",
    "Other Matter",
    "3 Ezra *obsolete*",
    "Apocalypse of Ezra",
    "5 Ezra (Latin Prologue)",
    "6 Ezra (Latin Epilogue)",
    "Introduction",
    "Concordance ",
    "Glossary ",
    "Topical Index",
    "Names Index",
    "Daniel Greek",
    "Psalms 152-155",
    "2 Baruch (Apocalypse)",
    "Letter of Baruch",
    "Jubilees",
    "Enoch",
    "1 Meqabyan",
    "2 Meqabyan",
    "3 Meqabyan",
    "Reproof (Proverbs 25-31)",
    "4 Baruch (Rest of Baruch)",
    "Laodiceans"
], Zt = Dn();
function gt(t, e = !0) {
    return e && (t = t.toUpperCase()), t in Zt ? Zt[t] : 0;
}
function Vt(t) {
    return gt(t) > 0;
}
function cn(t) {
    const e = typeof t == "string" ? gt(t) : t;
    return e >= 40 && e <= 66;
}
function ln(t) {
    return (typeof t == "string" ? gt(t) : t) <= 39;
}
function Mr(t) {
    return t <= 66;
}
function fn(t) {
    const e = typeof t == "string" ? gt(t) : t;
    return _r(e) && !Mr(e);
}
function* pn() {
    for (let t = 1; t <= it.length; t++)
        yield t;
}
const hn = 1, Br = it.length;
function dn() {
    return ["XXA", "XXB", "XXC", "XXD", "XXE", "XXF", "XXG"];
}
function Gt(t, e = "***") {
    const n = t - 1;
    return n < 0 || n >= it.length ? e : it[n];
}
function Rr(t) {
    return t <= 0 || t > Br ? "******" : xr[t - 1];
}
function mn(t) {
    return Rr(gt(t));
}
function _r(t) {
    const e = typeof t == "number" ? Gt(t) : t;
    return Vt(e) && !$t.includes(e);
}
function En(t) {
    const e = typeof t == "number" ? Gt(t) : t;
    return Vt(e) && $t.includes(e);
}
function gn(t) {
    return xr[t - 1].includes("*obsolete*");
}
function Dn() {
    const t = {};
    for (let e = 0; e < it.length; e++)
        t[it[e]] = e + 1;
    return t;
}
const be = {
    allBookIds: it,
    nonCanonicalIds: $t,
    bookIdToNumber: gt,
    isBookIdValid: Vt,
    isBookNT: cn,
    isBookOT: ln,
    isBookOTNT: Mr,
    isBookDC: fn,
    allBookNumbers: pn,
    firstBook: hn,
    lastBook: Br,
    extraBooks: dn,
    bookNumberToId: Gt,
    bookNumberToEnglishName: Rr,
    bookIdToEnglishName: mn,
    isCanonical: _r,
    isExtraMaterial: En,
    isObsolete: gn
};
var Le = /* @__PURE__ */ ((t) => (t[t.Unknown = 0] = "Unknown", t[t.Original = 1] = "Original", t[t.Septuagint = 2] = "Septuagint", t[t.Vulgate = 3] = "Vulgate", t[t.English = 4] = "English", t[t.RussianProtestant = 5] = "RussianProtestant", t[t.RussianOrthodox = 6] = "RussianOrthodox", t))(Le || {});
const Te = class {
    // private versInfo: Versification;
    constructor(e) {
        if (z(this, "name"), z(this, "fullPath"), z(this, "isPresent"), z(this, "hasVerseSegments"), z(this, "isCustomized"), z(this, "baseVersification"), z(this, "scriptureBooks"), z(this, "_type"), e == null)
            throw new Error("Argument undefined");
        typeof e == "string" ? (this.name = e, this._type = Le[e]) : (this._type = e, this.name = Le[e]);
    }
    get type() {
        return this._type;
    }
    equals(e) {
        return !e.type || !this.type ? !1 : e.type === this.type;
    }
};
z(Te, "Original", new Te(Le.Original)), z(Te, "Septuagint", new Te(Le.Septuagint)), z(Te, "Vulgate", new Te(Le.Vulgate)), z(Te, "English", new Te(Le.English)), z(Te, "RussianProtestant", new Te(Le.RussianProtestant)), z(Te, "RussianOrthodox", new Te(Le.RussianOrthodox));
let nt = Te;
function er(t, e) {
    const n = e[0];
    for (let i = 1; i < e.length; i++)
        t = t.split(e[i]).join(n);
    return t.split(n);
}
var Pr = /* @__PURE__ */ ((t) => (t[t.Valid = 0] = "Valid", t[t.UnknownVersification = 1] = "UnknownVersification", t[t.OutOfRange = 2] = "OutOfRange", t[t.VerseOutOfOrder = 3] = "VerseOutOfOrder", t[t.VerseRepeated = 4] = "VerseRepeated", t))(Pr || {});
const De = class Y {
    constructor(e, n, i, o) {
        if (z(this, "firstChapter"), z(this, "lastChapter"), z(this, "lastVerse"), z(this, "hasSegmentsDefined"), z(this, "text"), z(this, "BBBCCCVVVS"), z(this, "longHashCode"), z(this, "versification"), z(this, "rtlMark", "â€"), z(this, "_bookNum", 0), z(this, "_chapterNum", 0), z(this, "_verseNum", 0), z(this, "_verse"), i == null && o == null)
            if (e != null && typeof e == "string") {
                const a = e, h = n != null && n instanceof nt ? n : void 0;
                this.setEmpty(h), this.parse(a);
            }
            else if (e != null && typeof e == "number") {
                const a = n != null && n instanceof nt ? n : void 0;
                this.setEmpty(a), this._verseNum = e % Y.chapterDigitShifter, this._chapterNum = Math.floor(e % Y.bookDigitShifter / Y.chapterDigitShifter), this._bookNum = Math.floor(e / Y.bookDigitShifter);
            }
            else if (n == null)
                if (e != null && e instanceof Y) {
                    const a = e;
                    this._bookNum = a.bookNum, this._chapterNum = a.chapterNum, this._verseNum = a.verseNum, this._verse = a.verse, this.versification = a.versification;
                }
                else {
                    if (e == null)
                        return;
                    const a = e instanceof nt ? e : Y.defaultVersification;
                    this.setEmpty(a);
                }
            else
                throw new Error("VerseRef constructor not supported.");
        else if (e != null && n != null && i != null)
            if (typeof e == "string" && typeof n == "string" && typeof i == "string")
                this.setEmpty(o), this.updateInternal(e, n, i);
            else if (typeof e == "number" && typeof n == "number" && typeof i == "number")
                this._bookNum = e, this._chapterNum = n, this._verseNum = i, this.versification = o ?? Y.defaultVersification;
            else
                throw new Error("VerseRef constructor not supported.");
        else
            throw new Error("VerseRef constructor not supported.");
    }
    /**
     * Determines if the verse string is in a valid format (does not consider versification).
     */
    static isVerseParseable(e) {
        return e.length > 0 && "0123456789".includes(e[0]) && !e.endsWith(this.verseRangeSeparator) && !e.endsWith(this.verseSequenceIndicator);
    }
    /**
     * Tries to parse the specified string into a verse reference.
     * @param str - The string to attempt to parse.
     * @returns success: `true` if the specified string was successfully parsed, `false` otherwise.
     * @returns verseRef: The result of the parse if successful, or empty VerseRef if it failed
     */
    static tryParse(e) {
        let n;
        try {
            return n = new Y(e), { success: !0, verseRef: n };
        }
        catch (i) {
            if (i instanceof Ct)
                return n = new Y(), { success: !1, verseRef: n };
            throw i;
        }
    }
    /**
     * Gets the reference as a comparable integer where the book, chapter, and verse each occupy 3
     * digits.
     * @param bookNum - Book number (this is 1-based, not an index).
     * @param chapterNum - Chapter number.
     * @param verseNum - Verse number.
     * @returns The reference as a comparable integer where the book, chapter, and verse each occupy 3
     * digits.
     */
    static getBBBCCCVVV(e, n, i) {
        return e % Y.bcvMaxValue * Y.bookDigitShifter + (n >= 0 ? n % Y.bcvMaxValue * Y.chapterDigitShifter : 0) + (i >= 0 ? i % Y.bcvMaxValue : 0);
    }
    /**
     * Deserializes a serialized VerseRef.
     * @param serializedVerseRef - Serialized VerseRef to create from.
     * @returns the deserialized VerseRef.
     */
    static fromJSON(e) {
        const { book: n, chapterNum: i, verseNum: o, verse: a, versificationStr: h } = e, p = a || o.toString();
        let f;
        return h && (f = new nt(h)), n ? new Y(n, i.toString(), p, f) : new Y();
    }
    /**
     * Parses a verse string and gets the leading numeric portion as a number.
     * @param verseStr - verse string to parse
     * @returns true if the entire string could be parsed as a single, simple verse number (1-999);
     *    false if the verse string represented a verse bridge, contained segment letters, or was invalid
     */
    static tryGetVerseNum(e) {
        let n;
        if (!e)
            return n = -1, { success: !0, vNum: n };
        n = 0;
        let i;
        for (let o = 0; o < e.length; o++) {
            if (i = e[o], i < "0" || i > "9")
                return o === 0 && (n = -1), { success: !1, vNum: n };
            if (n = n * 10 + +i - 0, n > Y.bcvMaxValue)
                return n = -1, { success: !1, vNum: n };
        }
        return { success: !0, vNum: n };
    }
    /**
     * Checks to see if a VerseRef hasn't been set - all values are the default.
     */
    get isDefault() {
        return this.bookNum === 0 && this.chapterNum === 0 && this.verseNum === 0 && this.versification == null;
    }
    /**
     * Gets whether the verse contains multiple verses.
     */
    get hasMultiple() {
        return this._verse != null && (this._verse.includes(Y.verseRangeSeparator) || this._verse.includes(Y.verseSequenceIndicator));
    }
    /**
     * Gets or sets the book of the reference. Book is the 3-letter abbreviation in capital letters,
     * e.g. `'MAT'`.
     */
    get book() {
        return be.bookNumberToId(this.bookNum, "");
    }
    set book(e) {
        this.bookNum = be.bookIdToNumber(e);
    }
    /**
     * Gets or sets the chapter of the reference,. e.g. `'3'`.
     */
    get chapter() {
        return this.isDefault || this._chapterNum < 0 ? "" : this._chapterNum.toString();
    }
    set chapter(e) {
        const n = +e;
        this._chapterNum = Number.isInteger(n) ? n : -1;
    }
    /**
     * Gets or sets the verse of the reference, including range, segments, and sequences, e.g. `'4'`,
     * or `'4b-5a, 7'`.
     */
    get verse() {
        return this._verse != null ? this._verse : this.isDefault || this._verseNum < 0 ? "" : this._verseNum.toString();
    }
    set verse(e) {
        const { success: n, vNum: i } = Y.tryGetVerseNum(e);
        this._verse = n ? void 0 : e.replace(this.rtlMark, ""), this._verseNum = i, !(this._verseNum >= 0) && ({ vNum: this._verseNum } = Y.tryGetVerseNum(this._verse));
    }
    /**
     * Get or set Book based on book number, e.g. `42`.
     */
    get bookNum() {
        return this._bookNum;
    }
    set bookNum(e) {
        if (e <= 0 || e > be.lastBook)
            throw new Ct("BookNum must be greater than zero and less than or equal to last book");
        this._bookNum = e;
    }
    /**
     * Gets or sets the chapter number, e.g. `3`. `-1` if not valid.
     */
    get chapterNum() {
        return this._chapterNum;
    }
    set chapterNum(e) {
        this.chapterNum = e;
    }
    /**
     * Gets or sets verse start number, e.g. `4`. `-1` if not valid.
     */
    get verseNum() {
        return this._verseNum;
    }
    set verseNum(e) {
        this._verseNum = e;
    }
    /**
     * String representing the versification (should ONLY be used for serialization/deserialization).
     *
     * @remarks This is for backwards compatibility when ScrVers was an enumeration.
     */
    get versificationStr() {
        var e;
        return (e = this.versification) == null ? void 0 : e.name;
    }
    set versificationStr(e) {
        this.versification = this.versification != null ? new nt(e) : void 0;
    }
    /**
     * Determines if the reference is valid.
     */
    get valid() {
        return this.validStatus === 0;
    }
    /**
     * Get the valid status for this reference.
     */
    get validStatus() {
        return this.validateVerse(Y.verseRangeSeparators, Y.verseSequenceIndicators);
    }
    /**
     * Gets the reference as a comparable integer where the book,
     * chapter, and verse each occupy three digits and the verse is 0.
     */
    get BBBCCC() {
        return Y.getBBBCCCVVV(this._bookNum, this._chapterNum, 0);
    }
    /**
     * Gets the reference as a comparable integer where the book,
     * chapter, and verse each occupy three digits. If verse is not null
     * (i.e., this reference represents a complex reference with verse
     * segments or bridge) this cannot be used for an exact comparison.
     */
    get BBBCCCVVV() {
        return Y.getBBBCCCVVV(this._bookNum, this._chapterNum, this._verseNum);
    }
    /**
     * Gets whether the verse is defined as an excluded verse in the versification.
     * Does not handle verse ranges.
     */
    // eslint-disable-next-line @typescript-eslint/class-literal-property-style
    get isExcluded() {
        return !1;
    }
    /**
     * Parses the reference in the specified string.
     * Optionally versification can follow reference as in GEN 3:11/4
     * Throw an exception if
     * - invalid book name
     * - chapter number is missing or not a number
     * - verse number is missing or does not start with a number
     * - versification is invalid
     * @param verseStr - string to parse e.g. 'MAT 3:11'
     */
    parse(e) {
        if (e = e.replace(this.rtlMark, ""), e.includes("/")) {
            const a = e.split("/");
            if (e = a[0], a.length > 1)
                try {
                    const h = +a[1].trim();
                    this.versification = new nt(Le[h]);
                }
                catch {
                    throw new Ct("Invalid reference : " + e);
                }
        }
        const n = e.trim().split(" ");
        if (n.length !== 2)
            throw new Ct("Invalid reference : " + e);
        const i = n[1].split(":"), o = +i[0];
        if (i.length !== 2 || be.bookIdToNumber(n[0]) === 0 || !Number.isInteger(o) || o < 0 || !Y.isVerseParseable(i[1]))
            throw new Ct("Invalid reference : " + e);
        this.updateInternal(n[0], i[0], i[1]);
    }
    /**
     * Simplifies this verse ref so that it has no bridging of verses or
     * verse segments like `'1a'`.
     */
    simplify() {
        this._verse = void 0;
    }
    /**
     * Makes a clone of the reference.
     *
     * @returns The cloned VerseRef.
     */
    clone() {
        return new Y(this);
    }
    toString() {
        const e = this.book;
        return e === "" ? "" : `${e} ${this.chapter}:${this.verse}`;
    }
    toJSON() {
        let e = this.verse;
        (e === "" || e === this.verseNum.toString()) && (e = void 0);
        const n = {
            book: this.book,
            chapterNum: this.chapterNum,
            verseNum: this.verseNum,
            verse: e,
            versificationStr: this.versificationStr
        };
        return e || delete n.verse, n;
    }
    /**
     * Compares this `VerseRef` with supplied one.
     * @param verseRef - object to compare this one to.
     * @returns `true` if this `VerseRef` is equal to the supplied one, `false` otherwise.
     */
    equals(e) {
        return e instanceof Y ? e._bookNum === this._bookNum && e._chapterNum === this._chapterNum && e._verseNum === this._verseNum && e.verse === this.verse && (e.versification == null && this.versification == null || e.versification != null && this.versification != null && e.versification.equals(this.versification)) : !1;
    }
    /**
     * Enumerate all individual verses contained in a VerseRef.
     * Verse ranges are indicated by "-" and consecutive verses by ","s.
     * Examples:
     * GEN 1:2 returns GEN 1:2
     * GEN 1:1a-3b,5 returns GEN 1:1a, GEN 1:2, GEN 1:3b, GEN 1:5
     * GEN 1:2a-2c returns //! ??????
     *
     * @param specifiedVersesOnly - if set to <c>true</c> return only verses that are
     * explicitly specified only, not verses within a range. Defaults to `false`.
     * @param verseRangeSeparators - Verse range separators.
     * Defaults to `VerseRef.verseRangeSeparators`.
     * @param verseSequenceSeparators - Verse sequence separators.
     * Defaults to `VerseRef.verseSequenceIndicators`.
     * @returns An array of all single verse references in this VerseRef.
     */
    allVerses(e = !1, n = Y.verseRangeSeparators, i = Y.verseSequenceIndicators) {
        if (this._verse == null || this.chapterNum <= 0)
            return [this.clone()];
        const o = [], a = er(this._verse, i);
        for (const h of a.map((p) => er(p, n))) {
            const p = this.clone();
            p.verse = h[0];
            const f = p.verseNum;
            if (o.push(p), h.length > 1) {
                const m = this.clone();
                if (m.verse = h[1], !e)
                    for (let E = f + 1; E < m.verseNum; E++) {
                        const l = new Y(this._bookNum, this._chapterNum, E, this.versification);
                        this.isExcluded || o.push(l);
                    }
                o.push(m);
            }
        }
        return o;
    }
    /**
     * Validates a verse number using the supplied separators rather than the defaults.
     */
    validateVerse(e, n) {
        if (!this.verse)
            return this.internalValid;
        let i = 0;
        for (const o of this.allVerses(!0, e, n)) {
            const a = o.internalValid;
            if (a !== 0)
                return a;
            const h = o.BBBCCCVVV;
            if (i > h)
                return 3;
            if (i === h)
                return 4;
            i = h;
        }
        return 0;
    }
    /**
     * Gets whether a single verse reference is valid.
     */
    get internalValid() {
        return this.versification == null ? 1 : this._bookNum <= 0 || this._bookNum > be.lastBook ? 2 : (be.isCanonical(this._bookNum), 0);
    }
    setEmpty(e = Y.defaultVersification) {
        this._bookNum = 0, this._chapterNum = -1, this._verse = void 0, this.versification = e;
    }
    updateInternal(e, n, i) {
        this.bookNum = be.bookIdToNumber(e), this.chapter = n, this.verse = i;
    }
};
z(De, "defaultVersification", nt.English), z(De, "verseRangeSeparator", "-"), z(De, "verseSequenceIndicator", ","), z(De, "verseRangeSeparators", [De.verseRangeSeparator]), z(De, "verseSequenceIndicators", [De.verseSequenceIndicator]), z(De, "chapterDigitShifter", 1e3), z(De, "bookDigitShifter", De.chapterDigitShifter * De.chapterDigitShifter), z(De, "bcvMaxValue", De.chapterDigitShifter - 1), /**
* The valid status of the VerseRef.
*/
    z(De, "ValidStatusType", Pr);
let Lr = De;
class Ct extends Error {
}
var H = {}, se = {}, tr;
function Dt() {
    if (tr)
        return se;
    tr = 1;
    function t(R, k, $) {
        if ($ === void 0 && ($ = Array.prototype), R && typeof $.find == "function")
            return $.find.call(R, k);
        for (var ne = 0; ne < R.length; ne++)
            if (n(R, ne)) {
                var le = R[ne];
                if (k.call(void 0, le, ne, R))
                    return le;
            }
    }
    function e(R, k) {
        return k === void 0 && (k = Object), k && typeof k.getOwnPropertyDescriptors == "function" && (R = k.create(null, k.getOwnPropertyDescriptors(R))), k && typeof k.freeze == "function" ? k.freeze(R) : R;
    }
    function n(R, k) {
        return Object.prototype.hasOwnProperty.call(R, k);
    }
    function i(R, k) {
        if (R === null || typeof R != "object")
            throw new TypeError("target is not an object");
        for (var $ in k)
            n(k, $) && (R[$] = k[$]);
        return R;
    }
    var o = e({
        allowfullscreen: !0,
        async: !0,
        autofocus: !0,
        autoplay: !0,
        checked: !0,
        controls: !0,
        default: !0,
        defer: !0,
        disabled: !0,
        formnovalidate: !0,
        hidden: !0,
        ismap: !0,
        itemscope: !0,
        loop: !0,
        multiple: !0,
        muted: !0,
        nomodule: !0,
        novalidate: !0,
        open: !0,
        playsinline: !0,
        readonly: !0,
        required: !0,
        reversed: !0,
        selected: !0
    });
    function a(R) {
        return n(o, R.toLowerCase());
    }
    var h = e({
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });
    function p(R) {
        return n(h, R.toLowerCase());
    }
    var f = e({
        script: !1,
        style: !1,
        textarea: !0,
        title: !0
    });
    function m(R) {
        var k = R.toLowerCase();
        return n(f, k) && !f[k];
    }
    function E(R) {
        var k = R.toLowerCase();
        return n(f, k) && f[k];
    }
    function l(R) {
        return R === O.HTML;
    }
    function v(R) {
        return l(R) || R === O.XML_XHTML_APPLICATION;
    }
    var O = e({
        /**
         * `text/html`, the only mime type that triggers treating an XML document as HTML.
         *
         * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
         * @see https://en.wikipedia.org/wiki/HTML Wikipedia
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
         * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring
         *      WHATWG HTML Spec
         */
        HTML: "text/html",
        /**
         * `application/xml`, the standard mime type for XML documents.
         *
         * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType
         *      registration
         * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
         * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
         */
        XML_APPLICATION: "application/xml",
        /**
         * `text/xml`, an alias for `application/xml`.
         *
         * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
         * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
         * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
         */
        XML_TEXT: "text/xml",
        /**
         * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
         * but is parsed as an XML document.
         *
         * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType
         *      registration
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
         * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
         */
        XML_XHTML_APPLICATION: "application/xhtml+xml",
        /**
         * `image/svg+xml`,
         *
         * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
         * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
         * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
         */
        XML_SVG_IMAGE: "image/svg+xml"
    }), b = Object.keys(O).map(function (R) {
        return O[R];
    });
    function C(R) {
        return b.indexOf(R) > -1;
    }
    var j = e({
        /**
         * The XHTML namespace.
         *
         * @see http://www.w3.org/1999/xhtml
         */
        HTML: "http://www.w3.org/1999/xhtml",
        /**
         * The SVG namespace.
         *
         * @see http://www.w3.org/2000/svg
         */
        SVG: "http://www.w3.org/2000/svg",
        /**
         * The `xml:` namespace.
         *
         * @see http://www.w3.org/XML/1998/namespace
         */
        XML: "http://www.w3.org/XML/1998/namespace",
        /**
         * The `xmlns:` namespace.
         *
         * @see https://www.w3.org/2000/xmlns/
         */
        XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    return se.assign = i, se.find = t, se.freeze = e, se.HTML_BOOLEAN_ATTRIBUTES = o, se.HTML_RAW_TEXT_ELEMENTS = f, se.HTML_VOID_ELEMENTS = h, se.hasDefaultHTMLNamespace = v, se.hasOwn = n, se.isHTMLBooleanAttribute = a, se.isHTMLRawTextElement = m, se.isHTMLEscapableRawTextElement = E, se.isHTMLMimeType = l, se.isHTMLVoidElement = p, se.isValidMimeType = C, se.MIME_TYPE = O, se.NAMESPACE = j, se;
}
var dt = {}, rr;
function _t() {
    if (rr)
        return dt;
    rr = 1;
    var t = Dt();
    function e(v, O) {
        v.prototype = Object.create(Error.prototype, {
            constructor: { value: v },
            name: { value: v.name, enumerable: !0, writable: O }
        });
    }
    var n = t.freeze({
        /**
         * the default value as defined by the spec
         */
        Error: "Error",
        /**
         * @deprecated
         * Use RangeError instead.
         */
        IndexSizeError: "IndexSizeError",
        /**
         * @deprecated
         * Just to match the related static code, not part of the spec.
         */
        DomstringSizeError: "DomstringSizeError",
        HierarchyRequestError: "HierarchyRequestError",
        WrongDocumentError: "WrongDocumentError",
        InvalidCharacterError: "InvalidCharacterError",
        /**
         * @deprecated
         * Just to match the related static code, not part of the spec.
         */
        NoDataAllowedError: "NoDataAllowedError",
        NoModificationAllowedError: "NoModificationAllowedError",
        NotFoundError: "NotFoundError",
        NotSupportedError: "NotSupportedError",
        InUseAttributeError: "InUseAttributeError",
        InvalidStateError: "InvalidStateError",
        SyntaxError: "SyntaxError",
        InvalidModificationError: "InvalidModificationError",
        NamespaceError: "NamespaceError",
        /**
         * @deprecated
         * Use TypeError for invalid arguments,
         * "NotSupportedError" DOMException for unsupported operations,
         * and "NotAllowedError" DOMException for denied requests instead.
         */
        InvalidAccessError: "InvalidAccessError",
        /**
         * @deprecated
         * Just to match the related static code, not part of the spec.
         */
        ValidationError: "ValidationError",
        /**
         * @deprecated
         * Use TypeError instead.
         */
        TypeMismatchError: "TypeMismatchError",
        SecurityError: "SecurityError",
        NetworkError: "NetworkError",
        AbortError: "AbortError",
        /**
         * @deprecated
         * Just to match the related static code, not part of the spec.
         */
        URLMismatchError: "URLMismatchError",
        QuotaExceededError: "QuotaExceededError",
        TimeoutError: "TimeoutError",
        InvalidNodeTypeError: "InvalidNodeTypeError",
        DataCloneError: "DataCloneError",
        EncodingError: "EncodingError",
        NotReadableError: "NotReadableError",
        UnknownError: "UnknownError",
        ConstraintError: "ConstraintError",
        DataError: "DataError",
        TransactionInactiveError: "TransactionInactiveError",
        ReadOnlyError: "ReadOnlyError",
        VersionError: "VersionError",
        OperationError: "OperationError",
        NotAllowedError: "NotAllowedError",
        OptOutError: "OptOutError"
    }), i = Object.keys(n);
    function o(v) {
        return typeof v == "number" && v >= 1 && v <= 25;
    }
    function a(v) {
        return typeof v == "string" && v.substring(v.length - n.Error.length) === n.Error;
    }
    function h(v, O) {
        o(v) ? (this.name = i[v], this.message = O || "") : (this.message = v, this.name = a(O) ? O : n.Error), Error.captureStackTrace && Error.captureStackTrace(this, h);
    }
    e(h, !0), Object.defineProperties(h.prototype, {
        code: {
            enumerable: !0,
            get: function () {
                var v = i.indexOf(this.name);
                return o(v) ? v : 0;
            }
        }
    });
    for (var p = {
        INDEX_SIZE_ERR: 1,
        DOMSTRING_SIZE_ERR: 2,
        HIERARCHY_REQUEST_ERR: 3,
        WRONG_DOCUMENT_ERR: 4,
        INVALID_CHARACTER_ERR: 5,
        NO_DATA_ALLOWED_ERR: 6,
        NO_MODIFICATION_ALLOWED_ERR: 7,
        NOT_FOUND_ERR: 8,
        NOT_SUPPORTED_ERR: 9,
        INUSE_ATTRIBUTE_ERR: 10,
        INVALID_STATE_ERR: 11,
        SYNTAX_ERR: 12,
        INVALID_MODIFICATION_ERR: 13,
        NAMESPACE_ERR: 14,
        INVALID_ACCESS_ERR: 15,
        VALIDATION_ERR: 16,
        TYPE_MISMATCH_ERR: 17,
        SECURITY_ERR: 18,
        NETWORK_ERR: 19,
        ABORT_ERR: 20,
        URL_MISMATCH_ERR: 21,
        QUOTA_EXCEEDED_ERR: 22,
        TIMEOUT_ERR: 23,
        INVALID_NODE_TYPE_ERR: 24,
        DATA_CLONE_ERR: 25
    }, f = Object.entries(p), m = 0; m < f.length; m++) {
        var E = f[m][0];
        h[E] = f[m][1];
    }
    function l(v, O) {
        this.message = v, this.locator = O, Error.captureStackTrace && Error.captureStackTrace(this, l);
    }
    return e(l), dt.DOMException = h, dt.DOMExceptionName = n, dt.ExceptionCode = p, dt.ParseError = l, dt;
}
var re = {}, U = {}, nr;
function Fr() {
    if (nr)
        return U;
    nr = 1;
    function t(ue) {
        try {
            typeof ue != "function" && (ue = RegExp);
            var he = new ue("ðŒ†", "u").exec("ðŒ†");
            return !!he && he[0].length === 2;
        }
        catch {
        }
        return !1;
    }
    var e = t();
    function n(ue) {
        if (ue.source[0] !== "[")
            throw new Error(ue + " can not be used with chars");
        return ue.source.slice(1, ue.source.lastIndexOf("]"));
    }
    function i(ue, he) {
        if (ue.source[0] !== "[")
            throw new Error("/" + ue.source + "/ can not be used with chars_without");
        if (!he || typeof he != "string")
            throw new Error(JSON.stringify(he) + " is not a valid search");
        if (ue.source.indexOf(he) === -1)
            throw new Error('"' + he + '" is not is /' + ue.source + "/");
        if (he === "-" && ue.source.indexOf(he) !== 1)
            throw new Error('"' + he + '" is not at the first postion of /' + ue.source + "/");
        return new RegExp(ue.source.replace(he, ""), e ? "u" : "");
    }
    function o(ue) {
        var he = this;
        return new RegExp(Array.prototype.slice.call(arguments).map(function (ke) {
            var qe = typeof ke == "string";
            if (qe && he === void 0 && ke === "|")
                throw new Error("use regg instead of reg to wrap expressions with `|`!");
            return qe ? ke : ke.source;
        }).join(""), e ? "mu" : "m");
    }
    function a(ue) {
        if (arguments.length === 0)
            throw new Error("no parameters provided");
        return o.apply(a, ["(?:"].concat(Array.prototype.slice.call(arguments), [")"]));
    }
    var h = "ï¿½", p = /[-\x09\x0A\x0D\x20-\x2C\x2E-\uD7FF\uE000-\uFFFD]/;
    e && (p = o("[", n(p), "\\u{10000}-\\u{10FFFF}", "]"));
    var f = /[\x20\x09\x0D\x0A]/, m = n(f), E = o(f, "+"), l = o(f, "*"), v = /[:_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    e && (v = o("[", n(v), "\\u{10000}-\\u{10FFFF}", "]"));
    var O = n(v), b = o("[", O, n(/[-.0-9\xB7]/), n(/[\u0300-\u036F\u203F-\u2040]/), "]"), C = o(v, b, "*"), j = o(b, "+"), R = o("&", C, ";"), k = a(/&#[0-9]+;|&#x[0-9a-fA-F]+;/), $ = a(R, "|", k), ne = o("%", C, ";"), le = a(o('"', a(/[^%&"]/, "|", ne, "|", $), "*", '"'), "|", o("'", a(/[^%&']/, "|", ne, "|", $), "*", "'")), g = a('"', a(/[^<&"]/, "|", $), "*", '"', "|", "'", a(/[^<&']/, "|", $), "*", "'"), x = i(v, ":"), F = i(b, ":"), G = o(x, F, "*"), K = o(G, a(":", G), "?"), ee = o("^", K, "$"), Ie = o("(", K, ")"), te = a(/"[^"]*"|'[^']*'/), Be = o(/^<\?/, "(", C, ")", a(E, "(", p, "*?)"), "?", /\?>/), d = /[\x20\x0D\x0Aa-zA-Z0-9-'()+,./:=?;!*#@$_%]/, N = a('"', d, '*"', "|", "'", i(d, "'"), "*'"), w = "<!--", y = "-->", M = o(w, a(i(p, "-"), "|", o("-", i(p, "-"))), "*", y), A = "#PCDATA", B = a(o(/\(/, l, A, a(l, /\|/, l, K), "*", l, /\)\*/), "|", o(/\(/, l, A, l, /\)/)), J = /[?*+]?/, _ = o(/\([^>]+\)/, J
    /*regg(choice, '|', seq), _children_quantity*/
    ), T = a("EMPTY", "|", "ANY", "|", B, "|", _), I = "<!ELEMENT", L = o(I, E, a(K, "|", ne), E, a(T, "|", ne), l, ">"), V = o("NOTATION", E, /\(/, l, C, a(l, /\|/, l, C), "*", l, /\)/), fe = o(/\(/, l, j, a(l, /\|/, l, j), "*", l, /\)/), we = a(V, "|", fe), ve = a(/CDATA|ID|IDREF|IDREFS|ENTITY|ENTITIES|NMTOKEN|NMTOKENS/, "|", we), ie = a(/#REQUIRED|#IMPLIED/, "|", a(a("#FIXED", E), "?", g)), P = a(E, C, E, ve, E, ie), $e = "<!ATTLIST", Re = o($e, E, C, P, "*", l, ">"), pe = "about:legacy-compat", Ve = a('"' + pe + '"', "|", "'" + pe + "'"), _e = "SYSTEM", Se = "PUBLIC", Fe = a(a(_e, E, te), "|", a(Se, E, N, E, te)), He = o("^", a(a(_e, E, "(?<SystemLiteralOnly>", te, ")"), "|", a(Se, E, "(?<PubidLiteral>", N, ")", E, "(?<SystemLiteral>", te, ")"))), Je = a(E, "NDATA", E, C), Ce = a(le, "|", a(Fe, Je, "?")), Q = "<!ENTITY", Ge = o(Q, E, C, E, Ce, l, ">"), oe = a(le, "|", Fe), Xe = o(Q, E, "%", E, C, E, oe, l, ">"), vt = a(Ge, "|", Xe), Ye = o(Se, E, N), We = o("<!NOTATION", E, C, E, a(Fe, "|", Ye), l, ">"), q = o(l, "=", l), Z = /1[.]\d+/, Ae = o(E, "version", q, a("'", Z, "'", "|", '"', Z, '"')), Ne = /[A-Za-z][-A-Za-z0-9._]*/, Ke = a(E, "encoding", q, a('"', Ne, '"', "|", "'", Ne, "'")), st = a(E, "standalone", q, a("'", a("yes", "|", "no"), "'", "|", '"', a("yes", "|", "no"), '"')), ct = o(/^<\?xml/, Ae, Ke, "?", st, "?", l, /\?>/), lt = "<!DOCTYPE", At = "<![CDATA[", Nt = "]]>", ft = /<!\[CDATA\[/, Qe = /\]\]>/, pt = o(p, "*?", Qe), Ot = o(ft, pt);
    return U.chars = n, U.chars_without = i, U.detectUnicodeSupport = t, U.reg = o, U.regg = a, U.ABOUT_LEGACY_COMPAT = pe, U.ABOUT_LEGACY_COMPAT_SystemLiteral = Ve, U.AttlistDecl = Re, U.CDATA_START = At, U.CDATA_END = Nt, U.CDSect = Ot, U.Char = p, U.Comment = M, U.COMMENT_START = w, U.COMMENT_END = y, U.DOCTYPE_DECL_START = lt, U.elementdecl = L, U.EntityDecl = vt, U.EntityValue = le, U.ExternalID = Fe, U.ExternalID_match = He, U.Name = C, U.NotationDecl = We, U.Reference = $, U.PEReference = ne, U.PI = Be, U.PUBLIC = Se, U.PubidLiteral = N, U.QName = K, U.QName_exact = ee, U.QName_group = Ie, U.S = E, U.SChar_s = m, U.S_OPT = l, U.SYSTEM = _e, U.SystemLiteral = te, U.UNICODE_REPLACEMENT_CHARACTER = h, U.UNICODE_SUPPORT = e, U.XMLDecl = ct, U;
}
var ur;
function kr() {
    if (ur)
        return re;
    ur = 1;
    var t = Dt(), e = t.find, n = t.hasDefaultHTMLNamespace, i = t.hasOwn, o = t.isHTMLMimeType, a = t.isHTMLRawTextElement, h = t.isHTMLVoidElement, p = t.MIME_TYPE, f = t.NAMESPACE, m = Symbol(), E = _t(), l = E.DOMException, v = E.DOMExceptionName, O = Fr();
    function b(r) {
        if (r !== m)
            throw new TypeError("Illegal constructor");
    }
    function C(r) {
        return r !== "";
    }
    function j(r) {
        return r ? r.split(/[\t\n\f\r ]+/).filter(C) : [];
    }
    function R(r, u) {
        return i(r, u) || (r[u] = !0), r;
    }
    function k(r) {
        if (!r)
            return [];
        var u = j(r);
        return Object.keys(u.reduce(R, {}));
    }
    function $(r) {
        return function (u) {
            return r && r.indexOf(u) !== -1;
        };
    }
    function ne(r) {
        if (!O.QName_exact.test(r))
            throw new l(l.INVALID_CHARACTER_ERR, 'invalid character in qualified name "' + r + '"');
    }
    function le(r, u) {
        ne(u), r = r || null;
        var s = null, c = u;
        if (u.indexOf(":") >= 0) {
            var D = u.split(":");
            s = D[0], c = D[1];
        }
        if (s !== null && r === null)
            throw new l(l.NAMESPACE_ERR, "prefix is non-null and namespace is null");
        if (s === "xml" && r !== t.NAMESPACE.XML)
            throw new l(l.NAMESPACE_ERR, 'prefix is "xml" and namespace is not the XML namespace');
        if ((s === "xmlns" || u === "xmlns") && r !== t.NAMESPACE.XMLNS)
            throw new l(l.NAMESPACE_ERR, 'either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace');
        if (r === t.NAMESPACE.XMLNS && s !== "xmlns" && u !== "xmlns")
            throw new l(l.NAMESPACE_ERR, 'namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns"');
        return [r, s, c];
    }
    function g(r, u) {
        for (var s in r)
            i(r, s) && (u[s] = r[s]);
    }
    function x(r, u) {
        var s = r.prototype;
        if (!(s instanceof u)) {
            let c = function () {
            };
            c.prototype = u.prototype, c = new c(), g(s, c), r.prototype = s = c;
        }
        s.constructor != r && (typeof r != "function" && console.error("unknown Class:" + r), s.constructor = r);
    }
    var F = {}, G = F.ELEMENT_NODE = 1, K = F.ATTRIBUTE_NODE = 2, ee = F.TEXT_NODE = 3, Ie = F.CDATA_SECTION_NODE = 4, te = F.ENTITY_REFERENCE_NODE = 5, Be = F.ENTITY_NODE = 6, d = F.PROCESSING_INSTRUCTION_NODE = 7, N = F.COMMENT_NODE = 8, w = F.DOCUMENT_NODE = 9, y = F.DOCUMENT_TYPE_NODE = 10, M = F.DOCUMENT_FRAGMENT_NODE = 11, A = F.NOTATION_NODE = 12, B = t.freeze({
        DOCUMENT_POSITION_DISCONNECTED: 1,
        DOCUMENT_POSITION_PRECEDING: 2,
        DOCUMENT_POSITION_FOLLOWING: 4,
        DOCUMENT_POSITION_CONTAINS: 8,
        DOCUMENT_POSITION_CONTAINED_BY: 16,
        DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32
    });
    function J(r, u) {
        if (u.length < r.length)
            return J(u, r);
        var s = null;
        for (var c in r) {
            if (r[c] !== u[c])
                return s;
            s = r[c];
        }
        return s;
    }
    function _(r) {
        return r.guid || (r.guid = Math.random()), r.guid;
    }
    function T() {
    }
    T.prototype = {
        /**
         * The number of nodes in the list. The range of valid child node indices is 0 to length-1
         * inclusive.
         *
         * @type {number}
         */
        length: 0,
        /**
         * Returns the item at `index`. If index is greater than or equal to the number of nodes in
         * the list, this returns null.
         *
         * @param index
         * Unsigned long Index into the collection.
         * @returns {Node | null}
         * The node at position `index` in the NodeList,
         * or null if that is not a valid index.
         */
        item: function (r) {
            return r >= 0 && r < this.length ? this[r] : null;
        },
        /**
         * Returns a string representation of the NodeList.
         *
         * @param {unknown} nodeFilter
         * __A filter function? Not implemented according to the spec?__.
         * @returns {string}
         * A string representation of the NodeList.
         */
        toString: function (r) {
            for (var u = [], s = 0; s < this.length; s++)
                qe(this[s], u, r);
            return u.join("");
        },
        /**
         * Filters the NodeList based on a predicate.
         *
         * @param {function(Node): boolean} predicate
         * - A predicate function to filter the NodeList.
         * @returns {Node[]}
         * An array of nodes that satisfy the predicate.
         * @private
         */
        filter: function (r) {
            return Array.prototype.filter.call(this, r);
        },
        /**
         * Returns the first index at which a given node can be found in the NodeList, or -1 if it is
         * not present.
         *
         * @param {Node} item
         * - The Node item to locate in the NodeList.
         * @returns {number}
         * The first index of the node in the NodeList; -1 if not found.
         * @private
         */
        indexOf: function (r) {
            return Array.prototype.indexOf.call(this, r);
        }
    }, T.prototype[Symbol.iterator] = function () {
        var r = this, u = 0;
        return {
            next: function () {
                return u < r.length ? {
                    value: r[u++],
                    done: !1
                } : {
                    done: !0
                };
            },
            return: function () {
                return {
                    done: !0
                };
            }
        };
    };
    function I(r, u) {
        this._node = r, this._refresh = u, L(this);
    }
    function L(r) {
        var u = r._node._inc || r._node.ownerDocument._inc;
        if (r._inc !== u) {
            var s = r._refresh(r._node);
            if (Xt(r, "length", s.length), !r.$$length || s.length < r.$$length)
                for (var c = s.length; c in r; c++)
                    i(r, c) && delete r[c];
            g(s, r), r._inc = u;
        }
    }
    I.prototype.item = function (r) {
        return L(this), this[r] || null;
    }, x(I, T);
    function V() {
    }
    function fe(r, u) {
        for (var s = 0; s < r.length;) {
            if (r[s] === u)
                return s;
            s++;
        }
    }
    function we(r, u, s, c) {
        if (c ? u[fe(u, c)] = s : (u[u.length] = s, u.length++), r) {
            s.ownerElement = r;
            var D = r.ownerDocument;
            D && (c && _e(D, r, c), Ve(D, r, s));
        }
    }
    function ve(r, u, s) {
        var c = fe(u, s);
        if (c >= 0) {
            for (var D = u.length - 1; c <= D;)
                u[c] = u[++c];
            if (u.length = D, r) {
                var S = r.ownerDocument;
                S && _e(S, r, s), s.ownerElement = null;
            }
        }
    }
    V.prototype = {
        length: 0,
        item: T.prototype.item,
        /**
         * Get an attribute by name. Note: Name is in lower case in case of HTML namespace and
         * document.
         *
         * @param {string} localName
         * The local name of the attribute.
         * @returns {Attr | null}
         * The attribute with the given local name, or null if no such attribute exists.
         * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name
         */
        getNamedItem: function (r) {
            this._ownerElement && this._ownerElement._isInHTMLDocumentAndNamespace() && (r = r.toLowerCase());
            for (var u = 0; u < this.length;) {
                var s = this[u];
                if (s.nodeName === r)
                    return s;
                u++;
            }
            return null;
        },
        /**
         * Set an attribute.
         *
         * @param {Attr} attr
         * The attribute to set.
         * @returns {Attr | null}
         * The old attribute with the same local name and namespace URI as the new one, or null if no
         * such attribute exists.
         * @throws {DOMException}
         * With code:
         * - {@link INUSE_ATTRIBUTE_ERR} - If the attribute is already an attribute of another
         * element.
         * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
         */
        setNamedItem: function (r) {
            var u = r.ownerElement;
            if (u && u !== this._ownerElement)
                throw new l(l.INUSE_ATTRIBUTE_ERR);
            var s = this.getNamedItemNS(r.namespaceURI, r.localName);
            return s === r ? r : (we(this._ownerElement, this, r, s), s);
        },
        /**
         * Set an attribute, replacing an existing attribute with the same local name and namespace
         * URI if one exists.
         *
         * @param {Attr} attr
         * The attribute to set.
         * @returns {Attr | null}
         * The old attribute with the same local name and namespace URI as the new one, or null if no
         * such attribute exists.
         * @throws {DOMException}
         * Throws a DOMException with the name "InUseAttributeError" if the attribute is already an
         * attribute of another element.
         * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
         */
        setNamedItemNS: function (r) {
            return this.setNamedItem(r);
        },
        /**
         * Removes an attribute specified by the local name.
         *
         * @param {string} localName
         * The local name of the attribute to be removed.
         * @returns {Attr}
         * The attribute node that was removed.
         * @throws {DOMException}
         * With code:
         * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given name is found.
         * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditem
         * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name
         */
        removeNamedItem: function (r) {
            var u = this.getNamedItem(r);
            if (!u)
                throw new l(l.NOT_FOUND_ERR, r);
            return ve(this._ownerElement, this, u), u;
        },
        /**
         * Removes an attribute specified by the namespace and local name.
         *
         * @param {string | null} namespaceURI
         * The namespace URI of the attribute to be removed.
         * @param {string} localName
         * The local name of the attribute to be removed.
         * @returns {Attr}
         * The attribute node that was removed.
         * @throws {DOMException}
         * With code:
         * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given namespace URI and local
         * name is found.
         * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditemns
         * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace
         */
        removeNamedItemNS: function (r, u) {
            var s = this.getNamedItemNS(r, u);
            if (!s)
                throw new l(l.NOT_FOUND_ERR, r ? r + " : " + u : u);
            return ve(this._ownerElement, this, s), s;
        },
        /**
         * Get an attribute by namespace and local name.
         *
         * @param {string | null} namespaceURI
         * The namespace URI of the attribute.
         * @param {string} localName
         * The local name of the attribute.
         * @returns {Attr | null}
         * The attribute with the given namespace URI and local name, or null if no such attribute
         * exists.
         * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace
         */
        getNamedItemNS: function (r, u) {
            r || (r = null);
            for (var s = 0; s < this.length;) {
                var c = this[s];
                if (c.localName === u && c.namespaceURI === r)
                    return c;
                s++;
            }
            return null;
        }
    }, V.prototype[Symbol.iterator] = function () {
        var r = this, u = 0;
        return {
            next: function () {
                return u < r.length ? {
                    value: r[u++],
                    done: !1
                } : {
                    done: !0
                };
            },
            return: function () {
                return {
                    done: !0
                };
            }
        };
    };
    function ie() {
    }
    ie.prototype = {
        /**
         * Test if the DOM implementation implements a specific feature and version, as specified in
         * {@link https://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMFeatures DOM Features}.
         *
         * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given
         * feature is supported. The different implementations fairly diverged in what kind of
         * features were reported. The latest version of the spec settled to force this method to
         * always return true, where the functionality was accurate and in use.
         *
         * @deprecated
         * It is deprecated and modern browsers return true in all cases.
         * @function DOMImplementation#hasFeature
         * @param {string} feature
         * The name of the feature to test.
         * @param {string} [version]
         * This is the version number of the feature to test.
         * @returns {boolean}
         * Always returns true.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
         * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
         * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-5CED94D7 DOM Level 3 Core
         */
        hasFeature: function (r, u) {
            return !0;
        },
        /**
         * Creates a DOM Document object of the specified type with its document element. Note that
         * based on the {@link DocumentType}
         * given to create the document, the implementation may instantiate specialized
         * {@link Document} objects that support additional features than the "Core", such as "HTML"
         * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML}.
         * On the other hand, setting the {@link DocumentType} after the document was created makes
         * this very unlikely to happen. Alternatively, specialized {@link Document} creation methods,
         * such as createHTMLDocument
         * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML},
         * can be used to obtain specific types of {@link Document} objects.
         *
         * __It behaves slightly different from the description in the living standard__:
         * - There is no interface/class `XMLDocument`, it returns a `Document`
         * instance (with it's `type` set to `'xml'`).
         * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
         *
         * @function DOMImplementation.createDocument
         * @param {string | null} namespaceURI
         * The
         * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-namespaceURI namespace URI}
         * of the document element to create or null.
         * @param {string | null} qualifiedName
         * The
         * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified name}
         * of the document element to be created or null.
         * @param {DocumentType | null} [doctype=null]
         * The type of document to be created or null. When doctype is not null, its
         * {@link Node#ownerDocument} attribute is set to the document being created. Default is
         * `null`
         * @returns {Document}
         * A new {@link Document} object with its document element. If the NamespaceURI,
         * qualifiedName, and doctype are null, the returned {@link Document} is empty with no
         * document element.
         * @throws {DOMException}
         * With code:
         *
         * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
         * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
         * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed, if the qualifiedName has a
         * prefix and the namespaceURI is null, or if the qualifiedName is null and the namespaceURI
         * is different from null, or if the qualifiedName has a prefix that is "xml" and the
         * namespaceURI is different from "{@link http://www.w3.org/XML/1998/namespace}"
         * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#Namespaces XML Namespaces},
         * or if the DOM implementation does not support the "XML" feature but a non-null namespace
         * URI was provided, since namespaces were defined by XML.
         * - `WRONG_DOCUMENT_ERR`: Raised if doctype has already been used with a different document
         * or was created from a different implementation.
         * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
         * "XML" and the language exposed through the Document does not support XML Namespaces (such
         * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
         * @since DOM Level 2.
         * @see {@link #createHTMLDocument}
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument DOM Living Standard
         * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-2-Core-DOM-createDocument DOM
         *      Level 3 Core
         * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM
         *      Level 2 Core (initial)
         */
        createDocument: function (r, u, s) {
            var c = p.XML_APPLICATION;
            r === f.HTML ? c = p.XML_XHTML_APPLICATION : r === f.SVG && (c = p.XML_SVG_IMAGE);
            var D = new pe(m, { contentType: c });
            if (D.implementation = this, D.childNodes = new T(), D.doctype = s || null, s && D.appendChild(s), u) {
                var S = D.createElementNS(r, u);
                D.appendChild(S);
            }
            return D;
        },
        /**
         * Creates an empty DocumentType node. Entity declarations and notations are not made
         * available. Entity reference expansions and default attribute additions do not occur.
         *
         * **This behavior is slightly different from the one in the specs**:
         * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
         * - `publicId` and `systemId` contain the raw data including any possible quotes,
         *   so they can always be serialized back to the original value
         * - `internalSubset` contains the raw string between `[` and `]` if present,
         *   but is not parsed or validated in any form.
         *
         * @function DOMImplementation#createDocumentType
         * @param {string} qualifiedName
         * The {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified
         * name} of the document type to be created.
         * @param {string} [publicId]
         * The external subset public identifier.
         * @param {string} [systemId]
         * The external subset system identifier.
         * @param {string} [internalSubset]
         * the internal subset or an empty string if it is not present
         * @returns {DocumentType}
         * A new {@link DocumentType} node with {@link Node#ownerDocument} set to null.
         * @throws {DOMException}
         * With code:
         *
         * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
         * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
         * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed.
         * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
         * "XML" and the language exposed through the Document does not support XML Namespaces (such
         * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
         * @since DOM Level 2.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType
         *      MDN
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living
         *      Standard
         * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-3-Core-DOM-createDocType DOM
         *      Level 3 Core
         * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM
         *      Level 2 Core
         * @see https://github.com/xmldom/xmldom/blob/master/CHANGELOG.md#050
         * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-Core-DocType-internalSubset
         * @prettierignore
         */
        createDocumentType: function (r, u, s, c) {
            ne(r);
            var D = new lt(m);
            return D.name = r, D.nodeName = r, D.publicId = u || "", D.systemId = s || "", D.internalSubset = c || "", D.childNodes = new T(), D;
        },
        /**
         * Returns an HTML document, that might already have a basic DOM structure.
         *
         * __It behaves slightly different from the description in the living standard__:
         * - If the first argument is `false` no initial nodes are added (steps 3-7 in the specs are
         * omitted)
         * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
         *
         * @param {string | false} [title]
         * A string containing the title to give the new HTML document.
         * @returns {Document}
         * The HTML document.
         * @since WHATWG Living Standard.
         * @see {@link #createDocument}
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument
         * @see https://dom.spec.whatwg.org/#html-document
         */
        createHTMLDocument: function (r) {
            var u = new pe(m, { contentType: p.HTML });
            if (u.implementation = this, u.childNodes = new T(), r !== !1) {
                u.doctype = this.createDocumentType("html"), u.doctype.ownerDocument = u, u.appendChild(u.doctype);
                var s = u.createElement("html");
                u.appendChild(s);
                var c = u.createElement("head");
                if (s.appendChild(c), typeof r == "string") {
                    var D = u.createElement("title");
                    D.appendChild(u.createTextNode(r)), c.appendChild(D);
                }
                s.appendChild(u.createElement("body"));
            }
            return u;
        }
    };
    function P(r) {
        b(r);
    }
    P.prototype = {
        /**
         * The first child of this node.
         *
         * @type {Node | null}
         */
        firstChild: null,
        /**
         * The last child of this node.
         *
         * @type {Node | null}
         */
        lastChild: null,
        /**
         * The previous sibling of this node.
         *
         * @type {Node | null}
         */
        previousSibling: null,
        /**
         * The next sibling of this node.
         *
         * @type {Node | null}
         */
        nextSibling: null,
        /**
         * The parent node of this node.
         *
         * @type {Node | null}
         */
        parentNode: null,
        /**
         * The parent element of this node.
         *
         * @type {Element | null}
         */
        get parentElement() {
            return this.parentNode && this.parentNode.nodeType === this.ELEMENT_NODE ? this.parentNode : null;
        },
        /**
         * The child nodes of this node.
         *
         * @type {NodeList}
         */
        childNodes: null,
        /**
         * The document object associated with this node.
         *
         * @type {Document | null}
         */
        ownerDocument: null,
        /**
         * The value of this node.
         *
         * @type {string | null}
         */
        nodeValue: null,
        /**
         * The namespace URI of this node.
         *
         * @type {string | null}
         */
        namespaceURI: null,
        /**
         * The prefix of the namespace for this node.
         *
         * @type {string | null}
         */
        prefix: null,
        /**
         * The local part of the qualified name of this node.
         *
         * @type {string | null}
         */
        localName: null,
        /**
         * The baseURI is currently always `about:blank`,
         * since that's what happens when you create a document from scratch.
         *
         * @type {'about:blank'}
         */
        baseURI: "about:blank",
        /**
         * Is true if this node is part of a document.
         *
         * @type {boolean}
         */
        get isConnected() {
            var r = this.getRootNode();
            return r && r.nodeType === r.DOCUMENT_NODE;
        },
        /**
         * Checks whether `other` is an inclusive descendant of this node.
         *
         * @param {Node | null | undefined} other
         * The node to check.
         * @returns {boolean}
         * True if `other` is an inclusive descendant of this node; false otherwise.
         * @see https://dom.spec.whatwg.org/#dom-node-contains
         */
        contains: function (r) {
            if (!r)
                return !1;
            var u = r;
            do {
                if (this === u)
                    return !0;
                u = r.parentNode;
            } while (u);
            return !1;
        },
        /**
         * @typedef GetRootNodeOptions
         * @property {boolean} [composed=false]
         */
        /**
         * Searches for the root node of this node.
         *
         * **This behavior is slightly different from the in the specs**:
         * - ignores `options.composed`, since `ShadowRoot`s are unsupported, always returns root.
         *
         * @param {GetRootNodeOptions} [options]
         * @returns {Node}
         * Root node.
         * @see https://dom.spec.whatwg.org/#dom-node-getrootnode
         * @see https://dom.spec.whatwg.org/#concept-shadow-including-root
         */
        getRootNode: function (r) {
            var u = this;
            do {
                if (!u.parentNode)
                    return u;
                u = u.parentNode;
            } while (u);
        },
        /**
         * Checks whether the given node is equal to this node.
         *
         * @param {Node} [otherNode]
         * @see https://dom.spec.whatwg.org/#concept-node-equals
         */
        isEqualNode: function (r) {
            if (!r || this.nodeType !== r.nodeType)
                return !1;
            switch (this.nodeType) {
                case this.DOCUMENT_TYPE_NODE:
                    if (this.name !== r.name || this.publicId !== r.publicId || this.systemId !== r.systemId)
                        return !1;
                    break;
                case this.ELEMENT_NODE:
                    if (this.namespaceURI !== r.namespaceURI || this.prefix !== r.prefix || this.localName !== r.localName || this.attributes.length !== r.attributes.length)
                        return !1;
                    for (var u = 0; u < this.attributes.length; u++) {
                        var s = this.attributes.item(u);
                        if (!s.isEqualNode(r.getAttributeNodeNS(s.namespaceURI, s.localName)))
                            return !1;
                    }
                    break;
                case this.ATTRIBUTE_NODE:
                    if (this.namespaceURI !== r.namespaceURI || this.localName !== r.localName || this.value !== r.value)
                        return !1;
                    break;
                case this.PROCESSING_INSTRUCTION_NODE:
                    if (this.target !== r.target || this.data !== r.data)
                        return !1;
                    break;
                case this.TEXT_NODE:
                case this.COMMENT_NODE:
                    if (this.data !== r.data)
                        return !1;
                    break;
            }
            if (this.childNodes.length !== r.childNodes.length)
                return !1;
            for (var u = 0; u < this.childNodes.length; u++)
                if (!this.childNodes[u].isEqualNode(r.childNodes[u]))
                    return !1;
            return !0;
        },
        /**
         * Checks whether or not the given node is this node.
         *
         * @param {Node} [otherNode]
         */
        isSameNode: function (r) {
            return this === r;
        },
        /**
         * Inserts a node before a reference node as a child of this node.
         *
         * @param {Node} newChild
         * The new child node to be inserted.
         * @param {Node | null} refChild
         * The reference node before which newChild will be inserted.
         * @returns {Node}
         * The new child node successfully inserted.
         * @throws {DOMException}
         * Throws a DOMException if inserting the node would result in a DOM tree that is not
         * well-formed, or if `child` is provided but is not a child of `parent`.
         * See {@link _insertBefore} for more details.
         * @since Modified in DOM L2
         */
        insertBefore: function (r, u) {
            return q(this, r, u);
        },
        /**
         * Replaces an old child node with a new child node within this node.
         *
         * @param {Node} newChild
         * The new node that is to replace the old node.
         * If it already exists in the DOM, it is removed from its original position.
         * @param {Node} oldChild
         * The existing child node to be replaced.
         * @returns {Node}
         * Returns the replaced child node.
         * @throws {DOMException}
         * Throws a DOMException if replacing the node would result in a DOM tree that is not
         * well-formed, or if `oldChild` is not a child of `this`.
         * This can also occur if the pre-replacement validity assertion fails.
         * See {@link _insertBefore}, {@link Node.removeChild}, and
         * {@link assertPreReplacementValidityInDocument} for more details.
         * @see https://dom.spec.whatwg.org/#concept-node-replace
         */
        replaceChild: function (r, u) {
            q(this, r, u, We), u && this.removeChild(u);
        },
        /**
         * Removes an existing child node from this node.
         *
         * @param {Node} oldChild
         * The child node to be removed.
         * @returns {Node}
         * Returns the removed child node.
         * @throws {DOMException}
         * Throws a DOMException if `oldChild` is not a child of `this`.
         * See {@link _removeChild} for more details.
         */
        removeChild: function (r) {
            return Fe(this, r);
        },
        /**
         * Appends a child node to this node.
         *
         * @param {Node} newChild
         * The child node to be appended to this node.
         * If it already exists in the DOM, it is removed from its original position.
         * @returns {Node}
         * Returns the appended child node.
         * @throws {DOMException}
         * Throws a DOMException if appending the node would result in a DOM tree that is not
         * well-formed, or if `newChild` is not a valid Node.
         * See {@link insertBefore} for more details.
         */
        appendChild: function (r) {
            return this.insertBefore(r, null);
        },
        /**
         * Determines whether this node has any child nodes.
         *
         * @returns {boolean}
         * Returns true if this node has any child nodes, and false otherwise.
         */
        hasChildNodes: function () {
            return this.firstChild != null;
        },
        /**
         * Creates a copy of the calling node.
         *
         * @param {boolean} deep
         * If true, the contents of the node are recursively copied.
         * If false, only the node itself (and its attributes, if it is an element) are copied.
         * @returns {Node}
         * Returns the newly created copy of the node.
         * @throws {DOMException}
         * May throw a DOMException if operations within {@link Element#setAttributeNode} or
         * {@link Node#appendChild} (which are potentially invoked in this method) do not meet their
         * specific constraints.
         * @see {@link cloneNode}
         */
        cloneNode: function (r) {
            return Lt(this.ownerDocument || this, this, r);
        },
        /**
         * Puts the specified node and all of its subtree into a "normalized" form. In a normalized
         * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.
         *
         * Specifically, this method merges any adjacent text nodes (i.e., nodes for which `nodeType`
         * is `TEXT_NODE`) into a single node with the combined data. It also removes any empty text
         * nodes.
         *
         * This method operates recursively, so it also normalizes any and all descendent nodes within
         * the subtree.
         *
         * @throws {DOMException}
         * May throw a DOMException if operations within removeChild or appendData (which are
         * potentially invoked in this method) do not meet their specific constraints.
         * @since Modified in DOM Level 2
         * @see {@link Node.removeChild}
         * @see {@link CharacterData.appendData}
         */
        normalize: function () {
            for (var r = this.firstChild; r;) {
                var u = r.nextSibling;
                u && u.nodeType == ee && r.nodeType == ee ? (this.removeChild(u), r.appendData(u.data)) : (r.normalize(), r = u);
            }
        },
        /**
         * Checks whether the DOM implementation implements a specific feature and its version.
         *
         * @deprecated
         * Since `DOMImplementation.hasFeature` is deprecated and always returns true.
         * @param {string} feature
         * The package name of the feature to test. This is the same name that can be passed to the
         * method `hasFeature` on `DOMImplementation`.
         * @param {string} version
         * This is the version number of the package name to test.
         * @returns {boolean}
         * Returns true in all cases in the current implementation.
         * @since Introduced in DOM Level 2
         * @see {@link DOMImplementation.hasFeature}
         */
        isSupported: function (r, u) {
            return this.ownerDocument.implementation.hasFeature(r, u);
        },
        /**
         * Look up the prefix associated to the given namespace URI, starting from this node.
         * **The default namespace declarations are ignored by this method.**
         * See Namespace Prefix Lookup for details on the algorithm used by this method.
         *
         * **This behavior is different from the in the specs**:
         * - no node type specific handling
         * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
         *
         * @param {string | null} namespaceURI
         * The namespace URI for which to find the associated prefix.
         * @returns {string | null}
         * The associated prefix, if found; otherwise, null.
         * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
         * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
         * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
         * @see https://github.com/xmldom/xmldom/issues/322
         * @prettierignore
         */
        lookupPrefix: function (r) {
            for (var u = this; u;) {
                var s = u._nsMap;
                if (s) {
                    for (var c in s)
                        if (i(s, c) && s[c] === r)
                            return c;
                }
                u = u.nodeType == K ? u.ownerDocument : u.parentNode;
            }
            return null;
        },
        /**
         * This function is used to look up the namespace URI associated with the given prefix,
         * starting from this node.
         *
         * **This behavior is different from the in the specs**:
         * - no node type specific handling
         * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
         *
         * @param {string | null} prefix
         * The prefix for which to find the associated namespace URI.
         * @returns {string | null}
         * The associated namespace URI, if found; otherwise, null.
         * @since DOM Level 3
         * @see https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
         * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI
         * @prettierignore
         */
        lookupNamespaceURI: function (r) {
            for (var u = this; u;) {
                var s = u._nsMap;
                if (s && i(s, r))
                    return s[r];
                u = u.nodeType == K ? u.ownerDocument : u.parentNode;
            }
            return null;
        },
        /**
         * Determines whether the given namespace URI is the default namespace.
         *
         * The function works by looking up the prefix associated with the given namespace URI. If no
         * prefix is found (i.e., the namespace URI is not registered in the namespace map of this
         * node or any of its ancestors), it returns `true`, implying the namespace URI is considered
         * the default.
         *
         * **This behavior is different from the in the specs**:
         * - no node type specific handling
         * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
         *
         * @param {string | null} namespaceURI
         * The namespace URI to be checked.
         * @returns {boolean}
         * Returns true if the given namespace URI is the default namespace, false otherwise.
         * @since DOM Level 3
         * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isDefaultNamespace
         * @see https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
         * @prettierignore
         */
        isDefaultNamespace: function (r) {
            var u = this.lookupPrefix(r);
            return u == null;
        },
        /**
         * Compares the reference node with a node with regard to their position in the document and
         * according to the document order.
         *
         * @param {Node} other
         * The node to compare the reference node to.
         * @returns {number}
         * Returns how the node is positioned relatively to the reference node according to the
         * bitmask. 0 if reference node and given node are the same.
         * @since DOM Level 3
         * @see https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-compare
         * @see https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
         */
        compareDocumentPosition: function (r) {
            if (this === r)
                return 0;
            var u = r, s = this, c = null, D = null;
            if (u instanceof Ae && (c = u, u = c.ownerElement), s instanceof Ae && (D = s, s = D.ownerElement, c && u && s === u))
                for (var S = 0, X; X = s.attributes[S]; S++) {
                    if (X === c)
                        return B.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + B.DOCUMENT_POSITION_PRECEDING;
                    if (X === D)
                        return B.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + B.DOCUMENT_POSITION_FOLLOWING;
                }
            if (!u || !s || s.ownerDocument !== u.ownerDocument)
                return B.DOCUMENT_POSITION_DISCONNECTED + B.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + (_(s.ownerDocument) > _(u.ownerDocument) ? B.DOCUMENT_POSITION_FOLLOWING : B.DOCUMENT_POSITION_PRECEDING);
            if (D && u === s)
                return B.DOCUMENT_POSITION_CONTAINS + B.DOCUMENT_POSITION_PRECEDING;
            if (c && u === s)
                return B.DOCUMENT_POSITION_CONTAINED_BY + B.DOCUMENT_POSITION_FOLLOWING;
            for (var ae = [], de = u.parentNode; de;) {
                if (!D && de === s)
                    return B.DOCUMENT_POSITION_CONTAINED_BY + B.DOCUMENT_POSITION_FOLLOWING;
                ae.push(de), de = de.parentNode;
            }
            ae.reverse();
            for (var ye = [], ge = s.parentNode; ge;) {
                if (!c && ge === u)
                    return B.DOCUMENT_POSITION_CONTAINS + B.DOCUMENT_POSITION_PRECEDING;
                ye.push(ge), ge = ge.parentNode;
            }
            ye.reverse();
            var Ze = J(ae, ye);
            for (var Ue in Ze.childNodes) {
                var Oe = Ze.childNodes[Ue];
                if (Oe === s)
                    return B.DOCUMENT_POSITION_FOLLOWING;
                if (Oe === u)
                    return B.DOCUMENT_POSITION_PRECEDING;
                if (ye.indexOf(Oe) >= 0)
                    return B.DOCUMENT_POSITION_FOLLOWING;
                if (ae.indexOf(Oe) >= 0)
                    return B.DOCUMENT_POSITION_PRECEDING;
            }
            return 0;
        }
    };
    function $e(r) {
        return r == "<" && "&lt;" || r == ">" && "&gt;" || r == "&" && "&amp;" || r == '"' && "&quot;" || "&#" + r.charCodeAt() + ";";
    }
    g(F, P), g(F, P.prototype), g(B, P), g(B, P.prototype);
    function Re(r, u) {
        if (u(r))
            return !0;
        if (r = r.firstChild)
            do
                if (Re(r, u))
                    return !0;
            while (r = r.nextSibling);
    }
    function pe(r, u) {
        b(r);
        var s = u || {};
        this.ownerDocument = this, this.contentType = s.contentType || p.XML_APPLICATION, this.type = o(this.contentType) ? "html" : "xml";
    }
    function Ve(r, u, s) {
        r && r._inc++;
        var c = s.namespaceURI;
        c === f.XMLNS && (u._nsMap[s.prefix ? s.localName : ""] = s.value);
    }
    function _e(r, u, s, c) {
        r && r._inc++;
        var D = s.namespaceURI;
        D === f.XMLNS && delete u._nsMap[s.prefix ? s.localName : ""];
    }
    function Se(r, u, s) {
        if (r && r._inc) {
            r._inc++;
            var c = u.childNodes;
            if (s && !s.nextSibling)
                c[c.length++] = s;
            else {
                for (var D = u.firstChild, S = 0; D;)
                    c[S++] = D, D = D.nextSibling;
                c.length = S, delete c[c.length];
            }
        }
    }
    function Fe(r, u) {
        if (r !== u.parentNode)
            throw new l(l.NOT_FOUND_ERR, "child's parent is not parent");
        var s = u.previousSibling, c = u.nextSibling;
        return s ? s.nextSibling = c : r.firstChild = c, c ? c.previousSibling = s : r.lastChild = s, Se(r.ownerDocument, r), u.parentNode = null, u.previousSibling = null, u.nextSibling = null, u;
    }
    function He(r) {
        return r && (r.nodeType === P.DOCUMENT_NODE || r.nodeType === P.DOCUMENT_FRAGMENT_NODE || r.nodeType === P.ELEMENT_NODE);
    }
    function Je(r) {
        return r && (r.nodeType === P.CDATA_SECTION_NODE || r.nodeType === P.COMMENT_NODE || r.nodeType === P.DOCUMENT_FRAGMENT_NODE || r.nodeType === P.DOCUMENT_TYPE_NODE || r.nodeType === P.ELEMENT_NODE || r.nodeType === P.PROCESSING_INSTRUCTION_NODE || r.nodeType === P.TEXT_NODE);
    }
    function Ce(r) {
        return r && r.nodeType === P.DOCUMENT_TYPE_NODE;
    }
    function Q(r) {
        return r && r.nodeType === P.ELEMENT_NODE;
    }
    function Ge(r) {
        return r && r.nodeType === P.TEXT_NODE;
    }
    function oe(r, u) {
        var s = r.childNodes || [];
        if (e(s, Q) || Ce(u))
            return !1;
        var c = e(s, Ce);
        return !(u && c && s.indexOf(c) > s.indexOf(u));
    }
    function Xe(r, u) {
        var s = r.childNodes || [];
        function c(S) {
            return Q(S) && S !== u;
        }
        if (e(s, c))
            return !1;
        var D = e(s, Ce);
        return !(u && D && s.indexOf(D) > s.indexOf(u));
    }
    function vt(r, u, s) {
        if (!He(r))
            throw new l(l.HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + r.nodeType);
        if (s && s.parentNode !== r)
            throw new l(l.NOT_FOUND_ERR, "child not in parent");
        if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !Je(u) || // 5. If either `node` is a Text node and `parent` is a document,
            // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
            // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
            // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
            Ce(u) && r.nodeType !== P.DOCUMENT_NODE)
            throw new l(l.HIERARCHY_REQUEST_ERR, "Unexpected node type " + u.nodeType + " for parent node type " + r.nodeType);
    }
    function Ye(r, u, s) {
        var c = r.childNodes || [], D = u.childNodes || [];
        if (u.nodeType === P.DOCUMENT_FRAGMENT_NODE) {
            var S = D.filter(Q);
            if (S.length > 1 || e(D, Ge))
                throw new l(l.HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
            if (S.length === 1 && !oe(r, s))
                throw new l(l.HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
        if (Q(u) && !oe(r, s))
            throw new l(l.HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        if (Ce(u)) {
            if (e(c, Ce))
                throw new l(l.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
            var X = e(c, Q);
            if (s && c.indexOf(X) < c.indexOf(s))
                throw new l(l.HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
            if (!s && X)
                throw new l(l.HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
    }
    function We(r, u, s) {
        var c = r.childNodes || [], D = u.childNodes || [];
        if (u.nodeType === P.DOCUMENT_FRAGMENT_NODE) {
            var S = D.filter(Q);
            if (S.length > 1 || e(D, Ge))
                throw new l(l.HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
            if (S.length === 1 && !Xe(r, s))
                throw new l(l.HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
        if (Q(u) && !Xe(r, s))
            throw new l(l.HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        if (Ce(u)) {
            if (e(c, function (de) {
                return Ce(de) && de !== s;
            }))
                throw new l(l.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
            var X = e(c, Q);
            if (s && c.indexOf(X) < c.indexOf(s))
                throw new l(l.HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
    }
    function q(r, u, s, c) {
        vt(r, u, s), r.nodeType === P.DOCUMENT_NODE && (c || Ye)(r, u, s);
        var D = u.parentNode;
        if (D && D.removeChild(u), u.nodeType === M) {
            var S = u.firstChild;
            if (S == null)
                return u;
            var X = u.lastChild;
        }
        else
            S = X = u;
        var ae = s ? s.previousSibling : r.lastChild;
        S.previousSibling = ae, X.nextSibling = s, ae ? ae.nextSibling = S : r.firstChild = S, s == null ? r.lastChild = X : s.previousSibling = X;
        do
            S.parentNode = r;
        while (S !== X && (S = S.nextSibling));
        return Se(r.ownerDocument || r, r, u), u.nodeType == M && (u.firstChild = u.lastChild = null), u;
    }
    pe.prototype = {
        /**
         * The implementation that created this document.
         *
         * @type DOMImplementation
         * @readonly
         */
        implementation: null,
        nodeName: "#document",
        nodeType: w,
        /**
         * The DocumentType node of the document.
         *
         * @type DocumentType
         * @readonly
         */
        doctype: null,
        documentElement: null,
        _inc: 1,
        insertBefore: function (r, u) {
            if (r.nodeType === M) {
                for (var s = r.firstChild; s;) {
                    var c = s.nextSibling;
                    this.insertBefore(s, u), s = c;
                }
                return r;
            }
            return q(this, r, u), r.ownerDocument = this, this.documentElement === null && r.nodeType === G && (this.documentElement = r), r;
        },
        removeChild: function (r) {
            var u = Fe(this, r);
            return u === this.documentElement && (this.documentElement = null), u;
        },
        replaceChild: function (r, u) {
            q(this, r, u, We), r.ownerDocument = this, u && this.removeChild(u), Q(r) && (this.documentElement = r);
        },
        // Introduced in DOM Level 2:
        importNode: function (r, u) {
            return Jt(this, r, u);
        },
        // Introduced in DOM Level 2:
        getElementById: function (r) {
            var u = null;
            return Re(this.documentElement, function (s) {
                if (s.nodeType == G && s.getAttribute("id") == r)
                    return u = s, !0;
            }), u;
        },
        /**
         * Creates a new `Element` that is owned by this `Document`.
         * In HTML Documents `localName` is the lower cased `tagName`,
         * otherwise no transformation is being applied.
         * When `contentType` implies the HTML namespace, it will be set as `namespaceURI`.
         *
         * __This implementation differs from the specification:__ - The provided name is not checked
         * against the `Name` production,
         * so no related error will be thrown.
         * - There is no interface `HTMLElement`, it is always an `Element`.
         * - There is no support for a second argument to indicate using custom elements.
         *
         * @param {string} tagName
         * @returns {Element}
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
         * @see https://dom.spec.whatwg.org/#dom-document-createelement
         * @see https://dom.spec.whatwg.org/#concept-create-element
         */
        createElement: function (r) {
            var u = new Z(m);
            u.ownerDocument = this, this.type === "html" && (r = r.toLowerCase()), n(this.contentType) && (u.namespaceURI = f.HTML), u.nodeName = r, u.tagName = r, u.localName = r, u.childNodes = new T();
            var s = u.attributes = new V();
            return s._ownerElement = u, u;
        },
        /**
         * @returns {DocumentFragment}
         */
        createDocumentFragment: function () {
            var r = new Qe(m);
            return r.ownerDocument = this, r.childNodes = new T(), r;
        },
        /**
         * @param {string} data
         * @returns {Text}
         */
        createTextNode: function (r) {
            var u = new Ke(m);
            return u.ownerDocument = this, u.childNodes = new T(), u.appendData(r), u;
        },
        /**
         * @param {string} data
         * @returns {Comment}
         */
        createComment: function (r) {
            var u = new st(m);
            return u.ownerDocument = this, u.childNodes = new T(), u.appendData(r), u;
        },
        /**
         * @param {string} data
         * @returns {CDATASection}
         */
        createCDATASection: function (r) {
            var u = new ct(m);
            return u.ownerDocument = this, u.childNodes = new T(), u.appendData(r), u;
        },
        /**
         * @param {string} target
         * @param {string} data
         * @returns {ProcessingInstruction}
         */
        createProcessingInstruction: function (r, u) {
            var s = new pt(m);
            return s.ownerDocument = this, s.childNodes = new T(), s.nodeName = s.target = r, s.nodeValue = s.data = u, s;
        },
        /**
         * Creates an `Attr` node that is owned by this document.
         * In HTML Documents `localName` is the lower cased `name`,
         * otherwise no transformation is being applied.
         *
         * __This implementation differs from the specification:__ - The provided name is not checked
         * against the `Name` production,
         * so no related error will be thrown.
         *
         * @param {string} name
         * @returns {Attr}
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createAttribute
         * @see https://dom.spec.whatwg.org/#dom-document-createattribute
         */
        createAttribute: function (r) {
            if (!O.QName_exact.test(r))
                throw new l(l.INVALID_CHARACTER_ERR, 'invalid character in name "' + r + '"');
            return this.type === "html" && (r = r.toLowerCase()), this._createAttribute(r);
        },
        _createAttribute: function (r) {
            var u = new Ae(m);
            return u.ownerDocument = this, u.childNodes = new T(), u.name = r, u.nodeName = r, u.localName = r, u.specified = !0, u;
        },
        /**
         * Creates an EntityReference object.
         * The current implementation does not fill the `childNodes` with those of the corresponding
         * `Entity`
         *
         * @deprecated
         * In DOM Level 4.
         * @param {string} name
         * The name of the entity to reference. No namespace well-formedness checks are performed.
         * @returns {EntityReference}
         * @throws {DOMException}
         * With code `INVALID_CHARACTER_ERR` when `name` is not valid.
         * @throws {DOMException}
         * with code `NOT_SUPPORTED_ERR` when the document is of type `html`
         * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-392B75AE
         */
        createEntityReference: function (r) {
            if (!O.Name.test(r))
                throw new l(l.INVALID_CHARACTER_ERR, 'not a valid xml name "' + r + '"');
            if (this.type === "html")
                throw new l("document is an html document", v.NotSupportedError);
            var u = new ft(m);
            return u.ownerDocument = this, u.childNodes = new T(), u.nodeName = r, u;
        },
        // Introduced in DOM Level 2:
        /**
         * @param {string} namespaceURI
         * @param {string} qualifiedName
         * @returns {Element}
         */
        createElementNS: function (r, u) {
            var s = le(r, u), c = new Z(m), D = c.attributes = new V();
            return c.childNodes = new T(), c.ownerDocument = this, c.nodeName = u, c.tagName = u, c.namespaceURI = s[0], c.prefix = s[1], c.localName = s[2], D._ownerElement = c, c;
        },
        // Introduced in DOM Level 2:
        /**
         * @param {string} namespaceURI
         * @param {string} qualifiedName
         * @returns {Attr}
         */
        createAttributeNS: function (r, u) {
            var s = le(r, u), c = new Ae(m);
            return c.ownerDocument = this, c.childNodes = new T(), c.nodeName = u, c.name = u, c.specified = !0, c.namespaceURI = s[0], c.prefix = s[1], c.localName = s[2], c;
        }
    }, x(pe, P);
    function Z(r) {
        b(r), this._nsMap = /* @__PURE__ */ Object.create(null);
    }
    Z.prototype = {
        nodeType: G,
        /**
         * The attributes of this element.
         *
         * @type {NamedNodeMap | null}
         */
        attributes: null,
        getQualifiedName: function () {
            return this.prefix ? this.prefix + ":" + this.localName : this.localName;
        },
        _isInHTMLDocumentAndNamespace: function () {
            return this.ownerDocument.type === "html" && this.namespaceURI === f.HTML;
        },
        /**
         * Implementaton of Level2 Core function hasAttributes.
         *
         * @returns {boolean}
         * True if attribute list is not empty.
         * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-NodeHasAttrs
         */
        hasAttributes: function () {
            return !!(this.attributes && this.attributes.length);
        },
        hasAttribute: function (r) {
            return !!this.getAttributeNode(r);
        },
        /**
         * Returns elementâ€™s first attribute whose qualified name is `name`, and `null`
         * if there is no such attribute.
         *
         * @param {string} name
         * @returns {string | null}
         */
        getAttribute: function (r) {
            var u = this.getAttributeNode(r);
            return u ? u.value : null;
        },
        getAttributeNode: function (r) {
            return this._isInHTMLDocumentAndNamespace() && (r = r.toLowerCase()), this.attributes.getNamedItem(r);
        },
        /**
         * Sets the value of elementâ€™s first attribute whose qualified name is qualifiedName to value.
         *
         * @param {string} name
         * @param {string} value
         */
        setAttribute: function (r, u) {
            this._isInHTMLDocumentAndNamespace() && (r = r.toLowerCase());
            var s = this.getAttributeNode(r);
            s ? s.value = s.nodeValue = "" + u : (s = this.ownerDocument._createAttribute(r), s.value = s.nodeValue = "" + u, this.setAttributeNode(s));
        },
        removeAttribute: function (r) {
            var u = this.getAttributeNode(r);
            u && this.removeAttributeNode(u);
        },
        setAttributeNode: function (r) {
            return this.attributes.setNamedItem(r);
        },
        setAttributeNodeNS: function (r) {
            return this.attributes.setNamedItemNS(r);
        },
        removeAttributeNode: function (r) {
            return this.attributes.removeNamedItem(r.nodeName);
        },
        //get real attribute name,and remove it by removeAttributeNode
        removeAttributeNS: function (r, u) {
            var s = this.getAttributeNodeNS(r, u);
            s && this.removeAttributeNode(s);
        },
        hasAttributeNS: function (r, u) {
            return this.getAttributeNodeNS(r, u) != null;
        },
        /**
         * Returns elementâ€™s attribute whose namespace is `namespaceURI` and local name is
         * `localName`,
         * or `null` if there is no such attribute.
         *
         * @param {string} namespaceURI
         * @param {string} localName
         * @returns {string | null}
         */
        getAttributeNS: function (r, u) {
            var s = this.getAttributeNodeNS(r, u);
            return s ? s.value : null;
        },
        /**
         * Sets the value of elementâ€™s attribute whose namespace is `namespaceURI` and local name is
         * `localName` to value.
         *
         * @param {string} namespaceURI
         * @param {string} qualifiedName
         * @param {string} value
         * @see https://dom.spec.whatwg.org/#dom-element-setattributens
         */
        setAttributeNS: function (r, u, s) {
            var c = le(r, u), D = c[2], S = this.getAttributeNodeNS(r, D);
            S ? S.value = S.nodeValue = "" + s : (S = this.ownerDocument.createAttributeNS(r, u), S.value = S.nodeValue = "" + s, this.setAttributeNode(S));
        },
        getAttributeNodeNS: function (r, u) {
            return this.attributes.getNamedItemNS(r, u);
        },
        /**
         * Returns a LiveNodeList of all child elements which have **all** of the given class name(s).
         *
         * Returns an empty list if `classNames` is an empty string or only contains HTML white space
         * characters.
         *
         * Warning: This returns a live LiveNodeList.
         * Changes in the DOM will reflect in the array as the changes occur.
         * If an element selected by this array no longer qualifies for the selector,
         * it will automatically be removed. Be aware of this for iteration purposes.
         *
         * @param {string} classNames
         * Is a string representing the class name(s) to match; multiple class names are separated by
         * (ASCII-)whitespace.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
         * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
         */
        getElementsByClassName: function (r) {
            var u = k(r);
            return new I(this, function (s) {
                var c = [];
                return u.length > 0 && Re(s, function (D) {
                    if (D !== s && D.nodeType === G) {
                        var S = D.getAttribute("class");
                        if (S) {
                            var X = r === S;
                            if (!X) {
                                var ae = k(S);
                                X = u.every($(ae));
                            }
                            X && c.push(D);
                        }
                    }
                }), c;
            });
        },
        /**
         * Returns a LiveNodeList of elements with the given qualifiedName.
         * Searching for all descendants can be done by passing `*` as `qualifiedName`.
         *
         * All descendants of the specified element are searched, but not the element itself.
         * The returned list is live, which means it updates itself with the DOM tree automatically.
         * Therefore, there is no need to call `Element.getElementsByTagName()`
         * with the same element and arguments repeatedly if the DOM changes in between calls.
         *
         * When called on an HTML element in an HTML document,
         * `getElementsByTagName` lower-cases the argument before searching for it.
         * This is undesirable when trying to match camel-cased SVG elements (such as
         * `<linearGradient>`) in an HTML document.
         * Instead, use `Element.getElementsByTagNameNS()`,
         * which preserves the capitalization of the tag name.
         *
         * `Element.getElementsByTagName` is similar to `Document.getElementsByTagName()`,
         * except that it only searches for elements that are descendants of the specified element.
         *
         * @param {string} qualifiedName
         * @returns {LiveNodeList}
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName
         * @see https://dom.spec.whatwg.org/#concept-getelementsbytagname
         */
        getElementsByTagName: function (r) {
            var u = (this.nodeType === w ? this : this.ownerDocument).type === "html", s = r.toLowerCase();
            return new I(this, function (c) {
                var D = [];
                return Re(c, function (S) {
                    if (!(S === c || S.nodeType !== G))
                        if (r === "*")
                            D.push(S);
                        else {
                            var X = S.getQualifiedName(), ae = u && S.namespaceURI === f.HTML ? s : r;
                            X === ae && D.push(S);
                        }
                }), D;
            });
        },
        getElementsByTagNameNS: function (r, u) {
            return new I(this, function (s) {
                var c = [];
                return Re(s, function (D) {
                    D !== s && D.nodeType === G && (r === "*" || D.namespaceURI === r) && (u === "*" || D.localName == u) && c.push(D);
                }), c;
            });
        }
    }, pe.prototype.getElementsByClassName = Z.prototype.getElementsByClassName, pe.prototype.getElementsByTagName = Z.prototype.getElementsByTagName, pe.prototype.getElementsByTagNameNS = Z.prototype.getElementsByTagNameNS, x(Z, P);
    function Ae(r) {
        b(r), this.namespaceURI = null, this.prefix = null, this.ownerElement = null;
    }
    Ae.prototype.nodeType = K, x(Ae, P);
    function Ne(r) {
        b(r);
    }
    Ne.prototype = {
        data: "",
        substringData: function (r, u) {
            return this.data.substring(r, r + u);
        },
        appendData: function (r) {
            r = this.data + r, this.nodeValue = this.data = r, this.length = r.length;
        },
        insertData: function (r, u) {
            this.replaceData(r, 0, u);
        },
        deleteData: function (r, u) {
            this.replaceData(r, u, "");
        },
        replaceData: function (r, u, s) {
            var c = this.data.substring(0, r), D = this.data.substring(r + u);
            s = c + s + D, this.nodeValue = this.data = s, this.length = s.length;
        }
    }, x(Ne, P);
    function Ke(r) {
        b(r);
    }
    Ke.prototype = {
        nodeName: "#text",
        nodeType: ee,
        splitText: function (r) {
            var u = this.data, s = u.substring(r);
            u = u.substring(0, r), this.data = this.nodeValue = u, this.length = u.length;
            var c = this.ownerDocument.createTextNode(s);
            return this.parentNode && this.parentNode.insertBefore(c, this.nextSibling), c;
        }
    }, x(Ke, Ne);
    function st(r) {
        b(r);
    }
    st.prototype = {
        nodeName: "#comment",
        nodeType: N
    }, x(st, Ne);
    function ct(r) {
        b(r);
    }
    ct.prototype = {
        nodeName: "#cdata-section",
        nodeType: Ie
    }, x(ct, Ke);
    function lt(r) {
        b(r);
    }
    lt.prototype.nodeType = y, x(lt, P);
    function At(r) {
        b(r);
    }
    At.prototype.nodeType = A, x(At, P);
    function Nt(r) {
        b(r);
    }
    Nt.prototype.nodeType = Be, x(Nt, P);
    function ft(r) {
        b(r);
    }
    ft.prototype.nodeType = te, x(ft, P);
    function Qe(r) {
        b(r);
    }
    Qe.prototype.nodeName = "#document-fragment", Qe.prototype.nodeType = M, x(Qe, P);
    function pt(r) {
        b(r);
    }
    pt.prototype.nodeType = d, x(pt, Ne);
    function Ot() {
    }
    Ot.prototype.serializeToString = function (r, u) {
        return ue.call(r, u);
    }, P.prototype.toString = ue;
    function ue(r) {
        var u = [], s = this.nodeType === w && this.documentElement || this, c = s.prefix, D = s.namespaceURI;
        if (D && c == null) {
            var c = s.lookupPrefix(D);
            if (c == null)
                var S = [
                    { namespace: D, prefix: null }
                    //{namespace:uri,prefix:''}
                ];
        }
        return qe(this, u, r, S), u.join("");
    }
    function he(r, u, s) {
        var c = r.prefix || "", D = r.namespaceURI;
        if (!D || c === "xml" && D === f.XML || D === f.XMLNS)
            return !1;
        for (var S = s.length; S--;) {
            var X = s[S];
            if (X.prefix === c)
                return X.namespace !== D;
        }
        return !0;
    }
    function ke(r, u, s) {
        r.push(" ", u, '="', s.replace(/[<>&"\t\n\r]/g, $e), '"');
    }
    function qe(r, u, s, c) {
        c || (c = []);
        var D = r.nodeType === w ? r : r.ownerDocument, S = D.type === "html";
        if (s)
            if (r = s(r), r) {
                if (typeof r == "string") {
                    u.push(r);
                    return;
                }
            }
            else
                return;
        switch (r.nodeType) {
            case G:
                var X = r.attributes, ae = X.length, me = r.firstChild, de = r.tagName, ye = de;
                if (!S && !r.prefix && r.namespaceURI) {
                    for (var ge, Ze = 0; Ze < X.length; Ze++)
                        if (X.item(Ze).name === "xmlns") {
                            ge = X.item(Ze).value;
                            break;
                        }
                    if (!ge)
                        for (var Ue = c.length - 1; Ue >= 0; Ue--) {
                            var Oe = c[Ue];
                            if (Oe.prefix === "" && Oe.namespace === r.namespaceURI) {
                                ge = Oe.namespace;
                                break;
                            }
                        }
                    if (ge !== r.namespaceURI)
                        for (var Ue = c.length - 1; Ue >= 0; Ue--) {
                            var Oe = c[Ue];
                            if (Oe.namespace === r.namespaceURI) {
                                Oe.prefix && (ye = Oe.prefix + ":" + de);
                                break;
                            }
                        }
                }
                u.push("<", ye);
                for (var et = 0; et < ae; et++) {
                    var Pe = X.item(et);
                    Pe.prefix == "xmlns" ? c.push({
                        prefix: Pe.localName,
                        namespace: Pe.value
                    }) : Pe.nodeName == "xmlns" && c.push({ prefix: "", namespace: Pe.value });
                }
                for (var et = 0; et < ae; et++) {
                    var Pe = X.item(et);
                    if (he(Pe, S, c)) {
                        var tt = Pe.prefix || "", bt = Pe.namespaceURI;
                        ke(u, tt ? "xmlns:" + tt : "xmlns", bt), c.push({ prefix: tt, namespace: bt });
                    }
                    qe(Pe, u, s, c);
                }
                if (de === ye && he(r, S, c)) {
                    var tt = r.prefix || "", bt = r.namespaceURI;
                    ke(u, tt ? "xmlns:" + tt : "xmlns", bt), c.push({ prefix: tt, namespace: bt });
                }
                var Ft = !me;
                if (Ft && (S || r.namespaceURI === f.HTML) && (Ft = h(de)), Ft)
                    u.push("/>");
                else {
                    if (u.push(">"), S && a(de))
                        for (; me;)
                            me.data ? u.push(me.data) : qe(me, u, s, c.slice()), me = me.nextSibling;
                    else
                        for (; me;)
                            qe(me, u, s, c.slice()), me = me.nextSibling;
                    u.push("</", ye, ">");
                }
                return;
            case w:
            case M:
                for (var me = r.firstChild; me;)
                    qe(me, u, s, c.slice()), me = me.nextSibling;
                return;
            case K:
                return ke(u, r.name, r.value);
            case ee:
                return u.push(r.data.replace(/[<&>]/g, $e));
            case Ie:
                return u.push(O.CDATA_START, r.data, O.CDATA_END);
            case N:
                return u.push(O.COMMENT_START, r.data, O.COMMENT_END);
            case y:
                var Yt = r.publicId, ht = r.systemId;
                u.push(O.DOCTYPE_DECL_START, " ", r.name), Yt ? (u.push(" ", O.PUBLIC, " ", Yt), ht && ht !== "." && u.push(" ", ht)) : ht && ht !== "." && u.push(" ", O.SYSTEM, " ", ht), r.internalSubset && u.push(" [", r.internalSubset, "]"), u.push(">");
                return;
            case d:
                return u.push("<?", r.target, " ", r.data, "?>");
            case te:
                return u.push("&", r.nodeName, ";");
            //case ENTITY_NODE:
            //case NOTATION_NODE:
            default:
                u.push("??", r.nodeName);
        }
    }
    function Jt(r, u, s) {
        var c;
        switch (u.nodeType) {
            case G:
                c = u.cloneNode(!1), c.ownerDocument = r;
            //var attrs = node2.attributes;
            //var len = attrs.length;
            //for(var i=0;i<len;i++){
            //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
            //}
            case M:
                break;
            case K:
                s = !0;
                break;
        }
        if (c || (c = u.cloneNode(!1)), c.ownerDocument = r, c.parentNode = null, s)
            for (var D = u.firstChild; D;)
                c.appendChild(Jt(r, D, s)), D = D.nextSibling;
        return c;
    }
    function Lt(r, u, s) {
        var c = new u.constructor(m);
        for (var D in u)
            if (i(u, D)) {
                var S = u[D];
                typeof S != "object" && S != c[D] && (c[D] = S);
            }
        switch (u.childNodes && (c.childNodes = new T()), c.ownerDocument = r, c.nodeType) {
            case G:
                var X = u.attributes, ae = c.attributes = new V(), de = X.length;
                ae._ownerElement = c;
                for (var ye = 0; ye < de; ye++)
                    c.setAttributeNode(Lt(r, X.item(ye), !0));
                break;
            case K:
                s = !0;
        }
        if (s)
            for (var ge = u.firstChild; ge;)
                c.appendChild(Lt(r, ge, s)), ge = ge.nextSibling;
        return c;
    }
    function Xt(r, u, s) {
        r[u] = s;
    }
    try {
        if (Object.defineProperty) {
            let r = function (u) {
                switch (u.nodeType) {
                    case G:
                    case M:
                        var s = [];
                        for (u = u.firstChild; u;)
                            u.nodeType !== 7 && u.nodeType !== 8 && s.push(r(u)), u = u.nextSibling;
                        return s.join("");
                    default:
                        return u.nodeValue;
                }
            };
            Object.defineProperty(I.prototype, "length", {
                get: function () {
                    return L(this), this.$$length;
                }
            }), Object.defineProperty(P.prototype, "textContent", {
                get: function () {
                    return r(this);
                },
                set: function (u) {
                    switch (this.nodeType) {
                        case G:
                        case M:
                            for (; this.firstChild;)
                                this.removeChild(this.firstChild);
                            (u || String(u)) && this.appendChild(this.ownerDocument.createTextNode(u));
                            break;
                        default:
                            this.data = u, this.value = u, this.nodeValue = u;
                    }
                }
            }), Xt = function (u, s, c) {
                u["$$" + s] = c;
            };
        }
    }
    catch {
    }
    return re._updateLiveList = L, re.Attr = Ae, re.CDATASection = ct, re.CharacterData = Ne, re.Comment = st, re.Document = pe, re.DocumentFragment = Qe, re.DocumentType = lt, re.DOMImplementation = ie, re.Element = Z, re.Entity = Nt, re.EntityReference = ft, re.LiveNodeList = I, re.NamedNodeMap = V, re.Node = P, re.NodeList = T, re.Notation = At, re.Text = Ke, re.ProcessingInstruction = pt, re.XMLSerializer = Ot, re;
}
var rt = {}, kt = {}, ir;
function vn() {
    return ir || (ir = 1, function (t) {
        var e = Dt().freeze;
        t.XML_ENTITIES = e({
            amp: "&",
            apos: "'",
            gt: ">",
            lt: "<",
            quot: '"'
        }), t.HTML_ENTITIES = e({
            Aacute: "Ã",
            aacute: "Ã¡",
            Abreve: "Ä‚",
            abreve: "Äƒ",
            ac: "âˆ¾",
            acd: "âˆ¿",
            acE: "âˆ¾Ì³",
            Acirc: "Ã‚",
            acirc: "Ã¢",
            acute: "Â´",
            Acy: "Ð",
            acy: "Ð°",
            AElig: "Ã†",
            aelig: "Ã¦",
            af: "â¡",
            Afr: "ð”„",
            afr: "ð”ž",
            Agrave: "Ã€",
            agrave: "Ã ",
            alefsym: "â„µ",
            aleph: "â„µ",
            Alpha: "Î‘",
            alpha: "Î±",
            Amacr: "Ä€",
            amacr: "Ä",
            amalg: "â¨¿",
            AMP: "&",
            amp: "&",
            And: "â©“",
            and: "âˆ§",
            andand: "â©•",
            andd: "â©œ",
            andslope: "â©˜",
            andv: "â©š",
            ang: "âˆ ",
            ange: "â¦¤",
            angle: "âˆ ",
            angmsd: "âˆ¡",
            angmsdaa: "â¦¨",
            angmsdab: "â¦©",
            angmsdac: "â¦ª",
            angmsdad: "â¦«",
            angmsdae: "â¦¬",
            angmsdaf: "â¦­",
            angmsdag: "â¦®",
            angmsdah: "â¦¯",
            angrt: "âˆŸ",
            angrtvb: "âŠ¾",
            angrtvbd: "â¦",
            angsph: "âˆ¢",
            angst: "Ã…",
            angzarr: "â¼",
            Aogon: "Ä„",
            aogon: "Ä…",
            Aopf: "ð”¸",
            aopf: "ð•’",
            ap: "â‰ˆ",
            apacir: "â©¯",
            apE: "â©°",
            ape: "â‰Š",
            apid: "â‰‹",
            apos: "'",
            ApplyFunction: "â¡",
            approx: "â‰ˆ",
            approxeq: "â‰Š",
            Aring: "Ã…",
            aring: "Ã¥",
            Ascr: "ð’œ",
            ascr: "ð’¶",
            Assign: "â‰”",
            ast: "*",
            asymp: "â‰ˆ",
            asympeq: "â‰",
            Atilde: "Ãƒ",
            atilde: "Ã£",
            Auml: "Ã„",
            auml: "Ã¤",
            awconint: "âˆ³",
            awint: "â¨‘",
            backcong: "â‰Œ",
            backepsilon: "Ï¶",
            backprime: "â€µ",
            backsim: "âˆ½",
            backsimeq: "â‹",
            Backslash: "âˆ–",
            Barv: "â«§",
            barvee: "âŠ½",
            Barwed: "âŒ†",
            barwed: "âŒ…",
            barwedge: "âŒ…",
            bbrk: "âŽµ",
            bbrktbrk: "âŽ¶",
            bcong: "â‰Œ",
            Bcy: "Ð‘",
            bcy: "Ð±",
            bdquo: "â€ž",
            becaus: "âˆµ",
            Because: "âˆµ",
            because: "âˆµ",
            bemptyv: "â¦°",
            bepsi: "Ï¶",
            bernou: "â„¬",
            Bernoullis: "â„¬",
            Beta: "Î’",
            beta: "Î²",
            beth: "â„¶",
            between: "â‰¬",
            Bfr: "ð”…",
            bfr: "ð”Ÿ",
            bigcap: "â‹‚",
            bigcirc: "â—¯",
            bigcup: "â‹ƒ",
            bigodot: "â¨€",
            bigoplus: "â¨",
            bigotimes: "â¨‚",
            bigsqcup: "â¨†",
            bigstar: "â˜…",
            bigtriangledown: "â–½",
            bigtriangleup: "â–³",
            biguplus: "â¨„",
            bigvee: "â‹",
            bigwedge: "â‹€",
            bkarow: "â¤",
            blacklozenge: "â§«",
            blacksquare: "â–ª",
            blacktriangle: "â–´",
            blacktriangledown: "â–¾",
            blacktriangleleft: "â—‚",
            blacktriangleright: "â–¸",
            blank: "â£",
            blk12: "â–’",
            blk14: "â–‘",
            blk34: "â–“",
            block: "â–ˆ",
            bne: "=âƒ¥",
            bnequiv: "â‰¡âƒ¥",
            bNot: "â«­",
            bnot: "âŒ",
            Bopf: "ð”¹",
            bopf: "ð•“",
            bot: "âŠ¥",
            bottom: "âŠ¥",
            bowtie: "â‹ˆ",
            boxbox: "â§‰",
            boxDL: "â•—",
            boxDl: "â•–",
            boxdL: "â••",
            boxdl: "â”",
            boxDR: "â•”",
            boxDr: "â•“",
            boxdR: "â•’",
            boxdr: "â”Œ",
            boxH: "â•",
            boxh: "â”€",
            boxHD: "â•¦",
            boxHd: "â•¤",
            boxhD: "â•¥",
            boxhd: "â”¬",
            boxHU: "â•©",
            boxHu: "â•§",
            boxhU: "â•¨",
            boxhu: "â”´",
            boxminus: "âŠŸ",
            boxplus: "âŠž",
            boxtimes: "âŠ ",
            boxUL: "â•",
            boxUl: "â•œ",
            boxuL: "â•›",
            boxul: "â”˜",
            boxUR: "â•š",
            boxUr: "â•™",
            boxuR: "â•˜",
            boxur: "â””",
            boxV: "â•‘",
            boxv: "â”‚",
            boxVH: "â•¬",
            boxVh: "â•«",
            boxvH: "â•ª",
            boxvh: "â”¼",
            boxVL: "â•£",
            boxVl: "â•¢",
            boxvL: "â•¡",
            boxvl: "â”¤",
            boxVR: "â• ",
            boxVr: "â•Ÿ",
            boxvR: "â•ž",
            boxvr: "â”œ",
            bprime: "â€µ",
            Breve: "Ë˜",
            breve: "Ë˜",
            brvbar: "Â¦",
            Bscr: "â„¬",
            bscr: "ð’·",
            bsemi: "â",
            bsim: "âˆ½",
            bsime: "â‹",
            bsol: "\\",
            bsolb: "â§…",
            bsolhsub: "âŸˆ",
            bull: "â€¢",
            bullet: "â€¢",
            bump: "â‰Ž",
            bumpE: "âª®",
            bumpe: "â‰",
            Bumpeq: "â‰Ž",
            bumpeq: "â‰",
            Cacute: "Ä†",
            cacute: "Ä‡",
            Cap: "â‹’",
            cap: "âˆ©",
            capand: "â©„",
            capbrcup: "â©‰",
            capcap: "â©‹",
            capcup: "â©‡",
            capdot: "â©€",
            CapitalDifferentialD: "â……",
            caps: "âˆ©ï¸€",
            caret: "â",
            caron: "Ë‡",
            Cayleys: "â„­",
            ccaps: "â©",
            Ccaron: "ÄŒ",
            ccaron: "Ä",
            Ccedil: "Ã‡",
            ccedil: "Ã§",
            Ccirc: "Äˆ",
            ccirc: "Ä‰",
            Cconint: "âˆ°",
            ccups: "â©Œ",
            ccupssm: "â©",
            Cdot: "ÄŠ",
            cdot: "Ä‹",
            cedil: "Â¸",
            Cedilla: "Â¸",
            cemptyv: "â¦²",
            cent: "Â¢",
            CenterDot: "Â·",
            centerdot: "Â·",
            Cfr: "â„­",
            cfr: "ð” ",
            CHcy: "Ð§",
            chcy: "Ñ‡",
            check: "âœ“",
            checkmark: "âœ“",
            Chi: "Î§",
            chi: "Ï‡",
            cir: "â—‹",
            circ: "Ë†",
            circeq: "â‰—",
            circlearrowleft: "â†º",
            circlearrowright: "â†»",
            circledast: "âŠ›",
            circledcirc: "âŠš",
            circleddash: "âŠ",
            CircleDot: "âŠ™",
            circledR: "Â®",
            circledS: "â“ˆ",
            CircleMinus: "âŠ–",
            CirclePlus: "âŠ•",
            CircleTimes: "âŠ—",
            cirE: "â§ƒ",
            cire: "â‰—",
            cirfnint: "â¨",
            cirmid: "â«¯",
            cirscir: "â§‚",
            ClockwiseContourIntegral: "âˆ²",
            CloseCurlyDoubleQuote: "â€",
            CloseCurlyQuote: "â€™",
            clubs: "â™£",
            clubsuit: "â™£",
            Colon: "âˆ·",
            colon: ":",
            Colone: "â©´",
            colone: "â‰”",
            coloneq: "â‰”",
            comma: ",",
            commat: "@",
            comp: "âˆ",
            compfn: "âˆ˜",
            complement: "âˆ",
            complexes: "â„‚",
            cong: "â‰…",
            congdot: "â©­",
            Congruent: "â‰¡",
            Conint: "âˆ¯",
            conint: "âˆ®",
            ContourIntegral: "âˆ®",
            Copf: "â„‚",
            copf: "ð•”",
            coprod: "âˆ",
            Coproduct: "âˆ",
            COPY: "Â©",
            copy: "Â©",
            copysr: "â„—",
            CounterClockwiseContourIntegral: "âˆ³",
            crarr: "â†µ",
            Cross: "â¨¯",
            cross: "âœ—",
            Cscr: "ð’ž",
            cscr: "ð’¸",
            csub: "â«",
            csube: "â«‘",
            csup: "â«",
            csupe: "â«’",
            ctdot: "â‹¯",
            cudarrl: "â¤¸",
            cudarrr: "â¤µ",
            cuepr: "â‹ž",
            cuesc: "â‹Ÿ",
            cularr: "â†¶",
            cularrp: "â¤½",
            Cup: "â‹“",
            cup: "âˆª",
            cupbrcap: "â©ˆ",
            CupCap: "â‰",
            cupcap: "â©†",
            cupcup: "â©Š",
            cupdot: "âŠ",
            cupor: "â©…",
            cups: "âˆªï¸€",
            curarr: "â†·",
            curarrm: "â¤¼",
            curlyeqprec: "â‹ž",
            curlyeqsucc: "â‹Ÿ",
            curlyvee: "â‹Ž",
            curlywedge: "â‹",
            curren: "Â¤",
            curvearrowleft: "â†¶",
            curvearrowright: "â†·",
            cuvee: "â‹Ž",
            cuwed: "â‹",
            cwconint: "âˆ²",
            cwint: "âˆ±",
            cylcty: "âŒ­",
            Dagger: "â€¡",
            dagger: "â€ ",
            daleth: "â„¸",
            Darr: "â†¡",
            dArr: "â‡“",
            darr: "â†“",
            dash: "â€",
            Dashv: "â«¤",
            dashv: "âŠ£",
            dbkarow: "â¤",
            dblac: "Ë",
            Dcaron: "ÄŽ",
            dcaron: "Ä",
            Dcy: "Ð”",
            dcy: "Ð´",
            DD: "â……",
            dd: "â…†",
            ddagger: "â€¡",
            ddarr: "â‡Š",
            DDotrahd: "â¤‘",
            ddotseq: "â©·",
            deg: "Â°",
            Del: "âˆ‡",
            Delta: "Î”",
            delta: "Î´",
            demptyv: "â¦±",
            dfisht: "â¥¿",
            Dfr: "ð”‡",
            dfr: "ð”¡",
            dHar: "â¥¥",
            dharl: "â‡ƒ",
            dharr: "â‡‚",
            DiacriticalAcute: "Â´",
            DiacriticalDot: "Ë™",
            DiacriticalDoubleAcute: "Ë",
            DiacriticalGrave: "`",
            DiacriticalTilde: "Ëœ",
            diam: "â‹„",
            Diamond: "â‹„",
            diamond: "â‹„",
            diamondsuit: "â™¦",
            diams: "â™¦",
            die: "Â¨",
            DifferentialD: "â…†",
            digamma: "Ï",
            disin: "â‹²",
            div: "Ã·",
            divide: "Ã·",
            divideontimes: "â‹‡",
            divonx: "â‹‡",
            DJcy: "Ð‚",
            djcy: "Ñ’",
            dlcorn: "âŒž",
            dlcrop: "âŒ",
            dollar: "$",
            Dopf: "ð”»",
            dopf: "ð••",
            Dot: "Â¨",
            dot: "Ë™",
            DotDot: "âƒœ",
            doteq: "â‰",
            doteqdot: "â‰‘",
            DotEqual: "â‰",
            dotminus: "âˆ¸",
            dotplus: "âˆ”",
            dotsquare: "âŠ¡",
            doublebarwedge: "âŒ†",
            DoubleContourIntegral: "âˆ¯",
            DoubleDot: "Â¨",
            DoubleDownArrow: "â‡“",
            DoubleLeftArrow: "â‡",
            DoubleLeftRightArrow: "â‡”",
            DoubleLeftTee: "â«¤",
            DoubleLongLeftArrow: "âŸ¸",
            DoubleLongLeftRightArrow: "âŸº",
            DoubleLongRightArrow: "âŸ¹",
            DoubleRightArrow: "â‡’",
            DoubleRightTee: "âŠ¨",
            DoubleUpArrow: "â‡‘",
            DoubleUpDownArrow: "â‡•",
            DoubleVerticalBar: "âˆ¥",
            DownArrow: "â†“",
            Downarrow: "â‡“",
            downarrow: "â†“",
            DownArrowBar: "â¤“",
            DownArrowUpArrow: "â‡µ",
            DownBreve: "Ì‘",
            downdownarrows: "â‡Š",
            downharpoonleft: "â‡ƒ",
            downharpoonright: "â‡‚",
            DownLeftRightVector: "â¥",
            DownLeftTeeVector: "â¥ž",
            DownLeftVector: "â†½",
            DownLeftVectorBar: "â¥–",
            DownRightTeeVector: "â¥Ÿ",
            DownRightVector: "â‡",
            DownRightVectorBar: "â¥—",
            DownTee: "âŠ¤",
            DownTeeArrow: "â†§",
            drbkarow: "â¤",
            drcorn: "âŒŸ",
            drcrop: "âŒŒ",
            Dscr: "ð’Ÿ",
            dscr: "ð’¹",
            DScy: "Ð…",
            dscy: "Ñ•",
            dsol: "â§¶",
            Dstrok: "Ä",
            dstrok: "Ä‘",
            dtdot: "â‹±",
            dtri: "â–¿",
            dtrif: "â–¾",
            duarr: "â‡µ",
            duhar: "â¥¯",
            dwangle: "â¦¦",
            DZcy: "Ð",
            dzcy: "ÑŸ",
            dzigrarr: "âŸ¿",
            Eacute: "Ã‰",
            eacute: "Ã©",
            easter: "â©®",
            Ecaron: "Äš",
            ecaron: "Ä›",
            ecir: "â‰–",
            Ecirc: "ÃŠ",
            ecirc: "Ãª",
            ecolon: "â‰•",
            Ecy: "Ð­",
            ecy: "Ñ",
            eDDot: "â©·",
            Edot: "Ä–",
            eDot: "â‰‘",
            edot: "Ä—",
            ee: "â…‡",
            efDot: "â‰’",
            Efr: "ð”ˆ",
            efr: "ð”¢",
            eg: "âªš",
            Egrave: "Ãˆ",
            egrave: "Ã¨",
            egs: "âª–",
            egsdot: "âª˜",
            el: "âª™",
            Element: "âˆˆ",
            elinters: "â§",
            ell: "â„“",
            els: "âª•",
            elsdot: "âª—",
            Emacr: "Ä’",
            emacr: "Ä“",
            empty: "âˆ…",
            emptyset: "âˆ…",
            EmptySmallSquare: "â—»",
            emptyv: "âˆ…",
            EmptyVerySmallSquare: "â–«",
            emsp: "â€ƒ",
            emsp13: "â€„",
            emsp14: "â€…",
            ENG: "ÅŠ",
            eng: "Å‹",
            ensp: "â€‚",
            Eogon: "Ä˜",
            eogon: "Ä™",
            Eopf: "ð”¼",
            eopf: "ð•–",
            epar: "â‹•",
            eparsl: "â§£",
            eplus: "â©±",
            epsi: "Îµ",
            Epsilon: "Î•",
            epsilon: "Îµ",
            epsiv: "Ïµ",
            eqcirc: "â‰–",
            eqcolon: "â‰•",
            eqsim: "â‰‚",
            eqslantgtr: "âª–",
            eqslantless: "âª•",
            Equal: "â©µ",
            equals: "=",
            EqualTilde: "â‰‚",
            equest: "â‰Ÿ",
            Equilibrium: "â‡Œ",
            equiv: "â‰¡",
            equivDD: "â©¸",
            eqvparsl: "â§¥",
            erarr: "â¥±",
            erDot: "â‰“",
            Escr: "â„°",
            escr: "â„¯",
            esdot: "â‰",
            Esim: "â©³",
            esim: "â‰‚",
            Eta: "Î—",
            eta: "Î·",
            ETH: "Ã",
            eth: "Ã°",
            Euml: "Ã‹",
            euml: "Ã«",
            euro: "â‚¬",
            excl: "!",
            exist: "âˆƒ",
            Exists: "âˆƒ",
            expectation: "â„°",
            ExponentialE: "â…‡",
            exponentiale: "â…‡",
            fallingdotseq: "â‰’",
            Fcy: "Ð¤",
            fcy: "Ñ„",
            female: "â™€",
            ffilig: "ï¬ƒ",
            fflig: "ï¬€",
            ffllig: "ï¬„",
            Ffr: "ð”‰",
            ffr: "ð”£",
            filig: "ï¬",
            FilledSmallSquare: "â—¼",
            FilledVerySmallSquare: "â–ª",
            fjlig: "fj",
            flat: "â™­",
            fllig: "ï¬‚",
            fltns: "â–±",
            fnof: "Æ’",
            Fopf: "ð”½",
            fopf: "ð•—",
            ForAll: "âˆ€",
            forall: "âˆ€",
            fork: "â‹”",
            forkv: "â«™",
            Fouriertrf: "â„±",
            fpartint: "â¨",
            frac12: "Â½",
            frac13: "â…“",
            frac14: "Â¼",
            frac15: "â…•",
            frac16: "â…™",
            frac18: "â…›",
            frac23: "â…”",
            frac25: "â…–",
            frac34: "Â¾",
            frac35: "â…—",
            frac38: "â…œ",
            frac45: "â…˜",
            frac56: "â…š",
            frac58: "â…",
            frac78: "â…ž",
            frasl: "â„",
            frown: "âŒ¢",
            Fscr: "â„±",
            fscr: "ð’»",
            gacute: "Çµ",
            Gamma: "Î“",
            gamma: "Î³",
            Gammad: "Ïœ",
            gammad: "Ï",
            gap: "âª†",
            Gbreve: "Äž",
            gbreve: "ÄŸ",
            Gcedil: "Ä¢",
            Gcirc: "Äœ",
            gcirc: "Ä",
            Gcy: "Ð“",
            gcy: "Ð³",
            Gdot: "Ä ",
            gdot: "Ä¡",
            gE: "â‰§",
            ge: "â‰¥",
            gEl: "âªŒ",
            gel: "â‹›",
            geq: "â‰¥",
            geqq: "â‰§",
            geqslant: "â©¾",
            ges: "â©¾",
            gescc: "âª©",
            gesdot: "âª€",
            gesdoto: "âª‚",
            gesdotol: "âª„",
            gesl: "â‹›ï¸€",
            gesles: "âª”",
            Gfr: "ð”Š",
            gfr: "ð”¤",
            Gg: "â‹™",
            gg: "â‰«",
            ggg: "â‹™",
            gimel: "â„·",
            GJcy: "Ðƒ",
            gjcy: "Ñ“",
            gl: "â‰·",
            gla: "âª¥",
            glE: "âª’",
            glj: "âª¤",
            gnap: "âªŠ",
            gnapprox: "âªŠ",
            gnE: "â‰©",
            gne: "âªˆ",
            gneq: "âªˆ",
            gneqq: "â‰©",
            gnsim: "â‹§",
            Gopf: "ð”¾",
            gopf: "ð•˜",
            grave: "`",
            GreaterEqual: "â‰¥",
            GreaterEqualLess: "â‹›",
            GreaterFullEqual: "â‰§",
            GreaterGreater: "âª¢",
            GreaterLess: "â‰·",
            GreaterSlantEqual: "â©¾",
            GreaterTilde: "â‰³",
            Gscr: "ð’¢",
            gscr: "â„Š",
            gsim: "â‰³",
            gsime: "âªŽ",
            gsiml: "âª",
            Gt: "â‰«",
            GT: ">",
            gt: ">",
            gtcc: "âª§",
            gtcir: "â©º",
            gtdot: "â‹—",
            gtlPar: "â¦•",
            gtquest: "â©¼",
            gtrapprox: "âª†",
            gtrarr: "â¥¸",
            gtrdot: "â‹—",
            gtreqless: "â‹›",
            gtreqqless: "âªŒ",
            gtrless: "â‰·",
            gtrsim: "â‰³",
            gvertneqq: "â‰©ï¸€",
            gvnE: "â‰©ï¸€",
            Hacek: "Ë‡",
            hairsp: "â€Š",
            half: "Â½",
            hamilt: "â„‹",
            HARDcy: "Ðª",
            hardcy: "ÑŠ",
            hArr: "â‡”",
            harr: "â†”",
            harrcir: "â¥ˆ",
            harrw: "â†­",
            Hat: "^",
            hbar: "â„",
            Hcirc: "Ä¤",
            hcirc: "Ä¥",
            hearts: "â™¥",
            heartsuit: "â™¥",
            hellip: "â€¦",
            hercon: "âŠ¹",
            Hfr: "â„Œ",
            hfr: "ð”¥",
            HilbertSpace: "â„‹",
            hksearow: "â¤¥",
            hkswarow: "â¤¦",
            hoarr: "â‡¿",
            homtht: "âˆ»",
            hookleftarrow: "â†©",
            hookrightarrow: "â†ª",
            Hopf: "â„",
            hopf: "ð•™",
            horbar: "â€•",
            HorizontalLine: "â”€",
            Hscr: "â„‹",
            hscr: "ð’½",
            hslash: "â„",
            Hstrok: "Ä¦",
            hstrok: "Ä§",
            HumpDownHump: "â‰Ž",
            HumpEqual: "â‰",
            hybull: "âƒ",
            hyphen: "â€",
            Iacute: "Ã",
            iacute: "Ã­",
            ic: "â£",
            Icirc: "ÃŽ",
            icirc: "Ã®",
            Icy: "Ð˜",
            icy: "Ð¸",
            Idot: "Ä°",
            IEcy: "Ð•",
            iecy: "Ðµ",
            iexcl: "Â¡",
            iff: "â‡”",
            Ifr: "â„‘",
            ifr: "ð”¦",
            Igrave: "ÃŒ",
            igrave: "Ã¬",
            ii: "â…ˆ",
            iiiint: "â¨Œ",
            iiint: "âˆ­",
            iinfin: "â§œ",
            iiota: "â„©",
            IJlig: "Ä²",
            ijlig: "Ä³",
            Im: "â„‘",
            Imacr: "Äª",
            imacr: "Ä«",
            image: "â„‘",
            ImaginaryI: "â…ˆ",
            imagline: "â„",
            imagpart: "â„‘",
            imath: "Ä±",
            imof: "âŠ·",
            imped: "Æµ",
            Implies: "â‡’",
            in: "âˆˆ",
            incare: "â„…",
            infin: "âˆž",
            infintie: "â§",
            inodot: "Ä±",
            Int: "âˆ¬",
            int: "âˆ«",
            intcal: "âŠº",
            integers: "â„¤",
            Integral: "âˆ«",
            intercal: "âŠº",
            Intersection: "â‹‚",
            intlarhk: "â¨—",
            intprod: "â¨¼",
            InvisibleComma: "â£",
            InvisibleTimes: "â¢",
            IOcy: "Ð",
            iocy: "Ñ‘",
            Iogon: "Ä®",
            iogon: "Ä¯",
            Iopf: "ð•€",
            iopf: "ð•š",
            Iota: "Î™",
            iota: "Î¹",
            iprod: "â¨¼",
            iquest: "Â¿",
            Iscr: "â„",
            iscr: "ð’¾",
            isin: "âˆˆ",
            isindot: "â‹µ",
            isinE: "â‹¹",
            isins: "â‹´",
            isinsv: "â‹³",
            isinv: "âˆˆ",
            it: "â¢",
            Itilde: "Ä¨",
            itilde: "Ä©",
            Iukcy: "Ð†",
            iukcy: "Ñ–",
            Iuml: "Ã",
            iuml: "Ã¯",
            Jcirc: "Ä´",
            jcirc: "Äµ",
            Jcy: "Ð™",
            jcy: "Ð¹",
            Jfr: "ð”",
            jfr: "ð”§",
            jmath: "È·",
            Jopf: "ð•",
            jopf: "ð•›",
            Jscr: "ð’¥",
            jscr: "ð’¿",
            Jsercy: "Ðˆ",
            jsercy: "Ñ˜",
            Jukcy: "Ð„",
            jukcy: "Ñ”",
            Kappa: "Îš",
            kappa: "Îº",
            kappav: "Ï°",
            Kcedil: "Ä¶",
            kcedil: "Ä·",
            Kcy: "Ðš",
            kcy: "Ðº",
            Kfr: "ð”Ž",
            kfr: "ð”¨",
            kgreen: "Ä¸",
            KHcy: "Ð¥",
            khcy: "Ñ…",
            KJcy: "ÐŒ",
            kjcy: "Ñœ",
            Kopf: "ð•‚",
            kopf: "ð•œ",
            Kscr: "ð’¦",
            kscr: "ð“€",
            lAarr: "â‡š",
            Lacute: "Ä¹",
            lacute: "Äº",
            laemptyv: "â¦´",
            lagran: "â„’",
            Lambda: "Î›",
            lambda: "Î»",
            Lang: "âŸª",
            lang: "âŸ¨",
            langd: "â¦‘",
            langle: "âŸ¨",
            lap: "âª…",
            Laplacetrf: "â„’",
            laquo: "Â«",
            Larr: "â†ž",
            lArr: "â‡",
            larr: "â†",
            larrb: "â‡¤",
            larrbfs: "â¤Ÿ",
            larrfs: "â¤",
            larrhk: "â†©",
            larrlp: "â†«",
            larrpl: "â¤¹",
            larrsim: "â¥³",
            larrtl: "â†¢",
            lat: "âª«",
            lAtail: "â¤›",
            latail: "â¤™",
            late: "âª­",
            lates: "âª­ï¸€",
            lBarr: "â¤Ž",
            lbarr: "â¤Œ",
            lbbrk: "â²",
            lbrace: "{",
            lbrack: "[",
            lbrke: "â¦‹",
            lbrksld: "â¦",
            lbrkslu: "â¦",
            Lcaron: "Ä½",
            lcaron: "Ä¾",
            Lcedil: "Ä»",
            lcedil: "Ä¼",
            lceil: "âŒˆ",
            lcub: "{",
            Lcy: "Ð›",
            lcy: "Ð»",
            ldca: "â¤¶",
            ldquo: "â€œ",
            ldquor: "â€ž",
            ldrdhar: "â¥§",
            ldrushar: "â¥‹",
            ldsh: "â†²",
            lE: "â‰¦",
            le: "â‰¤",
            LeftAngleBracket: "âŸ¨",
            LeftArrow: "â†",
            Leftarrow: "â‡",
            leftarrow: "â†",
            LeftArrowBar: "â‡¤",
            LeftArrowRightArrow: "â‡†",
            leftarrowtail: "â†¢",
            LeftCeiling: "âŒˆ",
            LeftDoubleBracket: "âŸ¦",
            LeftDownTeeVector: "â¥¡",
            LeftDownVector: "â‡ƒ",
            LeftDownVectorBar: "â¥™",
            LeftFloor: "âŒŠ",
            leftharpoondown: "â†½",
            leftharpoonup: "â†¼",
            leftleftarrows: "â‡‡",
            LeftRightArrow: "â†”",
            Leftrightarrow: "â‡”",
            leftrightarrow: "â†”",
            leftrightarrows: "â‡†",
            leftrightharpoons: "â‡‹",
            leftrightsquigarrow: "â†­",
            LeftRightVector: "â¥Ž",
            LeftTee: "âŠ£",
            LeftTeeArrow: "â†¤",
            LeftTeeVector: "â¥š",
            leftthreetimes: "â‹‹",
            LeftTriangle: "âŠ²",
            LeftTriangleBar: "â§",
            LeftTriangleEqual: "âŠ´",
            LeftUpDownVector: "â¥‘",
            LeftUpTeeVector: "â¥ ",
            LeftUpVector: "â†¿",
            LeftUpVectorBar: "â¥˜",
            LeftVector: "â†¼",
            LeftVectorBar: "â¥’",
            lEg: "âª‹",
            leg: "â‹š",
            leq: "â‰¤",
            leqq: "â‰¦",
            leqslant: "â©½",
            les: "â©½",
            lescc: "âª¨",
            lesdot: "â©¿",
            lesdoto: "âª",
            lesdotor: "âªƒ",
            lesg: "â‹šï¸€",
            lesges: "âª“",
            lessapprox: "âª…",
            lessdot: "â‹–",
            lesseqgtr: "â‹š",
            lesseqqgtr: "âª‹",
            LessEqualGreater: "â‹š",
            LessFullEqual: "â‰¦",
            LessGreater: "â‰¶",
            lessgtr: "â‰¶",
            LessLess: "âª¡",
            lesssim: "â‰²",
            LessSlantEqual: "â©½",
            LessTilde: "â‰²",
            lfisht: "â¥¼",
            lfloor: "âŒŠ",
            Lfr: "ð”",
            lfr: "ð”©",
            lg: "â‰¶",
            lgE: "âª‘",
            lHar: "â¥¢",
            lhard: "â†½",
            lharu: "â†¼",
            lharul: "â¥ª",
            lhblk: "â–„",
            LJcy: "Ð‰",
            ljcy: "Ñ™",
            Ll: "â‹˜",
            ll: "â‰ª",
            llarr: "â‡‡",
            llcorner: "âŒž",
            Lleftarrow: "â‡š",
            llhard: "â¥«",
            lltri: "â—º",
            Lmidot: "Ä¿",
            lmidot: "Å€",
            lmoust: "âŽ°",
            lmoustache: "âŽ°",
            lnap: "âª‰",
            lnapprox: "âª‰",
            lnE: "â‰¨",
            lne: "âª‡",
            lneq: "âª‡",
            lneqq: "â‰¨",
            lnsim: "â‹¦",
            loang: "âŸ¬",
            loarr: "â‡½",
            lobrk: "âŸ¦",
            LongLeftArrow: "âŸµ",
            Longleftarrow: "âŸ¸",
            longleftarrow: "âŸµ",
            LongLeftRightArrow: "âŸ·",
            Longleftrightarrow: "âŸº",
            longleftrightarrow: "âŸ·",
            longmapsto: "âŸ¼",
            LongRightArrow: "âŸ¶",
            Longrightarrow: "âŸ¹",
            longrightarrow: "âŸ¶",
            looparrowleft: "â†«",
            looparrowright: "â†¬",
            lopar: "â¦…",
            Lopf: "ð•ƒ",
            lopf: "ð•",
            loplus: "â¨­",
            lotimes: "â¨´",
            lowast: "âˆ—",
            lowbar: "_",
            LowerLeftArrow: "â†™",
            LowerRightArrow: "â†˜",
            loz: "â—Š",
            lozenge: "â—Š",
            lozf: "â§«",
            lpar: "(",
            lparlt: "â¦“",
            lrarr: "â‡†",
            lrcorner: "âŒŸ",
            lrhar: "â‡‹",
            lrhard: "â¥­",
            lrm: "â€Ž",
            lrtri: "âŠ¿",
            lsaquo: "â€¹",
            Lscr: "â„’",
            lscr: "ð“",
            Lsh: "â†°",
            lsh: "â†°",
            lsim: "â‰²",
            lsime: "âª",
            lsimg: "âª",
            lsqb: "[",
            lsquo: "â€˜",
            lsquor: "â€š",
            Lstrok: "Å",
            lstrok: "Å‚",
            Lt: "â‰ª",
            LT: "<",
            lt: "<",
            ltcc: "âª¦",
            ltcir: "â©¹",
            ltdot: "â‹–",
            lthree: "â‹‹",
            ltimes: "â‹‰",
            ltlarr: "â¥¶",
            ltquest: "â©»",
            ltri: "â—ƒ",
            ltrie: "âŠ´",
            ltrif: "â—‚",
            ltrPar: "â¦–",
            lurdshar: "â¥Š",
            luruhar: "â¥¦",
            lvertneqq: "â‰¨ï¸€",
            lvnE: "â‰¨ï¸€",
            macr: "Â¯",
            male: "â™‚",
            malt: "âœ ",
            maltese: "âœ ",
            Map: "â¤…",
            map: "â†¦",
            mapsto: "â†¦",
            mapstodown: "â†§",
            mapstoleft: "â†¤",
            mapstoup: "â†¥",
            marker: "â–®",
            mcomma: "â¨©",
            Mcy: "Ðœ",
            mcy: "Ð¼",
            mdash: "â€”",
            mDDot: "âˆº",
            measuredangle: "âˆ¡",
            MediumSpace: "âŸ",
            Mellintrf: "â„³",
            Mfr: "ð”",
            mfr: "ð”ª",
            mho: "â„§",
            micro: "Âµ",
            mid: "âˆ£",
            midast: "*",
            midcir: "â«°",
            middot: "Â·",
            minus: "âˆ’",
            minusb: "âŠŸ",
            minusd: "âˆ¸",
            minusdu: "â¨ª",
            MinusPlus: "âˆ“",
            mlcp: "â«›",
            mldr: "â€¦",
            mnplus: "âˆ“",
            models: "âŠ§",
            Mopf: "ð•„",
            mopf: "ð•ž",
            mp: "âˆ“",
            Mscr: "â„³",
            mscr: "ð“‚",
            mstpos: "âˆ¾",
            Mu: "Îœ",
            mu: "Î¼",
            multimap: "âŠ¸",
            mumap: "âŠ¸",
            nabla: "âˆ‡",
            Nacute: "Åƒ",
            nacute: "Å„",
            nang: "âˆ âƒ’",
            nap: "â‰‰",
            napE: "â©°Ì¸",
            napid: "â‰‹Ì¸",
            napos: "Å‰",
            napprox: "â‰‰",
            natur: "â™®",
            natural: "â™®",
            naturals: "â„•",
            nbsp: "Â ",
            nbump: "â‰ŽÌ¸",
            nbumpe: "â‰Ì¸",
            ncap: "â©ƒ",
            Ncaron: "Å‡",
            ncaron: "Åˆ",
            Ncedil: "Å…",
            ncedil: "Å†",
            ncong: "â‰‡",
            ncongdot: "â©­Ì¸",
            ncup: "â©‚",
            Ncy: "Ð",
            ncy: "Ð½",
            ndash: "â€“",
            ne: "â‰ ",
            nearhk: "â¤¤",
            neArr: "â‡—",
            nearr: "â†—",
            nearrow: "â†—",
            nedot: "â‰Ì¸",
            NegativeMediumSpace: "â€‹",
            NegativeThickSpace: "â€‹",
            NegativeThinSpace: "â€‹",
            NegativeVeryThinSpace: "â€‹",
            nequiv: "â‰¢",
            nesear: "â¤¨",
            nesim: "â‰‚Ì¸",
            NestedGreaterGreater: "â‰«",
            NestedLessLess: "â‰ª",
            NewLine: `
`,
            nexist: "âˆ„",
            nexists: "âˆ„",
            Nfr: "ð”‘",
            nfr: "ð”«",
            ngE: "â‰§Ì¸",
            nge: "â‰±",
            ngeq: "â‰±",
            ngeqq: "â‰§Ì¸",
            ngeqslant: "â©¾Ì¸",
            nges: "â©¾Ì¸",
            nGg: "â‹™Ì¸",
            ngsim: "â‰µ",
            nGt: "â‰«âƒ’",
            ngt: "â‰¯",
            ngtr: "â‰¯",
            nGtv: "â‰«Ì¸",
            nhArr: "â‡Ž",
            nharr: "â†®",
            nhpar: "â«²",
            ni: "âˆ‹",
            nis: "â‹¼",
            nisd: "â‹º",
            niv: "âˆ‹",
            NJcy: "ÐŠ",
            njcy: "Ñš",
            nlArr: "â‡",
            nlarr: "â†š",
            nldr: "â€¥",
            nlE: "â‰¦Ì¸",
            nle: "â‰°",
            nLeftarrow: "â‡",
            nleftarrow: "â†š",
            nLeftrightarrow: "â‡Ž",
            nleftrightarrow: "â†®",
            nleq: "â‰°",
            nleqq: "â‰¦Ì¸",
            nleqslant: "â©½Ì¸",
            nles: "â©½Ì¸",
            nless: "â‰®",
            nLl: "â‹˜Ì¸",
            nlsim: "â‰´",
            nLt: "â‰ªâƒ’",
            nlt: "â‰®",
            nltri: "â‹ª",
            nltrie: "â‹¬",
            nLtv: "â‰ªÌ¸",
            nmid: "âˆ¤",
            NoBreak: "â ",
            NonBreakingSpace: "Â ",
            Nopf: "â„•",
            nopf: "ð•Ÿ",
            Not: "â«¬",
            not: "Â¬",
            NotCongruent: "â‰¢",
            NotCupCap: "â‰­",
            NotDoubleVerticalBar: "âˆ¦",
            NotElement: "âˆ‰",
            NotEqual: "â‰ ",
            NotEqualTilde: "â‰‚Ì¸",
            NotExists: "âˆ„",
            NotGreater: "â‰¯",
            NotGreaterEqual: "â‰±",
            NotGreaterFullEqual: "â‰§Ì¸",
            NotGreaterGreater: "â‰«Ì¸",
            NotGreaterLess: "â‰¹",
            NotGreaterSlantEqual: "â©¾Ì¸",
            NotGreaterTilde: "â‰µ",
            NotHumpDownHump: "â‰ŽÌ¸",
            NotHumpEqual: "â‰Ì¸",
            notin: "âˆ‰",
            notindot: "â‹µÌ¸",
            notinE: "â‹¹Ì¸",
            notinva: "âˆ‰",
            notinvb: "â‹·",
            notinvc: "â‹¶",
            NotLeftTriangle: "â‹ª",
            NotLeftTriangleBar: "â§Ì¸",
            NotLeftTriangleEqual: "â‹¬",
            NotLess: "â‰®",
            NotLessEqual: "â‰°",
            NotLessGreater: "â‰¸",
            NotLessLess: "â‰ªÌ¸",
            NotLessSlantEqual: "â©½Ì¸",
            NotLessTilde: "â‰´",
            NotNestedGreaterGreater: "âª¢Ì¸",
            NotNestedLessLess: "âª¡Ì¸",
            notni: "âˆŒ",
            notniva: "âˆŒ",
            notnivb: "â‹¾",
            notnivc: "â‹½",
            NotPrecedes: "âŠ€",
            NotPrecedesEqual: "âª¯Ì¸",
            NotPrecedesSlantEqual: "â‹ ",
            NotReverseElement: "âˆŒ",
            NotRightTriangle: "â‹«",
            NotRightTriangleBar: "â§Ì¸",
            NotRightTriangleEqual: "â‹­",
            NotSquareSubset: "âŠÌ¸",
            NotSquareSubsetEqual: "â‹¢",
            NotSquareSuperset: "âŠÌ¸",
            NotSquareSupersetEqual: "â‹£",
            NotSubset: "âŠ‚âƒ’",
            NotSubsetEqual: "âŠˆ",
            NotSucceeds: "âŠ",
            NotSucceedsEqual: "âª°Ì¸",
            NotSucceedsSlantEqual: "â‹¡",
            NotSucceedsTilde: "â‰¿Ì¸",
            NotSuperset: "âŠƒâƒ’",
            NotSupersetEqual: "âŠ‰",
            NotTilde: "â‰",
            NotTildeEqual: "â‰„",
            NotTildeFullEqual: "â‰‡",
            NotTildeTilde: "â‰‰",
            NotVerticalBar: "âˆ¤",
            npar: "âˆ¦",
            nparallel: "âˆ¦",
            nparsl: "â«½âƒ¥",
            npart: "âˆ‚Ì¸",
            npolint: "â¨”",
            npr: "âŠ€",
            nprcue: "â‹ ",
            npre: "âª¯Ì¸",
            nprec: "âŠ€",
            npreceq: "âª¯Ì¸",
            nrArr: "â‡",
            nrarr: "â†›",
            nrarrc: "â¤³Ì¸",
            nrarrw: "â†Ì¸",
            nRightarrow: "â‡",
            nrightarrow: "â†›",
            nrtri: "â‹«",
            nrtrie: "â‹­",
            nsc: "âŠ",
            nsccue: "â‹¡",
            nsce: "âª°Ì¸",
            Nscr: "ð’©",
            nscr: "ð“ƒ",
            nshortmid: "âˆ¤",
            nshortparallel: "âˆ¦",
            nsim: "â‰",
            nsime: "â‰„",
            nsimeq: "â‰„",
            nsmid: "âˆ¤",
            nspar: "âˆ¦",
            nsqsube: "â‹¢",
            nsqsupe: "â‹£",
            nsub: "âŠ„",
            nsubE: "â«…Ì¸",
            nsube: "âŠˆ",
            nsubset: "âŠ‚âƒ’",
            nsubseteq: "âŠˆ",
            nsubseteqq: "â«…Ì¸",
            nsucc: "âŠ",
            nsucceq: "âª°Ì¸",
            nsup: "âŠ…",
            nsupE: "â«†Ì¸",
            nsupe: "âŠ‰",
            nsupset: "âŠƒâƒ’",
            nsupseteq: "âŠ‰",
            nsupseteqq: "â«†Ì¸",
            ntgl: "â‰¹",
            Ntilde: "Ã‘",
            ntilde: "Ã±",
            ntlg: "â‰¸",
            ntriangleleft: "â‹ª",
            ntrianglelefteq: "â‹¬",
            ntriangleright: "â‹«",
            ntrianglerighteq: "â‹­",
            Nu: "Î",
            nu: "Î½",
            num: "#",
            numero: "â„–",
            numsp: "â€‡",
            nvap: "â‰âƒ’",
            nVDash: "âŠ¯",
            nVdash: "âŠ®",
            nvDash: "âŠ­",
            nvdash: "âŠ¬",
            nvge: "â‰¥âƒ’",
            nvgt: ">âƒ’",
            nvHarr: "â¤„",
            nvinfin: "â§ž",
            nvlArr: "â¤‚",
            nvle: "â‰¤âƒ’",
            nvlt: "<âƒ’",
            nvltrie: "âŠ´âƒ’",
            nvrArr: "â¤ƒ",
            nvrtrie: "âŠµâƒ’",
            nvsim: "âˆ¼âƒ’",
            nwarhk: "â¤£",
            nwArr: "â‡–",
            nwarr: "â†–",
            nwarrow: "â†–",
            nwnear: "â¤§",
            Oacute: "Ã“",
            oacute: "Ã³",
            oast: "âŠ›",
            ocir: "âŠš",
            Ocirc: "Ã”",
            ocirc: "Ã´",
            Ocy: "Ðž",
            ocy: "Ð¾",
            odash: "âŠ",
            Odblac: "Å",
            odblac: "Å‘",
            odiv: "â¨¸",
            odot: "âŠ™",
            odsold: "â¦¼",
            OElig: "Å’",
            oelig: "Å“",
            ofcir: "â¦¿",
            Ofr: "ð”’",
            ofr: "ð”¬",
            ogon: "Ë›",
            Ograve: "Ã’",
            ograve: "Ã²",
            ogt: "â§",
            ohbar: "â¦µ",
            ohm: "Î©",
            oint: "âˆ®",
            olarr: "â†º",
            olcir: "â¦¾",
            olcross: "â¦»",
            oline: "â€¾",
            olt: "â§€",
            Omacr: "ÅŒ",
            omacr: "Å",
            Omega: "Î©",
            omega: "Ï‰",
            Omicron: "ÎŸ",
            omicron: "Î¿",
            omid: "â¦¶",
            ominus: "âŠ–",
            Oopf: "ð•†",
            oopf: "ð• ",
            opar: "â¦·",
            OpenCurlyDoubleQuote: "â€œ",
            OpenCurlyQuote: "â€˜",
            operp: "â¦¹",
            oplus: "âŠ•",
            Or: "â©”",
            or: "âˆ¨",
            orarr: "â†»",
            ord: "â©",
            order: "â„´",
            orderof: "â„´",
            ordf: "Âª",
            ordm: "Âº",
            origof: "âŠ¶",
            oror: "â©–",
            orslope: "â©—",
            orv: "â©›",
            oS: "â“ˆ",
            Oscr: "ð’ª",
            oscr: "â„´",
            Oslash: "Ã˜",
            oslash: "Ã¸",
            osol: "âŠ˜",
            Otilde: "Ã•",
            otilde: "Ãµ",
            Otimes: "â¨·",
            otimes: "âŠ—",
            otimesas: "â¨¶",
            Ouml: "Ã–",
            ouml: "Ã¶",
            ovbar: "âŒ½",
            OverBar: "â€¾",
            OverBrace: "âž",
            OverBracket: "âŽ´",
            OverParenthesis: "âœ",
            par: "âˆ¥",
            para: "Â¶",
            parallel: "âˆ¥",
            parsim: "â«³",
            parsl: "â«½",
            part: "âˆ‚",
            PartialD: "âˆ‚",
            Pcy: "ÐŸ",
            pcy: "Ð¿",
            percnt: "%",
            period: ".",
            permil: "â€°",
            perp: "âŠ¥",
            pertenk: "â€±",
            Pfr: "ð”“",
            pfr: "ð”­",
            Phi: "Î¦",
            phi: "Ï†",
            phiv: "Ï•",
            phmmat: "â„³",
            phone: "â˜Ž",
            Pi: "Î ",
            pi: "Ï€",
            pitchfork: "â‹”",
            piv: "Ï–",
            planck: "â„",
            planckh: "â„Ž",
            plankv: "â„",
            plus: "+",
            plusacir: "â¨£",
            plusb: "âŠž",
            pluscir: "â¨¢",
            plusdo: "âˆ”",
            plusdu: "â¨¥",
            pluse: "â©²",
            PlusMinus: "Â±",
            plusmn: "Â±",
            plussim: "â¨¦",
            plustwo: "â¨§",
            pm: "Â±",
            Poincareplane: "â„Œ",
            pointint: "â¨•",
            Popf: "â„™",
            popf: "ð•¡",
            pound: "Â£",
            Pr: "âª»",
            pr: "â‰º",
            prap: "âª·",
            prcue: "â‰¼",
            prE: "âª³",
            pre: "âª¯",
            prec: "â‰º",
            precapprox: "âª·",
            preccurlyeq: "â‰¼",
            Precedes: "â‰º",
            PrecedesEqual: "âª¯",
            PrecedesSlantEqual: "â‰¼",
            PrecedesTilde: "â‰¾",
            preceq: "âª¯",
            precnapprox: "âª¹",
            precneqq: "âªµ",
            precnsim: "â‹¨",
            precsim: "â‰¾",
            Prime: "â€³",
            prime: "â€²",
            primes: "â„™",
            prnap: "âª¹",
            prnE: "âªµ",
            prnsim: "â‹¨",
            prod: "âˆ",
            Product: "âˆ",
            profalar: "âŒ®",
            profline: "âŒ’",
            profsurf: "âŒ“",
            prop: "âˆ",
            Proportion: "âˆ·",
            Proportional: "âˆ",
            propto: "âˆ",
            prsim: "â‰¾",
            prurel: "âŠ°",
            Pscr: "ð’«",
            pscr: "ð“…",
            Psi: "Î¨",
            psi: "Ïˆ",
            puncsp: "â€ˆ",
            Qfr: "ð””",
            qfr: "ð”®",
            qint: "â¨Œ",
            Qopf: "â„š",
            qopf: "ð•¢",
            qprime: "â—",
            Qscr: "ð’¬",
            qscr: "ð“†",
            quaternions: "â„",
            quatint: "â¨–",
            quest: "?",
            questeq: "â‰Ÿ",
            QUOT: '"',
            quot: '"',
            rAarr: "â‡›",
            race: "âˆ½Ì±",
            Racute: "Å”",
            racute: "Å•",
            radic: "âˆš",
            raemptyv: "â¦³",
            Rang: "âŸ«",
            rang: "âŸ©",
            rangd: "â¦’",
            range: "â¦¥",
            rangle: "âŸ©",
            raquo: "Â»",
            Rarr: "â† ",
            rArr: "â‡’",
            rarr: "â†’",
            rarrap: "â¥µ",
            rarrb: "â‡¥",
            rarrbfs: "â¤ ",
            rarrc: "â¤³",
            rarrfs: "â¤ž",
            rarrhk: "â†ª",
            rarrlp: "â†¬",
            rarrpl: "â¥…",
            rarrsim: "â¥´",
            Rarrtl: "â¤–",
            rarrtl: "â†£",
            rarrw: "â†",
            rAtail: "â¤œ",
            ratail: "â¤š",
            ratio: "âˆ¶",
            rationals: "â„š",
            RBarr: "â¤",
            rBarr: "â¤",
            rbarr: "â¤",
            rbbrk: "â³",
            rbrace: "}",
            rbrack: "]",
            rbrke: "â¦Œ",
            rbrksld: "â¦Ž",
            rbrkslu: "â¦",
            Rcaron: "Å˜",
            rcaron: "Å™",
            Rcedil: "Å–",
            rcedil: "Å—",
            rceil: "âŒ‰",
            rcub: "}",
            Rcy: "Ð ",
            rcy: "Ñ€",
            rdca: "â¤·",
            rdldhar: "â¥©",
            rdquo: "â€",
            rdquor: "â€",
            rdsh: "â†³",
            Re: "â„œ",
            real: "â„œ",
            realine: "â„›",
            realpart: "â„œ",
            reals: "â„",
            rect: "â–­",
            REG: "Â®",
            reg: "Â®",
            ReverseElement: "âˆ‹",
            ReverseEquilibrium: "â‡‹",
            ReverseUpEquilibrium: "â¥¯",
            rfisht: "â¥½",
            rfloor: "âŒ‹",
            Rfr: "â„œ",
            rfr: "ð”¯",
            rHar: "â¥¤",
            rhard: "â‡",
            rharu: "â‡€",
            rharul: "â¥¬",
            Rho: "Î¡",
            rho: "Ï",
            rhov: "Ï±",
            RightAngleBracket: "âŸ©",
            RightArrow: "â†’",
            Rightarrow: "â‡’",
            rightarrow: "â†’",
            RightArrowBar: "â‡¥",
            RightArrowLeftArrow: "â‡„",
            rightarrowtail: "â†£",
            RightCeiling: "âŒ‰",
            RightDoubleBracket: "âŸ§",
            RightDownTeeVector: "â¥",
            RightDownVector: "â‡‚",
            RightDownVectorBar: "â¥•",
            RightFloor: "âŒ‹",
            rightharpoondown: "â‡",
            rightharpoonup: "â‡€",
            rightleftarrows: "â‡„",
            rightleftharpoons: "â‡Œ",
            rightrightarrows: "â‡‰",
            rightsquigarrow: "â†",
            RightTee: "âŠ¢",
            RightTeeArrow: "â†¦",
            RightTeeVector: "â¥›",
            rightthreetimes: "â‹Œ",
            RightTriangle: "âŠ³",
            RightTriangleBar: "â§",
            RightTriangleEqual: "âŠµ",
            RightUpDownVector: "â¥",
            RightUpTeeVector: "â¥œ",
            RightUpVector: "â†¾",
            RightUpVectorBar: "â¥”",
            RightVector: "â‡€",
            RightVectorBar: "â¥“",
            ring: "Ëš",
            risingdotseq: "â‰“",
            rlarr: "â‡„",
            rlhar: "â‡Œ",
            rlm: "â€",
            rmoust: "âŽ±",
            rmoustache: "âŽ±",
            rnmid: "â«®",
            roang: "âŸ­",
            roarr: "â‡¾",
            robrk: "âŸ§",
            ropar: "â¦†",
            Ropf: "â„",
            ropf: "ð•£",
            roplus: "â¨®",
            rotimes: "â¨µ",
            RoundImplies: "â¥°",
            rpar: ")",
            rpargt: "â¦”",
            rppolint: "â¨’",
            rrarr: "â‡‰",
            Rrightarrow: "â‡›",
            rsaquo: "â€º",
            Rscr: "â„›",
            rscr: "ð“‡",
            Rsh: "â†±",
            rsh: "â†±",
            rsqb: "]",
            rsquo: "â€™",
            rsquor: "â€™",
            rthree: "â‹Œ",
            rtimes: "â‹Š",
            rtri: "â–¹",
            rtrie: "âŠµ",
            rtrif: "â–¸",
            rtriltri: "â§Ž",
            RuleDelayed: "â§´",
            ruluhar: "â¥¨",
            rx: "â„ž",
            Sacute: "Åš",
            sacute: "Å›",
            sbquo: "â€š",
            Sc: "âª¼",
            sc: "â‰»",
            scap: "âª¸",
            Scaron: "Å ",
            scaron: "Å¡",
            sccue: "â‰½",
            scE: "âª´",
            sce: "âª°",
            Scedil: "Åž",
            scedil: "ÅŸ",
            Scirc: "Åœ",
            scirc: "Å",
            scnap: "âªº",
            scnE: "âª¶",
            scnsim: "â‹©",
            scpolint: "â¨“",
            scsim: "â‰¿",
            Scy: "Ð¡",
            scy: "Ñ",
            sdot: "â‹…",
            sdotb: "âŠ¡",
            sdote: "â©¦",
            searhk: "â¤¥",
            seArr: "â‡˜",
            searr: "â†˜",
            searrow: "â†˜",
            sect: "Â§",
            semi: ";",
            seswar: "â¤©",
            setminus: "âˆ–",
            setmn: "âˆ–",
            sext: "âœ¶",
            Sfr: "ð”–",
            sfr: "ð”°",
            sfrown: "âŒ¢",
            sharp: "â™¯",
            SHCHcy: "Ð©",
            shchcy: "Ñ‰",
            SHcy: "Ð¨",
            shcy: "Ñˆ",
            ShortDownArrow: "â†“",
            ShortLeftArrow: "â†",
            shortmid: "âˆ£",
            shortparallel: "âˆ¥",
            ShortRightArrow: "â†’",
            ShortUpArrow: "â†‘",
            shy: "Â­",
            Sigma: "Î£",
            sigma: "Ïƒ",
            sigmaf: "Ï‚",
            sigmav: "Ï‚",
            sim: "âˆ¼",
            simdot: "â©ª",
            sime: "â‰ƒ",
            simeq: "â‰ƒ",
            simg: "âªž",
            simgE: "âª ",
            siml: "âª",
            simlE: "âªŸ",
            simne: "â‰†",
            simplus: "â¨¤",
            simrarr: "â¥²",
            slarr: "â†",
            SmallCircle: "âˆ˜",
            smallsetminus: "âˆ–",
            smashp: "â¨³",
            smeparsl: "â§¤",
            smid: "âˆ£",
            smile: "âŒ£",
            smt: "âªª",
            smte: "âª¬",
            smtes: "âª¬ï¸€",
            SOFTcy: "Ð¬",
            softcy: "ÑŒ",
            sol: "/",
            solb: "â§„",
            solbar: "âŒ¿",
            Sopf: "ð•Š",
            sopf: "ð•¤",
            spades: "â™ ",
            spadesuit: "â™ ",
            spar: "âˆ¥",
            sqcap: "âŠ“",
            sqcaps: "âŠ“ï¸€",
            sqcup: "âŠ”",
            sqcups: "âŠ”ï¸€",
            Sqrt: "âˆš",
            sqsub: "âŠ",
            sqsube: "âŠ‘",
            sqsubset: "âŠ",
            sqsubseteq: "âŠ‘",
            sqsup: "âŠ",
            sqsupe: "âŠ’",
            sqsupset: "âŠ",
            sqsupseteq: "âŠ’",
            squ: "â–¡",
            Square: "â–¡",
            square: "â–¡",
            SquareIntersection: "âŠ“",
            SquareSubset: "âŠ",
            SquareSubsetEqual: "âŠ‘",
            SquareSuperset: "âŠ",
            SquareSupersetEqual: "âŠ’",
            SquareUnion: "âŠ”",
            squarf: "â–ª",
            squf: "â–ª",
            srarr: "â†’",
            Sscr: "ð’®",
            sscr: "ð“ˆ",
            ssetmn: "âˆ–",
            ssmile: "âŒ£",
            sstarf: "â‹†",
            Star: "â‹†",
            star: "â˜†",
            starf: "â˜…",
            straightepsilon: "Ïµ",
            straightphi: "Ï•",
            strns: "Â¯",
            Sub: "â‹",
            sub: "âŠ‚",
            subdot: "âª½",
            subE: "â«…",
            sube: "âŠ†",
            subedot: "â«ƒ",
            submult: "â«",
            subnE: "â«‹",
            subne: "âŠŠ",
            subplus: "âª¿",
            subrarr: "â¥¹",
            Subset: "â‹",
            subset: "âŠ‚",
            subseteq: "âŠ†",
            subseteqq: "â«…",
            SubsetEqual: "âŠ†",
            subsetneq: "âŠŠ",
            subsetneqq: "â«‹",
            subsim: "â«‡",
            subsub: "â«•",
            subsup: "â«“",
            succ: "â‰»",
            succapprox: "âª¸",
            succcurlyeq: "â‰½",
            Succeeds: "â‰»",
            SucceedsEqual: "âª°",
            SucceedsSlantEqual: "â‰½",
            SucceedsTilde: "â‰¿",
            succeq: "âª°",
            succnapprox: "âªº",
            succneqq: "âª¶",
            succnsim: "â‹©",
            succsim: "â‰¿",
            SuchThat: "âˆ‹",
            Sum: "âˆ‘",
            sum: "âˆ‘",
            sung: "â™ª",
            Sup: "â‹‘",
            sup: "âŠƒ",
            sup1: "Â¹",
            sup2: "Â²",
            sup3: "Â³",
            supdot: "âª¾",
            supdsub: "â«˜",
            supE: "â«†",
            supe: "âŠ‡",
            supedot: "â«„",
            Superset: "âŠƒ",
            SupersetEqual: "âŠ‡",
            suphsol: "âŸ‰",
            suphsub: "â«—",
            suplarr: "â¥»",
            supmult: "â«‚",
            supnE: "â«Œ",
            supne: "âŠ‹",
            supplus: "â«€",
            Supset: "â‹‘",
            supset: "âŠƒ",
            supseteq: "âŠ‡",
            supseteqq: "â«†",
            supsetneq: "âŠ‹",
            supsetneqq: "â«Œ",
            supsim: "â«ˆ",
            supsub: "â«”",
            supsup: "â«–",
            swarhk: "â¤¦",
            swArr: "â‡™",
            swarr: "â†™",
            swarrow: "â†™",
            swnwar: "â¤ª",
            szlig: "ÃŸ",
            Tab: "	",
            target: "âŒ–",
            Tau: "Î¤",
            tau: "Ï„",
            tbrk: "âŽ´",
            Tcaron: "Å¤",
            tcaron: "Å¥",
            Tcedil: "Å¢",
            tcedil: "Å£",
            Tcy: "Ð¢",
            tcy: "Ñ‚",
            tdot: "âƒ›",
            telrec: "âŒ•",
            Tfr: "ð”—",
            tfr: "ð”±",
            there4: "âˆ´",
            Therefore: "âˆ´",
            therefore: "âˆ´",
            Theta: "Î˜",
            theta: "Î¸",
            thetasym: "Ï‘",
            thetav: "Ï‘",
            thickapprox: "â‰ˆ",
            thicksim: "âˆ¼",
            ThickSpace: "âŸâ€Š",
            thinsp: "â€‰",
            ThinSpace: "â€‰",
            thkap: "â‰ˆ",
            thksim: "âˆ¼",
            THORN: "Ãž",
            thorn: "Ã¾",
            Tilde: "âˆ¼",
            tilde: "Ëœ",
            TildeEqual: "â‰ƒ",
            TildeFullEqual: "â‰…",
            TildeTilde: "â‰ˆ",
            times: "Ã—",
            timesb: "âŠ ",
            timesbar: "â¨±",
            timesd: "â¨°",
            tint: "âˆ­",
            toea: "â¤¨",
            top: "âŠ¤",
            topbot: "âŒ¶",
            topcir: "â«±",
            Topf: "ð•‹",
            topf: "ð•¥",
            topfork: "â«š",
            tosa: "â¤©",
            tprime: "â€´",
            TRADE: "â„¢",
            trade: "â„¢",
            triangle: "â–µ",
            triangledown: "â–¿",
            triangleleft: "â—ƒ",
            trianglelefteq: "âŠ´",
            triangleq: "â‰œ",
            triangleright: "â–¹",
            trianglerighteq: "âŠµ",
            tridot: "â—¬",
            trie: "â‰œ",
            triminus: "â¨º",
            TripleDot: "âƒ›",
            triplus: "â¨¹",
            trisb: "â§",
            tritime: "â¨»",
            trpezium: "â¢",
            Tscr: "ð’¯",
            tscr: "ð“‰",
            TScy: "Ð¦",
            tscy: "Ñ†",
            TSHcy: "Ð‹",
            tshcy: "Ñ›",
            Tstrok: "Å¦",
            tstrok: "Å§",
            twixt: "â‰¬",
            twoheadleftarrow: "â†ž",
            twoheadrightarrow: "â† ",
            Uacute: "Ãš",
            uacute: "Ãº",
            Uarr: "â†Ÿ",
            uArr: "â‡‘",
            uarr: "â†‘",
            Uarrocir: "â¥‰",
            Ubrcy: "ÐŽ",
            ubrcy: "Ñž",
            Ubreve: "Å¬",
            ubreve: "Å­",
            Ucirc: "Ã›",
            ucirc: "Ã»",
            Ucy: "Ð£",
            ucy: "Ñƒ",
            udarr: "â‡…",
            Udblac: "Å°",
            udblac: "Å±",
            udhar: "â¥®",
            ufisht: "â¥¾",
            Ufr: "ð”˜",
            ufr: "ð”²",
            Ugrave: "Ã™",
            ugrave: "Ã¹",
            uHar: "â¥£",
            uharl: "â†¿",
            uharr: "â†¾",
            uhblk: "â–€",
            ulcorn: "âŒœ",
            ulcorner: "âŒœ",
            ulcrop: "âŒ",
            ultri: "â—¸",
            Umacr: "Åª",
            umacr: "Å«",
            uml: "Â¨",
            UnderBar: "_",
            UnderBrace: "âŸ",
            UnderBracket: "âŽµ",
            UnderParenthesis: "â",
            Union: "â‹ƒ",
            UnionPlus: "âŠŽ",
            Uogon: "Å²",
            uogon: "Å³",
            Uopf: "ð•Œ",
            uopf: "ð•¦",
            UpArrow: "â†‘",
            Uparrow: "â‡‘",
            uparrow: "â†‘",
            UpArrowBar: "â¤’",
            UpArrowDownArrow: "â‡…",
            UpDownArrow: "â†•",
            Updownarrow: "â‡•",
            updownarrow: "â†•",
            UpEquilibrium: "â¥®",
            upharpoonleft: "â†¿",
            upharpoonright: "â†¾",
            uplus: "âŠŽ",
            UpperLeftArrow: "â†–",
            UpperRightArrow: "â†—",
            Upsi: "Ï’",
            upsi: "Ï…",
            upsih: "Ï’",
            Upsilon: "Î¥",
            upsilon: "Ï…",
            UpTee: "âŠ¥",
            UpTeeArrow: "â†¥",
            upuparrows: "â‡ˆ",
            urcorn: "âŒ",
            urcorner: "âŒ",
            urcrop: "âŒŽ",
            Uring: "Å®",
            uring: "Å¯",
            urtri: "â—¹",
            Uscr: "ð’°",
            uscr: "ð“Š",
            utdot: "â‹°",
            Utilde: "Å¨",
            utilde: "Å©",
            utri: "â–µ",
            utrif: "â–´",
            uuarr: "â‡ˆ",
            Uuml: "Ãœ",
            uuml: "Ã¼",
            uwangle: "â¦§",
            vangrt: "â¦œ",
            varepsilon: "Ïµ",
            varkappa: "Ï°",
            varnothing: "âˆ…",
            varphi: "Ï•",
            varpi: "Ï–",
            varpropto: "âˆ",
            vArr: "â‡•",
            varr: "â†•",
            varrho: "Ï±",
            varsigma: "Ï‚",
            varsubsetneq: "âŠŠï¸€",
            varsubsetneqq: "â«‹ï¸€",
            varsupsetneq: "âŠ‹ï¸€",
            varsupsetneqq: "â«Œï¸€",
            vartheta: "Ï‘",
            vartriangleleft: "âŠ²",
            vartriangleright: "âŠ³",
            Vbar: "â««",
            vBar: "â«¨",
            vBarv: "â«©",
            Vcy: "Ð’",
            vcy: "Ð²",
            VDash: "âŠ«",
            Vdash: "âŠ©",
            vDash: "âŠ¨",
            vdash: "âŠ¢",
            Vdashl: "â«¦",
            Vee: "â‹",
            vee: "âˆ¨",
            veebar: "âŠ»",
            veeeq: "â‰š",
            vellip: "â‹®",
            Verbar: "â€–",
            verbar: "|",
            Vert: "â€–",
            vert: "|",
            VerticalBar: "âˆ£",
            VerticalLine: "|",
            VerticalSeparator: "â˜",
            VerticalTilde: "â‰€",
            VeryThinSpace: "â€Š",
            Vfr: "ð”™",
            vfr: "ð”³",
            vltri: "âŠ²",
            vnsub: "âŠ‚âƒ’",
            vnsup: "âŠƒâƒ’",
            Vopf: "ð•",
            vopf: "ð•§",
            vprop: "âˆ",
            vrtri: "âŠ³",
            Vscr: "ð’±",
            vscr: "ð“‹",
            vsubnE: "â«‹ï¸€",
            vsubne: "âŠŠï¸€",
            vsupnE: "â«Œï¸€",
            vsupne: "âŠ‹ï¸€",
            Vvdash: "âŠª",
            vzigzag: "â¦š",
            Wcirc: "Å´",
            wcirc: "Åµ",
            wedbar: "â©Ÿ",
            Wedge: "â‹€",
            wedge: "âˆ§",
            wedgeq: "â‰™",
            weierp: "â„˜",
            Wfr: "ð”š",
            wfr: "ð”´",
            Wopf: "ð•Ž",
            wopf: "ð•¨",
            wp: "â„˜",
            wr: "â‰€",
            wreath: "â‰€",
            Wscr: "ð’²",
            wscr: "ð“Œ",
            xcap: "â‹‚",
            xcirc: "â—¯",
            xcup: "â‹ƒ",
            xdtri: "â–½",
            Xfr: "ð”›",
            xfr: "ð”µ",
            xhArr: "âŸº",
            xharr: "âŸ·",
            Xi: "Îž",
            xi: "Î¾",
            xlArr: "âŸ¸",
            xlarr: "âŸµ",
            xmap: "âŸ¼",
            xnis: "â‹»",
            xodot: "â¨€",
            Xopf: "ð•",
            xopf: "ð•©",
            xoplus: "â¨",
            xotime: "â¨‚",
            xrArr: "âŸ¹",
            xrarr: "âŸ¶",
            Xscr: "ð’³",
            xscr: "ð“",
            xsqcup: "â¨†",
            xuplus: "â¨„",
            xutri: "â–³",
            xvee: "â‹",
            xwedge: "â‹€",
            Yacute: "Ã",
            yacute: "Ã½",
            YAcy: "Ð¯",
            yacy: "Ñ",
            Ycirc: "Å¶",
            ycirc: "Å·",
            Ycy: "Ð«",
            ycy: "Ñ‹",
            yen: "Â¥",
            Yfr: "ð”œ",
            yfr: "ð”¶",
            YIcy: "Ð‡",
            yicy: "Ñ—",
            Yopf: "ð•",
            yopf: "ð•ª",
            Yscr: "ð’´",
            yscr: "ð“Ž",
            YUcy: "Ð®",
            yucy: "ÑŽ",
            Yuml: "Å¸",
            yuml: "Ã¿",
            Zacute: "Å¹",
            zacute: "Åº",
            Zcaron: "Å½",
            zcaron: "Å¾",
            Zcy: "Ð—",
            zcy: "Ð·",
            Zdot: "Å»",
            zdot: "Å¼",
            zeetrf: "â„¨",
            ZeroWidthSpace: "â€‹",
            Zeta: "Î–",
            zeta: "Î¶",
            Zfr: "â„¨",
            zfr: "ð”·",
            ZHcy: "Ð–",
            zhcy: "Ð¶",
            zigrarr: "â‡",
            Zopf: "â„¤",
            zopf: "ð•«",
            Zscr: "ð’µ",
            zscr: "ð“",
            zwj: "â€",
            zwnj: "â€Œ"
        }), t.entityMap = t.HTML_ENTITIES;
    }(kt)), kt;
}
var yt = {}, or;
function An() {
    if (or)
        return yt;
    or = 1;
    var t = Dt(), e = Fr(), n = _t(), i = t.isHTMLEscapableRawTextElement, o = t.isHTMLMimeType, a = t.isHTMLRawTextElement, h = t.hasOwn, p = t.NAMESPACE, f = n.ParseError, m = n.DOMException, E = 0, l = 1, v = 2, O = 3, b = 4, C = 5, j = 6, R = 7;
    function k() {
    }
    k.prototype = {
        parse: function (d, N, w) {
            var y = this.domBuilder;
            y.startDocument(), G(N, N = /* @__PURE__ */ Object.create(null)), ne(d, N, w, y, this.errorHandler), y.endDocument();
        }
    };
    var $ = /&#?\w+;?/g;
    function ne(d, N, w, y, M) {
        var A = o(y.mimeType);
        d.indexOf(e.UNICODE_REPLACEMENT_CHARACTER) >= 0 && M.warning("Unicode replacement character detected, source encoding issues?");
        function B(q) {
            if (q > 65535) {
                q -= 65536;
                var Z = 55296 + (q >> 10), Ae = 56320 + (q & 1023);
                return String.fromCharCode(Z, Ae);
            }
            else
                return String.fromCharCode(q);
        }
        function J(q) {
            var Z = q[q.length - 1] === ";" ? q : q + ";";
            if (!A && Z !== q)
                return M.error("EntityRef: expecting ;"), q;
            var Ae = e.Reference.exec(Z);
            if (!Ae || Ae[0].length !== Z.length)
                return M.error("entity not matching Reference production: " + q), q;
            var Ne = Z.slice(1, -1);
            return h(w, Ne) ? w[Ne] : Ne.charAt(0) === "#" ? B(parseInt(Ne.substring(1).replace("x", "0x"))) : (M.error("entity not found:" + q), q);
        }
        function _(q) {
            if (q > ie) {
                var Z = d.substring(ie, q).replace($, J);
                V && fe(ie), y.characters(Z, 0, q - ie), ie = q;
            }
        }
        var T = 0, I = 0, L = /\r\n?|\n|$/g, V = y.locator;
        function fe(q, Z) {
            for (; q >= I && (Z = L.exec(d));)
                T = I, I = Z.index + Z[0].length, V.lineNumber++;
            V.columnNumber = q - T + 1;
        }
        for (var we = [{ currentNSMap: N }], ve = [], ie = 0;;) {
            try {
                var P = d.indexOf("<", ie);
                if (P < 0) {
                    if (!A && ve.length > 0)
                        return M.fatalError("unclosed xml tag(s): " + ve.join(", "));
                    if (!d.substring(ie).match(/^\s*$/)) {
                        var $e = y.doc, Re = $e.createTextNode(d.substring(ie));
                        if ($e.documentElement)
                            return M.error("Extra content at the end of the document");
                        $e.appendChild(Re), y.currentElement = Re;
                    }
                    return;
                }
                if (P > ie) {
                    var pe = d.substring(ie, P);
                    !A && ve.length === 0 && (pe = pe.replace(new RegExp(e.S_OPT.source, "g"), ""), pe && M.error("Unexpected content outside root element: '" + pe + "'")), _(P);
                }
                switch (d.charAt(P + 1)) {
                    case "/":
                        var oe = d.indexOf(">", P + 2), Ve = d.substring(P + 2, oe > 0 ? oe : void 0);
                        if (!Ve)
                            return M.fatalError("end tag name missing");
                        var _e = oe > 0 && e.reg("^", e.QName_group, e.S_OPT, "$").exec(Ve);
                        if (!_e)
                            return M.fatalError('end tag name contains invalid characters: "' + Ve + '"');
                        if (!y.currentElement && !y.doc.documentElement)
                            return;
                        var Se = ve[ve.length - 1] || y.currentElement.tagName || y.doc.documentElement.tagName || "";
                        if (Se !== _e[1]) {
                            var Fe = _e[1].toLowerCase();
                            if (!A || Se.toLowerCase() !== Fe)
                                return M.fatalError('Opening and ending tag mismatch: "' + Se + '" != "' + Ve + '"');
                        }
                        var He = we.pop();
                        ve.pop();
                        var Je = He.localNSMap;
                        if (y.endElement(He.uri, He.localName, Se), Je)
                            for (var Ce in Je)
                                h(Je, Ce) && y.endPrefixMapping(Ce);
                        oe++;
                        break;
                    // end element
                    case "?":
                        V && fe(P), oe = te(d, P, y, M);
                        break;
                    case "!":
                        V && fe(P), oe = Ie(d, P, y, M, A);
                        break;
                    default:
                        V && fe(P);
                        var Q = new Be(), Ge = we[we.length - 1].currentNSMap, oe = g(d, P, Q, Ge, J, M, A), Xe = Q.length;
                        if (Q.closed || (A && t.isHTMLVoidElement(Q.tagName) ? Q.closed = !0 : ve.push(Q.tagName)), V && Xe) {
                            for (var vt = le(V, {}), Ye = 0; Ye < Xe; Ye++) {
                                var We = Q[Ye];
                                fe(We.offset), We.locator = le(V, {});
                            }
                            y.locator = vt, x(Q, y, Ge) && we.push(Q), y.locator = V;
                        }
                        else
                            x(Q, y, Ge) && we.push(Q);
                        A && !Q.closed ? oe = F(d, oe, Q.tagName, J, y) : oe++;
                }
            }
            catch (q) {
                if (q instanceof f)
                    throw q;
                if (q instanceof m)
                    throw new f(q.name + ": " + q.message, y.locator, q);
                M.error("element parse error: " + q), oe = -1;
            }
            oe > ie ? ie = oe : _(Math.max(P, ie) + 1);
        }
    }
    function le(d, N) {
        return N.lineNumber = d.lineNumber, N.columnNumber = d.columnNumber, N;
    }
    function g(d, N, w, y, M, A, B) {
        function J(fe, we, ve) {
            if (h(w.attributeNames, fe))
                return A.fatalError("Attribute " + fe + " redefined");
            if (!B && we.indexOf("<") >= 0)
                return A.fatalError("Unescaped '<' not allowed in attributes values");
            w.addValue(fe, 
            // @see https://www.w3.org/TR/xml/#AVNormalize
            // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
            // - recursive replacement of (DTD) entity references
            // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
            we.replace(/[\t\n\r]/g, " ").replace($, M), ve);
        }
        for (var _, T, I = ++N, L = E;;) {
            var V = d.charAt(I);
            switch (V) {
                case "=":
                    if (L === l)
                        _ = d.slice(N, I), L = O;
                    else if (L === v)
                        L = O;
                    else
                        throw new Error("attribute equal must after attrName");
                    break;
                case "'":
                case '"':
                    if (L === O || L === l)
                        if (L === l && (A.warning('attribute value must after "="'), _ = d.slice(N, I)), N = I + 1, I = d.indexOf(V, N), I > 0)
                            T = d.slice(N, I), J(_, T, N - 1), L = C;
                        else
                            throw new Error("attribute value no end '" + V + "' match");
                    else if (L == b)
                        T = d.slice(N, I), J(_, T, N), A.warning('attribute "' + _ + '" missed start quot(' + V + ")!!"), N = I + 1, L = C;
                    else
                        throw new Error('attribute value must after "="');
                    break;
                case "/":
                    switch (L) {
                        case E:
                            w.setTagName(d.slice(N, I));
                        case C:
                        case j:
                        case R:
                            L = R, w.closed = !0;
                        case b:
                        case l:
                            break;
                        case v:
                            w.closed = !0;
                            break;
                        //case S_EQ:
                        default:
                            throw new Error("attribute invalid close char('/')");
                    }
                    break;
                case "":
                    return A.error("unexpected end of input"), L == E && w.setTagName(d.slice(N, I)), I;
                case ">":
                    switch (L) {
                        case E:
                            w.setTagName(d.slice(N, I));
                        case C:
                        case j:
                        case R:
                            break;
                        //normal
                        case b:
                        //Compatible state
                        case l:
                            T = d.slice(N, I), T.slice(-1) === "/" && (w.closed = !0, T = T.slice(0, -1));
                        case v:
                            L === v && (T = _), L == b ? (A.warning('attribute "' + T + '" missed quot(")!'), J(_, T, N)) : (B || A.warning('attribute "' + T + '" missed value!! "' + T + '" instead!!'), J(T, T, N));
                            break;
                        case O:
                            if (!B)
                                return A.fatalError(`AttValue: ' or " expected`);
                    }
                    return I;
                /*xml space '\x20' | #x9 | #xD | #xA; */
                case "Â€":
                    V = " ";
                default:
                    if (V <= " ")
                        switch (L) {
                            case E:
                                w.setTagName(d.slice(N, I)), L = j;
                                break;
                            case l:
                                _ = d.slice(N, I), L = v;
                                break;
                            case b:
                                var T = d.slice(N, I);
                                A.warning('attribute "' + T + '" missed quot(")!!'), J(_, T, N);
                            case C:
                                L = j;
                                break;
                        }
                    else
                        switch (L) {
                            //case S_TAG:void();break;
                            //case S_ATTR:void();break;
                            //case S_ATTR_NOQUOT_VALUE:void();break;
                            case v:
                                B || A.warning('attribute "' + _ + '" missed value!! "' + _ + '" instead2!!'), J(_, _, N), N = I, L = l;
                                break;
                            case C:
                                A.warning('attribute space is required"' + _ + '"!!');
                            case j:
                                L = l, N = I;
                                break;
                            case O:
                                L = b, N = I;
                                break;
                            case R:
                                throw new Error("elements closed character '/' and '>' must be connected to");
                        }
            }
            I++;
        }
    }
    function x(d, N, w) {
        for (var y = d.tagName, M = null, L = d.length; L--;) {
            var A = d[L], B = A.qName, J = A.value, V = B.indexOf(":");
            if (V > 0)
                var _ = A.prefix = B.slice(0, V), T = B.slice(V + 1), I = _ === "xmlns" && T;
            else
                T = B, _ = null, I = B === "xmlns" && "";
            A.localName = T, I !== !1 && (M == null && (M = /* @__PURE__ */ Object.create(null), G(w, w = /* @__PURE__ */ Object.create(null))), w[I] = M[I] = J, A.uri = p.XMLNS, N.startPrefixMapping(I, J));
        }
        for (var L = d.length; L--;)
            A = d[L], A.prefix && (A.prefix === "xml" && (A.uri = p.XML), A.prefix !== "xmlns" && (A.uri = w[A.prefix]));
        var V = y.indexOf(":");
        V > 0 ? (_ = d.prefix = y.slice(0, V), T = d.localName = y.slice(V + 1)) : (_ = null, T = d.localName = y);
        var fe = d.uri = w[_ || ""];
        if (N.startElement(fe, T, y, d), d.closed) {
            if (N.endElement(fe, T, y), M)
                for (_ in M)
                    h(M, _) && N.endPrefixMapping(_);
        }
        else
            return d.currentNSMap = w, d.localNSMap = M, !0;
    }
    function F(d, N, w, y, M) {
        var A = i(w);
        if (A || a(w)) {
            var B = d.indexOf("</" + w + ">", N), J = d.substring(N + 1, B);
            return A && (J = J.replace($, y)), M.characters(J, 0, J.length), B;
        }
        return N + 1;
    }
    function G(d, N) {
        for (var w in d)
            h(d, w) && (N[w] = d[w]);
    }
    function K(d, N) {
        var w = N;
        function y(I) {
            return I = I || 0, d.charAt(w + I);
        }
        function M(I) {
            I = I || 1, w += I;
        }
        function A() {
            for (var I = 0; w < d.length;) {
                var L = y();
                if (L !== " " && L !== `
` && L !== "	" && L !== "\r")
                    return I;
                I++, M();
            }
            return -1;
        }
        function B() {
            return d.substring(w);
        }
        function J(I) {
            return d.substring(w, w + I.length) === I;
        }
        function _(I) {
            return d.substring(w, w + I.length).toUpperCase() === I.toUpperCase();
        }
        function T(I) {
            var L = e.reg("^", I), V = L.exec(B());
            return V ? (M(V[0].length), V[0]) : null;
        }
        return {
            char: y,
            getIndex: function () {
                return w;
            },
            getMatch: T,
            getSource: function () {
                return d;
            },
            skip: M,
            skipBlanks: A,
            substringFromIndex: B,
            substringStartsWith: J,
            substringStartsWithCaseInsensitive: _
        };
    }
    function ee(d, N) {
        function w(J, _) {
            var T = e.PI.exec(J.substringFromIndex());
            return T ? T[1].toLowerCase() === "xml" ? _.fatalError("xml declaration is only allowed at the start of the document, but found at position " + J.getIndex()) : (J.skip(T[0].length), T[0]) : _.fatalError("processing instruction is not well-formed at position " + J.getIndex());
        }
        var y = d.getSource();
        if (d.char() === "[") {
            d.skip(1);
            for (var M = d.getIndex(); d.getIndex() < y.length;) {
                if (d.skipBlanks(), d.char() === "]") {
                    var A = y.substring(M, d.getIndex());
                    return d.skip(1), A;
                }
                var B = null;
                if (d.char() === "<" && d.char(1) === "!")
                    switch (d.char(2)) {
                        case "E":
                            d.char(3) === "L" ? B = d.getMatch(e.elementdecl) : d.char(3) === "N" && (B = d.getMatch(e.EntityDecl));
                            break;
                        case "A":
                            B = d.getMatch(e.AttlistDecl);
                            break;
                        case "N":
                            B = d.getMatch(e.NotationDecl);
                            break;
                        case "-":
                            B = d.getMatch(e.Comment);
                            break;
                    }
                else if (d.char() === "<" && d.char(1) === "?")
                    B = w(d, N);
                else if (d.char() === "%")
                    B = d.getMatch(e.PEReference);
                else
                    return N.fatalError("Error detected in Markup declaration");
                if (!B)
                    return N.fatalError("Error in internal subset at position " + d.getIndex());
            }
            return N.fatalError("doctype internal subset is not well-formed, missing ]");
        }
    }
    function Ie(d, N, w, y, M) {
        var A = K(d, N);
        switch (M ? A.char(2).toUpperCase() : A.char(2)) {
            case "-":
                var B = A.getMatch(e.Comment);
                return B ? (w.comment(B, e.COMMENT_START.length, B.length - e.COMMENT_START.length - e.COMMENT_END.length), A.getIndex()) : y.fatalError("comment is not well-formed at position " + A.getIndex());
            case "[":
                var J = A.getMatch(e.CDSect);
                return J ? !M && !w.currentElement ? y.fatalError("CDATA outside of element") : (w.startCDATA(), w.characters(J, e.CDATA_START.length, J.length - e.CDATA_START.length - e.CDATA_END.length), w.endCDATA(), A.getIndex()) : y.fatalError("Invalid CDATA starting at position " + N);
            case "D": {
                if (w.doc && w.doc.documentElement)
                    return y.fatalError("Doctype not allowed inside or after documentElement at position " + A.getIndex());
                if (M ? !A.substringStartsWithCaseInsensitive(e.DOCTYPE_DECL_START) : !A.substringStartsWith(e.DOCTYPE_DECL_START))
                    return y.fatalError("Expected " + e.DOCTYPE_DECL_START + " at position " + A.getIndex());
                if (A.skip(e.DOCTYPE_DECL_START.length), A.skipBlanks() < 1)
                    return y.fatalError("Expected whitespace after " + e.DOCTYPE_DECL_START + " at position " + A.getIndex());
                var _ = {
                    name: void 0,
                    publicId: void 0,
                    systemId: void 0,
                    internalSubset: void 0
                };
                if (_.name = A.getMatch(e.Name), !_.name)
                    return y.fatalError("doctype name missing or contains unexpected characters at position " + A.getIndex());
                if (M && _.name.toLowerCase() !== "html" && y.warning("Unexpected DOCTYPE in HTML document at position " + A.getIndex()), A.skipBlanks(), A.substringStartsWith(e.PUBLIC) || A.substringStartsWith(e.SYSTEM)) {
                    var T = e.ExternalID_match.exec(A.substringFromIndex());
                    if (!T)
                        return y.fatalError("doctype external id is not well-formed at position " + A.getIndex());
                    T.groups.SystemLiteralOnly !== void 0 ? _.systemId = T.groups.SystemLiteralOnly : (_.systemId = T.groups.SystemLiteral, _.publicId = T.groups.PubidLiteral), A.skip(T[0].length);
                }
                else if (M && A.substringStartsWithCaseInsensitive(e.SYSTEM)) {
                    if (A.skip(e.SYSTEM.length), A.skipBlanks() < 1)
                        return y.fatalError("Expected whitespace after " + e.SYSTEM + " at position " + A.getIndex());
                    if (_.systemId = A.getMatch(e.ABOUT_LEGACY_COMPAT_SystemLiteral), !_.systemId)
                        return y.fatalError("Expected " + e.ABOUT_LEGACY_COMPAT + " in single or double quotes after " + e.SYSTEM + " at position " + A.getIndex());
                }
                return M && _.systemId && !e.ABOUT_LEGACY_COMPAT_SystemLiteral.test(_.systemId) && y.warning("Unexpected doctype.systemId in HTML document at position " + A.getIndex()), M || (A.skipBlanks(), _.internalSubset = ee(A, y)), A.skipBlanks(), A.char() !== ">" ? y.fatalError("doctype not terminated with > at position " + A.getIndex()) : (A.skip(1), w.startDTD(_.name, _.publicId, _.systemId, _.internalSubset), w.endDTD(), A.getIndex());
            }
            default:
                return y.fatalError('Not well-formed XML starting with "<!" at position ' + N);
        }
    }
    function te(d, N, w, y) {
        var M = d.substring(N).match(e.PI);
        if (!M)
            return y.fatalError("Invalid processing instruction starting at position " + N);
        if (M[1].toLowerCase() === "xml") {
            if (N > 0)
                return y.fatalError("processing instruction at position " + N + " is an xml declaration which is only at the start of the document");
            if (!e.XMLDecl.test(d.substring(N)))
                return y.fatalError("xml declaration is not well-formed");
        }
        return w.processingInstruction(M[1], M[2]), N + M[0].length;
    }
    function Be() {
        this.attributeNames = /* @__PURE__ */ Object.create(null);
    }
    return Be.prototype = {
        setTagName: function (d) {
            if (!e.QName_exact.test(d))
                throw new Error("invalid tagName:" + d);
            this.tagName = d;
        },
        addValue: function (d, N, w) {
            if (!e.QName_exact.test(d))
                throw new Error("invalid attribute:" + d);
            this.attributeNames[d] = this.length, this[this.length++] = { qName: d, value: N, offset: w };
        },
        length: 0,
        getLocalName: function (d) {
            return this[d].localName;
        },
        getLocator: function (d) {
            return this[d].locator;
        },
        getQName: function (d) {
            return this[d].qName;
        },
        getURI: function (d) {
            return this[d].uri;
        },
        getValue: function (d) {
            return this[d].value;
        }
        //	,getIndex:function(uri, localName)){
        //		if(localName){
        //
        //		}else{
        //			var qName = uri
        //		}
        //	},
        //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
        //	getType:function(uri,localName){}
        //	getType:function(i){},
    }, yt.XMLReader = k, yt.parseUtils = K, yt.parseDoctypeCommentOrCData = Ie, yt;
}
var ar;
function Nn() {
    if (ar)
        return rt;
    ar = 1;
    var t = Dt(), e = kr(), n = _t(), i = vn(), o = An(), a = e.DOMImplementation, h = t.hasDefaultHTMLNamespace, p = t.isHTMLMimeType, f = t.isValidMimeType, m = t.MIME_TYPE, E = t.NAMESPACE, l = n.ParseError, v = o.XMLReader;
    function O(g) {
        return g.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028\u2029]/g, `
`);
    }
    function b(g) {
        if (g = g || {}, g.locator === void 0 && (g.locator = !0), this.assign = g.assign || t.assign, this.domHandler = g.domHandler || C, this.onError = g.onError || g.errorHandler, g.errorHandler && typeof g.errorHandler != "function")
            throw new TypeError("errorHandler object is no longer supported, switch to onError!");
        g.errorHandler && g.errorHandler("warning", "The `errorHandler` option has been deprecated, use `onError` instead!", this), this.normalizeLineEndings = g.normalizeLineEndings || O, this.locator = !!g.locator, this.xmlns = this.assign(/* @__PURE__ */ Object.create(null), g.xmlns);
    }
    b.prototype.parseFromString = function (g, x) {
        if (!f(x))
            throw new TypeError('DOMParser.parseFromString: the provided mimeType "' + x + '" is not valid.');
        var F = this.assign(/* @__PURE__ */ Object.create(null), this.xmlns), G = i.XML_ENTITIES, K = F[""] || null;
        h(x) ? (G = i.HTML_ENTITIES, K = E.HTML) : x === m.XML_SVG_IMAGE && (K = E.SVG), F[""] = K, F.xml = F.xml || E.XML;
        var ee = new this.domHandler({
            mimeType: x,
            defaultNamespace: K,
            onError: this.onError
        }), Ie = this.locator ? {} : void 0;
        this.locator && ee.setDocumentLocator(Ie);
        var te = new v();
        te.errorHandler = ee, te.domBuilder = ee;
        var Be = !t.isHTMLMimeType(x);
        return Be && typeof g != "string" && te.errorHandler.fatalError("source is not a string"), te.parse(this.normalizeLineEndings(String(g)), F, G), ee.doc.documentElement || te.errorHandler.fatalError("missing root element"), ee.doc;
    };
    function C(g) {
        var x = g || {};
        this.mimeType = x.mimeType || m.XML_APPLICATION, this.defaultNamespace = x.defaultNamespace || null, this.cdata = !1, this.currentElement = void 0, this.doc = void 0, this.locator = void 0, this.onError = x.onError;
    }
    function j(g, x) {
        x.lineNumber = g.lineNumber, x.columnNumber = g.columnNumber;
    }
    C.prototype = {
        /**
         * Either creates an XML or an HTML document and stores it under `this.doc`.
         * If it is an XML document, `this.defaultNamespace` is used to create it,
         * and it will not contain any `childNodes`.
         * If it is an HTML document, it will be created without any `childNodes`.
         *
         * @see http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
         */
        startDocument: function () {
            var g = new a();
            this.doc = p(this.mimeType) ? g.createHTMLDocument(!1) : g.createDocument(this.defaultNamespace, "");
        },
        startElement: function (g, x, F, G) {
            var K = this.doc, ee = K.createElementNS(g, F || x), Ie = G.length;
            $(this, ee), this.currentElement = ee, this.locator && j(this.locator, ee);
            for (var te = 0; te < Ie; te++) {
                var g = G.getURI(te), Be = G.getValue(te), F = G.getQName(te), d = K.createAttributeNS(g, F);
                this.locator && j(G.getLocator(te), d), d.value = d.nodeValue = Be, ee.setAttributeNode(d);
            }
        },
        endElement: function (g, x, F) {
            this.currentElement = this.currentElement.parentNode;
        },
        startPrefixMapping: function (g, x) {
        },
        endPrefixMapping: function (g) {
        },
        processingInstruction: function (g, x) {
            var F = this.doc.createProcessingInstruction(g, x);
            this.locator && j(this.locator, F), $(this, F);
        },
        ignorableWhitespace: function (g, x, F) {
        },
        characters: function (g, x, F) {
            if (g = k.apply(this, arguments), g) {
                if (this.cdata)
                    var G = this.doc.createCDATASection(g);
                else
                    var G = this.doc.createTextNode(g);
                this.currentElement ? this.currentElement.appendChild(G) : /^\s*$/.test(g) && this.doc.appendChild(G), this.locator && j(this.locator, G);
            }
        },
        skippedEntity: function (g) {
        },
        endDocument: function () {
            this.doc.normalize();
        },
        /**
         * Stores the locator to be able to set the `columnNumber` and `lineNumber`
         * on the created DOM nodes.
         *
         * @param {Locator} locator
         */
        setDocumentLocator: function (g) {
            g && (g.lineNumber = 0), this.locator = g;
        },
        //LexicalHandler
        comment: function (g, x, F) {
            g = k.apply(this, arguments);
            var G = this.doc.createComment(g);
            this.locator && j(this.locator, G), $(this, G);
        },
        startCDATA: function () {
            this.cdata = !0;
        },
        endCDATA: function () {
            this.cdata = !1;
        },
        startDTD: function (g, x, F, G) {
            var K = this.doc.implementation;
            if (K && K.createDocumentType) {
                var ee = K.createDocumentType(g, x, F, G);
                this.locator && j(this.locator, ee), $(this, ee), this.doc.doctype = ee;
            }
        },
        reportError: function (g, x) {
            if (typeof this.onError == "function")
                try {
                    this.onError(g, x, this);
                }
                catch (F) {
                    throw new l("Reporting " + g + ' "' + x + '" caused ' + F, this.locator);
                }
            else
                console.error("[xmldom " + g + "]	" + x, R(this.locator));
        },
        /**
         * @see http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
         */
        warning: function (g) {
            this.reportError("warning", g);
        },
        error: function (g) {
            this.reportError("error", g);
        },
        /**
         * This function reports a fatal error and throws a ParseError.
         *
         * @param {string} message
         * - The message to be used for reporting and throwing the error.
         * @returns {never}
         * This function always throws an error and never returns a value.
         * @throws {ParseError}
         * Always throws a ParseError with the provided message.
         */
        fatalError: function (g) {
            throw this.reportError("fatalError", g), new l(g, this.locator);
        }
    };
    function R(g) {
        if (g)
            return `
@#[line:` + g.lineNumber + ",col:" + g.columnNumber + "]";
    }
    function k(g, x, F) {
        return typeof g == "string" ? g.substr(x, F) : g.length >= x + F || x ? new java.lang.String(g, x, F) + "" : g;
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function (g) {
        C.prototype[g] = function () {
            return null;
        };
    });
    function $(g, x) {
        g.currentElement ? g.currentElement.appendChild(x) : g.doc.appendChild(x);
    }
    function ne(g) {
        if (g === "error")
            throw "onErrorStopParsing";
    }
    function le() {
        throw "onWarningStopParsing";
    }
    return rt.__DOMHandler = C, rt.DOMParser = b, rt.normalizeLineEndings = O, rt.onErrorStopParsing = ne, rt.onWarningStopParsing = le, rt;
}
var sr;
function bn() {
    if (sr)
        return H;
    sr = 1;
    var t = Dt();
    H.assign = t.assign, H.hasDefaultHTMLNamespace = t.hasDefaultHTMLNamespace, H.isHTMLMimeType = t.isHTMLMimeType, H.isValidMimeType = t.isValidMimeType, H.MIME_TYPE = t.MIME_TYPE, H.NAMESPACE = t.NAMESPACE;
    var e = _t();
    H.DOMException = e.DOMException, H.DOMExceptionName = e.DOMExceptionName, H.ExceptionCode = e.ExceptionCode, H.ParseError = e.ParseError;
    var n = kr();
    H.Attr = n.Attr, H.CDATASection = n.CDATASection, H.CharacterData = n.CharacterData, H.Comment = n.Comment, H.Document = n.Document, H.DocumentFragment = n.DocumentFragment, H.DocumentType = n.DocumentType, H.DOMImplementation = n.DOMImplementation, H.Element = n.Element, H.Entity = n.Entity, H.EntityReference = n.EntityReference, H.LiveNodeList = n.LiveNodeList, H.NamedNodeMap = n.NamedNodeMap, H.Node = n.Node, H.NodeList = n.NodeList, H.Notation = n.Notation, H.ProcessingInstruction = n.ProcessingInstruction, H.Text = n.Text, H.XMLSerializer = n.XMLSerializer;
    var i = Nn();
    return H.DOMParser = i.DOMParser, H.normalizeLineEndings = i.normalizeLineEndings, H.onErrorStopParsing = i.onErrorStopParsing, H.onWarningStopParsing = i.onWarningStopParsing, H;
}
bn();
const Ut = "USJ";
var xe = {}, qt, cr;
function Cn() {
    return cr || (cr = 1, qt = () => {
        const t = "\\ud800-\\udfff", h = "\\u0300-\\u036f" + "\\ufe20-\\ufe2f" + "\\u20d0-\\u20ff" + "\\u1ab0-\\u1aff" + "\\u1dc0-\\u1dff", p = "\\ufe0e\\ufe0f", f = "\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83C\\uDF93", m = `[${t}]`, E = `[${h}]`, l = "\\ud83c[\\udffb-\\udfff]", v = `(?:${E}|${l})`, O = `[^${t}]`, b = "(?:\\uD83C[\\uDDE6-\\uDDFF]){2}", C = "[\\ud800-\\udbff][\\udc00-\\udfff]", j = "\\u200d", R = "(?:\\ud83c\\udff4\\udb40\\udc67\\udb40\\udc62\\udb40(?:\\udc65|\\udc73|\\udc77)\\udb40(?:\\udc6e|\\udc63|\\udc6c)\\udb40(?:\\udc67|\\udc74|\\udc73)\\udb40\\udc7f)", k = `[${f}]`, $ = `${v}?`, ne = `[${p}]?`, le = `(?:${j}(?:${[O, b, C].join("|")})${ne + $})*`, g = ne + $ + le, F = `(?:${[`${O}${E}?`, E, b, C, m, k].join("|")})`;
        return new RegExp(`${R}|${l}(?=${l})|${F + g}`, "g");
    }), qt;
}
var lr;
function yn() {
    if (lr)
        return xe;
    lr = 1;
    var t = xe && xe.__importDefault || function (f) {
        return f && f.__esModule ? f : { default: f };
    };
    Object.defineProperty(xe, "__esModule", { value: !0 });
    var e = t(Cn());
    function n(f) {
        if (typeof f != "string")
            throw new Error("A string is expected as input");
        return f.match(e.default()) || [];
    }
    xe.toArray = n;
    function i(f) {
        if (typeof f != "string")
            throw new Error("Input must be a string");
        var m = f.match(e.default());
        return m === null ? 0 : m.length;
    }
    xe.length = i;
    function o(f, m, E) {
        if (m === void 0 && (m = 0), typeof f != "string")
            throw new Error("Input must be a string");
        (typeof m != "number" || m < 0) && (m = 0), typeof E == "number" && E < 0 && (E = 0);
        var l = f.match(e.default());
        return l ? l.slice(m, E).join("") : "";
    }
    xe.substring = o;
    function a(f, m, E) {
        if (m === void 0 && (m = 0), typeof f != "string")
            throw new Error("Input must be a string");
        var l = i(f);
        if (typeof m != "number" && (m = parseInt(m, 10)), m >= l)
            return "";
        m < 0 && (m += l);
        var v;
        typeof E > "u" ? v = l : (typeof E != "number" && (E = parseInt(E, 10)), v = E >= 0 ? E + m : m);
        var O = f.match(e.default());
        return O ? O.slice(m, v).join("") : "";
    }
    xe.substr = a;
    function h(f, m, E, l) {
        if (m === void 0 && (m = 16), E === void 0 && (E = "#"), l === void 0 && (l = "right"), typeof f != "string" || typeof m != "number")
            throw new Error("Invalid arguments specified");
        if (["left", "right"].indexOf(l) === -1)
            throw new Error("Pad position should be either left or right");
        typeof E != "string" && (E = String(E));
        var v = i(f);
        if (v > m)
            return o(f, 0, m);
        if (v < m) {
            var O = E.repeat(m - v);
            return l === "left" ? O + f : f + O;
        }
        return f;
    }
    xe.limit = h;
    function p(f, m, E) {
        if (E === void 0 && (E = 0), typeof f != "string")
            throw new Error("Input must be a string");
        if (f === "")
            return m === "" ? 0 : -1;
        E = Number(E), E = isNaN(E) ? 0 : E, m = String(m);
        var l = n(f);
        if (E >= l.length)
            return m === "" ? l.length : -1;
        if (m === "")
            return E;
        var v = n(m), O = !1, b;
        for (b = E; b < l.length; b += 1) {
            for (var C = 0; C < v.length && v[C] === l[b + C];)
                C += 1;
            if (C === v.length && v[C - 1] === l[b + C - 1]) {
                O = !0;
                break;
            }
        }
        return O ? b : -1;
    }
    return xe.indexOf = p, xe;
}
var ot = yn();
function qr(t) {
    return t ? Array.isArray(t) ? t : [t] : [];
}
function xt(t, e) {
    if (!(e > ce(t) || e < -ce(t)))
        return Pt(t, e, 1);
}
function Et(t, e) {
    return e < 0 || e > ce(t) - 1 ? "" : Pt(t, e, 1);
}
function Zu(t, e) {
    if (!(e < 0 || e > ce(t) - 1))
        return Pt(t, e, 1).codePointAt(0);
}
function Tn(t, e, n = ce(t)) {
    const i = In(t, e);
    return !(i === -1 || i + ce(e) !== n);
}
function wn(t, e, n) {
    if (e < 0)
        return -1;
    if (n) {
        if (Et(t, e) === "}" && Et(t, e - 1) === "\\")
            return e;
        const a = St(t, "\\}", e);
        return a >= 0 ? a + 1 : a;
    }
    let i = e;
    const o = ce(t);
    for (; i < o && (i = St(t, "}", i), !(i === -1 || Et(t, i - 1) !== "\\"));)
        i += 1;
    return i >= o ? -1 : i;
}
function Sn(t, e) {
    const n = [];
    let i = 0, o = 0;
    function a(p, f, m) {
        const E = ut(t, o, f), l = n.length > 0 && Me(n[n.length - 1]) ? `${n.pop()}${E}` : E;
        Me(p) ? n.push(`${l}${p}`) : (l && n.push(l), n.push(p)), o = f + m;
    }
    const h = ce(t);
    for (; i < h;) {
        switch (Et(t, i)) {
            case "{":
                if (Et(t, i - 1) !== "\\") {
                    const p = wn(t, i, !1);
                    if (p >= 0) {
                        const f = ut(t, i + 1, p), m = f in e ? (
                        // Just checked that the key is in the object
                        // eslint-disable-next-line no-type-assertion/no-type-assertion
                        e[f]) : f;
                        a(m, i, p + 1 - i), i = p, o = p + 1;
                    }
                }
                else
                    a("{", i - 1, 2);
                break;
            case "}":
                Et(t, i - 1) !== "\\" || a("}", i - 1, 2);
                break;
        }
        i += 1;
    }
    if (o < h) {
        const p = ut(t, o);
        n.push(n.length > 0 && Me(n[n.length - 1]) ? `${n.pop()}${p}` : p);
    }
    return n;
}
function ei(t, e) {
    return Sn(t, e).map((n) => `${n}`).join("");
}
function On(t, e, n = 0) {
    const i = ut(t, n);
    return St(i, e) !== -1;
}
function St(t, e, n = 0) {
    return ot.indexOf(t, e, n);
}
function In(t, e, n) {
    let i = n === void 0 ? ce(t) : n;
    i < 0 ? i = 0 : i >= ce(t) && (i = ce(t) - 1);
    for (let o = i; o >= 0; o--)
        if (Pt(t, o, ce(e)) === e)
            return o;
    return -1;
}
function ce(t) {
    return ot.length(t);
}
function ti(t, e) {
    const n = e.toUpperCase();
    return n === "NONE" ? t : t.normalize(n);
}
function ri(t, e, n) {
    return t.localeCompare(e, "en", n);
}
function ni(t, e, n = " ") {
    return e <= ce(t) ? t : ot.limit(t, e, n, "right");
}
function ui(t, e, n = " ") {
    return e <= ce(t) ? t : ot.limit(t, e, n, "left");
}
function fr(t, e) {
    return e > t ? t : e < -t ? 0 : e < 0 ? e + t : e;
}
function pr(t, e, n) {
    const i = ce(t);
    if (e > i || n && (e > n && !(e >= 0 && e < i && n < 0 && n > -i) || n < -i))
        return "";
    const o = fr(i, e), a = n ? fr(i, n) : void 0;
    return ut(t, o, a);
}
function hr(t, e, n) {
    const i = [];
    if (n !== void 0 && n <= 0)
        return [t];
    if (e === "")
        return xn(t).slice(0, n);
    let o = e;
    (typeof e == "string" || e instanceof RegExp && !On(e.flags, "g")) && (o = new RegExp(e, "g"));
    const a = t.match(o);
    let h = 0;
    if (!a)
        return [t];
    for (let p = 0; p < (n ? n - 1 : a.length); p++) {
        const f = St(t, a[p], h), m = ce(a[p]);
        if (i.push(ut(t, h, f)), h = f + m, n !== void 0 && i.length === n)
            break;
    }
    return i.push(ut(t, h)), i;
}
function Ur(t, e, n = 0) {
    return St(t, e, n) === n;
}
function Pt(t, e = 0, n = ce(t) - e) {
    return ot.substr(t, e, n);
}
function ut(t, e, n = ce(t)) {
    return ot.substring(t, e, n);
}
function xn(t) {
    return ot.toArray(t);
}
function ii(t) {
    return Ur(t, "%") && Tn(t, "%");
}
function oi(t) {
    if (typeof t != "string")
        throw new TypeError("Expected a string");
    return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function ai(t) {
    return t ? qr(t).map((i) => Array.isArray(i) ? i.map((o) => new RegExp(o)) : new RegExp(i)) : [];
}
function si(t) {
    return t ? qr(t).map((i) => new RegExp(i)) : [];
}
const Mn = (
// Using unicode control characters to be very explicit about which characters we are using.
// The first 6 characters are the control characters \f\n\r\t\v.
// eslint-disable-next-line no-control-regex
/^[\u000C\u000A\u000D\u0009\u000B\u0020\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\u0085]+$/);
function mt(t) {
    return Mn.test(t);
}
function ci(t) {
    let e = "";
    for (let n = 0; n < t.length; n++) {
        const i = t[n];
        if (i === i.toUpperCase() && i !== i.toLowerCase()) {
            if (n > 0) {
                const a = t[n - 1];
                if (!(a === a.toUpperCase() && a !== a.toLowerCase()))
                    e += "-";
                else if (n + 1 < t.length) {
                    const p = t[n + 1];
                    p === p.toLowerCase() && p !== p.toUpperCase() && (e += "-");
                }
            }
            e += i.toLowerCase();
        }
        else
            e += i;
    }
    return e;
}
const jt = ["chapter", "book", "para", "row", "sidebar", Ut], Bn = "â€‹", jr = [
    { shortName: "ERR", fullNames: ["ERROR"], chapters: -1 },
    { shortName: "GEN", fullNames: ["Genesis"], chapters: 50 },
    { shortName: "EXO", fullNames: ["Exodus"], chapters: 40 },
    { shortName: "LEV", fullNames: ["Leviticus"], chapters: 27 },
    { shortName: "NUM", fullNames: ["Numbers"], chapters: 36 },
    { shortName: "DEU", fullNames: ["Deuteronomy"], chapters: 34 },
    { shortName: "JOS", fullNames: ["Joshua"], chapters: 24 },
    { shortName: "JDG", fullNames: ["Judges"], chapters: 21 },
    { shortName: "RUT", fullNames: ["Ruth"], chapters: 4 },
    { shortName: "1SA", fullNames: ["1 Samuel"], chapters: 31 },
    { shortName: "2SA", fullNames: ["2 Samuel"], chapters: 24 },
    { shortName: "1KI", fullNames: ["1 Kings"], chapters: 22 },
    { shortName: "2KI", fullNames: ["2 Kings"], chapters: 25 },
    { shortName: "1CH", fullNames: ["1 Chronicles"], chapters: 29 },
    { shortName: "2CH", fullNames: ["2 Chronicles"], chapters: 36 },
    { shortName: "EZR", fullNames: ["Ezra"], chapters: 10 },
    { shortName: "NEH", fullNames: ["Nehemiah"], chapters: 13 },
    { shortName: "EST", fullNames: ["Esther"], chapters: 10 },
    { shortName: "JOB", fullNames: ["Job"], chapters: 42 },
    { shortName: "PSA", fullNames: ["Psalm", "Psalms"], chapters: 150 },
    { shortName: "PRO", fullNames: ["Proverbs"], chapters: 31 },
    { shortName: "ECC", fullNames: ["Ecclesiastes"], chapters: 12 },
    { shortName: "SNG", fullNames: ["Song of Solomon", "Song of Songs"], chapters: 8 },
    { shortName: "ISA", fullNames: ["Isaiah"], chapters: 66 },
    { shortName: "JER", fullNames: ["Jeremiah"], chapters: 52 },
    { shortName: "LAM", fullNames: ["Lamentations"], chapters: 5 },
    { shortName: "EZK", fullNames: ["Ezekiel"], chapters: 48 },
    { shortName: "DAN", fullNames: ["Daniel"], chapters: 12 },
    { shortName: "HOS", fullNames: ["Hosea"], chapters: 14 },
    { shortName: "JOL", fullNames: ["Joel"], chapters: 3 },
    { shortName: "AMO", fullNames: ["Amos"], chapters: 9 },
    { shortName: "OBA", fullNames: ["Obadiah"], chapters: 1 },
    { shortName: "JON", fullNames: ["Jonah"], chapters: 4 },
    { shortName: "MIC", fullNames: ["Micah"], chapters: 7 },
    { shortName: "NAM", fullNames: ["Nahum"], chapters: 3 },
    { shortName: "HAB", fullNames: ["Habakkuk"], chapters: 3 },
    { shortName: "ZEP", fullNames: ["Zephaniah"], chapters: 3 },
    { shortName: "HAG", fullNames: ["Haggai"], chapters: 2 },
    { shortName: "ZEC", fullNames: ["Zechariah"], chapters: 14 },
    { shortName: "MAL", fullNames: ["Malachi"], chapters: 4 },
    { shortName: "MAT", fullNames: ["Matthew"], chapters: 28 },
    { shortName: "MRK", fullNames: ["Mark"], chapters: 16 },
    { shortName: "LUK", fullNames: ["Luke"], chapters: 24 },
    { shortName: "JHN", fullNames: ["John"], chapters: 21 },
    { shortName: "ACT", fullNames: ["Acts"], chapters: 28 },
    { shortName: "ROM", fullNames: ["Romans"], chapters: 16 },
    { shortName: "1CO", fullNames: ["1 Corinthians"], chapters: 16 },
    { shortName: "2CO", fullNames: ["2 Corinthians"], chapters: 13 },
    { shortName: "GAL", fullNames: ["Galatians"], chapters: 6 },
    { shortName: "EPH", fullNames: ["Ephesians"], chapters: 6 },
    { shortName: "PHP", fullNames: ["Philippians"], chapters: 4 },
    { shortName: "COL", fullNames: ["Colossians"], chapters: 4 },
    { shortName: "1TH", fullNames: ["1 Thessalonians"], chapters: 5 },
    { shortName: "2TH", fullNames: ["2 Thessalonians"], chapters: 3 },
    { shortName: "1TI", fullNames: ["1 Timothy"], chapters: 6 },
    { shortName: "2TI", fullNames: ["2 Timothy"], chapters: 4 },
    { shortName: "TIT", fullNames: ["Titus"], chapters: 3 },
    { shortName: "PHM", fullNames: ["Philemon"], chapters: 1 },
    { shortName: "HEB", fullNames: ["Hebrews"], chapters: 13 },
    { shortName: "JAS", fullNames: ["James"], chapters: 5 },
    { shortName: "1PE", fullNames: ["1 Peter"], chapters: 5 },
    { shortName: "2PE", fullNames: ["2 Peter"], chapters: 3 },
    { shortName: "1JN", fullNames: ["1 John"], chapters: 5 },
    { shortName: "2JN", fullNames: ["2 John"], chapters: 1 },
    { shortName: "3JN", fullNames: ["3 John"], chapters: 1 },
    { shortName: "JUD", fullNames: ["Jude"], chapters: 1 },
    { shortName: "REV", fullNames: ["Revelation"], chapters: 22 }
], Rn = 1, _n = jr.length - 1, Pn = 1, Ln = 1, li = {
    book: "GEN",
    chapterNum: 1,
    verseNum: 1
}, Fn = (t) => {
    var e;
    return ((e = jr[t]) == null ? void 0 : e.chapters) ?? -1;
}, fi = (t, e) => ({
    book: be.bookNumberToId(Math.max(Rn, Math.min(be.bookIdToNumber(t.book) + e, _n))),
    chapterNum: 1,
    verseNum: 1
}), pi = (t, e) => ({
    ...t,
    chapterNum: Math.min(Math.max(Pn, t.chapterNum + e), Fn(be.bookIdToNumber(t.book))),
    verseNum: 1
}), hi = (t, e) => ({
    ...t,
    verseNum: Math.max(Ln, t.verseNum + e)
});
async function di(t, e, n) {
    const i = be.bookNumberToId(t);
    if (!Ur(Intl.getCanonicalLocales(e)[0], "zh"))
        return n({
            localizeKey: `LocalizedId.${i}`,
            languagesToSearch: [e]
        });
    const o = await n({
        localizeKey: `Book.${i}`,
        languagesToSearch: [e]
    }), a = hr(o, "-");
    return hr(a[0], "Ã¿08")[0].trim();
}
function mi(t) {
    return new Lr(be.bookIdToNumber(t.book), t.chapterNum, t.verseNum).BBBCCC;
}
function dr(t) {
    return new Lr(be.bookIdToNumber(t.book), t.chapterNum, t.verseNum).BBBCCCVVV;
}
function Ei(t, e) {
    return dr(t) - dr(e);
}
function kn(t) {
    return `%scrollGroup_${t}%`;
}
function gi(t) {
    return t.map((e) => kn(e));
}
function Di(t, e, n, i) {
    let o;
    switch (e ?? "id") {
        case "English":
            o = be.bookIdToEnglishName(t.book);
            break;
        case "id":
            o = t.book;
            break;
        default:
            o = e ?? "";
            break;
    }
    return `${o}${i ?? " "}${t.chapterNum}${n ?? ":"}${t.verseNum}`;
}
const qn = (
// Using unicode control characters to be very explicit about which characters we are using.
// The first 6 characters are the control characters \f\n\r\t\v.
// eslint-disable-next-line no-control-regex
/^[\u000C\u000A\u000D\u0009\u000B\u0020\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u200B\u0085]+$/);
function mr(t) {
    return qn.test(t);
}
const Un = /^[\u200d\u2003\u2002\u0020\u00a0\u202f\u2009\u200a\u3000\u200b\u200c\u2060\u200e\u200f]+$/;
function jn(t) {
    return Un.test(t);
}
function Er(t) {
    let e = "", n = !1, i = "\0";
    for (let o = 0; o < t.length; o += 1) {
        const a = t[o];
        a.charCodeAt(0) < 32 ? (n || (e += " "), n = !0) : !n && a === Bn && o + 1 < t.length && mr(t[o + 1]) || (mr(a) ? (n || (e += a), n = !0) : jn(a) && i === a || (e += a, n = !1)), i = a;
    }
    return e;
}
function gr(t) {
    return !t || t.length === 0 ? !0 : t.length === 1 && (t[0] === void 0 || t[0] === "");
}
function Dr(t, e) {
    if (!e || !jt.includes(e.type))
        return !1;
    if (!e.content)
        throw new Error(`Parent ${JSON.stringify(e)} of ${JSON.stringify(t)} does not have a content array! This should not happen!`);
    return t === e.content[e.content.length - 1];
}
function $r(t, e, n, i) {
    if (!t && !n)
        return !0;
    if (!t || !n)
        return !1;
    const o = Me(t), a = Me(n);
    if (o && a) {
        const h = Er(t), p = Er(n);
        if (h !== p) {
            if (!mt(xt(h, -1) ?? "") && !mt(xt(p, -1) ?? "") || !Dr(t, e) || !Dr(n, i))
                return !1;
            let f = h;
            for (; mt(xt(f, -1) ?? "");)
                f = pr(f, 0, -1);
            let m = p;
            for (; mt(xt(m, -1) ?? "");)
                m = pr(m, 0, -1);
            if (f !== m)
                return !1;
        }
    }
    else if (!o && !a) {
        const h = t, p = n, f = Object.keys(h).filter((l) => l !== "content");
        if (f.length !== Object.keys(p).filter((l) => l !== "content").length || f.some((l) => !(l in p) || h[l] !== p[l]))
            return !1;
        const m = gr(h.content), E = gr(p.content);
        if (m !== E)
            return !1;
        if (!m && !E) {
            let l = h.content, v = p.content;
            const O = l[l.length - 1];
            jt.includes(h.type) && Me(O) && mt(O) && (l = l.slice(0, -1));
            const b = v[v.length - 1];
            if (jt.includes(p.type) && Me(b) && mt(b) && (v = v.slice(0, -1)), l.length !== v.length)
                return !1;
            for (let C = 0; C < l.length; C += 1)
                if (!$r(l[C], h, v[C], p))
                    return !1;
        }
    }
    else
        return !1;
    return !0;
}
function vi(t, e) {
    return $r(t, void 0, e, void 0);
}
const Ai = (t) => (...e) => t.map((i) => i(...e)).every((i) => i), Ni = (t) => async (...e) => {
    const n = t.map(async (i) => i(...e));
    return (await Promise.all(n)).every((i) => i);
}, Mt = "chapter", Bt = "verse";
var $n = Object.getOwnPropertyNames, Vn = Object.getOwnPropertySymbols, Gn = Object.prototype.hasOwnProperty;
function vr(t, e) {
    return function (i, o, a) {
        return t(i, o, a) && e(i, o, a);
    };
}
function Rt(t) {
    return function (n, i, o) {
        if (!n || !i || typeof n != "object" || typeof i != "object")
            return t(n, i, o);
        var a = o.cache, h = a.get(n), p = a.get(i);
        if (h && p)
            return h === i && p === n;
        a.set(n, i), a.set(i, n);
        var f = t(n, i, o);
        return a.delete(n), a.delete(i), f;
    };
}
function Ar(t) {
    return $n(t).concat(Vn(t));
}
var zn = Object.hasOwn || function (t, e) {
    return Gn.call(t, e);
};
function at(t, e) {
    return t === e || !t && !e && t !== t && e !== e;
}
var Hn = "__v", Jn = "__o", Xn = "_owner", Nr = Object.getOwnPropertyDescriptor, br = Object.keys;
function Yn(t, e, n) {
    var i = t.length;
    if (e.length !== i)
        return !1;
    for (; i-- > 0;)
        if (!n.equals(t[i], e[i], i, i, t, e, n))
            return !1;
    return !0;
}
function Wn(t, e) {
    return at(t.getTime(), e.getTime());
}
function Kn(t, e) {
    return t.name === e.name && t.message === e.message && t.cause === e.cause && t.stack === e.stack;
}
function Qn(t, e) {
    return t === e;
}
function Cr(t, e, n) {
    var i = t.size;
    if (i !== e.size)
        return !1;
    if (!i)
        return !0;
    for (var o = new Array(i), a = t.entries(), h, p, f = 0; (h = a.next()) && !h.done;) {
        for (var m = e.entries(), E = !1, l = 0; (p = m.next()) && !p.done;) {
            if (o[l]) {
                l++;
                continue;
            }
            var v = h.value, O = p.value;
            if (n.equals(v[0], O[0], f, l, t, e, n) && n.equals(v[1], O[1], v[0], O[0], t, e, n)) {
                E = o[l] = !0;
                break;
            }
            l++;
        }
        if (!E)
            return !1;
        f++;
    }
    return !0;
}
var Zn = at;
function eu(t, e, n) {
    var i = br(t), o = i.length;
    if (br(e).length !== o)
        return !1;
    for (; o-- > 0;)
        if (!Vr(t, e, n, i[o]))
            return !1;
    return !0;
}
function Tt(t, e, n) {
    var i = Ar(t), o = i.length;
    if (Ar(e).length !== o)
        return !1;
    for (var a, h, p; o-- > 0;)
        if (a = i[o], !Vr(t, e, n, a) || (h = Nr(t, a), p = Nr(e, a), (h || p) && (!h || !p || h.configurable !== p.configurable || h.enumerable !== p.enumerable || h.writable !== p.writable)))
            return !1;
    return !0;
}
function tu(t, e) {
    return at(t.valueOf(), e.valueOf());
}
function ru(t, e) {
    return t.source === e.source && t.flags === e.flags;
}
function yr(t, e, n) {
    var i = t.size;
    if (i !== e.size)
        return !1;
    if (!i)
        return !0;
    for (var o = new Array(i), a = t.values(), h, p; (h = a.next()) && !h.done;) {
        for (var f = e.values(), m = !1, E = 0; (p = f.next()) && !p.done;) {
            if (!o[E] && n.equals(h.value, p.value, h.value, p.value, t, e, n)) {
                m = o[E] = !0;
                break;
            }
            E++;
        }
        if (!m)
            return !1;
    }
    return !0;
}
function nu(t, e) {
    var n = t.length;
    if (e.length !== n)
        return !1;
    for (; n-- > 0;)
        if (t[n] !== e[n])
            return !1;
    return !0;
}
function uu(t, e) {
    return t.hostname === e.hostname && t.pathname === e.pathname && t.protocol === e.protocol && t.port === e.port && t.hash === e.hash && t.username === e.username && t.password === e.password;
}
function Vr(t, e, n, i) {
    return (i === Xn || i === Jn || i === Hn) && (t.$$typeof || e.$$typeof) ? !0 : zn(e, i) && n.equals(t[i], e[i], i, i, t, e, n);
}
var iu = "[object Arguments]", ou = "[object Boolean]", au = "[object Date]", su = "[object Error]", cu = "[object Map]", lu = "[object Number]", fu = "[object Object]", pu = "[object RegExp]", hu = "[object Set]", du = "[object String]", mu = "[object URL]", Eu = Array.isArray, Tr = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, wr = Object.assign, gu = Object.prototype.toString.call.bind(Object.prototype.toString);
function Du(t) {
    var e = t.areArraysEqual, n = t.areDatesEqual, i = t.areErrorsEqual, o = t.areFunctionsEqual, a = t.areMapsEqual, h = t.areNumbersEqual, p = t.areObjectsEqual, f = t.arePrimitiveWrappersEqual, m = t.areRegExpsEqual, E = t.areSetsEqual, l = t.areTypedArraysEqual, v = t.areUrlsEqual;
    return function (b, C, j) {
        if (b === C)
            return !0;
        if (b == null || C == null)
            return !1;
        var R = typeof b;
        if (R !== typeof C)
            return !1;
        if (R !== "object")
            return R === "number" ? h(b, C, j) : R === "function" ? o(b, C, j) : !1;
        var k = b.constructor;
        if (k !== C.constructor)
            return !1;
        if (k === Object)
            return p(b, C, j);
        if (Eu(b))
            return e(b, C, j);
        if (Tr != null && Tr(b))
            return l(b, C, j);
        if (k === Date)
            return n(b, C, j);
        if (k === RegExp)
            return m(b, C, j);
        if (k === Map)
            return a(b, C, j);
        if (k === Set)
            return E(b, C, j);
        var $ = gu(b);
        return $ === au ? n(b, C, j) : $ === pu ? m(b, C, j) : $ === cu ? a(b, C, j) : $ === hu ? E(b, C, j) : $ === fu ? typeof b.then != "function" && typeof C.then != "function" && p(b, C, j) : $ === mu ? v(b, C, j) : $ === su ? i(b, C, j) : $ === iu ? p(b, C, j) : $ === ou || $ === lu || $ === du ? f(b, C, j) : !1;
    };
}
function vu(t) {
    var e = t.circular, n = t.createCustomConfig, i = t.strict, o = {
        areArraysEqual: i ? Tt : Yn,
        areDatesEqual: Wn,
        areErrorsEqual: Kn,
        areFunctionsEqual: Qn,
        areMapsEqual: i ? vr(Cr, Tt) : Cr,
        areNumbersEqual: Zn,
        areObjectsEqual: i ? Tt : eu,
        arePrimitiveWrappersEqual: tu,
        areRegExpsEqual: ru,
        areSetsEqual: i ? vr(yr, Tt) : yr,
        areTypedArraysEqual: i ? Tt : nu,
        areUrlsEqual: uu
    };
    if (n && (o = wr({}, o, n(o))), e) {
        var a = Rt(o.areArraysEqual), h = Rt(o.areMapsEqual), p = Rt(o.areObjectsEqual), f = Rt(o.areSetsEqual);
        o = wr({}, o, {
            areArraysEqual: a,
            areMapsEqual: h,
            areObjectsEqual: p,
            areSetsEqual: f
        });
    }
    return o;
}
function Au(t) {
    return function (e, n, i, o, a, h, p) {
        return t(e, n, p);
    };
}
function Nu(t) {
    var e = t.circular, n = t.comparator, i = t.createState, o = t.equals, a = t.strict;
    if (i)
        return function (f, m) {
            var E = i(), l = E.cache, v = l === void 0 ? e ? /* @__PURE__ */ new WeakMap() : void 0 : l, O = E.meta;
            return n(f, m, {
                cache: v,
                equals: o,
                meta: O,
                strict: a
            });
        };
    if (e)
        return function (f, m) {
            return n(f, m, {
                cache: /* @__PURE__ */ new WeakMap(),
                equals: o,
                meta: void 0,
                strict: a
            });
        };
    var h = {
        cache: void 0,
        equals: o,
        meta: void 0,
        strict: a
    };
    return function (f, m) {
        return n(f, m, h);
    };
}
var bu = ze();
ze({ strict: !0 });
ze({ circular: !0 });
ze({
    circular: !0,
    strict: !0
});
ze({
    createInternalComparator: function () {
        return at;
    }
});
ze({
    strict: !0,
    createInternalComparator: function () {
        return at;
    }
});
ze({
    circular: !0,
    createInternalComparator: function () {
        return at;
    }
});
ze({
    circular: !0,
    createInternalComparator: function () {
        return at;
    },
    strict: !0
});
function ze(t) {
    t === void 0 && (t = {});
    var e = t.circular, n = e === void 0 ? !1 : e, i = t.createInternalComparator, o = t.createState, a = t.strict, h = a === void 0 ? !1 : a, p = vu(t), f = Du(p), m = i ? i(f) : Au(f);
    return Nu({ circular: n, comparator: f, createState: o, equals: m, strict: h });
}
function Cu(t, e) {
    return bu(t, e);
}
function yu(t, e) {
    if (typeof t != typeof e)
        return !1;
    if (!t && !e)
        return !0;
    if (Array.isArray(t)) {
        const a = e, h = t;
        return a.length === 0 ? !0 : a.every((p) => h.includes(p));
    }
    if (typeof t != "object")
        return Cu(t, e);
    const n = e, i = t;
    let o = !0;
    return Object.keys(n).forEach((a) => {
        o && (Object.hasOwn(i, a) && yu(i[a], n[a]) || (o = !1));
    }), o;
}
function Sr(t, e, n) {
    return JSON.stringify(t, (o, a) => {
        let h = a;
        return e && (h = e(o, h)), h === void 0 && (h = null), h;
    }, n);
}
function Tu(t, e) {
    function n(o) {
        return Object.keys(o).forEach((a) => {
            o[a] === null ? o[a] = void 0 : typeof o[a] == "object" && (o[a] = n(o[a]));
        }), o;
    }
    const i = JSON.parse(t, e);
    if (i !== null)
        return typeof i == "object" ? n(i) : i;
}
function bi(t) {
    try {
        const e = Sr(t);
        return e === Sr(Tu(e));
    }
    catch {
        return !1;
    }
}
const Ci = (t) => t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
function yi() {
    return typeof navigator < "u" && navigator.languages ? navigator.languages[0] : new Wr().resolvedOptions().locale;
}
function Ti(t, e = 2) {
    if (t === 0)
        return "0 Bytes";
    const n = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"], i = Math.floor(Math.log(t) / Math.log(1024)), o = n[i];
    return `${new un("en", {
        style: "decimal",
        maximumFractionDigits: e,
        minimumFractionDigits: 0
    }).format(t / 1024 ** i)} ${o}`;
}
const wu = 1e3, Gr = 60, zr = Gr * 60, Su = zr * 24;
function wi(t, e, n = /* @__PURE__ */ new Date()) {
    const i = Math.floor((e.getTime() - n.getTime()) / wu), o = Math.round(i / Su);
    if (Math.abs(o) >= 1)
        return t.format(o, "day");
    const a = Math.round(i / zr);
    if (Math.abs(a) >= 1)
        return t.format(a, "hour");
    const h = Math.round(i / Gr);
    return Math.abs(h) >= 1 ? t.format(h, "minute") : t.format(i, "second");
}
const zt = {
    projectSettingsContribution: {
        description: "The data an extension provides to inform Platform.Bible of the project settings it provides",
        anyOf: [
            {
                $ref: "#/$defs/projectSettingsGroup"
            },
            {
                type: "array",
                items: {
                    $ref: "#/$defs/projectSettingsGroup"
                }
            }
        ]
    },
    projectSettingsGroup: {
        description: "Group of related settings definitions",
        type: "object",
        properties: {
            label: {
                description: "localizeKey that displays in the project settings dialog as the group name",
                $ref: "#/$defs/localizeKey"
            },
            description: {
                description: "localizeKey that displays in the project settings dialog to describe the group",
                $ref: "#/$defs/localizeKey"
            },
            properties: {
                $ref: "#/$defs/projectSettingProperties"
            }
        },
        required: ["label", "properties"]
    },
    projectSettingProperties: {
        description: "Object whose keys are setting IDs and whose values are settings objects",
        type: "object",
        patternProperties: {
            "^[\\w\\-]+\\.[\\w\\-]+$": {
                $ref: "#/$defs/projectSetting"
            }
        },
        additionalProperties: !1
    },
    projectSetting: {
        description: "A description of an extension's setting entry",
        anyOf: [
            {
                $ref: "#/$defs/extensionControlledProjectSetting"
            }
        ]
    },
    extensionControlledProjectSetting: {
        description: "Setting definition that is validated by the extension.",
        allOf: [
            {
                $ref: "#/$defs/projectSettingBase"
            },
            {
                $ref: "#/$defs/modifierExtensionControlled"
            }
        ]
    },
    projectSettingBase: {
        description: "Base information needed to describe a project setting entry",
        allOf: [
            {
                $ref: "#/$defs/settingBase"
            },
            {
                $ref: "#/$defs/modifierProject"
            }
        ]
    },
    modifierProject: {
        description: "Modifies setting type to be project setting",
        type: "object",
        properties: {
            includeProjectInterfaces: {
                description: "String representation of `RegExp` pattern(s) to match against projects' `projectInterface`s (using the [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test) function) to determine if they should be included.\n\nIf this is one string, it will be matched against `projectInterface`s. If this is an array, each entry is handled based on its type (at least one entry must match for this filter condition to pass):\n\n- If the entry is a string, it will be matched against each `projectInterface`. If any match, the project will pass this filter condition\n- If the entry is an array of strings, each will be matched against each `projectInterface`. If every string matches against at least one `projectInterface`, the project will pass this filter condition\n\nIn other words, each entry in the first-level array is `OR`'ed together. Each entry in second-level arrays (arrays within the first-level array) are `AND`'ed together.\n\nDefaults to all {@link ProjectInterfaces}, so all projects that do not match `excludeProjectInterfaces` will be included\n\n@example\n\n```typescript\nincludeProjectInterfaces: ['one', ['two', 'three']];\n```\n\nThis filter condition will succeed on projects whose `projectInterface`s fulfill at least one of the following conditions (At least one entry in the array must match):\n\n- Include `one`\n- Include both `two` and `three`.",
                anyOf: [
                    {
                        type: "null"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "array",
                        items: {
                            anyOf: [
                                {
                                    type: "string"
                                },
                                {
                                    type: "array",
                                    items: { type: "string" }
                                }
                            ]
                        }
                    }
                ]
            },
            excludeProjectInterfaces: {
                description: "String representation of `RegExp` pattern(s) to match against projects' `projectInterface`s (using the [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test) function) to determine if they should absolutely not be included even if they match with `includeProjectInterfaces`.\n\nIf this is one string, it will be matched against `projectInterface`s. If this is an array, each entry is handled based on its type (at least one entry must match for this filter condition to exclude the project):\n\n- If the entry is a string, it will be matched against each `projectInterface`. If any match, the project will pass this filter condition and exclude the project\n- If the entry is an array of strings, each will be matched against each `projectInterface`. If every string matches against at least one `projectInterface`, the project will pass this filter condition and exclude the project\n\nIn other words, each entry in the first-level array is `OR`'ed together. Each entry in second-level arrays (arrays within the first-level array) are `AND`'ed together.\n\nDefaults to no {@link ProjectInterfaces}, so all projects that match `includeProjectInterfaces` will be included\n\n@example\n\n```typescript\nexcludeProjectInterfaces: ['one', ['two', 'three']];\n```\n\nThis filter condition will succeed and exclude projects whose `projectInterface`s fulfill at least one of the following conditions (At least one entry in the array must match):\n\n- Include `one`\n- Include both `two` and `three`.",
                anyOf: [
                    {
                        type: "null"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "array",
                        items: {
                            anyOf: [
                                {
                                    type: "string"
                                },
                                {
                                    type: "array",
                                    items: { type: "string" }
                                }
                            ]
                        }
                    }
                ]
            },
            includePdpFactoryIds: {
                description: "String representation of `RegExp` pattern(s) to match against the Project Data Provider Factory Ids that provided each project's metadata (using the [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test) function) to determine if the projects should be included.\n\nDefaults to all Project Data Provider Factory Ids, so all projects that do not match `excludePdpFactoryIds` will be included",
                anyOf: [
                    {
                        type: "null"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "array",
                        items: { type: "string" }
                    }
                ]
            },
            excludePdpFactoryIds: {
                description: "String representation of `RegExp` pattern(s) to match against the Project Data Provider Factory Ids that provided each project's metadata (using the [`test`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test) function) to determine if the projects should absolutely not be included even if they match with `includeProjectInterfaces`.\n\nDefaults to none, so all projects that match `includePdpFactoryIds` will be included",
                anyOf: [
                    {
                        type: "null"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "array",
                        items: { type: "string" }
                    }
                ]
            }
        }
    },
    settingsContribution: {
        description: "The data an extension provides to inform Platform.Bible of the settings it provides",
        anyOf: [
            {
                $ref: "#/$defs/settingsGroup"
            },
            {
                type: "array",
                items: {
                    $ref: "#/$defs/settingsGroup"
                }
            }
        ]
    },
    settingsGroup: {
        description: "Group of related settings definitions",
        type: "object",
        properties: {
            label: {
                description: "localizeKey that displays in the settings dialog as the group name",
                $ref: "#/$defs/localizeKey"
            },
            description: {
                description: "localizeKey that displays in the settings dialog to describe the group",
                $ref: "#/$defs/localizeKey"
            },
            properties: {
                $ref: "#/$defs/settingProperties"
            }
        },
        required: ["label", "properties"]
    },
    settingProperties: {
        description: "Object whose keys are setting IDs and whose values are settings objects",
        type: "object",
        patternProperties: {
            "^[\\w-]+\\.[\\w-]+$": {
                $ref: "#/$defs/setting"
            }
        },
        additionalProperties: !1
    },
    setting: {
        description: "A description of an extension's setting entry",
        anyOf: [
            {
                $ref: "#/$defs/extensionControlledSetting"
            }
        ]
    },
    extensionControlledSetting: {
        description: "Setting definition that is validated by the extension.",
        allOf: [
            {
                $ref: "#/$defs/settingBase"
            },
            {
                $ref: "#/$defs/modifierExtensionControlled"
            }
        ]
    },
    settingBase: {
        description: "Base information needed to describe a setting entry",
        allOf: [
            {
                $ref: "#/$defs/stateBase"
            },
            {
                type: "object",
                properties: {
                    label: {
                        description: "localizeKey that displays in the settings dialog as the setting name",
                        $ref: "#/$defs/localizeKey"
                    },
                    description: {
                        description: "localizeKey that displays in the settings dialog to describe the setting",
                        $ref: "#/$defs/localizeKey"
                    }
                },
                required: ["label"]
            }
        ]
    },
    projectStateContribution: {
        description: "The data an extension provides to inform Platform.Bible of the project state it provides",
        $ref: "#/$defs/userStateProperties"
    },
    userStateContribution: {
        description: "The data an extension provides to inform Platform.Bible of the user state it provides",
        $ref: "#/$defs/userStateProperties"
    },
    userStateProperties: {
        description: "Object whose keys are state IDs and whose values are state objects",
        type: "object",
        patternProperties: {
            "^[\\w\\-]+\\.[\\w\\-]+$": {
                $ref: "#/$defs/userState"
            }
        },
        additionalProperties: !1
    },
    userState: {
        description: "A description of an extension's user state entry",
        anyOf: [
            {
                $ref: "#/$defs/extensionControlledState"
            }
        ]
    },
    extensionControlledState: {
        description: "State definition that is validated by the extension.",
        allOf: [
            {
                $ref: "#/$defs/stateBase"
            },
            {
                $ref: "#/$defs/modifierExtensionControlled"
            }
        ]
    },
    modifierExtensionControlled: {
        description: 'Modifies state/setting type to be extension-controlled. "Extension-controlled" means the extension provides the component and the validator for the state/setting, so the state/setting is controlled by the extension.',
        not: {
            anyOf: [
                {
                    type: "object",
                    required: ["platformType"]
                },
                {
                    type: "object",
                    required: ["type"]
                }
            ]
        }
    },
    stateBase: {
        description: "Base information needed to describe a state entry",
        type: "object",
        properties: {
            default: {
                description: "default value for the state/setting",
                type: "any"
            },
            derivesFrom: {
                description: "a state/setting ID whose value to set to this state/setting's starting value the first time this state/setting is loaded",
                $ref: "#/$defs/id"
            }
        },
        required: ["default"]
    },
    localizeKey: {
        description: "Identifier for a string that will be localized based on the user's UI language",
        type: "string",
        pattern: "^%[\\w\\-\\.]+%$",
        tsType: "LocalizeKey"
    },
    id: {
        description: "",
        type: "string",
        pattern: "^[\\w\\-]+\\.[\\w\\-]+$",
        tsType: "Id"
    }
};
function Ht(t) {
    t && Object.values(t).forEach((e) => {
        if (e.type) {
            if ("tsType" in e && delete e.tsType, e.type === "any") {
                delete e.type;
                return;
            }
            e.type === "object" && Ht(e.properties);
        }
    });
}
Ht(zt);
const Ou = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    title: "Project Settings Contribution",
    description: "The data an extension provides to inform Platform.Bible of the project settings it provides",
    anyOf: [
        {
            $ref: "#/$defs/projectSettingsGroup"
        },
        {
            type: "array",
            items: {
                $ref: "#/$defs/projectSettingsGroup"
            }
        }
    ],
    $defs: zt
};
Object.freeze(Ou);
const Iu = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    title: "Settings Contribution",
    description: "The data an extension provides to inform Platform.Bible of the settings it provides",
    anyOf: [
        {
            $ref: "#/$defs/settingsGroup"
        },
        {
            type: "array",
            items: {
                $ref: "#/$defs/settingsGroup"
            }
        }
    ],
    $defs: zt
};
Object.freeze(Iu);
const Hr = {
    languageStrings: {
        description: "Map whose keys are localized string keys and whose values provide information about how to localize strings for the localized string key",
        type: "object",
        patternProperties: {
            "^%[\\w\\-\\.]+%$": {
                $ref: "#/$defs/localizedStringValue"
            }
        },
        additionalProperties: !1
    },
    localizedStringValue: {
        description: "Localized string value associated with this key",
        type: "string"
    },
    stringsMetadata: {
        description: "Map whose keys are localized string keys and whose values provide additional non-locale-specific information about the localized string key",
        type: "object",
        patternProperties: {
            "^%[\\w\\-\\.]+%$": {
                $ref: "#/$defs/stringMetadata"
            }
        },
        additionalProperties: !1
    },
    stringMetadata: {
        description: "Additional non-locale-specific information about a localized string key",
        type: "object",
        properties: {
            fallbackKey: {
                description: "Localized string key from which to get this value if one does not exist in the specified language. If a new key/value pair needs to be made to replace an existing one, this could help smooth over the transition if the meanings are close enough.\nYou can use Paratext 9 Localized String Keys here. Be sure to escape any % signs with a backslash `\\`.",
                type: "string",
                pattern: "^%[\\w\\-\\.;&,' (){}#:/\\\\?%â‹®|[\\]â€œâ€â€˜â€™!~*Â +=â€¢`â€¦â€‹â†‘â†“]+%$",
                tsType: "LocalizeKey"
            },
            notes: {
                description: "Additional information provided by developers in English to help the translator to know how to translate this localized string accurately",
                type: "string"
            }
        }
    },
    localizeKey: {
        description: "Identifier for a string that will be localized based on the user's UI language",
        type: "string",
        pattern: "^%[\\w\\-\\.]+%$",
        tsType: "LocalizeKey"
    }
};
Ht(Hr);
const xu = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    title: "Localized String Data Contribution",
    description: "The data an extension provides to inform Platform.Bible of the localized strings it provides.",
    type: "object",
    properties: {
        metadata: {
            $ref: "#/$defs/stringsMetadata"
        },
        localizedStrings: {
            type: "object",
            additionalProperties: {
                $ref: "#/$defs/languageStrings"
            }
        }
    },
    $defs: Hr
};
Object.freeze(xu);
const Mu = {
    title: "Platform.Bible menus",
    type: "object",
    properties: {
        mainMenu: {
            description: "Top level menu for the application",
            $ref: "#/$defs/multiColumnMenu"
        },
        defaultWebViewTopMenu: {
            description: "Default top menu for web views that don't specify their own",
            $ref: "#/$defs/multiColumnMenu"
        },
        defaultWebViewContextMenu: {
            description: "Default context menu for web views that don't specify their own",
            $ref: "#/$defs/singleColumnMenu"
        },
        webViewMenus: {
            description: "Menus that apply per web view in the application",
            type: "object",
            patternProperties: {
                "^[\\w\\-]+\\.[\\w\\-]+$": {
                    $ref: "#/$defs/menusForOneWebView"
                }
            },
            additionalProperties: !1
        }
    },
    required: ["mainMenu", "defaultWebViewTopMenu", "defaultWebViewContextMenu", "webViewMenus"],
    additionalProperties: !1,
    $defs: {
        localizeKey: {
            description: "Identifier for a string that will be localized in a menu based on the user's UI language",
            type: "string",
            pattern: "^%[\\w\\-\\.]+%$"
        },
        referencedItem: {
            description: "Name of some UI element (i.e., tab, column, group, menu item) or some PAPI object (i.e., command)",
            type: "string",
            pattern: "^[\\w\\-]+\\.[\\w\\-]+$"
        },
        columnsWithHeaders: {
            description: "Group of columns that can be combined with other columns to form a multi-column menu",
            type: "object",
            patternProperties: {
                "^[\\w\\-]+\\.[\\w\\-]+$": {
                    description: "Single column with a header string",
                    type: "object",
                    properties: {
                        label: {
                            description: "Header text for this this column in the UI",
                            $ref: "#/$defs/localizeKey"
                        },
                        localizeNotes: {
                            description: "Additional information provided by developers to help people who perform localization",
                            type: "string"
                        },
                        order: {
                            description: "Relative order of this column compared to other columns (sorted ascending)",
                            type: "number"
                        },
                        isExtensible: {
                            description: "Defines whether contributions are allowed to add menu groups to this column",
                            type: "boolean"
                        }
                    },
                    required: ["label", "order"],
                    additionalProperties: !1
                }
            },
            properties: {
                isExtensible: {
                    description: "Defines whether contributions are allowed to add columns to this multi-column menu",
                    type: "boolean"
                }
            }
        },
        menuGroups: {
            description: "Group of menu items that can be combined with other groups to form a single menu/submenu. Groups are separated using a line within the menu/submenu.",
            type: "object",
            patternProperties: {
                "^[\\w\\-]+\\.[\\w\\-]+$": {
                    description: "Single group that contains menu items",
                    type: "object",
                    oneOf: [
                        {
                            properties: {
                                column: {
                                    description: "Column where this group belongs, not required for single column menus",
                                    $ref: "#/$defs/referencedItem"
                                },
                                order: {
                                    description: "Relative order of this group compared to other groups in the same column or submenu (sorted ascending)",
                                    type: "number"
                                },
                                isExtensible: {
                                    description: "Defines whether contributions are allowed to add menu items to this menu group",
                                    type: "boolean"
                                }
                            },
                            required: ["order"],
                            additionalProperties: !1
                        },
                        {
                            properties: {
                                menuItem: {
                                    description: "Menu item that anchors the submenu where this group belongs",
                                    $ref: "#/$defs/referencedItem"
                                },
                                order: {
                                    description: "Relative order of this group compared to other groups in the same column or submenu (sorted ascending)",
                                    type: "number"
                                },
                                isExtensible: {
                                    description: "Defines whether contributions are allowed to add menu items to this menu group",
                                    type: "boolean"
                                }
                            },
                            required: ["menuItem", "order"],
                            additionalProperties: !1
                        }
                    ]
                }
            },
            additionalProperties: !1
        },
        menuItem: {
            description: "Single item in a menu that can be clicked on to take an action or can be the parent of a submenu",
            type: "object",
            oneOf: [
                {
                    properties: {
                        id: {
                            description: "ID for this menu item that holds a submenu",
                            $ref: "#/$defs/referencedItem"
                        }
                    },
                    required: ["id"]
                },
                {
                    properties: {
                        command: {
                            description: "Name of the PAPI command to run when this menu item is selected.",
                            $ref: "#/$defs/referencedItem"
                        },
                        iconPathBefore: {
                            description: "Uri path to the icon to display before the menu text. Ex: `papi-extension://helloWorld/assets/icon.png`",
                            type: "string"
                        },
                        iconPathAfter: {
                            description: "Uri path to the icon to display after the menu text. Ex: `papi-extension://helloWorld/assets/icon.png`",
                            type: "string"
                        }
                    },
                    required: ["command"]
                }
            ],
            properties: {
                label: {
                    description: "Key that represents the text of this menu item to display",
                    $ref: "#/$defs/localizeKey"
                },
                tooltip: {
                    description: "Key that represents the text to display if a mouse pointer hovers over the menu item",
                    $ref: "#/$defs/localizeKey"
                },
                searchTerms: {
                    description: "Key that represents additional words the platform should reference when users are searching for menu items",
                    $ref: "#/$defs/localizeKey"
                },
                localizeNotes: {
                    description: "Additional information provided by developers to help people who perform localization",
                    type: "string"
                },
                group: {
                    description: "Group to which this menu item belongs",
                    $ref: "#/$defs/referencedItem"
                },
                order: {
                    description: "Relative order of this menu item compared to other menu items in the same group (sorted ascending)",
                    type: "number"
                }
            },
            required: ["label", "group", "order"],
            unevaluatedProperties: !1
        },
        groupsAndItems: {
            description: "Core schema for a column",
            type: "object",
            properties: {
                groups: {
                    description: "Groups that belong in this menu",
                    $ref: "#/$defs/menuGroups"
                },
                items: {
                    description: "List of menu items that belong in this menu",
                    type: "array",
                    items: { $ref: "#/$defs/menuItem" },
                    uniqueItems: !0
                }
            },
            required: ["groups", "items"]
        },
        singleColumnMenu: {
            description: "Menu that contains a column without a header",
            type: "object",
            allOf: [{ $ref: "#/$defs/groupsAndItems" }],
            unevaluatedProperties: !1
        },
        multiColumnMenu: {
            description: "Menu that can contain multiple columns with headers",
            type: "object",
            allOf: [
                { $ref: "#/$defs/groupsAndItems" },
                {
                    properties: {
                        columns: {
                            description: "Columns that belong in this menu",
                            $ref: "#/$defs/columnsWithHeaders"
                        }
                    },
                    required: ["columns"]
                }
            ],
            unevaluatedProperties: !1
        },
        menusForOneWebView: {
            description: "Set of menus that are associated with a single tab",
            type: "object",
            properties: {
                includeDefaults: {
                    description: "Indicates whether the platform default menus should be included for this webview",
                    type: "boolean"
                },
                topMenu: {
                    description: "Menu that opens when you click on the top left corner of a tab",
                    $ref: "#/$defs/multiColumnMenu"
                },
                contextMenu: {
                    description: "Menu that opens when you right click on the main body/area of a tab",
                    $ref: "#/$defs/singleColumnMenu"
                }
            },
            additionalProperties: !1
        }
    }
};
Object.freeze(Mu);
const je = ["figure", "note", "sidebar", "table"];
Object.freeze(je);
class Ee {
    constructor(e) {
        W(this, "usj");
        W(this, "parentMapInternal");
        this.usj = e;
    }
    // If new variables are created to speed up queries, they should be reset here
    usjChanged() {
        this.parentMapInternal = void 0;
    }
    // #region Directly using the JSONPath package to perform JSONPath query -> USJ node
    findSingleValue(e) {
        const n = (0,jsonpath_plus__WEBPACK_IMPORTED_MODULE_1__.JSONPath)({ path: e, json: this.usj, wrap: !0 });
        if (n === void 0 || n.length === 0)
            return;
        if (!Array.isArray(n[0]))
            return n[0];
        const i = (0,jsonpath_plus__WEBPACK_IMPORTED_MODULE_1__.JSONPath)({ path: e, json: this.usj, wrap: !1 });
        return i.length === 1 && Array.isArray(i[0]) ? i[0] : i;
    }
    findParent(e) {
        return this.findSingleValue(`${e}^`);
    }
    findBookId() {
        return this.findSingleValue('$.content[?(@.type=="book" && @.marker=="id")].code');
    }
    findChapterNode(e) {
        const n = `$..content[?(@.type=="chapter" && @.number=="${e}")]`;
        return this.findSingleValue(n);
    }
    // #endregion
    // #region Parent Maps
    static createParentMapInternal(e, n, i) {
        var o;
        i.set(e, n), e.content && i.set(e.content, e), (o = e.content) == null || o.forEach((a) => {
            typeof a == "object" && Ee.createParentMapInternal(a, e, i);
        });
    }
    /** Viewing a Usj object as a tree, build a map to walk up the tree */
    createUsjParentMap() {
        const e = /* @__PURE__ */ new Map();
        return this.usj.content && e.set(this.usj.content, this.usj), this.usj.content.forEach((n) => {
            typeof n == "object" && Ee.createParentMapInternal(n, this.usj, e);
        }), e;
    }
    /** Create the parent map if it doesn't already exist and return it */
    get parentMap() {
        return this.parentMapInternal ? this.parentMapInternal : (this.parentMapInternal = this.createUsjParentMap(), this.parentMapInternal);
    }
    // #endregion
    // #region Working Stacks
    /** Return the working stack applicable to the given node */
    createWorkingStack(e) {
        const n = [], { parentMap: i } = this;
        let o = e, a = i.get(o);
        for (; a !== void 0;) {
            if (!a.content)
                throw new Error("Invalid parentMap: all parents should have content");
            if (
            // Referencing tempNode and tempParent is OK in the loop since 'let' is used instead of 'var'
            // eslint-disable-next-line no-loop-func
            !a.content.find((h, p) => {
                if (h !== o)
                    return !1;
                if (!a)
                    throw new Error('undefined "tempParent" should not be possible');
                return n.unshift({ parent: a, index: p }), !0;
            }))
                throw new Error(`Unable to find correct parent node of ${JSON.stringify(o)}`);
            if (a.type === Ut)
                break;
            o = a, a = i.get(a);
        }
        return n;
    }
    static convertWorkingStackToJsonPath(e) {
        let n = "$";
        return e.forEach((i) => {
            n = `${n}.content[${i.index}]`;
        }), n;
    }
    convertJsonPathToWorkingStack(e) {
        const n = [], i = e.match(/content\[(\d+)\]/g);
        if (!i)
            throw new Error(`Malformed or unexpected jsonPath: ${e}`);
        let o = this.usj;
        return i.forEach((a, h) => {
            const p = /(\d+)/.exec(a);
            if (!p)
                throw new Error(`Malformed or unexpected jsonPath: ${e}`);
            const f = parseInt(p[0], 10);
            if (n.push({ parent: o, index: f }), h + 1 < i.length) {
                if (typeof o == "string" || !o.content)
                    throw new Error(`jsonPath points to node without children: ${JSON.stringify(o)}`);
                const m = o.content[f];
                if (typeof m == "string")
                    throw new Error(`jsonPath points to node without children: ${JSON.stringify(m)}`);
                o = m;
            }
        }), n;
    }
    // #endregion
    // #region Walk the node tree
    /**
     * Given the starting point of a tree to consider (`node`), find the rightmost MarkerObject from
     * the array of `content`. In the following example, this would be "J".
     *
     *         A        <- Consider "A" to be `node`
     *     / / | \ \
     *     B C D E F    <- Consider these to be MarkerObjects inside the `content` array owned by "A"
     *     |  / \  |
     *     G H   I J    <- Consider these to be MarkerObjects inside their parents `content` arrays
     *
     * If "F" did not exist in this example, then "E" would be returned. If "E" and "F" didn't exist,
     * then "I" would be returned.
     *
     * The general idea here is that we are looking for the MarkerObject in Usj that is immediately
     * adjacent to whatever `node`'s next sibling is in `parent`'s `content` array.
     */
    static findRightMostDescendantMarkerObject(e, n, i = []) {
        if (!e.content)
            return { node: e, parent: n };
        for (let o = e.content.length - 1; o >= 0; o--) {
            const a = e.content[o];
            if (typeof a == "object" && !i.includes(a.type))
                return a.content ? this.findRightMostDescendantMarkerObject(a, e, i) : { node: a, parent: e };
        }
        return { node: e, parent: n };
    }
    static findNextMatchingNodeUsingWorkingStack(e, n, i, o) {
        var h;
        let a = e;
        for (; a !== void 0;) {
            const p = typeof a == "object" && i.includes(a.type);
            if (!p && o(a, n))
                return a;
            if (!p && typeof a == "object" && (((h = a.content) == null ? void 0 : h.length) ?? 0) > 0)
                n.push({ parent: a, index: 0 }), [a] = a.content;
            else
                for (a = void 0; n.length > 0;) {
                    const f = n.pop();
                    if (f && f.index + 1 < f.parent.content.length) {
                        f.index += 1, n.push(f), a = f.parent.content[f.index];
                        break;
                    }
                }
        }
    }
    /**
     * Walk through a USJ node tree depth-first, left-to-right to find the first node that matches
     * criteria specified by `searchFunction` (i.e., the first node where `searchFunction` returns
     * `true`)
     */
    findNextMatchingNode(e, n, i) {
        const o = this.createWorkingStack(e);
        return Ee.findNextMatchingNodeUsingWorkingStack(e, o, n, i);
    }
    // #endregion
    // #region Node -> JSONPath
    nodeToJsonPath(e) {
        return Ee.convertWorkingStackToJsonPath(this.createWorkingStack(e));
    }
    // #endregion
    // #region USJ + node -> SerializedVerseRef + offset
    /** Find the chapter and verse that apply to a given USJ node */
    findVerseRefForNode(e, n, i = {
        chapterNum: void 0,
        verseNum: void 0,
        startingContentNode: void 0
    }) {
        if (i.verseNum !== void 0 && i.chapterNum !== void 0)
            return i;
        if (typeof e == "object" && e.number !== void 0) {
            const f = Number.parseInt(e.number, 10);
            if (e.type === Mt)
                return i.chapterNum = f, i.verseNum = i.verseNum ?? 0, i.startingContentNode = i.startingContentNode ?? e, i;
            e.type === Bt && !i.verseNum && (i.verseNum = f, i.startingContentNode = e);
        }
        if (!n.content)
            throw new Error(`"content" array not found: ${JSON.stringify(n)}`);
        let o = 0;
        for (let f = 0; f < n.content.length; f++)
            if (n.content[f] === e) {
                o = f;
                break;
            }
        let a = o - 1;
        for (; a >= 0 && typeof n.content[a] != "object";)
            a -= 1;
        if (a < 0) {
            if (n.type === Ut)
                return i.chapterNum === void 0 && (i.chapterNum = 1, i.verseNum = 0, i.startingContentNode = void 0), i;
            const f = n, m = this.parentMap.get(f);
            if (!m)
                throw new Error(`No parent found for ${JSON.stringify(n)}`);
            return this.findVerseRefForNode(f, m, i);
        }
        const h = n.content[a], p = Ee.findRightMostDescendantMarkerObject(h, n, je);
        return this.findVerseRefForNode(p.node, p.parent, i);
    }
    nodeToVerseRefAndOffset(e, n, i) {
        if (typeof n == "string" && i === void 0)
            throw new Error('If "node" is a string, then "nodeParent" cannot be undefined');
        let o;
        if (i === void 0 ? o = this.parentMap.get(n) : o = Array.isArray(i) ? this.parentMap.get(i) : i, o === void 0)
            throw new Error(`Cannot find parent for ${JSON.stringify(i)}`);
        const a = this.findVerseRefForNode(n, o);
        if (!a)
            return;
        if (!a.chapterNum)
            throw new Error(`Could not determine chapter number for ${JSON.stringify(n)}`);
        const h = {
            book: e,
            chapterNum: a.chapterNum,
            verseNum: a.verseNum ?? 0
        };
        let p = 0;
        return a.startingContentNode !== void 0 && this.findNextMatchingNode(a.startingContentNode, [], (f, m) => {
            var E, l;
            return f === n ? !0 : m.find((v) => je.includes(v.parent.type)) ? !1 : typeof f == "string" ? (p += f.length, !1) : f.type === Mt && f.number !== ((E = a.chapterNum) == null ? void 0 : E.toString()) || f.type === Bt && f.number !== ((l = a.verseNum) == null ? void 0 : l.toString()) ? (p = 0, !0) : !1;
        }), { verseRef: h, offset: p };
    }
    // #endregion
    // #region JSONPath -> SerializedVerseRef + offset
    jsonPathToVerseRefAndOffset(e, n) {
        const i = n ?? this.findBookId();
        if (!i)
            throw new Error("Not able to determine the book ID");
        const o = this.findSingleValue(e);
        if (!o)
            throw new Error(`No result found for JSONPath query: ${e}`);
        const a = this.findParent(e);
        if (!a)
            throw new Error(`Could not determine parent for ${e}`);
        const h = this.nodeToVerseRefAndOffset(i, o, a);
        if (!h)
            throw new Error(`Could not determine SerializedVerseRef that corresponds to ${e}`);
        return h;
    }
    // #endregion
    // #region SerializedVerseRef + offset -> Node + JSONPath + offset
    verseRefToUsjContentLocation(e, n = 0) {
        if (n < 0)
            throw new Error("offset must be >= 0");
        const i = this.findBookId() ?? e.book;
        if (!i)
            throw new Error("Not able to determine the book ID");
        if (i !== e.book)
            throw new Error(`Book IDs don't match: USJ=${i}, SerializedVerseRef=${e.book}`);
        const o = this.findChapterNode(e.chapterNum);
        if (o === void 0)
            throw new Error(`Could not find ${i} chapter ${e.chapterNum}`);
        let a = !1, h = "";
        const p = e.verse ?? e.verseNum.toString(), f = this.findNextMatchingNode(o, je, (v, O) => v === o ? e.verseNum === 0 ? (h = Ee.convertWorkingStackToJsonPath(O), !0) : !1 : typeof v != "object" ? !1 : v.type === Mt ? (a = !0, !0) : v.type === Bt && v.number !== void 0 && v.number === p ? (h = Ee.convertWorkingStackToJsonPath(O), !0) : !1);
        if (a || f === void 0 || typeof f == "string")
            throw new Error(`Verse ${p} not found in ${i} ${e.chapterNum}`);
        if (n === 0)
            return { node: f, offset: 0, jsonPath: h };
        let m = 0, E = 0, l;
        return this.findNextMatchingNode(f, je, (v, O) => {
            if (v === f)
                return !1;
            if (typeof v == "string") {
                if (m += v.length, m > n)
                    return h = Ee.convertWorkingStackToJsonPath(O), E = n - m + v.length, l = v, !0;
            }
            else if (v.type === Mt || v.type === Bt)
                return !0;
            return !1;
        }), { node: l ?? f, offset: E, jsonPath: h };
    }
    // #endregion
    // #region Search for text from a node + JSONPath + offset
    findNextLocationOfMatchingText(e, n, i = 1e3) {
        let o = "", a = 0, h = 0, p = 0;
        if (Ee.findNextMatchingNodeUsingWorkingStack(e.node, this.convertJsonPathToWorkingStack(e.jsonPath), je, (l) => {
            if (typeof l != "string")
                return !1;
            a += l.length, o = `${o}${l}`;
            const v = o.indexOf(n);
            return v < 0 ? (h += o.length, o.length > n.length && (o = o.substring(o.length - n.length)), h -= o.length, a > i) : (p = h + v, !0);
        }), p <= 0)
            return;
        a = 0;
        let f = 0, m = [];
        const E = Ee.findNextMatchingNodeUsingWorkingStack(e.node, this.convertJsonPathToWorkingStack(e.jsonPath), je, (l, v) => typeof l != "string" || (a += l.length, a < p + 1) ? !1 : (f = p - a + l.length, m = v, !0));
        if (!E)
            throw new Error("Internal error: inconsistent search results");
        return {
            node: E,
            offset: f,
            jsonPath: Ee.convertWorkingStackToJsonPath(m)
        };
    }
    // #endregion
    // #region Extract text from a node + JSONPath + offset
    extractText(e, n) {
        let i = "", o = e.offset, a = 0;
        return Ee.findNextMatchingNodeUsingWorkingStack(e.node, this.convertJsonPathToWorkingStack(e.jsonPath), je, (h) => {
            if (typeof h != "string")
                return !1;
            if (o >= h.length)
                return o -= h.length, !1;
            let p = h;
            if (o > 0 && (p = p.substring(o), o = 0), a + p.length < n)
                return a += p.length, i = `${i}${p}`, !1;
            const f = n - a;
            return i = `${i}${p.substring(0, f - 1)}`, !0;
        }), i;
    }
    extractTextBetweenPoints(e, n, i = 100) {
        let o = "";
        return Ee.findNextMatchingNodeUsingWorkingStack(e.node, this.convertJsonPathToWorkingStack(e.jsonPath), je, (a, h) => a === n.node && (typeof a == "object" || n.jsonPath === Ee.convertWorkingStackToJsonPath(h)) ? !0 : typeof a != "string" ? !1 : (o = `${o}${a}`, o.length > i && (o = o.substring(0, i)), o.length >= i)), o;
    }
    // #endregion
    // #region Edit this USJ data
    static removeContentNodesFromArray(e, n) {
        let i = 0;
        for (let o = e.length - 1; o >= 0; o--) {
            const a = e[o];
            n(a) ? (e.splice(o, 1), i += 1) : typeof a != "string" && a.content && (i += this.removeContentNodesFromArray(a.content, n));
        }
        return i;
    }
    removeContentNodes(e) {
        const n = Ee.removeContentNodesFromArray(this.usj.content, e);
        return this.usjChanged(), n;
    }
}




/***/ }),

/***/ "./release/app/buildInfo.json":
/*!************************************!*\
  !*** ./release/app/buildInfo.json ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"build":"mgetgen-dev.20250408175117.62a38561273dbf67434bdf1ddf3f0849d13f3e76"}');

/***/ }),

/***/ "./release/app/package.json":
/*!**********************************!*\
  !*** ./release/app/package.json ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"platform-bible","version":"0.3.0","description":"Extensible Bible translation software","license":"MIT","author":{"name":"Platform","url":"https://github.com/paranext/"},"main":"./dist/main/main.js","scripts":{"rebuild":"node -r ts-node/register ../../.erb/scripts/electron-rebuild.js","postinstall":"npm run rebuild && npm run link-modules","link-modules":"node -r ts-node/register ../../.erb/scripts/link-modules.ts"},"dependencies":{},"volta":{"extends":"../../package.json"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.dev.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			"main": 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("./" + __webpack_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(__webpack_require__.s = "./src/main/main.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQU87QUFDakMsa0JBQWtCLFFBQVEsT0FBTztBQUNqQyxrQkFBa0IsUUFBUSxPQUFPO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRTs7QUFFMUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxFQUFFLFVBQVUsRUFBRTtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxhQUFhO0FBQzFDO0FBQ0EsZ0JBQWdCLGFBQWEsYUFBYTtBQUMxQztBQUNBLGdCQUFnQixhQUFhLGFBQWE7QUFDMUM7QUFDQSxnQkFBZ0IsYUFBYSxhQUFhO0FBQzFDO0FBQ0EsZ0JBQWdCLGFBQWEsYUFBYTtBQUMxQztBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0MEJBLG9CQUFvQixtQkFBTyxDQUFDLGtFQUFlO0FBQzNDLGNBQWMsbUJBQU8sQ0FBQyxzREFBUzs7QUFFL0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3REFBd0QsdUNBQXVDO0FBQy9GLHNEQUFzRCxxQ0FBcUM7O0FBRTNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7Ozs7Ozs7Ozs7O0FDaEZBLG9CQUFvQixtQkFBTyxDQUFDLGtFQUFlOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9GWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU0saURBQXVCO0FBQzdCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xXYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7Ozs7Ozs7Ozs7O0FDclduQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSx1QkFBdUI7QUFDcEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWix3Q0FBd0MsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0Isc0JBQXNCLE9BQU87O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0I7QUFDeEIsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLG9CQUFvQjtBQUNwQixhQUFhLGVBQWUsR0FBRyx5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEMsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSyxZQUFZLEtBQUs7QUFDekU7QUFDQTtBQUNBLG1EQUFtRCxLQUFLLFlBQVksS0FBSztBQUN6RTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsdUZBQXVGO0FBQzdJO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0Q7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEI7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFNBQVM7QUFDcEIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsWUFBWTtBQUN6QixhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QixVQUFVLG9CQUFvQjtBQUM5QixVQUFVLGNBQWM7QUFDeEIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUscUJBQXFCO0FBQy9CLFVBQVUsUUFBUTtBQUNsQixZQUFZO0FBQ1o7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEI7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEI7O0FBRUE7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLGFBQWE7QUFDdkIsWUFBWTtBQUNaOztBQUVBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWM7QUFDZCxZQUFZO0FBQ1osY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVEsV0FBVztBQUNqQyxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWMsMEJBQTBCO0FBQ3hDLGNBQWMsYUFBYTtBQUMzQixjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLG1CQUFtQjtBQUNqQztBQUNBLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtB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QyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDLEVBQUUsWUFBWSxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMzTSxNQUFNLEVBQUUsR0FBRztJQUNULEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsK0NBQStDO0lBQy9DLEtBQUs7SUFDTCwrQ0FBK0M7SUFDL0MsS0FBSztJQUNMLCtDQUErQztJQUMvQyxLQUFLO0lBQ0wscURBQXFEO0lBQ3JELEtBQUs7SUFDTCwrQ0FBK0M7SUFDL0MsS0FBSztJQUNMLCtDQUErQztJQUMvQyxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLE1BQU07SUFDTixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCwyQ0FBMkM7SUFDM0MsS0FBSztJQUNMLCtEQUErRDtJQUMvRCxLQUFLO0lBQ0wsK0RBQStEO0lBQy9ELEtBQUs7SUFDTCwrREFBK0Q7SUFDL0QsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLE1BQU07SUFDTixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lB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QUUsQ0FBQyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLElBQUk7WUFDalYsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLE9BQU8sQ0FBQyxJQUFJLFFBQVEsRUFBRSxDQUFDO2dCQUN0QyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDM0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xDLENBQUM7aUJBQU0sSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLE9BQU8sQ0FBQyxJQUFJLFFBQVEsRUFBRSxDQUFDO2dCQUM3QyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3BELElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FDekYsQ0FBQyxHQUFHLENBQUMsQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsbUJBQW1CLENBQy9DLEVBQUUsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUN4RCxDQUFDO2lCQUFNLElBQUksQ0FBQyxJQUFJLElBQUk7Z0JBQ2xCLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUM7b0JBQ2hDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDWixJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsYUFBYSxDQUFDO2dCQUN2SixDQUFDO3FCQUFNLENBQUM7b0JBQ04sSUFBSSxDQUFDLElBQUksSUFBSTt3QkFBRSxPQUFPO29CQUN0QixNQUFNLENBQUMsR0FBRyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQztvQkFDdkQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbkIsQ0FBQzs7Z0JBRUQsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO2FBQ3RELElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJO1lBQzFDLElBQUksT0FBTyxDQUFDLElBQUksUUFBUSxJQUFJLE9BQU8sQ0FBQyxJQUFJLFFBQVEsSUFBSSxPQUFPLENBQUMsSUFBSSxRQUFRO2dCQUN0RSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztpQkFDNUMsSUFBSSxPQUFPLENBQUMsSUFBSSxRQUFRLElBQUksT0FBTyxDQUFDLElBQUksUUFBUSxJQUFJLE9BQU8sQ0FBQyxJQUFJLFFBQVE7Z0JBQzNFLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQzs7Z0JBRTlHLE1BQU0sSUFBSSxLQUFLLENBQUMscUNBQXFDLENBQUMsQ0FBQzs7WUFFekQsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFDRDs7T0FFRztJQUNILE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ3ZCLE9BQU8sQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQzFJLENBQUM7SUFDRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNmLElBQUksQ0FBQyxDQUFDO1FBQ04sSUFBSSxDQUFDO1lBQ0gsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ3BELENBQUM7UUFBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQ1gsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDakIsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUM7WUFDbkQsTUFBTSxDQUFDLENBQUM7UUFDVixDQUFDO0lBQ0gsQ0FBQztJQUNEOzs7Ozs7OztPQVFHO0lBQ0gsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDekIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlJLENBQUM7SUFDRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2YsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3hHLElBQUksQ0FBQyxDQUFDO1FBQ04sT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBQzFFLENBQUM7SUFDRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUNyQixJQUFJLENBQUMsQ0FBQztRQUNOLElBQUksQ0FBQyxDQUFDO1lBQ0osT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQzFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDTixJQUFJLENBQUMsQ0FBQztRQUNOLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDbEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUc7Z0JBQzlCLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUN2RCxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVc7Z0JBQ3hDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUM1QyxDQUFDO1FBQ0QsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUFDbEMsQ0FBQztJQUNEOztPQUVHO0lBQ0gsSUFBSSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUMsT0FBTyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQztJQUMxRyxDQUFDO0lBQ0Q7O09BRUc7SUFDSCxJQUFJLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQztJQUNoSSxDQUFDO0lBQ0Q7OztPQUdHO0lBQ0gsSUFBSSxJQUFJO1FBQ04sT0FBTyxFQUFFLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUNELElBQUksSUFBSSxDQUFDLENBQUM7UUFDUixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUNEOztPQUVHO0lBQ0gsSUFBSSxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbkYsQ0FBQztJQUNELElBQUksT0FBTyxDQUFDLENBQUM7UUFDWCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNiLElBQUksQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBQ0Q7OztPQUdHO0lBQ0gsSUFBSSxLQUFLO1FBQ1AsT0FBTyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25ILENBQUM7SUFDRCxJQUFJLEtBQUssQ0FBQyxDQUFDO1FBQ1QsTUFBTSxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNuSyxDQUFDO0lBQ0Q7O09BRUc7SUFDSCxJQUFJLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdkIsQ0FBQztJQUNELElBQUksT0FBTyxDQUFDLENBQUM7UUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRO1lBQzNCLE1BQU0sSUFBSSxFQUFFLENBQ1YsdUVBQXVFLENBQ3hFLENBQUM7UUFDSixJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztJQUNwQixDQUFDO0lBQ0Q7O09BRUc7SUFDSCxJQUFJLFVBQVU7UUFDWixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQUNELElBQUksVUFBVSxDQUFDLENBQUM7UUFDZCxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBQ0Q7O09BRUc7SUFDSCxJQUFJLFFBQVE7UUFDVixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDeEIsQ0FBQztJQUNELElBQUksUUFBUSxDQUFDLENBQUM7UUFDWixJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBQ0Q7Ozs7T0FJRztJQUNILElBQUksZ0JBQWdCO1FBQ2xCLElBQUksQ0FBQyxDQUFDO1FBQ04sT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUM1RCxDQUFDO0lBQ0QsSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBQ0Q7O09BRUc7SUFDSCxJQUFJLEtBQUs7UUFDUCxPQUFPLElBQUksQ0FBQyxXQUFXLEtBQUssQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFDRDs7T0FFRztJQUNILElBQUksV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDLHVCQUF1QixDQUFDLENBQUM7SUFDL0UsQ0FBQztJQUNEOzs7T0FHRztJQUNILElBQUksTUFBTTtRQUNSLE9BQU8sQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUNEOzs7OztPQUtHO0lBQ0gsSUFBSSxTQUFTO1FBQ1gsT0FBTyxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDekUsQ0FBQztJQUNEOzs7T0FHRztJQUNILDJFQUEyRTtJQUMzRSxJQUFJLFVBQVU7UUFDWixPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ1osQ0FBQztJQUNEOzs7Ozs7Ozs7T0FTRztJQUNILEtBQUssQ0FBQyxDQUFDO1FBQ0wsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUNyRCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUM7Z0JBQ3hCLElBQUksQ0FBQztvQkFDSCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztvQkFDdkIsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDckMsQ0FBQztnQkFBQyxNQUFNLENBQUM7b0JBQ1AsTUFBTSxJQUFJLEVBQUUsQ0FBQyxzQkFBc0IsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDM0MsQ0FBQztRQUNMLENBQUM7UUFDRCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDO1lBQ2hCLE1BQU0sSUFBSSxFQUFFLENBQUMsc0JBQXNCLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDM0MsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0csTUFBTSxJQUFJLEVBQUUsQ0FBQyxzQkFBc0IsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUMzQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUNEOzs7T0FHRztJQUNILFFBQVE7UUFDTixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFDRDs7OztPQUlHO0lBQ0gsS0FBSztRQUNILE9BQU8sSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDckIsQ0FBQztJQUNELFFBQVE7UUFDTixNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3BCLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUM5RCxDQUFDO0lBQ0QsTUFBTTtRQUNKLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDbkIsQ0FBQyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUM3RCxNQUFNLENBQUMsR0FBRztZQUNSLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtZQUNmLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVTtZQUMzQixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdkIsS0FBSyxFQUFFLENBQUM7WUFDUixnQkFBZ0IsRUFBRSxJQUFJLENBQUMsZ0JBQWdCO1NBQ3hDLENBQUM7UUFDRixPQUFPLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFDRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLENBQUM7UUFDTixPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsV0FBVyxLQUFLLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDLFNBQVMsS0FBSyxJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxhQUFhLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxhQUFhLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoVSxDQUFDO0lBQ0Q7Ozs7Ozs7Ozs7Ozs7OztPQWVHO0lBQ0gsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLG9CQUFvQixFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsdUJBQXVCO1FBQ3pFLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDO1lBQzdDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUN4QixNQUFNLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLEtBQUssTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDdkMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ3ZCLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2YsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQztZQUNyQixJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFDNUIsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUN2QixJQUFJLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDcEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7d0JBQ3hDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUNiLElBQUksQ0FBQyxRQUFRLEVBQ2IsSUFBSSxDQUFDLFdBQVcsRUFDaEIsQ0FBQyxFQUNELElBQUksQ0FBQyxhQUFhLENBQ25CLENBQUM7d0JBQ0YsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUMvQixDQUFDO2dCQUNILENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDWixDQUFDO1FBQ0gsQ0FBQztRQUNELE9BQU8sQ0FBQyxDQUFDO0lBQ1gsQ0FBQztJQUNEOztPQUVHO0lBQ0gsYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSztZQUNiLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUM1QixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDVixLQUFLLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDekMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGFBQWEsQ0FBQztZQUMxQixJQUFJLENBQUMsS0FBSyxDQUFDO2dCQUNULE9BQU8sQ0FBQyxDQUFDO1lBQ1gsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQztZQUN0QixJQUFJLENBQUMsR0FBRyxDQUFDO2dCQUNQLE9BQU8sQ0FBQyxDQUFDO1lBQ1gsSUFBSSxDQUFDLEtBQUssQ0FBQztnQkFDVCxPQUFPLENBQUMsQ0FBQztZQUNYLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDUixDQUFDO1FBQ0QsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBQ0Q7O09BRUc7SUFDSCxJQUFJLGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3JJLENBQUM7SUFDRCxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxvQkFBb0I7UUFDakMsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7SUFDRCxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUN4RSxDQUFDO0NBQ0YsQ0FBQztBQUNGLENBQUMsQ0FBQyxFQUFFLEVBQUUsc0JBQXNCLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUscUJBQXFCLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSx3QkFBd0IsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLHNCQUFzQixFQUFFLENBQUMsRUFBRSxDQUFDLG1CQUFtQixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLHlCQUF5QixFQUFFLENBQUMsRUFBRSxDQUFDLHNCQUFzQixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLHFCQUFxQixFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxDQUFDLG1CQUFtQixHQUFHLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsYUFBYSxFQUFFLEVBQUUsQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLENBQUMsRUFBRTs7RUFFM1k7SUFDRixDQUFDLENBQUMsRUFBRSxFQUFFLGlCQUFpQixFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzdCLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUNaLE1BQU0sRUFBRyxTQUFRLEtBQUs7Q0FDckI7QUFDRCxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUM7QUFDeEIsU0FBUyxFQUFFO0lBQ1QsSUFBSSxFQUFFO1FBQUUsT0FBTyxFQUFFLENBQUM7SUFDbEIsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNQLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUNoQixJQUFJLENBQUMsS0FBSyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLElBQUksSUFBSSxVQUFVO1lBQ3pFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzNCLEtBQUssSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRTtZQUNsQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDYixJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ2YsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO29CQUMzQixPQUFPLEVBQUUsQ0FBQztZQUNkLENBQUM7SUFDTCxDQUFDO0lBQ0QsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDYixPQUFPLENBQUMsS0FBSyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMseUJBQXlCLElBQUksVUFBVSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE1BQU0sSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzTSxDQUFDO0lBQ0QsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDYixPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUNELFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLE9BQU8sQ0FBQyxJQUFJLFFBQVE7WUFDcEMsTUFBTSxJQUFJLFNBQVMsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1FBQ2pELEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQztZQUNiLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0IsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1IsZUFBZSxFQUFFLENBQUMsQ0FBQztRQUNuQixLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQ1QsU0FBUyxFQUFFLENBQUMsQ0FBQztRQUNiLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDWixPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQ1gsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUNaLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDWCxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQ1QsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUNaLGNBQWMsRUFBRSxDQUFDLENBQUM7UUFDbEIsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUNWLEtBQUssRUFBRSxDQUFDLENBQUM7UUFDVCxTQUFTLEVBQUUsQ0FBQyxDQUFDO1FBQ2IsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUNSLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDWixLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQ1QsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUNaLFVBQVUsRUFBRSxDQUFDLENBQUM7UUFDZCxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ1IsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUNmLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDWixRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ1osUUFBUSxFQUFFLENBQUMsQ0FBQztRQUNaLFFBQVEsRUFBRSxDQUFDLENBQUM7S0FDYixDQUFDLENBQUM7SUFDSCxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ1YsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDUixJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ1IsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUNSLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDTixHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ1AsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUNULEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDTixHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ1AsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUNULElBQUksRUFBRSxDQUFDLENBQUM7UUFDUixJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ1IsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUNULE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDVixLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQ1QsR0FBRyxFQUFFLENBQUMsQ0FBQztLQUNSLENBQUMsQ0FBQztJQUNILFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDVixPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUNELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNSLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDVixLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQ1QsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUNaLEtBQUssRUFBRSxDQUFDLENBQUM7S0FDVixDQUFDLENBQUM7SUFDSCxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ1YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3hCLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBQ0QsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUNWLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN4QixPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFDRCxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ1YsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQztJQUN0QixDQUFDO0lBQ0QsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUNWLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMscUJBQXFCLENBQUM7SUFDL0MsQ0FBQztJQUNELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNSOzs7Ozs7OztXQVFHO1FBQ0gsSUFBSSxFQUFFLFdBQVc7UUFDakI7Ozs7Ozs7V0FPRztRQUNILGVBQWUsRUFBRSxpQkFBaUI7UUFDbEM7Ozs7OztXQU1HO1FBQ0gsUUFBUSxFQUFFLFVBQVU7UUFDcEI7Ozs7Ozs7O1dBUUc7UUFDSCxxQkFBcUIsRUFBRSx1QkFBdUI7UUFDOUM7Ozs7OztXQU1HO1FBQ0gsYUFBYSxFQUFFLGVBQWU7S0FDL0IsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFTLENBQUM7UUFDbkMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDZCxDQUFDLENBQUMsQ0FBQztJQUNILFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDVixPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUNELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNSOzs7O1dBSUc7UUFDSCxJQUFJLEVBQUUsOEJBQThCO1FBQ3BDOzs7O1dBSUc7UUFDSCxHQUFHLEVBQUUsNEJBQTRCO1FBQ2pDOzs7O1dBSUc7UUFDSCxHQUFHLEVBQUUsc0NBQXNDO1FBQzNDOzs7O1dBSUc7UUFDSCxLQUFLLEVBQUUsK0JBQStCO0tBQ3ZDLENBQUMsQ0FBQztJQUNILE9BQU8sRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLHVCQUF1QixHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsc0JBQXNCLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLHVCQUF1QixHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsc0JBQXNCLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLDZCQUE2QixHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsY0FBYyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsaUJBQWlCLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxlQUFlLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUMvWSxDQUFDO0FBQ0QsSUFBSSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQztBQUNoQixTQUFTLEVBQUU7SUFDVCxJQUFJLEVBQUU7UUFBRSxPQUFPLEVBQUUsQ0FBQztJQUNsQixFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ1AsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUM7SUFDYixTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNiLENBQUMsQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFO1lBQzNDLFdBQVcsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUU7WUFDekIsSUFBSSxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxDQUFDLEVBQUU7U0FDckQsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUNELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDZjs7V0FFRztRQUNILEtBQUssRUFBRSxPQUFPO1FBQ2Q7OztXQUdHO1FBQ0gsY0FBYyxFQUFFLGdCQUFnQjtRQUNoQzs7O1dBR0c7UUFDSCxrQkFBa0IsRUFBRSxvQkFBb0I7UUFDeEMscUJBQXFCLEVBQUUsdUJBQXVCO1FBQzlDLGtCQUFrQixFQUFFLG9CQUFvQjtRQUN4QyxxQkFBcUIsRUFBRSx1QkFBdUI7UUFDOUM7OztXQUdHO1FBQ0gsa0JBQWtCLEVBQUUsb0JBQW9CO1FBQ3hDLDBCQUEwQixFQUFFLDRCQUE0QjtRQUN4RCxhQUFhLEVBQUUsZUFBZTtRQUM5QixpQkFBaUIsRUFBRSxtQkFBbUI7UUFDdEMsbUJBQW1CLEVBQUUscUJBQXFCO1FBQzFDLGlCQUFpQixFQUFFLG1CQUFtQjtRQUN0QyxXQUFXLEVBQUUsYUFBYTtRQUMxQix3QkFBd0IsRUFBRSwwQkFBMEI7UUFDcEQsY0FBYyxFQUFFLGdCQUFnQjtRQUNoQzs7Ozs7V0FLRztRQUNILGtCQUFrQixFQUFFLG9CQUFvQjtRQUN4Qzs7O1dBR0c7UUFDSCxlQUFlLEVBQUUsaUJBQWlCO1FBQ2xDOzs7V0FHRztRQUNILGlCQUFpQixFQUFFLG1CQUFtQjtRQUN0QyxhQUFhLEVBQUUsZUFBZTtRQUM5QixZQUFZLEVBQUUsY0FBYztRQUM1QixVQUFVLEVBQUUsWUFBWTtRQUN4Qjs7O1dBR0c7UUFDSCxnQkFBZ0IsRUFBRSxrQkFBa0I7UUFDcEMsa0JBQWtCLEVBQUUsb0JBQW9CO1FBQ3hDLFlBQVksRUFBRSxjQUFjO1FBQzVCLG9CQUFvQixFQUFFLHNCQUFzQjtRQUM1QyxjQUFjLEVBQUUsZ0JBQWdCO1FBQ2hDLGFBQWEsRUFBRSxlQUFlO1FBQzlCLGdCQUFnQixFQUFFLGtCQUFrQjtRQUNwQyxZQUFZLEVBQUUsY0FBYztRQUM1QixlQUFlLEVBQUUsaUJBQWlCO1FBQ2xDLFNBQVMsRUFBRSxXQUFXO1FBQ3RCLHdCQUF3QixFQUFFLDBCQUEwQjtRQUNwRCxhQUFhLEVBQUUsZUFBZTtRQUM5QixZQUFZLEVBQUUsY0FBYztRQUM1QixjQUFjLEVBQUUsZ0JBQWdCO1FBQ2hDLGVBQWUsRUFBRSxpQkFBaUI7UUFDbEMsV0FBVyxFQUFFLGFBQWE7S0FDM0IsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDVixPQUFPLE9BQU8sQ0FBQyxJQUFJLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDbkQsQ0FBQztJQUNELFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDVixPQUFPLE9BQU8sQ0FBQyxJQUFJLFFBQVEsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQ3BGLENBQUM7SUFDRCxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNiLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLGlCQUFpQixJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdEssQ0FBQztJQUNELENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRTtRQUM3QyxJQUFJLEVBQUU7WUFDSixVQUFVLEVBQUUsQ0FBQyxDQUFDO1lBQ2QsR0FBRyxFQUFFO2dCQUNILElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUM3QixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEIsQ0FBQztTQUNGO0tBQ0YsQ0FBQyxDQUFDO0lBQ0gsS0FBSyxJQUFJLENBQUMsR0FBRztRQUNYLGNBQWMsRUFBRSxDQUFDO1FBQ2pCLGtCQUFrQixFQUFFLENBQUM7UUFDckIscUJBQXFCLEVBQUUsQ0FBQztRQUN4QixrQkFBa0IsRUFBRSxDQUFDO1FBQ3JCLHFCQUFxQixFQUFFLENBQUM7UUFDeEIsbUJBQW1CLEVBQUUsQ0FBQztRQUN0QiwyQkFBMkIsRUFBRSxDQUFDO1FBQzlCLGFBQWEsRUFBRSxDQUFDO1FBQ2hCLGlCQUFpQixFQUFFLENBQUM7UUFDcEIsbUJBQW1CLEVBQUUsRUFBRTtRQUN2QixpQkFBaUIsRUFBRSxFQUFFO1FBQ3JCLFVBQVUsRUFBRSxFQUFFO1FBQ2Qsd0JBQXdCLEVBQUUsRUFBRTtRQUM1QixhQUFhLEVBQUUsRUFBRTtRQUNqQixrQkFBa0IsRUFBRSxFQUFFO1FBQ3RCLGNBQWMsRUFBRSxFQUFFO1FBQ2xCLGlCQUFpQixFQUFFLEVBQUU7UUFDckIsWUFBWSxFQUFFLEVBQUU7UUFDaEIsV0FBVyxFQUFFLEVBQUU7UUFDZixTQUFTLEVBQUUsRUFBRTtRQUNiLGdCQUFnQixFQUFFLEVBQUU7UUFDcEIsa0JBQWtCLEVBQUUsRUFBRTtRQUN0QixXQUFXLEVBQUUsRUFBRTtRQUNmLHFCQUFxQixFQUFFLEVBQUU7UUFDekIsY0FBYyxFQUFFLEVBQUU7S0FDbkIsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDbkQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2hCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakIsQ0FBQztJQUNELFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLGlCQUFpQixJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEcsQ0FBQztJQUNELE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLGFBQWEsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLFVBQVUsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDO0FBQ3pHLENBQUM7QUFDRCxJQUFJLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUM7QUFDeEIsU0FBUyxFQUFFO0lBQ1QsSUFBSSxFQUFFO1FBQUUsT0FBTyxDQUFDLENBQUM7SUFDakIsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNQLFNBQVMsQ0FBQyxDQUFDLEVBQUU7UUFDWCxJQUFJLENBQUM7WUFDSCxPQUFPLEVBQUUsSUFBSSxVQUFVLElBQUksQ0FBQyxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUM7WUFDekMsSUFBSSxFQUFFLEdBQUcsSUFBSSxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN0QyxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7UUFDcEMsQ0FBQztRQUFDLE1BQU0sQ0FBQztRQUNULENBQUM7UUFDRCxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ1osQ0FBQztJQUNELElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO0lBQ1osU0FBUyxDQUFDLENBQUMsRUFBRTtRQUNYLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHO1lBQ3RCLE1BQU0sSUFBSSxLQUFLLENBQUMsRUFBRSxHQUFHLDZCQUE2QixDQUFDLENBQUM7UUFDdEQsT0FBTyxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBQ0QsU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUU7UUFDZixJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRztZQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsTUFBTSxHQUFHLHNDQUFzQyxDQUFDLENBQUM7UUFDNUUsSUFBSSxDQUFDLEVBQUUsSUFBSSxPQUFPLEVBQUUsSUFBSSxRQUFRO1lBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsR0FBRyx3QkFBd0IsQ0FBQyxDQUFDO1FBQ2pFLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxlQUFlLEdBQUcsRUFBRSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQztRQUNoRSxJQUFJLEVBQUUsS0FBSyxHQUFHLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQztZQUMzQyxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsb0NBQW9DLEdBQUcsRUFBRSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQztRQUNyRixPQUFPLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUNELFNBQVMsQ0FBQyxDQUFDLEVBQUU7UUFDWCxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFDZCxPQUFPLElBQUksTUFBTSxDQUNmLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBUyxFQUFFO1lBQ25ELElBQUksRUFBRSxHQUFHLE9BQU8sRUFBRSxJQUFJLFFBQVEsQ0FBQztZQUMvQixJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUc7Z0JBQ25DLE1BQU0sSUFBSSxLQUFLLENBQUMsdURBQXVELENBQUMsQ0FBQztZQUMzRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDO1FBQzdCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFDWCxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUNmLENBQUM7SUFDSixDQUFDO0lBQ0QsU0FBUyxDQUFDLENBQUMsRUFBRTtRQUNYLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDO1lBQ3hCLE1BQU0sSUFBSSxLQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQztRQUM1QyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsRixDQUFDO0lBQ0QsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxrREFBa0QsQ0FBQztJQUNwRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsd0JBQXdCLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN2RCxJQUFJLENBQUMsR0FBRyxvQkFBb0IsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxvSUFBb0ksQ0FBQztJQUMvTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsd0JBQXdCLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN2RCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLENBQUMsOEJBQThCLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsNEJBQTRCLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQzVOLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQzlDLEdBQUcsRUFDSCxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUMvQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUcsNENBQTRDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQ3ZlLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsRUFDL0MsR0FBRyxFQUNILENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQ3ZCLEVBQUUsQ0FBQyxHQUFHLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUNwQixXQUFXLEVBQ1gsQ0FBQztJQUNELDhDQUE4QztLQUMvQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyx3REFBd0QsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxvQkFBb0IsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsR0FBRyxXQUFXLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcscUJBQXFCLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsUUFBUSxFQUFFLEVBQUUsR0FBRyxRQUFRLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQ2xuQixHQUFHLEVBQ0gsQ0FBQyxDQUNDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLHVCQUF1QixFQUFFLEVBQUUsRUFBRSxHQUFHLENBQUMsRUFDMUMsR0FBRyxFQUNILENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLGtCQUFrQixFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLG1CQUFtQixFQUFFLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FDdEUsQ0FDRixFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEdBQUcseUJBQXlCLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxZQUFZLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLEdBQUcsV0FBVyxFQUFFLEVBQUUsR0FBRyxXQUFXLEVBQUUsRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEdBQUcsYUFBYSxFQUFFLEVBQUUsR0FBRyxPQUFPLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzlzQixPQUFPLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLG1CQUFtQixHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsaUNBQWlDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxXQUFXLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxXQUFXLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxTQUFTLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLFdBQVcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLFdBQVcsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLFVBQVUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLGdCQUFnQixHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsV0FBVyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsWUFBWSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsV0FBVyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsV0FBVyxHQUFHLEVB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LEdBQUc7WUFDWCxNQUFNLEVBQUUsR0FBRztZQUNYLE1BQU0sRUFBRSxHQUFHO1lBQ1gsRUFBRSxFQUFFLEdBQUc7WUFDUCxHQUFHLEVBQUUsR0FBRztZQUNSLEdBQUcsRUFBRSxJQUFJO1lBQ1QsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsR0FBRyxFQUFFLEdBQUc7WUFDUixHQUFHLEVBQUUsR0FBRztZQUNSLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixFQUFFLEVBQUUsR0FBRztZQUNQLEdBQUcsRUFBRSxJQUFJO1lBQ1QsR0FBRyxFQUFFLElBQUk7WUFDVCxNQUFNLEVBQUUsR0FBRztZQUNYLE1BQU0sRUFBRSxHQUFHO1lBQ1gsT0FBTyxFQUFFLEdBQUc7WUFDWixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixHQUFHLEVBQUUsR0FBRztZQUNSLEdBQUcsRUFBRSxHQUFHO1lBQ1IsR0FBRyxFQUFFLEdBQUc7WUFDUixHQUFHLEVBQUUsR0FBRztZQUNSLE1BQU0sRUFBRSxHQUFHO1lBQ1gsSUFBSSxFQUFFLEdBQUc7WUFDVCxRQUFRLEVBQUUsR0FBRztZQUNiLElBQUksRUFBRSxHQUFHO1lBQ1QsR0FBRyxFQUFFLEdBQUc7WUFDUixJQUFJLEVBQUUsR0FBRztZQUNULEtBQUssRUFBRSxHQUFHO1lBQ1YsTUFBTSxFQUFFLEdBQUc7WUFDWCxRQUFRLEVBQUUsR0FBRztZQUNiLFFBQVEsRUFBRSxHQUFHO1lBQ2IsUUFBUSxFQUFFLEdBQUc7WUFDYixRQUFRLEVBQUUsR0FBRztZQUNiLFFBQVEsRUFBRSxHQUFHO1lBQ2IsUUFBUSxFQUFFLEdBQUc7WUFDYixRQUFRLEVBQUUsR0FBRztZQUNiLFFBQVEsRUFBRSxHQUFHO1lBQ2IsS0FBSyxFQUFF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STtZQUNiLElBQUksRUFBRSxHQUFHO1lBQ1QsSUFBSSxFQUFFLEdBQUc7WUFDVCxJQUFJLEVBQUUsSUFBSTtZQUNWLElBQUksRUFBRSxJQUFJO1lBQ1YsR0FBRyxFQUFFLEdBQUc7WUFDUixNQUFNLEVBQUUsR0FBRztZQUNYLE1BQU0sRUFBRSxHQUFHO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsSUFBSSxFQUFFLEdBQUc7WUFDVCxJQUFJLEVBQUUsR0FBRztZQUNULEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixRQUFRLEVBQUUsR0FBRztZQUNiLE9BQU8sRUFBRSxHQUFHO1lBQ1osUUFBUSxFQUFFLEdBQUc7WUFDYixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsSUFBSSxFQUFFLEdBQUc7WUFDVCxJQUFJLEVBQUUsR0FBRztZQUNULEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FB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QUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsSUFBSSxFQUFFLEdBQUc7WUFDVCxJQUFJLEVBQUUsSUFBSTtZQUNWLE1BQU0sRUFBRSxHQUFHO1lBQ1gsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLE1BQU0sRUFBRSxHQUFHO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxHQUFHLEVBQUUsR0FBRztZQUNSLE1BQU0sRUFBRSxHQUFHO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxNQUFNLEVBQUUsR0FBRztZQUNYLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixHQUFHLEVBQUUsR0FBRztZQUNSLEdBQUcsRUFBRSxHQUFHO1lBQ1IsSUFBSSxFQUFFLEdBQUc7WUFDVCxJQUFJLEVBQUUsR0FBRztZQUNULEVBQUUsRUFBRSxHQUFHO1lBQ1AsRUFBRSxFQUFFLEdBQUc7WUFDUCxHQUFHLEVBQUUsR0FBRztZQUNSLEdBQUcsRUFBRSxHQUFHO1lBQ1IsR0FBRyxFQUFFLEdBQUc7WUFDUixJQUFJLEVBQUUsR0FBRztZQUNULFFBQVEsRUFBRSxHQUFHO1lBQ2IsR0FBRyxFQUFFLEdBQUc7WUFDUixLQUFLLEVBQUUsR0FBRztZQUNWLE1BQU0sRUFBRSxHQUFHO1lBQ1gsT0FBTyxFQUFFLEdBQUc7WUFDWixRQUFRLEVBQUUsR0FBRztZQUNiLElBQUksRUFBRSxJQUFJO1lBQ1YsTUFBTSxFQUFFLEdBQUc7WUFDWCxHQUFHLEVBQUUsSUFBSTtZQUNULEdBQUcsRUFBRSxJQUFJO1lBQ1QsRUFBRSxFQUFFLEdBQUc7WUFDUCxFQUFFLEVBQUUsR0FBRztZQUNQLEdBQUcsRUFBRSxHQUFHO1lBQ1IsS0FBSyxFQUFFLEdBQUc7WUFDVixJQUFJLEVBQUUsR0FBRztZQUNULElBQUksRUFBRSxHQUFHO1lBQ1QsRUFBRSxFQUFFLEdBQUc7WUFDUCxHQUFHLEVBQUUsR0FBRztZQUNSLEdBQUcsRUFBRSxHQUFHO1lBQ1IsR0FBRyxFQUFFLEdBQUc7WUFDUixJQUFJLEVBQUUsR0FBRztZ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WUFDVixJQUFJLEVBQUUsR0FBRztZQUNULElBQUksRUFBRSxHQUFHO1lBQ1QsS0FBSyxFQUFFLEdBQUc7WUFDVixNQUFNLEVBQUUsR0FBRztZQUNYLElBQUksRUFBRSxHQUFHO1lBQ1QsSUFBSSxFQUFFLElBQUk7WUFDVixJQUFJLEVBQUUsR0FBRztZQUNULE9BQU8sRUFBRSxHQUFHO1lBQ1osS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLE1BQU0sRUFBRSxHQUFHO1lBQ1gsS0FBSyxFQUFFLEdBQUc7WUFDVixFQUFFLEVBQUUsR0FBRztZQUNQLE1BQU0sRUFBRSxHQUFHO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsSUFBSSxFQUFFLEdBQUc7WUFDVCxJQUFJLEVBQUUsR0FBRztZQUNULEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixHQUFHLEVBQUUsR0FBRztZQUNSLEdBQUcsRUFBRSxHQUFHO1lBQ1IsR0FBRyxFQUFFLElBQUk7WUFDVCxHQUFHLEVBQUUsSUFBSTtZQUNULEtBQUssRUFBRSxHQUFHO1lBQ1YsSUFBSSxFQUFFLElBQUk7WUFDVixJQUFJLEVBQUUsSUFBSTtZQUNWLElBQUksRUFBRSxJQUFJO1lBQ1YsSUFBSSxFQUFFLElBQUk7WUFDVixNQUFNLEVBQUUsR0FBRztZQUNYLE1BQU0sRUFBRSxHQUFHO1lBQ1gsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixNQUFNLEVBQUUsR0FBRztZQUNYLE1BQU0sRUFBRSxHQUFHO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxHQUFHLEVBQUUsR0FBRztZQUNSLEdBQUcsRUFBRSxHQUFHO1lBQ1IsR0FBRyxFQUFFLElBQUk7WUFDVCxHQUFHLEVBQUUsSUFBSTtZQUNULE1BQU0sRUFBRSxHQUFHO1lBQ1gsSUFBSSxFQUFFLEdBQUc7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QUcsRUFBRSxHQUFHO1lBQ1IsT0FBTyxFQUFFLEdBQUc7WUFDWixJQUFJLEVBQUUsR0FBRztZQUNULElBQUksRUFBRSxHQUFHO1lBQ1QsTUFBTSxFQUFFLEdBQUc7WUFDWCxLQUFLLEVBQUUsR0FBRztZQUNWLFFBQVEsRUFBRSxHQUFHO1lBQ2IsS0FBSyxFQUFFLEdBQUc7WUFDVixNQUFNLEVBQUUsR0FBRztZQUNYLEdBQUcsRUFBRSxHQUFHO1lBQ1IsS0FBSyxFQUFFLEdBQUc7WUFDVixNQUFNLEVBQUUsR0FBRztZQUNYLElBQUksRUFBRSxHQUFHO1lBQ1QsSUFBSSxFQUFFLElBQUk7WUFDVixHQUFHLEVBQUUsR0FBRztZQUNSLEdBQUcsRUFBRSxHQUFHO1lBQ1IsSUFBSSxFQUFFLEdBQUc7WUFDVCxLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsSUFBSSxFQUFFLEdBQUc7WUFDVCxLQUFLLEVBQUUsR0FBRztZQUNWLE1BQU0sRUFBRSxHQUFHO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxNQUFNLEVBQUUsR0FBRztZQUNYLEVBQUUsRUFBRSxHQUFHO1lBQ1AsRUFBRSxFQUFFLEdBQUc7WUFDUCxFQUFFLEVBQUUsR0FBRztZQUNQLElBQUksRUFBRSxHQUFHO1lBQ1QsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLE1BQU0sRUFBRSxHQUFHO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxNQUFNLEVBQUUsR0FBRztZQUNYLE9BQU8sRUFBRSxHQUFHO1lBQ1osSUFBSSxFQUFFLEdBQUc7WUFDVCxLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsTUFBTSxFQUFFLEdBQUc7WUFDWCxRQUFRLEVBQUUsR0FBRztZQUNiLE9BQU8sRUFBRSxHQUFHO1lBQ1osU0FBUyxFQUFFLElBQUk7WUFDZixJQUFJLEVBQUUsSUFBSTtZQUNWLElBQUksRUFBRSxHQUFHO1lBQ1QsSUFBSSxFQUFFLEdBQUc7WUFDVCxJQUFJLEVBQUUsR0FBRztZQUNULE9B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LEVBQUUsSUFBSTtZQUNULEdBQUcsRUFBRSxHQUFHO1lBQ1IsSUFBSSxFQUFFLEdBQUc7WUFDVCxLQUFLLEVBQUUsSUFBSTtZQUNYLFNBQVMsRUFBRSxJQUFJO1lBQ2YsSUFBSSxFQUFFLElBQUk7WUFDVixHQUFHLEVBQUUsSUFBSTtZQUNULEtBQUssRUFBRSxHQUFHO1lBQ1YsR0FBRyxFQUFFLElBQUk7WUFDVCxHQUFHLEVBQUUsR0FBRztZQUNSLElBQUksRUFBRSxHQUFHO1lBQ1QsSUFBSSxFQUFFLElBQUk7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixFQUFFLEVBQUUsR0FBRztZQUNQLEdBQUcsRUFBRSxHQUFHO1lBQ1IsSUFBSSxFQUFFLEdBQUc7WUFDVCxHQUFHLEVBQUUsR0FBRztZQUNSLElBQUksRUFBRSxHQUFHO1lBQ1QsSUFBSSxFQUFFLEdBQUc7WUFDVCxLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsSUFBSSxFQUFFLEdBQUc7WUFDVCxHQUFHLEVBQUUsSUFBSTtZQUNULEdBQUcsRUFBRSxHQUFHO1lBQ1IsVUFBVSxFQUFFLEdBQUc7WUFDZixVQUFVLEVBQUUsR0FBRztZQUNmLGVBQWUsRUFBRSxHQUFHO1lBQ3BCLGVBQWUsRUFBRSxHQUFHO1lBQ3BCLElBQUksRUFBRSxHQUFHO1lBQ1QsS0FBSyxFQUFFLElBQUk7WUFDWCxTQUFTLEVBQUUsSUFBSTtZQUNmLElBQUksRUFBRSxJQUFJO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixHQUFHLEVBQUUsSUFBSTtZQUNULEtBQUssRUFBRSxHQUFHO1lBQ1YsR0FBRyxFQUFFLElBQUk7WUFDVCxHQUFHLEVBQUUsR0FBRztZQUNSLEtBQUssRUFBRSxHQUFHO1lBQ1YsTUFBTSxFQUFFLEdBQUc7WUFDWCxJQUFJLEVBQUUsSUFBSTtZQUNWLElBQUksRUFBRSxHQUFHO1lBQ1QsT0FBTyxFQUFFLEdBQUc7WUFDWixnQkFBZ0IsRUFBRSxHQUFHO1lBQ3JC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LElBQUksRUFBRSxJQUFJO1lBQ1YsTUFBTSxFQUFFLEdBQUc7WUFDWCxPQUFPLEVBQUUsR0FBRztZQUNaLE1BQU0sRUFBRSxHQUFHO1lBQ1gsSUFBSSxFQUFFLElBQUk7WUFDVixJQUFJLEVBQUUsSUFBSTtZQUNWLE9BQU8sRUFBRSxJQUFJO1lBQ2IsTUFBTSxFQUFFLEdBQUc7WUFDWCxPQUFPLEVBQUUsSUFBSTtZQUNiLEtBQUssRUFBRSxJQUFJO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsT0FBTyxFQUFFLEdBQUc7WUFDWixNQUFNLEVBQUUsR0FBRztZQUNYLE1BQU0sRUFBRSxHQUFHO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxJQUFJLEVBQUUsR0FBRztZQUNULElBQUksRUFBRSxHQUFHO1lBQ1QsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEdBQUcsRUFBRSxHQUFHO1lBQ1IsR0FBRyxFQUFFLEdBQUc7WUFDUixLQUFLLEVBQUUsR0FBRztZQUNWLE1BQU0sRUFBRSxHQUFHO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxJQUFJLEVBQUUsR0FBRztZQUNULElBQUksRUFBRSxHQUFHO1lBQ1QsTUFBTSxFQUFFLEdBQUc7WUFDWCxLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixHQUFHLEVBQUUsSUFBSTtZQUNULEdBQUcsRUFBRSxJQUFJO1lBQ1QsSUFBSSxFQUFFLEdBQUc7WUFDVCxNQUFNLEVBQUUsR0FBRztZQUNYLE1BQU0sRUFBRSxHQUFHO1lBQ1gsR0FBRyxFQUFFLEdBQUc7WUFDUixLQUFLLEVBQUUsR0FBRztZQUNWLEdBQUcsRUFBRSxHQUFHO1lBQ1IsSUFBSSxFQUFFLEdBQUc7WUFDVCxLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsT0FBTyxFQUFFLEdBQUc7WUFDWixLQUFLLEVBQUUsR0FBRztZQUNW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RUFBRSxJQUFJO1lBQ1YsSUFBSSxFQUFFLElBQUk7WUFDVixFQUFFLEVBQUUsR0FBRztZQUNQLEVBQUUsRUFBRSxHQUFHO1lBQ1AsTUFBTSxFQUFFLEdBQUc7WUFDWCxJQUFJLEVBQUUsSUFBSTtZQUNWLElBQUksRUFBRSxJQUFJO1lBQ1YsSUFBSSxFQUFFLEdBQUc7WUFDVCxLQUFLLEVBQUUsR0FBRztZQUNWLElBQUksRUFBRSxHQUFHO1lBQ1QsS0FBSyxFQUFFLEdBQUc7WUFDVixHQUFHLEVBQUUsSUFBSTtZQUNULEdBQUcsRUFBRSxJQUFJO1lBQ1QsS0FBSyxFQUFFLEdBQUc7WUFDVixLQUFLLEVBQUUsR0FBRztZQUNWLEVBQUUsRUFBRSxHQUFHO1lBQ1AsRUFBRSxFQUFFLEdBQUc7WUFDUCxLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsSUFBSSxFQUFFLEdBQUc7WUFDVCxJQUFJLEVBQUUsR0FBRztZQUNULEtBQUssRUFBRSxHQUFHO1lBQ1YsSUFBSSxFQUFFLElBQUk7WUFDVixJQUFJLEVBQUUsSUFBSTtZQUNWLE1BQU0sRUFBRSxHQUFHO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxLQUFLLEVBQUUsR0FBRztZQUNWLEtBQUssRUFBRSxHQUFHO1lBQ1YsSUFBSSxFQUFFLElBQUk7WUFDVixJQUFJLEVBQUUsSUFBSTtZQUNWLE1BQU0sRUFBRSxHQUFHO1lBQ1gsTUFBTSxFQUFFLEdBQUc7WUFDWCxLQUFLLEVBQUUsR0FBRztZQUNWLElBQUksRUFBRSxHQUFHO1lBQ1QsTUFBTSxFQUFFLEdBQUc7WUFDWCxNQUFNLEVBQUUsR0FBRztZQUNYLE1BQU0sRUFBRSxHQUFHO1lBQ1gsSUFBSSxFQUFFLEdBQUc7WUFDVCxJQUFJLEVBQUUsR0FBRztZQUNULEtBQUssRUFBRSxHQUFHO1lBQ1YsS0FBSyxFQUFFLEdBQUc7WUFDVixHQUFHLEVBQUUsR0FBRztZQUNSLEdBQUcsRUFBRSxHQUFHO1lBQ1IsR0FBRyxFQUFFLEdBQUc7WUFDUixHQUFHLEVBQUUsSUFBSTtZQUNULEdBQUcs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RyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLE9BQU8sSUFBSSxDQUFDLENBQUM7O2dCQUU3RSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxPQUFPLElBQUksRUFBRSxDQUFDO1lBQzNDLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsZUFBZSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDck0sQ0FBQztRQUNELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUU7WUFDeEIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxLQUFLLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0csSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUMzRyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUMxQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUMzQixLQUFLLENBQUMsSUFBSSxDQUFDO29CQUNULENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDLENBQUM7O1lBQ0MsT0FBTyxDQUFDLENBQUMsWUFBWSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsVUFBVSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBQ0QsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDdEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDZCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDaEUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNyRSxDQUFDO1FBQ0QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2YsQ0FBQztJQUNELFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2IsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ2IsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBQ0QsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDVixTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ1YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNyQyxDQUFDO1FBQ0QsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUNWLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENB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LE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0QixDQUFDO0FBQ0QsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDZCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDMUIsT0FBTyxDQUFDLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDM0MsQ0FBQztBQUNELFNBQVMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUNqQixPQUFPLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNyQyxDQUFDO0FBQ0QsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRztJQUN2QixPQUFPLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUNyRCxDQUFDO0FBQ0QsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRztJQUN2QixPQUFPLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBQ0QsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDZCxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBQ0QsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0lBQ2pCLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoQixJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzFFLE9BQU8sRUFBRSxDQUFDO0lBQ1osTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM5QyxPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3JCLENBQUM7QUFDRCxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUFDakIsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ2IsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDeEIsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2IsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdkMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ1YsQ0FBQyxPQUFPLENBQUMsSUFBSSxRQUFRLElBQUksQ0FBQyxZQUFZLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxNQUFNLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0YsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDVixJQUFJLENBQUMsQ0FBQztRQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ2hELE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQztZQUNoRSxNQUFNO0lBQ1YsQ0FBQztJQUNELE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzdCLENBQUM7QUFDRCxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFF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SyxFQUFFLFNBQVMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDNUQsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDMUQsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDOUQsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDekQsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDekQsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLFFBQVEsRUFBRSxDQUFDLEVBQUU7SUFDdEQsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDM0QsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDM0QsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDMUQsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDMUQsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDL0QsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDL0QsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDdkQsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDM0QsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDekQsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7SUFDdEQsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFO0lBQ25FLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQzNELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQy9ELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxlQUFlLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQ2xGLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQ3pELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQzNELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQzlELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQzFELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQ3pELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQ3hELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQ3RELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQ3RELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQ3pELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQ3ZELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQ3ZELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQ3ZELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQzFELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxXQUFXLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQzNELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQ3hELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxXQUFXLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQzVELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQ3pELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQzFELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQ3ZELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQ3ZELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQ3ZELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQ3ZELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQ3pELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQ2hFLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFO0lBQ2hFLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxXQUFXLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQzNELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxXQUFXLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQzNELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQzdELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO0lBQzVELEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLFFBQVEsRUFBRSxDQUFDLEVBQUU7SUFDakUsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRTtJQUNqRSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRTtJQUMzRCxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRTtJQUMzRCxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRTtJQUN2RCxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRTtJQUMxRCxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRTtJQUMxRCxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRTtJQUN2RCxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRTtJQUN6RCxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRTtJQUN6RCxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRTtJQUN4RCxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRTtJQUN4RCxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRTtJQUN4RCxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRTtJQUN0RCxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsWUFBWSxDQUFDLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRTtDQUM5RCxFQUFFLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUc7SUFDbEQsSUFBSSxFQUFFLEtBQUs7SUFDWCxVQUFVLEVBQUUsQ0FBQztJQUNiLFFBQVEsRUFBRSxDQUFDO0NBQ1osRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRTtJQUNaLElBQUksQ0FBQyxDQUFDO0lBQ04sT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUMzRCxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNqQixJQUFJLEVBQUUsRUFBRSxDQUFDLGNBQWMsQ0FDckIsSUFBSSxDQUFDLEdBQUcsQ0FDTixFQUFFLEVBQ0YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQzVDLENBQ0Y7SUFDRCxVQUFVLEVBQUUsQ0FBQztJQUNiLFFBQVEsRUFBRSxDQUFDO0NBQ1osQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDbEIsR0FBRyxDQUFDO0lBQ0osVUFBVSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQ2xCLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQzlCLEVBQUUsQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUM5QjtJQUNELFFBQVEsRUFBRSxDQUFDO0NBQ1osQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDbEIsR0FBRyxDQUFDO0lBQ0osUUFBUSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0NBQ3ZDLENBQUMsQ0FBQztBQUNILEtBQUssVUFBVSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0lBQ3ZCLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0IsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDO1FBQzNDLE9BQU8sQ0FBQyxDQUFDO1lBQ1AsV0FBVyxFQUFFLGVBQWUsQ0FBQyxFQUFFO1lBQy9CLGlCQUFpQixFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3ZCLENBQUMsQ0FBQztJQUNMLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO1FBQ2hCLFdBQVcsRUFBRSxRQUFRLENBQUMsRUFBRTtRQUN4QixpQkFBaUIsRUFBRSxDQUFDLENBQUMsQ0FBQztLQUN2QixDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDbkIsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ25DLENBQUM7QUFDRCxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ1gsT0FBTyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDNUUsQ0FBQztBQUNELFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDWCxPQUFPLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUMvRSxDQUFDO0FBQ0QsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDZCxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkIsQ0FBQztBQUNELFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDWCxPQUFPLGdCQUFnQixDQUFDLEdBQUcsQ0FBQztBQUM5QixDQUFDO0FBQ0QsU0FBUyxFQUFFLENBQUMsQ0FBQztJQUNYLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUNELFNBQVMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUFDcEIsSUFBSSxDQUFDLENBQUM7SUFDTixRQUFRLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUNsQixLQUFLLFNBQVM7WUFDWixDQUFDLEdBQUcsRUFBRSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNuQyxNQUFNO1FBQ1IsS0FBSyxJQUFJO1lBQ1AsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDWCxNQUFNO1FBQ1I7WUFDRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNaLE1BQU07SUFDVixDQUFDO0lBQ0QsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDbEUsQ0FBQztBQUNELE1BQU0sRUFBRSxHQUFHO0FBQ1QsNEZBQTRGO0FBQzVGLGdFQUFnRTtBQUNoRSw0Q0FBNEM7QUFDNUMsd0dBQXdHLENBQ3pHLENBQUM7QUFDRixTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ1gsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLENBQUM7QUFDRCxNQUFNLEVBQUUsR0FBRywyRkFBMkYsQ0FBQztBQUN2RyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ1gsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLENBQUM7QUFDRCxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ1gsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQzdCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUNyQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDZixDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzNMLENBQUM7SUFDRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFDRCxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ1gsT0FB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QUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUN2QixDQUFDO1FBQ0YsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDOUgsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzQyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDYixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDO1lBQ2pDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzFCLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzlELE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMs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QUFDO0lBQ2YsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUk7UUFDZCxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ1osSUFBSSxDQUFDLENBQUM7UUFDSixPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ1osS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUksQ0FBQztRQUNyRixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUksQ0FBQztZQUNyRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUNULENBQUMsRUFBRSxDQUFDO2dCQUNKLFNBQVM7WUFDWCxDQUFDO1lBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQztZQUM3QixJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxF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Q3BCLElBQUksQ0FBQyxLQUFLLE1BQU07WUFDZCxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxLQUFLLEdBQUc7WUFDWCxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxLQUFLLEdBQUc7WUFDWCxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNkLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksSUFBSSxVQUFVLElBQUksT0FBTyxDQUFDLENBQUMsSUFBSSxJQUFJLFVBQVUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FB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Q0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUNELElBQUksT0FBTyxDQUFDLElBQUksUUFBUTtRQUN0QixPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDWCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7UUFDbEMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ1IsQ0FBQztBQUNELFNBQVMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUNqQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ2hDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNWLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzNELENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNSLENBQUM7QUFDRCxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUNkLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDVixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDbEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ1IsQ0FBQztJQUNELE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzNCLElBQUksQ0FBQyxLQUFLLElBQUk7UUFDWixPQUFPLE9BQU8sQ0FBQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDM0MsQ0FBQztBQUNELFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDWCxJQUFJLENBQUM7UUFDSCxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEIsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFBQyxNQUFNLENBQUM7UUFDUCxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ1osQ0FBQztBQUNILENBQUM7QUFDRCxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQ2hLLFNBQVMsRUFBRTtJQUNULE9BQU8sT0FBTyxTQUFTLEdBQUcsR0FBRyxJQUFJLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsZUFBZSxFQUFFLENBQUMsTUFBTSxDQUFDO0FBQ3BILENBQUM7QUFDRCxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7SUFDbEIsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUFFLE9BQU8sU0FBUyxDQUFDO0lBQzlCLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVILE9BQU8sR0FBRyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUU7UUFDckIsS0FBSyxFQUFFLFNBQVM7UUFDaEIscUJBQXFCLEVBQUUsQ0FBQztRQUN4QixxQkFBcUIsRUFBRSxDQUFDO0tBQ3pCLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUNsQyxDQUFDO0FBQ0QsTUFBTSxFQUFFLEdBQUcsR0FBRyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDcEQsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsZUFBZSxDQUFDLElBQUksSUFBSSxFQUFFO0lBQzlDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQy9FLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQUUsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNoRCxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUM3QixJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUFFLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDakQsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDN0IsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQzFFLENBQUM7QUFDRCxNQUFNLEVBQUUsR0FBRztJQUNULDJCQUEyQixFQUFFO1FBQzNCLFdBQVcsRUFBRSw2RkFBNkY7UUFDMUcsS0FBSyxFQUFFO1lBQ0w7Z0JBQ0UsSUFBSSxFQUFFLDhCQUE4QjthQUNyQztZQUNEO2dCQUNFLElBQUksRUFBRSxPQUFPO2dCQUNiLEtBQUssRUFBRTtvQkFDTCxJQUFJLEVBQUUsOEJBQThCO2lCQUNyQzthQUNGO1NBQ0Y7S0FDRjtJQUNELG9CQUFvQixFQUFFO1FBQ3BCLFdBQVcsRUFBRSx1Q0FBdUM7UUFDcEQsSUFBSSxFQUFFLFFBQVE7UUFDZCxVQUFVLEVBQUU7WUFDVixLQUFLLEVBQUU7Z0JBQ0wsV0FBVyxFQUFFLDRFQUE0RTtnQkFDekYsSUFBSSxFQUFFLHFCQUFxQjthQUM1QjtZQUNELFdBQVcsRUFBRTtnQkFDWCxXQUFXLEVBQUUsZ0ZBQWdGO2dCQUM3RixJQUFJLEVBQUUscUJBQXFCO2FBQzVCO1lBQ0QsVUFBVSxFQUFFO2dCQUNWLElBQUksRUFBRSxrQ0FBa0M7YUFDekM7U0FDRjtRQUNELFFBQVEsRUFBRSxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUM7S0FDbEM7SUFDRCx3QkFBd0IsRUFBRTtRQUN4QixXQUFXLEVBQUUseUVBQXlFO1FBQ3RGLElBQUksRUFBRSxRQUFRO1FBQ2QsaUJBQWlCLEVBQUU7WUFDakIseUJBQXlCLEVBQUU7Z0JBQ3pCLElBQUksRUFBRSx3QkFBd0I7YUFDL0I7U0FDRjtRQUNELG9CQUFvQixFQUFFLENBQUMsQ0FBQztLQUN6QjtJQUNELGNBQWMsRUFBRTtRQUNkLFdBQVcsRUFBRSwrQ0FBK0M7UUFDNUQsS0FBSyxFQUFFO1lBQ0w7Z0JBQ0UsSUFBSSxFQUFFLDJDQUEyQzthQUNsRDtTQUNGO0tBQ0Y7SUFDRCxpQ0FBaUMsRUFBRTtRQUNqQyxXQUFXLEVBQUUsd0RBQXdEO1FBQ3JFLEtBQUssRUFBRTtZQUNMO2dCQUNFLElBQUksRUFBRSw0QkFBNEI7YUFDbkM7WUFDRDtnQkFDRSxJQUFJLEVBQUUscUNBQXFDO2FBQzVDO1NBQ0Y7S0FDRjtJQUNELGtCQUFrQixFQUFFO1FBQ2xCLFdBQVcsRUFBRSw2REFBNkQ7UUFDMUUsS0FBSyxFQUFFO1lBQ0w7Z0JBQ0UsSUFBSSxFQUFFLHFCQUFxQjthQUM1QjtZQUNEO2dCQUNFLElBQUksRUFBRSx5QkFBeUI7YUFDaEM7U0FDRjtLQUNGO0lBQ0QsZUFBZSxFQUFFO1FBQ2YsV0FBVyxFQUFFLDZDQUE2QztRQUMxRCxJQUFJLEVBQUUsUUFBUTtRQUNkLFVBQVUsRUFBRTtZQUNWLHdCQUF3QixFQUFFO2dCQUN4QixXQUFXLEVBQUUsbzRDQUFvNEM7Z0JBQ2o1QyxLQUFLLEVBQUU7b0JBQ0w7d0JBQ0UsSUFBSSxFQUFFLE1BQU07cUJBQ2I7b0JBQ0Q7d0JBQ0UsSUFBSSxFQUFFLFFBQVE7cUJBQ2Y7b0JBQ0Q7d0JBQ0UsSUFBSSxFQUFFLE9BQU87d0JBQ2IsS0FBSyxFQUFFOzRCQUNMLEtBQUssRUFBRTtnQ0FDTDtvQ0FDRSxJQUFJLEVBQUUsUUFBUTtpQ0FDZjtnQ0FDRDtvQ0FDRSxJQUFJLEVBQUUsT0FBTztvQ0FDYixLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFO2lDQUMxQjs2QkFDRjt5QkFDRjtxQkFDRjtpQkFDRjthQUNGO1lBQ0Qsd0JBQXdCLEVBQUU7Z0JBQ3hCLFdBQVcsRUFBRSxzZ0RBQXNnRDtnQkFDbmhELEtBQUssRUFBRTtvQkFDTDt3QkFDRSxJQUFJLEVBQUUsTUFBTTtxQkFDYjtvQkFDRDt3QkFDRSxJQUFJLEVBQUUsUUFBUTtxQkFDZjtvQkFDRDt3QkFDRSxJQUFJLEVBQUUsT0FBTzt3QkFDYixLQUFLLEVBQUU7NEJBQ0wsS0FBSyxFQUFFO2dDQUNMO29DQUNFLElBQUksRUFBRSxRQUFRO2lDQUNmO2dDQUNEO29DQUNFLElBQUksRUFBRSxPQUFPO29DQUNiLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUU7aUNBQzFCOzZCQUNGO3lCQUNGO3FCQUNGO2lCQUNGO2FBQ0Y7WUFDRCxvQkFBb0IsRUFBRTtnQkFDcEIsV0FBVyxFQUFFLHdiQUF3YjtnQkFDcmMsS0FBSyxFQUFFO29CQUNMO3dCQUNFLElBQUksRUFBRSxNQUFNO3FCQUNiO29CQUNEO3dCQUNFLElBQUksRUFBRSxRQUFRO3FCQUNmO29CQUNEO3dCQUNFLElBQUksRUFBRSxPQUFPO3dCQUNiLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUU7cUJBQzFCO2lCQUNGO2FBQ0Y7WUFDRCxvQkFBb0IsRUFBRTtnQkFDcEIsV0FBVyxFQUFFLGtkQUFrZDtnQkFDL2QsS0FBSyxFQUFFO29CQUNMO3dCQUNFLElBQUksRUFBRSxNQUFNO3FCQUNiO29CQUNEO3dCQUNFLElBQUksRUFBRSxRQUFRO3FCQUNmO29CQUNEO3dCQUNFLElBQUksRUFBRSxPQUFPO3dCQUNiLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUU7cUJBQzFCO2lCQUNGO2FBQ0Y7U0FDRjtLQUNGO0lBQ0Qsb0JBQW9CLEVBQUU7UUFDcEIsV0FBVyxFQUFFLHFGQUFxRjtRQUNsRyxLQUFLLEVBQUU7WUFDTDtnQkFDRSxJQUFJLEVBQUUsdUJBQXVCO2FBQzlCO1lBQ0Q7Z0JBQ0UsSUFBSSxFQUFFLE9BQU87Z0JBQ2IsS0FBSyxFQUFFO29CQUNMLElBQUksRUFBRSx1QkFBdUI7aUJBQzlCO2FBQ0Y7U0FDRjtLQUNGO0lBQ0QsYUFBYSxFQUFFO1FBQ2IsV0FBVyxFQUFFLHVDQUF1QztRQUNwRCxJQUFJLEVBQUUsUUFBUTtRQUNkLFVBQVUsRUFBRTtZQUNWLEtBQUssRUFBRTtnQkFDTCxXQUFXLEVBQUUsb0VBQW9FO2dCQUNqRixJQUFJLEVBQUUscUJBQXFCO2FBQzVCO1lBQ0QsV0FBVyxFQUFFO2dCQUNYLFdBQVcsRUFBRSx3RUFBd0U7Z0JBQ3JGLElBQUksRUFBRSxxQkFBcUI7YUFDNUI7WUFDRCxVQUFVLEVBQUU7Z0JBQ1YsSUFBSSxFQUFFLDJCQUEyQjthQUNsQztTQUNGO1FBQ0QsUUFBUSxFQUFFLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQztLQUNsQztJQUNELGlCQUFpQixFQUFFO1FBQ2pCLFdBQVcsRUFBRSx5RUFBeUU7UUFDdEYsSUFBSSxFQUFFLFFBQVE7UUFDZCxpQkFBaUIsRUFBRTtZQUNqQixxQkFBcUIsRUFBRTtnQkFDckIsSUFBSSxFQUFFLGlCQUFpQjthQUN4QjtTQUNGO1FBQ0Qsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDO0tBQ3pCO0lBQ0QsT0FBTyxFQUFFO1FBQ1AsV0FBVyxFQUFFLCtDQUErQztRQUM1RCxLQUFLLEVBQUU7WUFDTDtnQkFDRSxJQUFJLEVBQUUsb0NBQW9DO2FBQzNDO1NBQ0Y7S0FDRjtJQUNELDBCQUEwQixFQUFFO1FBQzFCLFdBQVcsRUFBRSx3REFBd0Q7UUFDckUsS0FBSyxFQUFFO1lBQ0w7Z0JBQ0UsSUFBSSxFQUFFLHFCQUFxQjthQUM1QjtZQUNEO2dCQUNFLElBQUksRUFBRSxxQ0FBcUM7YUFDNUM7U0FDRjtLQUNGO0lBQ0QsV0FBVyxFQUFFO1FBQ1gsV0FBVyxFQUFFLHFEQUFxRDtRQUNsRSxLQUFLLEVBQUU7WUFDTDtnQkFDRSxJQUFJLEVBQUUsbUJBQW1CO2FBQzFCO1lBQ0Q7Z0JBQ0UsSUFBSSxFQUFFLFFBQVE7Z0JBQ2QsVUFBVSxFQUFFO29CQUNWLEtBQUssRUFBRTt3QkFDTCxXQUFXLEVBQUUsc0VBQXNFO3dCQUNuRixJQUFJLEVBQUUscUJBQXFCO3FCQUM1QjtvQkFDRCxXQUFXLEVBQUU7d0JBQ1gsV0FBVyxFQUFFLDBFQUEwRTt3QkFDdkYsSUFBSSxFQUFFLHFCQUFxQjtxQkFDNUI7aUJBQ0Y7Z0JBQ0QsUUFBUSxFQUFFLENBQUMsT0FBTyxDQUFDO2FBQ3BCO1NBQ0Y7S0FDRjtJQUNELHdCQUF3QixFQUFFO1FBQ3hCLFdBQVcsRUFBRSwwRkFBMEY7UUFDdkcsSUFBSSxFQUFFLDZCQUE2QjtLQUNwQztJQUNELHFCQUFxQixFQUFFO1FBQ3JCLFdBQVcsRUFBRSx1RkFBdUY7UUFDcEcsSUFBSSxFQUFFLDZCQUE2QjtLQUNwQztJQUNELG1CQUFtQixFQUFFO1FBQ25CLFdBQVcsRUFBRSxvRUFBb0U7UUFDakYsSUFBSSxFQUFFLFFBQVE7UUFDZCxpQkFBaUIsRUFBRTtZQUNqQix5QkFBeUIsRUFBRTtnQkFDekIsSUFBSSxFQUFFLG1CQUFtQjthQUMxQjtTQUNGO1FBQ0Qsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDO0tBQ3pCO0lBQ0QsU0FBUyxFQUFFO1FBQ1QsV0FBVyxFQUFFLGtEQUFrRDtRQUMvRCxLQUFLLEVBQUU7WUFDTDtnQkFDRSxJQUFJLEVBQUUsa0NBQWtDO2FBQ3pDO1NBQ0Y7S0FDRjtJQUNELHdCQUF3QixFQUFFO1FBQ3hCLFdBQVcsRUFBRSxzREFBc0Q7UUFDbkUsS0FBSyxFQUFFO1lBQ0w7Z0JBQ0UsSUFBSSxFQUFFLG1CQUFtQjthQUMxQjtZQUNEO2dCQUNFLElBQUksRUFBRSxxQ0FBcUM7YUFDNUM7U0FDRjtLQUNGO0lBQ0QsMkJBQTJCLEVBQUU7UUFDM0IsV0FBVyxFQUFFLHlOQUF5TjtRQUN0TyxHQUFHLEVBQUU7WUFDSCxLQUFLLEVBQUU7Z0JBQ0w7b0JBQ0UsSUFBSSxFQUFFLFFBQVE7b0JBQ2QsUUFBUSxFQUFFLENBQUMsY0FBYyxDQUFDO2lCQUMzQjtnQkFDRDtvQkFDRSxJQUFJLEVBQUUsUUFBUTtvQkFDZCxRQUFRLEVBQUUsQ0FBQyxNQUFNLENBQUM7aUJBQ25CO2FBQ0Y7U0FDRjtLQUNGO0lBQ0QsU0FBUyxFQUFFO1FBQ1QsV0FBVyxFQUFFLG1EQUFtRDtRQUNoRSxJQUFJLEVBQUUsUUFBUTtRQUNkLFVBQVUsRUFBRTtZQUNWLE9BQU8sRUFBRTtnQkFDUCxXQUFXLEVBQUUscUNBQXFDO2dCQUNsRCxJQUFJLEVBQUUsS0FBSzthQUNaO1lBQ0QsV0FBVyxFQUFFO2dCQUNYLFdBQVcsRUFBRSwwSEFBMEg7Z0JBQ3ZJLElBQUksRUFBRSxZQUFZO2FBQ25CO1NBQ0Y7UUFDRCxRQUFRLEVBQUUsQ0FBQyxTQUFTLENBQUM7S0FDdEI7SUFDRCxXQUFXLEVBQUU7UUFDWCxXQUFXLEVBQUUsZ0ZBQWdGO1FBQzdGLElBQUksRUFBRSxRQUFRO1FBQ2QsT0FBTyxFQUFFLGtCQUFrQjtRQUMzQixNQUFNLEVBQUUsYUFBYTtLQUN0QjtJQUNELEVBQUUsRUFBRTtRQUNGLFdBQVcsRUFBRSxFQUFFO1FBQ2YsSUFBSSxFQUFFLFFBQVE7UUFDZCxPQUFPLEVBQUUseUJBQXlCO1FBQ2xDLE1BQU0sRUFBRSxJQUFJO0tBQ2I7Q0FDRixDQUFDO0FBQ0YsU0FBUyxFQUFFLENBQUMsQ0FBQztJQUNYLENBQUMsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1FBQ2xDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ1gsSUFBSSxRQUFRLElBQUksQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsSUFBSSxLQUFLLEtBQUssRUFBRSxDQUFDO2dCQUN2RCxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUM7Z0JBQ2QsT0FBTztZQUNULENBQUM7WUFDRCxDQUFDLENBQUMsSUFBSSxLQUFLLFFBQVEsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzFDLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFDRCxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDUCxNQUFNLEVBQUUsR0FBRztJQUNULE9BQU8sRUFBRSw4Q0FBOEM7SUFDdkQsS0FBSyxFQUFFLCtCQUErQjtJQUN0QyxXQUFXLEVBQUUsNkZBQTZGO0lBQzFHLEtBQUssRUFBRTtRQUNMO1lBQ0UsSUFBSSxFQUFFLDhCQUE4QjtTQUNyQztRQUNEO1lBQ0UsSUFBSSxFQUFFLE9BQU87WUFDYixLQUFLLEVBQUU7Z0JBQ0wsSUFBSSxFQUFFLDhCQUE4QjthQUNyQztTQUNGO0tBQ0Y7SUFDRCxLQUFLLEVBQUUsRUFBRTtDQUNWLENBQUM7QUFDRixNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2xCLE1BQU0sRUFBRSxHQUFHO0lBQ1QsT0FBTyxFQUFFLDhDQUE4QztJQUN2RCxLQUFLLEVBQUUsdUJBQXVCO0lBQzlCLFdBQVcsRUFBRSxxRkFBcUY7SUFDbEcsS0FBSyxFQUFFO1FBQ0w7WUFDRSxJQUFJLEVBQUUsdUJBQXVCO1NBQzlCO1FBQ0Q7WUFDRSxJQUFJLEVBQUUsT0FBTztZQUNiLEtBQUssRUFBRTtnQkFDTCxJQUFJLEVBQUUsdUJBQXVCO2FBQzlCO1NBQ0Y7S0FDRjtJQUNELEtBQUssRUFBRSxFQUFFO0NBQ1YsQ0FBQztBQUNGLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDbEIsTUFBTSxFQUFFLEdBQUc7SUFDVCxlQUFlLEVBQUU7UUFDZixXQUFXLEVBQUUsMElBQTBJO1FBQ3ZKLElBQUksRUFBRSxRQUFRO1FBQ2QsaUJBQWlCLEVBQUU7WUFDakIsa0JBQWtCLEVBQUU7Z0JBQ2xCLElBQUksRUFBRSw4QkFBOEI7YUFDckM7U0FDRjtRQUNELG9CQUFvQixFQUFFLENBQUMsQ0FBQztLQUN6QjtJQUNELG9CQUFvQixFQUFFO1FBQ3BCLFdBQVcsRUFBRSxpREFBaUQ7UUFDOUQsSUFBSSxFQUFFLFFBQVE7S0FDZjtJQUNELGVBQWUsRUFBRTtRQUNmLFdBQVcsRUFBRSw2SUFBNkk7UUFDMUosSUFBSSxFQUFFLFFBQVE7UUFDZCxpQkFBaUIsRUFBRTtZQUNqQixrQkFBa0IsRUFBRTtnQkFDbEIsSUFBSSxFQUFFLHdCQUF3QjthQUMvQjtTQUNGO1FBQ0Qsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDO0tBQ3pCO0lBQ0QsY0FBYyxFQUFFO1FBQ2QsV0FBVyxFQUFFLHlFQUF5RTtRQUN0RixJQUFJLEVBQUUsUUFBUTtRQUNkLFVBQVUsRUFBRTtZQUNWLFdBQVcsRUFBRTtnQkFDWCxXQUFXLEVBQUUsK1ZBQStWO2dCQUM1VyxJQUFJLEVBQUUsUUFBUTtnQkFDZCxPQUFPLEVBQUUsMERBQTBEO2dCQUNuRSxNQUFNLEVBQUUsYUFBYTthQUN0QjtZQUNELEtBQUssRUFBRTtnQkFDTCxXQUFXLEVBQUUsMklBQTJJO2dCQUN4SixJQUFJLEVBQUUsUUFBUTthQUNmO1NBQ0Y7S0FDRjtJQUNELFdBQVcsRUFBRTtRQUNYLFdBQVcsRUFBRSxnRkFBZ0Y7UUFDN0YsSUFBSSxFQUFFLFFBQVE7UUFDZCxPQUFPLEVBQUUsa0JBQWtCO1FBQzNCLE1BQU0sRUFBRSxhQUFhO0tBQ3RCO0NBQ0YsQ0FBQztBQUNGLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNQLE1BQU0sRUFBRSxHQUFHO0lBQ1QsT0FBTyxFQUFFLDhDQUE4QztJQUN2RCxLQUFLLEVBQUUsb0NBQW9DO0lBQzNDLFdBQVcsRUFBRSwrRkFBK0Y7SUFDNUcsSUFBSSxFQUFFLFFBQVE7SUFDZCxVQUFVLEVBQUU7UUFDVixRQUFRLEVBQUU7WUFDUixJQUFJLEVBQUUseUJBQXlCO1NBQ2hDO1FBQ0QsZ0JBQWdCLEVBQUU7WUFDaEIsSUFBSSxFQUFFLFFBQVE7WUFDZCxvQkFBb0IsRUFBRTtnQkFDcEIsSUFBSSxFQUFFLHlCQUF5QjthQUNoQztTQUNGO0tBQ0Y7SUFDRCxLQUFLLEVBQUUsRUFBRTtDQUNWLENBQUM7QUFDRixNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2xCLE1BQU0sRUFBRSxHQUFHO0lBQ1QsS0FBSyxFQUFFLHNCQUFzQjtJQUM3QixJQUFJLEVBQUUsUUFBUTtJQUNkLFVBQVUsRUFBRTtRQUNWLFFBQVEsRUFBRTtZQUNSLFdBQVcsRUFBRSxvQ0FBb0M7WUFDakQsSUFBSSxFQUFFLHlCQUF5QjtTQUNoQztRQUNELHFCQUFxQixFQUFFO1lBQ3JCLFdBQVcsRUFBRSw2REFBNkQ7WUFDMUUsSUFBSSxFQUFFLHlCQUF5QjtTQUNoQztRQUNELHlCQUF5QixFQUFFO1lBQ3pCLFdBQVcsRUFBRSxpRUFBaUU7WUFDOUUsSUFBSSxFQUFFLDBCQUEwQjtTQUNqQztRQUNELFlBQVksRUFBRTtZQUNaLFdBQVcsRUFBRSxrREFBa0Q7WUFDL0QsSUFBSSxFQUFFLFFBQVE7WUFDZCxpQkFBaUIsRUFBRTtnQkFDakIseUJBQXlCLEVBQUU7b0JBQ3pCLElBQUksRUFBRSw0QkFBNEI7aUJBQ25DO2FBQ0Y7WUFDRCxvQkFBb0IsRUFBRSxDQUFDLENBQUM7U0FDekI7S0FDRjtJQUNELFFBQVEsRUFBRSxDQUFDLFVBQVUsRUFBRSx1QkFBdUIsRUFBRSwyQkFBMkIsRUFBRSxjQUFjLENBQUM7SUFDNUYsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDO0lBQ3hCLEtBQUssRUFBRTtRQUNMLFdBQVcsRUFBRTtZQUNYLFdBQVcsRUFBRSwwRkFBMEY7WUFDdkcsSUFBSSxFQUFFLFFBQVE7WUFDZCxPQUFPLEVBQUUsa0JBQWtCO1NBQzVCO1FBQ0QsY0FBYyxFQUFFO1lBQ2QsV0FBVyxFQUFFLG1HQUFtRztZQUNoSCxJQUFJLEVBQUUsUUFBUTtZQUNkLE9BQU8sRUFBRSx5QkFBeUI7U0FDbkM7UUFDRCxrQkFBa0IsRUFBRTtZQUNsQixXQUFXLEVBQUUsc0ZBQXNGO1lBQ25HLElBQUksRUFBRSxRQUFRO1lBQ2QsaUJBQWlCLEVBQUU7Z0JBQ2pCLHlCQUF5QixFQUFFO29CQUN6QixXQUFXLEVBQUUsb0NBQW9DO29CQUNqRCxJQUFJLEVBQUUsUUFBUTtvQkFDZCxVQUFVLEVBQUU7d0JBQ1YsS0FBSyxFQUFFOzRCQUNMLFdBQVcsRUFBRSw0Q0FBNEM7NEJBQ3pELElBQUksRUFBRSxxQkFBcUI7eUJBQzVCO3dCQUNELGFBQWEsRUFBRTs0QkFDYixXQUFXLEVBQUUsdUZBQXVGOzRCQUNwRyxJQUFJLEVBQUUsUUFBUTt5QkFDZjt3QkFDRCxLQUFLLEVBQUU7NEJBQ0wsV0FBVyxFQUFFLDRFQUE0RTs0QkFDekYsSUFBSSxFQUFFLFFBQVE7eUJBQ2Y7d0JBQ0QsWUFBWSxFQUFFOzRCQUNaLFdBQVcsRUFBRSw2RUFBNkU7NEJBQzFGLElBQUksRUFBRSxTQUFTO3lCQUNoQjtxQkFDRjtvQkFDRCxRQUFRLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDO29CQUM1QixvQkFBb0IsRUFBRSxDQUFDLENBQUM7aUJBQ3pCO2FBQ0Y7WUFDRCxVQUFVLEVBQUU7Z0JBQ1YsWUFBWSxFQUFFO29CQUNaLFdBQVcsRUFBRSxvRkFBb0Y7b0JBQ2pHLElBQUksRUFBRSxTQUFTO2lCQUNoQjthQUNGO1NBQ0Y7UUFDRCxVQUFVLEVBQUU7WUFDVixXQUFXLEVBQUUsc0pBQXNKO1lBQ25LLElBQUksRUFBRSxRQUFRO1lBQ2QsaUJBQWlCLEVBQUU7Z0JBQ2pCLHlCQUF5QixFQUFFO29CQUN6QixXQUFXLEVBQUUsdUNBQXVDO29CQUNwRCxJQUFJLEVBQUUsUUFBUTtvQkFDZCxLQUFLLEVBQUU7d0JBQ0w7NEJBQ0UsVUFBVSxFQUFFO2dDQUNWLE1BQU0sRUFBRTtvQ0FDTixXQUFXLEVBQUUsdUVBQXVFO29DQUNwRixJQUFJLEVBQUUsd0JBQXdCO2lDQUMvQjtnQ0FDRCxLQUFLLEVBQUU7b0NBQ0wsV0FBVyxFQUFFLHdHQUF3RztvQ0FDckgsSUFBSSxFQUFFLFFBQVE7aUNBQ2Y7Z0NBQ0QsWUFBWSxFQUFFO29DQUNaLFdBQVcsRUFBRSxnRkFBZ0Y7b0NBQzdGLElBQUksRUFBRSxTQUFTO2lDQUNoQjs2QkFDRjs0QkFDRCxRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUM7NEJBQ25CLG9CQUFvQixFQUFFLENBQUMsQ0FBQzt5QkFDekI7d0JBQ0Q7NEJBQ0UsVUFBVSxFQUFFO2dDQUNWLFFBQVEsRUFBRTtvQ0FDUixXQUFXLEVBQUUsNkRBQTZEO29DQUMxRSxJQUFJLEVBQUUsd0JBQXdCO2lDQUMvQjtnQ0FDRCxLQUFLLEVBQUU7b0NBQ0wsV0FBVyxFQUFFLHdHQUF3RztvQ0FDckgsSUFBSSxFQUFFLFFBQVE7aUNBQ2Y7Z0NBQ0QsWUFBWSxFQUFFO29DQUNaLFdBQVcsRUFBRSxnRkFBZ0Y7b0NBQzdGLElBQUksRUFBRSxTQUFTO2lDQUNoQjs2QkFDRjs0QkFDRCxRQUFRLEVBQUUsQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDOzRCQUMvQixvQkFBb0IsRUFBRSxDQUFDLENBQUM7eUJBQ3pCO3FCQUNGO2lCQUNGO2FBQ0Y7WUFDRCxvQkFBb0IsRUFBRSxDQUFDLENBQUM7U0FDekI7UUFDRCxRQUFRLEVBQUU7WUFDUixXQUFXLEVBQUUsa0dBQWtHO1lBQy9HLElBQUksRUFBRSxRQUFRO1lBQ2QsS0FBSyxFQUFFO2dCQUNMO29CQUNFLFVBQVUsRUFBRTt3QkFDVixFQUFFLEVBQUU7NEJBQ0YsV0FBVyxFQUFFLDRDQUE0Qzs0QkFDekQsSUFBSSxFQUFFLHdCQUF3Qjt5QkFDL0I7cUJBQ0Y7b0JBQ0QsUUFBUSxFQUFFLENBQUMsSUFBSSxDQUFDO2lCQUNqQjtnQkFDRDtvQkFDRSxVQUFVLEVBQUU7d0JBQ1YsT0FBTyxFQUFFOzRCQUNQLFdBQVcsRUFBRSxrRUFBa0U7NEJBQy9FLElBQUksRUFBRSx3QkFBd0I7eUJBQy9CO3dCQUNELGNBQWMsRUFBRTs0QkFDZCxXQUFXLEVBQUUseUdBQXlHOzRCQUN0SCxJQUFJLEVBQUUsUUFBUTt5QkFDZjt3QkFDRCxhQUFhLEVBQUU7NEJBQ2IsV0FBVyxFQUFFLHdHQUF3Rzs0QkFDckgsSUFBSSxFQUFFLFFBQVE7eUJBQ2Y7cUJBQ0Y7b0JBQ0QsUUFBUSxFQUFFLENBQUMsU0FBUyxDQUFDO2lCQUN0QjthQUNGO1lBQ0QsVUFBVSxFQUFFO2dCQUNWLEtBQUssRUFBRTtvQkFDTCxXQUFXLEVBQUUsMkRBQTJEO29CQUN4RSxJQUFJLEVBQUUscUJBQXFCO2lCQUM1QjtnQkFDRCxPQUFPLEVBQUU7b0JBQ1AsV0FBVyxFQUFFLHNGQUFzRjtvQkFDbkcsSUFBSSxFQUFFLHFCQUFxQjtpQkFDNUI7Z0JBQ0QsV0FBVyxFQUFFO29CQUNYLFdBQVcsRUFBRSw0R0FBNEc7b0JBQ3pILElBQUksRUFBRSxxQkFBcUI7aUJBQzVCO2dCQUNELGFBQWEsRUFBRTtvQkFDYixXQUFXLEVBQUUsdUZBQXVGO29CQUNwRyxJQUFJLEVBQUUsUUFBUTtpQkFDZjtnQkFDRCxLQUFLLEVBQUU7b0JBQ0wsV0FBVyxFQUFFLHVDQUF1QztvQkFDcEQsSUFBSSxFQUFFLHdCQUF3QjtpQkFDL0I7Z0JBQ0QsS0FBSyxFQUFFO29CQUNMLFdBQVcsRUFBRSxvR0FBb0c7b0JBQ2pILElBQUksRUFBRSxRQUFRO2lCQUNmO2FBQ0Y7WUFDRCxRQUFRLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQztZQUNyQyxxQkFBcUIsRUFBRSxDQUFDLENBQUM7U0FDMUI7UUFDRCxjQUFjLEVBQUU7WUFDZCxXQUFXLEVBQUUsMEJBQTBCO1lBQ3ZDLElBQUksRUFBRSxRQUFRO1lBQ2QsVUFBVSxFQUFFO2dCQUNWLE1BQU0sRUFBRTtvQkFDTixXQUFXLEVBQUUsaUNBQWlDO29CQUM5QyxJQUFJLEVBQUUsb0JBQW9CO2lCQUMzQjtnQkFDRCxLQUFLLEVBQUU7b0JBQ0wsV0FBVyxFQUFFLDZDQUE2QztvQkFDMUQsSUFBSSxFQUFFLE9BQU87b0JBQ2IsS0FBSyxFQUFFLEVBQUUsSUFBSSxFQUFFLGtCQUFrQixFQUFFO29CQUNuQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO2lCQUNoQjthQUNGO1lBQ0QsUUFBUSxFQUFFLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQztTQUM5QjtRQUNELGdCQUFnQixFQUFFO1lBQ2hCLFdBQVcsRUFBRSw4Q0FBOEM7WUFDM0QsSUFBSSxFQUFFLFFBQVE7WUFDZCxLQUFLLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSx3QkFBd0IsRUFBRSxDQUFDO1lBQzNDLHFCQUFxQixFQUFFLENBQUMsQ0FBQztTQUMxQjtRQUNELGVBQWUsRUFBRTtZQUNmLFdBQVcsRUFBRSxxREFBcUQ7WUFDbEUsSUFBSSxFQUFFLFFBQVE7WUFDZCxLQUFLLEVBQUU7Z0JBQ0wsRUFBRSxJQUFJLEVBQUUsd0JBQXdCLEVBQUU7Z0JBQ2xDO29CQUNFLFVBQVUsRUFBRTt3QkFDVixPQUFPLEVBQUU7NEJBQ1AsV0FBVyxFQUFFLGtDQUFrQzs0QkFDL0MsSUFBSSxFQUFFLDRCQUE0Qjt5QkFDbkM7cUJBQ0Y7b0JBQ0QsUUFBUSxFQUFFLENBQUMsU0FBUyxDQUFDO2lCQUN0QjthQUNGO1lBQ0QscUJBQXFCLEVBQUUsQ0FBQyxDQUFDO1NBQzFCO1FBQ0Qsa0JBQWtCLEVBQUU7WUFDbEIsV0FBVyxFQUFFLG9EQUFvRDtZQUNqRSxJQUFJLEVBQUUsUUFBUTtZQUNkLFVBQVUsRUFBRTtnQkFDVixlQUFlLEVBQUU7b0JBQ2YsV0FBVyxFQUFFLGtGQUFrRjtvQkFDL0YsSUFBSSxFQUFFLFNBQVM7aUJBQ2hCO2dCQUNELE9BQU8sRUFBRTtvQkFDUCxXQUFXLEVBQUUsZ0VBQWdFO29CQUM3RSxJQUFJLEVBQUUseUJBQXlCO2lCQUNoQztnQkFDRCxXQUFXLEVBQUU7b0JBQ1gsV0FBVyxFQUFFLHFFQUFxRTtvQkFDbEYsSUFBSSxFQUFFLDBCQUEwQjtpQkFDakM7YUFDRjtZQUNELG9CQUFvQixFQUFFLENBQUMsQ0FBQztTQUN6QjtLQUNGO0NBQ0YsQ0FBQztBQUNGLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDbEIsTUFBTSxFQUFFLEdBQUcsQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUNsRCxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2xCLE1BQU0sRUFBRTtJQUNOLFlBQVksQ0FBQztRQUNYLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDZixDQUFDLENBQUMsSUFBSSxFQUFFLG1CQUFtQixDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDZixDQUFDO0lBQ0QsOEVBQThFO0lBQzlFLFVBQVU7UUFDUixJQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUNELG9GQUFvRjtJQUNwRixlQUFlLENBQUMsQ0FBQztRQUNmLE1BQU0sQ0FBQyxHQUFHLHVEQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDO1lBQUUsT0FBTztRQUMzQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QyxNQUFNLENBQUMsR0FBRyx1REFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3BELE9BQU8sQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUNELFVBQVUsQ0FBQyxDQUFDO1FBQ1YsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBQ0QsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO0lBQ3JGLENBQUM7SUFDRCxlQUFlLENBQUMsQ0FBQztRQUNmLE1BQU0sQ0FBQyxHQUFHLGdEQUFnRCxDQUFDLEtBQUssQ0FBQztRQUNqRSxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUNELGFBQWE7SUFDYixzQkFBc0I7SUFDdEIsTUFBTSxDQUFDLHVCQUF1QixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUNwQyxJQUFJLENBQUMsQ0FBQztRQUNOLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ3hGLE9BQU8sQ0FBQyxJQUFJLFFBQVEsSUFBSSxFQUFFLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM5RCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFDRCxzRUFBc0U7SUFDdEUsa0JBQWtCO1FBQ2hCLE1BQU0sQ0FBQyxHQUFHLGVBQWUsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ3BDLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDM0YsT0FBTyxDQUFDLElBQUksUUFBUSxJQUFJLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNyRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDUixDQUFDO0lBQ0Qsc0VBQXNFO0lBQ3RFLElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3hJLENBQUM7SUFDRCxhQUFhO0lBQ2IseUJBQXlCO0lBQ3pCLDREQUE0RDtJQUM1RCxrQkFBa0IsQ0FBQyxDQUFDO1FBQ2xCLE1BQU0sQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFDdEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLE9BQU8sQ0FBQyxLQUFLLEtBQUssQ0FBQyxHQUFJLENBQUM7WUFDdEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPO2dCQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztZQUN4RTtZQUNFLDZGQUE2RjtZQUM3Rix3Q0FBd0M7WUFDeEMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDdkIsSUFBSSxDQUFDLEtBQUssQ0FBQztvQkFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO2dCQUN2QixJQUFJLENBQUMsQ0FBQztvQkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUM7Z0JBQ3pFLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDaEQsQ0FBQyxDQUFDO2dCQUVGLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2hGLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxFQUFFO2dCQUFFLE1BQU07WUFDekIsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QixDQUFDO1FBQ0QsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBQ0QsTUFBTSxDQUFDLDZCQUE2QixDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQ1osT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDckIsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQztRQUNqQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDUixDQUFDO0lBQ0QsNkJBQTZCLENBQUMsQ0FBQztRQUM3QixNQUFNLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUMvQyxJQUFJLENBQUMsQ0FBQztZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMscUNBQXFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbEUsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNqQixPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDeEIsTUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMxQixJQUFJLENBQUMsQ0FBQztnQkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2xFLE1BQU0sQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDN0IsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDdEQsSUFBSSxPQUFPLENBQUMsSUFBSSxRQUFRLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTztvQkFDcEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ3BGLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZCLElBQUksT0FBTyxDQUFDLElBQUksUUFBUTtvQkFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ3BGLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDUixDQUFDO1FBQ0gsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ1IsQ0FBQztJQUNELGFBQWE7SUFDYiw2QkFBNkI7SUFDN0I7Ozs7Ozs7Ozs7Ozs7OztPQWVHO0lBQ0gsTUFBTSxDQUFDLG1DQUFtQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUU7UUFDckQsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPO1lBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQzlDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUMvQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZCLElBQUksT0FBTyxDQUFDLElBQUksUUFBUSxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO2dCQUM3QyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ2xHLENBQUM7UUFDRCxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUFDaEMsQ0FBQztJQUNELE1BQU0sQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ3JELElBQUksQ0FBQyxDQUFDO1FBQ04sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsT0FBTyxDQUFDLEtBQUssS0FBSyxDQUFDLEdBQUksQ0FBQztZQUN0QixNQUFNLENBQUMsR0FBRyxPQUFPLENBQUMsSUFBSSxRQUFRLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDckQsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFBRSxPQUFPLENBQUMsQ0FBQztZQUM1QixJQUFJLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDO2dCQUN4RixDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7O2dCQUVqRCxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBSSxDQUFDO29CQUNoQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO3dCQUMvQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBQ3ZELE1BQU07b0JBQ1IsQ0FBQztnQkFDSCxDQUFDO1FBQ0wsQ0FBQztJQUNILENBQUM7SUFDRDs7OztPQUlHO0lBQ0gsb0JBQW9CLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQzFCLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyQyxPQUFPLEVBQUUsQ0FBQyxxQ0FBcUMsQ0FDN0MsQ0FBQyxFQUNELENBQUMsRUFDRCxDQUFDLEVBQ0QsQ0FBQyxDQUNGLENBQUM7SUFDSixDQUFDO0lBQ0QsYUFBYTtJQUNiLDJCQUEyQjtJQUMzQixjQUFjLENBQUMsQ0FBQztRQUNkLE9BQU8sRUFBRSxDQUFDLDZCQUE2QixDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7SUFDRCxhQUFhO0lBQ2Isb0RBQW9EO0lBQ3BELGdFQUFnRTtJQUNoRSxtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRztRQUM1QixVQUFVLEVBQUUsS0FBSyxDQUFDO1FBQ2xCLFFBQVEsRUFBRSxLQUFLLENBQUM7UUFDaEIsbUJBQW1CLEVBQUUsS0FBSyxDQUFDO0tBQzVCO1FBQ0MsSUFBSSxDQUFDLENBQUMsUUFBUSxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLEtBQUssS0FBSyxDQUFDO1lBQUUsT0FBTyxDQUFDLENBQUM7UUFDL0QsSUFBSSxPQUFPLENBQUMsSUFBSSxRQUFRLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQ2hELE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztZQUN4QyxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssRUFBRTtnQkFDZixPQUFPLENBQUMsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLG1CQUFtQixHQUFHLENBQUMsQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQy9HLENBQUMsQ0FBQyxJQUFJLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUM5RSxDQUFDO1FBQ0QsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPO1lBQ1osTUFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDckUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRTtZQUN2QyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQ3ZCLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ04sTUFBTTtZQUNSLENBQUM7UUFDSCxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRO1lBQzlDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDVCxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUNWLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxFQUFFO2dCQUNmLE9BQU8sQ0FBQyxDQUFDLFVBQVUsS0FBSyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxtQkFBbUIsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMxRyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxDQUFDO2dCQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3BFLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDM0MsQ0FBQztRQUNELE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxtQ0FBbUMsQ0FDaEUsQ0FBQyxFQUNELENBQUMsRUFDRCxFQUFFLENBQ0gsQ0FBQztRQUNGLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBQ0QsdUJBQXVCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQzdCLElBQUksT0FBTyxDQUFDLElBQUksUUFBUSxJQUFJLENBQUMsS0FBSyxLQUFLLENBQUM7WUFDdEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO1FBQ2xGLElBQUksQ0FBQyxDQUFDO1FBQ04sSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEtBQUssQ0FBQztZQUMzRyxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNqRSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxDQUFDO1lBQUUsT0FBTztRQUNmLElBQUksQ0FBQyxDQUFDLENBQUMsVUFBVTtZQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQTBDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2pGLE1BQU0sQ0FBQyxHQUFHO1lBQ1IsSUFBSSxFQUFFLENBQUM7WUFDUCxVQUFVLEVBQUUsQ0FBQyxDQUFDLFVBQVU7WUFDeEIsUUFBUSxFQUFFLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQztTQUMxQixDQUFDO1FBQ0YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsT0FBTyxDQUFDLENBQUMsbUJBQW1CLEtBQUssS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDdkcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ1QsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaFQsQ0FBQyxDQUFDLEVBQUUsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUNqQyxDQUFDO0lBQ0QsYUFBYTtJQUNiLGtEQUFrRDtJQUNsRCwyQkFBMkIsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUM5QixNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxDQUFDO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO1FBQzdELE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLENBQUM7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3BFLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLENBQUM7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLGtDQUFrQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQy9ELE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQyxDQUFDO1lBQ0osTUFBTSxJQUFJLEtBQUssQ0FDYiw4REFBOEQsQ0FBQyxFQUFFLENBQ2xFLENBQUM7UUFDSixPQUFPLENBQUMsQ0FBQztJQUNYLENBQUM7SUFDRCxhQUFhO0lBQ2Isa0VBQWtFO0lBQ2xFLDRCQUE0QixDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQztRQUNuQyxJQUFJLENBQUMsR0FBRyxDQUFDO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1FBQ2xELE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxDQUFDO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO1FBQzdELElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJO1lBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7UUFDbEYsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDO1lBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQ2pFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDbkIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQ3ZFLENBQUMsRUFDRCxFQUFFLEVBQ0YsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLDZCQUE2QixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLDZCQUE2QixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNuUSxDQUFDO1FBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLFFBQVE7WUFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQztRQUNsRSxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDeEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUM5QixDQUFDLEVBQ0QsRUFBRSxFQUNGLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ1AsSUFBSSxDQUFDLEtBQUssQ0FBQztnQkFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3ZCLElBQUksT0FBTyxDQUFDLElBQUksUUFBUSxFQUFFLENBQUM7Z0JBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUM7b0JBQ3RCLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDcEYsQ0FBQztpQkFBTSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssRUFBRTtnQkFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3JELE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDWixDQUFDLENBQ0YsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDO0lBQzlDLENBQUM7SUFDRCxhQUFhO0lBQ2IsMERBQTBEO0lBQzFELDhCQUE4QixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUc7UUFDMUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2hDLElBQUksRUFBRSxDQUFDLHFDQUFxQyxDQUMxQyxDQUFDLENBQUMsSUFBSSxFQUNOLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQzlDLEVBQUUsRUFDRixDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ0osSUFBSSxPQUFPLENBQUMsSUFBSSxRQUFRO2dCQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDcEMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQzlCLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEksQ0FBQyxDQUNGLEVBQUUsQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPO1FBQ2xCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDTixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNsQixNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMscUNBQXFDLENBQ2hELENBQUMsQ0FBQyxJQUFJLEVBQ04sSUFBSSxDQUFDLDZCQUE2QixDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFDOUMsRUFBRSxFQUNGLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQ3RHLENBQUM7UUFDRixJQUFJLENBQUMsQ0FBQztZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsNkNBQTZDLENBQUMsQ0FBQztRQUN2RSxPQUFPO1lBQ0wsSUFBSSxFQUFFLENBQUM7WUFDUCxNQUFNLEVBQUUsQ0FBQztZQUNULFFBQVEsRUFBRSxFQUFFLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxDQUFDO1NBQzlDLENBQUM7SUFDSixDQUFDO0lBQ0QsYUFBYTtJQUNiLHVEQUF1RDtJQUN2RCxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDZCxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoQyxPQUFPLEVBQUUsQ0FBQyxxQ0FBcUMsQ0FDN0MsQ0FBQyxDQUFDLElBQUksRUFDTixJQUFJLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUM5QyxFQUFFLEVBQ0YsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUNKLElBQUksT0FBTyxDQUFDLElBQUksUUFBUTtnQkFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNO2dCQUNmLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDM0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ1YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUM7Z0JBQ3hELE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzNDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDaEIsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDaEQsQ0FBQyxDQUNGLEVBQUUsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUNELHdCQUF3QixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUc7UUFDcEMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ1gsT0FBTyxFQUFFLENBQUMscUNBQXFDLENBQzdDLENBQUMsQ0FBQyxJQUFJLEVBQ04sSUFBSSxDQUFDLDZCQUE2QixDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFDOUMsRUFBRSxFQUNGLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxRQUFRLElBQUksQ0FBQyxDQUFDLFFBQVEsS0FBSyxFQUFFLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FDbk4sRUFBRSxDQUFDLENBQUM7SUFDUCxDQUFDO0lBQ0QsYUFBYTtJQUNiLDZCQUE2QjtJQUM3QixNQUFNLENBQUMsMkJBQTJCLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDckMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDdkMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2YsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksUUFBUSxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLDJCQUEyQixDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvSCxDQUFDO1FBQ0QsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBQ0Qsa0JBQWtCLENBQUMsQ0FBQztRQUNsQixNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsMkJBQTJCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDOUQsT0FBTyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzlCLENBQUM7Q0FFRjtBQTJGQztBQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVQ3J2UUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTs7Ozs7V0MvQkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esc0RBQXNEO1dBQ3RELHNDQUFzQyxpRUFBaUU7V0FDdkc7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRUFBRTtXQUNGOzs7OztXQ1JBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDSkE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDSkE7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsZ0JBQWdCLHFCQUFxQjtXQUNyQzs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGFBQWE7V0FDYjtXQUNBLElBQUk7V0FDSjtXQUNBOztXQUVBOztXQUVBOztXQUVBOzs7OztVRXJDQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fuc2ktc3R5bGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGFsay9zb3VyY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoYWxrL3NvdXJjZS90ZW1wbGF0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoYWxrL3NvdXJjZS91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2NvbnZlcnNpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L3JvdXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb2xvci1uYW1lL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvc3JjL2NvcmUvTG9nZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvc3JjL2NvcmUvc2NvcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9zcmMvbWFpbi9FcnJvckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9zcmMvbWFpbi9FdmVudExvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3NyYy9tYWluL2VsZWN0cm9uQXBpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvc3JjL21haW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9zcmMvbWFpbi9pbml0aWFsaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvc3JjL21haW4vdHJhbnNmb3Jtcy9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9zcmMvbWFpbi90cmFuc2Zvcm1zL29iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3NyYy9tYWluL3RyYW5zZm9ybXMvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9zcmMvbWFpbi90cmFuc2Zvcm1zL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3NyYy9tYWluL3RyYW5zcG9ydHMvY29uc29sZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3NyYy9tYWluL3RyYW5zcG9ydHMvZmlsZS9GaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvc3JjL21haW4vdHJhbnNwb3J0cy9maWxlL0ZpbGVSZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3NyYy9tYWluL3RyYW5zcG9ydHMvZmlsZS9OdWxsRmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3NyYy9tYWluL3RyYW5zcG9ydHMvZmlsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3NyYy9tYWluL3RyYW5zcG9ydHMvZmlsZS9wYWNrYWdlSnNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3NyYy9tYWluL3RyYW5zcG9ydHMvZmlsZS92YXJpYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9zcmMvbWFpbi90cmFuc3BvcnRzL3JlbW90ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3NyYy9yZW5kZXJlci9lbGVjdHJvbi1sb2ctcHJlbG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3NyYy9yZW5kZXJlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3NyYy9yZW5kZXJlci9saWIvUmVuZGVyZXJFcnJvckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9zcmMvcmVuZGVyZXIvbGliL3RyYW5zcG9ydHMvY29uc29sZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3NyYy9yZW5kZXJlci9saWIvdHJhbnNwb3J0cy9pcGMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXdpbmRvdy1zdGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2dyYWNlZnVsLWZzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9sZWdhY3ktc3RyZWFtcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvcG9seWZpbGxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXMtZmxhZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHR0cC1zdGF0dXMtY29kZXMvYnVpbGQvZXMvc3RhdHVzLWNvZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbXVybXVyaGFzaC9pbXVybXVyaGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbi1ycGMtMi4wL2Rpc3QvY2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc29uLXJwYy0yLjAvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbi1ycGMtMi4wL2Rpc3QvaW50ZXJmYWNlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbi1ycGMtMi4wL2Rpc3QvaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb24tcnBjLTIuMC9kaXN0L21vZGVscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbi1ycGMtMi4wL2Rpc3Qvc2VydmVyLWFuZC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb24tcnBjLTIuMC9kaXN0L3NlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbmZpbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21lbW9pemUtb25lL2Rpc3QvbWVtb2l6ZS1vbmUuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ta2RpcnAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtbG9jYWxzdG9yYWdlL0xvY2FsU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vZ2xvYmFsLXRoaXMubW9kZWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vbWFpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9wbGF0Zm9ybS1tYWNvcy1tZW51YmFyLmRhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vcGxhdGZvcm0tbWFjb3MtbWVudWJhci51dGlsLnRzIiwid2VicGFjazovLy8uL3NyYy9tYWluL3NlcnZpY2VzL2FwcC5zZXJ2aWNlLWhvc3QudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vc2VydmljZXMvZGF0YS1wcm90ZWN0aW9uLnNlcnZpY2UtaG9zdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9zZXJ2aWNlcy9kb3RuZXQtZGF0YS1wcm92aWRlci5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL3NyYy9tYWluL3NlcnZpY2VzL2V4dGVuc2lvbi1hc3NldC1wcm90b2NvbC5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL3NyYy9tYWluL3NlcnZpY2VzL2V4dGVuc2lvbi1ob3N0LnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vc2VydmljZXMvbmV0d29yay1vYmplY3Qtc3RhdHVzLnNlcnZpY2UtaG9zdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9zZXJ2aWNlcy9wcm9qZWN0LWxvb2t1cC5zZXJ2aWNlLWhvc3QudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGUvbW9kZWxzL2ludGVycHJvY2Vzcy1tZXNzYWdlcy5tb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZS9wb2x5ZmlsbHMvbG9jYWwtc3RvcmFnZS5wb2x5ZmlsbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZS9zZXJ2aWNlcy9leHRlbnNpb24uc2VydmljZS1tb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZS91dGlscy9jb21tYW5kLWxpbmUudXRpbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZS91dGlscy91dGlsLnRzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvZGF0YS9wbGF0Zm9ybS1iaWJsZS1tZW51LmNvbW1hbmRzLnRzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvZGF0YS9wbGF0Zm9ybS5kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvZGF0YS9ycGMubW9kZWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9nbG9iYWwtdGhpcy5tb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL21vZGVscy9kYXRhLXByb3RlY3Rpb24uc2VydmljZS1tb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL21vZGVscy9kYXRhLXByb3ZpZGVyLWVuZ2luZS5tb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL21vZGVscy9kYXRhLXByb3ZpZGVyLm1vZGVsLnRzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvbW9kZWxzL25ldHdvcmstb2JqZWN0LXN0YXR1cy5zZXJ2aWNlLW1vZGVsLnRzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvbW9kZWxzL25vdGlmaWNhdGlvbi5zZXJ2aWNlLW1vZGVsLnRzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvbW9kZWxzL29wZW5ycGMubW9kZWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9tb2RlbHMvcGFwaS1uZXR3b3JrLWV2ZW50LWVtaXR0ZXIubW9kZWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9tb2RlbHMvcHJvamVjdC1kYXRhLXByb3ZpZGVyLWZhY3RvcnkuaW50ZXJmYWNlLnRzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvbW9kZWxzL3Byb2plY3QtZGF0YS1wcm92aWRlci5tb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL21vZGVscy9wcm9qZWN0LWxvb2t1cC5zZXJ2aWNlLW1vZGVsLnRzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvc2VydmljZXMvYXBwLnNlcnZpY2UtbW9kZWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9zZXJ2aWNlcy9jb21tYW5kLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9zZXJ2aWNlcy9kYXRhLXByb3ZpZGVyLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9zZXJ2aWNlcy9leHRlbnNpb24tYXNzZXQuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL3NlcnZpY2VzL2xvY2FsaXphdGlvbi5zZXJ2aWNlLW1vZGVsLnRzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvc2VydmljZXMvbG9jYWxpemF0aW9uLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9zZXJ2aWNlcy9sb2dnZXIuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL3NlcnZpY2VzL21lbnUtZGF0YS5zZXJ2aWNlLW1vZGVsLnRzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvc2VydmljZXMvbWVudS1kYXRhLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9zZXJ2aWNlcy9uZXR3b3JrLW9iamVjdC1zdGF0dXMuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL3NlcnZpY2VzL25ldHdvcmstb2JqZWN0LnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9zZXJ2aWNlcy9uZXR3b3JrLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9zZXJ2aWNlcy9ub3RpZmljYXRpb24uc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL3NlcnZpY2VzL3Byb2plY3QtZGF0YS1wcm92aWRlci5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvc2VydmljZXMvcHJvamVjdC1sb29rdXAuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL3NlcnZpY2VzL3JwYy1oYW5kbGVyLmZhY3RvcnkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9zZXJ2aWNlcy9zZXR0aW5ncy5zZXJ2aWNlLW1vZGVsLnRzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvc2VydmljZXMvc2V0dGluZ3Muc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL3V0aWxzL2ludGVybmFsLXV0aWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC91dGlscy91dGlsLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cml0ZS1maWxlLWF0b21pYy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJhc3NlcnRcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImJ1ZmZlclwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiY2hpbGRfcHJvY2Vzc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiY29uc3RhbnRzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImVsZWN0cm9uXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJldmVudHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImZzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJmcy9wcm9taXNlc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiaHR0cFwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiaHR0cHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5ldFwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwib3NcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInBhdGhcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInN0cmVhbVwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidGxzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJ0dHlcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInVybFwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidXRpbFwiIiwid2VicGFjazovLy9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidm1cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIndvcmtlcl90aHJlYWRzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJ6bGliXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dyaXRlLWZpbGUtYXRvbWljL25vZGVfbW9kdWxlcy9zaWduYWwtZXhpdC9kaXN0L2Nqcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3JpdGUtZmlsZS1hdG9taWMvbm9kZV9tb2R1bGVzL3NpZ25hbC1leGl0L2Rpc3QvY2pzL3NpZ25hbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzeW5jLW11dGV4L2luZGV4Lm1qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbnBhdGgtcGx1cy9kaXN0L2luZGV4LW5vZGUtZXNtLmpzIiwid2VicGFjazovLy8uL2xpYi9wbGF0Zm9ybS1iaWJsZS11dGlscy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9jcmVhdGUgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9lbnN1cmUgY2h1bmsiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL25vZGUgbW9kdWxlIGRlY29yYXRvciIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL3JlcXVpcmUgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly8vd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly8vd2VicGFjay9zdGFydHVwIiwid2VicGFjazovLy93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKGdsb2JhbCwgKCkgPT4ge1xucmV0dXJuICIsIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgd3JhcEFuc2kxNiA9IChmbiwgb2Zmc2V0KSA9PiAoLi4uYXJncykgPT4ge1xuXHRjb25zdCBjb2RlID0gZm4oLi4uYXJncyk7XG5cdHJldHVybiBgXFx1MDAxQlske2NvZGUgKyBvZmZzZXR9bWA7XG59O1xuXG5jb25zdCB3cmFwQW5zaTI1NiA9IChmbiwgb2Zmc2V0KSA9PiAoLi4uYXJncykgPT4ge1xuXHRjb25zdCBjb2RlID0gZm4oLi4uYXJncyk7XG5cdHJldHVybiBgXFx1MDAxQlskezM4ICsgb2Zmc2V0fTs1OyR7Y29kZX1tYDtcbn07XG5cbmNvbnN0IHdyYXBBbnNpMTZtID0gKGZuLCBvZmZzZXQpID0+ICguLi5hcmdzKSA9PiB7XG5cdGNvbnN0IHJnYiA9IGZuKC4uLmFyZ3MpO1xuXHRyZXR1cm4gYFxcdTAwMUJbJHszOCArIG9mZnNldH07Mjske3JnYlswXX07JHtyZ2JbMV19OyR7cmdiWzJdfW1gO1xufTtcblxuY29uc3QgYW5zaTJhbnNpID0gbiA9PiBuO1xuY29uc3QgcmdiMnJnYiA9IChyLCBnLCBiKSA9PiBbciwgZywgYl07XG5cbmNvbnN0IHNldExhenlQcm9wZXJ0eSA9IChvYmplY3QsIHByb3BlcnR5LCBnZXQpID0+IHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHtcblx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdGNvbnN0IHZhbHVlID0gZ2V0KCk7XG5cblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7XG5cdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSxcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHR9KTtcbn07XG5cbi8qKiBAdHlwZSB7dHlwZW9mIGltcG9ydCgnY29sb3ItY29udmVydCcpfSAqL1xubGV0IGNvbG9yQ29udmVydDtcbmNvbnN0IG1ha2VEeW5hbWljU3R5bGVzID0gKHdyYXAsIHRhcmdldFNwYWNlLCBpZGVudGl0eSwgaXNCYWNrZ3JvdW5kKSA9PiB7XG5cdGlmIChjb2xvckNvbnZlcnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbG9yQ29udmVydCA9IHJlcXVpcmUoJ2NvbG9yLWNvbnZlcnQnKTtcblx0fVxuXG5cdGNvbnN0IG9mZnNldCA9IGlzQmFja2dyb3VuZCA/IDEwIDogMDtcblx0Y29uc3Qgc3R5bGVzID0ge307XG5cblx0Zm9yIChjb25zdCBbc291cmNlU3BhY2UsIHN1aXRlXSBvZiBPYmplY3QuZW50cmllcyhjb2xvckNvbnZlcnQpKSB7XG5cdFx0Y29uc3QgbmFtZSA9IHNvdXJjZVNwYWNlID09PSAnYW5zaTE2JyA/ICdhbnNpJyA6IHNvdXJjZVNwYWNlO1xuXHRcdGlmIChzb3VyY2VTcGFjZSA9PT0gdGFyZ2V0U3BhY2UpIHtcblx0XHRcdHN0eWxlc1tuYW1lXSA9IHdyYXAoaWRlbnRpdHksIG9mZnNldCk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygc3VpdGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRzdHlsZXNbbmFtZV0gPSB3cmFwKHN1aXRlW3RhcmdldFNwYWNlXSwgb2Zmc2V0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufTtcblxuZnVuY3Rpb24gYXNzZW1ibGVTdHlsZXMoKSB7XG5cdGNvbnN0IGNvZGVzID0gbmV3IE1hcCgpO1xuXHRjb25zdCBzdHlsZXMgPSB7XG5cdFx0bW9kaWZpZXI6IHtcblx0XHRcdHJlc2V0OiBbMCwgMF0sXG5cdFx0XHQvLyAyMSBpc24ndCB3aWRlbHkgc3VwcG9ydGVkIGFuZCAyMiBkb2VzIHRoZSBzYW1lIHRoaW5nXG5cdFx0XHRib2xkOiBbMSwgMjJdLFxuXHRcdFx0ZGltOiBbMiwgMjJdLFxuXHRcdFx0aXRhbGljOiBbMywgMjNdLFxuXHRcdFx0dW5kZXJsaW5lOiBbNCwgMjRdLFxuXHRcdFx0aW52ZXJzZTogWzcsIDI3XSxcblx0XHRcdGhpZGRlbjogWzgsIDI4XSxcblx0XHRcdHN0cmlrZXRocm91Z2g6IFs5LCAyOV1cblx0XHR9LFxuXHRcdGNvbG9yOiB7XG5cdFx0XHRibGFjazogWzMwLCAzOV0sXG5cdFx0XHRyZWQ6IFszMSwgMzldLFxuXHRcdFx0Z3JlZW46IFszMiwgMzldLFxuXHRcdFx0eWVsbG93OiBbMzMsIDM5XSxcblx0XHRcdGJsdWU6IFszNCwgMzldLFxuXHRcdFx0bWFnZW50YTogWzM1LCAzOV0sXG5cdFx0XHRjeWFuOiBbMzYsIDM5XSxcblx0XHRcdHdoaXRlOiBbMzcsIDM5XSxcblxuXHRcdFx0Ly8gQnJpZ2h0IGNvbG9yXG5cdFx0XHRibGFja0JyaWdodDogWzkwLCAzOV0sXG5cdFx0XHRyZWRCcmlnaHQ6IFs5MSwgMzldLFxuXHRcdFx0Z3JlZW5CcmlnaHQ6IFs5MiwgMzldLFxuXHRcdFx0eWVsbG93QnJpZ2h0OiBbOTMsIDM5XSxcblx0XHRcdGJsdWVCcmlnaHQ6IFs5NCwgMzldLFxuXHRcdFx0bWFnZW50YUJyaWdodDogWzk1LCAzOV0sXG5cdFx0XHRjeWFuQnJpZ2h0OiBbOTYsIDM5XSxcblx0XHRcdHdoaXRlQnJpZ2h0OiBbOTcsIDM5XVxuXHRcdH0sXG5cdFx0YmdDb2xvcjoge1xuXHRcdFx0YmdCbGFjazogWzQwLCA0OV0sXG5cdFx0XHRiZ1JlZDogWzQxLCA0OV0sXG5cdFx0XHRiZ0dyZWVuOiBbNDIsIDQ5XSxcblx0XHRcdGJnWWVsbG93OiBbNDMsIDQ5XSxcblx0XHRcdGJnQmx1ZTogWzQ0LCA0OV0sXG5cdFx0XHRiZ01hZ2VudGE6IFs0NSwgNDldLFxuXHRcdFx0YmdDeWFuOiBbNDYsIDQ5XSxcblx0XHRcdGJnV2hpdGU6IFs0NywgNDldLFxuXG5cdFx0XHQvLyBCcmlnaHQgY29sb3Jcblx0XHRcdGJnQmxhY2tCcmlnaHQ6IFsxMDAsIDQ5XSxcblx0XHRcdGJnUmVkQnJpZ2h0OiBbMTAxLCA0OV0sXG5cdFx0XHRiZ0dyZWVuQnJpZ2h0OiBbMTAyLCA0OV0sXG5cdFx0XHRiZ1llbGxvd0JyaWdodDogWzEwMywgNDldLFxuXHRcdFx0YmdCbHVlQnJpZ2h0OiBbMTA0LCA0OV0sXG5cdFx0XHRiZ01hZ2VudGFCcmlnaHQ6IFsxMDUsIDQ5XSxcblx0XHRcdGJnQ3lhbkJyaWdodDogWzEwNiwgNDldLFxuXHRcdFx0YmdXaGl0ZUJyaWdodDogWzEwNywgNDldXG5cdFx0fVxuXHR9O1xuXG5cdC8vIEFsaWFzIGJyaWdodCBibGFjayBhcyBncmF5IChhbmQgZ3JleSlcblx0c3R5bGVzLmNvbG9yLmdyYXkgPSBzdHlsZXMuY29sb3IuYmxhY2tCcmlnaHQ7XG5cdHN0eWxlcy5iZ0NvbG9yLmJnR3JheSA9IHN0eWxlcy5iZ0NvbG9yLmJnQmxhY2tCcmlnaHQ7XG5cdHN0eWxlcy5jb2xvci5ncmV5ID0gc3R5bGVzLmNvbG9yLmJsYWNrQnJpZ2h0O1xuXHRzdHlsZXMuYmdDb2xvci5iZ0dyZXkgPSBzdHlsZXMuYmdDb2xvci5iZ0JsYWNrQnJpZ2h0O1xuXG5cdGZvciAoY29uc3QgW2dyb3VwTmFtZSwgZ3JvdXBdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcykpIHtcblx0XHRmb3IgKGNvbnN0IFtzdHlsZU5hbWUsIHN0eWxlXSBvZiBPYmplY3QuZW50cmllcyhncm91cCkpIHtcblx0XHRcdHN0eWxlc1tzdHlsZU5hbWVdID0ge1xuXHRcdFx0XHRvcGVuOiBgXFx1MDAxQlske3N0eWxlWzBdfW1gLFxuXHRcdFx0XHRjbG9zZTogYFxcdTAwMUJbJHtzdHlsZVsxXX1tYFxuXHRcdFx0fTtcblxuXHRcdFx0Z3JvdXBbc3R5bGVOYW1lXSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG5cdFx0XHRjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTtcblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHtcblx0XHRcdHZhbHVlOiBncm91cCxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSk7XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCAnY29kZXMnLCB7XG5cdFx0dmFsdWU6IGNvZGVzLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdH0pO1xuXG5cdHN0eWxlcy5jb2xvci5jbG9zZSA9ICdcXHUwMDFCWzM5bSc7XG5cdHN0eWxlcy5iZ0NvbG9yLmNsb3NlID0gJ1xcdTAwMUJbNDltJztcblxuXHRzZXRMYXp5UHJvcGVydHkoc3R5bGVzLmNvbG9yLCAnYW5zaScsICgpID0+IG1ha2VEeW5hbWljU3R5bGVzKHdyYXBBbnNpMTYsICdhbnNpMTYnLCBhbnNpMmFuc2ksIGZhbHNlKSk7XG5cdHNldExhenlQcm9wZXJ0eShzdHlsZXMuY29sb3IsICdhbnNpMjU2JywgKCkgPT4gbWFrZUR5bmFtaWNTdHlsZXMod3JhcEFuc2kyNTYsICdhbnNpMjU2JywgYW5zaTJhbnNpLCBmYWxzZSkpO1xuXHRzZXRMYXp5UHJvcGVydHkoc3R5bGVzLmNvbG9yLCAnYW5zaTE2bScsICgpID0+IG1ha2VEeW5hbWljU3R5bGVzKHdyYXBBbnNpMTZtLCAncmdiJywgcmdiMnJnYiwgZmFsc2UpKTtcblx0c2V0TGF6eVByb3BlcnR5KHN0eWxlcy5iZ0NvbG9yLCAnYW5zaScsICgpID0+IG1ha2VEeW5hbWljU3R5bGVzKHdyYXBBbnNpMTYsICdhbnNpMTYnLCBhbnNpMmFuc2ksIHRydWUpKTtcblx0c2V0TGF6eVByb3BlcnR5KHN0eWxlcy5iZ0NvbG9yLCAnYW5zaTI1NicsICgpID0+IG1ha2VEeW5hbWljU3R5bGVzKHdyYXBBbnNpMjU2LCAnYW5zaTI1NicsIGFuc2kyYW5zaSwgdHJ1ZSkpO1xuXHRzZXRMYXp5UHJvcGVydHkoc3R5bGVzLmJnQ29sb3IsICdhbnNpMTZtJywgKCkgPT4gbWFrZUR5bmFtaWNTdHlsZXMod3JhcEFuc2kxNm0sICdyZ2InLCByZ2IycmdiLCB0cnVlKSk7XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuLy8gTWFrZSB0aGUgZXhwb3J0IGltbXV0YWJsZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgJ2V4cG9ydHMnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogYXNzZW1ibGVTdHlsZXNcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgYW5zaVN0eWxlcyA9IHJlcXVpcmUoJ2Fuc2ktc3R5bGVzJyk7XG5jb25zdCB7c3Rkb3V0OiBzdGRvdXRDb2xvciwgc3RkZXJyOiBzdGRlcnJDb2xvcn0gPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuY29uc3Qge1xuXHRzdHJpbmdSZXBsYWNlQWxsLFxuXHRzdHJpbmdFbmNhc2VDUkxGV2l0aEZpcnN0SW5kZXhcbn0gPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuY29uc3Qge2lzQXJyYXl9ID0gQXJyYXk7XG5cbi8vIGBzdXBwb3J0c0NvbG9yLmxldmVsYCDihpIgYGFuc2lTdHlsZXMuY29sb3JbbmFtZV1gIG1hcHBpbmdcbmNvbnN0IGxldmVsTWFwcGluZyA9IFtcblx0J2Fuc2knLFxuXHQnYW5zaScsXG5cdCdhbnNpMjU2Jyxcblx0J2Fuc2kxNm0nXG5dO1xuXG5jb25zdCBzdHlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5jb25zdCBhcHBseU9wdGlvbnMgPSAob2JqZWN0LCBvcHRpb25zID0ge30pID0+IHtcblx0aWYgKG9wdGlvbnMubGV2ZWwgJiYgIShOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubGV2ZWwpICYmIG9wdGlvbnMubGV2ZWwgPj0gMCAmJiBvcHRpb25zLmxldmVsIDw9IDMpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgYGxldmVsYCBvcHRpb24gc2hvdWxkIGJlIGFuIGludGVnZXIgZnJvbSAwIHRvIDMnKTtcblx0fVxuXG5cdC8vIERldGVjdCBsZXZlbCBpZiBub3Qgc2V0IG1hbnVhbGx5XG5cdGNvbnN0IGNvbG9yTGV2ZWwgPSBzdGRvdXRDb2xvciA/IHN0ZG91dENvbG9yLmxldmVsIDogMDtcblx0b2JqZWN0LmxldmVsID0gb3B0aW9ucy5sZXZlbCA9PT0gdW5kZWZpbmVkID8gY29sb3JMZXZlbCA6IG9wdGlvbnMubGV2ZWw7XG59O1xuXG5jbGFzcyBDaGFsa0NsYXNzIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cblx0XHRyZXR1cm4gY2hhbGtGYWN0b3J5KG9wdGlvbnMpO1xuXHR9XG59XG5cbmNvbnN0IGNoYWxrRmFjdG9yeSA9IG9wdGlvbnMgPT4ge1xuXHRjb25zdCBjaGFsayA9IHt9O1xuXHRhcHBseU9wdGlvbnMoY2hhbGssIG9wdGlvbnMpO1xuXG5cdGNoYWxrLnRlbXBsYXRlID0gKC4uLmFyZ3VtZW50c18pID0+IGNoYWxrVGFnKGNoYWxrLnRlbXBsYXRlLCAuLi5hcmd1bWVudHNfKTtcblxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoY2hhbGssIENoYWxrLnByb3RvdHlwZSk7XG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihjaGFsay50ZW1wbGF0ZSwgY2hhbGspO1xuXG5cdGNoYWxrLnRlbXBsYXRlLmNvbnN0cnVjdG9yID0gKCkgPT4ge1xuXHRcdHRocm93IG5ldyBFcnJvcignYGNoYWxrLmNvbnN0cnVjdG9yKClgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgbmV3IGNoYWxrLkluc3RhbmNlKClgIGluc3RlYWQuJyk7XG5cdH07XG5cblx0Y2hhbGsudGVtcGxhdGUuSW5zdGFuY2UgPSBDaGFsa0NsYXNzO1xuXG5cdHJldHVybiBjaGFsay50ZW1wbGF0ZTtcbn07XG5cbmZ1bmN0aW9uIENoYWxrKG9wdGlvbnMpIHtcblx0cmV0dXJuIGNoYWxrRmFjdG9yeShvcHRpb25zKTtcbn1cblxuZm9yIChjb25zdCBbc3R5bGVOYW1lLCBzdHlsZV0gb2YgT2JqZWN0LmVudHJpZXMoYW5zaVN0eWxlcykpIHtcblx0c3R5bGVzW3N0eWxlTmFtZV0gPSB7XG5cdFx0Z2V0KCkge1xuXHRcdFx0Y29uc3QgYnVpbGRlciA9IGNyZWF0ZUJ1aWxkZXIodGhpcywgY3JlYXRlU3R5bGVyKHN0eWxlLm9wZW4sIHN0eWxlLmNsb3NlLCB0aGlzLl9zdHlsZXIpLCB0aGlzLl9pc0VtcHR5KTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBzdHlsZU5hbWUsIHt2YWx1ZTogYnVpbGRlcn0pO1xuXHRcdFx0cmV0dXJuIGJ1aWxkZXI7XG5cdFx0fVxuXHR9O1xufVxuXG5zdHlsZXMudmlzaWJsZSA9IHtcblx0Z2V0KCkge1xuXHRcdGNvbnN0IGJ1aWxkZXIgPSBjcmVhdGVCdWlsZGVyKHRoaXMsIHRoaXMuX3N0eWxlciwgdHJ1ZSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd2aXNpYmxlJywge3ZhbHVlOiBidWlsZGVyfSk7XG5cdFx0cmV0dXJuIGJ1aWxkZXI7XG5cdH1cbn07XG5cbmNvbnN0IHVzZWRNb2RlbHMgPSBbJ3JnYicsICdoZXgnLCAna2V5d29yZCcsICdoc2wnLCAnaHN2JywgJ2h3YicsICdhbnNpJywgJ2Fuc2kyNTYnXTtcblxuZm9yIChjb25zdCBtb2RlbCBvZiB1c2VkTW9kZWxzKSB7XG5cdHN0eWxlc1ttb2RlbF0gPSB7XG5cdFx0Z2V0KCkge1xuXHRcdFx0Y29uc3Qge2xldmVsfSA9IHRoaXM7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3VtZW50c18pIHtcblx0XHRcdFx0Y29uc3Qgc3R5bGVyID0gY3JlYXRlU3R5bGVyKGFuc2lTdHlsZXMuY29sb3JbbGV2ZWxNYXBwaW5nW2xldmVsXV1bbW9kZWxdKC4uLmFyZ3VtZW50c18pLCBhbnNpU3R5bGVzLmNvbG9yLmNsb3NlLCB0aGlzLl9zdHlsZXIpO1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlQnVpbGRlcih0aGlzLCBzdHlsZXIsIHRoaXMuX2lzRW1wdHkpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH07XG59XG5cbmZvciAoY29uc3QgbW9kZWwgb2YgdXNlZE1vZGVscykge1xuXHRjb25zdCBiZ01vZGVsID0gJ2JnJyArIG1vZGVsWzBdLnRvVXBwZXJDYXNlKCkgKyBtb2RlbC5zbGljZSgxKTtcblx0c3R5bGVzW2JnTW9kZWxdID0ge1xuXHRcdGdldCgpIHtcblx0XHRcdGNvbnN0IHtsZXZlbH0gPSB0aGlzO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG5cdFx0XHRcdGNvbnN0IHN0eWxlciA9IGNyZWF0ZVN0eWxlcihhbnNpU3R5bGVzLmJnQ29sb3JbbGV2ZWxNYXBwaW5nW2xldmVsXV1bbW9kZWxdKC4uLmFyZ3VtZW50c18pLCBhbnNpU3R5bGVzLmJnQ29sb3IuY2xvc2UsIHRoaXMuX3N0eWxlcik7XG5cdFx0XHRcdHJldHVybiBjcmVhdGVCdWlsZGVyKHRoaXMsIHN0eWxlciwgdGhpcy5faXNFbXB0eSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcbn1cblxuY29uc3QgcHJvdG8gPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcygoKSA9PiB7fSwge1xuXHQuLi5zdHlsZXMsXG5cdGxldmVsOiB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZ2VuZXJhdG9yLmxldmVsO1xuXHRcdH0sXG5cdFx0c2V0KGxldmVsKSB7XG5cdFx0XHR0aGlzLl9nZW5lcmF0b3IubGV2ZWwgPSBsZXZlbDtcblx0XHR9XG5cdH1cbn0pO1xuXG5jb25zdCBjcmVhdGVTdHlsZXIgPSAob3BlbiwgY2xvc2UsIHBhcmVudCkgPT4ge1xuXHRsZXQgb3BlbkFsbDtcblx0bGV0IGNsb3NlQWxsO1xuXHRpZiAocGFyZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRvcGVuQWxsID0gb3Blbjtcblx0XHRjbG9zZUFsbCA9IGNsb3NlO1xuXHR9IGVsc2Uge1xuXHRcdG9wZW5BbGwgPSBwYXJlbnQub3BlbkFsbCArIG9wZW47XG5cdFx0Y2xvc2VBbGwgPSBjbG9zZSArIHBhcmVudC5jbG9zZUFsbDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0b3Blbixcblx0XHRjbG9zZSxcblx0XHRvcGVuQWxsLFxuXHRcdGNsb3NlQWxsLFxuXHRcdHBhcmVudFxuXHR9O1xufTtcblxuY29uc3QgY3JlYXRlQnVpbGRlciA9IChzZWxmLCBfc3R5bGVyLCBfaXNFbXB0eSkgPT4ge1xuXHRjb25zdCBidWlsZGVyID0gKC4uLmFyZ3VtZW50c18pID0+IHtcblx0XHRpZiAoaXNBcnJheShhcmd1bWVudHNfWzBdKSAmJiBpc0FycmF5KGFyZ3VtZW50c19bMF0ucmF3KSkge1xuXHRcdFx0Ly8gQ2FsbGVkIGFzIGEgdGVtcGxhdGUgbGl0ZXJhbCwgZm9yIGV4YW1wbGU6IGNoYWxrLnJlZGAyICsgMyA9IHtib2xkICR7MiszfX1gXG5cdFx0XHRyZXR1cm4gYXBwbHlTdHlsZShidWlsZGVyLCBjaGFsa1RhZyhidWlsZGVyLCAuLi5hcmd1bWVudHNfKSk7XG5cdFx0fVxuXG5cdFx0Ly8gU2luZ2xlIGFyZ3VtZW50IGlzIGhvdCBwYXRoLCBpbXBsaWNpdCBjb2VyY2lvbiBpcyBmYXN0ZXIgdGhhbiBhbnl0aGluZ1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbXBsaWNpdC1jb2VyY2lvblxuXHRcdHJldHVybiBhcHBseVN0eWxlKGJ1aWxkZXIsIChhcmd1bWVudHNfLmxlbmd0aCA9PT0gMSkgPyAoJycgKyBhcmd1bWVudHNfWzBdKSA6IGFyZ3VtZW50c18uam9pbignICcpKTtcblx0fTtcblxuXHQvLyBXZSBhbHRlciB0aGUgcHJvdG90eXBlIGJlY2F1c2Ugd2UgbXVzdCByZXR1cm4gYSBmdW5jdGlvbiwgYnV0IHRoZXJlIGlzXG5cdC8vIG5vIHdheSB0byBjcmVhdGUgYSBmdW5jdGlvbiB3aXRoIGEgZGlmZmVyZW50IHByb3RvdHlwZVxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVpbGRlciwgcHJvdG8pO1xuXG5cdGJ1aWxkZXIuX2dlbmVyYXRvciA9IHNlbGY7XG5cdGJ1aWxkZXIuX3N0eWxlciA9IF9zdHlsZXI7XG5cdGJ1aWxkZXIuX2lzRW1wdHkgPSBfaXNFbXB0eTtcblxuXHRyZXR1cm4gYnVpbGRlcjtcbn07XG5cbmNvbnN0IGFwcGx5U3R5bGUgPSAoc2VsZiwgc3RyaW5nKSA9PiB7XG5cdGlmIChzZWxmLmxldmVsIDw9IDAgfHwgIXN0cmluZykge1xuXHRcdHJldHVybiBzZWxmLl9pc0VtcHR5ID8gJycgOiBzdHJpbmc7XG5cdH1cblxuXHRsZXQgc3R5bGVyID0gc2VsZi5fc3R5bGVyO1xuXG5cdGlmIChzdHlsZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBzdHJpbmc7XG5cdH1cblxuXHRjb25zdCB7b3BlbkFsbCwgY2xvc2VBbGx9ID0gc3R5bGVyO1xuXHRpZiAoc3RyaW5nLmluZGV4T2YoJ1xcdTAwMUInKSAhPT0gLTEpIHtcblx0XHR3aGlsZSAoc3R5bGVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIFJlcGxhY2UgYW55IGluc3RhbmNlcyBhbHJlYWR5IHByZXNlbnQgd2l0aCBhIHJlLW9wZW5pbmcgY29kZVxuXHRcdFx0Ly8gb3RoZXJ3aXNlIG9ubHkgdGhlIHBhcnQgb2YgdGhlIHN0cmluZyB1bnRpbCBzYWlkIGNsb3NpbmcgY29kZVxuXHRcdFx0Ly8gd2lsbCBiZSBjb2xvcmVkLCBhbmQgdGhlIHJlc3Qgd2lsbCBzaW1wbHkgYmUgJ3BsYWluJy5cblx0XHRcdHN0cmluZyA9IHN0cmluZ1JlcGxhY2VBbGwoc3RyaW5nLCBzdHlsZXIuY2xvc2UsIHN0eWxlci5vcGVuKTtcblxuXHRcdFx0c3R5bGVyID0gc3R5bGVyLnBhcmVudDtcblx0XHR9XG5cdH1cblxuXHQvLyBXZSBjYW4gbW92ZSBib3RoIG5leHQgYWN0aW9ucyBvdXQgb2YgbG9vcCwgYmVjYXVzZSByZW1haW5pbmcgYWN0aW9ucyBpbiBsb29wIHdvbid0IGhhdmVcblx0Ly8gYW55L3Zpc2libGUgZWZmZWN0IG9uIHBhcnRzIHdlIGFkZCBoZXJlLiBDbG9zZSB0aGUgc3R5bGluZyBiZWZvcmUgYSBsaW5lYnJlYWsgYW5kIHJlb3BlblxuXHQvLyBhZnRlciBuZXh0IGxpbmUgdG8gZml4IGEgYmxlZWQgaXNzdWUgb24gbWFjT1M6IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFsay9jaGFsay9wdWxsLzkyXG5cdGNvbnN0IGxmSW5kZXggPSBzdHJpbmcuaW5kZXhPZignXFxuJyk7XG5cdGlmIChsZkluZGV4ICE9PSAtMSkge1xuXHRcdHN0cmluZyA9IHN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleChzdHJpbmcsIGNsb3NlQWxsLCBvcGVuQWxsLCBsZkluZGV4KTtcblx0fVxuXG5cdHJldHVybiBvcGVuQWxsICsgc3RyaW5nICsgY2xvc2VBbGw7XG59O1xuXG5sZXQgdGVtcGxhdGU7XG5jb25zdCBjaGFsa1RhZyA9IChjaGFsaywgLi4uc3RyaW5ncykgPT4ge1xuXHRjb25zdCBbZmlyc3RTdHJpbmddID0gc3RyaW5ncztcblxuXHRpZiAoIWlzQXJyYXkoZmlyc3RTdHJpbmcpIHx8ICFpc0FycmF5KGZpcnN0U3RyaW5nLnJhdykpIHtcblx0XHQvLyBJZiBjaGFsaygpIHdhcyBjYWxsZWQgYnkgaXRzZWxmIG9yIHdpdGggYSBzdHJpbmcsXG5cdFx0Ly8gcmV0dXJuIHRoZSBzdHJpbmcgaXRzZWxmIGFzIGEgc3RyaW5nLlxuXHRcdHJldHVybiBzdHJpbmdzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGNvbnN0IGFyZ3VtZW50c18gPSBzdHJpbmdzLnNsaWNlKDEpO1xuXHRjb25zdCBwYXJ0cyA9IFtmaXJzdFN0cmluZy5yYXdbMF1dO1xuXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgZmlyc3RTdHJpbmcubGVuZ3RoOyBpKyspIHtcblx0XHRwYXJ0cy5wdXNoKFxuXHRcdFx0U3RyaW5nKGFyZ3VtZW50c19baSAtIDFdKS5yZXBsYWNlKC9be31cXFxcXS9nLCAnXFxcXCQmJyksXG5cdFx0XHRTdHJpbmcoZmlyc3RTdHJpbmcucmF3W2ldKVxuXHRcdCk7XG5cdH1cblxuXHRpZiAodGVtcGxhdGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMnKTtcblx0fVxuXG5cdHJldHVybiB0ZW1wbGF0ZShjaGFsaywgcGFydHMuam9pbignJykpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2hhbGsucHJvdG90eXBlLCBzdHlsZXMpO1xuXG5jb25zdCBjaGFsayA9IENoYWxrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuY2hhbGsuc3VwcG9ydHNDb2xvciA9IHN0ZG91dENvbG9yO1xuY2hhbGsuc3RkZXJyID0gQ2hhbGsoe2xldmVsOiBzdGRlcnJDb2xvciA/IHN0ZGVyckNvbG9yLmxldmVsIDogMH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbmNoYWxrLnN0ZGVyci5zdXBwb3J0c0NvbG9yID0gc3RkZXJyQ29sb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gY2hhbGs7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBURU1QTEFURV9SRUdFWCA9IC8oPzpcXFxcKHUoPzpbYS1mXFxkXXs0fXxcXHtbYS1mXFxkXXsxLDZ9XFx9KXx4W2EtZlxcZF17Mn18LikpfCg/Olxceyh+KT8oXFx3Kyg/OlxcKFteKV0qXFwpKT8oPzpcXC5cXHcrKD86XFwoW14pXSpcXCkpPykqKSg/OlsgXFx0XXwoPz1cXHI/XFxuKSkpfChcXH0pfCgoPzoufFtcXHJcXG5cXGZdKSs/KS9naTtcbmNvbnN0IFNUWUxFX1JFR0VYID0gLyg/Ol58XFwuKShcXHcrKSg/OlxcKChbXildKilcXCkpPy9nO1xuY29uc3QgU1RSSU5HX1JFR0VYID0gL14oWydcIl0pKCg/OlxcXFwufCg/IVxcMSlbXlxcXFxdKSopXFwxJC87XG5jb25zdCBFU0NBUEVfUkVHRVggPSAvXFxcXCh1KD86W2EtZlxcZF17NH18e1thLWZcXGRdezEsNn19KXx4W2EtZlxcZF17Mn18Lil8KFteXFxcXF0pL2dpO1xuXG5jb25zdCBFU0NBUEVTID0gbmV3IE1hcChbXG5cdFsnbicsICdcXG4nXSxcblx0WydyJywgJ1xcciddLFxuXHRbJ3QnLCAnXFx0J10sXG5cdFsnYicsICdcXGInXSxcblx0WydmJywgJ1xcZiddLFxuXHRbJ3YnLCAnXFx2J10sXG5cdFsnMCcsICdcXDAnXSxcblx0WydcXFxcJywgJ1xcXFwnXSxcblx0WydlJywgJ1xcdTAwMUInXSxcblx0WydhJywgJ1xcdTAwMDcnXVxuXSk7XG5cbmZ1bmN0aW9uIHVuZXNjYXBlKGMpIHtcblx0Y29uc3QgdSA9IGNbMF0gPT09ICd1Jztcblx0Y29uc3QgYnJhY2tldCA9IGNbMV0gPT09ICd7JztcblxuXHRpZiAoKHUgJiYgIWJyYWNrZXQgJiYgYy5sZW5ndGggPT09IDUpIHx8IChjWzBdID09PSAneCcgJiYgYy5sZW5ndGggPT09IDMpKSB7XG5cdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYy5zbGljZSgxKSwgMTYpKTtcblx0fVxuXG5cdGlmICh1ICYmIGJyYWNrZXQpIHtcblx0XHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQoYy5zbGljZSgyLCAtMSksIDE2KSk7XG5cdH1cblxuXHRyZXR1cm4gRVNDQVBFUy5nZXQoYykgfHwgYztcbn1cblxuZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMobmFtZSwgYXJndW1lbnRzXykge1xuXHRjb25zdCByZXN1bHRzID0gW107XG5cdGNvbnN0IGNodW5rcyA9IGFyZ3VtZW50c18udHJpbSgpLnNwbGl0KC9cXHMqLFxccyovZyk7XG5cdGxldCBtYXRjaGVzO1xuXG5cdGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG5cdFx0Y29uc3QgbnVtYmVyID0gTnVtYmVyKGNodW5rKTtcblx0XHRpZiAoIU51bWJlci5pc05hTihudW1iZXIpKSB7XG5cdFx0XHRyZXN1bHRzLnB1c2gobnVtYmVyKTtcblx0XHR9IGVsc2UgaWYgKChtYXRjaGVzID0gY2h1bmsubWF0Y2goU1RSSU5HX1JFR0VYKSkpIHtcblx0XHRcdHJlc3VsdHMucHVzaChtYXRjaGVzWzJdLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCAobSwgZXNjYXBlLCBjaGFyYWN0ZXIpID0+IGVzY2FwZSA/IHVuZXNjYXBlKGVzY2FwZSkgOiBjaGFyYWN0ZXIpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIENoYWxrIHRlbXBsYXRlIHN0eWxlIGFyZ3VtZW50OiAke2NodW5rfSAoaW4gc3R5bGUgJyR7bmFtZX0nKWApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0eWxlKHN0eWxlKSB7XG5cdFNUWUxFX1JFR0VYLmxhc3RJbmRleCA9IDA7XG5cblx0Y29uc3QgcmVzdWx0cyA9IFtdO1xuXHRsZXQgbWF0Y2hlcztcblxuXHR3aGlsZSAoKG1hdGNoZXMgPSBTVFlMRV9SRUdFWC5leGVjKHN0eWxlKSkgIT09IG51bGwpIHtcblx0XHRjb25zdCBuYW1lID0gbWF0Y2hlc1sxXTtcblxuXHRcdGlmIChtYXRjaGVzWzJdKSB7XG5cdFx0XHRjb25zdCBhcmdzID0gcGFyc2VBcmd1bWVudHMobmFtZSwgbWF0Y2hlc1syXSk7XG5cdFx0XHRyZXN1bHRzLnB1c2goW25hbWVdLmNvbmNhdChhcmdzKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdHMucHVzaChbbmFtZV0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBidWlsZFN0eWxlKGNoYWxrLCBzdHlsZXMpIHtcblx0Y29uc3QgZW5hYmxlZCA9IHt9O1xuXG5cdGZvciAoY29uc3QgbGF5ZXIgb2Ygc3R5bGVzKSB7XG5cdFx0Zm9yIChjb25zdCBzdHlsZSBvZiBsYXllci5zdHlsZXMpIHtcblx0XHRcdGVuYWJsZWRbc3R5bGVbMF1dID0gbGF5ZXIuaW52ZXJzZSA/IG51bGwgOiBzdHlsZS5zbGljZSgxKTtcblx0XHR9XG5cdH1cblxuXHRsZXQgY3VycmVudCA9IGNoYWxrO1xuXHRmb3IgKGNvbnN0IFtzdHlsZU5hbWUsIHN0eWxlc10gb2YgT2JqZWN0LmVudHJpZXMoZW5hYmxlZCkpIHtcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKCEoc3R5bGVOYW1lIGluIGN1cnJlbnQpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gQ2hhbGsgc3R5bGU6ICR7c3R5bGVOYW1lfWApO1xuXHRcdH1cblxuXHRcdGN1cnJlbnQgPSBzdHlsZXMubGVuZ3RoID4gMCA/IGN1cnJlbnRbc3R5bGVOYW1lXSguLi5zdHlsZXMpIDogY3VycmVudFtzdHlsZU5hbWVdO1xuXHR9XG5cblx0cmV0dXJuIGN1cnJlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKGNoYWxrLCB0ZW1wb3JhcnkpID0+IHtcblx0Y29uc3Qgc3R5bGVzID0gW107XG5cdGNvbnN0IGNodW5rcyA9IFtdO1xuXHRsZXQgY2h1bmsgPSBbXTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuXHR0ZW1wb3JhcnkucmVwbGFjZShURU1QTEFURV9SRUdFWCwgKG0sIGVzY2FwZUNoYXJhY3RlciwgaW52ZXJzZSwgc3R5bGUsIGNsb3NlLCBjaGFyYWN0ZXIpID0+IHtcblx0XHRpZiAoZXNjYXBlQ2hhcmFjdGVyKSB7XG5cdFx0XHRjaHVuay5wdXNoKHVuZXNjYXBlKGVzY2FwZUNoYXJhY3RlcikpO1xuXHRcdH0gZWxzZSBpZiAoc3R5bGUpIHtcblx0XHRcdGNvbnN0IHN0cmluZyA9IGNodW5rLmpvaW4oJycpO1xuXHRcdFx0Y2h1bmsgPSBbXTtcblx0XHRcdGNodW5rcy5wdXNoKHN0eWxlcy5sZW5ndGggPT09IDAgPyBzdHJpbmcgOiBidWlsZFN0eWxlKGNoYWxrLCBzdHlsZXMpKHN0cmluZykpO1xuXHRcdFx0c3R5bGVzLnB1c2goe2ludmVyc2UsIHN0eWxlczogcGFyc2VTdHlsZShzdHlsZSl9KTtcblx0XHR9IGVsc2UgaWYgKGNsb3NlKSB7XG5cdFx0XHRpZiAoc3R5bGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGV4dHJhbmVvdXMgfSBpbiBDaGFsayB0ZW1wbGF0ZSBsaXRlcmFsJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNodW5rcy5wdXNoKGJ1aWxkU3R5bGUoY2hhbGssIHN0eWxlcykoY2h1bmsuam9pbignJykpKTtcblx0XHRcdGNodW5rID0gW107XG5cdFx0XHRzdHlsZXMucG9wKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNodW5rLnB1c2goY2hhcmFjdGVyKTtcblx0XHR9XG5cdH0pO1xuXG5cdGNodW5rcy5wdXNoKGNodW5rLmpvaW4oJycpKTtcblxuXHRpZiAoc3R5bGVzLmxlbmd0aCA+IDApIHtcblx0XHRjb25zdCBlcnJNZXNzYWdlID0gYENoYWxrIHRlbXBsYXRlIGxpdGVyYWwgaXMgbWlzc2luZyAke3N0eWxlcy5sZW5ndGh9IGNsb3NpbmcgYnJhY2tldCR7c3R5bGVzLmxlbmd0aCA9PT0gMSA/ICcnIDogJ3MnfSAoXFxgfVxcYClgO1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnJNZXNzYWdlKTtcblx0fVxuXG5cdHJldHVybiBjaHVua3Muam9pbignJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzdHJpbmdSZXBsYWNlQWxsID0gKHN0cmluZywgc3Vic3RyaW5nLCByZXBsYWNlcikgPT4ge1xuXHRsZXQgaW5kZXggPSBzdHJpbmcuaW5kZXhPZihzdWJzdHJpbmcpO1xuXHRpZiAoaW5kZXggPT09IC0xKSB7XG5cdFx0cmV0dXJuIHN0cmluZztcblx0fVxuXG5cdGNvbnN0IHN1YnN0cmluZ0xlbmd0aCA9IHN1YnN0cmluZy5sZW5ndGg7XG5cdGxldCBlbmRJbmRleCA9IDA7XG5cdGxldCByZXR1cm5WYWx1ZSA9ICcnO1xuXHRkbyB7XG5cdFx0cmV0dXJuVmFsdWUgKz0gc3RyaW5nLnN1YnN0cihlbmRJbmRleCwgaW5kZXggLSBlbmRJbmRleCkgKyBzdWJzdHJpbmcgKyByZXBsYWNlcjtcblx0XHRlbmRJbmRleCA9IGluZGV4ICsgc3Vic3RyaW5nTGVuZ3RoO1xuXHRcdGluZGV4ID0gc3RyaW5nLmluZGV4T2Yoc3Vic3RyaW5nLCBlbmRJbmRleCk7XG5cdH0gd2hpbGUgKGluZGV4ICE9PSAtMSk7XG5cblx0cmV0dXJuVmFsdWUgKz0gc3RyaW5nLnN1YnN0cihlbmRJbmRleCk7XG5cdHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG5cbmNvbnN0IHN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleCA9IChzdHJpbmcsIHByZWZpeCwgcG9zdGZpeCwgaW5kZXgpID0+IHtcblx0bGV0IGVuZEluZGV4ID0gMDtcblx0bGV0IHJldHVyblZhbHVlID0gJyc7XG5cdGRvIHtcblx0XHRjb25zdCBnb3RDUiA9IHN0cmluZ1tpbmRleCAtIDFdID09PSAnXFxyJztcblx0XHRyZXR1cm5WYWx1ZSArPSBzdHJpbmcuc3Vic3RyKGVuZEluZGV4LCAoZ290Q1IgPyBpbmRleCAtIDEgOiBpbmRleCkgLSBlbmRJbmRleCkgKyBwcmVmaXggKyAoZ290Q1IgPyAnXFxyXFxuJyA6ICdcXG4nKSArIHBvc3RmaXg7XG5cdFx0ZW5kSW5kZXggPSBpbmRleCArIDE7XG5cdFx0aW5kZXggPSBzdHJpbmcuaW5kZXhPZignXFxuJywgZW5kSW5kZXgpO1xuXHR9IHdoaWxlIChpbmRleCAhPT0gLTEpO1xuXG5cdHJldHVyblZhbHVlICs9IHN0cmluZy5zdWJzdHIoZW5kSW5kZXgpO1xuXHRyZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0c3RyaW5nUmVwbGFjZUFsbCxcblx0c3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4XG59O1xuIiwiLyogTUlUIGxpY2Vuc2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLW1peGVkLW9wZXJhdG9ycyAqL1xuY29uc3QgY3NzS2V5d29yZHMgPSByZXF1aXJlKCdjb2xvci1uYW1lJyk7XG5cbi8vIE5PVEU6IGNvbnZlcnNpb25zIHNob3VsZCBvbmx5IHJldHVybiBwcmltaXRpdmUgdmFsdWVzIChpLmUuIGFycmF5cywgb3Jcbi8vICAgICAgIHZhbHVlcyB0aGF0IGdpdmUgY29ycmVjdCBgdHlwZW9mYCByZXN1bHRzKS5cbi8vICAgICAgIGRvIG5vdCB1c2UgYm94IHZhbHVlcyB0eXBlcyAoaS5lLiBOdW1iZXIoKSwgU3RyaW5nKCksIGV0Yy4pXG5cbmNvbnN0IHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY3NzS2V5d29yZHMpKSB7XG5cdHJldmVyc2VLZXl3b3Jkc1tjc3NLZXl3b3Jkc1trZXldXSA9IGtleTtcbn1cblxuY29uc3QgY29udmVydCA9IHtcblx0cmdiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ3JnYid9LFxuXHRoc2w6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHNsJ30sXG5cdGhzdjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdoc3YnfSxcblx0aHdiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2h3Yid9LFxuXHRjbXlrOiB7Y2hhbm5lbHM6IDQsIGxhYmVsczogJ2NteWsnfSxcblx0eHl6OiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ3h5eid9LFxuXHRsYWI6IHtjaGFubmVsczogMywgbGFiZWxzOiAnbGFiJ30sXG5cdGxjaDoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdsY2gnfSxcblx0aGV4OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydoZXgnXX0sXG5cdGtleXdvcmQ6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2tleXdvcmQnXX0sXG5cdGFuc2kxNjoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnYW5zaTE2J119LFxuXHRhbnNpMjU2OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydhbnNpMjU2J119LFxuXHRoY2c6IHtjaGFubmVsczogMywgbGFiZWxzOiBbJ2gnLCAnYycsICdnJ119LFxuXHRhcHBsZToge2NoYW5uZWxzOiAzLCBsYWJlbHM6IFsncjE2JywgJ2cxNicsICdiMTYnXX0sXG5cdGdyYXk6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2dyYXknXX1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydDtcblxuLy8gSGlkZSAuY2hhbm5lbHMgYW5kIC5sYWJlbHMgcHJvcGVydGllc1xuZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3Qua2V5cyhjb252ZXJ0KSkge1xuXHRpZiAoISgnY2hhbm5lbHMnIGluIGNvbnZlcnRbbW9kZWxdKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjaGFubmVscyBwcm9wZXJ0eTogJyArIG1vZGVsKTtcblx0fVxuXG5cdGlmICghKCdsYWJlbHMnIGluIGNvbnZlcnRbbW9kZWxdKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjaGFubmVsIGxhYmVscyBwcm9wZXJ0eTogJyArIG1vZGVsKTtcblx0fVxuXG5cdGlmIChjb252ZXJ0W21vZGVsXS5sYWJlbHMubGVuZ3RoICE9PSBjb252ZXJ0W21vZGVsXS5jaGFubmVscykge1xuXHRcdHRocm93IG5ldyBFcnJvcignY2hhbm5lbCBhbmQgbGFiZWwgY291bnRzIG1pc21hdGNoOiAnICsgbW9kZWwpO1xuXHR9XG5cblx0Y29uc3Qge2NoYW5uZWxzLCBsYWJlbHN9ID0gY29udmVydFttb2RlbF07XG5cdGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5jaGFubmVscztcblx0ZGVsZXRlIGNvbnZlcnRbbW9kZWxdLmxhYmVscztcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCAnY2hhbm5lbHMnLCB7dmFsdWU6IGNoYW5uZWxzfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W21vZGVsXSwgJ2xhYmVscycsIHt2YWx1ZTogbGFiZWxzfSk7XG59XG5cbmNvbnZlcnQucmdiLmhzbCA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0Y29uc3QgciA9IHJnYlswXSAvIDI1NTtcblx0Y29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcblx0Y29uc3QgYiA9IHJnYlsyXSAvIDI1NTtcblx0Y29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG5cdGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHRjb25zdCBkZWx0YSA9IG1heCAtIG1pbjtcblx0bGV0IGg7XG5cdGxldCBzO1xuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdGggPSAwO1xuXHR9IGVsc2UgaWYgKHIgPT09IG1heCkge1xuXHRcdGggPSAoZyAtIGIpIC8gZGVsdGE7XG5cdH0gZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG5cdFx0aCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG5cdH0gZWxzZSBpZiAoYiA9PT0gbWF4KSB7XG5cdFx0aCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cdH1cblxuXHRoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG5cdGlmIChoIDwgMCkge1xuXHRcdGggKz0gMzYwO1xuXHR9XG5cblx0Y29uc3QgbCA9IChtaW4gKyBtYXgpIC8gMjtcblxuXHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRzID0gMDtcblx0fSBlbHNlIGlmIChsIDw9IDAuNSkge1xuXHRcdHMgPSBkZWx0YSAvIChtYXggKyBtaW4pO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblx0fVxuXG5cdHJldHVybiBbaCwgcyAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG5jb252ZXJ0LnJnYi5oc3YgPSBmdW5jdGlvbiAocmdiKSB7XG5cdGxldCByZGlmO1xuXHRsZXQgZ2RpZjtcblx0bGV0IGJkaWY7XG5cdGxldCBoO1xuXHRsZXQgcztcblxuXHRjb25zdCByID0gcmdiWzBdIC8gMjU1O1xuXHRjb25zdCBnID0gcmdiWzFdIC8gMjU1O1xuXHRjb25zdCBiID0gcmdiWzJdIC8gMjU1O1xuXHRjb25zdCB2ID0gTWF0aC5tYXgociwgZywgYik7XG5cdGNvbnN0IGRpZmYgPSB2IC0gTWF0aC5taW4ociwgZywgYik7XG5cdGNvbnN0IGRpZmZjID0gZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gKHYgLSBjKSAvIDYgLyBkaWZmICsgMSAvIDI7XG5cdH07XG5cblx0aWYgKGRpZmYgPT09IDApIHtcblx0XHRoID0gMDtcblx0XHRzID0gMDtcblx0fSBlbHNlIHtcblx0XHRzID0gZGlmZiAvIHY7XG5cdFx0cmRpZiA9IGRpZmZjKHIpO1xuXHRcdGdkaWYgPSBkaWZmYyhnKTtcblx0XHRiZGlmID0gZGlmZmMoYik7XG5cblx0XHRpZiAociA9PT0gdikge1xuXHRcdFx0aCA9IGJkaWYgLSBnZGlmO1xuXHRcdH0gZWxzZSBpZiAoZyA9PT0gdikge1xuXHRcdFx0aCA9ICgxIC8gMykgKyByZGlmIC0gYmRpZjtcblx0XHR9IGVsc2UgaWYgKGIgPT09IHYpIHtcblx0XHRcdGggPSAoMiAvIDMpICsgZ2RpZiAtIHJkaWY7XG5cdFx0fVxuXG5cdFx0aWYgKGggPCAwKSB7XG5cdFx0XHRoICs9IDE7XG5cdFx0fSBlbHNlIGlmIChoID4gMSkge1xuXHRcdFx0aCAtPSAxO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBbXG5cdFx0aCAqIDM2MCxcblx0XHRzICogMTAwLFxuXHRcdHYgKiAxMDBcblx0XTtcbn07XG5cbmNvbnZlcnQucmdiLmh3YiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0Y29uc3QgciA9IHJnYlswXTtcblx0Y29uc3QgZyA9IHJnYlsxXTtcblx0bGV0IGIgPSByZ2JbMl07XG5cdGNvbnN0IGggPSBjb252ZXJ0LnJnYi5oc2wocmdiKVswXTtcblx0Y29uc3QgdyA9IDEgLyAyNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSk7XG5cblx0YiA9IDEgLSAxIC8gMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG5cdHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LnJnYi5jbXlrID0gZnVuY3Rpb24gKHJnYikge1xuXHRjb25zdCByID0gcmdiWzBdIC8gMjU1O1xuXHRjb25zdCBnID0gcmdiWzFdIC8gMjU1O1xuXHRjb25zdCBiID0gcmdiWzJdIC8gMjU1O1xuXG5cdGNvbnN0IGsgPSBNYXRoLm1pbigxIC0gciwgMSAtIGcsIDEgLSBiKTtcblx0Y29uc3QgYyA9ICgxIC0gciAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXHRjb25zdCBtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cdGNvbnN0IHkgPSAoMSAtIGIgLSBrKSAvICgxIC0gaykgfHwgMDtcblxuXHRyZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xufTtcblxuZnVuY3Rpb24gY29tcGFyYXRpdmVEaXN0YW5jZSh4LCB5KSB7XG5cdC8qXG5cdFx0U2VlIGh0dHBzOi8vZW4ubS53aWtpcGVkaWEub3JnL3dpa2kvRXVjbGlkZWFuX2Rpc3RhbmNlI1NxdWFyZWRfRXVjbGlkZWFuX2Rpc3RhbmNlXG5cdCovXG5cdHJldHVybiAoXG5cdFx0KCh4WzBdIC0geVswXSkgKiogMikgK1xuXHRcdCgoeFsxXSAtIHlbMV0pICoqIDIpICtcblx0XHQoKHhbMl0gLSB5WzJdKSAqKiAyKVxuXHQpO1xufVxuXG5jb252ZXJ0LnJnYi5rZXl3b3JkID0gZnVuY3Rpb24gKHJnYikge1xuXHRjb25zdCByZXZlcnNlZCA9IHJldmVyc2VLZXl3b3Jkc1tyZ2JdO1xuXHRpZiAocmV2ZXJzZWQpIHtcblx0XHRyZXR1cm4gcmV2ZXJzZWQ7XG5cdH1cblxuXHRsZXQgY3VycmVudENsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXHRsZXQgY3VycmVudENsb3Nlc3RLZXl3b3JkO1xuXG5cdGZvciAoY29uc3Qga2V5d29yZCBvZiBPYmplY3Qua2V5cyhjc3NLZXl3b3JkcykpIHtcblx0XHRjb25zdCB2YWx1ZSA9IGNzc0tleXdvcmRzW2tleXdvcmRdO1xuXG5cdFx0Ly8gQ29tcHV0ZSBjb21wYXJhdGl2ZSBkaXN0YW5jZVxuXHRcdGNvbnN0IGRpc3RhbmNlID0gY29tcGFyYXRpdmVEaXN0YW5jZShyZ2IsIHZhbHVlKTtcblxuXHRcdC8vIENoZWNrIGlmIGl0cyBsZXNzLCBpZiBzbyBzZXQgYXMgY2xvc2VzdFxuXHRcdGlmIChkaXN0YW5jZSA8IGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UpIHtcblx0XHRcdGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHRcdGN1cnJlbnRDbG9zZXN0S2V5d29yZCA9IGtleXdvcmQ7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcbn07XG5cbmNvbnZlcnQua2V5d29yZC5yZ2IgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xuXHRyZXR1cm4gY3NzS2V5d29yZHNba2V5d29yZF07XG59O1xuXG5jb252ZXJ0LnJnYi54eXogPSBmdW5jdGlvbiAocmdiKSB7XG5cdGxldCByID0gcmdiWzBdIC8gMjU1O1xuXHRsZXQgZyA9IHJnYlsxXSAvIDI1NTtcblx0bGV0IGIgPSByZ2JbMl0gLyAyNTU7XG5cblx0Ly8gQXNzdW1lIHNSR0Jcblx0ciA9IHIgPiAwLjA0MDQ1ID8gKCgociArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQpIDogKHIgLyAxMi45Mik7XG5cdGcgPSBnID4gMC4wNDA0NSA/ICgoKGcgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40KSA6IChnIC8gMTIuOTIpO1xuXHRiID0gYiA+IDAuMDQwNDUgPyAoKChiICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCkgOiAoYiAvIDEyLjkyKTtcblxuXHRjb25zdCB4ID0gKHIgKiAwLjQxMjQpICsgKGcgKiAwLjM1NzYpICsgKGIgKiAwLjE4MDUpO1xuXHRjb25zdCB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuXHRjb25zdCB6ID0gKHIgKiAwLjAxOTMpICsgKGcgKiAwLjExOTIpICsgKGIgKiAwLjk1MDUpO1xuXG5cdHJldHVybiBbeCAqIDEwMCwgeSAqIDEwMCwgeiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LnJnYi5sYWIgPSBmdW5jdGlvbiAocmdiKSB7XG5cdGNvbnN0IHh5eiA9IGNvbnZlcnQucmdiLnh5eihyZ2IpO1xuXHRsZXQgeCA9IHh5elswXTtcblx0bGV0IHkgPSB4eXpbMV07XG5cdGxldCB6ID0geHl6WzJdO1xuXG5cdHggLz0gOTUuMDQ3O1xuXHR5IC89IDEwMDtcblx0eiAvPSAxMDguODgzO1xuXG5cdHggPSB4ID4gMC4wMDg4NTYgPyAoeCAqKiAoMSAvIDMpKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcblx0eSA9IHkgPiAwLjAwODg1NiA/ICh5ICoqICgxIC8gMykpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuXHR6ID0geiA+IDAuMDA4ODU2ID8gKHogKiogKDEgLyAzKSkgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cblx0Y29uc3QgbCA9ICgxMTYgKiB5KSAtIDE2O1xuXHRjb25zdCBhID0gNTAwICogKHggLSB5KTtcblx0Y29uc3QgYiA9IDIwMCAqICh5IC0geik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQuaHNsLnJnYiA9IGZ1bmN0aW9uIChoc2wpIHtcblx0Y29uc3QgaCA9IGhzbFswXSAvIDM2MDtcblx0Y29uc3QgcyA9IGhzbFsxXSAvIDEwMDtcblx0Y29uc3QgbCA9IGhzbFsyXSAvIDEwMDtcblx0bGV0IHQyO1xuXHRsZXQgdDM7XG5cdGxldCB2YWw7XG5cblx0aWYgKHMgPT09IDApIHtcblx0XHR2YWwgPSBsICogMjU1O1xuXHRcdHJldHVybiBbdmFsLCB2YWwsIHZhbF07XG5cdH1cblxuXHRpZiAobCA8IDAuNSkge1xuXHRcdHQyID0gbCAqICgxICsgcyk7XG5cdH0gZWxzZSB7XG5cdFx0dDIgPSBsICsgcyAtIGwgKiBzO1xuXHR9XG5cblx0Y29uc3QgdDEgPSAyICogbCAtIHQyO1xuXG5cdGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHR0MyA9IGggKyAxIC8gMyAqIC0oaSAtIDEpO1xuXHRcdGlmICh0MyA8IDApIHtcblx0XHRcdHQzKys7XG5cdFx0fVxuXG5cdFx0aWYgKHQzID4gMSkge1xuXHRcdFx0dDMtLTtcblx0XHR9XG5cblx0XHRpZiAoNiAqIHQzIDwgMSkge1xuXHRcdFx0dmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG5cdFx0fSBlbHNlIGlmICgyICogdDMgPCAxKSB7XG5cdFx0XHR2YWwgPSB0Mjtcblx0XHR9IGVsc2UgaWYgKDMgKiB0MyA8IDIpIHtcblx0XHRcdHZhbCA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsID0gdDE7XG5cdFx0fVxuXG5cdFx0cmdiW2ldID0gdmFsICogMjU1O1xuXHR9XG5cblx0cmV0dXJuIHJnYjtcbn07XG5cbmNvbnZlcnQuaHNsLmhzdiA9IGZ1bmN0aW9uIChoc2wpIHtcblx0Y29uc3QgaCA9IGhzbFswXTtcblx0bGV0IHMgPSBoc2xbMV0gLyAxMDA7XG5cdGxldCBsID0gaHNsWzJdIC8gMTAwO1xuXHRsZXQgc21pbiA9IHM7XG5cdGNvbnN0IGxtaW4gPSBNYXRoLm1heChsLCAwLjAxKTtcblxuXHRsICo9IDI7XG5cdHMgKj0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG5cdHNtaW4gKj0gbG1pbiA8PSAxID8gbG1pbiA6IDIgLSBsbWluO1xuXHRjb25zdCB2ID0gKGwgKyBzKSAvIDI7XG5cdGNvbnN0IHN2ID0gbCA9PT0gMCA/ICgyICogc21pbikgLyAobG1pbiArIHNtaW4pIDogKDIgKiBzKSAvIChsICsgcyk7XG5cblx0cmV0dXJuIFtoLCBzdiAqIDEwMCwgdiAqIDEwMF07XG59O1xuXG5jb252ZXJ0Lmhzdi5yZ2IgPSBmdW5jdGlvbiAoaHN2KSB7XG5cdGNvbnN0IGggPSBoc3ZbMF0gLyA2MDtcblx0Y29uc3QgcyA9IGhzdlsxXSAvIDEwMDtcblx0bGV0IHYgPSBoc3ZbMl0gLyAxMDA7XG5cdGNvbnN0IGhpID0gTWF0aC5mbG9vcihoKSAlIDY7XG5cblx0Y29uc3QgZiA9IGggLSBNYXRoLmZsb29yKGgpO1xuXHRjb25zdCBwID0gMjU1ICogdiAqICgxIC0gcyk7XG5cdGNvbnN0IHEgPSAyNTUgKiB2ICogKDEgLSAocyAqIGYpKTtcblx0Y29uc3QgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpO1xuXHR2ICo9IDI1NTtcblxuXHRzd2l0Y2ggKGhpKSB7XG5cdFx0Y2FzZSAwOlxuXHRcdFx0cmV0dXJuIFt2LCB0LCBwXTtcblx0XHRjYXNlIDE6XG5cdFx0XHRyZXR1cm4gW3EsIHYsIHBdO1xuXHRcdGNhc2UgMjpcblx0XHRcdHJldHVybiBbcCwgdiwgdF07XG5cdFx0Y2FzZSAzOlxuXHRcdFx0cmV0dXJuIFtwLCBxLCB2XTtcblx0XHRjYXNlIDQ6XG5cdFx0XHRyZXR1cm4gW3QsIHAsIHZdO1xuXHRcdGNhc2UgNTpcblx0XHRcdHJldHVybiBbdiwgcCwgcV07XG5cdH1cbn07XG5cbmNvbnZlcnQuaHN2LmhzbCA9IGZ1bmN0aW9uIChoc3YpIHtcblx0Y29uc3QgaCA9IGhzdlswXTtcblx0Y29uc3QgcyA9IGhzdlsxXSAvIDEwMDtcblx0Y29uc3QgdiA9IGhzdlsyXSAvIDEwMDtcblx0Y29uc3Qgdm1pbiA9IE1hdGgubWF4KHYsIDAuMDEpO1xuXHRsZXQgc2w7XG5cdGxldCBsO1xuXG5cdGwgPSAoMiAtIHMpICogdjtcblx0Y29uc3QgbG1pbiA9ICgyIC0gcykgKiB2bWluO1xuXHRzbCA9IHMgKiB2bWluO1xuXHRzbCAvPSAobG1pbiA8PSAxKSA/IGxtaW4gOiAyIC0gbG1pbjtcblx0c2wgPSBzbCB8fCAwO1xuXHRsIC89IDI7XG5cblx0cmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG4vLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MtY29sb3IvI2h3Yi10by1yZ2JcbmNvbnZlcnQuaHdiLnJnYiA9IGZ1bmN0aW9uIChod2IpIHtcblx0Y29uc3QgaCA9IGh3YlswXSAvIDM2MDtcblx0bGV0IHdoID0gaHdiWzFdIC8gMTAwO1xuXHRsZXQgYmwgPSBod2JbMl0gLyAxMDA7XG5cdGNvbnN0IHJhdGlvID0gd2ggKyBibDtcblx0bGV0IGY7XG5cblx0Ly8gV2ggKyBibCBjYW50IGJlID4gMVxuXHRpZiAocmF0aW8gPiAxKSB7XG5cdFx0d2ggLz0gcmF0aW87XG5cdFx0YmwgLz0gcmF0aW87XG5cdH1cblxuXHRjb25zdCBpID0gTWF0aC5mbG9vcig2ICogaCk7XG5cdGNvbnN0IHYgPSAxIC0gYmw7XG5cdGYgPSA2ICogaCAtIGk7XG5cblx0aWYgKChpICYgMHgwMSkgIT09IDApIHtcblx0XHRmID0gMSAtIGY7XG5cdH1cblxuXHRjb25zdCBuID0gd2ggKyBmICogKHYgLSB3aCk7IC8vIExpbmVhciBpbnRlcnBvbGF0aW9uXG5cblx0bGV0IHI7XG5cdGxldCBnO1xuXHRsZXQgYjtcblx0LyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMtcGVyLWxpbmUsbm8tbXVsdGktc3BhY2VzICovXG5cdHN3aXRjaCAoaSkge1xuXHRcdGRlZmF1bHQ6XG5cdFx0Y2FzZSA2OlxuXHRcdGNhc2UgMDogciA9IHY7ICBnID0gbjsgIGIgPSB3aDsgYnJlYWs7XG5cdFx0Y2FzZSAxOiByID0gbjsgIGcgPSB2OyAgYiA9IHdoOyBicmVhaztcblx0XHRjYXNlIDI6IHIgPSB3aDsgZyA9IHY7ICBiID0gbjsgYnJlYWs7XG5cdFx0Y2FzZSAzOiByID0gd2g7IGcgPSBuOyAgYiA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgNDogciA9IG47ICBnID0gd2g7IGIgPSB2OyBicmVhaztcblx0XHRjYXNlIDU6IHIgPSB2OyAgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG5cdH1cblx0LyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cy1wZXItbGluZSxuby1tdWx0aS1zcGFjZXMgKi9cblxuXHRyZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29udmVydC5jbXlrLnJnYiA9IGZ1bmN0aW9uIChjbXlrKSB7XG5cdGNvbnN0IGMgPSBjbXlrWzBdIC8gMTAwO1xuXHRjb25zdCBtID0gY215a1sxXSAvIDEwMDtcblx0Y29uc3QgeSA9IGNteWtbMl0gLyAxMDA7XG5cdGNvbnN0IGsgPSBjbXlrWzNdIC8gMTAwO1xuXG5cdGNvbnN0IHIgPSAxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKTtcblx0Y29uc3QgZyA9IDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspO1xuXHRjb25zdCBiID0gMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgayk7XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQueHl6LnJnYiA9IGZ1bmN0aW9uICh4eXopIHtcblx0Y29uc3QgeCA9IHh5elswXSAvIDEwMDtcblx0Y29uc3QgeSA9IHh5elsxXSAvIDEwMDtcblx0Y29uc3QgeiA9IHh5elsyXSAvIDEwMDtcblx0bGV0IHI7XG5cdGxldCBnO1xuXHRsZXQgYjtcblxuXHRyID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG5cdGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuXHRiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuXHQvLyBBc3N1bWUgc1JHQlxuXHRyID0gciA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIChyICoqICgxLjAgLyAyLjQpKSkgLSAwLjA1NSlcblx0XHQ6IHIgKiAxMi45MjtcblxuXHRnID0gZyA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIChnICoqICgxLjAgLyAyLjQpKSkgLSAwLjA1NSlcblx0XHQ6IGcgKiAxMi45MjtcblxuXHRiID0gYiA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIChiICoqICgxLjAgLyAyLjQpKSkgLSAwLjA1NSlcblx0XHQ6IGIgKiAxMi45MjtcblxuXHRyID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuXHRnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuXHRiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0Lnh5ei5sYWIgPSBmdW5jdGlvbiAoeHl6KSB7XG5cdGxldCB4ID0geHl6WzBdO1xuXHRsZXQgeSA9IHh5elsxXTtcblx0bGV0IHogPSB4eXpbMl07XG5cblx0eCAvPSA5NS4wNDc7XG5cdHkgLz0gMTAwO1xuXHR6IC89IDEwOC44ODM7XG5cblx0eCA9IHggPiAwLjAwODg1NiA/ICh4ICoqICgxIC8gMykpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuXHR5ID0geSA+IDAuMDA4ODU2ID8gKHkgKiogKDEgLyAzKSkgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG5cdHogPSB6ID4gMC4wMDg4NTYgPyAoeiAqKiAoMSAvIDMpKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuXHRjb25zdCBsID0gKDExNiAqIHkpIC0gMTY7XG5cdGNvbnN0IGEgPSA1MDAgKiAoeCAtIHkpO1xuXHRjb25zdCBiID0gMjAwICogKHkgLSB6KTtcblxuXHRyZXR1cm4gW2wsIGEsIGJdO1xufTtcblxuY29udmVydC5sYWIueHl6ID0gZnVuY3Rpb24gKGxhYikge1xuXHRjb25zdCBsID0gbGFiWzBdO1xuXHRjb25zdCBhID0gbGFiWzFdO1xuXHRjb25zdCBiID0gbGFiWzJdO1xuXHRsZXQgeDtcblx0bGV0IHk7XG5cdGxldCB6O1xuXG5cdHkgPSAobCArIDE2KSAvIDExNjtcblx0eCA9IGEgLyA1MDAgKyB5O1xuXHR6ID0geSAtIGIgLyAyMDA7XG5cblx0Y29uc3QgeTIgPSB5ICoqIDM7XG5cdGNvbnN0IHgyID0geCAqKiAzO1xuXHRjb25zdCB6MiA9IHogKiogMztcblx0eSA9IHkyID4gMC4wMDg4NTYgPyB5MiA6ICh5IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cdHggPSB4MiA+IDAuMDA4ODU2ID8geDIgOiAoeCAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXHR6ID0gejIgPiAwLjAwODg1NiA/IHoyIDogKHogLSAxNiAvIDExNikgLyA3Ljc4NztcblxuXHR4ICo9IDk1LjA0Nztcblx0eSAqPSAxMDA7XG5cdHogKj0gMTA4Ljg4MztcblxuXHRyZXR1cm4gW3gsIHksIHpdO1xufTtcblxuY29udmVydC5sYWIubGNoID0gZnVuY3Rpb24gKGxhYikge1xuXHRjb25zdCBsID0gbGFiWzBdO1xuXHRjb25zdCBhID0gbGFiWzFdO1xuXHRjb25zdCBiID0gbGFiWzJdO1xuXHRsZXQgaDtcblxuXHRjb25zdCBociA9IE1hdGguYXRhbjIoYiwgYSk7XG5cdGggPSBociAqIDM2MCAvIDIgLyBNYXRoLlBJO1xuXG5cdGlmIChoIDwgMCkge1xuXHRcdGggKz0gMzYwO1xuXHR9XG5cblx0Y29uc3QgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblxuXHRyZXR1cm4gW2wsIGMsIGhdO1xufTtcblxuY29udmVydC5sY2gubGFiID0gZnVuY3Rpb24gKGxjaCkge1xuXHRjb25zdCBsID0gbGNoWzBdO1xuXHRjb25zdCBjID0gbGNoWzFdO1xuXHRjb25zdCBoID0gbGNoWzJdO1xuXG5cdGNvbnN0IGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuXHRjb25zdCBhID0gYyAqIE1hdGguY29zKGhyKTtcblx0Y29uc3QgYiA9IGMgKiBNYXRoLnNpbihocik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmFuc2kxNiA9IGZ1bmN0aW9uIChhcmdzLCBzYXR1cmF0aW9uID0gbnVsbCkge1xuXHRjb25zdCBbciwgZywgYl0gPSBhcmdzO1xuXHRsZXQgdmFsdWUgPSBzYXR1cmF0aW9uID09PSBudWxsID8gY29udmVydC5yZ2IuaHN2KGFyZ3MpWzJdIDogc2F0dXJhdGlvbjsgLy8gSHN2IC0+IGFuc2kxNiBvcHRpbWl6YXRpb25cblxuXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgLyA1MCk7XG5cblx0aWYgKHZhbHVlID09PSAwKSB7XG5cdFx0cmV0dXJuIDMwO1xuXHR9XG5cblx0bGV0IGFuc2kgPSAzMFxuXHRcdCsgKChNYXRoLnJvdW5kKGIgLyAyNTUpIDw8IDIpXG5cdFx0fCAoTWF0aC5yb3VuZChnIC8gMjU1KSA8PCAxKVxuXHRcdHwgTWF0aC5yb3VuZChyIC8gMjU1KSk7XG5cblx0aWYgKHZhbHVlID09PSAyKSB7XG5cdFx0YW5zaSArPSA2MDtcblx0fVxuXG5cdHJldHVybiBhbnNpO1xufTtcblxuY29udmVydC5oc3YuYW5zaTE2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Ly8gT3B0aW1pemF0aW9uIGhlcmU7IHdlIGFscmVhZHkga25vdyB0aGUgdmFsdWUgYW5kIGRvbid0IG5lZWQgdG8gZ2V0XG5cdC8vIGl0IGNvbnZlcnRlZCBmb3IgdXMuXG5cdHJldHVybiBjb252ZXJ0LnJnYi5hbnNpMTYoY29udmVydC5oc3YucmdiKGFyZ3MpLCBhcmdzWzJdKTtcbn07XG5cbmNvbnZlcnQucmdiLmFuc2kyNTYgPSBmdW5jdGlvbiAoYXJncykge1xuXHRjb25zdCByID0gYXJnc1swXTtcblx0Y29uc3QgZyA9IGFyZ3NbMV07XG5cdGNvbnN0IGIgPSBhcmdzWzJdO1xuXG5cdC8vIFdlIHVzZSB0aGUgZXh0ZW5kZWQgZ3JleXNjYWxlIHBhbGV0dGUgaGVyZSwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mXG5cdC8vIGJsYWNrIGFuZCB3aGl0ZS4gbm9ybWFsIHBhbGV0dGUgb25seSBoYXMgNCBncmV5c2NhbGUgc2hhZGVzLlxuXHRpZiAociA9PT0gZyAmJiBnID09PSBiKSB7XG5cdFx0aWYgKHIgPCA4KSB7XG5cdFx0XHRyZXR1cm4gMTY7XG5cdFx0fVxuXG5cdFx0aWYgKHIgPiAyNDgpIHtcblx0XHRcdHJldHVybiAyMzE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGgucm91bmQoKChyIC0gOCkgLyAyNDcpICogMjQpICsgMjMyO1xuXHR9XG5cblx0Y29uc3QgYW5zaSA9IDE2XG5cdFx0KyAoMzYgKiBNYXRoLnJvdW5kKHIgLyAyNTUgKiA1KSlcblx0XHQrICg2ICogTWF0aC5yb3VuZChnIC8gMjU1ICogNSkpXG5cdFx0KyBNYXRoLnJvdW5kKGIgLyAyNTUgKiA1KTtcblxuXHRyZXR1cm4gYW5zaTtcbn07XG5cbmNvbnZlcnQuYW5zaTE2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdGxldCBjb2xvciA9IGFyZ3MgJSAxMDtcblxuXHQvLyBIYW5kbGUgZ3JleXNjYWxlXG5cdGlmIChjb2xvciA9PT0gMCB8fCBjb2xvciA9PT0gNykge1xuXHRcdGlmIChhcmdzID4gNTApIHtcblx0XHRcdGNvbG9yICs9IDMuNTtcblx0XHR9XG5cblx0XHRjb2xvciA9IGNvbG9yIC8gMTAuNSAqIDI1NTtcblxuXHRcdHJldHVybiBbY29sb3IsIGNvbG9yLCBjb2xvcl07XG5cdH1cblxuXHRjb25zdCBtdWx0ID0gKH5+KGFyZ3MgPiA1MCkgKyAxKSAqIDAuNTtcblx0Y29uc3QgciA9ICgoY29sb3IgJiAxKSAqIG11bHQpICogMjU1O1xuXHRjb25zdCBnID0gKCgoY29sb3IgPj4gMSkgJiAxKSAqIG11bHQpICogMjU1O1xuXHRjb25zdCBiID0gKCgoY29sb3IgPj4gMikgJiAxKSAqIG11bHQpICogMjU1O1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0LmFuc2kyNTYucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Ly8gSGFuZGxlIGdyZXlzY2FsZVxuXHRpZiAoYXJncyA+PSAyMzIpIHtcblx0XHRjb25zdCBjID0gKGFyZ3MgLSAyMzIpICogMTAgKyA4O1xuXHRcdHJldHVybiBbYywgYywgY107XG5cdH1cblxuXHRhcmdzIC09IDE2O1xuXG5cdGxldCByZW07XG5cdGNvbnN0IHIgPSBNYXRoLmZsb29yKGFyZ3MgLyAzNikgLyA1ICogMjU1O1xuXHRjb25zdCBnID0gTWF0aC5mbG9vcigocmVtID0gYXJncyAlIDM2KSAvIDYpIC8gNSAqIDI1NTtcblx0Y29uc3QgYiA9IChyZW0gJSA2KSAvIDUgKiAyNTU7XG5cblx0cmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmhleCA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdGNvbnN0IGludGVnZXIgPSAoKE1hdGgucm91bmQoYXJnc1swXSkgJiAweEZGKSA8PCAxNilcblx0XHQrICgoTWF0aC5yb3VuZChhcmdzWzFdKSAmIDB4RkYpIDw8IDgpXG5cdFx0KyAoTWF0aC5yb3VuZChhcmdzWzJdKSAmIDB4RkYpO1xuXG5cdGNvbnN0IHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdHJldHVybiAnMDAwMDAwJy5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59O1xuXG5jb252ZXJ0LmhleC5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHRjb25zdCBtYXRjaCA9IGFyZ3MudG9TdHJpbmcoMTYpLm1hdGNoKC9bYS1mMC05XXs2fXxbYS1mMC05XXszfS9pKTtcblx0aWYgKCFtYXRjaCkge1xuXHRcdHJldHVybiBbMCwgMCwgMF07XG5cdH1cblxuXHRsZXQgY29sb3JTdHJpbmcgPSBtYXRjaFswXTtcblxuXHRpZiAobWF0Y2hbMF0ubGVuZ3RoID09PSAzKSB7XG5cdFx0Y29sb3JTdHJpbmcgPSBjb2xvclN0cmluZy5zcGxpdCgnJykubWFwKGNoYXIgPT4ge1xuXHRcdFx0cmV0dXJuIGNoYXIgKyBjaGFyO1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0Y29uc3QgaW50ZWdlciA9IHBhcnNlSW50KGNvbG9yU3RyaW5nLCAxNik7XG5cdGNvbnN0IHIgPSAoaW50ZWdlciA+PiAxNikgJiAweEZGO1xuXHRjb25zdCBnID0gKGludGVnZXIgPj4gOCkgJiAweEZGO1xuXHRjb25zdCBiID0gaW50ZWdlciAmIDB4RkY7XG5cblx0cmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmhjZyA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0Y29uc3QgciA9IHJnYlswXSAvIDI1NTtcblx0Y29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcblx0Y29uc3QgYiA9IHJnYlsyXSAvIDI1NTtcblx0Y29uc3QgbWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgociwgZyksIGIpO1xuXHRjb25zdCBtaW4gPSBNYXRoLm1pbihNYXRoLm1pbihyLCBnKSwgYik7XG5cdGNvbnN0IGNocm9tYSA9IChtYXggLSBtaW4pO1xuXHRsZXQgZ3JheXNjYWxlO1xuXHRsZXQgaHVlO1xuXG5cdGlmIChjaHJvbWEgPCAxKSB7XG5cdFx0Z3JheXNjYWxlID0gbWluIC8gKDEgLSBjaHJvbWEpO1xuXHR9IGVsc2Uge1xuXHRcdGdyYXlzY2FsZSA9IDA7XG5cdH1cblxuXHRpZiAoY2hyb21hIDw9IDApIHtcblx0XHRodWUgPSAwO1xuXHR9IGVsc2Vcblx0aWYgKG1heCA9PT0gcikge1xuXHRcdGh1ZSA9ICgoZyAtIGIpIC8gY2hyb21hKSAlIDY7XG5cdH0gZWxzZVxuXHRpZiAobWF4ID09PSBnKSB7XG5cdFx0aHVlID0gMiArIChiIC0gcikgLyBjaHJvbWE7XG5cdH0gZWxzZSB7XG5cdFx0aHVlID0gNCArIChyIC0gZykgLyBjaHJvbWE7XG5cdH1cblxuXHRodWUgLz0gNjtcblx0aHVlICU9IDE7XG5cblx0cmV0dXJuIFtodWUgKiAzNjAsIGNocm9tYSAqIDEwMCwgZ3JheXNjYWxlICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHNsLmhjZyA9IGZ1bmN0aW9uIChoc2wpIHtcblx0Y29uc3QgcyA9IGhzbFsxXSAvIDEwMDtcblx0Y29uc3QgbCA9IGhzbFsyXSAvIDEwMDtcblxuXHRjb25zdCBjID0gbCA8IDAuNSA/ICgyLjAgKiBzICogbCkgOiAoMi4wICogcyAqICgxLjAgLSBsKSk7XG5cblx0bGV0IGYgPSAwO1xuXHRpZiAoYyA8IDEuMCkge1xuXHRcdGYgPSAobCAtIDAuNSAqIGMpIC8gKDEuMCAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtoc2xbMF0sIGMgKiAxMDAsIGYgKiAxMDBdO1xufTtcblxuY29udmVydC5oc3YuaGNnID0gZnVuY3Rpb24gKGhzdikge1xuXHRjb25zdCBzID0gaHN2WzFdIC8gMTAwO1xuXHRjb25zdCB2ID0gaHN2WzJdIC8gMTAwO1xuXG5cdGNvbnN0IGMgPSBzICogdjtcblx0bGV0IGYgPSAwO1xuXG5cdGlmIChjIDwgMS4wKSB7XG5cdFx0ZiA9ICh2IC0gYykgLyAoMSAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtoc3ZbMF0sIGMgKiAxMDAsIGYgKiAxMDBdO1xufTtcblxuY29udmVydC5oY2cucmdiID0gZnVuY3Rpb24gKGhjZykge1xuXHRjb25zdCBoID0gaGNnWzBdIC8gMzYwO1xuXHRjb25zdCBjID0gaGNnWzFdIC8gMTAwO1xuXHRjb25zdCBnID0gaGNnWzJdIC8gMTAwO1xuXG5cdGlmIChjID09PSAwLjApIHtcblx0XHRyZXR1cm4gW2cgKiAyNTUsIGcgKiAyNTUsIGcgKiAyNTVdO1xuXHR9XG5cblx0Y29uc3QgcHVyZSA9IFswLCAwLCAwXTtcblx0Y29uc3QgaGkgPSAoaCAlIDEpICogNjtcblx0Y29uc3QgdiA9IGhpICUgMTtcblx0Y29uc3QgdyA9IDEgLSB2O1xuXHRsZXQgbWcgPSAwO1xuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLXBlci1saW5lICovXG5cdHN3aXRjaCAoTWF0aC5mbG9vcihoaSkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRwdXJlWzBdID0gMTsgcHVyZVsxXSA9IHY7IHB1cmVbMl0gPSAwOyBicmVhaztcblx0XHRjYXNlIDE6XG5cdFx0XHRwdXJlWzBdID0gdzsgcHVyZVsxXSA9IDE7IHB1cmVbMl0gPSAwOyBicmVhaztcblx0XHRjYXNlIDI6XG5cdFx0XHRwdXJlWzBdID0gMDsgcHVyZVsxXSA9IDE7IHB1cmVbMl0gPSB2OyBicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRwdXJlWzBdID0gMDsgcHVyZVsxXSA9IHc7IHB1cmVbMl0gPSAxOyBicmVhaztcblx0XHRjYXNlIDQ6XG5cdFx0XHRwdXJlWzBdID0gdjsgcHVyZVsxXSA9IDA7IHB1cmVbMl0gPSAxOyBicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cHVyZVswXSA9IDE7IHB1cmVbMV0gPSAwOyBwdXJlWzJdID0gdztcblx0fVxuXHQvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzLXBlci1saW5lICovXG5cblx0bWcgPSAoMS4wIC0gYykgKiBnO1xuXG5cdHJldHVybiBbXG5cdFx0KGMgKiBwdXJlWzBdICsgbWcpICogMjU1LFxuXHRcdChjICogcHVyZVsxXSArIG1nKSAqIDI1NSxcblx0XHQoYyAqIHB1cmVbMl0gKyBtZykgKiAyNTVcblx0XTtcbn07XG5cbmNvbnZlcnQuaGNnLmhzdiA9IGZ1bmN0aW9uIChoY2cpIHtcblx0Y29uc3QgYyA9IGhjZ1sxXSAvIDEwMDtcblx0Y29uc3QgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHRjb25zdCB2ID0gYyArIGcgKiAoMS4wIC0gYyk7XG5cdGxldCBmID0gMDtcblxuXHRpZiAodiA+IDAuMCkge1xuXHRcdGYgPSBjIC8gdjtcblx0fVxuXG5cdHJldHVybiBbaGNnWzBdLCBmICogMTAwLCB2ICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaGNnLmhzbCA9IGZ1bmN0aW9uIChoY2cpIHtcblx0Y29uc3QgYyA9IGhjZ1sxXSAvIDEwMDtcblx0Y29uc3QgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHRjb25zdCBsID0gZyAqICgxLjAgLSBjKSArIDAuNSAqIGM7XG5cdGxldCBzID0gMDtcblxuXHRpZiAobCA+IDAuMCAmJiBsIDwgMC41KSB7XG5cdFx0cyA9IGMgLyAoMiAqIGwpO1xuXHR9IGVsc2Vcblx0aWYgKGwgPj0gMC41ICYmIGwgPCAxLjApIHtcblx0XHRzID0gYyAvICgyICogKDEgLSBsKSk7XG5cdH1cblxuXHRyZXR1cm4gW2hjZ1swXSwgcyAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5od2IgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdGNvbnN0IGMgPSBoY2dbMV0gLyAxMDA7XG5cdGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG5cdGNvbnN0IHYgPSBjICsgZyAqICgxLjAgLSBjKTtcblx0cmV0dXJuIFtoY2dbMF0sICh2IC0gYykgKiAxMDAsICgxIC0gdikgKiAxMDBdO1xufTtcblxuY29udmVydC5od2IuaGNnID0gZnVuY3Rpb24gKGh3Yikge1xuXHRjb25zdCB3ID0gaHdiWzFdIC8gMTAwO1xuXHRjb25zdCBiID0gaHdiWzJdIC8gMTAwO1xuXHRjb25zdCB2ID0gMSAtIGI7XG5cdGNvbnN0IGMgPSB2IC0gdztcblx0bGV0IGcgPSAwO1xuXG5cdGlmIChjIDwgMSkge1xuXHRcdGcgPSAodiAtIGMpIC8gKDEgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHdiWzBdLCBjICogMTAwLCBnICogMTAwXTtcbn07XG5cbmNvbnZlcnQuYXBwbGUucmdiID0gZnVuY3Rpb24gKGFwcGxlKSB7XG5cdHJldHVybiBbKGFwcGxlWzBdIC8gNjU1MzUpICogMjU1LCAoYXBwbGVbMV0gLyA2NTUzNSkgKiAyNTUsIChhcHBsZVsyXSAvIDY1NTM1KSAqIDI1NV07XG59O1xuXG5jb252ZXJ0LnJnYi5hcHBsZSA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0cmV0dXJuIFsocmdiWzBdIC8gMjU1KSAqIDY1NTM1LCAocmdiWzFdIC8gMjU1KSAqIDY1NTM1LCAocmdiWzJdIC8gMjU1KSAqIDY1NTM1XTtcbn07XG5cbmNvbnZlcnQuZ3JheS5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHRyZXR1cm4gW2FyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTVdO1xufTtcblxuY29udmVydC5ncmF5LmhzbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHJldHVybiBbMCwgMCwgYXJnc1swXV07XG59O1xuXG5jb252ZXJ0LmdyYXkuaHN2ID0gY29udmVydC5ncmF5LmhzbDtcblxuY29udmVydC5ncmF5Lmh3YiA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbMCwgMTAwLCBncmF5WzBdXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5jbXlrID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFswLCAwLCAwLCBncmF5WzBdXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5sYWIgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gW2dyYXlbMF0sIDAsIDBdO1xufTtcblxuY29udmVydC5ncmF5LmhleCA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdGNvbnN0IHZhbCA9IE1hdGgucm91bmQoZ3JheVswXSAvIDEwMCAqIDI1NSkgJiAweEZGO1xuXHRjb25zdCBpbnRlZ2VyID0gKHZhbCA8PCAxNikgKyAodmFsIDw8IDgpICsgdmFsO1xuXG5cdGNvbnN0IHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdHJldHVybiAnMDAwMDAwJy5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59O1xuXG5jb252ZXJ0LnJnYi5ncmF5ID0gZnVuY3Rpb24gKHJnYikge1xuXHRjb25zdCB2YWwgPSAocmdiWzBdICsgcmdiWzFdICsgcmdiWzJdKSAvIDM7XG5cdHJldHVybiBbdmFsIC8gMjU1ICogMTAwXTtcbn07XG4iLCJjb25zdCBjb252ZXJzaW9ucyA9IHJlcXVpcmUoJy4vY29udmVyc2lvbnMnKTtcbmNvbnN0IHJvdXRlID0gcmVxdWlyZSgnLi9yb3V0ZScpO1xuXG5jb25zdCBjb252ZXJ0ID0ge307XG5cbmNvbnN0IG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcblxuZnVuY3Rpb24gd3JhcFJhdyhmbikge1xuXHRjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdGNvbnN0IGFyZzAgPSBhcmdzWzBdO1xuXHRcdGlmIChhcmcwID09PSB1bmRlZmluZWQgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGFyZzA7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZzAubGVuZ3RoID4gMSkge1xuXHRcdFx0YXJncyA9IGFyZzA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZuKGFyZ3MpO1xuXHR9O1xuXG5cdC8vIFByZXNlcnZlIC5jb252ZXJzaW9uIHByb3BlcnR5IGlmIHRoZXJlIGlzIG9uZVxuXHRpZiAoJ2NvbnZlcnNpb24nIGluIGZuKSB7XG5cdFx0d3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuXHR9XG5cblx0cmV0dXJuIHdyYXBwZWRGbjtcbn1cblxuZnVuY3Rpb24gd3JhcFJvdW5kZWQoZm4pIHtcblx0Y29uc3Qgd3JhcHBlZEZuID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRjb25zdCBhcmcwID0gYXJnc1swXTtcblxuXHRcdGlmIChhcmcwID09PSB1bmRlZmluZWQgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGFyZzA7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZzAubGVuZ3RoID4gMSkge1xuXHRcdFx0YXJncyA9IGFyZzA7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVzdWx0ID0gZm4oYXJncyk7XG5cblx0XHQvLyBXZSdyZSBhc3N1bWluZyB0aGUgcmVzdWx0IGlzIGFuIGFycmF5IGhlcmUuXG5cdFx0Ly8gc2VlIG5vdGljZSBpbiBjb252ZXJzaW9ucy5qczsgZG9uJ3QgdXNlIGJveCB0eXBlc1xuXHRcdC8vIGluIGNvbnZlcnNpb24gZnVuY3Rpb25zLlxuXHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Zm9yIChsZXQgbGVuID0gcmVzdWx0Lmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSBNYXRoLnJvdW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvLyBQcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblx0aWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuXHRcdHdyYXBwZWRGbi5jb252ZXJzaW9uID0gZm4uY29udmVyc2lvbjtcblx0fVxuXG5cdHJldHVybiB3cmFwcGVkRm47XG59XG5cbm1vZGVscy5mb3JFYWNoKGZyb21Nb2RlbCA9PiB7XG5cdGNvbnZlcnRbZnJvbU1vZGVsXSA9IHt9O1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W2Zyb21Nb2RlbF0sICdjaGFubmVscycsIHt2YWx1ZTogY29udmVyc2lvbnNbZnJvbU1vZGVsXS5jaGFubmVsc30pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCAnbGFiZWxzJywge3ZhbHVlOiBjb252ZXJzaW9uc1tmcm9tTW9kZWxdLmxhYmVsc30pO1xuXG5cdGNvbnN0IHJvdXRlcyA9IHJvdXRlKGZyb21Nb2RlbCk7XG5cdGNvbnN0IHJvdXRlTW9kZWxzID0gT2JqZWN0LmtleXMocm91dGVzKTtcblxuXHRyb3V0ZU1vZGVscy5mb3JFYWNoKHRvTW9kZWwgPT4ge1xuXHRcdGNvbnN0IGZuID0gcm91dGVzW3RvTW9kZWxdO1xuXG5cdFx0Y29udmVydFtmcm9tTW9kZWxdW3RvTW9kZWxdID0gd3JhcFJvdW5kZWQoZm4pO1xuXHRcdGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXS5yYXcgPSB3cmFwUmF3KGZuKTtcblx0fSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJ0O1xuIiwiY29uc3QgY29udmVyc2lvbnMgPSByZXF1aXJlKCcuL2NvbnZlcnNpb25zJyk7XG5cbi8qXG5cdFRoaXMgZnVuY3Rpb24gcm91dGVzIGEgbW9kZWwgdG8gYWxsIG90aGVyIG1vZGVscy5cblxuXHRhbGwgZnVuY3Rpb25zIHRoYXQgYXJlIHJvdXRlZCBoYXZlIGEgcHJvcGVydHkgYC5jb252ZXJzaW9uYCBhdHRhY2hlZFxuXHR0byB0aGUgcmV0dXJuZWQgc3ludGhldGljIGZ1bmN0aW9uLiBUaGlzIHByb3BlcnR5IGlzIGFuIGFycmF5XG5cdG9mIHN0cmluZ3MsIGVhY2ggd2l0aCB0aGUgc3RlcHMgaW4gYmV0d2VlbiB0aGUgJ2Zyb20nIGFuZCAndG8nXG5cdGNvbG9yIG1vZGVscyAoaW5jbHVzaXZlKS5cblxuXHRjb252ZXJzaW9ucyB0aGF0IGFyZSBub3QgcG9zc2libGUgc2ltcGx5IGFyZSBub3QgaW5jbHVkZWQuXG4qL1xuXG5mdW5jdGlvbiBidWlsZEdyYXBoKCkge1xuXHRjb25zdCBncmFwaCA9IHt9O1xuXHQvLyBodHRwczovL2pzcGVyZi5jb20vb2JqZWN0LWtleXMtdnMtZm9yLWluLXdpdGgtY2xvc3VyZS8zXG5cdGNvbnN0IG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcblxuXHRmb3IgKGxldCBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0Z3JhcGhbbW9kZWxzW2ldXSA9IHtcblx0XHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tLzEtdnMtaW5maW5pdHlcblx0XHRcdC8vIG1pY3JvLW9wdCwgYnV0IHRoaXMgaXMgc2ltcGxlLlxuXHRcdFx0ZGlzdGFuY2U6IC0xLFxuXHRcdFx0cGFyZW50OiBudWxsXG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBncmFwaDtcbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlYWR0aC1maXJzdF9zZWFyY2hcbmZ1bmN0aW9uIGRlcml2ZUJGUyhmcm9tTW9kZWwpIHtcblx0Y29uc3QgZ3JhcGggPSBidWlsZEdyYXBoKCk7XG5cdGNvbnN0IHF1ZXVlID0gW2Zyb21Nb2RlbF07IC8vIFVuc2hpZnQgLT4gcXVldWUgLT4gcG9wXG5cblx0Z3JhcGhbZnJvbU1vZGVsXS5kaXN0YW5jZSA9IDA7XG5cblx0d2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdGNvbnN0IGN1cnJlbnQgPSBxdWV1ZS5wb3AoKTtcblx0XHRjb25zdCBhZGphY2VudHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9uc1tjdXJyZW50XSk7XG5cblx0XHRmb3IgKGxldCBsZW4gPSBhZGphY2VudHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjb25zdCBhZGphY2VudCA9IGFkamFjZW50c1tpXTtcblx0XHRcdGNvbnN0IG5vZGUgPSBncmFwaFthZGphY2VudF07XG5cblx0XHRcdGlmIChub2RlLmRpc3RhbmNlID09PSAtMSkge1xuXHRcdFx0XHRub2RlLmRpc3RhbmNlID0gZ3JhcGhbY3VycmVudF0uZGlzdGFuY2UgKyAxO1xuXHRcdFx0XHRub2RlLnBhcmVudCA9IGN1cnJlbnQ7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoYWRqYWNlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBncmFwaDtcbn1cblxuZnVuY3Rpb24gbGluayhmcm9tLCB0bykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRyZXR1cm4gdG8oZnJvbShhcmdzKSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIHdyYXBDb252ZXJzaW9uKHRvTW9kZWwsIGdyYXBoKSB7XG5cdGNvbnN0IHBhdGggPSBbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50LCB0b01vZGVsXTtcblx0bGV0IGZuID0gY29udmVyc2lvbnNbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50XVt0b01vZGVsXTtcblxuXHRsZXQgY3VyID0gZ3JhcGhbdG9Nb2RlbF0ucGFyZW50O1xuXHR3aGlsZSAoZ3JhcGhbY3VyXS5wYXJlbnQpIHtcblx0XHRwYXRoLnVuc2hpZnQoZ3JhcGhbY3VyXS5wYXJlbnQpO1xuXHRcdGZuID0gbGluayhjb252ZXJzaW9uc1tncmFwaFtjdXJdLnBhcmVudF1bY3VyXSwgZm4pO1xuXHRcdGN1ciA9IGdyYXBoW2N1cl0ucGFyZW50O1xuXHR9XG5cblx0Zm4uY29udmVyc2lvbiA9IHBhdGg7XG5cdHJldHVybiBmbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZnJvbU1vZGVsKSB7XG5cdGNvbnN0IGdyYXBoID0gZGVyaXZlQkZTKGZyb21Nb2RlbCk7XG5cdGNvbnN0IGNvbnZlcnNpb24gPSB7fTtcblxuXHRjb25zdCBtb2RlbHMgPSBPYmplY3Qua2V5cyhncmFwaCk7XG5cdGZvciAobGV0IGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRjb25zdCB0b01vZGVsID0gbW9kZWxzW2ldO1xuXHRcdGNvbnN0IG5vZGUgPSBncmFwaFt0b01vZGVsXTtcblxuXHRcdGlmIChub2RlLnBhcmVudCA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gTm8gcG9zc2libGUgY29udmVyc2lvbiwgb3IgdGhpcyBub2RlIGlzIHRoZSBzb3VyY2UgbW9kZWwuXG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb252ZXJzaW9uW3RvTW9kZWxdID0gd3JhcENvbnZlcnNpb24odG9Nb2RlbCwgZ3JhcGgpO1xuXHR9XG5cblx0cmV0dXJuIGNvbnZlcnNpb247XG59O1xuXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzY29wZUZhY3RvcnkgPSByZXF1aXJlKCcuL3Njb3BlJyk7XG5cbi8qKlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZXJyb3JcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHdhcm5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluZm9cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHZlcmJvc2VcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRlYnVnXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBzaWxseVxuICovXG5jbGFzcyBMb2dnZXIge1xuICBzdGF0aWMgaW5zdGFuY2VzID0ge307XG5cbiAgZXJyb3JIYW5kbGVyID0gbnVsbDtcbiAgZXZlbnRMb2dnZXIgPSBudWxsO1xuICBmdW5jdGlvbnMgPSB7fTtcbiAgaG9va3MgPSBbXTtcbiAgaXNEZXYgPSBmYWxzZTtcbiAgbGV2ZWxzID0gbnVsbDtcbiAgbG9nSWQgPSBudWxsO1xuICBzY29wZSA9IG51bGw7XG4gIHRyYW5zcG9ydHMgPSB7fTtcbiAgdmFyaWFibGVzID0ge307XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIGFsbG93VW5rbm93bkxldmVsID0gZmFsc2UsXG4gICAgZXJyb3JIYW5kbGVyLFxuICAgIGV2ZW50TG9nZ2VyLFxuICAgIGluaXRpYWxpemVGbixcbiAgICBpc0RldiA9IGZhbHNlLFxuICAgIGxldmVscyA9IFsnZXJyb3InLCAnd2FybicsICdpbmZvJywgJ3ZlcmJvc2UnLCAnZGVidWcnLCAnc2lsbHknXSxcbiAgICBsb2dJZCxcbiAgICB0cmFuc3BvcnRGYWN0b3JpZXMgPSB7fSxcbiAgICB2YXJpYWJsZXMsXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuYWRkTGV2ZWwgPSB0aGlzLmFkZExldmVsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jcmVhdGUgPSB0aGlzLmNyZWF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubG9nRGF0YSA9IHRoaXMubG9nRGF0YS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvY2Vzc01lc3NhZ2UgPSB0aGlzLnByb2Nlc3NNZXNzYWdlLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmFsbG93VW5rbm93bkxldmVsID0gYWxsb3dVbmtub3duTGV2ZWw7XG4gICAgdGhpcy5pbml0aWFsaXplRm4gPSBpbml0aWFsaXplRm47XG4gICAgdGhpcy5pc0RldiA9IGlzRGV2O1xuICAgIHRoaXMubGV2ZWxzID0gbGV2ZWxzO1xuICAgIHRoaXMubG9nSWQgPSBsb2dJZDtcbiAgICB0aGlzLnRyYW5zcG9ydEZhY3RvcmllcyA9IHRyYW5zcG9ydEZhY3RvcmllcztcbiAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcyB8fCB7fTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGVGYWN0b3J5KHRoaXMpO1xuXG4gICAgdGhpcy5hZGRMZXZlbCgnbG9nJywgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmxldmVscykge1xuICAgICAgdGhpcy5hZGRMZXZlbChuYW1lLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gICAgZXJyb3JIYW5kbGVyPy5zZXRPcHRpb25zKHsgbG9nRm46IHRoaXMuZXJyb3IgfSk7XG5cbiAgICB0aGlzLmV2ZW50TG9nZ2VyID0gZXZlbnRMb2dnZXI7XG4gICAgZXZlbnRMb2dnZXI/LnNldE9wdGlvbnMoeyBsb2dnZXI6IHRoaXMgfSk7XG5cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBmYWN0b3J5XSBvZiBPYmplY3QuZW50cmllcyh0cmFuc3BvcnRGYWN0b3JpZXMpKSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydHNbbmFtZV0gPSBmYWN0b3J5KHRoaXMpO1xuICAgIH1cblxuICAgIExvZ2dlci5pbnN0YW5jZXNbbG9nSWRdID0gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh7IGxvZ0lkIH0pIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNbbG9nSWRdIHx8IHRoaXMuaW5zdGFuY2VzLmRlZmF1bHQ7XG4gIH1cblxuICBhZGRMZXZlbChsZXZlbCwgaW5kZXggPSB0aGlzLmxldmVscy5sZW5ndGgpIHtcbiAgICBpZiAoaW5kZXggIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmxldmVscy5zcGxpY2UoaW5kZXgsIDAsIGxldmVsKTtcbiAgICB9XG5cbiAgICB0aGlzW2xldmVsXSA9ICguLi5hcmdzKSA9PiB0aGlzLmxvZ0RhdGEoYXJncywgeyBsZXZlbCB9KTtcbiAgICB0aGlzLmZ1bmN0aW9uc1tsZXZlbF0gPSB0aGlzW2xldmVsXTtcbiAgfVxuXG4gIGNhdGNoRXJyb3JzKG9wdGlvbnMpIHtcbiAgICB0aGlzLnByb2Nlc3NNZXNzYWdlKFxuICAgICAge1xuICAgICAgICBkYXRhOiBbJ2xvZy5jYXRjaEVycm9ycyBpcyBkZXByZWNhdGVkLiBVc2UgbG9nLmVycm9ySGFuZGxlciBpbnN0ZWFkJ10sXG4gICAgICAgIGxldmVsOiAnd2FybicsXG4gICAgICB9LFxuICAgICAgeyB0cmFuc3BvcnRzOiBbJ2NvbnNvbGUnXSB9LFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLnN0YXJ0Q2F0Y2hpbmcob3B0aW9ucyk7XG4gIH1cblxuICBjcmVhdGUob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMgPSB7IGxvZ0lkOiBvcHRpb25zIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBMb2dnZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGVycm9ySGFuZGxlcjogdGhpcy5lcnJvckhhbmRsZXIsXG4gICAgICBpbml0aWFsaXplRm46IHRoaXMuaW5pdGlhbGl6ZUZuLFxuICAgICAgaXNEZXY6IHRoaXMuaXNEZXYsXG4gICAgICB0cmFuc3BvcnRGYWN0b3JpZXM6IHRoaXMudHJhbnNwb3J0RmFjdG9yaWVzLFxuICAgICAgdmFyaWFibGVzOiB7IC4uLnRoaXMudmFyaWFibGVzIH0sXG4gICAgfSk7XG4gIH1cblxuICBjb21wYXJlTGV2ZWxzKHBhc3NMZXZlbCwgY2hlY2tMZXZlbCwgbGV2ZWxzID0gdGhpcy5sZXZlbHMpIHtcbiAgICBjb25zdCBwYXNzID0gbGV2ZWxzLmluZGV4T2YocGFzc0xldmVsKTtcbiAgICBjb25zdCBjaGVjayA9IGxldmVscy5pbmRleE9mKGNoZWNrTGV2ZWwpO1xuICAgIGlmIChjaGVjayA9PT0gLTEgfHwgcGFzcyA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBjaGVjayA8PSBwYXNzO1xuICB9XG5cbiAgaW5pdGlhbGl6ZShvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmluaXRpYWxpemVGbih7IGxvZ2dlcjogdGhpcywgLi4ub3B0aW9ucyB9KTtcbiAgfVxuXG4gIGxvZ0RhdGEoZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5wcm9jZXNzTWVzc2FnZSh7IGRhdGEsIC4uLm9wdGlvbnMgfSk7XG4gIH1cblxuICBwcm9jZXNzTWVzc2FnZShtZXNzYWdlLCB7IHRyYW5zcG9ydHMgPSB0aGlzLnRyYW5zcG9ydHMgfSA9IHt9KSB7XG4gICAgaWYgKG1lc3NhZ2UuY21kID09PSAnZXJyb3JIYW5kbGVyJykge1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlKG1lc3NhZ2UuZXJyb3IsIHtcbiAgICAgICAgZXJyb3JOYW1lOiBtZXNzYWdlLmVycm9yTmFtZSxcbiAgICAgICAgcHJvY2Vzc1R5cGU6ICdyZW5kZXJlcicsXG4gICAgICAgIHNob3dEaWFsb2c6IEJvb2xlYW4obWVzc2FnZS5zaG93RGlhbG9nKSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBsZXZlbCA9IG1lc3NhZ2UubGV2ZWw7XG4gICAgaWYgKCF0aGlzLmFsbG93VW5rbm93bkxldmVsKSB7XG4gICAgICBsZXZlbCA9IHRoaXMubGV2ZWxzLmluY2x1ZGVzKG1lc3NhZ2UubGV2ZWwpID8gbWVzc2FnZS5sZXZlbCA6ICdpbmZvJztcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkTWVzc2FnZSA9IHtcbiAgICAgIGRhdGU6IG5ldyBEYXRlKCksXG4gICAgICAuLi5tZXNzYWdlLFxuICAgICAgbGV2ZWwsXG4gICAgICB2YXJpYWJsZXM6IHtcbiAgICAgICAgLi4udGhpcy52YXJpYWJsZXMsXG4gICAgICAgIC4uLm1lc3NhZ2UudmFyaWFibGVzLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBbdHJhbnNOYW1lLCB0cmFuc0ZuXSBvZiB0aGlzLnRyYW5zcG9ydEVudHJpZXModHJhbnNwb3J0cykpIHtcbiAgICAgIGlmICh0eXBlb2YgdHJhbnNGbiAhPT0gJ2Z1bmN0aW9uJyB8fCB0cmFuc0ZuLmxldmVsID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNvbXBhcmVMZXZlbHModHJhbnNGbi5sZXZlbCwgbWVzc2FnZS5sZXZlbCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJvdy1ib2R5LXN0eWxlXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkTXNnID0gdGhpcy5ob29rcy5yZWR1Y2UoKG1zZywgaG9vaykgPT4ge1xuICAgICAgICAgIHJldHVybiBtc2cgPyBob29rKG1zZywgdHJhbnNGbiwgdHJhbnNOYW1lKSA6IG1zZztcbiAgICAgICAgfSwgbm9ybWFsaXplZE1lc3NhZ2UpO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZE1zZykge1xuICAgICAgICAgIHRyYW5zRm4oeyAuLi50cmFuc2Zvcm1lZE1zZywgZGF0YTogWy4uLnRyYW5zZm9ybWVkTXNnLmRhdGFdIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc0ludGVybmFsRXJyb3JGbihlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm9jZXNzSW50ZXJuYWxFcnJvckZuKF9lKSB7XG4gICAgLy8gRG8gbm90aGluZyBieSBkZWZhdWx0XG4gIH1cblxuICB0cmFuc3BvcnRFbnRyaWVzKHRyYW5zcG9ydHMgPSB0aGlzLnRyYW5zcG9ydHMpIHtcbiAgICBjb25zdCB0cmFuc3BvcnRBcnJheSA9IEFycmF5LmlzQXJyYXkodHJhbnNwb3J0cylcbiAgICAgID8gdHJhbnNwb3J0c1xuICAgICAgOiBPYmplY3QuZW50cmllcyh0cmFuc3BvcnRzKTtcblxuICAgIHJldHVybiB0cmFuc3BvcnRBcnJheVxuICAgICAgLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBpdGVtKSB7XG4gICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydHNbaXRlbV0gPyBbaXRlbSwgdGhpcy50cmFuc3BvcnRzW2l0ZW1dXSA6IG51bGw7XG4gICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIFtpdGVtLm5hbWUsIGl0ZW1dO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpdGVtKSA/IGl0ZW0gOiBudWxsO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExvZ2dlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBzY29wZUZhY3Rvcnk7XG5cbmZ1bmN0aW9uIHNjb3BlRmFjdG9yeShsb2dnZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlLCB7XG4gICAgZGVmYXVsdExhYmVsOiB7IHZhbHVlOiAnJywgd3JpdGFibGU6IHRydWUgfSxcbiAgICBsYWJlbFBhZGRpbmc6IHsgdmFsdWU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgbWF4TGFiZWxMZW5ndGg6IHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgbGFiZWxMZW5ndGg6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2NvcGUubGFiZWxQYWRkaW5nKSB7XG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiBzY29wZS5sYWJlbFBhZGRpbmcgPyBzY29wZS5tYXhMYWJlbExlbmd0aCA6IDA7XG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuIHNjb3BlLmxhYmVsUGFkZGluZztcbiAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LFxuICB9KTtcblxuICBmdW5jdGlvbiBzY29wZShsYWJlbCkge1xuICAgIHNjb3BlLm1heExhYmVsTGVuZ3RoID0gTWF0aC5tYXgoc2NvcGUubWF4TGFiZWxMZW5ndGgsIGxhYmVsLmxlbmd0aCk7XG5cbiAgICBjb25zdCBuZXdTY29wZSA9IHt9O1xuICAgIGZvciAoY29uc3QgbGV2ZWwgb2YgWy4uLmxvZ2dlci5sZXZlbHMsICdsb2cnXSkge1xuICAgICAgbmV3U2NvcGVbbGV2ZWxdID0gKC4uLmQpID0+IGxvZ2dlci5sb2dEYXRhKGQsIHsgbGV2ZWwsIHNjb3BlOiBsYWJlbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1Njb3BlO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1kaXNhYmxlIGdsb2JhbC1yZXF1aXJlICovXG5cbmNvbnN0IGlzUmVuZGVyZXIgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCdcbiAgfHwgKHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCBwcm9jZXNzLnR5cGUgPT09ICd3b3JrZXInKTtcblxuaWYgKGlzUmVuZGVyZXIpIHtcbiAgLy8gTWFrZXMgc2Vuc2Ugd2hlbiBjb250ZXh0SXNvbGF0aW9uL3NhbmRib3ggZGlzYWJsZWRcbiAgcmVxdWlyZSgnLi9yZW5kZXJlci9lbGVjdHJvbi1sb2ctcHJlbG9hZCcpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVuZGVyZXInKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWluJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGVsZWN0cm9uQXBpID0gcmVxdWlyZSgnLi9lbGVjdHJvbkFwaScpO1xuXG5jbGFzcyBFcnJvckhhbmRsZXIge1xuICBpc0FjdGl2ZSA9IGZhbHNlO1xuICBsb2dGbiA9IG51bGw7XG4gIG9uRXJyb3IgPSBudWxsO1xuICBzaG93RGlhbG9nID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3Rvcih7IGxvZ0ZuID0gbnVsbCwgb25FcnJvciA9IG51bGwsIHNob3dEaWFsb2cgPSB0cnVlIH0gPSB7fSkge1xuICAgIHRoaXMuY3JlYXRlSXNzdWUgPSB0aGlzLmNyZWF0ZUlzc3VlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVFcnJvciA9IHRoaXMuaGFuZGxlRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZVJlamVjdGlvbiA9IHRoaXMuaGFuZGxlUmVqZWN0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZXRPcHRpb25zKHsgbG9nRm4sIG9uRXJyb3IsIHNob3dEaWFsb2cgfSk7XG4gICAgdGhpcy5zdGFydENhdGNoaW5nID0gdGhpcy5zdGFydENhdGNoaW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdG9wQ2F0Y2hpbmcgPSB0aGlzLnN0b3BDYXRjaGluZy5iaW5kKHRoaXMpO1xuICB9XG5cbiAgaGFuZGxlKGVycm9yLCB7XG4gICAgbG9nRm4gPSB0aGlzLmxvZ0ZuLFxuICAgIG9uRXJyb3IgPSB0aGlzLm9uRXJyb3IsXG4gICAgcHJvY2Vzc1R5cGUgPSAnYnJvd3NlcicsXG4gICAgc2hvd0RpYWxvZyA9IHRoaXMuc2hvd0RpYWxvZyxcbiAgICBlcnJvck5hbWUgPSAnJyxcbiAgfSA9IHt9KSB7XG4gICAgZXJyb3IgPSBub3JtYWxpemVFcnJvcihlcnJvcik7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb25zID0gZWxlY3Ryb25BcGkuZ2V0VmVyc2lvbnMoKTtcbiAgICAgICAgY29uc3QgY3JlYXRlSXNzdWUgPSB0aGlzLmNyZWF0ZUlzc3VlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBvbkVycm9yKHtcbiAgICAgICAgICBjcmVhdGVJc3N1ZSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBlcnJvck5hbWUsXG4gICAgICAgICAgcHJvY2Vzc1R5cGUsXG4gICAgICAgICAgdmVyc2lvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlcnJvck5hbWUgPyBsb2dGbihlcnJvck5hbWUsIGVycm9yKSA6IGxvZ0ZuKGVycm9yKTtcblxuICAgICAgaWYgKHNob3dEaWFsb2cgJiYgIWVycm9yTmFtZS5pbmNsdWRlcygncmVqZWN0aW9uJykpIHtcbiAgICAgICAgZWxlY3Ryb25BcGkuc2hvd0Vycm9yQm94KFxuICAgICAgICAgIGBBIEphdmFTY3JpcHQgZXJyb3Igb2NjdXJyZWQgaW4gdGhlICR7cHJvY2Vzc1R5cGV9IHByb2Nlc3NgLFxuICAgICAgICAgIGVycm9yLnN0YWNrLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbiAgfVxuXG4gIHNldE9wdGlvbnMoeyBsb2dGbiwgb25FcnJvciwgc2hvd0RpYWxvZyB9KSB7XG4gICAgaWYgKHR5cGVvZiBsb2dGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5sb2dGbiA9IGxvZ0ZuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5vbkVycm9yID0gb25FcnJvcjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNob3dEaWFsb2cgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5zaG93RGlhbG9nID0gc2hvd0RpYWxvZztcbiAgICB9XG4gIH1cblxuICBzdGFydENhdGNoaW5nKHsgb25FcnJvciwgc2hvd0RpYWxvZyB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2V0T3B0aW9ucyh7IG9uRXJyb3IsIHNob3dEaWFsb2cgfSk7XG4gICAgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCB0aGlzLmhhbmRsZUVycm9yKTtcbiAgICBwcm9jZXNzLm9uKCd1bmhhbmRsZWRSZWplY3Rpb24nLCB0aGlzLmhhbmRsZVJlamVjdGlvbik7XG4gIH1cblxuICBzdG9wQ2F0Y2hpbmcoKSB7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ3VuY2F1Z2h0RXhjZXB0aW9uJywgdGhpcy5oYW5kbGVFcnJvcik7XG4gICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcigndW5oYW5kbGVkUmVqZWN0aW9uJywgdGhpcy5oYW5kbGVSZWplY3Rpb24pO1xuICB9XG5cbiAgY3JlYXRlSXNzdWUocGFnZVVybCwgcXVlcnlQYXJhbXMpIHtcbiAgICBlbGVjdHJvbkFwaS5vcGVuVXJsKFxuICAgICAgYCR7cGFnZVVybH0/JHtuZXcgVVJMU2VhcmNoUGFyYW1zKHF1ZXJ5UGFyYW1zKS50b1N0cmluZygpfWAsXG4gICAgKTtcbiAgfVxuXG4gIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgdGhpcy5oYW5kbGUoZXJyb3IsIHsgZXJyb3JOYW1lOiAnVW5oYW5kbGVkJyB9KTtcbiAgfVxuXG4gIGhhbmRsZVJlamVjdGlvbihyZWFzb24pIHtcbiAgICBjb25zdCBlcnJvciA9IHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yXG4gICAgICA/IHJlYXNvblxuICAgICAgOiBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVhc29uKSk7XG4gICAgdGhpcy5oYW5kbGUoZXJyb3IsIHsgZXJyb3JOYW1lOiAnVW5oYW5kbGVkIHJlamVjdGlvbicgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRXJyb3IoZSkge1xuICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICBpZiAoZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoZS5tZXNzYWdlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoZS5tZXNzYWdlKSwgZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGUpKTtcbiAgICB9IGNhdGNoIChzZXJFcnIpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoYENvdWxkbid0IG5vcm1hbGl6ZSBlcnJvciAke1N0cmluZyhlKX06ICR7c2VyRXJyfWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgRXJyb3IoYENhbid0IG5vcm1hbGl6ZSBlcnJvciAke1N0cmluZyhlKX1gKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFcnJvckhhbmRsZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGVsZWN0cm9uQXBpID0gcmVxdWlyZSgnLi9lbGVjdHJvbkFwaScpO1xuXG5jbGFzcyBFdmVudExvZ2dlciB7XG4gIGRpc3Bvc2VycyA9IFtdO1xuICBmb3JtYXQgPSAne2V2ZW50U291cmNlfSN7ZXZlbnROYW1lfTonO1xuICBmb3JtYXR0ZXJzID0ge1xuICAgIGFwcDoge1xuICAgICAgJ2NlcnRpZmljYXRlLWVycm9yJzogKHsgYXJncyB9KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5VG9PYmplY3QoYXJncy5zbGljZSgxLCA0KSwgW1xuICAgICAgICAgICd1cmwnLFxuICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgJ2NlcnRpZmljYXRlJyxcbiAgICAgICAgXSk7XG4gICAgICB9LFxuICAgICAgJ2NoaWxkLXByb2Nlc3MtZ29uZSc6ICh7IGFyZ3MgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYXJncy5sZW5ndGggPT09IDEgPyBhcmdzWzBdIDogYXJncztcbiAgICAgIH0sXG4gICAgICAncmVuZGVyLXByb2Nlc3MtZ29uZSc6ICh7IGFyZ3M6IFt3ZWJDb250ZW50cywgZGV0YWlsc10gfSkgPT4ge1xuICAgICAgICByZXR1cm4gZGV0YWlscyAmJiB0eXBlb2YgZGV0YWlscyA9PT0gJ29iamVjdCdcbiAgICAgICAgICA/IHsgLi4uZGV0YWlscywgLi4udGhpcy5nZXRXZWJDb250ZW50c0RldGFpbHMod2ViQ29udGVudHMpIH1cbiAgICAgICAgICA6IFtdO1xuICAgICAgfSxcbiAgICB9LFxuXG4gICAgd2ViQ29udGVudHM6IHtcbiAgICAgICdjb25zb2xlLW1lc3NhZ2UnOiAoeyBhcmdzOiBbbGV2ZWwsIG1lc3NhZ2UsIGxpbmUsIHNvdXJjZUlkXSB9KSA9PiB7XG4gICAgICAgIC8vIDA6IGRlYnVnLCAxOiBpbmZvLCAyOiB3YXJuaW5nLCAzOiBlcnJvclxuICAgICAgICBpZiAobGV2ZWwgPCAzKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2UsIHNvdXJjZTogYCR7c291cmNlSWR9OiR7bGluZX1gIH07XG4gICAgICB9LFxuICAgICAgJ2RpZC1mYWlsLWxvYWQnOiAoeyBhcmdzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlUb09iamVjdChhcmdzLCBbXG4gICAgICAgICAgJ2Vycm9yQ29kZScsXG4gICAgICAgICAgJ2Vycm9yRGVzY3JpcHRpb24nLFxuICAgICAgICAgICd2YWxpZGF0ZWRVUkwnLFxuICAgICAgICAgICdpc01haW5GcmFtZScsXG4gICAgICAgICAgJ2ZyYW1lUHJvY2Vzc0lkJyxcbiAgICAgICAgICAnZnJhbWVSb3V0aW5nSWQnLFxuICAgICAgICBdKTtcbiAgICAgIH0sXG4gICAgICAnZGlkLWZhaWwtcHJvdmlzaW9uYWwtbG9hZCc6ICh7IGFyZ3MgfSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVRvT2JqZWN0KGFyZ3MsIFtcbiAgICAgICAgICAnZXJyb3JDb2RlJyxcbiAgICAgICAgICAnZXJyb3JEZXNjcmlwdGlvbicsXG4gICAgICAgICAgJ3ZhbGlkYXRlZFVSTCcsXG4gICAgICAgICAgJ2lzTWFpbkZyYW1lJyxcbiAgICAgICAgICAnZnJhbWVQcm9jZXNzSWQnLFxuICAgICAgICAgICdmcmFtZVJvdXRpbmdJZCcsXG4gICAgICAgIF0pO1xuICAgICAgfSxcbiAgICAgICdwbHVnaW4tY3Jhc2hlZCc6ICh7IGFyZ3MgfSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVRvT2JqZWN0KGFyZ3MsIFsnbmFtZScsICd2ZXJzaW9uJ10pO1xuICAgICAgfSxcbiAgICAgICdwcmVsb2FkLWVycm9yJzogKHsgYXJncyB9KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5VG9PYmplY3QoYXJncywgWydwcmVsb2FkUGF0aCcsICdlcnJvciddKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcblxuICBldmVudHMgPSB7XG4gICAgYXBwOiB7XG4gICAgICAnY2VydGlmaWNhdGUtZXJyb3InOiB0cnVlLFxuICAgICAgJ2NoaWxkLXByb2Nlc3MtZ29uZSc6IHRydWUsXG4gICAgICAncmVuZGVyLXByb2Nlc3MtZ29uZSc6IHRydWUsXG4gICAgfSxcblxuICAgIHdlYkNvbnRlbnRzOiB7XG4gICAgICAvLyAnY29uc29sZS1tZXNzYWdlJzogdHJ1ZSxcbiAgICAgICdkaWQtZmFpbC1sb2FkJzogdHJ1ZSxcbiAgICAgICdkaWQtZmFpbC1wcm92aXNpb25hbC1sb2FkJzogdHJ1ZSxcbiAgICAgICdwbHVnaW4tY3Jhc2hlZCc6IHRydWUsXG4gICAgICAncHJlbG9hZC1lcnJvcic6IHRydWUsXG4gICAgICAndW5yZXNwb25zaXZlJzogdHJ1ZSxcbiAgICB9LFxuICB9O1xuXG4gIGxldmVsID0gJ2Vycm9yJztcbiAgc2NvcGUgPSAnJztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICBzZXRPcHRpb25zKHsgZXZlbnRzLCBsZXZlbCwgbG9nZ2VyLCBmb3JtYXQsIGZvcm1hdHRlcnMsIHNjb3BlIH0pIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsb2dnZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5mb3JtYXR0ZXJzID0gZm9ybWF0dGVycztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXJ0TG9nZ2luZyhvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICB0aGlzLmRpc3Bvc2VMaXN0ZW5lcnMoKTtcblxuICAgIGZvciAoY29uc3QgZXZlbnROYW1lIG9mIHRoaXMuZ2V0RXZlbnROYW1lcyh0aGlzLmV2ZW50cy5hcHApKSB7XG4gICAgICB0aGlzLmRpc3Bvc2Vycy5wdXNoKFxuICAgICAgICBlbGVjdHJvbkFwaS5vbkFwcEV2ZW50KGV2ZW50TmFtZSwgKC4uLmhhbmRsZXJBcmdzKSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVFdmVudCh7IGV2ZW50U291cmNlOiAnYXBwJywgZXZlbnROYW1lLCBoYW5kbGVyQXJncyB9KTtcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZXZlbnROYW1lIG9mIHRoaXMuZ2V0RXZlbnROYW1lcyh0aGlzLmV2ZW50cy53ZWJDb250ZW50cykpIHtcbiAgICAgIHRoaXMuZGlzcG9zZXJzLnB1c2goXG4gICAgICAgIGVsZWN0cm9uQXBpLm9uRXZlcnlXZWJDb250ZW50c0V2ZW50KGV2ZW50TmFtZSwgKC4uLmhhbmRsZXJBcmdzKSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVFdmVudChcbiAgICAgICAgICAgIHsgZXZlbnRTb3VyY2U6ICd3ZWJDb250ZW50cycsIGV2ZW50TmFtZSwgaGFuZGxlckFyZ3MgfSxcbiAgICAgICAgICApO1xuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgc3RvcExvZ2dpbmcoKSB7XG4gICAgdGhpcy5kaXNwb3NlTGlzdGVuZXJzKCk7XG4gIH1cblxuICBhcnJheVRvT2JqZWN0KGFycmF5LCBmaWVsZE5hbWVzKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSwgaW5kZXgpID0+IHtcbiAgICAgIG9ialtmaWVsZE5hbWVdID0gYXJyYXlbaW5kZXhdO1xuICAgIH0pO1xuXG4gICAgaWYgKGFycmF5Lmxlbmd0aCA+IGZpZWxkTmFtZXMubGVuZ3RoKSB7XG4gICAgICBvYmoudW5rbm93bkFyZ3MgPSBhcnJheS5zbGljZShmaWVsZE5hbWVzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGRpc3Bvc2VMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5kaXNwb3NlcnMuZm9yRWFjaCgoZGlzcG9zZXIpID0+IGRpc3Bvc2VyKCkpO1xuICAgIHRoaXMuZGlzcG9zZXJzID0gW107XG4gIH1cblxuICBmb3JtYXRFdmVudExvZyh7IGV2ZW50TmFtZSwgZXZlbnRTb3VyY2UsIGhhbmRsZXJBcmdzIH0pIHtcbiAgICBjb25zdCBbZXZlbnQsIC4uLmFyZ3NdID0gaGFuZGxlckFyZ3M7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHsgYXJncywgZXZlbnQsIGV2ZW50TmFtZSwgZXZlbnRTb3VyY2UgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybWF0dGVyID0gdGhpcy5mb3JtYXR0ZXJzW2V2ZW50U291cmNlXT8uW2V2ZW50TmFtZV07XG4gICAgbGV0IGZvcm1hdHRlZEFyZ3MgPSBhcmdzO1xuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmb3JtYXR0ZWRBcmdzID0gZm9ybWF0dGVyKHsgYXJncywgZXZlbnQsIGV2ZW50TmFtZSwgZXZlbnRTb3VyY2UgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFmb3JtYXR0ZWRBcmdzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50RGF0YSA9IHt9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm9ybWF0dGVkQXJncykpIHtcbiAgICAgIGV2ZW50RGF0YS5hcmdzID0gZm9ybWF0dGVkQXJncztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXR0ZWRBcmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmFzc2lnbihldmVudERhdGEsIGZvcm1hdHRlZEFyZ3MpO1xuICAgIH1cblxuICAgIGlmIChldmVudFNvdXJjZSA9PT0gJ3dlYkNvbnRlbnRzJykge1xuICAgICAgT2JqZWN0LmFzc2lnbihldmVudERhdGEsIHRoaXMuZ2V0V2ViQ29udGVudHNEZXRhaWxzKGV2ZW50Py5zZW5kZXIpKTtcbiAgICB9XG5cbiAgICBjb25zdCB0aXRsZSA9IHRoaXMuZm9ybWF0XG4gICAgICAucmVwbGFjZSgne2V2ZW50U291cmNlfScsIGV2ZW50U291cmNlID09PSAnYXBwJyA/ICdBcHAnIDogJ1dlYkNvbnRlbnRzJylcbiAgICAgIC5yZXBsYWNlKCd7ZXZlbnROYW1lfScsIGV2ZW50TmFtZSk7XG5cbiAgICByZXR1cm4gW3RpdGxlLCBldmVudERhdGFdO1xuICB9XG5cbiAgZ2V0RXZlbnROYW1lcyhldmVudE1hcCkge1xuICAgIGlmICghZXZlbnRNYXAgfHwgdHlwZW9mIGV2ZW50TWFwICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhldmVudE1hcClcbiAgICAgIC5maWx0ZXIoKFtfLCBsaXN0ZW5dKSA9PiBsaXN0ZW4pXG4gICAgICAubWFwKChbZXZlbnROYW1lXSkgPT4gZXZlbnROYW1lKTtcbiAgfVxuXG4gIGdldFdlYkNvbnRlbnRzRGV0YWlscyh3ZWJDb250ZW50cykge1xuICAgIGlmICghd2ViQ29udGVudHM/LmxvYWRVUkwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2ViQ29udGVudHM6IHtcbiAgICAgICAgICBpZDogd2ViQ29udGVudHMuaWQsXG4gICAgICAgICAgdXJsOiB3ZWJDb250ZW50cy5nZXRVUkwoKSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRXZlbnQoeyBldmVudE5hbWUsIGV2ZW50U291cmNlLCBoYW5kbGVyQXJncyB9KSB7XG4gICAgY29uc3QgbG9nID0gdGhpcy5mb3JtYXRFdmVudExvZyh7IGV2ZW50TmFtZSwgZXZlbnRTb3VyY2UsIGhhbmRsZXJBcmdzIH0pO1xuICAgIGlmIChsb2cpIHtcbiAgICAgIGNvbnN0IGxvZ0ZucyA9IHRoaXMuc2NvcGUgPyB0aGlzLmxvZ2dlci5zY29wZSh0aGlzLnNjb3BlKSA6IHRoaXMubG9nZ2VyO1xuICAgICAgbG9nRm5zPy5bdGhpcy5sZXZlbF0/LiguLi5sb2cpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TG9nZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG4vKiogQHR5cGUge0VsZWN0cm9uLk1haW59ICovXG5sZXQgZWxlY3Ryb247XG50cnkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmUsaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4gIGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbn0gY2F0Y2gge1xuICBlbGVjdHJvbiA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRBcHBVc2VyRGF0YVBhdGgoKSB7XG4gICAgcmV0dXJuIGdldFBhdGgoJ3VzZXJEYXRhJyk7XG4gIH0sXG5cbiAgZ2V0TmFtZSxcblxuICBnZXRQYXRoLFxuXG4gIGdldFZlcnNpb24sXG5cbiAgZ2V0VmVyc2lvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFwcDogYCR7Z2V0TmFtZSgpfSAke2dldFZlcnNpb24oKX1gLFxuICAgICAgZWxlY3Ryb246IGBFbGVjdHJvbiAke3Byb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb259YCxcbiAgICAgIG9zOiBnZXRPc1ZlcnNpb24oKSxcbiAgICB9O1xuICB9LFxuXG4gIGlzRGV2KCkge1xuICAgIGNvbnN0IGFwcCA9IGdldEFwcCgpO1xuXG4gICAgaWYgKGFwcD8uaXNQYWNrYWdlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gIWFwcC5pc1BhY2thZ2VkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2Vzcy5leGVjUGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGV4ZWNGaWxlTmFtZSA9IHBhdGguYmFzZW5hbWUocHJvY2Vzcy5leGVjUGF0aCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBleGVjRmlsZU5hbWUuc3RhcnRzV2l0aCgnZWxlY3Ryb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCdcbiAgICAgIHx8IHByb2Nlc3MuZW52LkVMRUNUUk9OX0lTX0RFViA9PT0gJzEnO1xuICB9LFxuXG4gIGlzRWxlY3Ryb24oKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4ocHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbik7XG4gIH0sXG5cbiAgb25BcHBFdmVudChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBlbGVjdHJvbj8uYXBwPy5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVsZWN0cm9uPy5hcHA/Lm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH07XG4gIH0sXG5cbiAgb25BcHBSZWFkeShoYW5kbGVyKSB7XG4gICAgaWYgKGVsZWN0cm9uPy5hcHA/LmlzUmVhZHkoKSkge1xuICAgICAgaGFuZGxlcigpO1xuICAgIH0gZWxzZSBpZiAoZWxlY3Ryb24/LmFwcD8ub25jZSkge1xuICAgICAgZWxlY3Ryb24/LmFwcD8ub25jZSgncmVhZHknLCBoYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcigpO1xuICAgIH1cbiAgfSxcblxuICBvbkV2ZXJ5V2ViQ29udGVudHNFdmVudChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBlbGVjdHJvbj8ud2ViQ29udGVudHM/LmdldEFsbFdlYkNvbnRlbnRzKCkuZm9yRWFjaCgod2ViQ29udGVudHMpID0+IHtcbiAgICAgIHdlYkNvbnRlbnRzLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfSk7XG5cbiAgICBlbGVjdHJvbj8uYXBwPy5vbignd2ViLWNvbnRlbnRzLWNyZWF0ZWQnLCBvbldlYkNvbnRlbnRzQ3JlYXRlZCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZWxlY3Ryb24/LndlYkNvbnRlbnRzPy5nZXRBbGxXZWJDb250ZW50cygpLmZvckVhY2goKHdlYkNvbnRlbnRzKSA9PiB7XG4gICAgICAgIHdlYkNvbnRlbnRzLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIGVsZWN0cm9uPy5hcHA/Lm9mZignd2ViLWNvbnRlbnRzLWNyZWF0ZWQnLCBvbldlYkNvbnRlbnRzQ3JlYXRlZCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9uV2ViQ29udGVudHNDcmVhdGVkKF8sIHdlYkNvbnRlbnRzKSB7XG4gICAgICB3ZWJDb250ZW50cy5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIGFzeW5jIG1lc3NhZ2VzIHNlbnQgZnJvbSBvcHBvc2l0ZSBwcm9jZXNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFubmVsXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyXG4gICAqL1xuICBvbklwYyhjaGFubmVsLCBsaXN0ZW5lcikge1xuICAgIGdldElwYygpPy5vbihjaGFubmVsLCBsaXN0ZW5lcik7XG4gIH0sXG5cbiAgb25JcGNJbnZva2UoY2hhbm5lbCwgbGlzdGVuZXIpIHtcbiAgICBnZXRJcGMoKT8uaGFuZGxlPy4oY2hhbm5lbCwgbGlzdGVuZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtsb2dGdW5jdGlvbl1cbiAgICovXG4gIG9wZW5VcmwodXJsLCBsb2dGdW5jdGlvbiA9IGNvbnNvbGUuZXJyb3IpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgZ2V0RWxlY3Ryb25Nb2R1bGUoJ3NoZWxsJyk/Lm9wZW5FeHRlcm5hbCh1cmwpLmNhdGNoKGxvZ0Z1bmN0aW9uKTtcbiAgfSxcblxuICBzZXRQcmVsb2FkRmlsZUZvclNlc3Npb25zKHtcbiAgICBmaWxlUGF0aCxcbiAgICBpbmNsdWRlRnV0dXJlU2Vzc2lvbiA9IHRydWUsXG4gICAgZ2V0U2Vzc2lvbnMgPSAoKSA9PiBbZWxlY3Ryb24/LnNlc3Npb24/LmRlZmF1bHRTZXNzaW9uXSxcbiAgfSkge1xuICAgIGZvciAoY29uc3Qgc2Vzc2lvbiBvZiBnZXRTZXNzaW9ucygpLmZpbHRlcihCb29sZWFuKSkge1xuICAgICAgc2V0UHJlbG9hZChzZXNzaW9uKTtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZUZ1dHVyZVNlc3Npb24pIHtcbiAgICAgIGVsZWN0cm9uPy5hcHA/Lm9uKCdzZXNzaW9uLWNyZWF0ZWQnLCAoc2Vzc2lvbikgPT4ge1xuICAgICAgICBzZXRQcmVsb2FkKHNlc3Npb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTZXNzaW9ufSBzZXNzaW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0UHJlbG9hZChzZXNzaW9uKSB7XG4gICAgICBzZXNzaW9uLnNldFByZWxvYWRzKFsuLi5zZXNzaW9uLmdldFByZWxvYWRzKCksIGZpbGVQYXRoXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZW50IGEgbWVzc2FnZSB0byBvcHBvc2l0ZSBwcm9jZXNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFubmVsXG4gICAqIEBwYXJhbSB7YW55fSBtZXNzYWdlXG4gICAqL1xuICBzZW5kSXBjKGNoYW5uZWwsIG1lc3NhZ2UpIHtcbiAgICBpZiAocHJvY2Vzcy50eXBlID09PSAnYnJvd3NlcicpIHtcbiAgICAgIHNlbmRJcGNUb1JlbmRlcmVyKGNoYW5uZWwsIG1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgICBzZW5kSXBjVG9NYWluKGNoYW5uZWwsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfSxcblxuICBzaG93RXJyb3JCb3godGl0bGUsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBkaWFsb2cgPSBnZXRFbGVjdHJvbk1vZHVsZSgnZGlhbG9nJyk7XG4gICAgaWYgKCFkaWFsb2cpIHJldHVybjtcblxuICAgIGRpYWxvZy5zaG93RXJyb3JCb3godGl0bGUsIG1lc3NhZ2UpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gZ2V0QXBwKCkge1xuICByZXR1cm4gZ2V0RWxlY3Ryb25Nb2R1bGUoJ2FwcCcpO1xufVxuXG5mdW5jdGlvbiBnZXROYW1lKCkge1xuICBjb25zdCBhcHAgPSBnZXRBcHAoKTtcbiAgaWYgKCFhcHApIHJldHVybiBudWxsO1xuXG4gIHJldHVybiAnbmFtZScgaW4gYXBwID8gYXBwLm5hbWUgOiBhcHAuZ2V0TmFtZSgpO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVjdHJvbk1vZHVsZShuYW1lKSB7XG4gIHJldHVybiBlbGVjdHJvbj8uW25hbWVdIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldElwYygpIHtcbiAgaWYgKHByb2Nlc3MudHlwZSA9PT0gJ2Jyb3dzZXInICYmIGVsZWN0cm9uPy5pcGNNYWluKSB7XG4gICAgcmV0dXJuIGVsZWN0cm9uLmlwY01haW47XG4gIH1cblxuICBpZiAocHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInICYmIGVsZWN0cm9uPy5pcGNSZW5kZXJlcikge1xuICAgIHJldHVybiBlbGVjdHJvbi5pcGNSZW5kZXJlcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRWZXJzaW9uKCkge1xuICBjb25zdCBhcHAgPSBnZXRBcHAoKTtcbiAgaWYgKCFhcHApIHJldHVybiBudWxsO1xuXG4gIHJldHVybiAndmVyc2lvbicgaW4gYXBwID8gYXBwLnZlcnNpb24gOiBhcHAuZ2V0VmVyc2lvbigpO1xufVxuXG5mdW5jdGlvbiBnZXRPc1ZlcnNpb24oKSB7XG4gIGxldCBvc05hbWUgPSBvcy50eXBlKCkucmVwbGFjZSgnXycsICcgJyk7XG4gIGxldCBvc1ZlcnNpb24gPSBvcy5yZWxlYXNlKCk7XG5cbiAgaWYgKG9zTmFtZSA9PT0gJ0RhcndpbicpIHtcbiAgICBvc05hbWUgPSAnbWFjT1MnO1xuICAgIG9zVmVyc2lvbiA9IGdldE1hY09zVmVyc2lvbigpO1xuICB9XG5cbiAgcmV0dXJuIGAke29zTmFtZX0gJHtvc1ZlcnNpb259YDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFjT3NWZXJzaW9uKCkge1xuICBjb25zdCByZWxlYXNlID0gTnVtYmVyKG9zLnJlbGVhc2UoKS5zcGxpdCgnLicpWzBdKTtcbiAgaWYgKHJlbGVhc2UgPD0gMTkpIHtcbiAgICByZXR1cm4gYDEwLiR7cmVsZWFzZSAtIDR9YDtcbiAgfVxuXG4gIHJldHVybiByZWxlYXNlIC0gOTtcbn1cblxuZnVuY3Rpb24gZ2V0UGF0aChuYW1lKSB7XG4gIGNvbnN0IGFwcCA9IGdldEFwcCgpO1xuICBpZiAoIWFwcCkgcmV0dXJuIG51bGw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXBwLmdldFBhdGgobmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZW5kSXBjVG9NYWluKGNoYW5uZWwsIG1lc3NhZ2UpIHtcbiAgZ2V0SXBjKCk/LnNlbmQoY2hhbm5lbCwgbWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHNlbmRJcGNUb1JlbmRlcmVyKGNoYW5uZWwsIG1lc3NhZ2UpIHtcbiAgZWxlY3Ryb24/LkJyb3dzZXJXaW5kb3c/LmdldEFsbFdpbmRvd3MoKS5mb3JFYWNoKCh3bmQpID0+IHtcbiAgICBpZiAod25kLndlYkNvbnRlbnRzPy5pc0Rlc3Ryb3llZCgpID09PSBmYWxzZSkge1xuICAgICAgd25kLndlYkNvbnRlbnRzLnNlbmQoY2hhbm5lbCwgbWVzc2FnZSk7XG4gICAgfVxuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZWxlY3Ryb25BcGkgPSByZXF1aXJlKCcuL2VsZWN0cm9uQXBpJyk7XG5jb25zdCB7IGluaXRpYWxpemUgfSA9IHJlcXVpcmUoJy4vaW5pdGlhbGl6ZScpO1xuY29uc3QgdHJhbnNwb3J0Q29uc29sZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9jb25zb2xlJyk7XG5jb25zdCB0cmFuc3BvcnRGaWxlID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2ZpbGUnKTtcbmNvbnN0IHRyYW5zcG9ydFJlbW90ZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9yZW1vdGUnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2NvcmUvTG9nZ2VyJyk7XG5jb25zdCBFcnJvckhhbmRsZXIgPSByZXF1aXJlKCcuL0Vycm9ySGFuZGxlcicpO1xuY29uc3QgRXZlbnRMb2dnZXIgPSByZXF1aXJlKCcuL0V2ZW50TG9nZ2VyJyk7XG5cbmNvbnN0IGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKHtcbiAgZXJyb3JIYW5kbGVyOiBuZXcgRXJyb3JIYW5kbGVyKCksXG4gIGV2ZW50TG9nZ2VyOiBuZXcgRXZlbnRMb2dnZXIoKSxcbiAgaW5pdGlhbGl6ZUZuOiBpbml0aWFsaXplLFxuICBpc0RldjogZWxlY3Ryb25BcGkuaXNEZXYoKSxcbiAgbG9nSWQ6ICdkZWZhdWx0JyxcbiAgdHJhbnNwb3J0RmFjdG9yaWVzOiB7XG4gICAgY29uc29sZTogdHJhbnNwb3J0Q29uc29sZSxcbiAgICBmaWxlOiB0cmFuc3BvcnRGaWxlLFxuICAgIHJlbW90ZTogdHJhbnNwb3J0UmVtb3RlLFxuICB9LFxuICB2YXJpYWJsZXM6IHtcbiAgICBwcm9jZXNzVHlwZTogJ21haW4nLFxuICB9LFxufSk7XG5cbmRlZmF1bHRMb2dnZXIucHJvY2Vzc0ludGVybmFsRXJyb3JGbiA9IChlKSA9PiB7XG4gIGRlZmF1bHRMb2dnZXIudHJhbnNwb3J0cy5jb25zb2xlLndyaXRlRm4oe1xuICAgIG1lc3NhZ2U6IHtcbiAgICAgIGRhdGE6IFsnVW5oYW5kbGVkIGVsZWN0cm9uLWxvZyBlcnJvcicsIGVdLFxuICAgICAgbGV2ZWw6ICdlcnJvcicsXG4gICAgfSxcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRMb2dnZXI7XG5tb2R1bGUuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG5cbmVsZWN0cm9uQXBpLm9uSXBjKCdfX0VMRUNUUk9OX0xPR19fJywgKF8sIG1lc3NhZ2UpID0+IHtcbiAgaWYgKG1lc3NhZ2Uuc2NvcGUpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UobWVzc2FnZSkuc2NvcGUobWVzc2FnZS5zY29wZSk7XG4gIH1cblxuICBjb25zdCBkYXRlID0gbmV3IERhdGUobWVzc2FnZS5kYXRlKTtcbiAgcHJvY2Vzc01lc3NhZ2Uoe1xuICAgIC4uLm1lc3NhZ2UsXG4gICAgZGF0ZTogZGF0ZS5nZXRUaW1lKCkgPyBkYXRlIDogbmV3IERhdGUoKSxcbiAgfSk7XG59KTtcblxuZWxlY3Ryb25BcGkub25JcGNJbnZva2UoJ19fRUxFQ1RST05fTE9HX18nLCAoXywgeyBjbWQgPSAnJywgbG9nSWQgfSkgPT4ge1xuICBzd2l0Y2ggKGNtZCkge1xuICAgIGNhc2UgJ2dldE9wdGlvbnMnOiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoeyBsb2dJZCB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxldmVsczogbG9nZ2VyLmxldmVscyxcbiAgICAgICAgbG9nSWQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHByb2Nlc3NNZXNzYWdlKHsgZGF0YTogW2BVbmtub3duIGNtZCAnJHtjbWR9J2BdLCBsZXZlbDogJ2Vycm9yJyB9KTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gIExvZ2dlci5nZXRJbnN0YW5jZShtZXNzYWdlKT8ucHJvY2Vzc01lc3NhZ2UobWVzc2FnZSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBlbGVjdHJvbkFwaSA9IHJlcXVpcmUoJy4vZWxlY3Ryb25BcGknKTtcbmNvbnN0IHByZWxvYWRJbml0aWFsaXplRm4gPSByZXF1aXJlKCcuLi9yZW5kZXJlci9lbGVjdHJvbi1sb2ctcHJlbG9hZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdGlhbGl6ZSh7XG4gICAgZ2V0U2Vzc2lvbnMsXG4gICAgaW5jbHVkZUZ1dHVyZVNlc3Npb24sXG4gICAgbG9nZ2VyLFxuICAgIHByZWxvYWQgPSB0cnVlLFxuICAgIHNweVJlbmRlcmVyQ29uc29sZSA9IGZhbHNlLFxuICB9KSB7XG4gICAgZWxlY3Ryb25BcGkub25BcHBSZWFkeSgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocHJlbG9hZCkge1xuICAgICAgICAgIGluaXRpYWxpemVQcmVsb2FkKHtcbiAgICAgICAgICAgIGdldFNlc3Npb25zLFxuICAgICAgICAgICAgaW5jbHVkZUZ1dHVyZVNlc3Npb24sXG4gICAgICAgICAgICBwcmVsb2FkT3B0aW9uOiBwcmVsb2FkLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNweVJlbmRlcmVyQ29uc29sZSkge1xuICAgICAgICAgIGluaXRpYWxpemVTcHlSZW5kZXJlckNvbnNvbGUoeyBsb2dnZXIgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dnZXIud2FybihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxufTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVByZWxvYWQoe1xuICBnZXRTZXNzaW9ucyxcbiAgaW5jbHVkZUZ1dHVyZVNlc3Npb24sXG4gIHByZWxvYWRPcHRpb24sXG59KSB7XG4gIGxldCBwcmVsb2FkUGF0aCA9IHR5cGVvZiBwcmVsb2FkT3B0aW9uID09PSAnc3RyaW5nJ1xuICAgID8gcHJlbG9hZE9wdGlvblxuICAgIDogcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uL3JlbmRlcmVyL2VsZWN0cm9uLWxvZy1wcmVsb2FkLmpzJyk7XG5cbiAgaWYgKCFmcy5leGlzdHNTeW5jKHByZWxvYWRQYXRoKSkge1xuICAgIHByZWxvYWRQYXRoID0gcGF0aC5qb2luKFxuICAgICAgZWxlY3Ryb25BcGkuZ2V0QXBwVXNlckRhdGFQYXRoKCkgfHwgb3MudG1wZGlyKCksXG4gICAgICAnZWxlY3Ryb24tbG9nLXByZWxvYWQuanMnLFxuICAgICk7XG4gICAgY29uc3QgcHJlbG9hZENvZGUgPSBgXG4gICAgICB0cnkge1xuICAgICAgICAoJHtwcmVsb2FkSW5pdGlhbGl6ZUZuLnRvU3RyaW5nKCl9KShyZXF1aXJlKCdlbGVjdHJvbicpKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfVxuICAgIGA7XG4gICAgZnMud3JpdGVGaWxlU3luYyhwcmVsb2FkUGF0aCwgcHJlbG9hZENvZGUsICd1dGY4Jyk7XG4gIH1cblxuICBlbGVjdHJvbkFwaS5zZXRQcmVsb2FkRmlsZUZvclNlc3Npb25zKHtcbiAgICBmaWxlUGF0aDogcHJlbG9hZFBhdGgsXG4gICAgaW5jbHVkZUZ1dHVyZVNlc3Npb24sXG4gICAgZ2V0U2Vzc2lvbnMsXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplU3B5UmVuZGVyZXJDb25zb2xlKHsgbG9nZ2VyIH0pIHtcbiAgY29uc3QgbGV2ZWxzID0gWyd2ZXJib3NlJywgJ2luZm8nLCAnd2FybmluZycsICdlcnJvciddO1xuICBlbGVjdHJvbkFwaS5vbkV2ZXJ5V2ViQ29udGVudHNFdmVudChcbiAgICAnY29uc29sZS1tZXNzYWdlJyxcbiAgICAoZXZlbnQsIGxldmVsLCBtZXNzYWdlKSA9PiB7XG4gICAgICBsb2dnZXIucHJvY2Vzc01lc3NhZ2Uoe1xuICAgICAgICBkYXRhOiBbbWVzc2FnZV0sXG4gICAgICAgIGxldmVsOiBsZXZlbHNbbGV2ZWxdLFxuICAgICAgICB2YXJpYWJsZXM6IHsgcHJvY2Vzc1R5cGU6ICdyZW5kZXJlcicgfSxcbiAgICAgIH0pO1xuICAgIH0sXG4gICk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdHJhbnNmb3JtIH0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uY2F0Rmlyc3RTdHJpbmdFbGVtZW50cyxcbiAgZm9ybWF0U2NvcGUsXG4gIGZvcm1hdFRleHQsXG4gIGZvcm1hdFZhcmlhYmxlcyxcbiAgdGltZVpvbmVGcm9tT2Zmc2V0LFxuXG4gIGZvcm1hdCh7IG1lc3NhZ2UsIGxvZ2dlciwgdHJhbnNwb3J0LCBkYXRhID0gbWVzc2FnZT8uZGF0YSB9KSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdHJhbnNwb3J0LmZvcm1hdCkge1xuICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtKHtcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgICB0cmFuc2Zvcm1zOiBbZm9ybWF0VmFyaWFibGVzLCBmb3JtYXRTY29wZSwgZm9ybWF0VGV4dF0sXG4gICAgICAgICAgdHJhbnNwb3J0LFxuICAgICAgICAgIGluaXRpYWxEYXRhOiBbdHJhbnNwb3J0LmZvcm1hdCwgLi4uZGF0YV0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdmdW5jdGlvbic6IHtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydC5mb3JtYXQoe1xuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgbGV2ZWw6IG1lc3NhZ2U/LmxldmVsIHx8ICdpbmZvJyxcbiAgICAgICAgICBsb2dnZXIsXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICB0cmFuc3BvcnQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbn07XG5cbi8qKlxuICogVGhlIGZpcnN0IGFyZ3VtZW50IG9mIGNvbnNvbGUubG9nIG1heSBjb250YWluIGEgdGVtcGxhdGUuIEluIHRoZSBsaWJyYXJ5XG4gKiB0aGUgZmlyc3QgZWxlbWVudCBpcyBhIHN0cmluZyByZWxhdGVkIHRvIHRyYW5zcG9ydHMuY29uc29sZS5mb3JtYXQuIFNvXG4gKiB0aGlzIGZ1bmN0aW9uIGNvbmNhdGVuYXRlcyBmaXJzdCB0d28gZWxlbWVudHMgdG8gbWFrZSB0ZW1wbGF0ZXMgbGlrZSAlZFxuICogd29ya1xuICogQHBhcmFtIHsqW119IGRhdGFcbiAqIEByZXR1cm4geypbXX1cbiAqL1xuZnVuY3Rpb24gY29uY2F0Rmlyc3RTdHJpbmdFbGVtZW50cyh7IGRhdGEgfSkge1xuICBpZiAodHlwZW9mIGRhdGFbMF0gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkYXRhWzFdICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGFbMF0ubWF0Y2goLyVbMWNkZmlPb3NdLykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJldHVybiBbYCR7ZGF0YVswXX0gJHtkYXRhWzFdfWAsIC4uLmRhdGEuc2xpY2UoMildO1xufVxuXG5mdW5jdGlvbiB0aW1lWm9uZUZyb21PZmZzZXQobWludXRlc09mZnNldCkge1xuICBjb25zdCBtaW51dGVzUG9zaXRpdmUgPSBNYXRoLmFicyhtaW51dGVzT2Zmc2V0KTtcbiAgY29uc3Qgc2lnbiA9IG1pbnV0ZXNPZmZzZXQgPj0gMCA/ICctJyA6ICcrJztcbiAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKG1pbnV0ZXNQb3NpdGl2ZSAvIDYwKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XG4gIGNvbnN0IG1pbnV0ZXMgPSAobWludXRlc1Bvc2l0aXZlICUgNjApLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgcmV0dXJuIGAke3NpZ259JHtob3Vyc306JHttaW51dGVzfWA7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFNjb3BlKHsgZGF0YSwgbG9nZ2VyLCBtZXNzYWdlIH0pIHtcbiAgY29uc3QgeyBkZWZhdWx0TGFiZWwsIGxhYmVsTGVuZ3RoIH0gPSBsb2dnZXI/LnNjb3BlIHx8IHt9O1xuICBjb25zdCB0ZW1wbGF0ZSA9IGRhdGFbMF07XG4gIGxldCBsYWJlbCA9IG1lc3NhZ2Uuc2NvcGU7XG5cbiAgaWYgKCFsYWJlbCkge1xuICAgIGxhYmVsID0gZGVmYXVsdExhYmVsO1xuICB9XG5cbiAgbGV0IHNjb3BlVGV4dDtcbiAgaWYgKGxhYmVsID09PSAnJykge1xuICAgIHNjb3BlVGV4dCA9IGxhYmVsTGVuZ3RoID4gMCA/ICcnLnBhZEVuZChsYWJlbExlbmd0aCArIDMpIDogJyc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJykge1xuICAgIHNjb3BlVGV4dCA9IGAgKCR7bGFiZWx9KWAucGFkRW5kKGxhYmVsTGVuZ3RoICsgMyk7XG4gIH0gZWxzZSB7XG4gICAgc2NvcGVUZXh0ID0gJyc7XG4gIH1cblxuICBkYXRhWzBdID0gdGVtcGxhdGUucmVwbGFjZSgne3Njb3BlfScsIHNjb3BlVGV4dCk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRWYXJpYWJsZXMoeyBkYXRhLCBtZXNzYWdlIH0pIHtcbiAgbGV0IHRlbXBsYXRlID0gZGF0YVswXTtcbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8vIEFkZCBhZGRpdGlvbmFsIHNwYWNlIHRvIHRoZSBlbmQgb2Yge2xldmVsfV0gdGVtcGxhdGUgdG8gYWxpZ24gbWVzc2FnZXNcbiAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKCd7bGV2ZWx9XScsIGAke21lc3NhZ2UubGV2ZWx9XWAucGFkRW5kKDYsICcgJykpO1xuXG4gIGNvbnN0IGRhdGUgPSBtZXNzYWdlLmRhdGUgfHwgbmV3IERhdGUoKTtcbiAgZGF0YVswXSA9IHRlbXBsYXRlXG4gICAgLnJlcGxhY2UoL1xceyhcXHcrKX0vZywgKHN1YnN0cmluZywgbmFtZSkgPT4ge1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgJ2xldmVsJzogcmV0dXJuIG1lc3NhZ2UubGV2ZWwgfHwgJ2luZm8nO1xuICAgICAgICBjYXNlICdsb2dJZCc6IHJldHVybiBtZXNzYWdlLmxvZ0lkO1xuXG4gICAgICAgIGNhc2UgJ3knOiByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgY2FzZSAnbSc6IHJldHVybiAoZGF0ZS5nZXRNb250aCgpICsgMSkudG9TdHJpbmcoMTApLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgIGNhc2UgJ2QnOiByZXR1cm4gZGF0ZS5nZXREYXRlKCkudG9TdHJpbmcoMTApLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgIGNhc2UgJ2gnOiByZXR1cm4gZGF0ZS5nZXRIb3VycygpLnRvU3RyaW5nKDEwKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICBjYXNlICdpJzogcmV0dXJuIGRhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKDEwKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICBjYXNlICdzJzogcmV0dXJuIGRhdGUuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKDEwKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICBjYXNlICdtcyc6IHJldHVybiBkYXRlLmdldE1pbGxpc2Vjb25kcygpLnRvU3RyaW5nKDEwKS5wYWRTdGFydCgzLCAnMCcpO1xuICAgICAgICBjYXNlICd6JzogcmV0dXJuIHRpbWVab25lRnJvbU9mZnNldChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgICAgICBjYXNlICdpc28nOiByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xuXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZS52YXJpYWJsZXM/LltuYW1lXSB8fCBzdWJzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIC50cmltKCk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRleHQoeyBkYXRhIH0pIHtcbiAgY29uc3QgdGVtcGxhdGUgPSBkYXRhWzBdO1xuICBpZiAodHlwZW9mIHRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgY29uc3QgdGV4dFRwbFBvc2l0aW9uID0gdGVtcGxhdGUubGFzdEluZGV4T2YoJ3t0ZXh0fScpO1xuICBpZiAodGV4dFRwbFBvc2l0aW9uID09PSB0ZW1wbGF0ZS5sZW5ndGggLSA2KSB7XG4gICAgZGF0YVswXSA9IHRlbXBsYXRlLnJlcGxhY2UoL1xccz97dGV4dH0vLCAnJyk7XG4gICAgaWYgKGRhdGFbMF0gPT09ICcnKSB7XG4gICAgICBkYXRhLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBjb25zdCB0ZW1wbGF0ZVBpZWNlcyA9IHRlbXBsYXRlLnNwbGl0KCd7dGV4dH0nKTtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gIGlmICh0ZW1wbGF0ZVBpZWNlc1swXSAhPT0gJycpIHtcbiAgICByZXN1bHQucHVzaCh0ZW1wbGF0ZVBpZWNlc1swXSk7XG4gIH1cblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGRhdGEuc2xpY2UoMSkpO1xuXG4gIGlmICh0ZW1wbGF0ZVBpZWNlc1sxXSAhPT0gJycpIHtcbiAgICByZXN1bHQucHVzaCh0ZW1wbGF0ZVBpZWNlc1sxXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2VyaWFsaXplLFxuXG4gIG1heERlcHRoKHsgZGF0YSwgdHJhbnNwb3J0LCBkZXB0aCA9IHRyYW5zcG9ydD8uZGVwdGggPz8gNiB9KSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBpZiAoZGVwdGggPCAxKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkgcmV0dXJuICdbYXJyYXldJztcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YSkgcmV0dXJuICdbb2JqZWN0XSc7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5tYXAoKGNoaWxkKSA9PiBtb2R1bGUuZXhwb3J0cy5tYXhEZXB0aCh7XG4gICAgICAgIGRhdGE6IGNoaWxkLFxuICAgICAgICBkZXB0aDogZGVwdGggLSAxLFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhLnRvSVNPU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvLyBub2luc3BlY3Rpb24gUG9pbnRsZXNzQm9vbGVhbkV4cHJlc3Npb25KU1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdKc29uID0ge307XG4gICAgZm9yIChjb25zdCBpIGluIGRhdGEpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGkpKSBjb250aW51ZTtcbiAgICAgIG5ld0pzb25baV0gPSBtb2R1bGUuZXhwb3J0cy5tYXhEZXB0aCh7XG4gICAgICAgIGRhdGE6IGRhdGFbaV0sXG4gICAgICAgIGRlcHRoOiBkZXB0aCAtIDEsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3SnNvbjtcbiAgfSxcblxuICB0b0pTT04oeyBkYXRhIH0pIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhLCBjcmVhdGVTZXJpYWxpemVyKCkpKTtcbiAgfSxcblxuICB0b1N0cmluZyh7IGRhdGEsIHRyYW5zcG9ydCB9KSB7XG4gICAgY29uc3QgaW5zcGVjdE9wdGlvbnMgPSB0cmFuc3BvcnQ/Lmluc3BlY3RPcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3Qgc2ltcGxpZmllZERhdGEgPSBkYXRhLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeShpdGVtLCBjcmVhdGVTZXJpYWxpemVyKCksICcgICcpO1xuICAgICAgICByZXR1cm4gc3RyID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBKU09OLnBhcnNlKHN0cik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBzb21lIHJhcmUgY2FzZXMgd2hlbiBhbiBpdGVtIGNhbid0IGJlIHNpbXBsaWZpZWQuXG4gICAgICAgIC8vIEluIHRoYXQgY2FzZSwgaXQncyBmaW5lIHRvIHBhc3MgaXQgdG8gdXRpbC5mb3JtYXQgZGlyZWN0bHkuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHV0aWwuZm9ybWF0V2l0aE9wdGlvbnMoaW5zcGVjdE9wdGlvbnMsIC4uLnNpbXBsaWZpZWREYXRhKTtcbiAgfSxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnM/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWFsaXplTWFwQW5kU2V0P1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6ZXIob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHNlZW4uYWRkKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VyaWFsaXplKGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnM/XG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZShrZXksIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgc2VyaWFsaXplTWFwQW5kU2V0ID0gb3B0aW9ucz8uc2VyaWFsaXplTWFwQW5kU2V0ICE9PSBmYWxzZTtcblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiB2YWx1ZS5zdGFjaztcbiAgfVxuXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGBbZnVuY3Rpb25dICR7dmFsdWUudG9TdHJpbmcoKX1gO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZU1hcEFuZFNldCAmJiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCAmJiBPYmplY3QuZnJvbUVudHJpZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVNYXBBbmRTZXQgJiYgdmFsdWUgaW5zdGFuY2VvZiBTZXQgJiYgQXJyYXkuZnJvbSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRyYW5zZm9ybVN0eWxlcyxcblxuICBhcHBseUFuc2lTdHlsZXMoeyBkYXRhIH0pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtU3R5bGVzKGRhdGEsIHN0eWxlVG9BbnNpLCByZXNldEFuc2lTdHlsZSk7XG4gIH0sXG5cbiAgcmVtb3ZlU3R5bGVzKHsgZGF0YSB9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVN0eWxlcyhkYXRhLCAoKSA9PiAnJyk7XG4gIH0sXG59O1xuXG5jb25zdCBBTlNJX0NPTE9SUyA9IHtcbiAgdW5zZXQ6ICdcXHgxYlswbScsXG4gIGJsYWNrOiAnXFx4MWJbMzBtJyxcbiAgcmVkOiAnXFx4MWJbMzFtJyxcbiAgZ3JlZW46ICdcXHgxYlszMm0nLFxuICB5ZWxsb3c6ICdcXHgxYlszM20nLFxuICBibHVlOiAnXFx4MWJbMzRtJyxcbiAgbWFnZW50YTogJ1xceDFiWzM1bScsXG4gIGN5YW46ICdcXHgxYlszNm0nLFxuICB3aGl0ZTogJ1xceDFiWzM3bScsXG59O1xuXG5mdW5jdGlvbiBzdHlsZVRvQW5zaShzdHlsZSkge1xuICBjb25zdCBjb2xvciA9IHN0eWxlLnJlcGxhY2UoL2NvbG9yOlxccyooXFx3KykuKi8sICckMScpLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBBTlNJX0NPTE9SU1tjb2xvcl0gfHwgJyc7XG59XG5cbmZ1bmN0aW9uIHJlc2V0QW5zaVN0eWxlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nICsgQU5TSV9DT0xPUlMudW5zZXQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0eWxlcyhkYXRhLCBvblN0eWxlRm91bmQsIG9uU3R5bGVBcHBsaWVkKSB7XG4gIGNvbnN0IGZvdW5kU3R5bGVzID0ge307XG5cbiAgcmV0dXJuIGRhdGEucmVkdWNlKChyZXN1bHQsIGl0ZW0sIGluZGV4LCBhcnJheSkgPT4ge1xuICAgIGlmIChmb3VuZFN0eWxlc1tpbmRleF0pIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IHZhbHVlSW5kZXggPSBpbmRleDtcbiAgICAgIGxldCBzdHlsZUFwcGxpZWQgPSBmYWxzZTtcblxuICAgICAgaXRlbSA9IGl0ZW0ucmVwbGFjZSgvJVsxY2RmaU9vc10vZywgKG1hdGNoKSA9PiB7XG4gICAgICAgIHZhbHVlSW5kZXggKz0gMTtcblxuICAgICAgICBpZiAobWF0Y2ggIT09ICclYycpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdHlsZSA9IGFycmF5W3ZhbHVlSW5kZXhdO1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGZvdW5kU3R5bGVzW3ZhbHVlSW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICBzdHlsZUFwcGxpZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBvblN0eWxlRm91bmQoc3R5bGUsIGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzdHlsZUFwcGxpZWQgJiYgb25TdHlsZUFwcGxpZWQpIHtcbiAgICAgICAgaXRlbSA9IG9uU3R5bGVBcHBsaWVkKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIFtdKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7IHRyYW5zZm9ybSB9O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm0oe1xuICBsb2dnZXIsXG4gIG1lc3NhZ2UsXG4gIHRyYW5zcG9ydCxcblxuICBpbml0aWFsRGF0YSA9IG1lc3NhZ2U/LmRhdGEgfHwgW10sXG4gIHRyYW5zZm9ybXMgPSB0cmFuc3BvcnQ/LnRyYW5zZm9ybXMsXG59KSB7XG4gIHJldHVybiB0cmFuc2Zvcm1zLnJlZHVjZSgoZGF0YSwgdHJhbnMpID0+IHtcbiAgICBpZiAodHlwZW9mIHRyYW5zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdHJhbnMoeyBkYXRhLCBsb2dnZXIsIG1lc3NhZ2UsIHRyYW5zcG9ydCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfSwgaW5pdGlhbERhdGEpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cbmNvbnN0IHsgY29uY2F0Rmlyc3RTdHJpbmdFbGVtZW50cywgZm9ybWF0IH0gPSByZXF1aXJlKCcuLi90cmFuc2Zvcm1zL2Zvcm1hdCcpO1xuY29uc3QgeyBtYXhEZXB0aCwgdG9KU09OIH0gPSByZXF1aXJlKCcuLi90cmFuc2Zvcm1zL29iamVjdCcpO1xuY29uc3QgeyBhcHBseUFuc2lTdHlsZXMsIHJlbW92ZVN0eWxlcyB9ID0gcmVxdWlyZSgnLi4vdHJhbnNmb3Jtcy9zdHlsZScpO1xuY29uc3QgeyB0cmFuc2Zvcm0gfSA9IHJlcXVpcmUoJy4uL3RyYW5zZm9ybXMvdHJhbnNmb3JtJyk7XG5cbmNvbnN0IGNvbnNvbGVNZXRob2RzID0ge1xuICBlcnJvcjogY29uc29sZS5lcnJvcixcbiAgd2FybjogY29uc29sZS53YXJuLFxuICBpbmZvOiBjb25zb2xlLmluZm8sXG4gIHZlcmJvc2U6IGNvbnNvbGUuaW5mbyxcbiAgZGVidWc6IGNvbnNvbGUuZGVidWcsXG4gIHNpbGx5OiBjb25zb2xlLmRlYnVnLFxuICBsb2c6IGNvbnNvbGUubG9nLFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlVHJhbnNwb3J0RmFjdG9yeTtcblxuY29uc3Qgc2VwYXJhdG9yID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICc+JyA6ICfigLonO1xuY29uc3QgREVGQVVMVF9GT1JNQVQgPSBgJWN7aH06e2l9OntzfS57bXN9e3Njb3BlfSVjICR7c2VwYXJhdG9yfSB7dGV4dH1gO1xuXG5PYmplY3QuYXNzaWduKGNvbnNvbGVUcmFuc3BvcnRGYWN0b3J5LCB7XG4gIERFRkFVTFRfRk9STUFULFxufSk7XG5cbmZ1bmN0aW9uIGNvbnNvbGVUcmFuc3BvcnRGYWN0b3J5KGxvZ2dlcikge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0cmFuc3BvcnQsIHtcbiAgICBmb3JtYXQ6IERFRkFVTFRfRk9STUFULFxuICAgIGxldmVsOiAnc2lsbHknLFxuICAgIHRyYW5zZm9ybXM6IFtcbiAgICAgIGFkZFRlbXBsYXRlQ29sb3JzLFxuICAgICAgZm9ybWF0LFxuICAgICAgZm9ybWF0U3R5bGVzLFxuICAgICAgY29uY2F0Rmlyc3RTdHJpbmdFbGVtZW50cyxcbiAgICAgIG1heERlcHRoLFxuICAgICAgdG9KU09OLFxuICAgIF0sXG4gICAgdXNlU3R5bGVzOiBwcm9jZXNzLmVudi5GT1JDRV9TVFlMRVMsXG5cbiAgICB3cml0ZUZuKHsgbWVzc2FnZSB9KSB7XG4gICAgICBjb25zdCBjb25zb2xlTG9nRm4gPSBjb25zb2xlTWV0aG9kc1ttZXNzYWdlLmxldmVsXSB8fCBjb25zb2xlTWV0aG9kcy5pbmZvO1xuICAgICAgY29uc29sZUxvZ0ZuKC4uLm1lc3NhZ2UuZGF0YSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdHJhbnNwb3J0KG1lc3NhZ2UpIHtcbiAgICBjb25zdCBkYXRhID0gdHJhbnNmb3JtKHsgbG9nZ2VyLCBtZXNzYWdlLCB0cmFuc3BvcnQgfSk7XG4gICAgdHJhbnNwb3J0LndyaXRlRm4oe1xuICAgICAgbWVzc2FnZTogeyAuLi5tZXNzYWdlLCBkYXRhIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkVGVtcGxhdGVDb2xvcnMoeyBkYXRhLCBtZXNzYWdlLCB0cmFuc3BvcnQgfSkge1xuICBpZiAodHJhbnNwb3J0LmZvcm1hdCAhPT0gREVGQVVMVF9GT1JNQVQpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJldHVybiBbYGNvbG9yOiR7bGV2ZWxUb1N0eWxlKG1lc3NhZ2UubGV2ZWwpfWAsICdjb2xvcjp1bnNldCcsIC4uLmRhdGFdO1xufVxuXG5mdW5jdGlvbiBjYW5Vc2VTdHlsZXModXNlU3R5bGVWYWx1ZSwgbGV2ZWwpIHtcbiAgaWYgKHR5cGVvZiB1c2VTdHlsZVZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gdXNlU3R5bGVWYWx1ZTtcbiAgfVxuXG4gIGNvbnN0IHVzZVN0ZGVyciA9IGxldmVsID09PSAnZXJyb3InIHx8IGxldmVsID09PSAnd2Fybic7XG4gIGNvbnN0IHN0cmVhbSA9IHVzZVN0ZGVyciA/IHByb2Nlc3Muc3RkZXJyIDogcHJvY2Vzcy5zdGRvdXQ7XG4gIHJldHVybiBzdHJlYW0gJiYgc3RyZWFtLmlzVFRZO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRTdHlsZXMoYXJncykge1xuICBjb25zdCB7IG1lc3NhZ2UsIHRyYW5zcG9ydCB9ID0gYXJncztcbiAgY29uc3QgdXNlU3R5bGVzID0gY2FuVXNlU3R5bGVzKHRyYW5zcG9ydC51c2VTdHlsZXMsIG1lc3NhZ2UubGV2ZWwpO1xuICBjb25zdCBuZXh0VHJhbnNmb3JtID0gdXNlU3R5bGVzID8gYXBwbHlBbnNpU3R5bGVzIDogcmVtb3ZlU3R5bGVzO1xuICByZXR1cm4gbmV4dFRyYW5zZm9ybShhcmdzKTtcbn1cblxuZnVuY3Rpb24gbGV2ZWxUb1N0eWxlKGxldmVsKSB7XG4gIGNvbnN0IG1hcCA9IHsgZXJyb3I6ICdyZWQnLCB3YXJuOiAneWVsbG93JywgaW5mbzogJ2N5YW4nLCBkZWZhdWx0OiAndW5zZXQnIH07XG4gIHJldHVybiBtYXBbbGV2ZWxdIHx8IG1hcC5kZWZhdWx0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcblxuY2xhc3MgRmlsZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGFzeW5jV3JpdGVRdWV1ZSA9IFtdO1xuICBieXRlc1dyaXR0ZW4gPSAwO1xuICBoYXNBY3RpdmVBc3luY1dyaXRpbmcgPSBmYWxzZTtcbiAgcGF0aCA9IG51bGw7XG4gIGluaXRpYWxTaXplID0gdW5kZWZpbmVkO1xuICB3cml0ZU9wdGlvbnMgPSBudWxsO1xuICB3cml0ZUFzeW5jID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhdGgsXG4gICAgd3JpdGVPcHRpb25zID0geyBlbmNvZGluZzogJ3V0ZjgnLCBmbGFnOiAnYScsIG1vZGU6IDBvNjY2IH0sXG4gICAgd3JpdGVBc3luYyA9IGZhbHNlLFxuICB9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy53cml0ZU9wdGlvbnMgPSB3cml0ZU9wdGlvbnM7XG4gICAgdGhpcy53cml0ZUFzeW5jID0gd3JpdGVBc3luYztcbiAgfVxuXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNpemUoKTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRyeSB7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKHRoaXMucGF0aCwgJycsIHtcbiAgICAgICAgbW9kZTogdGhpcy53cml0ZU9wdGlvbnMubW9kZSxcbiAgICAgICAgZmxhZzogJ3cnLFxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUsIHRoaXMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNyb3AoYnl0ZXNBZnRlcikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gcmVhZEZpbGVTeW5jRnJvbUVuZCh0aGlzLnBhdGgsIGJ5dGVzQWZ0ZXIgfHwgNDA5Nik7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB0aGlzLndyaXRlTGluZShgW2xvZyBjcm9wcGVkXSR7b3MuRU9MfSR7Y29udGVudH1gKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmVtaXQoXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgIG5ldyBFcnJvcihgQ291bGRuJ3QgY3JvcCBmaWxlICR7dGhpcy5wYXRofS4gJHtlLm1lc3NhZ2V9YCksXG4gICAgICAgIHRoaXMsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGdldFNpemUoKSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbFNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyh0aGlzLnBhdGgpO1xuICAgICAgICB0aGlzLmluaXRpYWxTaXplID0gc3RhdHMuc2l6ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsU2l6ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbFNpemUgKyB0aGlzLmJ5dGVzV3JpdHRlbjtcbiAgfVxuXG4gIGluY3JlYXNlQnl0ZXNXcml0dGVuQ291bnRlcih0ZXh0KSB7XG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gKz0gQnVmZmVyLmJ5dGVMZW5ndGgodGV4dCwgdGhpcy53cml0ZU9wdGlvbnMuZW5jb2RpbmcpO1xuICB9XG5cbiAgaXNOdWxsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG5leHRBc3luY1dyaXRlKCkge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuaGFzQWN0aXZlQXN5bmNXcml0aW5nIHx8IHRoaXMuYXN5bmNXcml0ZVF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHQgPSB0aGlzLmFzeW5jV3JpdGVRdWV1ZS5qb2luKCcnKTtcbiAgICB0aGlzLmFzeW5jV3JpdGVRdWV1ZSA9IFtdO1xuICAgIHRoaXMuaGFzQWN0aXZlQXN5bmNXcml0aW5nID0gdHJ1ZTtcblxuICAgIGZzLndyaXRlRmlsZSh0aGlzLnBhdGgsIHRleHQsIHRoaXMud3JpdGVPcHRpb25zLCAoZSkgPT4ge1xuICAgICAgZmlsZS5oYXNBY3RpdmVBc3luY1dyaXRpbmcgPSBmYWxzZTtcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgZmlsZS5lbWl0KFxuICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgbmV3IEVycm9yKGBDb3VsZG4ndCB3cml0ZSB0byAke2ZpbGUucGF0aH0uICR7ZS5tZXNzYWdlfWApLFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWxlLmluY3JlYXNlQnl0ZXNXcml0dGVuQ291bnRlcih0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgZmlsZS5uZXh0QXN5bmNXcml0ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5pbml0aWFsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoO1xuICB9XG5cbiAgd3JpdGVMaW5lKHRleHQpIHtcbiAgICB0ZXh0ICs9IG9zLkVPTDtcblxuICAgIGlmICh0aGlzLndyaXRlQXN5bmMpIHtcbiAgICAgIHRoaXMuYXN5bmNXcml0ZVF1ZXVlLnB1c2godGV4dCk7XG4gICAgICB0aGlzLm5leHRBc3luY1dyaXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5wYXRoLCB0ZXh0LCB0aGlzLndyaXRlT3B0aW9ucyk7XG4gICAgICB0aGlzLmluY3JlYXNlQnl0ZXNXcml0dGVuQ291bnRlcih0ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmVtaXQoXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgIG5ldyBFcnJvcihgQ291bGRuJ3Qgd3JpdGUgdG8gJHt0aGlzLnBhdGh9LiAke2UubWVzc2FnZX1gKSxcbiAgICAgICAgdGhpcyxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsZTtcblxuZnVuY3Rpb24gcmVhZEZpbGVTeW5jRnJvbUVuZChmaWxlUGF0aCwgYnl0ZXNDb3VudCkge1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoYnl0ZXNDb3VudCk7XG4gIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZVBhdGgpO1xuXG4gIGNvbnN0IHJlYWRMZW5ndGggPSBNYXRoLm1pbihzdGF0cy5zaXplLCBieXRlc0NvdW50KTtcbiAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgc3RhdHMuc2l6ZSAtIGJ5dGVzQ291bnQpO1xuXG4gIGNvbnN0IGZkID0gZnMub3BlblN5bmMoZmlsZVBhdGgsICdyJyk7XG4gIGNvbnN0IHRvdGFsQnl0ZXMgPSBmcy5yZWFkU3luYyhmZCwgYnVmZmVyLCAwLCByZWFkTGVuZ3RoLCBvZmZzZXQpO1xuICBmcy5jbG9zZVN5bmMoZmQpO1xuXG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ3V0ZjgnLCAwLCB0b3RhbEJ5dGVzKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgRmlsZSA9IHJlcXVpcmUoJy4vRmlsZScpO1xuY29uc3QgTnVsbEZpbGUgPSByZXF1aXJlKCcuL051bGxGaWxlJyk7XG5cbmNsYXNzIEZpbGVSZWdpc3RyeSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHN0b3JlID0ge307XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmVtaXRFcnJvciA9IHRoaXMuZW1pdEVycm9yLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZSBhIEZpbGUgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZpbGVQYXRoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlUGF0aFxuICAgKiBAcGFyYW0ge1dyaXRlT3B0aW9uc30gW3dyaXRlT3B0aW9uc11cbiAgICogQHBhcmFtIHtib29sZWFufSBbd3JpdGVBc3luY11cbiAgICogQHJldHVybiB7RmlsZX1cbiAgICovXG4gIHByb3ZpZGUoeyBmaWxlUGF0aCwgd3JpdGVPcHRpb25zLCB3cml0ZUFzeW5jID0gZmFsc2UgfSkge1xuICAgIGxldCBmaWxlO1xuICAgIHRyeSB7XG4gICAgICBmaWxlUGF0aCA9IHBhdGgucmVzb2x2ZShmaWxlUGF0aCk7XG5cbiAgICAgIGlmICh0aGlzLnN0b3JlW2ZpbGVQYXRoXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZVtmaWxlUGF0aF07XG4gICAgICB9XG5cbiAgICAgIGZpbGUgPSB0aGlzLmNyZWF0ZUZpbGUoeyBmaWxlUGF0aCwgd3JpdGVPcHRpb25zLCB3cml0ZUFzeW5jIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGZpbGUgPSBuZXcgTnVsbEZpbGUoeyBwYXRoOiBmaWxlUGF0aCB9KTtcbiAgICAgIHRoaXMuZW1pdEVycm9yKGUsIGZpbGUpO1xuICAgIH1cblxuICAgIGZpbGUub24oJ2Vycm9yJywgdGhpcy5lbWl0RXJyb3IpO1xuICAgIHRoaXMuc3RvcmVbZmlsZVBhdGhdID0gZmlsZTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGhcbiAgICogQHBhcmFtIHtXcml0ZU9wdGlvbnN9IHdyaXRlT3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFzeW5jXG4gICAqIEByZXR1cm4ge0ZpbGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVGaWxlKHsgZmlsZVBhdGgsIHdyaXRlT3B0aW9ucywgd3JpdGVBc3luYyB9KSB7XG4gICAgdGhpcy50ZXN0RmlsZVdyaXRpbmcoZmlsZVBhdGgpO1xuICAgIHJldHVybiBuZXcgRmlsZSh7IHBhdGg6IGZpbGVQYXRoLCB3cml0ZU9wdGlvbnMsIHdyaXRlQXN5bmMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAgICogQHBhcmFtIHtGaWxlfSBmaWxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0RXJyb3IoZXJyb3IsIGZpbGUpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IsIGZpbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlUGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGVzdEZpbGVXcml0aW5nKGZpbGVQYXRoKSB7XG4gICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShmaWxlUGF0aCksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsICcnLCB7IGZsYWc6ICdhJyB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGVSZWdpc3RyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRmlsZSA9IHJlcXVpcmUoJy4vRmlsZScpO1xuXG5jbGFzcyBOdWxsRmlsZSBleHRlbmRzIEZpbGUge1xuICBjbGVhcigpIHtcblxuICB9XG5cbiAgY3JvcCgpIHtcblxuICB9XG5cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlzTnVsbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHdyaXRlTGluZSgpIHtcblxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTnVsbEZpbGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBGaWxlUmVnaXN0cnkgPSByZXF1aXJlKCcuL0ZpbGVSZWdpc3RyeScpO1xuY29uc3QgdmFyaWFibGVzID0gcmVxdWlyZSgnLi92YXJpYWJsZXMnKTtcbmNvbnN0IHsgdHJhbnNmb3JtIH0gPSByZXF1aXJlKCcuLi8uLi90cmFuc2Zvcm1zL3RyYW5zZm9ybScpO1xuY29uc3QgeyByZW1vdmVTdHlsZXMgfSA9IHJlcXVpcmUoJy4uLy4uL3RyYW5zZm9ybXMvc3R5bGUnKTtcbmNvbnN0IHsgZm9ybWF0IH0gPSByZXF1aXJlKCcuLi8uLi90cmFuc2Zvcm1zL2Zvcm1hdCcpO1xuY29uc3QgeyB0b1N0cmluZyB9ID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNmb3Jtcy9vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaWxlVHJhbnNwb3J0RmFjdG9yeTtcblxuLy8gU2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgZmlsZSB0cmFuc3BvcnQgaW5zdGFuY2VzXG5jb25zdCBnbG9iYWxSZWdpc3RyeSA9IG5ldyBGaWxlUmVnaXN0cnkoKTtcblxuZnVuY3Rpb24gZmlsZVRyYW5zcG9ydEZhY3RvcnkobG9nZ2VyLCByZWdpc3RyeSA9IGdsb2JhbFJlZ2lzdHJ5KSB7XG4gIC8qKiBAdHlwZSB7UGF0aFZhcmlhYmxlc30gKi9cbiAgbGV0IHBhdGhWYXJpYWJsZXM7XG5cbiAgaWYgKHJlZ2lzdHJ5Lmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPCAxKSB7XG4gICAgcmVnaXN0cnkub24oJ2Vycm9yJywgKGUsIGZpbGUpID0+IHtcbiAgICAgIGxvZ0NvbnNvbGUoYENhbid0IHdyaXRlIHRvICR7ZmlsZX1gLCBlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHRyYW5zcG9ydCwge1xuICAgIGZpbGVOYW1lOiBnZXREZWZhdWx0RmlsZU5hbWUobG9nZ2VyLnZhcmlhYmxlcy5wcm9jZXNzVHlwZSksXG4gICAgZm9ybWF0OiAnW3t5fS17bX0te2R9IHtofTp7aX06e3N9Lnttc31dIFt7bGV2ZWx9XXtzY29wZX0ge3RleHR9JyxcbiAgICBnZXRGaWxlLFxuICAgIGluc3BlY3RPcHRpb25zOiB7IGRlcHRoOiA1IH0sXG4gICAgbGV2ZWw6ICdzaWxseScsXG4gICAgbWF4U2l6ZTogMTAyNCAqKiAyLFxuICAgIHJlYWRBbGxMb2dzLFxuICAgIHN5bmM6IHRydWUsXG4gICAgdHJhbnNmb3JtczogW3JlbW92ZVN0eWxlcywgZm9ybWF0LCB0b1N0cmluZ10sXG4gICAgd3JpdGVPcHRpb25zOiB7IGZsYWc6ICdhJywgbW9kZTogMG82NjYsIGVuY29kaW5nOiAndXRmOCcgfSxcblxuICAgIGFyY2hpdmVMb2dGbihmaWxlKSB7XG4gICAgICBjb25zdCBvbGRQYXRoID0gZmlsZS50b1N0cmluZygpO1xuICAgICAgY29uc3QgaW5mID0gcGF0aC5wYXJzZShvbGRQYXRoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLnJlbmFtZVN5bmMob2xkUGF0aCwgcGF0aC5qb2luKGluZi5kaXIsIGAke2luZi5uYW1lfS5vbGQke2luZi5leHR9YCkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dDb25zb2xlKCdDb3VsZCBub3Qgcm90YXRlIGxvZycsIGUpO1xuICAgICAgICBjb25zdCBxdWFydGVyT2ZNYXhTaXplID0gTWF0aC5yb3VuZCh0cmFuc3BvcnQubWF4U2l6ZSAvIDQpO1xuICAgICAgICBmaWxlLmNyb3AoTWF0aC5taW4ocXVhcnRlck9mTWF4U2l6ZSwgMjU2ICogMTAyNCkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNvbHZlUGF0aEZuKHZhcnMpIHtcbiAgICAgIHJldHVybiBwYXRoLmpvaW4odmFycy5saWJyYXJ5RGVmYXVsdERpciwgdmFycy5maWxlTmFtZSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdHJhbnNwb3J0KG1lc3NhZ2UpIHtcbiAgICBjb25zdCBmaWxlID0gZ2V0RmlsZShtZXNzYWdlKTtcblxuICAgIGNvbnN0IG5lZWRMb2dSb3RhdGlvbiA9IHRyYW5zcG9ydC5tYXhTaXplID4gMFxuICAgICAgJiYgZmlsZS5zaXplID4gdHJhbnNwb3J0Lm1heFNpemU7XG5cbiAgICBpZiAobmVlZExvZ1JvdGF0aW9uKSB7XG4gICAgICB0cmFuc3BvcnQuYXJjaGl2ZUxvZ0ZuKGZpbGUpO1xuICAgICAgZmlsZS5yZXNldCgpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnQgPSB0cmFuc2Zvcm0oeyBsb2dnZXIsIG1lc3NhZ2UsIHRyYW5zcG9ydCB9KTtcbiAgICBmaWxlLndyaXRlTGluZShjb250ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVPbkZpcnN0QWNjZXNzKCkge1xuICAgIGlmIChwYXRoVmFyaWFibGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFrZSBhIHNoYWxsb3cgY29weSBvZiBwYXRoVmFyaWFibGVzIHRvIGtlZXAgZ2V0dGVycyBpbnRhY3RcbiAgICBwYXRoVmFyaWFibGVzID0gT2JqZWN0LmNyZWF0ZShcbiAgICAgIE9iamVjdC5wcm90b3R5cGUsXG4gICAgICB7XG4gICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKFxuICAgICAgICAgIHZhcmlhYmxlcy5nZXRQYXRoVmFyaWFibGVzKHByb2Nlc3MucGxhdGZvcm0pLFxuICAgICAgICApLFxuICAgICAgICBmaWxlTmFtZToge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnQuZmlsZU5hbWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgaWYgKHR5cGVvZiB0cmFuc3BvcnQuYXJjaGl2ZUxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJhbnNwb3J0LmFyY2hpdmVMb2dGbiA9IHRyYW5zcG9ydC5hcmNoaXZlTG9nO1xuICAgICAgbG9nQ29uc29sZSgnYXJjaGl2ZUxvZyBpcyBkZXByZWNhdGVkLiBVc2UgYXJjaGl2ZUxvZ0ZuIGluc3RlYWQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRyYW5zcG9ydC5yZXNvbHZlUGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJhbnNwb3J0LnJlc29sdmVQYXRoRm4gPSB0cmFuc3BvcnQucmVzb2x2ZVBhdGg7XG4gICAgICBsb2dDb25zb2xlKCdyZXNvbHZlUGF0aCBpcyBkZXByZWNhdGVkLiBVc2UgcmVzb2x2ZVBhdGhGbiBpbnN0ZWFkJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9nQ29uc29sZShtZXNzYWdlLCBlcnJvciA9IG51bGwsIGxldmVsID0gJ2Vycm9yJykge1xuICAgIGNvbnN0IGRhdGEgPSBbYGVsZWN0cm9uLWxvZy50cmFuc3BvcnRzLmZpbGU6ICR7bWVzc2FnZX1gXTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgZGF0YS5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBsb2dnZXIudHJhbnNwb3J0cy5jb25zb2xlKHsgZGF0YSwgZGF0ZTogbmV3IERhdGUoKSwgbGV2ZWwgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGaWxlKG1zZykge1xuICAgIGluaXRpYWxpemVPbkZpcnN0QWNjZXNzKCk7XG5cbiAgICBjb25zdCBmaWxlUGF0aCA9IHRyYW5zcG9ydC5yZXNvbHZlUGF0aEZuKHBhdGhWYXJpYWJsZXMsIG1zZyk7XG4gICAgcmV0dXJuIHJlZ2lzdHJ5LnByb3ZpZGUoe1xuICAgICAgZmlsZVBhdGgsXG4gICAgICB3cml0ZUFzeW5jOiAhdHJhbnNwb3J0LnN5bmMsXG4gICAgICB3cml0ZU9wdGlvbnM6IHRyYW5zcG9ydC53cml0ZU9wdGlvbnMsXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkQWxsTG9ncyh7IGZpbGVGaWx0ZXIgPSAoZikgPT4gZi5lbmRzV2l0aCgnLmxvZycpIH0gPSB7fSkge1xuICAgIGNvbnN0IGxvZ3NQYXRoID0gcGF0aC5kaXJuYW1lKHRyYW5zcG9ydC5yZXNvbHZlUGF0aEZuKHBhdGhWYXJpYWJsZXMpKTtcblxuICAgIHJldHVybiBmcy5yZWFkZGlyU3luYyhsb2dzUGF0aClcbiAgICAgIC5tYXAoKGZpbGVOYW1lKSA9PiBwYXRoLmpvaW4obG9nc1BhdGgsIGZpbGVOYW1lKSlcbiAgICAgIC5maWx0ZXIoZmlsZUZpbHRlcilcbiAgICAgIC5tYXAoKGxvZ1BhdGgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aDogbG9nUGF0aCxcbiAgICAgICAgICAgIGxpbmVzOiBmcy5yZWFkRmlsZVN5bmMobG9nUGF0aCwgJ3V0ZjgnKS5zcGxpdChvcy5FT0wpLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RmlsZU5hbWUocHJvY2Vzc1R5cGUgPSBwcm9jZXNzLnR5cGUpIHtcbiAgc3dpdGNoIChwcm9jZXNzVHlwZSkge1xuICAgIGNhc2UgJ3JlbmRlcmVyJzogcmV0dXJuICdyZW5kZXJlci5sb2cnO1xuICAgIGNhc2UgJ3dvcmtlcic6IHJldHVybiAnd29ya2VyLmxvZyc7XG4gICAgZGVmYXVsdDogcmV0dXJuICdtYWluLmxvZyc7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlYWRQYWNrYWdlSnNvbixcbiAgdHJ5UmVhZEpzb25BdCxcbn07XG5cbi8qKlxuICogQHJldHVybiB7eyBuYW1lPzogc3RyaW5nLCB2ZXJzaW9uPzogc3RyaW5nfX1cbiAqL1xuZnVuY3Rpb24gcmVhZFBhY2thZ2VKc29uKCkge1xuICByZXR1cm4gdHJ5UmVhZEpzb25BdChyZXF1aXJlLm1haW4gJiYgcmVxdWlyZS5tYWluLmZpbGVuYW1lKVxuICAgIHx8IHRyeVJlYWRKc29uQXQoZXh0cmFjdFBhdGhGcm9tQXJncygpKVxuICAgIHx8IHRyeVJlYWRKc29uQXQocHJvY2Vzcy5yZXNvdXJjZXNQYXRoLCAnYXBwLmFzYXInKVxuICAgIHx8IHRyeVJlYWRKc29uQXQocHJvY2Vzcy5yZXNvdXJjZXNQYXRoLCAnYXBwJylcbiAgICB8fCB0cnlSZWFkSnNvbkF0KHByb2Nlc3MuY3dkKCkpXG4gICAgfHwgeyBuYW1lOiBudWxsLCB2ZXJzaW9uOiBudWxsIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHsuLi5zdHJpbmd9IHNlYXJjaFBhdGhzXG4gKiBAcmV0dXJuIHt7IG5hbWU/OiBzdHJpbmcsIHZlcnNpb24/OiBzdHJpbmcgfSB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIHRyeVJlYWRKc29uQXQoLi4uc2VhcmNoUGF0aHMpIHtcbiAgaWYgKCFzZWFyY2hQYXRoc1swXSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzZWFyY2hQYXRoID0gcGF0aC5qb2luKC4uLnNlYXJjaFBhdGhzKTtcbiAgICBjb25zdCBmaWxlTmFtZSA9IGZpbmRVcCgncGFja2FnZS5qc29uJywgc2VhcmNoUGF0aCk7XG4gICAgaWYgKCFmaWxlTmFtZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGZpbGVOYW1lLCAndXRmOCcpKTtcbiAgICBjb25zdCBuYW1lID0ganNvbi5wcm9kdWN0TmFtZSB8fCBqc29uLm5hbWU7XG4gICAgaWYgKCFuYW1lIHx8IG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2VsZWN0cm9uJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGpzb24ucHJvZHVjdE5hbWUgfHwganNvbi5uYW1lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICB2ZXJzaW9uOiBqc29uLnZlcnNpb24sXG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gW2N3ZF1cbiAqIEByZXR1cm4ge3N0cmluZyB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGZpbmRVcChmaWxlTmFtZSwgY3dkKSB7XG4gIGxldCBjdXJyZW50UGF0aCA9IGN3ZDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHBhcnNlZFBhdGggPSBwYXRoLnBhcnNlKGN1cnJlbnRQYXRoKTtcbiAgICBjb25zdCByb290ID0gcGFyc2VkUGF0aC5yb290O1xuICAgIGNvbnN0IGRpciA9IHBhcnNlZFBhdGguZGlyO1xuXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMocGF0aC5qb2luKGN1cnJlbnRQYXRoLCBmaWxlTmFtZSkpKSB7XG4gICAgICByZXR1cm4gcGF0aC5yZXNvbHZlKHBhdGguam9pbihjdXJyZW50UGF0aCwgZmlsZU5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFBhdGggPT09IHJvb3QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGN1cnJlbnRQYXRoID0gZGlyO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGFwcCBwYXRoIGZyb20gLS11c2VyLWRhdGEtZGlyIGNtZCBhcmcsIHBhc3NlZCB0byBhIHJlbmRlcmVyIHByb2Nlc3NcbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICovXG5mdW5jdGlvbiBleHRyYWN0UGF0aEZyb21BcmdzKCkge1xuICBjb25zdCBtYXRjaGVkQXJncyA9IHByb2Nlc3MuYXJndi5maWx0ZXIoKGFyZykgPT4ge1xuICAgIHJldHVybiBhcmcuaW5kZXhPZignLS11c2VyLWRhdGEtZGlyPScpID09PSAwO1xuICB9KTtcblxuICBpZiAobWF0Y2hlZEFyZ3MubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBtYXRjaGVkQXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHVzZXJEYXRhRGlyID0gbWF0Y2hlZEFyZ3NbMF07XG4gIHJldHVybiB1c2VyRGF0YURpci5yZXBsYWNlKCctLXVzZXItZGF0YS1kaXI9JywgJycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZWxlY3Ryb25BcGkgPSByZXF1aXJlKCcuLi8uLi9lbGVjdHJvbkFwaScpO1xuY29uc3QgcGFja2FnZUpzb24gPSByZXF1aXJlKCcuL3BhY2thZ2VKc29uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRBcHBEYXRhLFxuICBnZXRMaWJyYXJ5RGVmYXVsdERpcixcbiAgZ2V0TGlicmFyeVRlbXBsYXRlLFxuICBnZXROYW1lQW5kVmVyc2lvbixcbiAgZ2V0UGF0aFZhcmlhYmxlcyxcbiAgZ2V0VXNlckRhdGEsXG59O1xuXG5mdW5jdGlvbiBnZXRBcHBEYXRhKHBsYXRmb3JtKSB7XG4gIGNvbnN0IGFwcERhdGEgPSBlbGVjdHJvbkFwaS5nZXRQYXRoKCdhcHBEYXRhJyk7XG4gIGlmIChhcHBEYXRhKSB7XG4gICAgcmV0dXJuIGFwcERhdGE7XG4gIH1cblxuICBjb25zdCBob21lID0gZ2V0SG9tZSgpO1xuXG4gIHN3aXRjaCAocGxhdGZvcm0pIHtcbiAgICBjYXNlICdkYXJ3aW4nOiB7XG4gICAgICByZXR1cm4gcGF0aC5qb2luKGhvbWUsICdMaWJyYXJ5L0FwcGxpY2F0aW9uIFN1cHBvcnQnKTtcbiAgICB9XG5cbiAgICBjYXNlICd3aW4zMic6IHtcbiAgICAgIHJldHVybiBwcm9jZXNzLmVudi5BUFBEQVRBIHx8IHBhdGguam9pbihob21lLCAnQXBwRGF0YS9Sb2FtaW5nJyk7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIHByb2Nlc3MuZW52LlhER19DT05GSUdfSE9NRSB8fCBwYXRoLmpvaW4oaG9tZSwgJy5jb25maWcnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9tZSgpIHtcbiAgcmV0dXJuIG9zLmhvbWVkaXIgPyBvcy5ob21lZGlyKCkgOiBwcm9jZXNzLmVudi5IT01FO1xufVxuXG5mdW5jdGlvbiBnZXRMaWJyYXJ5RGVmYXVsdERpcihwbGF0Zm9ybSwgYXBwTmFtZSkge1xuICBpZiAocGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgcmV0dXJuIHBhdGguam9pbihnZXRIb21lKCksICdMaWJyYXJ5L0xvZ3MnLCBhcHBOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBwYXRoLmpvaW4oZ2V0VXNlckRhdGEocGxhdGZvcm0sIGFwcE5hbWUpLCAnbG9ncycpO1xufVxuXG5mdW5jdGlvbiBnZXRMaWJyYXJ5VGVtcGxhdGUocGxhdGZvcm0pIHtcbiAgaWYgKHBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgIHJldHVybiBwYXRoLmpvaW4oZ2V0SG9tZSgpLCAnTGlicmFyeS9Mb2dzJywgJ3thcHBOYW1lfScpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGguam9pbihnZXRBcHBEYXRhKHBsYXRmb3JtKSwgJ3thcHBOYW1lfScsICdsb2dzJyk7XG59XG5cbmZ1bmN0aW9uIGdldE5hbWVBbmRWZXJzaW9uKCkge1xuICBsZXQgbmFtZSA9IGVsZWN0cm9uQXBpLmdldE5hbWUoKSB8fCAnJztcbiAgbGV0IHZlcnNpb24gPSBlbGVjdHJvbkFwaS5nZXRWZXJzaW9uKCk7XG5cbiAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2VsZWN0cm9uJykge1xuICAgIG5hbWUgPSAnJztcbiAgICB2ZXJzaW9uID0gJyc7XG4gIH1cblxuICBpZiAobmFtZSAmJiB2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIHsgbmFtZSwgdmVyc2lvbiB9O1xuICB9XG5cbiAgY29uc3QgcGFja2FnZVZhbHVlcyA9IHBhY2thZ2VKc29uLnJlYWRQYWNrYWdlSnNvbigpO1xuICBpZiAoIW5hbWUpIHtcbiAgICBuYW1lID0gcGFja2FnZVZhbHVlcy5uYW1lO1xuICB9XG5cbiAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgdmVyc2lvbiA9IHBhY2thZ2VWYWx1ZXMudmVyc2lvbjtcbiAgfVxuXG4gIGlmICghbmFtZSkge1xuICAgIC8vIEZhbGxiYWNrLCBvdGhlcndpc2UgZmlsZSB0cmFuc3BvcnQgY2FuJ3QgYmUgaW5pdGlhbGl6ZWRcbiAgICBuYW1lID0gJ0VsZWN0cm9uJztcbiAgfVxuXG4gIHJldHVybiB7IG5hbWUsIHZlcnNpb24gfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGxhdGZvcm1cbiAqIEByZXR1cm4ge1BhdGhWYXJpYWJsZXN9XG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhWYXJpYWJsZXMocGxhdGZvcm0pIHtcbiAgY29uc3QgbmFtZUFuZFZlcnNpb24gPSBnZXROYW1lQW5kVmVyc2lvbigpO1xuICBjb25zdCBhcHBOYW1lID0gbmFtZUFuZFZlcnNpb24ubmFtZTtcbiAgY29uc3QgYXBwVmVyc2lvbiA9IG5hbWVBbmRWZXJzaW9uLnZlcnNpb247XG5cbiAgcmV0dXJuIHtcbiAgICBhcHBEYXRhOiBnZXRBcHBEYXRhKHBsYXRmb3JtKSxcbiAgICBhcHBOYW1lLFxuICAgIGFwcFZlcnNpb24sXG4gICAgZ2V0IGVsZWN0cm9uRGVmYXVsdERpcigpIHtcbiAgICAgIHJldHVybiBlbGVjdHJvbkFwaS5nZXRQYXRoKCdsb2dzJyk7XG4gICAgfSxcbiAgICBob21lOiBnZXRIb21lKCksXG4gICAgbGlicmFyeURlZmF1bHREaXI6IGdldExpYnJhcnlEZWZhdWx0RGlyKHBsYXRmb3JtLCBhcHBOYW1lKSxcbiAgICBsaWJyYXJ5VGVtcGxhdGU6IGdldExpYnJhcnlUZW1wbGF0ZShwbGF0Zm9ybSksXG4gICAgdGVtcDogZWxlY3Ryb25BcGkuZ2V0UGF0aCgndGVtcCcpIHx8IG9zLnRtcGRpcigpLFxuICAgIHVzZXJEYXRhOiBnZXRVc2VyRGF0YShwbGF0Zm9ybSwgYXBwTmFtZSksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFVzZXJEYXRhKHBsYXRmb3JtLCBhcHBOYW1lKSB7XG4gIGlmIChlbGVjdHJvbkFwaS5nZXROYW1lKCkgIT09IGFwcE5hbWUpIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKGdldEFwcERhdGEocGxhdGZvcm0pLCBhcHBOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBlbGVjdHJvbkFwaS5nZXRQYXRoKCd1c2VyRGF0YScpXG4gICAgfHwgcGF0aC5qb2luKGdldEFwcERhdGEocGxhdGZvcm0pLCBhcHBOYW1lKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IHsgdHJhbnNmb3JtIH0gPSByZXF1aXJlKCcuLi90cmFuc2Zvcm1zL3RyYW5zZm9ybScpO1xuY29uc3QgeyByZW1vdmVTdHlsZXMgfSA9IHJlcXVpcmUoJy4uL3RyYW5zZm9ybXMvc3R5bGUnKTtcbmNvbnN0IHsgdG9KU09OLCBtYXhEZXB0aCB9ID0gcmVxdWlyZSgnLi4vdHJhbnNmb3Jtcy9vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZW1vdGVUcmFuc3BvcnRGYWN0b3J5O1xuXG5mdW5jdGlvbiByZW1vdGVUcmFuc3BvcnRGYWN0b3J5KGxvZ2dlcikge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0cmFuc3BvcnQsIHtcbiAgICBjbGllbnQ6IHsgbmFtZTogJ2VsZWN0cm9uLWFwcGxpY2F0aW9uJyB9LFxuICAgIGRlcHRoOiA2LFxuICAgIGxldmVsOiBmYWxzZSxcbiAgICByZXF1ZXN0T3B0aW9uczoge30sXG4gICAgdHJhbnNmb3JtczogW3JlbW92ZVN0eWxlcywgdG9KU09OLCBtYXhEZXB0aF0sXG5cbiAgICBtYWtlQm9keUZuKHsgbWVzc2FnZSB9KSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBjbGllbnQ6IHRyYW5zcG9ydC5jbGllbnQsXG4gICAgICAgIGRhdGE6IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgZGF0ZTogbWVzc2FnZS5kYXRlLmdldFRpbWUoKSxcbiAgICAgICAgbGV2ZWw6IG1lc3NhZ2UubGV2ZWwsXG4gICAgICAgIHNjb3BlOiBtZXNzYWdlLnNjb3BlLFxuICAgICAgICB2YXJpYWJsZXM6IG1lc3NhZ2UudmFyaWFibGVzLFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHByb2Nlc3NFcnJvckZuKHsgZXJyb3IgfSkge1xuICAgICAgbG9nZ2VyLnByb2Nlc3NNZXNzYWdlKFxuICAgICAgICB7XG4gICAgICAgICAgZGF0YTogW2BlbGVjdHJvbi1sb2c6IGNhbid0IFBPU1QgJHt0cmFuc3BvcnQudXJsfWAsIGVycm9yXSxcbiAgICAgICAgICBsZXZlbDogJ3dhcm4nLFxuICAgICAgICB9LFxuICAgICAgICB7IHRyYW5zcG9ydHM6IFsnY29uc29sZScsICdmaWxlJ10gfSxcbiAgICAgICk7XG4gICAgfSxcblxuICAgIHNlbmRSZXF1ZXN0Rm4oeyBzZXJ2ZXJVcmwsIHJlcXVlc3RPcHRpb25zLCBib2R5IH0pIHtcbiAgICAgIGNvbnN0IGh0dHBUcmFuc3BvcnQgPSBzZXJ2ZXJVcmwuc3RhcnRzV2l0aCgnaHR0cHM6JykgPyBodHRwcyA6IGh0dHA7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBodHRwVHJhbnNwb3J0LnJlcXVlc3Qoc2VydmVyVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAuLi5yZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgLi4ucmVxdWVzdE9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICByZXF1ZXN0LndyaXRlKGJvZHkpO1xuICAgICAgcmVxdWVzdC5lbmQoKTtcblxuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfSxcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdHJhbnNwb3J0KG1lc3NhZ2UpIHtcbiAgICBpZiAoIXRyYW5zcG9ydC51cmwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gdHJhbnNwb3J0Lm1ha2VCb2R5Rm4oe1xuICAgICAgbG9nZ2VyLFxuICAgICAgbWVzc2FnZTogeyAuLi5tZXNzYWdlLCBkYXRhOiB0cmFuc2Zvcm0oeyBsb2dnZXIsIG1lc3NhZ2UsIHRyYW5zcG9ydCB9KSB9LFxuICAgICAgdHJhbnNwb3J0LFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVxdWVzdCA9IHRyYW5zcG9ydC5zZW5kUmVxdWVzdEZuKHtcbiAgICAgIHNlcnZlclVybDogdHJhbnNwb3J0LnVybCxcbiAgICAgIHJlcXVlc3RPcHRpb25zOiB0cmFuc3BvcnQucmVxdWVzdE9wdGlvbnMsXG4gICAgICBib2R5OiBCdWZmZXIuZnJvbShib2R5LCAndXRmOCcpLFxuICAgIH0pO1xuXG4gICAgcmVxdWVzdC5vbignZXJyb3InLCAoZXJyb3IpID0+IHRyYW5zcG9ydC5wcm9jZXNzRXJyb3JGbih7XG4gICAgICBlcnJvcixcbiAgICAgIGxvZ2dlcixcbiAgICAgIG1lc3NhZ2UsXG4gICAgICByZXF1ZXN0LFxuICAgICAgdHJhbnNwb3J0LFxuICAgIH0pKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5sZXQgZWxlY3Ryb24gPSB7fTtcblxudHJ5IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlLGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuICBlbGVjdHJvbiA9IHJlcXVpcmUoJ2VsZWN0cm9uJyk7XG59IGNhdGNoIChlKSB7XG4gIC8vIHJlcXVpcmUgaXNuJ3QgYXZhaWxhYmxlLCBub3QgZnJvbSBhIHByZWxvYWQgc2NyaXB0XG59XG5cbmlmIChlbGVjdHJvbi5pcGNSZW5kZXJlcikge1xuICBpbml0aWFsaXplKGVsZWN0cm9uKTtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW5pdGlhbGl6ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZWN0cm9uLkNvbnRleHRCcmlkZ2V9IGNvbnRleHRCcmlkZ2VcbiAqIEBwYXJhbSB7RWxlY3Ryb24uSXBjUmVuZGVyZXJ9IGlwY1JlbmRlcmVyXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemUoeyBjb250ZXh0QnJpZGdlLCBpcGNSZW5kZXJlciB9KSB7XG4gIGlmICghaXBjUmVuZGVyZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpcGNSZW5kZXJlci5vbignX19FTEVDVFJPTl9MT0dfSVBDX18nLCAoXywgbWVzc2FnZSkgPT4ge1xuICAgIHdpbmRvdy5wb3N0TWVzc2FnZSh7IGNtZDogJ21lc3NhZ2UnLCAuLi5tZXNzYWdlIH0pO1xuICB9KTtcblxuICBpcGNSZW5kZXJlclxuICAgIC5pbnZva2UoJ19fRUxFQ1RST05fTE9HX18nLCB7IGNtZDogJ2dldE9wdGlvbnMnIH0pXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAuY2F0Y2goKGUpID0+IGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKFxuICAgICAgJ2VsZWN0cm9uLWxvZyBpc25cXCd0IGluaXRpYWxpemVkIGluIHRoZSBtYWluIHByb2Nlc3MuICdcbiAgICAgICsgYFBsZWFzZSBjYWxsIGxvZy5pbml0aWFsaXplKCkgYmVmb3JlLiAke2UubWVzc2FnZX1gLFxuICAgICkpKTtcblxuICBjb25zdCBlbGVjdHJvbkxvZyA9IHtcbiAgICBzZW5kVG9NYWluKG1lc3NhZ2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlwY1JlbmRlcmVyLnNlbmQoJ19fRUxFQ1RST05fTE9HX18nLCBtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvcignZWxlY3Ryb25Mb2cuc2VuZFRvTWFpbiAnLCBlLCAnZGF0YTonLCBtZXNzYWdlKTtcblxuICAgICAgICBpcGNSZW5kZXJlci5zZW5kKCdfX0VMRUNUUk9OX0xPR19fJywge1xuICAgICAgICAgIGNtZDogJ2Vycm9ySGFuZGxlcicsXG4gICAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogZT8ubWVzc2FnZSwgc3RhY2s6IGU/LnN0YWNrIH0sXG4gICAgICAgICAgZXJyb3JOYW1lOiAnc2VuZFRvTWFpbicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBsb2coLi4uZGF0YSkge1xuICAgICAgZWxlY3Ryb25Mb2cuc2VuZFRvTWFpbih7IGRhdGEsIGxldmVsOiAnaW5mbycgfSk7XG4gICAgfSxcbiAgfTtcblxuICBmb3IgKGNvbnN0IGxldmVsIG9mIFsnZXJyb3InLCAnd2FybicsICdpbmZvJywgJ3ZlcmJvc2UnLCAnZGVidWcnLCAnc2lsbHknXSkge1xuICAgIGVsZWN0cm9uTG9nW2xldmVsXSA9ICguLi5kYXRhKSA9PiBlbGVjdHJvbkxvZy5zZW5kVG9NYWluKHtcbiAgICAgIGRhdGEsXG4gICAgICBsZXZlbCxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjb250ZXh0QnJpZGdlICYmIHByb2Nlc3MuY29udGV4dElzb2xhdGVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRleHRCcmlkZ2UuZXhwb3NlSW5NYWluV29ybGQoJ19fZWxlY3Ryb25Mb2cnLCBlbGVjdHJvbkxvZyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBTb21ldGltZXMgdGhpcyBmaWxlcyBjYW4gYmUgaW5jbHVkZWQgdHdpY2VcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICB3aW5kb3cuX19lbGVjdHJvbkxvZyA9IGVsZWN0cm9uTG9nO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vaW5zcGVjdGlvbiBKU0NvbnN0YW50UmVhc3NpZ25tZW50XG4gICAgX19lbGVjdHJvbkxvZyA9IGVsZWN0cm9uTG9nO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2NvcmUvTG9nZ2VyJyk7XG5jb25zdCBSZW5kZXJlckVycm9ySGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL1JlbmRlcmVyRXJyb3JIYW5kbGVyJyk7XG5jb25zdCB0cmFuc3BvcnRDb25zb2xlID0gcmVxdWlyZSgnLi9saWIvdHJhbnNwb3J0cy9jb25zb2xlJyk7XG5jb25zdCB0cmFuc3BvcnRJcGMgPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnRzL2lwYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUxvZ2dlcigpO1xubW9kdWxlLmV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xuXG5mdW5jdGlvbiBjcmVhdGVMb2dnZXIoKSB7XG4gIGNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoe1xuICAgIGFsbG93VW5rbm93bkxldmVsOiB0cnVlLFxuICAgIGVycm9ySGFuZGxlcjogbmV3IFJlbmRlcmVyRXJyb3JIYW5kbGVyKCksXG4gICAgaW5pdGlhbGl6ZUZuOiAoKSA9PiB7fSxcbiAgICBsb2dJZDogJ2RlZmF1bHQnLFxuICAgIHRyYW5zcG9ydEZhY3Rvcmllczoge1xuICAgICAgY29uc29sZTogdHJhbnNwb3J0Q29uc29sZSxcbiAgICAgIGlwYzogdHJhbnNwb3J0SXBjLFxuICAgIH0sXG4gICAgdmFyaWFibGVzOiB7XG4gICAgICBwcm9jZXNzVHlwZTogJ3JlbmRlcmVyJyxcbiAgICB9LFxuICB9KTtcblxuICBsb2dnZXIuZXJyb3JIYW5kbGVyLnNldE9wdGlvbnMoe1xuICAgIGxvZ0ZuKHsgZXJyb3IsIGVycm9yTmFtZSwgc2hvd0RpYWxvZyB9KSB7XG4gICAgICBsb2dnZXIudHJhbnNwb3J0cy5jb25zb2xlKHtcbiAgICAgICAgZGF0YTogW2Vycm9yTmFtZSwgZXJyb3JdLmZpbHRlcihCb29sZWFuKSxcbiAgICAgICAgbGV2ZWw6ICdlcnJvcicsXG4gICAgICB9KTtcbiAgICAgIGxvZ2dlci50cmFuc3BvcnRzLmlwYyh7XG4gICAgICAgIGNtZDogJ2Vycm9ySGFuZGxlcicsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgY2F1c2U6IGVycm9yPy5jYXVzZSxcbiAgICAgICAgICBjb2RlOiBlcnJvcj8uY29kZSxcbiAgICAgICAgICBuYW1lOiBlcnJvcj8ubmFtZSxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvcj8ubWVzc2FnZSxcbiAgICAgICAgICBzdGFjazogZXJyb3I/LnN0YWNrLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvck5hbWUsXG4gICAgICAgIGxvZ0lkOiBsb2dnZXIubG9nSWQsXG4gICAgICAgIHNob3dEaWFsb2csXG4gICAgICB9KTtcbiAgICB9LFxuICB9KTtcblxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBjbWQsIGxvZ0lkLCAuLi5tZXNzYWdlIH0gPSBldmVudC5kYXRhIHx8IHt9O1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoeyBsb2dJZCB9KTtcblxuICAgICAgaWYgKGNtZCA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgIGluc3RhbmNlLnByb2Nlc3NNZXNzYWdlKG1lc3NhZ2UsIHsgdHJhbnNwb3J0czogWydjb25zb2xlJ10gfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBUbyBzdXBwb3J0IGN1c3RvbSBsZXZlbHNcbiAgcmV0dXJuIG5ldyBQcm94eShsb2dnZXIsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAodHlwZW9mIHRhcmdldFtwcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICguLi5kYXRhKSA9PiBsb2dnZXIubG9nRGF0YShkYXRhLCB7IGxldmVsOiBwcm9wIH0pO1xuICAgIH0sXG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuY29uc3QgY29uc29sZUVycm9yID0gY29uc29sZS5lcnJvcjtcblxuY2xhc3MgUmVuZGVyZXJFcnJvckhhbmRsZXIge1xuICBsb2dGbiA9IG51bGw7XG4gIG9uRXJyb3IgPSBudWxsO1xuICBzaG93RGlhbG9nID0gZmFsc2U7XG4gIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3Rvcih7IGxvZ0ZuID0gbnVsbCB9ID0ge30pIHtcbiAgICB0aGlzLmhhbmRsZUVycm9yID0gdGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlUmVqZWN0aW9uID0gdGhpcy5oYW5kbGVSZWplY3Rpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLnN0YXJ0Q2F0Y2hpbmcgPSB0aGlzLnN0YXJ0Q2F0Y2hpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLmxvZ0ZuID0gbG9nRm47XG4gIH1cblxuICBoYW5kbGUoZXJyb3IsIHtcbiAgICBsb2dGbiA9IHRoaXMubG9nRm4sXG4gICAgZXJyb3JOYW1lID0gJycsXG4gICAgb25FcnJvciA9IHRoaXMub25FcnJvcixcbiAgICBzaG93RGlhbG9nID0gdGhpcy5zaG93RGlhbG9nLFxuICB9ID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG9uRXJyb3I/Lih7IGVycm9yLCBlcnJvck5hbWUsIHByb2Nlc3NUeXBlOiAncmVuZGVyZXInIH0pICE9PSBmYWxzZSkge1xuICAgICAgICBsb2dGbih7IGVycm9yLCBlcnJvck5hbWUsIHNob3dEaWFsb2cgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICBjb25zb2xlRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHNldE9wdGlvbnMoeyBsb2dGbiwgb25FcnJvciwgcHJldmVudERlZmF1bHQsIHNob3dEaWFsb2cgfSkge1xuICAgIGlmICh0eXBlb2YgbG9nRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMubG9nRm4gPSBsb2dGbjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcmV2ZW50RGVmYXVsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzaG93RGlhbG9nID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuc2hvd0RpYWxvZyA9IHNob3dEaWFsb2c7XG4gICAgfVxuICB9XG5cbiAgc3RhcnRDYXRjaGluZyh7IG9uRXJyb3IsIHNob3dEaWFsb2cgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnNldE9wdGlvbnMoeyBvbkVycm9yLCBzaG93RGlhbG9nIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLnByZXZlbnREZWZhdWx0ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0Py4oKTtcbiAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXZlbnQuZXJyb3IgfHwgZXZlbnQpO1xuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMucHJldmVudERlZmF1bHQgJiYgZXZlbnQucHJldmVudERlZmF1bHQ/LigpO1xuICAgICAgdGhpcy5oYW5kbGVSZWplY3Rpb24oZXZlbnQucmVhc29uIHx8IGV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgdGhpcy5oYW5kbGUoZXJyb3IsIHsgZXJyb3JOYW1lOiAnVW5oYW5kbGVkJyB9KTtcbiAgfVxuXG4gIGhhbmRsZVJlamVjdGlvbihyZWFzb24pIHtcbiAgICBjb25zdCBlcnJvciA9IHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yXG4gICAgICA/IHJlYXNvblxuICAgICAgOiBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVhc29uKSk7XG4gICAgdGhpcy5oYW5kbGUoZXJyb3IsIHsgZXJyb3JOYW1lOiAnVW5oYW5kbGVkIHJlamVjdGlvbicgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlckVycm9ySGFuZGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGVUcmFuc3BvcnRSZW5kZXJlckZhY3Rvcnk7XG5cbmNvbnN0IGNvbnNvbGVNZXRob2RzID0ge1xuICBlcnJvcjogY29uc29sZS5lcnJvcixcbiAgd2FybjogY29uc29sZS53YXJuLFxuICBpbmZvOiBjb25zb2xlLmluZm8sXG4gIHZlcmJvc2U6IGNvbnNvbGUuaW5mbyxcbiAgZGVidWc6IGNvbnNvbGUuZGVidWcsXG4gIHNpbGx5OiBjb25zb2xlLmRlYnVnLFxuICBsb2c6IGNvbnNvbGUubG9nLFxufTtcblxuZnVuY3Rpb24gY29uc29sZVRyYW5zcG9ydFJlbmRlcmVyRmFjdG9yeShsb2dnZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24odHJhbnNwb3J0LCB7XG4gICAgZm9ybWF0OiAne2h9OntpfTp7c30ue21zfXtzY29wZX0g4oC6IHt0ZXh0fScsXG5cbiAgICBmb3JtYXREYXRhRm4oe1xuICAgICAgZGF0YSA9IFtdLFxuICAgICAgZGF0ZSA9IG5ldyBEYXRlKCksXG4gICAgICBmb3JtYXQgPSB0cmFuc3BvcnQuZm9ybWF0LFxuICAgICAgbG9nSWQgPSBsb2dnZXIubG9nSWQsXG4gICAgICBzY29wZSA9IGxvZ2dlci5zY29wZU5hbWUsXG4gICAgICAuLi5tZXNzYWdlXG4gICAgfSkge1xuICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdCh7IC4uLm1lc3NhZ2UsIGRhdGEsIGRhdGUsIGxvZ0lkLCBzY29wZSB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnVuc2hpZnQoZm9ybWF0KTtcblxuICAgICAgLy8gQ29uY2F0ZW5hdGUgZmlyc3QgdHdvIGRhdGEgaXRlbXMgdG8gc3VwcG9ydCBwcmludGYtbGlrZSB0ZW1wbGF0ZXNcbiAgICAgIGlmICh0eXBlb2YgZGF0YVsxXSA9PT0gJ3N0cmluZycgJiYgZGF0YVsxXS5tYXRjaCgvJVsxY2RmaU9vc10vKSkge1xuICAgICAgICBkYXRhID0gW2Ake2RhdGFbMF19ICR7ZGF0YVsxXX1gLCAuLi5kYXRhLnNsaWNlKDIpXTtcbiAgICAgIH1cblxuICAgICAgZGF0YVswXSA9IGRhdGFbMF1cbiAgICAgICAgLnJlcGxhY2UoL1xceyhcXHcrKX0vZywgKHN1YnN0cmluZywgbmFtZSkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnbGV2ZWwnOiByZXR1cm4gbWVzc2FnZS5sZXZlbDtcbiAgICAgICAgICAgIGNhc2UgJ2xvZ0lkJzogcmV0dXJuIGxvZ0lkO1xuICAgICAgICAgICAgY2FzZSAnc2NvcGUnOiByZXR1cm4gc2NvcGUgPyBgICgke3Njb3BlfSlgIDogJyc7XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzogcmV0dXJuICcnO1xuXG4gICAgICAgICAgICBjYXNlICd5JzogcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygxMCk7XG4gICAgICAgICAgICBjYXNlICdtJzogcmV0dXJuIChkYXRlLmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygxMClcbiAgICAgICAgICAgICAgLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgICAgICBjYXNlICdkJzogcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpLnRvU3RyaW5nKDEwKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICAgICAgY2FzZSAnaCc6IHJldHVybiBkYXRlLmdldEhvdXJzKCkudG9TdHJpbmcoMTApLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgICAgICBjYXNlICdpJzogcmV0dXJuIGRhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKDEwKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICAgICAgY2FzZSAncyc6IHJldHVybiBkYXRlLmdldFNlY29uZHMoKS50b1N0cmluZygxMCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgICAgIGNhc2UgJ21zJzogcmV0dXJuIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoMTApXG4gICAgICAgICAgICAgIC5wYWRTdGFydCgzLCAnMCcpO1xuICAgICAgICAgICAgY2FzZSAnaXNvJzogcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcblxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZS52YXJpYWJsZXM/LltuYW1lXSB8fCBzdWJzdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAudHJpbSgpO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgd3JpdGVGbih7IG1lc3NhZ2U6IHsgbGV2ZWwsIGRhdGEgfSB9KSB7XG4gICAgICBjb25zdCBjb25zb2xlTG9nRm4gPSBjb25zb2xlTWV0aG9kc1tsZXZlbF0gfHwgY29uc29sZU1ldGhvZHMuaW5mbztcblxuICAgICAgLy8gbWFrZSBhbiBlbXB0eSBjYWxsIHN0YWNrXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGNvbnNvbGVMb2dGbiguLi5kYXRhKSk7XG4gICAgfSxcblxuICB9KTtcblxuICBmdW5jdGlvbiB0cmFuc3BvcnQobWVzc2FnZSkge1xuICAgIHRyYW5zcG9ydC53cml0ZUZuKHtcbiAgICAgIG1lc3NhZ2U6IHsgLi4ubWVzc2FnZSwgZGF0YTogdHJhbnNwb3J0LmZvcm1hdERhdGFGbihtZXNzYWdlKSB9LFxuICAgIH0pO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXBjVHJhbnNwb3J0UmVuZGVyZXJGYWN0b3J5O1xuXG5jb25zdCBSRVNUUklDVEVEX1RZUEVTID0gbmV3IFNldChbUHJvbWlzZSwgV2Vha01hcCwgV2Vha1NldF0pO1xuXG5mdW5jdGlvbiBpcGNUcmFuc3BvcnRSZW5kZXJlckZhY3RvcnkobG9nZ2VyKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHRyYW5zcG9ydCwge1xuICAgIGRlcHRoOiA1LFxuXG4gICAgc2VyaWFsaXplRm4oZGF0YSwgeyBkZXB0aCA9IDUsIHNlZW4gPSBuZXcgV2Vha1NldCgpIH0gPSB7fSkge1xuICAgICAgaWYgKGRlcHRoIDwgMSkge1xuICAgICAgICByZXR1cm4gYFske3R5cGVvZiBkYXRhfV1gO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2Vlbi5oYXMoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChbJ2Z1bmN0aW9uJywgJ3N5bWJvbCddLmluY2x1ZGVzKHR5cGVvZiBkYXRhKSkge1xuICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmltaXRpdmUgdHlwZXMgKGluY2x1ZGluZyBudWxsIGFuZCB1bmRlZmluZWQpXG4gICAgICBpZiAoT2JqZWN0KGRhdGEpICE9PSBkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBPYmplY3QgdHlwZXNcblxuICAgICAgaWYgKFJFU1RSSUNURURfVFlQRVMuaGFzKGRhdGEuY29uc3RydWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBgWyR7ZGF0YS5jb25zdHJ1Y3Rvci5uYW1lfV1gO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICByZXR1cm4gZGF0YS5tYXAoKGl0ZW0pID0+IHRyYW5zcG9ydC5zZXJpYWxpemVGbihcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIHsgZGVwdGg6IGRlcHRoIC0gMSwgc2VlbiB9LFxuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZGF0YS5zdGFjaztcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoXG4gICAgICAgICAgQXJyYXlcbiAgICAgICAgICAgIC5mcm9tKGRhdGEpXG4gICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICAgICAgdHJhbnNwb3J0LnNlcmlhbGl6ZUZuKGtleSwgeyBkZXB0aDogZGVwdGggLSAxLCBzZWVuIH0pLFxuICAgICAgICAgICAgICB0cmFuc3BvcnQuc2VyaWFsaXplRm4odmFsdWUsIHsgZGVwdGg6IGRlcHRoIC0gMSwgc2VlbiB9KSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldChcbiAgICAgICAgICBBcnJheS5mcm9tKGRhdGEpLm1hcChcbiAgICAgICAgICAgICh2YWwpID0+IHRyYW5zcG9ydC5zZXJpYWxpemVGbih2YWwsIHsgZGVwdGg6IGRlcHRoIC0gMSwgc2VlbiB9KSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBzZWVuLmFkZChkYXRhKTtcblxuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YSkubWFwKFxuICAgICAgICAgIChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHRyYW5zcG9ydC5zZXJpYWxpemVGbih2YWx1ZSwgeyBkZXB0aDogZGVwdGggLSAxLCBzZWVuIH0pLFxuICAgICAgICAgIF0sXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH0sXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHRyYW5zcG9ydChtZXNzYWdlKSB7XG4gICAgaWYgKCF3aW5kb3cuX19lbGVjdHJvbkxvZykge1xuICAgICAgbG9nZ2VyLnByb2Nlc3NNZXNzYWdlKFxuICAgICAgICB7XG4gICAgICAgICAgZGF0YTogWydlbGVjdHJvbi1sb2c6IGxvZ2dlciBpc25cXCd0IGluaXRpYWxpemVkIGluIHRoZSBtYWluIHByb2Nlc3MnXSxcbiAgICAgICAgICBsZXZlbDogJ2Vycm9yJyxcbiAgICAgICAgfSxcbiAgICAgICAgeyB0cmFuc3BvcnRzOiBbJ2NvbnNvbGUnXSB9LFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgX19lbGVjdHJvbkxvZy5zZW5kVG9NYWluKHRyYW5zcG9ydC5zZXJpYWxpemVGbihtZXNzYWdlLCB7XG4gICAgICAgIGRlcHRoOiB0cmFuc3BvcnQuZGVwdGgsXG4gICAgICB9KSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLnRyYW5zcG9ydHMuY29uc29sZSh7XG4gICAgICAgIGRhdGE6IFsnZWxlY3Ryb25Mb2cudHJhbnNwb3J0cy5pcGMnLCBlLCAnZGF0YTonLCBtZXNzYWdlLmRhdGFdLFxuICAgICAgICBsZXZlbDogJ2Vycm9yJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZWxlY3Ryb24gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xuY29uc3QganNvbmZpbGUgPSByZXF1aXJlKCdqc29uZmlsZScpO1xuY29uc3QgbWtkaXJwID0gcmVxdWlyZSgnbWtkaXJwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgY29uc3QgYXBwID0gZWxlY3Ryb24uYXBwIHx8IGVsZWN0cm9uLnJlbW90ZS5hcHA7XG4gIGNvbnN0IHNjcmVlbiA9IGVsZWN0cm9uLnNjcmVlbiB8fCBlbGVjdHJvbi5yZW1vdGUuc2NyZWVuO1xuICBsZXQgc3RhdGU7XG4gIGxldCB3aW5SZWY7XG4gIGxldCBzdGF0ZUNoYW5nZVRpbWVyO1xuICBjb25zdCBldmVudEhhbmRsaW5nRGVsYXkgPSAxMDA7XG4gIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGZpbGU6ICd3aW5kb3ctc3RhdGUuanNvbicsXG4gICAgcGF0aDogYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksXG4gICAgbWF4aW1pemU6IHRydWUsXG4gICAgZnVsbFNjcmVlbjogdHJ1ZVxuICB9LCBvcHRpb25zKTtcbiAgY29uc3QgZnVsbFN0b3JlRmlsZU5hbWUgPSBwYXRoLmpvaW4oY29uZmlnLnBhdGgsIGNvbmZpZy5maWxlKTtcblxuICBmdW5jdGlvbiBpc05vcm1hbCh3aW4pIHtcbiAgICByZXR1cm4gIXdpbi5pc01heGltaXplZCgpICYmICF3aW4uaXNNaW5pbWl6ZWQoKSAmJiAhd2luLmlzRnVsbFNjcmVlbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQm91bmRzKCkge1xuICAgIHJldHVybiBzdGF0ZSAmJlxuICAgICAgTnVtYmVyLmlzSW50ZWdlcihzdGF0ZS54KSAmJlxuICAgICAgTnVtYmVyLmlzSW50ZWdlcihzdGF0ZS55KSAmJlxuICAgICAgTnVtYmVyLmlzSW50ZWdlcihzdGF0ZS53aWR0aCkgJiYgc3RhdGUud2lkdGggPiAwICYmXG4gICAgICBOdW1iZXIuaXNJbnRlZ2VyKHN0YXRlLmhlaWdodCkgJiYgc3RhdGUuaGVpZ2h0ID4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0U3RhdGVUb0RlZmF1bHQoKSB7XG4gICAgY29uc3QgZGlzcGxheUJvdW5kcyA9IHNjcmVlbi5nZXRQcmltYXJ5RGlzcGxheSgpLmJvdW5kcztcblxuICAgIC8vIFJlc2V0IHN0YXRlIHRvIGRlZmF1bHQgdmFsdWVzIG9uIHRoZSBwcmltYXJ5IGRpc3BsYXlcbiAgICBzdGF0ZSA9IHtcbiAgICAgIHdpZHRoOiBjb25maWcuZGVmYXVsdFdpZHRoIHx8IDgwMCxcbiAgICAgIGhlaWdodDogY29uZmlnLmRlZmF1bHRIZWlnaHQgfHwgNjAwLFxuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICBkaXNwbGF5Qm91bmRzXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpbmRvd1dpdGhpbkJvdW5kcyhib3VuZHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3RhdGUueCA+PSBib3VuZHMueCAmJlxuICAgICAgc3RhdGUueSA+PSBib3VuZHMueSAmJlxuICAgICAgc3RhdGUueCArIHN0YXRlLndpZHRoIDw9IGJvdW5kcy54ICsgYm91bmRzLndpZHRoICYmXG4gICAgICBzdGF0ZS55ICsgc3RhdGUuaGVpZ2h0IDw9IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodFxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVXaW5kb3dWaXNpYmxlT25Tb21lRGlzcGxheSgpIHtcbiAgICBjb25zdCB2aXNpYmxlID0gc2NyZWVuLmdldEFsbERpc3BsYXlzKCkuc29tZShkaXNwbGF5ID0+IHtcbiAgICAgIHJldHVybiB3aW5kb3dXaXRoaW5Cb3VuZHMoZGlzcGxheS5ib3VuZHMpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAvLyBXaW5kb3cgaXMgcGFydGlhbGx5IG9yIGZ1bGx5IG5vdCB2aXNpYmxlIG5vdy5cbiAgICAgIC8vIFJlc2V0IGl0IHRvIHNhZmUgZGVmYXVsdHMuXG4gICAgICByZXR1cm4gcmVzZXRTdGF0ZVRvRGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlU3RhdGUoKSB7XG4gICAgY29uc3QgaXNWYWxpZCA9IHN0YXRlICYmIChoYXNCb3VuZHMoKSB8fCBzdGF0ZS5pc01heGltaXplZCB8fCBzdGF0ZS5pc0Z1bGxTY3JlZW4pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChoYXNCb3VuZHMoKSAmJiBzdGF0ZS5kaXNwbGF5Qm91bmRzKSB7XG4gICAgICBlbnN1cmVXaW5kb3dWaXNpYmxlT25Tb21lRGlzcGxheSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHdpbikge1xuICAgIHdpbiA9IHdpbiB8fCB3aW5SZWY7XG4gICAgaWYgKCF3aW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRG9uJ3QgdGhyb3cgYW4gZXJyb3Igd2hlbiB3aW5kb3cgd2FzIGNsb3NlZFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB3aW5Cb3VuZHMgPSB3aW4uZ2V0Qm91bmRzKCk7XG4gICAgICBpZiAoaXNOb3JtYWwod2luKSkge1xuICAgICAgICBzdGF0ZS54ID0gd2luQm91bmRzLng7XG4gICAgICAgIHN0YXRlLnkgPSB3aW5Cb3VuZHMueTtcbiAgICAgICAgc3RhdGUud2lkdGggPSB3aW5Cb3VuZHMud2lkdGg7XG4gICAgICAgIHN0YXRlLmhlaWdodCA9IHdpbkJvdW5kcy5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBzdGF0ZS5pc01heGltaXplZCA9IHdpbi5pc01heGltaXplZCgpO1xuICAgICAgc3RhdGUuaXNGdWxsU2NyZWVuID0gd2luLmlzRnVsbFNjcmVlbigpO1xuICAgICAgc3RhdGUuZGlzcGxheUJvdW5kcyA9IHNjcmVlbi5nZXREaXNwbGF5TWF0Y2hpbmcod2luQm91bmRzKS5ib3VuZHM7XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuICB9XG5cbiAgZnVuY3Rpb24gc2F2ZVN0YXRlKHdpbikge1xuICAgIC8vIFVwZGF0ZSB3aW5kb3cgc3RhdGUgb25seSBpZiBpdCB3YXMgcHJvdmlkZWRcbiAgICBpZiAod2luKSB7XG4gICAgICB1cGRhdGVTdGF0ZSh3aW4pO1xuICAgIH1cblxuICAgIC8vIFNhdmUgc3RhdGVcbiAgICB0cnkge1xuICAgICAgbWtkaXJwLnN5bmMocGF0aC5kaXJuYW1lKGZ1bGxTdG9yZUZpbGVOYW1lKSk7XG4gICAgICBqc29uZmlsZS53cml0ZUZpbGVTeW5jKGZ1bGxTdG9yZUZpbGVOYW1lLCBzdGF0ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBEb24ndCBjYXJlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhdGVDaGFuZ2VIYW5kbGVyKCkge1xuICAgIC8vIEhhbmRsZXMgYm90aCAncmVzaXplJyBhbmQgJ21vdmUnXG4gICAgY2xlYXJUaW1lb3V0KHN0YXRlQ2hhbmdlVGltZXIpO1xuICAgIHN0YXRlQ2hhbmdlVGltZXIgPSBzZXRUaW1lb3V0KHVwZGF0ZVN0YXRlLCBldmVudEhhbmRsaW5nRGVsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VIYW5kbGVyKCkge1xuICAgIHVwZGF0ZVN0YXRlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZWRIYW5kbGVyKCkge1xuICAgIC8vIFVucmVnaXN0ZXIgbGlzdGVuZXJzIGFuZCBzYXZlIHN0YXRlXG4gICAgdW5tYW5hZ2UoKTtcbiAgICBzYXZlU3RhdGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hbmFnZSh3aW4pIHtcbiAgICBpZiAoY29uZmlnLm1heGltaXplICYmIHN0YXRlLmlzTWF4aW1pemVkKSB7XG4gICAgICB3aW4ubWF4aW1pemUoKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5mdWxsU2NyZWVuICYmIHN0YXRlLmlzRnVsbFNjcmVlbikge1xuICAgICAgd2luLnNldEZ1bGxTY3JlZW4odHJ1ZSk7XG4gICAgfVxuICAgIHdpbi5vbigncmVzaXplJywgc3RhdGVDaGFuZ2VIYW5kbGVyKTtcbiAgICB3aW4ub24oJ21vdmUnLCBzdGF0ZUNoYW5nZUhhbmRsZXIpO1xuICAgIHdpbi5vbignY2xvc2UnLCBjbG9zZUhhbmRsZXIpO1xuICAgIHdpbi5vbignY2xvc2VkJywgY2xvc2VkSGFuZGxlcik7XG4gICAgd2luUmVmID0gd2luO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5tYW5hZ2UoKSB7XG4gICAgaWYgKHdpblJlZikge1xuICAgICAgd2luUmVmLnJlbW92ZUxpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZUNoYW5nZUhhbmRsZXIpO1xuICAgICAgd2luUmVmLnJlbW92ZUxpc3RlbmVyKCdtb3ZlJywgc3RhdGVDaGFuZ2VIYW5kbGVyKTtcbiAgICAgIGNsZWFyVGltZW91dChzdGF0ZUNoYW5nZVRpbWVyKTtcbiAgICAgIHdpblJlZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbG9zZUhhbmRsZXIpO1xuICAgICAgd2luUmVmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZWQnLCBjbG9zZWRIYW5kbGVyKTtcbiAgICAgIHdpblJlZiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBwcmV2aW91cyBzdGF0ZVxuICB0cnkge1xuICAgIHN0YXRlID0ganNvbmZpbGUucmVhZEZpbGVTeW5jKGZ1bGxTdG9yZUZpbGVOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRG9uJ3QgY2FyZVxuICB9XG5cbiAgLy8gQ2hlY2sgc3RhdGUgdmFsaWRpdHlcbiAgdmFsaWRhdGVTdGF0ZSgpO1xuXG4gIC8vIFNldCBzdGF0ZSBmYWxsYmFjayB2YWx1ZXNcbiAgc3RhdGUgPSBPYmplY3QuYXNzaWduKHtcbiAgICB3aWR0aDogY29uZmlnLmRlZmF1bHRXaWR0aCB8fCA4MDAsXG4gICAgaGVpZ2h0OiBjb25maWcuZGVmYXVsdEhlaWdodCB8fCA2MDBcbiAgfSwgc3RhdGUpO1xuXG4gIHJldHVybiB7XG4gICAgZ2V0IHgoKSB7IHJldHVybiBzdGF0ZS54OyB9LFxuICAgIGdldCB5KCkgeyByZXR1cm4gc3RhdGUueTsgfSxcbiAgICBnZXQgd2lkdGgoKSB7IHJldHVybiBzdGF0ZS53aWR0aDsgfSxcbiAgICBnZXQgaGVpZ2h0KCkgeyByZXR1cm4gc3RhdGUuaGVpZ2h0OyB9LFxuICAgIGdldCBkaXNwbGF5Qm91bmRzKCkgeyByZXR1cm4gc3RhdGUuZGlzcGxheUJvdW5kczsgfSxcbiAgICBnZXQgaXNNYXhpbWl6ZWQoKSB7IHJldHVybiBzdGF0ZS5pc01heGltaXplZDsgfSxcbiAgICBnZXQgaXNGdWxsU2NyZWVuKCkgeyByZXR1cm4gc3RhdGUuaXNGdWxsU2NyZWVuOyB9LFxuICAgIHNhdmVTdGF0ZSxcbiAgICB1bm1hbmFnZSxcbiAgICBtYW5hZ2UsXG4gICAgcmVzZXRTdGF0ZVRvRGVmYXVsdFxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lXG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmouX19wcm90b19fXG59XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JylcbiAgICByZXR1cm4gb2JqXG5cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIE9iamVjdClcbiAgICB2YXIgY29weSA9IHsgX19wcm90b19fOiBnZXRQcm90b3R5cGVPZihvYmopIH1cbiAgZWxzZVxuICAgIHZhciBjb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvcHksIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkpXG4gIH0pXG5cbiAgcmV0dXJuIGNvcHlcbn1cbiIsInZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBwb2x5ZmlsbHMgPSByZXF1aXJlKCcuL3BvbHlmaWxscy5qcycpXG52YXIgbGVnYWN5ID0gcmVxdWlyZSgnLi9sZWdhY3ktc3RyZWFtcy5qcycpXG52YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lLmpzJylcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBub2RlIDAueCBwb2x5ZmlsbCAqL1xudmFyIGdyYWNlZnVsUXVldWVcbnZhciBwcmV2aW91c1N5bWJvbFxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIG5vZGUgMC54IHBvbHlmaWxsICovXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBncmFjZWZ1bFF1ZXVlID0gU3ltYm9sLmZvcignZ3JhY2VmdWwtZnMucXVldWUnKVxuICAvLyBUaGlzIGlzIHVzZWQgaW4gdGVzdGluZyBieSBmdXR1cmUgdmVyc2lvbnNcbiAgcHJldmlvdXNTeW1ib2wgPSBTeW1ib2wuZm9yKCdncmFjZWZ1bC1mcy5wcmV2aW91cycpXG59IGVsc2Uge1xuICBncmFjZWZ1bFF1ZXVlID0gJ19fX2dyYWNlZnVsLWZzLnF1ZXVlJ1xuICBwcmV2aW91c1N5bWJvbCA9ICdfX19ncmFjZWZ1bC1mcy5wcmV2aW91cydcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBwdWJsaXNoUXVldWUoY29udGV4dCwgcXVldWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnRleHQsIGdyYWNlZnVsUXVldWUsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHF1ZXVlXG4gICAgfVxuICB9KVxufVxuXG52YXIgZGVidWcgPSBub29wXG5pZiAodXRpbC5kZWJ1Z2xvZylcbiAgZGVidWcgPSB1dGlsLmRlYnVnbG9nKCdnZnM0JylcbmVsc2UgaWYgKC9cXGJnZnM0XFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnKSlcbiAgZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbSA9IHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cylcbiAgICBtID0gJ0dGUzQ6ICcgKyBtLnNwbGl0KC9cXG4vKS5qb2luKCdcXG5HRlM0OiAnKVxuICAgIGNvbnNvbGUuZXJyb3IobSlcbiAgfVxuXG4vLyBPbmNlIHRpbWUgaW5pdGlhbGl6YXRpb25cbmlmICghZnNbZ3JhY2VmdWxRdWV1ZV0pIHtcbiAgLy8gVGhpcyBxdWV1ZSBjYW4gYmUgc2hhcmVkIGJ5IG11bHRpcGxlIGxvYWRlZCBpbnN0YW5jZXNcbiAgdmFyIHF1ZXVlID0gZ2xvYmFsW2dyYWNlZnVsUXVldWVdIHx8IFtdXG4gIHB1Ymxpc2hRdWV1ZShmcywgcXVldWUpXG5cbiAgLy8gUGF0Y2ggZnMuY2xvc2UvY2xvc2VTeW5jIHRvIHNoYXJlZCBxdWV1ZSB2ZXJzaW9uLCBiZWNhdXNlIHdlIG5lZWRcbiAgLy8gdG8gcmV0cnkoKSB3aGVuZXZlciBhIGNsb3NlIGhhcHBlbnMgKmFueXdoZXJlKiBpbiB0aGUgcHJvZ3JhbS5cbiAgLy8gVGhpcyBpcyBlc3NlbnRpYWwgd2hlbiBtdWx0aXBsZSBncmFjZWZ1bC1mcyBpbnN0YW5jZXMgYXJlXG4gIC8vIGluIHBsYXkgYXQgdGhlIHNhbWUgdGltZS5cbiAgZnMuY2xvc2UgPSAoZnVuY3Rpb24gKGZzJGNsb3NlKSB7XG4gICAgZnVuY3Rpb24gY2xvc2UgKGZkLCBjYikge1xuICAgICAgcmV0dXJuIGZzJGNsb3NlLmNhbGwoZnMsIGZkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgZ3JhY2VmdWwtZnMgc2hhcmVkIHF1ZXVlXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgcmVzZXRRdWV1ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlLCBwcmV2aW91c1N5bWJvbCwge1xuICAgICAgdmFsdWU6IGZzJGNsb3NlXG4gICAgfSlcbiAgICByZXR1cm4gY2xvc2VcbiAgfSkoZnMuY2xvc2UpXG5cbiAgZnMuY2xvc2VTeW5jID0gKGZ1bmN0aW9uIChmcyRjbG9zZVN5bmMpIHtcbiAgICBmdW5jdGlvbiBjbG9zZVN5bmMgKGZkKSB7XG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgZnMkY2xvc2VTeW5jLmFwcGx5KGZzLCBhcmd1bWVudHMpXG4gICAgICByZXNldFF1ZXVlKClcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvc2VTeW5jLCBwcmV2aW91c1N5bWJvbCwge1xuICAgICAgdmFsdWU6IGZzJGNsb3NlU3luY1xuICAgIH0pXG4gICAgcmV0dXJuIGNsb3NlU3luY1xuICB9KShmcy5jbG9zZVN5bmMpXG5cbiAgaWYgKC9cXGJnZnM0XFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnKSkge1xuICAgIHByb2Nlc3Mub24oJ2V4aXQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKGZzW2dyYWNlZnVsUXVldWVdKVxuICAgICAgcmVxdWlyZSgnYXNzZXJ0JykuZXF1YWwoZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoLCAwKVxuICAgIH0pXG4gIH1cbn1cblxuaWYgKCFnbG9iYWxbZ3JhY2VmdWxRdWV1ZV0pIHtcbiAgcHVibGlzaFF1ZXVlKGdsb2JhbCwgZnNbZ3JhY2VmdWxRdWV1ZV0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoKGNsb25lKGZzKSlcbmlmIChwcm9jZXNzLmVudi5URVNUX0dSQUNFRlVMX0ZTX0dMT0JBTF9QQVRDSCAmJiAhZnMuX19wYXRjaGVkKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXRjaChmcylcbiAgICBmcy5fX3BhdGNoZWQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBwYXRjaCAoZnMpIHtcbiAgLy8gRXZlcnl0aGluZyB0aGF0IHJlZmVyZW5jZXMgdGhlIG9wZW4oKSBmdW5jdGlvbiBuZWVkcyB0byBiZSBpbiBoZXJlXG4gIHBvbHlmaWxscyhmcylcbiAgZnMuZ3JhY2VmdWxpZnkgPSBwYXRjaFxuXG4gIGZzLmNyZWF0ZVJlYWRTdHJlYW0gPSBjcmVhdGVSZWFkU3RyZWFtXG4gIGZzLmNyZWF0ZVdyaXRlU3RyZWFtID0gY3JlYXRlV3JpdGVTdHJlYW1cbiAgdmFyIGZzJHJlYWRGaWxlID0gZnMucmVhZEZpbGVcbiAgZnMucmVhZEZpbGUgPSByZWFkRmlsZVxuICBmdW5jdGlvbiByZWFkRmlsZSAocGF0aCwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kcmVhZEZpbGUocGF0aCwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRyZWFkRmlsZSAocGF0aCwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kcmVhZEZpbGUsIFtwYXRoLCBvcHRpb25zLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyR3cml0ZUZpbGUgPSBmcy53cml0ZUZpbGVcbiAgZnMud3JpdGVGaWxlID0gd3JpdGVGaWxlXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kd3JpdGVGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kd3JpdGVGaWxlLCBbcGF0aCwgZGF0YSwgb3B0aW9ucywgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB2YXIgZnMkYXBwZW5kRmlsZSA9IGZzLmFwcGVuZEZpbGVcbiAgaWYgKGZzJGFwcGVuZEZpbGUpXG4gICAgZnMuYXBwZW5kRmlsZSA9IGFwcGVuZEZpbGVcbiAgZnVuY3Rpb24gYXBwZW5kRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJGFwcGVuZEZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kYXBwZW5kRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJGNvcHlGaWxlID0gZnMuY29weUZpbGVcbiAgaWYgKGZzJGNvcHlGaWxlKVxuICAgIGZzLmNvcHlGaWxlID0gY29weUZpbGVcbiAgZnVuY3Rpb24gY29weUZpbGUgKHNyYywgZGVzdCwgZmxhZ3MsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBmbGFnc1xuICAgICAgZmxhZ3MgPSAwXG4gICAgfVxuICAgIHJldHVybiBnbyRjb3B5RmlsZShzcmMsIGRlc3QsIGZsYWdzLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJGNvcHlGaWxlIChzcmMsIGRlc3QsIGZsYWdzLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkY29weUZpbGUoc3JjLCBkZXN0LCBmbGFncywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRjb3B5RmlsZSwgW3NyYywgZGVzdCwgZmxhZ3MsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJHJlYWRkaXIgPSBmcy5yZWFkZGlyXG4gIGZzLnJlYWRkaXIgPSByZWFkZGlyXG4gIHZhciBub1JlYWRkaXJPcHRpb25WZXJzaW9ucyA9IC9edlswLTVdXFwuL1xuICBmdW5jdGlvbiByZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHZhciBnbyRyZWFkZGlyID0gbm9SZWFkZGlyT3B0aW9uVmVyc2lvbnMudGVzdChwcm9jZXNzLnZlcnNpb24pXG4gICAgICA/IGZ1bmN0aW9uIGdvJHJlYWRkaXIgKHBhdGgsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZzJHJlYWRkaXIocGF0aCwgZnMkcmVhZGRpckNhbGxiYWNrKFxuICAgICAgICAgIHBhdGgsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWVcbiAgICAgICAgKSlcbiAgICAgIH1cbiAgICAgIDogZnVuY3Rpb24gZ28kcmVhZGRpciAocGF0aCwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgICByZXR1cm4gZnMkcmVhZGRpcihwYXRoLCBvcHRpb25zLCBmcyRyZWFkZGlyQ2FsbGJhY2soXG4gICAgICAgICAgcGF0aCwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZVxuICAgICAgICApKVxuICAgICAgfVxuXG4gICAgcmV0dXJuIGdvJHJlYWRkaXIocGF0aCwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBmcyRyZWFkZGlyQ2FsbGJhY2sgKHBhdGgsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtcbiAgICAgICAgICAgIGdvJHJlYWRkaXIsXG4gICAgICAgICAgICBbcGF0aCwgb3B0aW9ucywgY2JdLFxuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgc3RhcnRUaW1lIHx8IERhdGUubm93KCksXG4gICAgICAgICAgICBEYXRlLm5vdygpXG4gICAgICAgICAgXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGZpbGVzICYmIGZpbGVzLnNvcnQpXG4gICAgICAgICAgICBmaWxlcy5zb3J0KClcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5jYWxsKHRoaXMsIGVyciwgZmlsZXMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy52ZXJzaW9uLnN1YnN0cigwLCA0KSA9PT0gJ3YwLjgnKSB7XG4gICAgdmFyIGxlZ1N0cmVhbXMgPSBsZWdhY3koZnMpXG4gICAgUmVhZFN0cmVhbSA9IGxlZ1N0cmVhbXMuUmVhZFN0cmVhbVxuICAgIFdyaXRlU3RyZWFtID0gbGVnU3RyZWFtcy5Xcml0ZVN0cmVhbVxuICB9XG5cbiAgdmFyIGZzJFJlYWRTdHJlYW0gPSBmcy5SZWFkU3RyZWFtXG4gIGlmIChmcyRSZWFkU3RyZWFtKSB7XG4gICAgUmVhZFN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGZzJFJlYWRTdHJlYW0ucHJvdG90eXBlKVxuICAgIFJlYWRTdHJlYW0ucHJvdG90eXBlLm9wZW4gPSBSZWFkU3RyZWFtJG9wZW5cbiAgfVxuXG4gIHZhciBmcyRXcml0ZVN0cmVhbSA9IGZzLldyaXRlU3RyZWFtXG4gIGlmIChmcyRXcml0ZVN0cmVhbSkge1xuICAgIFdyaXRlU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZnMkV3JpdGVTdHJlYW0ucHJvdG90eXBlKVxuICAgIFdyaXRlU3RyZWFtLnByb3RvdHlwZS5vcGVuID0gV3JpdGVTdHJlYW0kb3BlblxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnUmVhZFN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBSZWFkU3RyZWFtXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIFJlYWRTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgJ1dyaXRlU3RyZWFtJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFdyaXRlU3RyZWFtXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIFdyaXRlU3RyZWFtID0gdmFsXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuXG4gIC8vIGxlZ2FjeSBuYW1lc1xuICB2YXIgRmlsZVJlYWRTdHJlYW0gPSBSZWFkU3RyZWFtXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgJ0ZpbGVSZWFkU3RyZWFtJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEZpbGVSZWFkU3RyZWFtXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIEZpbGVSZWFkU3RyZWFtID0gdmFsXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuICB2YXIgRmlsZVdyaXRlU3RyZWFtID0gV3JpdGVTdHJlYW1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnRmlsZVdyaXRlU3RyZWFtJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEZpbGVXcml0ZVN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBGaWxlV3JpdGVTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG5cbiAgZnVuY3Rpb24gUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUmVhZFN0cmVhbSlcbiAgICAgIHJldHVybiBmcyRSZWFkU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXNcbiAgICBlbHNlXG4gICAgICByZXR1cm4gUmVhZFN0cmVhbS5hcHBseShPYmplY3QuY3JlYXRlKFJlYWRTdHJlYW0ucHJvdG90eXBlKSwgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gUmVhZFN0cmVhbSRvcGVuICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBvcGVuKHRoYXQucGF0aCwgdGhhdC5mbGFncywgdGhhdC5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAodGhhdC5hdXRvQ2xvc2UpXG4gICAgICAgICAgdGhhdC5kZXN0cm95KClcblxuICAgICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5mZCA9IGZkXG4gICAgICAgIHRoYXQuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgICB0aGF0LnJlYWQoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pXG4gICAgICByZXR1cm4gZnMkV3JpdGVTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBXcml0ZVN0cmVhbS5hcHBseShPYmplY3QuY3JlYXRlKFdyaXRlU3RyZWFtLnByb3RvdHlwZSksIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtJG9wZW4gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIG9wZW4odGhhdC5wYXRoLCB0aGF0LmZsYWdzLCB0aGF0Lm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoYXQuZGVzdHJveSgpXG4gICAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LmZkID0gZmRcbiAgICAgICAgdGhhdC5lbWl0KCdvcGVuJywgZmQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IGZzLlJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucylcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBmcy5Xcml0ZVN0cmVhbShwYXRoLCBvcHRpb25zKVxuICB9XG5cbiAgdmFyIGZzJG9wZW4gPSBmcy5vcGVuXG4gIGZzLm9wZW4gPSBvcGVuXG4gIGZ1bmN0aW9uIG9wZW4gKHBhdGgsIGZsYWdzLCBtb2RlLCBjYikge1xuICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gbW9kZSwgbW9kZSA9IG51bGxcblxuICAgIHJldHVybiBnbyRvcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJG9wZW4gKHBhdGgsIGZsYWdzLCBtb2RlLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkb3BlbihwYXRoLCBmbGFncywgbW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kb3BlbiwgW3BhdGgsIGZsYWdzLCBtb2RlLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmc1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlIChlbGVtKSB7XG4gIGRlYnVnKCdFTlFVRVVFJywgZWxlbVswXS5uYW1lLCBlbGVtWzFdKVxuICBmc1tncmFjZWZ1bFF1ZXVlXS5wdXNoKGVsZW0pXG4gIHJldHJ5KClcbn1cblxuLy8ga2VlcCB0cmFjayBvZiB0aGUgdGltZW91dCBiZXR3ZWVuIHJldHJ5KCkgY2FsbHNcbnZhciByZXRyeVRpbWVyXG5cbi8vIHJlc2V0IHRoZSBzdGFydFRpbWUgYW5kIGxhc3RUaW1lIHRvIG5vd1xuLy8gdGhpcyByZXNldHMgdGhlIHN0YXJ0IG9mIHRoZSA2MCBzZWNvbmQgb3ZlcmFsbCB0aW1lb3V0IGFzIHdlbGwgYXMgdGhlXG4vLyBkZWxheSBiZXR3ZWVuIGF0dGVtcHRzIHNvIHRoYXQgd2UnbGwgcmV0cnkgdGhlc2Ugam9icyBzb29uZXJcbmZ1bmN0aW9uIHJlc2V0UXVldWUgKCkge1xuICB2YXIgbm93ID0gRGF0ZS5ub3coKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZzW2dyYWNlZnVsUXVldWVdLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gZW50cmllcyB0aGF0IGFyZSBvbmx5IGEgbGVuZ3RoIG9mIDIgYXJlIGZyb20gYW4gb2xkZXIgdmVyc2lvbiwgZG9uJ3RcbiAgICAvLyBib3RoZXIgbW9kaWZ5aW5nIHRob3NlIHNpbmNlIHRoZXknbGwgYmUgcmV0cmllZCBhbnl3YXkuXG4gICAgaWYgKGZzW2dyYWNlZnVsUXVldWVdW2ldLmxlbmd0aCA+IDIpIHtcbiAgICAgIGZzW2dyYWNlZnVsUXVldWVdW2ldWzNdID0gbm93IC8vIHN0YXJ0VGltZVxuICAgICAgZnNbZ3JhY2VmdWxRdWV1ZV1baV1bNF0gPSBub3cgLy8gbGFzdFRpbWVcbiAgICB9XG4gIH1cbiAgLy8gY2FsbCByZXRyeSB0byBtYWtlIHN1cmUgd2UncmUgYWN0aXZlbHkgcHJvY2Vzc2luZyB0aGUgcXVldWVcbiAgcmV0cnkoKVxufVxuXG5mdW5jdGlvbiByZXRyeSAoKSB7XG4gIC8vIGNsZWFyIHRoZSB0aW1lciBhbmQgcmVtb3ZlIGl0IHRvIGhlbHAgcHJldmVudCB1bmludGVuZGVkIGNvbmN1cnJlbmN5XG4gIGNsZWFyVGltZW91dChyZXRyeVRpbWVyKVxuICByZXRyeVRpbWVyID0gdW5kZWZpbmVkXG5cbiAgaWYgKGZzW2dyYWNlZnVsUXVldWVdLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm5cblxuICB2YXIgZWxlbSA9IGZzW2dyYWNlZnVsUXVldWVdLnNoaWZ0KClcbiAgdmFyIGZuID0gZWxlbVswXVxuICB2YXIgYXJncyA9IGVsZW1bMV1cbiAgLy8gdGhlc2UgaXRlbXMgbWF5IGJlIHVuc2V0IGlmIHRoZXkgd2VyZSBhZGRlZCBieSBhbiBvbGRlciBncmFjZWZ1bC1mc1xuICB2YXIgZXJyID0gZWxlbVsyXVxuICB2YXIgc3RhcnRUaW1lID0gZWxlbVszXVxuICB2YXIgbGFzdFRpbWUgPSBlbGVtWzRdXG5cbiAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhIHN0YXJ0VGltZSB3ZSBoYXZlIG5vIHdheSBvZiBrbm93aW5nIGlmIHdlJ3ZlIHdhaXRlZFxuICAvLyBsb25nIGVub3VnaCwgc28gZ28gYWhlYWQgYW5kIHJldHJ5IHRoaXMgaXRlbSBub3dcbiAgaWYgKHN0YXJ0VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWcoJ1JFVFJZJywgZm4ubmFtZSwgYXJncylcbiAgICBmbi5hcHBseShudWxsLCBhcmdzKVxuICB9IGVsc2UgaWYgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPj0gNjAwMDApIHtcbiAgICAvLyBpdCdzIGJlZW4gbW9yZSB0aGFuIDYwIHNlY29uZHMgdG90YWwsIGJhaWwgbm93XG4gICAgZGVidWcoJ1RJTUVPVVQnLCBmbi5uYW1lLCBhcmdzKVxuICAgIHZhciBjYiA9IGFyZ3MucG9wKClcbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IuY2FsbChudWxsLCBlcnIpXG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gdGhlIGxhc3QgYXR0ZW1wdCBhbmQgcmlnaHQgbm93XG4gICAgdmFyIHNpbmNlQXR0ZW1wdCA9IERhdGUubm93KCkgLSBsYXN0VGltZVxuICAgIC8vIHRoZSBhbW91bnQgb2YgdGltZSBiZXR3ZWVuIHdoZW4gd2UgZmlyc3QgdHJpZWQsIGFuZCB3aGVuIHdlIGxhc3QgdHJpZWRcbiAgICAvLyByb3VuZGVkIHVwIHRvIGF0IGxlYXN0IDFcbiAgICB2YXIgc2luY2VTdGFydCA9IE1hdGgubWF4KGxhc3RUaW1lIC0gc3RhcnRUaW1lLCAxKVxuICAgIC8vIGJhY2tvZmYuIHdhaXQgbG9uZ2VyIHRoYW4gdGhlIHRvdGFsIHRpbWUgd2UndmUgYmVlbiByZXRyeWluZywgYnV0IG9ubHlcbiAgICAvLyB1cCB0byBhIG1heGltdW0gb2YgMTAwbXNcbiAgICB2YXIgZGVzaXJlZERlbGF5ID0gTWF0aC5taW4oc2luY2VTdGFydCAqIDEuMiwgMTAwKVxuICAgIC8vIGl0J3MgYmVlbiBsb25nIGVub3VnaCBzaW5jZSB0aGUgbGFzdCByZXRyeSwgZG8gaXQgYWdhaW5cbiAgICBpZiAoc2luY2VBdHRlbXB0ID49IGRlc2lyZWREZWxheSkge1xuICAgICAgZGVidWcoJ1JFVFJZJywgZm4ubmFtZSwgYXJncylcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtzdGFydFRpbWVdKSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgd2UgY2FuJ3QgZG8gdGhpcyBqb2IgeWV0LCBwdXNoIGl0IHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG4gICAgICAvLyBhbmQgbGV0IHRoZSBuZXh0IGl0ZXJhdGlvbiBjaGVjayBhZ2FpblxuICAgICAgZnNbZ3JhY2VmdWxRdWV1ZV0ucHVzaChlbGVtKVxuICAgIH1cbiAgfVxuXG4gIC8vIHNjaGVkdWxlIG91ciBuZXh0IHJ1biBpZiBvbmUgaXNuJ3QgYWxyZWFkeSBzY2hlZHVsZWRcbiAgaWYgKHJldHJ5VGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHJ5VGltZXIgPSBzZXRUaW1lb3V0KHJldHJ5LCAwKVxuICB9XG59XG4iLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtXG5cbm1vZHVsZS5leHBvcnRzID0gbGVnYWN5XG5cbmZ1bmN0aW9uIGxlZ2FjeSAoZnMpIHtcbiAgcmV0dXJuIHtcbiAgICBSZWFkU3RyZWFtOiBSZWFkU3RyZWFtLFxuICAgIFdyaXRlU3RyZWFtOiBXcml0ZVN0cmVhbVxuICB9XG5cbiAgZnVuY3Rpb24gUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkU3RyZWFtKSkgcmV0dXJuIG5ldyBSZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLmZsYWdzID0gJ3InO1xuICAgIHRoaXMubW9kZSA9IDQzODsgLyo9MDY2NiovXG4gICAgdGhpcy5idWZmZXJTaXplID0gNjQgKiAxMDI0O1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBNaXhpbiBvcHRpb25zIGludG8gdGhpc1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbmNvZGluZykgdGhpcy5zZXRFbmNvZGluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmVuZCA9IEluZmluaXR5O1xuICAgICAgfSBlbHNlIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignZW5kIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhcnQgPiB0aGlzLmVuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG11c3QgYmUgPD0gZW5kJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9zID0gdGhpcy5zdGFydDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mZCAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fcmVhZCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnMub3Blbih0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIHNlbGYucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmZkID0gZmQ7XG4gICAgICBzZWxmLmVtaXQoJ29wZW4nLCBmZCk7XG4gICAgICBzZWxmLl9yZWFkKCk7XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRlU3RyZWFtKSkgcmV0dXJuIG5ldyBXcml0ZVN0cmVhbShwYXRoLCBvcHRpb25zKTtcblxuICAgIFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmZkID0gbnVsbDtcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAndyc7XG4gICAgdGhpcy5lbmNvZGluZyA9ICdiaW5hcnknO1xuICAgIHRoaXMubW9kZSA9IDQzODsgLyo9MDY2NiovXG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBNaXhpbiBvcHRpb25zIGludG8gdGhpc1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB0aGlzLnN0YXJ0KSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignc3RhcnQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhcnQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA+PSB6ZXJvJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9zID0gdGhpcy5zdGFydDtcbiAgICB9XG5cbiAgICB0aGlzLmJ1c3kgPSBmYWxzZTtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuXG4gICAgaWYgKHRoaXMuZmQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX29wZW4gPSBmcy5vcGVuO1xuICAgICAgdGhpcy5fcXVldWUucHVzaChbdGhpcy5fb3BlbiwgdGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIHVuZGVmaW5lZF0pO1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgfVxufVxuIiwidmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpXG5cbnZhciBvcmlnQ3dkID0gcHJvY2Vzcy5jd2RcbnZhciBjd2QgPSBudWxsXG5cbnZhciBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52LkdSQUNFRlVMX0ZTX1BMQVRGT1JNIHx8IHByb2Nlc3MucGxhdGZvcm1cblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFjd2QpXG4gICAgY3dkID0gb3JpZ0N3ZC5jYWxsKHByb2Nlc3MpXG4gIHJldHVybiBjd2Rcbn1cbnRyeSB7XG4gIHByb2Nlc3MuY3dkKClcbn0gY2F0Y2ggKGVyKSB7fVxuXG4vLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB1bnRpbCBub2RlLmpzIDEyIGlzIHJlcXVpcmVkXG5pZiAodHlwZW9mIHByb2Nlc3MuY2hkaXIgPT09ICdmdW5jdGlvbicpIHtcbiAgdmFyIGNoZGlyID0gcHJvY2Vzcy5jaGRpclxuICBwcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGQpIHtcbiAgICBjd2QgPSBudWxsXG4gICAgY2hkaXIuY2FsbChwcm9jZXNzLCBkKVxuICB9XG4gIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm9jZXNzLmNoZGlyLCBjaGRpcilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuXG5mdW5jdGlvbiBwYXRjaCAoZnMpIHtcbiAgLy8gKHJlLSlpbXBsZW1lbnQgc29tZSB0aGluZ3MgdGhhdCBhcmUga25vd24gYnVzdGVkIG9yIG1pc3NpbmcuXG5cbiAgLy8gbGNobW9kLCBicm9rZW4gcHJpb3IgdG8gMC42LjJcbiAgLy8gYmFjay1wb3J0IHRoZSBmaXggaGVyZS5cbiAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eSgnT19TWU1MSU5LJykgJiZcbiAgICAgIHByb2Nlc3MudmVyc2lvbi5tYXRjaCgvXnYwXFwuNlxcLlswLTJdfF52MFxcLjVcXC4vKSkge1xuICAgIHBhdGNoTGNobW9kKGZzKVxuICB9XG5cbiAgLy8gbHV0aW1lcyBpbXBsZW1lbnRhdGlvbiwgb3Igbm8tb3BcbiAgaWYgKCFmcy5sdXRpbWVzKSB7XG4gICAgcGF0Y2hMdXRpbWVzKGZzKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdyYWNlZnVsLWZzL2lzc3Vlcy80XG4gIC8vIENob3duIHNob3VsZCBub3QgZmFpbCBvbiBlaW52YWwgb3IgZXBlcm0gaWYgbm9uLXJvb3QuXG4gIC8vIEl0IHNob3VsZCBub3QgZmFpbCBvbiBlbm9zeXMgZXZlciwgYXMgdGhpcyBqdXN0IGluZGljYXRlc1xuICAvLyB0aGF0IGEgZnMgZG9lc24ndCBzdXBwb3J0IHRoZSBpbnRlbmRlZCBvcGVyYXRpb24uXG5cbiAgZnMuY2hvd24gPSBjaG93bkZpeChmcy5jaG93bilcbiAgZnMuZmNob3duID0gY2hvd25GaXgoZnMuZmNob3duKVxuICBmcy5sY2hvd24gPSBjaG93bkZpeChmcy5sY2hvd24pXG5cbiAgZnMuY2htb2QgPSBjaG1vZEZpeChmcy5jaG1vZClcbiAgZnMuZmNobW9kID0gY2htb2RGaXgoZnMuZmNobW9kKVxuICBmcy5sY2htb2QgPSBjaG1vZEZpeChmcy5sY2htb2QpXG5cbiAgZnMuY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmNob3duU3luYylcbiAgZnMuZmNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5mY2hvd25TeW5jKVxuICBmcy5sY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmxjaG93blN5bmMpXG5cbiAgZnMuY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmNobW9kU3luYylcbiAgZnMuZmNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5mY2htb2RTeW5jKVxuICBmcy5sY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmxjaG1vZFN5bmMpXG5cbiAgZnMuc3RhdCA9IHN0YXRGaXgoZnMuc3RhdClcbiAgZnMuZnN0YXQgPSBzdGF0Rml4KGZzLmZzdGF0KVxuICBmcy5sc3RhdCA9IHN0YXRGaXgoZnMubHN0YXQpXG5cbiAgZnMuc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5zdGF0U3luYylcbiAgZnMuZnN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMuZnN0YXRTeW5jKVxuICBmcy5sc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5sc3RhdFN5bmMpXG5cbiAgLy8gaWYgbGNobW9kL2xjaG93biBkbyBub3QgZXhpc3QsIHRoZW4gbWFrZSB0aGVtIG5vLW9wc1xuICBpZiAoZnMuY2htb2QgJiYgIWZzLmxjaG1vZCkge1xuICAgIGZzLmxjaG1vZCA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYikge1xuICAgICAgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKCkge31cbiAgfVxuICBpZiAoZnMuY2hvd24gJiYgIWZzLmxjaG93bikge1xuICAgIGZzLmxjaG93biA9IGZ1bmN0aW9uIChwYXRoLCB1aWQsIGdpZCwgY2IpIHtcbiAgICAgIGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gICAgZnMubGNob3duU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cblxuICAvLyBvbiBXaW5kb3dzLCBBL1Ygc29mdHdhcmUgY2FuIGxvY2sgdGhlIGRpcmVjdG9yeSwgY2F1c2luZyB0aGlzXG4gIC8vIHRvIGZhaWwgd2l0aCBhbiBFQUNDRVMgb3IgRVBFUk0gaWYgdGhlIGRpcmVjdG9yeSBjb250YWlucyBuZXdseVxuICAvLyBjcmVhdGVkIGZpbGVzLiAgVHJ5IGFnYWluIG9uIGZhaWx1cmUsIGZvciB1cCB0byA2MCBzZWNvbmRzLlxuXG4gIC8vIFNldCB0aGUgdGltZW91dCB0aGlzIGxvbmcgYmVjYXVzZSBzb21lIFdpbmRvd3MgQW50aS1WaXJ1cywgc3VjaCBhcyBQYXJpdHlcbiAgLy8gYml0OSwgbWF5IGxvY2sgZmlsZXMgZm9yIHVwIHRvIGEgbWludXRlLCBjYXVzaW5nIG5wbSBwYWNrYWdlIGluc3RhbGxcbiAgLy8gZmFpbHVyZXMuIEFsc28sIHRha2UgY2FyZSB0byB5aWVsZCB0aGUgc2NoZWR1bGVyLiBXaW5kb3dzIHNjaGVkdWxpbmcgZ2l2ZXNcbiAgLy8gQ1BVIHRvIGEgYnVzeSBsb29waW5nIHByb2Nlc3MsIHdoaWNoIGNhbiBjYXVzZSB0aGUgcHJvZ3JhbSBjYXVzaW5nIHRoZSBsb2NrXG4gIC8vIGNvbnRlbnRpb24gdG8gYmUgc3RhcnZlZCBvZiBDUFUgYnkgbm9kZSwgc28gdGhlIGNvbnRlbnRpb24gZG9lc24ndCByZXNvbHZlLlxuICBpZiAocGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgIGZzLnJlbmFtZSA9IHR5cGVvZiBmcy5yZW5hbWUgIT09ICdmdW5jdGlvbicgPyBmcy5yZW5hbWVcbiAgICA6IChmdW5jdGlvbiAoZnMkcmVuYW1lKSB7XG4gICAgICBmdW5jdGlvbiByZW5hbWUgKGZyb20sIHRvLCBjYikge1xuICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpXG4gICAgICAgIHZhciBiYWNrb2ZmID0gMDtcbiAgICAgICAgZnMkcmVuYW1lKGZyb20sIHRvLCBmdW5jdGlvbiBDQiAoZXIpIHtcbiAgICAgICAgICBpZiAoZXJcbiAgICAgICAgICAgICAgJiYgKGVyLmNvZGUgPT09IFwiRUFDQ0VTXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiIHx8IGVyLmNvZGUgPT09IFwiRUJVU1lcIilcbiAgICAgICAgICAgICAgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0IDwgNjAwMDApIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGZzLnN0YXQodG8sIGZ1bmN0aW9uIChzdGF0ZXIsIHN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlciAmJiBzdGF0ZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgICAgICAgICAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgQ0IpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIGNiKGVyKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSwgYmFja29mZilcbiAgICAgICAgICAgIGlmIChiYWNrb2ZmIDwgMTAwKVxuICAgICAgICAgICAgICBiYWNrb2ZmICs9IDEwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikgT2JqZWN0LnNldFByb3RvdHlwZU9mKHJlbmFtZSwgZnMkcmVuYW1lKVxuICAgICAgcmV0dXJuIHJlbmFtZVxuICAgIH0pKGZzLnJlbmFtZSlcbiAgfVxuXG4gIC8vIGlmIHJlYWQoKSByZXR1cm5zIEVBR0FJTiwgdGhlbiBqdXN0IHRyeSBpdCBhZ2Fpbi5cbiAgZnMucmVhZCA9IHR5cGVvZiBmcy5yZWFkICE9PSAnZnVuY3Rpb24nID8gZnMucmVhZFxuICA6IChmdW5jdGlvbiAoZnMkcmVhZCkge1xuICAgIGZ1bmN0aW9uIHJlYWQgKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2tfKSB7XG4gICAgICB2YXIgY2FsbGJhY2tcbiAgICAgIGlmIChjYWxsYmFja18gJiYgdHlwZW9mIGNhbGxiYWNrXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXIsIF8sIF9fKSB7XG4gICAgICAgICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFQUdBSU4nICYmIGVhZ0NvdW50ZXIgPCAxMCkge1xuICAgICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2tfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvLyBUaGlzIGVuc3VyZXMgYHV0aWwucHJvbWlzaWZ5YCB3b3JrcyBhcyBpdCBkb2VzIGZvciBuYXRpdmUgYGZzLnJlYWRgLlxuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIE9iamVjdC5zZXRQcm90b3R5cGVPZihyZWFkLCBmcyRyZWFkKVxuICAgIHJldHVybiByZWFkXG4gIH0pKGZzLnJlYWQpXG5cbiAgZnMucmVhZFN5bmMgPSB0eXBlb2YgZnMucmVhZFN5bmMgIT09ICdmdW5jdGlvbicgPyBmcy5yZWFkU3luY1xuICA6IChmdW5jdGlvbiAoZnMkcmVhZFN5bmMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZzJHJlYWRTeW5jLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbilcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmIChlci5jb2RlID09PSAnRUFHQUlOJyAmJiBlYWdDb3VudGVyIDwgMTApIHtcbiAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfX0pKGZzLnJlYWRTeW5jKVxuXG4gIGZ1bmN0aW9uIHBhdGNoTGNobW9kIChmcykge1xuICAgIGZzLmxjaG1vZCA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYWxsYmFjaykge1xuICAgICAgZnMub3BlbiggcGF0aFxuICAgICAgICAgICAgICwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOS1xuICAgICAgICAgICAgICwgbW9kZVxuICAgICAgICAgICAgICwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgICAgICAvLyBidXQgc3RpbGwgdHJ5IHRvIGNsb3NlLCBhbmQgcmVwb3J0IGNsb3NpbmcgZXJyb3JzIGlmIHRoZXkgb2NjdXIuXG4gICAgICAgIGZzLmZjaG1vZChmZCwgbW9kZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGZzLmNsb3NlKGZkLCBmdW5jdGlvbihlcnIyKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciB8fCBlcnIyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZzLmxjaG1vZFN5bmMgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSkge1xuICAgICAgdmFyIGZkID0gZnMub3BlblN5bmMocGF0aCwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOSywgbW9kZSlcblxuICAgICAgLy8gcHJlZmVyIHRvIHJldHVybiB0aGUgY2htb2QgZXJyb3IsIGlmIG9uZSBvY2N1cnMsXG4gICAgICAvLyBidXQgc3RpbGwgdHJ5IHRvIGNsb3NlLCBhbmQgcmVwb3J0IGNsb3NpbmcgZXJyb3JzIGlmIHRoZXkgb2NjdXIuXG4gICAgICB2YXIgdGhyZXcgPSB0cnVlXG4gICAgICB2YXIgcmV0XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBmcy5mY2htb2RTeW5jKGZkLCBtb2RlKVxuICAgICAgICB0aHJldyA9IGZhbHNlXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoTHV0aW1lcyAoZnMpIHtcbiAgICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KFwiT19TWU1MSU5LXCIpICYmIGZzLmZ1dGltZXMpIHtcbiAgICAgIGZzLmx1dGltZXMgPSBmdW5jdGlvbiAocGF0aCwgYXQsIG10LCBjYikge1xuICAgICAgICBmcy5vcGVuKHBhdGgsIGNvbnN0YW50cy5PX1NZTUxJTkssIGZ1bmN0aW9uIChlciwgZmQpIHtcbiAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIGlmIChjYikgY2IoZXIpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgZnMuZnV0aW1lcyhmZCwgYXQsIG10LCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgICAgIGZzLmNsb3NlKGZkLCBmdW5jdGlvbiAoZXIyKSB7XG4gICAgICAgICAgICAgIGlmIChjYikgY2IoZXIgfHwgZXIyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBmcy5sdXRpbWVzU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBhdCwgbXQpIHtcbiAgICAgICAgdmFyIGZkID0gZnMub3BlblN5bmMocGF0aCwgY29uc3RhbnRzLk9fU1lNTElOSylcbiAgICAgICAgdmFyIHJldFxuICAgICAgICB2YXIgdGhyZXcgPSB0cnVlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0ID0gZnMuZnV0aW1lc1N5bmMoZmQsIGF0LCBtdClcbiAgICAgICAgICB0aHJldyA9IGZhbHNlXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgICAgICB9IGNhdGNoIChlcikge31cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGZzLmZ1dGltZXMpIHtcbiAgICAgIGZzLmx1dGltZXMgPSBmdW5jdGlvbiAoX2EsIF9iLCBfYywgY2IpIHsgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKSB9XG4gICAgICBmcy5sdXRpbWVzU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2htb2RGaXggKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUsIGNiKSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICBpZiAoY2hvd25Fck9rKGVyKSkgZXIgPSBudWxsXG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaG1vZEZpeFN5bmMgKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgbW9kZSlcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNob3duRml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCwgY2IpIHtcbiAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgdWlkLCBnaWQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICBpZiAoY2hvd25Fck9rKGVyKSkgZXIgPSBudWxsXG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaG93bkZpeFN5bmMgKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHVpZCwgZ2lkKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgaWYgKCFjaG93bkVyT2soZXIpKSB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRGaXggKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgTm9kZSBlcnJvbmVvdXNseSByZXR1cm5lZCBzaWduZWQgaW50ZWdlcnMgZm9yXG4gICAgLy8gdWlkICsgZ2lkLlxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0gbnVsbFxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2FsbGJhY2sgKGVyLCBzdGF0cykge1xuICAgICAgICBpZiAoc3RhdHMpIHtcbiAgICAgICAgICBpZiAoc3RhdHMudWlkIDwgMCkgc3RhdHMudWlkICs9IDB4MTAwMDAwMDAwXG4gICAgICAgICAgaWYgKHN0YXRzLmdpZCA8IDApIHN0YXRzLmdpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICB9XG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMgPyBvcmlnLmNhbGwoZnMsIHRhcmdldCwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIDogb3JpZy5jYWxsKGZzLCB0YXJnZXQsIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRGaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAgIC8vIHVpZCArIGdpZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdmFyIHN0YXRzID0gb3B0aW9ucyA/IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBvcHRpb25zKVxuICAgICAgICA6IG9yaWcuY2FsbChmcywgdGFyZ2V0KVxuICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgIGlmIChzdGF0cy51aWQgPCAwKSBzdGF0cy51aWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgICAgaWYgKHN0YXRzLmdpZCA8IDApIHN0YXRzLmdpZCArPSAweDEwMDAwMDAwMFxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVOT1NZUyBtZWFucyB0aGF0IHRoZSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIG9wLiBKdXN0IGlnbm9yZVxuICAvLyB0aGF0LCBiZWNhdXNlIGl0IGRvZXNuJ3QgbWF0dGVyLlxuICAvL1xuICAvLyBpZiB0aGVyZSdzIG5vIGdldHVpZCwgb3IgaWYgZ2V0dWlkKCkgaXMgc29tZXRoaW5nIG90aGVyXG4gIC8vIHRoYW4gMCwgYW5kIHRoZSBlcnJvciBpcyBFSU5WQUwgb3IgRVBFUk0sIHRoZW4ganVzdCBpZ25vcmVcbiAgLy8gaXQuXG4gIC8vXG4gIC8vIFRoaXMgc3BlY2lmaWMgY2FzZSBpcyBhIHNpbGVudCBmYWlsdXJlIGluIGNwLCBpbnN0YWxsLCB0YXIsXG4gIC8vIGFuZCBtb3N0IG90aGVyIHVuaXggdG9vbHMgdGhhdCBtYW5hZ2UgcGVybWlzc2lvbnMuXG4gIC8vXG4gIC8vIFdoZW4gcnVubmluZyBhcyByb290LCBvciBpZiBvdGhlciB0eXBlcyBvZiBlcnJvcnMgYXJlXG4gIC8vIGVuY291bnRlcmVkLCB0aGVuIGl0J3Mgc3RyaWN0LlxuICBmdW5jdGlvbiBjaG93bkVyT2sgKGVyKSB7XG4gICAgaWYgKCFlcilcbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICBpZiAoZXIuY29kZSA9PT0gXCJFTk9TWVNcIilcbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICB2YXIgbm9ucm9vdCA9ICFwcm9jZXNzLmdldHVpZCB8fCBwcm9jZXNzLmdldHVpZCgpICE9PSAwXG4gICAgaWYgKG5vbnJvb3QpIHtcbiAgICAgIGlmIChlci5jb2RlID09PSBcIkVJTlZBTFwiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmbGFnLCBhcmd2ID0gcHJvY2Vzcy5hcmd2KSA9PiB7XG5cdGNvbnN0IHByZWZpeCA9IGZsYWcuc3RhcnRzV2l0aCgnLScpID8gJycgOiAoZmxhZy5sZW5ndGggPT09IDEgPyAnLScgOiAnLS0nKTtcblx0Y29uc3QgcG9zaXRpb24gPSBhcmd2LmluZGV4T2YocHJlZml4ICsgZmxhZyk7XG5cdGNvbnN0IHRlcm1pbmF0b3JQb3NpdGlvbiA9IGFyZ3YuaW5kZXhPZignLS0nKTtcblx0cmV0dXJuIHBvc2l0aW9uICE9PSAtMSAmJiAodGVybWluYXRvclBvc2l0aW9uID09PSAtMSB8fCBwb3NpdGlvbiA8IHRlcm1pbmF0b3JQb3NpdGlvbik7XG59O1xuIiwiLy8gR2VuZXJhdGVkIGZpbGUuIERvIG5vdCBlZGl0XG5leHBvcnQgdmFyIFN0YXR1c0NvZGVzO1xuKGZ1bmN0aW9uIChTdGF0dXNDb2Rlcykge1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuMi4xXG4gICAgICpcbiAgICAgKiBUaGlzIGludGVyaW0gcmVzcG9uc2UgaW5kaWNhdGVzIHRoYXQgZXZlcnl0aGluZyBzbyBmYXIgaXMgT0sgYW5kIHRoYXQgdGhlIGNsaWVudCBzaG91bGQgY29udGludWUgd2l0aCB0aGUgcmVxdWVzdCBvciBpZ25vcmUgaXQgaWYgaXQgaXMgYWxyZWFkeSBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIkNPTlRJTlVFXCJdID0gMTAwXSA9IFwiQ09OVElOVUVcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjIuMlxuICAgICAqXG4gICAgICogVGhpcyBjb2RlIGlzIHNlbnQgaW4gcmVzcG9uc2UgdG8gYW4gVXBncmFkZSByZXF1ZXN0IGhlYWRlciBieSB0aGUgY2xpZW50LCBhbmQgaW5kaWNhdGVzIHRoZSBwcm90b2NvbCB0aGUgc2VydmVyIGlzIHN3aXRjaGluZyB0b28uXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJTV0lUQ0hJTkdfUFJPVE9DT0xTXCJdID0gMTAxXSA9IFwiU1dJVENISU5HX1BST1RPQ09MU1wiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjUxOCNzZWN0aW9uLTEwLjFcbiAgICAgKlxuICAgICAqIFRoaXMgY29kZSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VydmVyIGhhcyByZWNlaXZlZCBhbmQgaXMgcHJvY2Vzc2luZyB0aGUgcmVxdWVzdCwgYnV0IG5vIHJlc3BvbnNlIGlzIGF2YWlsYWJsZSB5ZXQuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJQUk9DRVNTSU5HXCJdID0gMTAyXSA9IFwiUFJPQ0VTU0lOR1wiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjODI5NyNwYWdlLTNcbiAgICAgKlxuICAgICAqIFRoaXMgY29kZSBpbmRpY2F0ZXMgdG8gdGhlIGNsaWVudCB0aGF0IHRoZSBzZXJ2ZXIgaXMgbGlrZWx5IHRvIHNlbmQgYSBmaW5hbCByZXNwb25zZSB3aXRoIHRoZSBoZWFkZXIgZmllbGRzIGluY2x1ZGVkIGluIHRoZSBpbmZvcm1hdGlvbmFsIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiRUFSTFlfSElOVFNcIl0gPSAxMDNdID0gXCJFQVJMWV9ISU5UU1wiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuMy4xXG4gICAgICpcbiAgICAgKiBUaGUgcmVxdWVzdCBoYXMgc3VjY2VlZGVkLiBUaGUgbWVhbmluZyBvZiBhIHN1Y2Nlc3MgdmFyaWVzIGRlcGVuZGluZyBvbiB0aGUgSFRUUCBtZXRob2Q6XG4gICAgICogR0VUOiBUaGUgcmVzb3VyY2UgaGFzIGJlZW4gZmV0Y2hlZCBhbmQgaXMgdHJhbnNtaXR0ZWQgaW4gdGhlIG1lc3NhZ2UgYm9keS5cbiAgICAgKiBIRUFEOiBUaGUgZW50aXR5IGhlYWRlcnMgYXJlIGluIHRoZSBtZXNzYWdlIGJvZHkuXG4gICAgICogUE9TVDogVGhlIHJlc291cmNlIGRlc2NyaWJpbmcgdGhlIHJlc3VsdCBvZiB0aGUgYWN0aW9uIGlzIHRyYW5zbWl0dGVkIGluIHRoZSBtZXNzYWdlIGJvZHkuXG4gICAgICogVFJBQ0U6IFRoZSBtZXNzYWdlIGJvZHkgY29udGFpbnMgdGhlIHJlcXVlc3QgbWVzc2FnZSBhcyByZWNlaXZlZCBieSB0aGUgc2VydmVyXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJPS1wiXSA9IDIwMF0gPSBcIk9LXCI7XG4gICAgLyoqXG4gICAgICogT2ZmaWNpYWwgRG9jdW1lbnRhdGlvbiBAIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi4zLjJcbiAgICAgKlxuICAgICAqIFRoZSByZXF1ZXN0IGhhcyBzdWNjZWVkZWQgYW5kIGEgbmV3IHJlc291cmNlIGhhcyBiZWVuIGNyZWF0ZWQgYXMgYSByZXN1bHQgb2YgaXQuIFRoaXMgaXMgdHlwaWNhbGx5IHRoZSByZXNwb25zZSBzZW50IGFmdGVyIGEgUFVUIHJlcXVlc3QuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJDUkVBVEVEXCJdID0gMjAxXSA9IFwiQ1JFQVRFRFwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuMy4zXG4gICAgICpcbiAgICAgKiBUaGUgcmVxdWVzdCBoYXMgYmVlbiByZWNlaXZlZCBidXQgbm90IHlldCBhY3RlZCB1cG9uLiBJdCBpcyBub24tY29tbWl0dGFsLCBtZWFuaW5nIHRoYXQgdGhlcmUgaXMgbm8gd2F5IGluIEhUVFAgdG8gbGF0ZXIgc2VuZCBhbiBhc3luY2hyb25vdXMgcmVzcG9uc2UgaW5kaWNhdGluZyB0aGUgb3V0Y29tZSBvZiBwcm9jZXNzaW5nIHRoZSByZXF1ZXN0LiBJdCBpcyBpbnRlbmRlZCBmb3IgY2FzZXMgd2hlcmUgYW5vdGhlciBwcm9jZXNzIG9yIHNlcnZlciBoYW5kbGVzIHRoZSByZXF1ZXN0LCBvciBmb3IgYmF0Y2ggcHJvY2Vzc2luZy5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIkFDQ0VQVEVEXCJdID0gMjAyXSA9IFwiQUNDRVBURURcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjMuNFxuICAgICAqXG4gICAgICogVGhpcyByZXNwb25zZSBjb2RlIG1lYW5zIHJldHVybmVkIG1ldGEtaW5mb3JtYXRpb24gc2V0IGlzIG5vdCBleGFjdCBzZXQgYXMgYXZhaWxhYmxlIGZyb20gdGhlIG9yaWdpbiBzZXJ2ZXIsIGJ1dCBjb2xsZWN0ZWQgZnJvbSBhIGxvY2FsIG9yIGEgdGhpcmQgcGFydHkgY29weS4gRXhjZXB0IHRoaXMgY29uZGl0aW9uLCAyMDAgT0sgcmVzcG9uc2Ugc2hvdWxkIGJlIHByZWZlcnJlZCBpbnN0ZWFkIG9mIHRoaXMgcmVzcG9uc2UuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTlwiXSA9IDIwM10gPSBcIk5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OXCI7XG4gICAgLyoqXG4gICAgICogT2ZmaWNpYWwgRG9jdW1lbnRhdGlvbiBAIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi4zLjVcbiAgICAgKlxuICAgICAqIFRoZXJlIGlzIG5vIGNvbnRlbnQgdG8gc2VuZCBmb3IgdGhpcyByZXF1ZXN0LCBidXQgdGhlIGhlYWRlcnMgbWF5IGJlIHVzZWZ1bC4gVGhlIHVzZXItYWdlbnQgbWF5IHVwZGF0ZSBpdHMgY2FjaGVkIGhlYWRlcnMgZm9yIHRoaXMgcmVzb3VyY2Ugd2l0aCB0aGUgbmV3IG9uZXMuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJOT19DT05URU5UXCJdID0gMjA0XSA9IFwiTk9fQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuMy42XG4gICAgICpcbiAgICAgKiBUaGlzIHJlc3BvbnNlIGNvZGUgaXMgc2VudCBhZnRlciBhY2NvbXBsaXNoaW5nIHJlcXVlc3QgdG8gdGVsbCB1c2VyIGFnZW50IHJlc2V0IGRvY3VtZW50IHZpZXcgd2hpY2ggc2VudCB0aGlzIHJlcXVlc3QuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJSRVNFVF9DT05URU5UXCJdID0gMjA1XSA9IFwiUkVTRVRfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMyNzZWN0aW9uLTQuMVxuICAgICAqXG4gICAgICogVGhpcyByZXNwb25zZSBjb2RlIGlzIHVzZWQgYmVjYXVzZSBvZiByYW5nZSBoZWFkZXIgc2VudCBieSB0aGUgY2xpZW50IHRvIHNlcGFyYXRlIGRvd25sb2FkIGludG8gbXVsdGlwbGUgc3RyZWFtcy5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIlBBUlRJQUxfQ09OVEVOVFwiXSA9IDIwNl0gPSBcIlBBUlRJQUxfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjUxOCNzZWN0aW9uLTEwLjJcbiAgICAgKlxuICAgICAqIEEgTXVsdGktU3RhdHVzIHJlc3BvbnNlIGNvbnZleXMgaW5mb3JtYXRpb24gYWJvdXQgbXVsdGlwbGUgcmVzb3VyY2VzIGluIHNpdHVhdGlvbnMgd2hlcmUgbXVsdGlwbGUgc3RhdHVzIGNvZGVzIG1pZ2h0IGJlIGFwcHJvcHJpYXRlLlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiTVVMVElfU1RBVFVTXCJdID0gMjA3XSA9IFwiTVVMVElfU1RBVFVTXCI7XG4gICAgLyoqXG4gICAgICogT2ZmaWNpYWwgRG9jdW1lbnRhdGlvbiBAIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40LjFcbiAgICAgKlxuICAgICAqIFRoZSByZXF1ZXN0IGhhcyBtb3JlIHRoYW4gb25lIHBvc3NpYmxlIHJlc3BvbnNlcy4gVXNlci1hZ2VudCBvciB1c2VyIHNob3VsZCBjaG9vc2Ugb25lIG9mIHRoZW0uIFRoZXJlIGlzIG5vIHN0YW5kYXJkaXplZCB3YXkgdG8gY2hvb3NlIG9uZSBvZiB0aGUgcmVzcG9uc2VzLlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiTVVMVElQTEVfQ0hPSUNFU1wiXSA9IDMwMF0gPSBcIk1VTFRJUExFX0NIT0lDRVNcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjQuMlxuICAgICAqXG4gICAgICogVGhpcyByZXNwb25zZSBjb2RlIG1lYW5zIHRoYXQgVVJJIG9mIHJlcXVlc3RlZCByZXNvdXJjZSBoYXMgYmVlbiBjaGFuZ2VkLiBQcm9iYWJseSwgbmV3IFVSSSB3b3VsZCBiZSBnaXZlbiBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJNT1ZFRF9QRVJNQU5FTlRMWVwiXSA9IDMwMV0gPSBcIk1PVkVEX1BFUk1BTkVOVExZXCI7XG4gICAgLyoqXG4gICAgICogT2ZmaWNpYWwgRG9jdW1lbnRhdGlvbiBAIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40LjNcbiAgICAgKlxuICAgICAqIFRoaXMgcmVzcG9uc2UgY29kZSBtZWFucyB0aGF0IFVSSSBvZiByZXF1ZXN0ZWQgcmVzb3VyY2UgaGFzIGJlZW4gY2hhbmdlZCB0ZW1wb3JhcmlseS4gTmV3IGNoYW5nZXMgaW4gdGhlIFVSSSBtaWdodCBiZSBtYWRlIGluIHRoZSBmdXR1cmUuIFRoZXJlZm9yZSwgdGhpcyBzYW1lIFVSSSBzaG91bGQgYmUgdXNlZCBieSB0aGUgY2xpZW50IGluIGZ1dHVyZSByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIk1PVkVEX1RFTVBPUkFSSUxZXCJdID0gMzAyXSA9IFwiTU9WRURfVEVNUE9SQVJJTFlcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjQuNFxuICAgICAqXG4gICAgICogU2VydmVyIHNlbnQgdGhpcyByZXNwb25zZSB0byBkaXJlY3RpbmcgY2xpZW50IHRvIGdldCByZXF1ZXN0ZWQgcmVzb3VyY2UgdG8gYW5vdGhlciBVUkkgd2l0aCBhbiBHRVQgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIlNFRV9PVEhFUlwiXSA9IDMwM10gPSBcIlNFRV9PVEhFUlwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMiNzZWN0aW9uLTQuMVxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VkIGZvciBjYWNoaW5nIHB1cnBvc2VzLiBJdCBpcyB0ZWxsaW5nIHRvIGNsaWVudCB0aGF0IHJlc3BvbnNlIGhhcyBub3QgYmVlbiBtb2RpZmllZC4gU28sIGNsaWVudCBjYW4gY29udGludWUgdG8gdXNlIHNhbWUgY2FjaGVkIHZlcnNpb24gb2YgcmVzcG9uc2UuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJOT1RfTU9ESUZJRURcIl0gPSAzMDRdID0gXCJOT1RfTU9ESUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNC42XG4gICAgICpcbiAgICAgKiBXYXMgZGVmaW5lZCBpbiBhIHByZXZpb3VzIHZlcnNpb24gb2YgdGhlIEhUVFAgc3BlY2lmaWNhdGlvbiB0byBpbmRpY2F0ZSB0aGF0IGEgcmVxdWVzdGVkIHJlc3BvbnNlIG11c3QgYmUgYWNjZXNzZWQgYnkgYSBwcm94eS4gSXQgaGFzIGJlZW4gZGVwcmVjYXRlZCBkdWUgdG8gc2VjdXJpdHkgY29uY2VybnMgcmVnYXJkaW5nIGluLWJhbmQgY29uZmlndXJhdGlvbiBvZiBhIHByb3h5LlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiVVNFX1BST1hZXCJdID0gMzA1XSA9IFwiVVNFX1BST1hZXCI7XG4gICAgLyoqXG4gICAgICogT2ZmaWNpYWwgRG9jdW1lbnRhdGlvbiBAIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40LjdcbiAgICAgKlxuICAgICAqIFNlcnZlciBzZW50IHRoaXMgcmVzcG9uc2UgdG8gZGlyZWN0aW5nIGNsaWVudCB0byBnZXQgcmVxdWVzdGVkIHJlc291cmNlIHRvIGFub3RoZXIgVVJJIHdpdGggc2FtZSBtZXRob2QgdGhhdCB1c2VkIHByaW9yIHJlcXVlc3QuIFRoaXMgaGFzIHRoZSBzYW1lIHNlbWFudGljIHRoYW4gdGhlIDMwMiBGb3VuZCBIVFRQIHJlc3BvbnNlIGNvZGUsIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IHRoZSB1c2VyIGFnZW50IG11c3Qgbm90IGNoYW5nZSB0aGUgSFRUUCBtZXRob2QgdXNlZDogaWYgYSBQT1NUIHdhcyB1c2VkIGluIHRoZSBmaXJzdCByZXF1ZXN0LCBhIFBPU1QgbXVzdCBiZSB1c2VkIGluIHRoZSBzZWNvbmQgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIlRFTVBPUkFSWV9SRURJUkVDVFwiXSA9IDMwN10gPSBcIlRFTVBPUkFSWV9SRURJUkVDVFwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUzOCNzZWN0aW9uLTNcbiAgICAgKlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgcmVzb3VyY2UgaXMgbm93IHBlcm1hbmVudGx5IGxvY2F0ZWQgYXQgYW5vdGhlciBVUkksIHNwZWNpZmllZCBieSB0aGUgTG9jYXRpb246IEhUVFAgUmVzcG9uc2UgaGVhZGVyLiBUaGlzIGhhcyB0aGUgc2FtZSBzZW1hbnRpY3MgYXMgdGhlIDMwMSBNb3ZlZCBQZXJtYW5lbnRseSBIVFRQIHJlc3BvbnNlIGNvZGUsIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IHRoZSB1c2VyIGFnZW50IG11c3Qgbm90IGNoYW5nZSB0aGUgSFRUUCBtZXRob2QgdXNlZDogaWYgYSBQT1NUIHdhcyB1c2VkIGluIHRoZSBmaXJzdCByZXF1ZXN0LCBhIFBPU1QgbXVzdCBiZSB1c2VkIGluIHRoZSBzZWNvbmQgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIlBFUk1BTkVOVF9SRURJUkVDVFwiXSA9IDMwOF0gPSBcIlBFUk1BTkVOVF9SRURJUkVDVFwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNS4xXG4gICAgICpcbiAgICAgKiBUaGlzIHJlc3BvbnNlIG1lYW5zIHRoYXQgc2VydmVyIGNvdWxkIG5vdCB1bmRlcnN0YW5kIHRoZSByZXF1ZXN0IGR1ZSB0byBpbnZhbGlkIHN5bnRheC5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIkJBRF9SRVFVRVNUXCJdID0gNDAwXSA9IFwiQkFEX1JFUVVFU1RcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzUjc2VjdGlvbi0zLjFcbiAgICAgKlxuICAgICAqIEFsdGhvdWdoIHRoZSBIVFRQIHN0YW5kYXJkIHNwZWNpZmllcyBcInVuYXV0aG9yaXplZFwiLCBzZW1hbnRpY2FsbHkgdGhpcyByZXNwb25zZSBtZWFucyBcInVuYXV0aGVudGljYXRlZFwiLiBUaGF0IGlzLCB0aGUgY2xpZW50IG11c3QgYXV0aGVudGljYXRlIGl0c2VsZiB0byBnZXQgdGhlIHJlcXVlc3RlZCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIlVOQVVUSE9SSVpFRFwiXSA9IDQwMV0gPSBcIlVOQVVUSE9SSVpFRFwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNS4yXG4gICAgICpcbiAgICAgKiBUaGlzIHJlc3BvbnNlIGNvZGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UuIEluaXRpYWwgYWltIGZvciBjcmVhdGluZyB0aGlzIGNvZGUgd2FzIHVzaW5nIGl0IGZvciBkaWdpdGFsIHBheW1lbnQgc3lzdGVtcyBob3dldmVyIHRoaXMgaXMgbm90IHVzZWQgY3VycmVudGx5LlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiUEFZTUVOVF9SRVFVSVJFRFwiXSA9IDQwMl0gPSBcIlBBWU1FTlRfUkVRVUlSRURcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjUuM1xuICAgICAqXG4gICAgICogVGhlIGNsaWVudCBkb2VzIG5vdCBoYXZlIGFjY2VzcyByaWdodHMgdG8gdGhlIGNvbnRlbnQsIGkuZS4gdGhleSBhcmUgdW5hdXRob3JpemVkLCBzbyBzZXJ2ZXIgaXMgcmVqZWN0aW5nIHRvIGdpdmUgcHJvcGVyIHJlc3BvbnNlLiBVbmxpa2UgNDAxLCB0aGUgY2xpZW50J3MgaWRlbnRpdHkgaXMga25vd24gdG8gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIkZPUkJJRERFTlwiXSA9IDQwM10gPSBcIkZPUkJJRERFTlwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNS40XG4gICAgICpcbiAgICAgKiBUaGUgc2VydmVyIGNhbiBub3QgZmluZCByZXF1ZXN0ZWQgcmVzb3VyY2UuIEluIHRoZSBicm93c2VyLCB0aGlzIG1lYW5zIHRoZSBVUkwgaXMgbm90IHJlY29nbml6ZWQuIEluIGFuIEFQSSwgdGhpcyBjYW4gYWxzbyBtZWFuIHRoYXQgdGhlIGVuZHBvaW50IGlzIHZhbGlkIGJ1dCB0aGUgcmVzb3VyY2UgaXRzZWxmIGRvZXMgbm90IGV4aXN0LiBTZXJ2ZXJzIG1heSBhbHNvIHNlbmQgdGhpcyByZXNwb25zZSBpbnN0ZWFkIG9mIDQwMyB0byBoaWRlIHRoZSBleGlzdGVuY2Ugb2YgYSByZXNvdXJjZSBmcm9tIGFuIHVuYXV0aG9yaXplZCBjbGllbnQuIFRoaXMgcmVzcG9uc2UgY29kZSBpcyBwcm9iYWJseSB0aGUgbW9zdCBmYW1vdXMgb25lIGR1ZSB0byBpdHMgZnJlcXVlbnQgb2NjdXJlbmNlIG9uIHRoZSB3ZWIuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJOT1RfRk9VTkRcIl0gPSA0MDRdID0gXCJOT1RfRk9VTkRcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjUuNVxuICAgICAqXG4gICAgICogVGhlIHJlcXVlc3QgbWV0aG9kIGlzIGtub3duIGJ5IHRoZSBzZXJ2ZXIgYnV0IGhhcyBiZWVuIGRpc2FibGVkIGFuZCBjYW5ub3QgYmUgdXNlZC4gRm9yIGV4YW1wbGUsIGFuIEFQSSBtYXkgZm9yYmlkIERFTEVURS1pbmcgYSByZXNvdXJjZS4gVGhlIHR3byBtYW5kYXRvcnkgbWV0aG9kcywgR0VUIGFuZCBIRUFELCBtdXN0IG5ldmVyIGJlIGRpc2FibGVkIGFuZCBzaG91bGQgbm90IHJldHVybiB0aGlzIGVycm9yIGNvZGUuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJNRVRIT0RfTk9UX0FMTE9XRURcIl0gPSA0MDVdID0gXCJNRVRIT0RfTk9UX0FMTE9XRURcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjUuNlxuICAgICAqXG4gICAgICogVGhpcyByZXNwb25zZSBpcyBzZW50IHdoZW4gdGhlIHdlYiBzZXJ2ZXIsIGFmdGVyIHBlcmZvcm1pbmcgc2VydmVyLWRyaXZlbiBjb250ZW50IG5lZ290aWF0aW9uLCBkb2Vzbid0IGZpbmQgYW55IGNvbnRlbnQgZm9sbG93aW5nIHRoZSBjcml0ZXJpYSBnaXZlbiBieSB0aGUgdXNlciBhZ2VudC5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIk5PVF9BQ0NFUFRBQkxFXCJdID0gNDA2XSA9IFwiTk9UX0FDQ0VQVEFCTEVcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzUjc2VjdGlvbi0zLjJcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgc2ltaWxhciB0byA0MDEgYnV0IGF1dGhlbnRpY2F0aW9uIGlzIG5lZWRlZCB0byBiZSBkb25lIGJ5IGEgcHJveHkuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRFwiXSA9IDQwN10gPSBcIlBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEXCI7XG4gICAgLyoqXG4gICAgICogT2ZmaWNpYWwgRG9jdW1lbnRhdGlvbiBAIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi41LjdcbiAgICAgKlxuICAgICAqIFRoaXMgcmVzcG9uc2UgaXMgc2VudCBvbiBhbiBpZGxlIGNvbm5lY3Rpb24gYnkgc29tZSBzZXJ2ZXJzLCBldmVuIHdpdGhvdXQgYW55IHByZXZpb3VzIHJlcXVlc3QgYnkgdGhlIGNsaWVudC4gSXQgbWVhbnMgdGhhdCB0aGUgc2VydmVyIHdvdWxkIGxpa2UgdG8gc2h1dCBkb3duIHRoaXMgdW51c2VkIGNvbm5lY3Rpb24uIFRoaXMgcmVzcG9uc2UgaXMgdXNlZCBtdWNoIG1vcmUgc2luY2Ugc29tZSBicm93c2VycywgbGlrZSBDaHJvbWUsIEZpcmVmb3ggMjcrLCBvciBJRTksIHVzZSBIVFRQIHByZS1jb25uZWN0aW9uIG1lY2hhbmlzbXMgdG8gc3BlZWQgdXAgc3VyZmluZy4gQWxzbyBub3RlIHRoYXQgc29tZSBzZXJ2ZXJzIG1lcmVseSBzaHV0IGRvd24gdGhlIGNvbm5lY3Rpb24gd2l0aG91dCBzZW5kaW5nIHRoaXMgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIlJFUVVFU1RfVElNRU9VVFwiXSA9IDQwOF0gPSBcIlJFUVVFU1RfVElNRU9VVFwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNS44XG4gICAgICpcbiAgICAgKiBUaGlzIHJlc3BvbnNlIGlzIHNlbnQgd2hlbiBhIHJlcXVlc3QgY29uZmxpY3RzIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIkNPTkZMSUNUXCJdID0gNDA5XSA9IFwiQ09ORkxJQ1RcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjUuOVxuICAgICAqXG4gICAgICogVGhpcyByZXNwb25zZSB3b3VsZCBiZSBzZW50IHdoZW4gdGhlIHJlcXVlc3RlZCBjb250ZW50IGhhcyBiZWVuIHBlcm1lbmFudGx5IGRlbGV0ZWQgZnJvbSBzZXJ2ZXIsIHdpdGggbm8gZm9yd2FyZGluZyBhZGRyZXNzLiBDbGllbnRzIGFyZSBleHBlY3RlZCB0byByZW1vdmUgdGhlaXIgY2FjaGVzIGFuZCBsaW5rcyB0byB0aGUgcmVzb3VyY2UuIFRoZSBIVFRQIHNwZWNpZmljYXRpb24gaW50ZW5kcyB0aGlzIHN0YXR1cyBjb2RlIHRvIGJlIHVzZWQgZm9yIFwibGltaXRlZC10aW1lLCBwcm9tb3Rpb25hbCBzZXJ2aWNlc1wiLiBBUElzIHNob3VsZCBub3QgZmVlbCBjb21wZWxsZWQgdG8gaW5kaWNhdGUgcmVzb3VyY2VzIHRoYXQgaGF2ZSBiZWVuIGRlbGV0ZWQgd2l0aCB0aGlzIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiR09ORVwiXSA9IDQxMF0gPSBcIkdPTkVcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjUuMTBcbiAgICAgKlxuICAgICAqIFRoZSBzZXJ2ZXIgcmVqZWN0ZWQgdGhlIHJlcXVlc3QgYmVjYXVzZSB0aGUgQ29udGVudC1MZW5ndGggaGVhZGVyIGZpZWxkIGlzIG5vdCBkZWZpbmVkIGFuZCB0aGUgc2VydmVyIHJlcXVpcmVzIGl0LlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiTEVOR1RIX1JFUVVJUkVEXCJdID0gNDExXSA9IFwiTEVOR1RIX1JFUVVJUkVEXCI7XG4gICAgLyoqXG4gICAgICogT2ZmaWNpYWwgRG9jdW1lbnRhdGlvbiBAIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMyI3NlY3Rpb24tNC4yXG4gICAgICpcbiAgICAgKiBUaGUgY2xpZW50IGhhcyBpbmRpY2F0ZWQgcHJlY29uZGl0aW9ucyBpbiBpdHMgaGVhZGVycyB3aGljaCB0aGUgc2VydmVyIGRvZXMgbm90IG1lZXQuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJQUkVDT05ESVRJT05fRkFJTEVEXCJdID0gNDEyXSA9IFwiUFJFQ09ORElUSU9OX0ZBSUxFRFwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNS4xMVxuICAgICAqXG4gICAgICogUmVxdWVzdCBlbnRpdHkgaXMgbGFyZ2VyIHRoYW4gbGltaXRzIGRlZmluZWQgYnkgc2VydmVyOyB0aGUgc2VydmVyIG1pZ2h0IGNsb3NlIHRoZSBjb25uZWN0aW9uIG9yIHJldHVybiBhbiBSZXRyeS1BZnRlciBoZWFkZXIgZmllbGQuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJSRVFVRVNUX1RPT19MT05HXCJdID0gNDEzXSA9IFwiUkVRVUVTVF9UT09fTE9OR1wiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNS4xMlxuICAgICAqXG4gICAgICogVGhlIFVSSSByZXF1ZXN0ZWQgYnkgdGhlIGNsaWVudCBpcyBsb25nZXIgdGhhbiB0aGUgc2VydmVyIGlzIHdpbGxpbmcgdG8gaW50ZXJwcmV0LlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiUkVRVUVTVF9VUklfVE9PX0xPTkdcIl0gPSA0MTRdID0gXCJSRVFVRVNUX1VSSV9UT09fTE9OR1wiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNS4xM1xuICAgICAqXG4gICAgICogVGhlIG1lZGlhIGZvcm1hdCBvZiB0aGUgcmVxdWVzdGVkIGRhdGEgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyLCBzbyB0aGUgc2VydmVyIGlzIHJlamVjdGluZyB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIlVOU1VQUE9SVEVEX01FRElBX1RZUEVcIl0gPSA0MTVdID0gXCJVTlNVUFBPUlRFRF9NRURJQV9UWVBFXCI7XG4gICAgLyoqXG4gICAgICogT2ZmaWNpYWwgRG9jdW1lbnRhdGlvbiBAIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMzI3NlY3Rpb24tNC40XG4gICAgICpcbiAgICAgKiBUaGUgcmFuZ2Ugc3BlY2lmaWVkIGJ5IHRoZSBSYW5nZSBoZWFkZXIgZmllbGQgaW4gdGhlIHJlcXVlc3QgY2FuJ3QgYmUgZnVsZmlsbGVkOyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHJhbmdlIGlzIG91dHNpZGUgdGhlIHNpemUgb2YgdGhlIHRhcmdldCBVUkkncyBkYXRhLlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiUkVRVUVTVEVEX1JBTkdFX05PVF9TQVRJU0ZJQUJMRVwiXSA9IDQxNl0gPSBcIlJFUVVFU1RFRF9SQU5HRV9OT1RfU0FUSVNGSUFCTEVcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjUuMTRcbiAgICAgKlxuICAgICAqIFRoaXMgcmVzcG9uc2UgY29kZSBtZWFucyB0aGUgZXhwZWN0YXRpb24gaW5kaWNhdGVkIGJ5IHRoZSBFeHBlY3QgcmVxdWVzdCBoZWFkZXIgZmllbGQgY2FuJ3QgYmUgbWV0IGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJFWFBFQ1RBVElPTl9GQUlMRURcIl0gPSA0MTddID0gXCJFWFBFQ1RBVElPTl9GQUlMRURcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIzMjQjc2VjdGlvbi0yLjMuMlxuICAgICAqXG4gICAgICogQW55IGF0dGVtcHQgdG8gYnJldyBjb2ZmZWUgd2l0aCBhIHRlYXBvdCBzaG91bGQgcmVzdWx0IGluIHRoZSBlcnJvciBjb2RlIFwiNDE4IEknbSBhIHRlYXBvdFwiLiBUaGUgcmVzdWx0aW5nIGVudGl0eSBib2R5IE1BWSBiZSBzaG9ydCBhbmQgc3RvdXQuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJJTV9BX1RFQVBPVFwiXSA9IDQxOF0gPSBcIklNX0FfVEVBUE9UXCI7XG4gICAgLyoqXG4gICAgICogT2ZmaWNpYWwgRG9jdW1lbnRhdGlvbiBAIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNTE4I3NlY3Rpb24tMTAuNlxuICAgICAqXG4gICAgICogVGhlIDUwNyAoSW5zdWZmaWNpZW50IFN0b3JhZ2UpIHN0YXR1cyBjb2RlIG1lYW5zIHRoZSBtZXRob2QgY291bGQgbm90IGJlIHBlcmZvcm1lZCBvbiB0aGUgcmVzb3VyY2UgYmVjYXVzZSB0aGUgc2VydmVyIGlzIHVuYWJsZSB0byBzdG9yZSB0aGUgcmVwcmVzZW50YXRpb24gbmVlZGVkIHRvIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZSB0aGUgcmVxdWVzdC4gVGhpcyBjb25kaXRpb24gaXMgY29uc2lkZXJlZCB0byBiZSB0ZW1wb3JhcnkuIElmIHRoZSByZXF1ZXN0IHdoaWNoIHJlY2VpdmVkIHRoaXMgc3RhdHVzIGNvZGUgd2FzIHRoZSByZXN1bHQgb2YgYSB1c2VyIGFjdGlvbiwgdGhlIHJlcXVlc3QgTVVTVCBOT1QgYmUgcmVwZWF0ZWQgdW50aWwgaXQgaXMgcmVxdWVzdGVkIGJ5IGEgc2VwYXJhdGUgdXNlciBhY3Rpb24uXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJJTlNVRkZJQ0lFTlRfU1BBQ0VfT05fUkVTT1VSQ0VcIl0gPSA0MTldID0gXCJJTlNVRkZJQ0lFTlRfU1BBQ0VfT05fUkVTT1VSQ0VcIjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL3JmY2RpZmY/ZGlmZnR5cGU9LS1od2RpZmYmdXJsMj1kcmFmdC1pZXRmLXdlYmRhdi1wcm90b2NvbC0wNi50eHRcbiAgICAgKlxuICAgICAqIEEgZGVwcmVjYXRlZCByZXNwb25zZSB1c2VkIGJ5IHRoZSBTcHJpbmcgRnJhbWV3b3JrIHdoZW4gYSBtZXRob2QgaGFzIGZhaWxlZC5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIk1FVEhPRF9GQUlMVVJFXCJdID0gNDIwXSA9IFwiTUVUSE9EX0ZBSUxVUkVcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM3NTQwI3NlY3Rpb24tOS4xLjJcbiAgICAgKlxuICAgICAqIERlZmluZWQgaW4gdGhlIHNwZWNpZmljYXRpb24gb2YgSFRUUC8yIHRvIGluZGljYXRlIHRoYXQgYSBzZXJ2ZXIgaXMgbm90IGFibGUgdG8gcHJvZHVjZSBhIHJlc3BvbnNlIGZvciB0aGUgY29tYmluYXRpb24gb2Ygc2NoZW1lIGFuZCBhdXRob3JpdHkgdGhhdCBhcmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QgVVJJLlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiTUlTRElSRUNURURfUkVRVUVTVFwiXSA9IDQyMV0gPSBcIk1JU0RJUkVDVEVEX1JFUVVFU1RcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI1MTgjc2VjdGlvbi0xMC4zXG4gICAgICpcbiAgICAgKiBUaGUgcmVxdWVzdCB3YXMgd2VsbC1mb3JtZWQgYnV0IHdhcyB1bmFibGUgdG8gYmUgZm9sbG93ZWQgZHVlIHRvIHNlbWFudGljIGVycm9ycy5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIlVOUFJPQ0VTU0FCTEVfRU5USVRZXCJdID0gNDIyXSA9IFwiVU5QUk9DRVNTQUJMRV9FTlRJVFlcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI1MTgjc2VjdGlvbi0xMC40XG4gICAgICpcbiAgICAgKiBUaGUgcmVzb3VyY2UgdGhhdCBpcyBiZWluZyBhY2Nlc3NlZCBpcyBsb2NrZWQuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJMT0NLRURcIl0gPSA0MjNdID0gXCJMT0NLRURcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI1MTgjc2VjdGlvbi0xMC41XG4gICAgICpcbiAgICAgKiBUaGUgcmVxdWVzdCBmYWlsZWQgZHVlIHRvIGZhaWx1cmUgb2YgYSBwcmV2aW91cyByZXF1ZXN0LlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiRkFJTEVEX0RFUEVOREVOQ1lcIl0gPSA0MjRdID0gXCJGQUlMRURfREVQRU5ERU5DWVwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjUuMTVcbiAgICAgKlxuICAgICAqIFRoZSBzZXJ2ZXIgcmVmdXNlcyB0byBwZXJmb3JtIHRoZSByZXF1ZXN0IHVzaW5nIHRoZSBjdXJyZW50IHByb3RvY29sIGJ1dCBtaWdodCBiZSB3aWxsaW5nIHRvIGRvIHNvIGFmdGVyIHRoZSBjbGllbnQgdXBncmFkZXMgdG8gYSBkaWZmZXJlbnQgcHJvdG9jb2wuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJVUEdSQURFX1JFUVVJUkVEXCJdID0gNDI2XSA9IFwiVVBHUkFERV9SRVFVSVJFRFwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjU4NSNzZWN0aW9uLTNcbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW4gc2VydmVyIHJlcXVpcmVzIHRoZSByZXF1ZXN0IHRvIGJlIGNvbmRpdGlvbmFsLiBJbnRlbmRlZCB0byBwcmV2ZW50IHRoZSAnbG9zdCB1cGRhdGUnIHByb2JsZW0sIHdoZXJlIGEgY2xpZW50IEdFVHMgYSByZXNvdXJjZSdzIHN0YXRlLCBtb2RpZmllcyBpdCwgYW5kIFBVVHMgaXQgYmFjayB0byB0aGUgc2VydmVyLCB3aGVuIG1lYW53aGlsZSBhIHRoaXJkIHBhcnR5IGhhcyBtb2RpZmllZCB0aGUgc3RhdGUgb24gdGhlIHNlcnZlciwgbGVhZGluZyB0byBhIGNvbmZsaWN0LlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiUFJFQ09ORElUSU9OX1JFUVVJUkVEXCJdID0gNDI4XSA9IFwiUFJFQ09ORElUSU9OX1JFUVVJUkVEXCI7XG4gICAgLyoqXG4gICAgICogT2ZmaWNpYWwgRG9jdW1lbnRhdGlvbiBAIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NTg1I3NlY3Rpb24tNFxuICAgICAqXG4gICAgICogVGhlIHVzZXIgaGFzIHNlbnQgdG9vIG1hbnkgcmVxdWVzdHMgaW4gYSBnaXZlbiBhbW91bnQgb2YgdGltZSAoXCJyYXRlIGxpbWl0aW5nXCIpLlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiVE9PX01BTllfUkVRVUVTVFNcIl0gPSA0MjldID0gXCJUT09fTUFOWV9SRVFVRVNUU1wiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjU4NSNzZWN0aW9uLTVcbiAgICAgKlxuICAgICAqIFRoZSBzZXJ2ZXIgaXMgdW53aWxsaW5nIHRvIHByb2Nlc3MgdGhlIHJlcXVlc3QgYmVjYXVzZSBpdHMgaGVhZGVyIGZpZWxkcyBhcmUgdG9vIGxhcmdlLiBUaGUgcmVxdWVzdCBNQVkgYmUgcmVzdWJtaXR0ZWQgYWZ0ZXIgcmVkdWNpbmcgdGhlIHNpemUgb2YgdGhlIHJlcXVlc3QgaGVhZGVyIGZpZWxkcy5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIlJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VcIl0gPSA0MzFdID0gXCJSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFXCI7XG4gICAgLyoqXG4gICAgICogT2ZmaWNpYWwgRG9jdW1lbnRhdGlvbiBAIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NzI1XG4gICAgICpcbiAgICAgKiBUaGUgdXNlci1hZ2VudCByZXF1ZXN0ZWQgYSByZXNvdXJjZSB0aGF0IGNhbm5vdCBsZWdhbGx5IGJlIHByb3ZpZGVkLCBzdWNoIGFzIGEgd2ViIHBhZ2UgY2Vuc29yZWQgYnkgYSBnb3Zlcm5tZW50LlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlNcIl0gPSA0NTFdID0gXCJVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OU1wiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNi4xXG4gICAgICpcbiAgICAgKiBUaGUgc2VydmVyIGVuY291bnRlcmVkIGFuIHVuZXhwZWN0ZWQgY29uZGl0aW9uIHRoYXQgcHJldmVudGVkIGl0IGZyb20gZnVsZmlsbGluZyB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiXSA9IDUwMF0gPSBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNi4yXG4gICAgICpcbiAgICAgKiBUaGUgcmVxdWVzdCBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyIGFuZCBjYW5ub3QgYmUgaGFuZGxlZC4gVGhlIG9ubHkgbWV0aG9kcyB0aGF0IHNlcnZlcnMgYXJlIHJlcXVpcmVkIHRvIHN1cHBvcnQgKGFuZCB0aGVyZWZvcmUgdGhhdCBtdXN0IG5vdCByZXR1cm4gdGhpcyBjb2RlKSBhcmUgR0VUIGFuZCBIRUFELlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiTk9UX0lNUExFTUVOVEVEXCJdID0gNTAxXSA9IFwiTk9UX0lNUExFTUVOVEVEXCI7XG4gICAgLyoqXG4gICAgICogT2ZmaWNpYWwgRG9jdW1lbnRhdGlvbiBAIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi42LjNcbiAgICAgKlxuICAgICAqIFRoaXMgZXJyb3IgcmVzcG9uc2UgbWVhbnMgdGhhdCB0aGUgc2VydmVyLCB3aGlsZSB3b3JraW5nIGFzIGEgZ2F0ZXdheSB0byBnZXQgYSByZXNwb25zZSBuZWVkZWQgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LCBnb3QgYW4gaW52YWxpZCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIkJBRF9HQVRFV0FZXCJdID0gNTAyXSA9IFwiQkFEX0dBVEVXQVlcIjtcbiAgICAvKipcbiAgICAgKiBPZmZpY2lhbCBEb2N1bWVudGF0aW9uIEAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjYuNFxuICAgICAqXG4gICAgICogVGhlIHNlcnZlciBpcyBub3QgcmVhZHkgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LiBDb21tb24gY2F1c2VzIGFyZSBhIHNlcnZlciB0aGF0IGlzIGRvd24gZm9yIG1haW50ZW5hbmNlIG9yIHRoYXQgaXMgb3ZlcmxvYWRlZC4gTm90ZSB0aGF0IHRvZ2V0aGVyIHdpdGggdGhpcyByZXNwb25zZSwgYSB1c2VyLWZyaWVuZGx5IHBhZ2UgZXhwbGFpbmluZyB0aGUgcHJvYmxlbSBzaG91bGQgYmUgc2VudC4gVGhpcyByZXNwb25zZXMgc2hvdWxkIGJlIHVzZWQgZm9yIHRlbXBvcmFyeSBjb25kaXRpb25zIGFuZCB0aGUgUmV0cnktQWZ0ZXI6IEhUVFAgaGVhZGVyIHNob3VsZCwgaWYgcG9zc2libGUsIGNvbnRhaW4gdGhlIGVzdGltYXRlZCB0aW1lIGJlZm9yZSB0aGUgcmVjb3Zlcnkgb2YgdGhlIHNlcnZpY2UuIFRoZSB3ZWJtYXN0ZXIgbXVzdCBhbHNvIHRha2UgY2FyZSBhYm91dCB0aGUgY2FjaGluZy1yZWxhdGVkIGhlYWRlcnMgdGhhdCBhcmUgc2VudCBhbG9uZyB3aXRoIHRoaXMgcmVzcG9uc2UsIGFzIHRoZXNlIHRlbXBvcmFyeSBjb25kaXRpb24gcmVzcG9uc2VzIHNob3VsZCB1c3VhbGx5IG5vdCBiZSBjYWNoZWQuXG4gICAgICovXG4gICAgU3RhdHVzQ29kZXNbU3RhdHVzQ29kZXNbXCJTRVJWSUNFX1VOQVZBSUxBQkxFXCJdID0gNTAzXSA9IFwiU0VSVklDRV9VTkFWQUlMQUJMRVwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNi41XG4gICAgICpcbiAgICAgKiBUaGlzIGVycm9yIHJlc3BvbnNlIGlzIGdpdmVuIHdoZW4gdGhlIHNlcnZlciBpcyBhY3RpbmcgYXMgYSBnYXRld2F5IGFuZCBjYW5ub3QgZ2V0IGEgcmVzcG9uc2UgaW4gdGltZS5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIkdBVEVXQVlfVElNRU9VVFwiXSA9IDUwNF0gPSBcIkdBVEVXQVlfVElNRU9VVFwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNi42XG4gICAgICpcbiAgICAgKiBUaGUgSFRUUCB2ZXJzaW9uIHVzZWQgaW4gdGhlIHJlcXVlc3QgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiSFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURURcIl0gPSA1MDVdID0gXCJIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRFwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjUxOCNzZWN0aW9uLTEwLjZcbiAgICAgKlxuICAgICAqIFRoZSBzZXJ2ZXIgaGFzIGFuIGludGVybmFsIGNvbmZpZ3VyYXRpb24gZXJyb3I6IHRoZSBjaG9zZW4gdmFyaWFudCByZXNvdXJjZSBpcyBjb25maWd1cmVkIHRvIGVuZ2FnZSBpbiB0cmFuc3BhcmVudCBjb250ZW50IG5lZ290aWF0aW9uIGl0c2VsZiwgYW5kIGlzIHRoZXJlZm9yZSBub3QgYSBwcm9wZXIgZW5kIHBvaW50IGluIHRoZSBuZWdvdGlhdGlvbiBwcm9jZXNzLlxuICAgICAqL1xuICAgIFN0YXR1c0NvZGVzW1N0YXR1c0NvZGVzW1wiSU5TVUZGSUNJRU5UX1NUT1JBR0VcIl0gPSA1MDddID0gXCJJTlNVRkZJQ0lFTlRfU1RPUkFHRVwiO1xuICAgIC8qKlxuICAgICAqIE9mZmljaWFsIERvY3VtZW50YXRpb24gQCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjU4NSNzZWN0aW9uLTZcbiAgICAgKlxuICAgICAqIFRoZSA1MTEgc3RhdHVzIGNvZGUgaW5kaWNhdGVzIHRoYXQgdGhlIGNsaWVudCBuZWVkcyB0byBhdXRoZW50aWNhdGUgdG8gZ2FpbiBuZXR3b3JrIGFjY2Vzcy5cbiAgICAgKi9cbiAgICBTdGF0dXNDb2Rlc1tTdGF0dXNDb2Rlc1tcIk5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRURcIl0gPSA1MTFdID0gXCJORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEXCI7XG59KShTdGF0dXNDb2RlcyB8fCAoU3RhdHVzQ29kZXMgPSB7fSkpO1xuIiwiLyoqXG4gKiBAcHJlc2VydmVcbiAqIEpTIEltcGxlbWVudGF0aW9uIG9mIGluY3JlbWVudGFsIE11cm11ckhhc2gzIChyMTUwKSAoYXMgb2YgTWF5IDEwLCAyMDEzKVxuICpcbiAqIEBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpqZW5zeXRAZ21haWwuY29tXCI+SmVucyBUYXlsb3I8L2E+XG4gKiBAc2VlIGh0dHA6Ly9naXRodWIuY29tL2hvbWVicmV3aW5nL2JyYXVoYXVzLWRpZmZcbiAqIEBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpnYXJ5LmNvdXJ0QGdtYWlsLmNvbVwiPkdhcnkgQ291cnQ8L2E+XG4gKiBAc2VlIGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC9tdXJtdXJoYXNoLWpzXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86YWFwcGxlYnlAZ21haWwuY29tXCI+QXVzdGluIEFwcGxlYnk8L2E+XG4gKiBAc2VlIGh0dHA6Ly9zaXRlcy5nb29nbGUuY29tL3NpdGUvbXVybXVyaGFzaC9cbiAqL1xuKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGNhY2hlO1xuXG4gICAgLy8gQ2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGhvdXQgYG5ld2AgdG8gdXNlIHRoZSBjYWNoZWQgb2JqZWN0IChnb29kIGZvclxuICAgIC8vIHNpbmdsZS10aHJlYWRlZCBlbnZpcm9ubWVudHMpLCBvciB3aXRoIGBuZXdgIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3QuXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge3N0cmluZ30ga2V5IEEgVVRGLTE2IG9yIEFTQ0lJIHN0cmluZ1xuICAgIC8vIEBwYXJhbSB7bnVtYmVyfSBzZWVkIEFuIG9wdGlvbmFsIHBvc2l0aXZlIGludGVnZXJcbiAgICAvLyBAcmV0dXJuIHtvYmplY3R9IEEgTXVybXVySGFzaDMgb2JqZWN0IGZvciBpbmNyZW1lbnRhbCBoYXNoaW5nXG4gICAgZnVuY3Rpb24gTXVybXVySGFzaDMoa2V5LCBzZWVkKSB7XG4gICAgICAgIHZhciBtID0gdGhpcyBpbnN0YW5jZW9mIE11cm11ckhhc2gzID8gdGhpcyA6IGNhY2hlO1xuICAgICAgICBtLnJlc2V0KHNlZWQpXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbS5oYXNoKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobSAhPT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW5jcmVtZW50YWxseSBhZGQgYSBzdHJpbmcgdG8gdGhpcyBoYXNoXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge3N0cmluZ30ga2V5IEEgVVRGLTE2IG9yIEFTQ0lJIHN0cmluZ1xuICAgIC8vIEByZXR1cm4ge29iamVjdH0gdGhpc1xuICAgIE11cm11ckhhc2gzLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBoMSwgazEsIGksIHRvcCwgbGVuO1xuXG4gICAgICAgIGxlbiA9IGtleS5sZW5ndGg7XG4gICAgICAgIHRoaXMubGVuICs9IGxlbjtcblxuICAgICAgICBrMSA9IHRoaXMuazE7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucmVtKSB7XG4gICAgICAgICAgICBjYXNlIDA6IGsxIF49IGxlbiA+IGkgPyAoa2V5LmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmZmZikgOiAwO1xuICAgICAgICAgICAgY2FzZSAxOiBrMSBePSBsZW4gPiBpID8gKGtleS5jaGFyQ29kZUF0KGkrKykgJiAweGZmZmYpIDw8IDggOiAwO1xuICAgICAgICAgICAgY2FzZSAyOiBrMSBePSBsZW4gPiBpID8gKGtleS5jaGFyQ29kZUF0KGkrKykgJiAweGZmZmYpIDw8IDE2IDogMDtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBrMSBePSBsZW4gPiBpID8gKGtleS5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgMjQgOiAwO1xuICAgICAgICAgICAgICAgIGsxIF49IGxlbiA+IGkgPyAoa2V5LmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmYwMCkgPj4gOCA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbSA9IChsZW4gKyB0aGlzLnJlbSkgJiAzOyAvLyAmIDMgaXMgc2FtZSBhcyAlIDRcbiAgICAgICAgbGVuIC09IHRoaXMucmVtO1xuICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgaDEgPSB0aGlzLmgxO1xuICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICBrMSA9IChrMSAqIDB4MmQ1MSArIChrMSAmIDB4ZmZmZikgKiAweGNjOWUwMDAwKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICAgICAgazEgPSAoazEgPDwgMTUpIHwgKGsxID4+PiAxNyk7XG4gICAgICAgICAgICAgICAgazEgPSAoazEgKiAweDM1OTMgKyAoazEgJiAweGZmZmYpICogMHgxYjg3MDAwMCkgJiAweGZmZmZmZmZmO1xuXG4gICAgICAgICAgICAgICAgaDEgXj0gazE7XG4gICAgICAgICAgICAgICAgaDEgPSAoaDEgPDwgMTMpIHwgKGgxID4+PiAxOSk7XG4gICAgICAgICAgICAgICAgaDEgPSAoaDEgKiA1ICsgMHhlNjU0NmI2NCkgJiAweGZmZmZmZmZmO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGsxID0gKChrZXkuY2hhckNvZGVBdChpKyspICYgMHhmZmZmKSkgXlxuICAgICAgICAgICAgICAgICAgICAgKChrZXkuY2hhckNvZGVBdChpKyspICYgMHhmZmZmKSA8PCA4KSBeXG4gICAgICAgICAgICAgICAgICAgICAoKGtleS5jaGFyQ29kZUF0KGkrKykgJiAweGZmZmYpIDw8IDE2KTtcbiAgICAgICAgICAgICAgICB0b3AgPSBrZXkuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgIGsxIF49ICgodG9wICYgMHhmZikgPDwgMjQpIF5cbiAgICAgICAgICAgICAgICAgICAgICAoKHRvcCAmIDB4ZmYwMCkgPj4gOCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGsxID0gMDtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5yZW0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDM6IGsxIF49IChrZXkuY2hhckNvZGVBdChpICsgMikgJiAweGZmZmYpIDw8IDE2O1xuICAgICAgICAgICAgICAgIGNhc2UgMjogazEgXj0gKGtleS5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmZmZikgPDwgODtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IGsxIF49IChrZXkuY2hhckNvZGVBdChpKSAmIDB4ZmZmZik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaDEgPSBoMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuazEgPSBrMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIEdldCB0aGUgcmVzdWx0IG9mIHRoaXMgaGFzaFxuICAgIC8vXG4gICAgLy8gQHJldHVybiB7bnVtYmVyfSBUaGUgMzItYml0IGhhc2hcbiAgICBNdXJtdXJIYXNoMy5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrMSwgaDE7XG4gICAgICAgIFxuICAgICAgICBrMSA9IHRoaXMuazE7XG4gICAgICAgIGgxID0gdGhpcy5oMTtcblxuICAgICAgICBpZiAoazEgPiAwKSB7XG4gICAgICAgICAgICBrMSA9IChrMSAqIDB4MmQ1MSArIChrMSAmIDB4ZmZmZikgKiAweGNjOWUwMDAwKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBrMSA9IChrMSA8PCAxNSkgfCAoazEgPj4+IDE3KTtcbiAgICAgICAgICAgIGsxID0gKGsxICogMHgzNTkzICsgKGsxICYgMHhmZmZmKSAqIDB4MWI4NzAwMDApICYgMHhmZmZmZmZmZjtcbiAgICAgICAgICAgIGgxIF49IGsxO1xuICAgICAgICB9XG5cbiAgICAgICAgaDEgXj0gdGhpcy5sZW47XG5cbiAgICAgICAgaDEgXj0gaDEgPj4+IDE2O1xuICAgICAgICBoMSA9IChoMSAqIDB4Y2E2YiArIChoMSAmIDB4ZmZmZikgKiAweDg1ZWIwMDAwKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIGgxIF49IGgxID4+PiAxMztcbiAgICAgICAgaDEgPSAoaDEgKiAweGFlMzUgKyAoaDEgJiAweGZmZmYpICogMHhjMmIyMDAwMCkgJiAweGZmZmZmZmZmO1xuICAgICAgICBoMSBePSBoMSA+Pj4gMTY7XG5cbiAgICAgICAgcmV0dXJuIGgxID4+PiAwO1xuICAgIH07XG5cbiAgICAvLyBSZXNldCB0aGUgaGFzaCBvYmplY3QgZm9yIHJldXNlXG4gICAgLy9cbiAgICAvLyBAcGFyYW0ge251bWJlcn0gc2VlZCBBbiBvcHRpb25hbCBwb3NpdGl2ZSBpbnRlZ2VyXG4gICAgTXVybXVySGFzaDMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oc2VlZCkge1xuICAgICAgICB0aGlzLmgxID0gdHlwZW9mIHNlZWQgPT09ICdudW1iZXInID8gc2VlZCA6IDA7XG4gICAgICAgIHRoaXMucmVtID0gdGhpcy5rMSA9IHRoaXMubGVuID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIEEgY2FjaGVkIG9iamVjdCB0byB1c2UuIFRoaXMgY2FuIGJlIHNhZmVseSB1c2VkIGlmIHlvdSdyZSBpbiBhIHNpbmdsZS1cbiAgICAvLyB0aHJlYWRlZCBlbnZpcm9ubWVudCwgb3RoZXJ3aXNlIHlvdSBuZWVkIHRvIGNyZWF0ZSBuZXcgaGFzaGVzIHRvIHVzZS5cbiAgICBjYWNoZSA9IG5ldyBNdXJtdXJIYXNoMygpO1xuXG4gICAgaWYgKHR5cGVvZihtb2R1bGUpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gTXVybXVySGFzaDM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5NdXJtdXJIYXNoMyA9IE11cm11ckhhc2gzO1xuICAgIH1cbn0oKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSlNPTlJQQ0NsaWVudCA9IHZvaWQgMDtcbnZhciBtb2RlbHNfMSA9IHJlcXVpcmUoXCIuL21vZGVsc1wiKTtcbnZhciBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG52YXIgSlNPTlJQQ0NsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU09OUlBDQ2xpZW50KF9zZW5kLCBjcmVhdGVJRCkge1xuICAgICAgICB0aGlzLl9zZW5kID0gX3NlbmQ7XG4gICAgICAgIHRoaXMuY3JlYXRlSUQgPSBjcmVhdGVJRDtcbiAgICAgICAgdGhpcy5pZFRvUmVzb2x2ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pZCA9IDA7XG4gICAgfVxuICAgIEpTT05SUENDbGllbnQucHJvdG90eXBlLl9jcmVhdGVJRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3JlYXRlSUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUlEKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKyt0aGlzLmlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09OUlBDQ2xpZW50LnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKGRlbGF5LCBvdmVycmlkZUNyZWF0ZUpTT05SUENFcnJvclJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvdmVycmlkZUNyZWF0ZUpTT05SUENFcnJvclJlc3BvbnNlID09PSB2b2lkIDApIHsgb3ZlcnJpZGVDcmVhdGVKU09OUlBDRXJyb3JSZXNwb25zZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBtb2RlbHNfMS5jcmVhdGVKU09OUlBDRXJyb3JSZXNwb25zZSkoaWQsIGludGVybmFsXzEuRGVmYXVsdEVycm9yQ29kZSwgXCJSZXF1ZXN0IHRpbWVvdXRcIik7XG4gICAgICAgIH07IH1cbiAgICAgICAgdmFyIHRpbWVvdXRSZXF1ZXN0ID0gZnVuY3Rpb24gKGlkcywgcmVxdWVzdCkge1xuICAgICAgICAgICAgdmFyIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZSA9IF90aGlzLmlkVG9SZXNvbHZlTWFwLmdldChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pZFRvUmVzb2x2ZU1hcC5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdmVycmlkZUNyZWF0ZUpTT05SUENFcnJvclJlc3BvbnNlKGlkKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcXVlc3RBZHZhbmNlZCA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBjbGllbnRQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBpZHMgPSAoIUFycmF5LmlzQXJyYXkocmVxdWVzdCkgPyBbcmVxdWVzdF0gOiByZXF1ZXN0KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJlcXVlc3QpIHsgcmV0dXJuIHJlcXVlc3QuaWQ7IH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihpc0RlZmluZWRBbmROb25OdWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0aW1lb3V0UmVxdWVzdChpZHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVxdWVzdEFkdmFuY2VkKHJlcXVlc3QsIGNsaWVudFBhcmFtcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcywgY2xpZW50UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX3RoaXMuX2NyZWF0ZUlEKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVvdXRSZXF1ZXN0KFtpZF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlcXVlc3RXaXRoSUQobWV0aG9kLCBwYXJhbXMsIGNsaWVudFBhcmFtcywgaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVlc3RBZHZhbmNlZDogZnVuY3Rpb24gKHJlcXVlc3QsIGNsaWVudFBhcmFtcykgeyByZXR1cm4gcmVxdWVzdEFkdmFuY2VkKHJlcXVlc3QsIGNsaWVudFBhcmFtcyk7IH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBKU09OUlBDQ2xpZW50LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zLCBjbGllbnRQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFdpdGhJRChtZXRob2QsIHBhcmFtcywgY2xpZW50UGFyYW1zLCB0aGlzLl9jcmVhdGVJRCgpKTtcbiAgICB9O1xuICAgIEpTT05SUENDbGllbnQucHJvdG90eXBlLnJlcXVlc3RXaXRoSUQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMsIGNsaWVudFBhcmFtcywgaWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QsIHJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9ICgwLCBtb2RlbHNfMS5jcmVhdGVKU09OUlBDUmVxdWVzdCkoaWQsIG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVxdWVzdEFkdmFuY2VkKHJlcXVlc3QsIGNsaWVudFBhcmFtcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiAhcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzcG9uc2UucmVzdWx0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFByb21pc2UucmVqZWN0KG5ldyBtb2RlbHNfMS5KU09OUlBDRXJyb3JFeGNlcHRpb24ocmVzcG9uc2UuZXJyb3IubWVzc2FnZSwgcmVzcG9uc2UuZXJyb3IuY29kZSwgcmVzcG9uc2UuZXJyb3IuZGF0YSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkXCIpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSlNPTlJQQ0NsaWVudC5wcm90b3R5cGUucmVxdWVzdEFkdmFuY2VkID0gZnVuY3Rpb24gKHJlcXVlc3RzLCBjbGllbnRQYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZVJlcXVlc3RzT3JpZ2luYWxseUFycmF5ID0gQXJyYXkuaXNBcnJheShyZXF1ZXN0cyk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXF1ZXN0cykpIHtcbiAgICAgICAgICAgIHJlcXVlc3RzID0gW3JlcXVlc3RzXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVxdWVzdHNXaXRoSUQgPSByZXF1ZXN0cy5maWx0ZXIoZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0RlZmluZWRBbmROb25OdWxsKHJlcXVlc3QuaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHByb21pc2VzID0gcmVxdWVzdHNXaXRoSUQubWFwKGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIF90aGlzLmlkVG9SZXNvbHZlTWFwLnNldChyZXF1ZXN0LmlkLCByZXNvbHZlKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGlmIChhcmVSZXF1ZXN0c09yaWdpbmFsbHlBcnJheSB8fCAhcmVzcG9uc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChhcmVSZXF1ZXN0c09yaWdpbmFsbHlBcnJheSA/IHJlcXVlc3RzIDogcmVxdWVzdHNbMF0sIGNsaWVudFBhcmFtcykudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9taXNlOyB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlcXVlc3RzV2l0aElELmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWNlaXZlKCgwLCBtb2RlbHNfMS5jcmVhdGVKU09OUlBDRXJyb3JSZXNwb25zZSkocmVxdWVzdC5pZCwgaW50ZXJuYWxfMS5EZWZhdWx0RXJyb3JDb2RlLCAoZXJyb3IgJiYgZXJyb3IubWVzc2FnZSkgfHwgXCJGYWlsZWQgdG8gc2VuZCBhIHJlcXVlc3RcIikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKU09OUlBDQ2xpZW50LnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMsIGNsaWVudFBhcmFtcykge1xuICAgICAgICB2YXIgcmVxdWVzdCA9ICgwLCBtb2RlbHNfMS5jcmVhdGVKU09OUlBDTm90aWZpY2F0aW9uKShtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMuc2VuZChyZXF1ZXN0LCBjbGllbnRQYXJhbXMpLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0pO1xuICAgIH07XG4gICAgSlNPTlJQQ0NsaWVudC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjbGllbnRQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9zZW5kKHBheWxvYWQsIGNsaWVudFBhcmFtcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSlNPTlJQQ0NsaWVudC5wcm90b3R5cGUucmVqZWN0QWxsUGVuZGluZ1JlcXVlc3RzID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5pZFRvUmVzb2x2ZU1hcC5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZlLCBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKDAsIG1vZGVsc18xLmNyZWF0ZUpTT05SUENFcnJvclJlc3BvbnNlKShpZCwgaW50ZXJuYWxfMS5EZWZhdWx0RXJyb3JDb2RlLCBtZXNzYWdlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlkVG9SZXNvbHZlTWFwLmNsZWFyKCk7XG4gICAgfTtcbiAgICBKU09OUlBDQ2xpZW50LnByb3RvdHlwZS5yZWNlaXZlID0gZnVuY3Rpb24gKHJlc3BvbnNlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcG9uc2VzKSkge1xuICAgICAgICAgICAgcmVzcG9uc2VzID0gW3Jlc3BvbnNlc107XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uc2VzLmZvckVhY2goZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZSA9IF90aGlzLmlkVG9SZXNvbHZlTWFwLmdldChyZXNwb25zZS5pZCk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmlkVG9SZXNvbHZlTWFwLmRlbGV0ZShyZXNwb25zZS5pZCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05SUENDbGllbnQ7XG59KCkpO1xuZXhwb3J0cy5KU09OUlBDQ2xpZW50ID0gSlNPTlJQQ0NsaWVudDtcbnZhciBpc0RlZmluZWRBbmROb25OdWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jbGllbnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludGVyZmFjZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGVsc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VydmVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXJ2ZXItYW5kLWNsaWVudFwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWZhdWx0RXJyb3JDb2RlID0gdm9pZCAwO1xuZXhwb3J0cy5EZWZhdWx0RXJyb3JDb2RlID0gMDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSlNPTlJQQ05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuY3JlYXRlSlNPTlJQQ1JlcXVlc3QgPSBleHBvcnRzLmNyZWF0ZUpTT05SUENTdWNjZXNzUmVzcG9uc2UgPSBleHBvcnRzLmNyZWF0ZUpTT05SUENFcnJvclJlc3BvbnNlID0gZXhwb3J0cy5KU09OUlBDRXJyb3JDb2RlID0gZXhwb3J0cy5KU09OUlBDRXJyb3JFeGNlcHRpb24gPSBleHBvcnRzLmlzSlNPTlJQQ1Jlc3BvbnNlcyA9IGV4cG9ydHMuaXNKU09OUlBDUmVzcG9uc2UgPSBleHBvcnRzLmlzSlNPTlJQQ1JlcXVlc3RzID0gZXhwb3J0cy5pc0pTT05SUENSZXF1ZXN0ID0gZXhwb3J0cy5pc0pTT05SUENJRCA9IGV4cG9ydHMuSlNPTlJQQyA9IHZvaWQgMDtcbmV4cG9ydHMuSlNPTlJQQyA9IFwiMi4wXCI7XG52YXIgaXNKU09OUlBDSUQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlkID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIiB8fCBpZCA9PT0gbnVsbDtcbn07XG5leHBvcnRzLmlzSlNPTlJQQ0lEID0gaXNKU09OUlBDSUQ7XG52YXIgaXNKU09OUlBDUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgcmV0dXJuIChwYXlsb2FkLmpzb25ycGMgPT09IGV4cG9ydHMuSlNPTlJQQyAmJlxuICAgICAgICBwYXlsb2FkLm1ldGhvZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHBheWxvYWQucmVzdWx0ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgcGF5bG9hZC5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbn07XG5leHBvcnRzLmlzSlNPTlJQQ1JlcXVlc3QgPSBpc0pTT05SUENSZXF1ZXN0O1xudmFyIGlzSlNPTlJQQ1JlcXVlc3RzID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmV2ZXJ5KGV4cG9ydHMuaXNKU09OUlBDUmVxdWVzdCk7XG59O1xuZXhwb3J0cy5pc0pTT05SUENSZXF1ZXN0cyA9IGlzSlNPTlJQQ1JlcXVlc3RzO1xudmFyIGlzSlNPTlJQQ1Jlc3BvbnNlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICByZXR1cm4gKHBheWxvYWQuanNvbnJwYyA9PT0gZXhwb3J0cy5KU09OUlBDICYmXG4gICAgICAgIHBheWxvYWQuaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAocGF5bG9hZC5yZXN1bHQgIT09IHVuZGVmaW5lZCB8fCBwYXlsb2FkLmVycm9yICE9PSB1bmRlZmluZWQpKTtcbn07XG5leHBvcnRzLmlzSlNPTlJQQ1Jlc3BvbnNlID0gaXNKU09OUlBDUmVzcG9uc2U7XG52YXIgaXNKU09OUlBDUmVzcG9uc2VzID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmV2ZXJ5KGV4cG9ydHMuaXNKU09OUlBDUmVzcG9uc2UpO1xufTtcbmV4cG9ydHMuaXNKU09OUlBDUmVzcG9uc2VzID0gaXNKU09OUlBDUmVzcG9uc2VzO1xudmFyIGNyZWF0ZUpTT05SUENFcnJvciA9IGZ1bmN0aW9uIChjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgdmFyIGVycm9yID0geyBjb2RlOiBjb2RlLCBtZXNzYWdlOiBtZXNzYWdlIH07XG4gICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICBlcnJvci5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufTtcbnZhciBKU09OUlBDRXJyb3JFeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05SUENFcnJvckV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKU09OUlBDRXJyb3JFeGNlcHRpb24obWVzc2FnZSwgY29kZSwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICAvLyBNYW51YWxseSBzZXQgdGhlIHByb3RvdHlwZSB0byBmaXggVHlwZVNjcmlwdCBpc3N1ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0LXdpa2kvYmxvYi9tYWluL0JyZWFraW5nLUNoYW5nZXMubWQjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgSlNPTlJQQ0Vycm9yRXhjZXB0aW9uLnByb3RvdHlwZSk7XG4gICAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBKU09OUlBDRXJyb3JFeGNlcHRpb24ucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlSlNPTlJQQ0Vycm9yKHRoaXMuY29kZSwgdGhpcy5tZXNzYWdlLCB0aGlzLmRhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05SUENFcnJvckV4Y2VwdGlvbjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuSlNPTlJQQ0Vycm9yRXhjZXB0aW9uID0gSlNPTlJQQ0Vycm9yRXhjZXB0aW9uO1xudmFyIEpTT05SUENFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEpTT05SUENFcnJvckNvZGUpIHtcbiAgICBKU09OUlBDRXJyb3JDb2RlW0pTT05SUENFcnJvckNvZGVbXCJQYXJzZUVycm9yXCJdID0gLTMyNzAwXSA9IFwiUGFyc2VFcnJvclwiO1xuICAgIEpTT05SUENFcnJvckNvZGVbSlNPTlJQQ0Vycm9yQ29kZVtcIkludmFsaWRSZXF1ZXN0XCJdID0gLTMyNjAwXSA9IFwiSW52YWxpZFJlcXVlc3RcIjtcbiAgICBKU09OUlBDRXJyb3JDb2RlW0pTT05SUENFcnJvckNvZGVbXCJNZXRob2ROb3RGb3VuZFwiXSA9IC0zMjYwMV0gPSBcIk1ldGhvZE5vdEZvdW5kXCI7XG4gICAgSlNPTlJQQ0Vycm9yQ29kZVtKU09OUlBDRXJyb3JDb2RlW1wiSW52YWxpZFBhcmFtc1wiXSA9IC0zMjYwMl0gPSBcIkludmFsaWRQYXJhbXNcIjtcbiAgICBKU09OUlBDRXJyb3JDb2RlW0pTT05SUENFcnJvckNvZGVbXCJJbnRlcm5hbEVycm9yXCJdID0gLTMyNjAzXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xufSkoSlNPTlJQQ0Vycm9yQ29kZSA9IGV4cG9ydHMuSlNPTlJQQ0Vycm9yQ29kZSB8fCAoZXhwb3J0cy5KU09OUlBDRXJyb3JDb2RlID0ge30pKTtcbnZhciBjcmVhdGVKU09OUlBDRXJyb3JSZXNwb25zZSA9IGZ1bmN0aW9uIChpZCwgY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IGV4cG9ydHMuSlNPTlJQQyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBlcnJvcjogY3JlYXRlSlNPTlJQQ0Vycm9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpLFxuICAgIH07XG59O1xuZXhwb3J0cy5jcmVhdGVKU09OUlBDRXJyb3JSZXNwb25zZSA9IGNyZWF0ZUpTT05SUENFcnJvclJlc3BvbnNlO1xudmFyIGNyZWF0ZUpTT05SUENTdWNjZXNzUmVzcG9uc2UgPSBmdW5jdGlvbiAoaWQsIHJlc3VsdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IGV4cG9ydHMuSlNPTlJQQyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQgIT09IHZvaWQgMCA/IHJlc3VsdCA6IG51bGwsXG4gICAgfTtcbn07XG5leHBvcnRzLmNyZWF0ZUpTT05SUENTdWNjZXNzUmVzcG9uc2UgPSBjcmVhdGVKU09OUlBDU3VjY2Vzc1Jlc3BvbnNlO1xudmFyIGNyZWF0ZUpTT05SUENSZXF1ZXN0ID0gZnVuY3Rpb24gKGlkLCBtZXRob2QsIHBhcmFtcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IGV4cG9ydHMuSlNPTlJQQyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgfTtcbn07XG5leHBvcnRzLmNyZWF0ZUpTT05SUENSZXF1ZXN0ID0gY3JlYXRlSlNPTlJQQ1JlcXVlc3Q7XG52YXIgY3JlYXRlSlNPTlJQQ05vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IGV4cG9ydHMuSlNPTlJQQyxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgIH07XG59O1xuZXhwb3J0cy5jcmVhdGVKU09OUlBDTm90aWZpY2F0aW9uID0gY3JlYXRlSlNPTlJQQ05vdGlmaWNhdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5KU09OUlBDU2VydmVyQW5kQ2xpZW50ID0gdm9pZCAwO1xudmFyIG1vZGVsc18xID0gcmVxdWlyZShcIi4vbW9kZWxzXCIpO1xudmFyIEpTT05SUENTZXJ2ZXJBbmRDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNPTlJQQ1NlcnZlckFuZENsaWVudChzZXJ2ZXIsIGNsaWVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5lcnJvckxpc3RlbmVyID0gKF9hID0gb3B0aW9ucy5lcnJvckxpc3RlbmVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zb2xlLndhcm47XG4gICAgfVxuICAgIEpTT05SUENTZXJ2ZXJBbmRDbGllbnQucHJvdG90eXBlLmFwcGx5U2VydmVyTWlkZGxld2FyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgbWlkZGxld2FyZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG1pZGRsZXdhcmVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5zZXJ2ZXIpLmFwcGx5TWlkZGxld2FyZS5hcHBseShfYSwgbWlkZGxld2FyZXMpO1xuICAgIH07XG4gICAgSlNPTlJQQ1NlcnZlckFuZENsaWVudC5wcm90b3R5cGUuaGFzTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyLmhhc01ldGhvZChuYW1lKTtcbiAgICB9O1xuICAgIEpTT05SUENTZXJ2ZXJBbmRDbGllbnQucHJvdG90eXBlLmFkZE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBtZXRob2QpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXIuYWRkTWV0aG9kKG5hbWUsIG1ldGhvZCk7XG4gICAgfTtcbiAgICBKU09OUlBDU2VydmVyQW5kQ2xpZW50LnByb3RvdHlwZS5hZGRNZXRob2RBZHZhbmNlZCA9IGZ1bmN0aW9uIChuYW1lLCBtZXRob2QpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXIuYWRkTWV0aG9kQWR2YW5jZWQobmFtZSwgbWV0aG9kKTtcbiAgICB9O1xuICAgIEpTT05SUENTZXJ2ZXJBbmRDbGllbnQucHJvdG90eXBlLnJlbW92ZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoaXMuc2VydmVyLnJlbW92ZU1ldGhvZChuYW1lKTtcbiAgICB9O1xuICAgIEpTT05SUENTZXJ2ZXJBbmRDbGllbnQucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnRpbWVvdXQoZGVsYXkpO1xuICAgIH07XG4gICAgSlNPTlJQQ1NlcnZlckFuZENsaWVudC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcywgY2xpZW50UGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0KG1ldGhvZCwgcGFyYW1zLCBjbGllbnRQYXJhbXMpO1xuICAgIH07XG4gICAgSlNPTlJQQ1NlcnZlckFuZENsaWVudC5wcm90b3R5cGUucmVxdWVzdEFkdmFuY2VkID0gZnVuY3Rpb24gKGpzb25SUENSZXF1ZXN0LCBjbGllbnRQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3RBZHZhbmNlZChqc29uUlBDUmVxdWVzdCwgY2xpZW50UGFyYW1zKTtcbiAgICB9O1xuICAgIEpTT05SUENTZXJ2ZXJBbmRDbGllbnQucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcywgY2xpZW50UGFyYW1zKSB7XG4gICAgICAgIHRoaXMuY2xpZW50Lm5vdGlmeShtZXRob2QsIHBhcmFtcywgY2xpZW50UGFyYW1zKTtcbiAgICB9O1xuICAgIEpTT05SUENTZXJ2ZXJBbmRDbGllbnQucHJvdG90eXBlLnJlamVjdEFsbFBlbmRpbmdSZXF1ZXN0cyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LnJlamVjdEFsbFBlbmRpbmdSZXF1ZXN0cyhtZXNzYWdlKTtcbiAgICB9O1xuICAgIEpTT05SUENTZXJ2ZXJBbmRDbGllbnQucHJvdG90eXBlLnJlY2VpdmVBbmRTZW5kID0gZnVuY3Rpb24gKHBheWxvYWQsIHNlcnZlclBhcmFtcywgY2xpZW50UGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSwgbWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCgwLCBtb2RlbHNfMS5pc0pTT05SUENSZXNwb25zZSkocGF5bG9hZCkgfHwgKDAsIG1vZGVsc18xLmlzSlNPTlJQQ1Jlc3BvbnNlcykocGF5bG9hZCkpKSByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50LnJlY2VpdmUocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoKDAsIG1vZGVsc18xLmlzSlNPTlJQQ1JlcXVlc3QpKHBheWxvYWQpIHx8ICgwLCBtb2RlbHNfMS5pc0pTT05SUENSZXF1ZXN0cykocGF5bG9hZCkpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2VydmVyLnJlY2VpdmUocGF5bG9hZCwgc2VydmVyUGFyYW1zKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuY2xpZW50LnNlbmQocmVzcG9uc2UsIGNsaWVudFBhcmFtcyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlJlY2VpdmVkIGFuIGludmFsaWQgSlNPTi1SUEMgbWVzc2FnZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvckxpc3RlbmVyKG1lc3NhZ2UsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihtZXNzYWdlKSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTlJQQ1NlcnZlckFuZENsaWVudDtcbn0oKSk7XG5leHBvcnRzLkpTT05SUENTZXJ2ZXJBbmRDbGllbnQgPSBKU09OUlBDU2VydmVyQW5kQ2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5KU09OUlBDU2VydmVyID0gdm9pZCAwO1xudmFyIG1vZGVsc18xID0gcmVxdWlyZShcIi4vbW9kZWxzXCIpO1xudmFyIGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbnZhciBjcmVhdGVQYXJzZUVycm9yUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgwLCBtb2RlbHNfMS5jcmVhdGVKU09OUlBDRXJyb3JSZXNwb25zZSkobnVsbCwgbW9kZWxzXzEuSlNPTlJQQ0Vycm9yQ29kZS5QYXJzZUVycm9yLCBcIlBhcnNlIGVycm9yXCIpO1xufTtcbnZhciBjcmVhdGVJbnZhbGlkUmVxdWVzdFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gKDAsIG1vZGVsc18xLmNyZWF0ZUpTT05SUENFcnJvclJlc3BvbnNlKSgoMCwgbW9kZWxzXzEuaXNKU09OUlBDSUQpKHJlcXVlc3QuaWQpID8gcmVxdWVzdC5pZCA6IG51bGwsIG1vZGVsc18xLkpTT05SUENFcnJvckNvZGUuSW52YWxpZFJlcXVlc3QsIFwiSW52YWxpZCBSZXF1ZXN0XCIpO1xufTtcbnZhciBjcmVhdGVNZXRob2ROb3RGb3VuZFJlc3BvbnNlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuICgwLCBtb2RlbHNfMS5jcmVhdGVKU09OUlBDRXJyb3JSZXNwb25zZSkoaWQsIG1vZGVsc18xLkpTT05SUENFcnJvckNvZGUuTWV0aG9kTm90Rm91bmQsIFwiTWV0aG9kIG5vdCBmb3VuZFwiKTtcbn07XG52YXIgSlNPTlJQQ1NlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU09OUlBDU2VydmVyKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLm1hcEVycm9yVG9KU09OUlBDRXJyb3JSZXNwb25zZSA9IGRlZmF1bHRNYXBFcnJvclRvSlNPTlJQQ0Vycm9yUmVzcG9uc2U7XG4gICAgICAgIHRoaXMubmFtZVRvTWV0aG9kRGljdGlvbmFyeSA9IHt9O1xuICAgICAgICB0aGlzLm1pZGRsZXdhcmUgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9yTGlzdGVuZXIgPSAoX2EgPSBvcHRpb25zLmVycm9yTGlzdGVuZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnNvbGUud2FybjtcbiAgICB9XG4gICAgSlNPTlJQQ1NlcnZlci5wcm90b3R5cGUuaGFzTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5uYW1lVG9NZXRob2REaWN0aW9uYXJ5W25hbWVdO1xuICAgIH07XG4gICAgSlNPTlJQQ1NlcnZlci5wcm90b3R5cGUuYWRkTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIG1ldGhvZCkge1xuICAgICAgICB0aGlzLmFkZE1ldGhvZEFkdmFuY2VkKG5hbWUsIHRoaXMudG9KU09OUlBDTWV0aG9kKG1ldGhvZCkpO1xuICAgIH07XG4gICAgSlNPTlJQQ1NlcnZlci5wcm90b3R5cGUucmVtb3ZlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubmFtZVRvTWV0aG9kRGljdGlvbmFyeVtuYW1lXTtcbiAgICB9O1xuICAgIEpTT05SUENTZXJ2ZXIucHJvdG90eXBlLnRvSlNPTlJQQ01ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXF1ZXN0LCBzZXJ2ZXJQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IG1ldGhvZChyZXF1ZXN0LnBhcmFtcywgc2VydmVyUGFyYW1zKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXBSZXN1bHRUb0pTT05SUENSZXNwb25zZShyZXF1ZXN0LmlkLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBKU09OUlBDU2VydmVyLnByb3RvdHlwZS5hZGRNZXRob2RBZHZhbmNlZCA9IGZ1bmN0aW9uIChuYW1lLCBtZXRob2QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLm5hbWVUb01ldGhvZERpY3Rpb25hcnkgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5uYW1lVG9NZXRob2REaWN0aW9uYXJ5KSwgKF9hID0ge30sIF9hW25hbWVdID0gbWV0aG9kLCBfYSkpO1xuICAgIH07XG4gICAgSlNPTlJQQ1NlcnZlci5wcm90b3R5cGUucmVjZWl2ZUpTT04gPSBmdW5jdGlvbiAoanNvbiwgc2VydmVyUGFyYW1zKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy50cnlQYXJzZVJlcXVlc3RKU09OKGpzb24pO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZShyZXF1ZXN0LCBzZXJ2ZXJQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVQYXJzZUVycm9yUmVzcG9uc2UoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05SUENTZXJ2ZXIucHJvdG90eXBlLnRyeVBhcnNlUmVxdWVzdEpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTlJQQ1NlcnZlci5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBzZXJ2ZXJQYXJhbXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxdWVzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVNdWx0aXBsZShyZXF1ZXN0LCBzZXJ2ZXJQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZVNpbmdsZShyZXF1ZXN0LCBzZXJ2ZXJQYXJhbXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09OUlBDU2VydmVyLnByb3RvdHlwZS5yZWNlaXZlTXVsdGlwbGUgPSBmdW5jdGlvbiAocmVxdWVzdHMsIHNlcnZlclBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VzO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwocmVxdWVzdHMubWFwKGZ1bmN0aW9uIChyZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5yZWNlaXZlU2luZ2xlKHJlcXVlc3QsIHNlcnZlclBhcmFtcyk7IH0pKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlcyA9IChfYS5zZW50KCkpLmZpbHRlcihpc05vbk51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzcG9uc2VzWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzcG9uc2VzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKU09OUlBDU2VydmVyLnByb3RvdHlwZS5yZWNlaXZlU2luZ2xlID0gZnVuY3Rpb24gKHJlcXVlc3QsIHNlcnZlclBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kLCByZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHRoaXMubmFtZVRvTWV0aG9kRGljdGlvbmFyeVtyZXF1ZXN0Lm1ldGhvZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISEoMCwgbW9kZWxzXzEuaXNKU09OUlBDUmVxdWVzdCkocmVxdWVzdCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNyZWF0ZUludmFsaWRSZXF1ZXN0UmVzcG9uc2UocmVxdWVzdCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2FsbE1ldGhvZChtZXRob2QsIHJlcXVlc3QsIHNlcnZlclBhcmFtcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBtYXBSZXNwb25zZShyZXF1ZXN0LCByZXNwb25zZSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpTT05SUENTZXJ2ZXIucHJvdG90eXBlLmFwcGx5TWlkZGxld2FyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1pZGRsZXdhcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBtaWRkbGV3YXJlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgIHRoaXMubWlkZGxld2FyZSA9IHRoaXMuY29tYmluZU1pZGRsZXdhcmVzKF9fc3ByZWFkQXJyYXkoW1xuICAgICAgICAgICAgICAgIHRoaXMubWlkZGxld2FyZVxuICAgICAgICAgICAgXSwgbWlkZGxld2FyZXMsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWlkZGxld2FyZSA9IHRoaXMuY29tYmluZU1pZGRsZXdhcmVzKG1pZGRsZXdhcmVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTlJQQ1NlcnZlci5wcm90b3R5cGUuY29tYmluZU1pZGRsZXdhcmVzID0gZnVuY3Rpb24gKG1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGlmICghbWlkZGxld2FyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlcy5yZWR1Y2UodGhpcy5taWRkbGV3YXJlUmVkdWNlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05SUENTZXJ2ZXIucHJvdG90eXBlLm1pZGRsZXdhcmVSZWR1Y2VyID0gZnVuY3Rpb24gKHByZXZNaWRkbGV3YXJlLCBuZXh0TWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQsIHJlcXVlc3QsIHNlcnZlclBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZNaWRkbGV3YXJlKGZ1bmN0aW9uIChyZXF1ZXN0LCBzZXJ2ZXJQYXJhbXMpIHsgcmV0dXJuIG5leHRNaWRkbGV3YXJlKG5leHQsIHJlcXVlc3QsIHNlcnZlclBhcmFtcyk7IH0sIHJlcXVlc3QsIHNlcnZlclBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBKU09OUlBDU2VydmVyLnByb3RvdHlwZS5jYWxsTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCwgcmVxdWVzdCwgc2VydmVyUGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjYWxsTWV0aG9kID0gZnVuY3Rpb24gKHJlcXVlc3QsIHNlcnZlclBhcmFtcykge1xuICAgICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QocmVxdWVzdCwgc2VydmVyUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcXVlc3QuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlTWV0aG9kTm90Rm91bmRSZXNwb25zZShyZXF1ZXN0LmlkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMuZXJyb3JMaXN0ZW5lcihcIkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgd2hpbGUgZXhlY3V0aW5nIFxcXCJcIi5jb25jYXQocmVxdWVzdC5tZXRob2QsIFwiXFxcIiBKU09OLVJQQyBtZXRob2Q6XCIpLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF90aGlzLm1hcEVycm9yVG9KU09OUlBDRXJyb3JSZXNwb25zZUlmTmVjZXNzYXJ5KHJlcXVlc3QuaWQsIGVycm9yKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubWlkZGxld2FyZSB8fCBub29wTWlkZGxld2FyZSkoY2FsbE1ldGhvZCwgcmVxdWVzdCwgc2VydmVyUGFyYW1zKS50aGVuKHVuZGVmaW5lZCwgb25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gb25FcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05SUENTZXJ2ZXIucHJvdG90eXBlLm1hcEVycm9yVG9KU09OUlBDRXJyb3JSZXNwb25zZUlmTmVjZXNzYXJ5ID0gZnVuY3Rpb24gKGlkLCBlcnJvcikge1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwRXJyb3JUb0pTT05SUENFcnJvclJlc3BvbnNlKGlkLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEpTT05SUENTZXJ2ZXI7XG59KCkpO1xuZXhwb3J0cy5KU09OUlBDU2VydmVyID0gSlNPTlJQQ1NlcnZlcjtcbnZhciBpc05vbk51bGwgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlICE9PSBudWxsOyB9O1xudmFyIG5vb3BNaWRkbGV3YXJlID0gZnVuY3Rpb24gKG5leHQsIHJlcXVlc3QsIHNlcnZlclBhcmFtcykgeyByZXR1cm4gbmV4dChyZXF1ZXN0LCBzZXJ2ZXJQYXJhbXMpOyB9O1xudmFyIG1hcFJlc3VsdFRvSlNPTlJQQ1Jlc3BvbnNlID0gZnVuY3Rpb24gKGlkLCByZXN1bHQpIHtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKDAsIG1vZGVsc18xLmNyZWF0ZUpTT05SUENTdWNjZXNzUmVzcG9uc2UpKGlkLCByZXN1bHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbnZhciBkZWZhdWx0TWFwRXJyb3JUb0pTT05SUENFcnJvclJlc3BvbnNlID0gZnVuY3Rpb24gKGlkLCBlcnJvcikge1xuICAgIHZhciBfYTtcbiAgICB2YXIgbWVzc2FnZSA9IChfYSA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWRcIjtcbiAgICB2YXIgY29kZSA9IGludGVybmFsXzEuRGVmYXVsdEVycm9yQ29kZTtcbiAgICB2YXIgZGF0YTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBtb2RlbHNfMS5KU09OUlBDRXJyb3JFeGNlcHRpb24pIHtcbiAgICAgICAgY29kZSA9IGVycm9yLmNvZGU7XG4gICAgICAgIGRhdGEgPSBlcnJvci5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIG1vZGVsc18xLmNyZWF0ZUpTT05SUENFcnJvclJlc3BvbnNlKShpZCwgY29kZSwgbWVzc2FnZSwgZGF0YSk7XG59O1xudmFyIG1hcFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVxdWVzdC5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoMCwgbW9kZWxzXzEuY3JlYXRlSlNPTlJQQ0Vycm9yUmVzcG9uc2UpKHJlcXVlc3QuaWQsIG1vZGVsc18xLkpTT05SUENFcnJvckNvZGUuSW50ZXJuYWxFcnJvciwgXCJJbnRlcm5hbCBlcnJvclwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG4iLCJ2YXIgX2ZzXG50cnkge1xuICBfZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG59IGNhdGNoIChfKSB7XG4gIF9mcyA9IHJlcXVpcmUoJ2ZzJylcbn1cblxuZnVuY3Rpb24gcmVhZEZpbGUgKGZpbGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtlbmNvZGluZzogb3B0aW9uc31cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgdmFyIHNob3VsZFRocm93ID0gdHJ1ZVxuICBpZiAoJ3Rocm93cycgaW4gb3B0aW9ucykge1xuICAgIHNob3VsZFRocm93ID0gb3B0aW9ucy50aHJvd3NcbiAgfVxuXG4gIGZzLnJlYWRGaWxlKGZpbGUsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgZGF0YSA9IHN0cmlwQm9tKGRhdGEpXG5cbiAgICB2YXIgb2JqXG4gICAgdHJ5IHtcbiAgICAgIG9iaiA9IEpTT04ucGFyc2UoZGF0YSwgb3B0aW9ucyA/IG9wdGlvbnMucmV2aXZlciA6IG51bGwpXG4gICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICAgIGVycjIubWVzc2FnZSA9IGZpbGUgKyAnOiAnICsgZXJyMi5tZXNzYWdlXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgb2JqKVxuICB9KVxufVxuXG5mdW5jdGlvbiByZWFkRmlsZVN5bmMgKGZpbGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7ZW5jb2Rpbmc6IG9wdGlvbnN9XG4gIH1cblxuICB2YXIgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIHZhciBzaG91bGRUaHJvdyA9IHRydWVcbiAgaWYgKCd0aHJvd3MnIGluIG9wdGlvbnMpIHtcbiAgICBzaG91bGRUaHJvdyA9IG9wdGlvbnMudGhyb3dzXG4gIH1cblxuICB0cnkge1xuICAgIHZhciBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGUsIG9wdGlvbnMpXG4gICAgY29udGVudCA9IHN0cmlwQm9tKGNvbnRlbnQpXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCwgb3B0aW9ucy5yZXZpdmVyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gZmlsZSArICc6ICcgKyBlcnIubWVzc2FnZVxuICAgICAgdGhyb3cgZXJyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSAob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzcGFjZXNcbiAgdmFyIEVPTCA9ICdcXG4nXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIGlmIChvcHRpb25zLnNwYWNlcykge1xuICAgICAgc3BhY2VzID0gb3B0aW9ucy5zcGFjZXNcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuRU9MKSB7XG4gICAgICBFT0wgPSBvcHRpb25zLkVPTFxuICAgIH1cbiAgfVxuXG4gIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmosIG9wdGlvbnMgPyBvcHRpb25zLnJlcGxhY2VyIDogbnVsbCwgc3BhY2VzKVxuXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxuL2csIEVPTCkgKyBFT0xcbn1cblxuZnVuY3Rpb24gd3JpdGVGaWxlIChmaWxlLCBvYmosIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICB2YXIgc3RyID0gJydcbiAgdHJ5IHtcbiAgICBzdHIgPSBzdHJpbmdpZnkob2JqLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBOZWVkIHRvIHJldHVybiB3aGV0aGVyIGEgY2FsbGJhY2sgd2FzIHBhc3NlZCBvciBub3RcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciwgbnVsbClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZzLndyaXRlRmlsZShmaWxlLCBzdHIsIG9wdGlvbnMsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZpbGVTeW5jIChmaWxlLCBvYmosIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICB2YXIgc3RyID0gc3RyaW5naWZ5KG9iaiwgb3B0aW9ucylcbiAgLy8gbm90IHN1cmUgaWYgZnMud3JpdGVGaWxlU3luYyByZXR1cm5zIGFueXRoaW5nLCBidXQganVzdCBpbiBjYXNlXG4gIHJldHVybiBmcy53cml0ZUZpbGVTeW5jKGZpbGUsIHN0ciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RyaXBCb20gKGNvbnRlbnQpIHtcbiAgLy8gd2UgZG8gdGhpcyBiZWNhdXNlIEpTT04ucGFyc2Ugd291bGQgY29udmVydCBpdCB0byBhIHV0Zjggc3RyaW5nIGlmIGVuY29kaW5nIHdhc24ndCBzcGVjaWZpZWRcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjb250ZW50KSkgY29udGVudCA9IGNvbnRlbnQudG9TdHJpbmcoJ3V0ZjgnKVxuICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9eXFx1RkVGRi8sICcnKVxuICByZXR1cm4gY29udGVudFxufVxuXG52YXIganNvbmZpbGUgPSB7XG4gIHJlYWRGaWxlOiByZWFkRmlsZSxcbiAgcmVhZEZpbGVTeW5jOiByZWFkRmlsZVN5bmMsXG4gIHdyaXRlRmlsZTogd3JpdGVGaWxlLFxuICB3cml0ZUZpbGVTeW5jOiB3cml0ZUZpbGVTeW5jXG59XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbmZpbGVcbiIsInZhciBzYWZlSXNOYU4gPSBOdW1iZXIuaXNOYU4gfHxcbiAgICBmdW5jdGlvbiBwb255ZmlsbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gdmFsdWU7XG4gICAgfTtcbmZ1bmN0aW9uIGlzRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICAgIGlmIChmaXJzdCA9PT0gc2Vjb25kKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc2FmZUlzTmFOKGZpcnN0KSAmJiBzYWZlSXNOYU4oc2Vjb25kKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYXJlSW5wdXRzRXF1YWwobmV3SW5wdXRzLCBsYXN0SW5wdXRzKSB7XG4gICAgaWYgKG5ld0lucHV0cy5sZW5ndGggIT09IGxhc3RJbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc0VxdWFsKG5ld0lucHV0c1tpXSwgbGFzdElucHV0c1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWVtb2l6ZU9uZShyZXN1bHRGbiwgaXNFcXVhbCkge1xuICAgIGlmIChpc0VxdWFsID09PSB2b2lkIDApIHsgaXNFcXVhbCA9IGFyZUlucHV0c0VxdWFsOyB9XG4gICAgdmFyIGNhY2hlID0gbnVsbDtcbiAgICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICAgICAgdmFyIG5ld0FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5ld0FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUubGFzdFRoaXMgPT09IHRoaXMgJiYgaXNFcXVhbChuZXdBcmdzLCBjYWNoZS5sYXN0QXJncykpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5sYXN0UmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0UmVzdWx0ID0gcmVzdWx0Rm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgICAgIGNhY2hlID0ge1xuICAgICAgICAgICAgbGFzdFJlc3VsdDogbGFzdFJlc3VsdCxcbiAgICAgICAgICAgIGxhc3RBcmdzOiBuZXdBcmdzLFxuICAgICAgICAgICAgbGFzdFRoaXM6IHRoaXMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH1cbiAgICBtZW1vaXplZC5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBjYWNoZSA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbmV4cG9ydCB7IG1lbW9pemVPbmUgYXMgZGVmYXVsdCB9O1xuIiwidmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIF8wNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBta2RpclAubWtkaXJwID0gbWtkaXJQLm1rZGlyUCA9IG1rZGlyUDtcblxuZnVuY3Rpb24gbWtkaXJQIChwLCBvcHRzLCBmLCBtYWRlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGYgPSBvcHRzO1xuICAgICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0geyBtb2RlOiBvcHRzIH07XG4gICAgfVxuICAgIFxuICAgIHZhciBtb2RlID0gb3B0cy5tb2RlO1xuICAgIHZhciB4ZnMgPSBvcHRzLmZzIHx8IGZzO1xuICAgIFxuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbW9kZSA9IF8wNzc3XG4gICAgfVxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XG4gICAgXG4gICAgdmFyIGNiID0gZiB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoKSB7fTtcbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xuICAgIFxuICAgIHhmcy5ta2RpcihwLCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKCFlcikge1xuICAgICAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBtYWRlKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGVyLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VOT0VOVCc6XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKHBhdGguZGlybmFtZShwKSA9PT0gcCkgcmV0dXJuIGNiKGVyKTtcbiAgICAgICAgICAgICAgICBta2RpclAocGF0aC5kaXJuYW1lKHApLCBvcHRzLCBmdW5jdGlvbiAoZXIsIG1hZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcikgY2IoZXIsIG1hZGUpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIG1rZGlyUChwLCBvcHRzLCBjYiwgbWFkZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxuICAgICAgICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcbiAgICAgICAgICAgIC8vIGlzIGJvcmtlZC5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgeGZzLnN0YXQocCwgZnVuY3Rpb24gKGVyMiwgc3RhdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RhdCBmYWlscywgdGhlbiB0aGF0J3Mgc3VwZXIgd2VpcmQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCB0aGUgb3JpZ2luYWwgZXJyb3IgYmUgdGhlIGZhaWx1cmUgcmVhc29uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZXIyIHx8ICFzdGF0LmlzRGlyZWN0b3J5KCkpIGNiKGVyLCBtYWRlKVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGNiKG51bGwsIG1hZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbm1rZGlyUC5zeW5jID0gZnVuY3Rpb24gc3luYyAocCwgb3B0cywgbWFkZSkge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9O1xuICAgIH1cbiAgICBcbiAgICB2YXIgbW9kZSA9IG9wdHMubW9kZTtcbiAgICB2YXIgeGZzID0gb3B0cy5mcyB8fCBmcztcbiAgICBcbiAgICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1vZGUgPSBfMDc3N1xuICAgIH1cbiAgICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsO1xuXG4gICAgcCA9IHBhdGgucmVzb2x2ZShwKTtcblxuICAgIHRyeSB7XG4gICAgICAgIHhmcy5ta2RpclN5bmMocCwgbW9kZSk7XG4gICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XG4gICAgfVxuICAgIGNhdGNoIChlcnIwKSB7XG4gICAgICAgIHN3aXRjaCAoZXJyMC5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdFTk9FTlQnIDpcbiAgICAgICAgICAgICAgICBtYWRlID0gc3luYyhwYXRoLmRpcm5hbWUocCksIG9wdHMsIG1hZGUpO1xuICAgICAgICAgICAgICAgIHN5bmMocCwgb3B0cywgbWFkZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxuICAgICAgICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcbiAgICAgICAgICAgIC8vIGlzIGJvcmtlZC5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFyIHN0YXQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHhmcy5zdGF0U3luYyhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycjEpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0LmlzRGlyZWN0b3J5KCkpIHRocm93IGVycjA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFkZTtcbn07XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuNy4wXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBKU09OU3RvcmFnZSwgS0VZX0ZPUl9FTVBUWV9TVFJJTkcsIExvY2FsU3RvcmFnZSwgTWV0YUtleSwgUVVPVEFfRVhDRUVERURfRVJSLCBTdG9yYWdlRXZlbnQsIF9lbXB0eURpcmVjdG9yeSwgX2VzY2FwZUtleSwgX3JtLCBjcmVhdGVNYXAsIGV2ZW50cywgZnMsIHBhdGgsIHdyaXRlU3luYztcblxuICBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG4gIGZzID0gcmVxdWlyZSgnZnMnKTtcblxuICBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcblxuICB3cml0ZVN5bmMgPSByZXF1aXJlKCd3cml0ZS1maWxlLWF0b21pYycpLnN5bmM7XG5cbiAgS0VZX0ZPUl9FTVBUWV9TVFJJTkcgPSAnLS0tLkVNUFRZX1NUUklORy4tLS0nOyAvLyBDaG9zZSBzb21ldGhpbmcgdGhhdCBubyBvbmUgaXMgbGlrZWx5IHRvIGV2ZXIgdXNlXG5cbiAgX2VtcHR5RGlyZWN0b3J5ID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIGksIGxlbiwgcCwgcmVmLCByZXN1bHRzO1xuICAgIHJlZiA9IGZzLnJlYWRkaXJTeW5jKHRhcmdldCk7XG4gICAgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcCA9IHJlZltpXTtcbiAgICAgIHJlc3VsdHMucHVzaChfcm0ocGF0aC5qb2luKHRhcmdldCwgcCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgX3JtID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgaWYgKGZzLnN0YXRTeW5jKHRhcmdldCkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgX2VtcHR5RGlyZWN0b3J5KHRhcmdldCk7XG4gICAgICByZXR1cm4gZnMucm1kaXJTeW5jKHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmcy51bmxpbmtTeW5jKHRhcmdldCk7XG4gICAgfVxuICB9O1xuXG4gIF9lc2NhcGVLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgbmV3S2V5O1xuICAgIGlmIChrZXkgPT09ICcnKSB7XG4gICAgICBuZXdLZXkgPSBLRVlfRk9SX0VNUFRZX1NUUklORztcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3S2V5ID0gYCR7a2V5fWA7XG4gICAgfVxuICAgIHJldHVybiBuZXdLZXk7XG4gIH07XG5cbiAgUVVPVEFfRVhDRUVERURfRVJSID0gY2xhc3MgUVVPVEFfRVhDRUVERURfRVJSIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSAnVW5rbm93biBlcnJvci4nKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAhPSBudWxsKSB7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX06ICR7dGhpcy5tZXNzYWdlfWA7XG4gICAgfVxuXG4gIH07XG5cbiAgU3RvcmFnZUV2ZW50ID0gY2xhc3MgU3RvcmFnZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihrZXkxLCBvbGRWYWx1ZTEsIG5ld1ZhbHVlMSwgdXJsLCBzdG9yYWdlQXJlYSA9ICdsb2NhbFN0b3JhZ2UnKSB7XG4gICAgICB0aGlzLmtleSA9IGtleTE7XG4gICAgICB0aGlzLm9sZFZhbHVlID0gb2xkVmFsdWUxO1xuICAgICAgdGhpcy5uZXdWYWx1ZSA9IG5ld1ZhbHVlMTtcbiAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgdGhpcy5zdG9yYWdlQXJlYSA9IHN0b3JhZ2VBcmVhO1xuICAgIH1cblxuICB9O1xuXG4gIE1ldGFLZXkgPSBjbGFzcyBNZXRhS2V5IHsgLy8gTWV0YUtleSBjb250YWlucyBrZXkgYW5kIHNpemVcbiAgICBjb25zdHJ1Y3RvcihrZXkxLCBpbmRleDEpIHtcbiAgICAgIHRoaXMua2V5ID0ga2V5MTtcbiAgICAgIHRoaXMuaW5kZXggPSBpbmRleDE7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWV0YUtleSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRhS2V5KHRoaXMua2V5LCB0aGlzLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICBjcmVhdGVNYXAgPSBmdW5jdGlvbigpIHsgLy8gY3JlYXRlTWFwIGNvbnRhaW5zIE1ldGFrZXlzIGFzIHByb3BlcnRpZXNcbiAgICB2YXIgTWFwO1xuICAgIE1hcCA9IGZ1bmN0aW9uKCkge307XG4gICAgTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgfTtcblxuICBMb2NhbFN0b3JhZ2UgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluc3RhbmNlTWFwO1xuXG4gICAgY2xhc3MgTG9jYWxTdG9yYWdlIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XG4gICAgICBjb25zdHJ1Y3RvcihfbG9jYXRpb24sIHF1b3RhID0gNSAqIDEwMjQgKiAxMDI0KSB7XG4gICAgICAgIHZhciBoYW5kbGVyO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IF9sb2NhdGlvbjtcbiAgICAgICAgdGhpcy5xdW90YSA9IHF1b3RhO1xuICAgICAgICAvLyBzdXBlcihfbG9jYXRpb24sIHF1b3RhKVxuICAgICAgICAvLyBAX2xvY2F0aW9uID0gX2xvY2F0aW9uXG4gICAgICAgIC8vIEBxdW90YSA9IHF1b3RhXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMb2NhbFN0b3JhZ2UpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2NhbFN0b3JhZ2UodGhpcy5fbG9jYXRpb24sIHRoaXMucXVvdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gcGF0aC5yZXNvbHZlKHRoaXMuX2xvY2F0aW9uKTtcbiAgICAgICAgaWYgKGluc3RhbmNlTWFwW3RoaXMuX2xvY2F0aW9uXSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlTWFwW3RoaXMuX2xvY2F0aW9uXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7IC8vICFUT0RPOiBNYXliZSBjaGFuZ2UgdGhpcyB0byBhIHByb3BlcnR5IHdpdGggX19kZWZpbmVQcm9wZXJ0eV9fXG4gICAgICAgIHRoaXMuX2J5dGVzSW5Vc2UgPSAwO1xuICAgICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgICAgIHRoaXMuX21ldGFLZXlNYXAgPSBjcmVhdGVNYXAoKTtcbiAgICAgICAgdGhpcy5fZXZlbnRVcmwgPSBcInBpZDpcIiArIHByb2Nlc3MucGlkO1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAgIHRoaXMuX1FVT1RBX0VYQ0VFREVEX0VSUiA9IFFVT1RBX0VYQ0VFREVEX0VSUjtcbiAgICAgICAgaWYgKHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBQcm94eSAhPT0gbnVsbCkge1xuICAgICAgICAgIGhhbmRsZXIgPSB7XG4gICAgICAgICAgICBzZXQ6IChyZWNlaXZlciwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpc1trZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiAocmVjZWl2ZXIsIGtleSkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpc1trZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1trZXldO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG93bktleXM6ICh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleXMubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gS0VZX0ZPUl9FTVBUWV9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzW2tleV0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGluc3RhbmNlTWFwW3RoaXMuX2xvY2F0aW9uXSA9IG5ldyBQcm94eSh0aGlzLCBoYW5kbGVyKTtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2VNYXBbdGhpcy5fbG9jYXRpb25dO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgaXQnbGwgcmV0dXJuIHRoaXNcbiAgICAgICAgaW5zdGFuY2VNYXBbdGhpcy5fbG9jYXRpb25dID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlTWFwW3RoaXMuX2xvY2F0aW9uXTtcbiAgICAgIH1cblxuICAgICAgX2luaXQoKSB7XG4gICAgICAgIHZhciBlLCBzdGF0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXQgPSBmcy5zdGF0U3luYyh0aGlzLl9sb2NhdGlvbik7XG4gICAgICAgICAgaWYgKChzdGF0ICE9IG51bGwpICYmICFzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBmaWxlIGV4aXN0cyBhdCB0aGUgbG9jYXRpb24gJyR7dGhpcy5fbG9jYXRpb259JyB3aGVuIHRyeWluZyB0byBjcmVhdGUvb3BlbiBsb2NhbFN0b3JhZ2VgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgaXQgZXhpc3RzIGFuZCBpcyBkZWZpbml0ZWx5IGEgZGlyZWN0b3J5LiBTbyByZWFkIGl0LlxuICAgICAgICAgIHRoaXMuX3N5bmMoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBlID0gZXJyb3I7XG4gICAgICAgICAgLy8gSWYgaXQgZXJyb3JzLCB0aGF0IG1pZ2h0IG1lYW4gaXQgZGlkbid0IGV4aXN0LCBzbyB0cnkgdG8gY3JlYXRlIGl0XG4gICAgICAgICAgaWYgKGUuY29kZSAhPT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLm1rZGlyU3luYyh0aGlzLl9sb2NhdGlvbiwge1xuICAgICAgICAgICAgICByZWN1cnNpdmU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlID0gZXJyb3I7XG4gICAgICAgICAgICBpZiAoZS5jb2RlICE9PSBcIkVFWElTVFwiKSB7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9zeW5jKCkge1xuICAgICAgICB2YXIgX01ldGFLZXksIF9kZWNvZGVkS2V5LCBfa2V5cywgaSwgaW5kZXgsIGssIGxlbiwgc3RhdDtcbiAgICAgICAgdGhpcy5fYnl0ZXNJblVzZSA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgX2tleXMgPSBmcy5yZWFkZGlyU3luYyh0aGlzLl9sb2NhdGlvbik7XG4gICAgICAgIGZvciAoaW5kZXggPSBpID0gMCwgbGVuID0gX2tleXMubGVuZ3RoOyBpIDwgbGVuOyBpbmRleCA9ICsraSkge1xuICAgICAgICAgIGsgPSBfa2V5c1tpbmRleF07XG4gICAgICAgICAgX2RlY29kZWRLZXkgPSBkZWNvZGVVUklDb21wb25lbnQoayk7XG4gICAgICAgICAgdGhpcy5fa2V5cy5wdXNoKF9kZWNvZGVkS2V5KTtcbiAgICAgICAgICBfTWV0YUtleSA9IG5ldyBNZXRhS2V5KGssIGluZGV4KTtcbiAgICAgICAgICB0aGlzLl9tZXRhS2V5TWFwW19kZWNvZGVkS2V5XSA9IF9NZXRhS2V5O1xuICAgICAgICAgIHN0YXQgPSB0aGlzLl9nZXRTdGF0KGspO1xuICAgICAgICAgIGlmICgoc3RhdCAhPSBudWxsID8gc3RhdC5zaXplIDogdm9pZCAwKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfTWV0YUtleS5zaXplID0gc3RhdC5zaXplO1xuICAgICAgICAgICAgdGhpcy5fYnl0ZXNJblVzZSArPSBzdGF0LnNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9IF9rZXlzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBlbmNvZGVkS2V5LCBldm50LCBleGlzdHNCZWZvcmVTZXQsIGZpbGVuYW1lLCBoYXNMaXN0ZW5lcnMsIG1ldGFLZXksIG9sZExlbmd0aCwgb2xkVmFsdWUsIHZhbHVlU3RyaW5nLCB2YWx1ZVN0cmluZ0xlbmd0aDtcbiAgICAgICAgaGFzTGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lckNvdW50KCdzdG9yYWdlJyk7XG4gICAgICAgIG9sZFZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKGhhc0xpc3RlbmVycykge1xuICAgICAgICAgIG9sZFZhbHVlID0gdGhpcy5nZXRJdGVtKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gX2VzY2FwZUtleShrZXkpO1xuICAgICAgICBlbmNvZGVkS2V5ID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkucmVwbGFjZSgvWyEnKCldL2csIGVzY2FwZSkucmVwbGFjZSgvXFwqL2csIFwiJTJBXCIpO1xuICAgICAgICBmaWxlbmFtZSA9IHBhdGguam9pbih0aGlzLl9sb2NhdGlvbiwgZW5jb2RlZEtleSk7XG4gICAgICAgIHZhbHVlU3RyaW5nID0gYCR7dmFsdWV9YDtcbiAgICAgICAgdmFsdWVTdHJpbmdMZW5ndGggPSB2YWx1ZVN0cmluZy5sZW5ndGg7XG4gICAgICAgIG1ldGFLZXkgPSB0aGlzLl9tZXRhS2V5TWFwW2tleV07XG4gICAgICAgIGV4aXN0c0JlZm9yZVNldCA9ICEhbWV0YUtleTtcbiAgICAgICAgaWYgKGV4aXN0c0JlZm9yZVNldCkge1xuICAgICAgICAgIG9sZExlbmd0aCA9IG1ldGFLZXkuc2l6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRMZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9ieXRlc0luVXNlIC0gb2xkTGVuZ3RoICsgdmFsdWVTdHJpbmdMZW5ndGggPiB0aGlzLnF1b3RhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFFVT1RBX0VYQ0VFREVEX0VSUigpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlU3luYyhmaWxlbmFtZSwgdmFsdWVTdHJpbmcsIHtcbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWV4aXN0c0JlZm9yZVNldCkge1xuICAgICAgICAgIG1ldGFLZXkgPSBuZXcgTWV0YUtleShlbmNvZGVkS2V5LCAodGhpcy5fa2V5cy5wdXNoKGtleSkpIC0gMSk7XG4gICAgICAgICAgbWV0YUtleS5zaXplID0gdmFsdWVTdHJpbmdMZW5ndGg7XG4gICAgICAgICAgdGhpcy5fbWV0YUtleU1hcFtrZXldID0gbWV0YUtleTtcbiAgICAgICAgICB0aGlzLmxlbmd0aCArPSAxO1xuICAgICAgICAgIHRoaXMuX2J5dGVzSW5Vc2UgKz0gdmFsdWVTdHJpbmdMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0xpc3RlbmVycykge1xuICAgICAgICAgIGV2bnQgPSBuZXcgU3RvcmFnZUV2ZW50KGtleSwgb2xkVmFsdWUsIHZhbHVlLCB0aGlzLl9ldmVudFVybCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnc3RvcmFnZScsIGV2bnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHZhciBmaWxlbmFtZSwgbWV0YUtleTtcbiAgICAgICAga2V5ID0gX2VzY2FwZUtleShrZXkpO1xuICAgICAgICBtZXRhS2V5ID0gdGhpcy5fbWV0YUtleU1hcFtrZXldO1xuICAgICAgICBpZiAoISFtZXRhS2V5KSB7XG4gICAgICAgICAgZmlsZW5hbWUgPSBwYXRoLmpvaW4odGhpcy5fbG9jYXRpb24sIG1ldGFLZXkua2V5KTtcbiAgICAgICAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCAndXRmOCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9nZXRTdGF0KGtleSkge1xuICAgICAgICB2YXIgZmlsZW5hbWU7XG4gICAgICAgIGtleSA9IF9lc2NhcGVLZXkoa2V5KTtcbiAgICAgICAgZmlsZW5hbWUgPSBwYXRoLmpvaW4odGhpcy5fbG9jYXRpb24sIGVuY29kZVVSSUNvbXBvbmVudChrZXkpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZnMuc3RhdFN5bmMoZmlsZW5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIHZhciBldm50LCBmaWxlbmFtZSwgaGFzTGlzdGVuZXJzLCBrLCBtZXRhLCBtZXRhS2V5LCBvbGRWYWx1ZSwgcmVmLCB2O1xuICAgICAgICBrZXkgPSBfZXNjYXBlS2V5KGtleSk7XG4gICAgICAgIG1ldGFLZXkgPSB0aGlzLl9tZXRhS2V5TWFwW2tleV07XG4gICAgICAgIGlmICghIW1ldGFLZXkpIHtcbiAgICAgICAgICBoYXNMaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3N0b3JhZ2UnKTtcbiAgICAgICAgICBvbGRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgaWYgKGhhc0xpc3RlbmVycykge1xuICAgICAgICAgICAgb2xkVmFsdWUgPSB0aGlzLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX21ldGFLZXlNYXBba2V5XTtcbiAgICAgICAgICB0aGlzLmxlbmd0aCAtPSAxO1xuICAgICAgICAgIHRoaXMuX2J5dGVzSW5Vc2UgLT0gbWV0YUtleS5zaXplO1xuICAgICAgICAgIGZpbGVuYW1lID0gcGF0aC5qb2luKHRoaXMuX2xvY2F0aW9uLCBtZXRhS2V5LmtleSk7XG4gICAgICAgICAgdGhpcy5fa2V5cy5zcGxpY2UobWV0YUtleS5pbmRleCwgMSk7XG4gICAgICAgICAgcmVmID0gdGhpcy5fbWV0YUtleU1hcDtcbiAgICAgICAgICBmb3IgKGsgaW4gcmVmKSB7XG4gICAgICAgICAgICB2ID0gcmVmW2tdO1xuICAgICAgICAgICAgbWV0YSA9IHRoaXMuX21ldGFLZXlNYXBba107XG4gICAgICAgICAgICBpZiAobWV0YS5pbmRleCA+IG1ldGFLZXkuaW5kZXgpIHtcbiAgICAgICAgICAgICAgbWV0YS5pbmRleCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfcm0oZmlsZW5hbWUpO1xuICAgICAgICAgIGlmIChoYXNMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGV2bnQgPSBuZXcgU3RvcmFnZUV2ZW50KGtleSwgb2xkVmFsdWUsIG51bGwsIHRoaXMuX2V2ZW50VXJsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ3N0b3JhZ2UnLCBldm50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAga2V5KG4pIHtcbiAgICAgICAgdmFyIHJhd0tleTtcbiAgICAgICAgcmF3S2V5ID0gdGhpcy5fa2V5c1tuXTtcbiAgICAgICAgaWYgKHJhd0tleSA9PT0gS0VZX0ZPUl9FTVBUWV9TVFJJTkcpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJhd0tleTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbGVhcigpIHtcbiAgICAgICAgdmFyIGV2bnQ7XG4gICAgICAgIF9lbXB0eURpcmVjdG9yeSh0aGlzLl9sb2NhdGlvbik7XG4gICAgICAgIHRoaXMuX21ldGFLZXlNYXAgPSBjcmVhdGVNYXAoKTtcbiAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2J5dGVzSW5Vc2UgPSAwO1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdzdG9yYWdlJykpIHtcbiAgICAgICAgICBldm50ID0gbmV3IFN0b3JhZ2VFdmVudChudWxsLCBudWxsLCBudWxsLCB0aGlzLl9ldmVudFVybCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnc3RvcmFnZScsIGV2bnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9nZXRCeXRlc0luVXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZXNJblVzZTtcbiAgICAgIH1cblxuICAgICAgX2RlbGV0ZUxvY2F0aW9uKCkge1xuICAgICAgICBkZWxldGUgaW5zdGFuY2VNYXBbdGhpcy5fbG9jYXRpb25dO1xuICAgICAgICBfcm0odGhpcy5fbG9jYXRpb24pO1xuICAgICAgICB0aGlzLl9tZXRhS2V5TWFwID0ge307XG4gICAgICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZXNJblVzZSA9IDA7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgaW5zdGFuY2VNYXAgPSB7fTtcblxuICAgIHJldHVybiBMb2NhbFN0b3JhZ2U7XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxuICBKU09OU3RvcmFnZSA9IGNsYXNzIEpTT05TdG9yYWdlIGV4dGVuZHMgTG9jYWxTdG9yYWdlIHtcbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgIG5ld1ZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgcmV0dXJuIHN1cGVyLnNldEl0ZW0oa2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHN1cGVyLmdldEl0ZW0oa2V5KSk7XG4gICAgfVxuXG4gIH07XG5cbiAgZXhwb3J0cy5Mb2NhbFN0b3JhZ2UgPSBMb2NhbFN0b3JhZ2U7XG5cbiAgZXhwb3J0cy5KU09OU3RvcmFnZSA9IEpTT05TdG9yYWdlO1xuXG4gIGV4cG9ydHMuUVVPVEFfRVhDRUVERURfRVJSID0gUVVPVEFfRVhDRUVERURfRVJSO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCBoYXNGbGFnID0gcmVxdWlyZSgnaGFzLWZsYWcnKTtcblxuY29uc3Qge2Vudn0gPSBwcm9jZXNzO1xuXG5sZXQgZm9yY2VDb2xvcjtcbmlmIChoYXNGbGFnKCduby1jb2xvcicpIHx8XG5cdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9yPWZhbHNlJykgfHxcblx0aGFzRmxhZygnY29sb3I9bmV2ZXInKSkge1xuXHRmb3JjZUNvbG9yID0gMDtcbn0gZWxzZSBpZiAoaGFzRmxhZygnY29sb3InKSB8fFxuXHRoYXNGbGFnKCdjb2xvcnMnKSB8fFxuXHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0aGFzRmxhZygnY29sb3I9YWx3YXlzJykpIHtcblx0Zm9yY2VDb2xvciA9IDE7XG59XG5cbmlmICgnRk9SQ0VfQ09MT1InIGluIGVudikge1xuXHRpZiAoZW52LkZPUkNFX0NPTE9SID09PSAndHJ1ZScpIHtcblx0XHRmb3JjZUNvbG9yID0gMTtcblx0fSBlbHNlIGlmIChlbnYuRk9SQ0VfQ09MT1IgPT09ICdmYWxzZScpIHtcblx0XHRmb3JjZUNvbG9yID0gMDtcblx0fSBlbHNlIHtcblx0XHRmb3JjZUNvbG9yID0gZW52LkZPUkNFX0NPTE9SLmxlbmd0aCA9PT0gMCA/IDEgOiBNYXRoLm1pbihwYXJzZUludChlbnYuRk9SQ0VfQ09MT1IsIDEwKSwgMyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlTGV2ZWwobGV2ZWwpIHtcblx0aWYgKGxldmVsID09PSAwKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRsZXZlbCxcblx0XHRoYXNCYXNpYzogdHJ1ZSxcblx0XHRoYXMyNTY6IGxldmVsID49IDIsXG5cdFx0aGFzMTZtOiBsZXZlbCA+PSAzXG5cdH07XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ29sb3IoaGF2ZVN0cmVhbSwgc3RyZWFtSXNUVFkpIHtcblx0aWYgKGZvcmNlQ29sb3IgPT09IDApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0xNm0nKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWZ1bGwnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWVjb2xvcicpKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnY29sb3I9MjU2JykpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGlmIChoYXZlU3RyZWFtICYmICFzdHJlYW1Jc1RUWSAmJiBmb3JjZUNvbG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGNvbnN0IG1pbiA9IGZvcmNlQ29sb3IgfHwgMDtcblxuXHRpZiAoZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiBtaW47XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdC8vIFdpbmRvd3MgMTAgYnVpbGQgMTA1ODYgaXMgdGhlIGZpcnN0IFdpbmRvd3MgcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDI1NiBjb2xvcnMuXG5cdFx0Ly8gV2luZG93cyAxMCBidWlsZCAxNDkzMSBpcyB0aGUgZmlyc3QgcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDE2bS9UcnVlQ29sb3IuXG5cdFx0Y29uc3Qgb3NSZWxlYXNlID0gb3MucmVsZWFzZSgpLnNwbGl0KCcuJyk7XG5cdFx0aWYgKFxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVswXSkgPj0gMTAgJiZcblx0XHRcdE51bWJlcihvc1JlbGVhc2VbMl0pID49IDEwNTg2XG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gTnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTQ5MzEgPyAzIDogMjtcblx0XHR9XG5cblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ0knIGluIGVudikge1xuXHRcdGlmIChbJ1RSQVZJUycsICdDSVJDTEVDSScsICdBUFBWRVlPUicsICdHSVRMQUJfQ0knLCAnR0lUSFVCX0FDVElPTlMnLCAnQlVJTERLSVRFJ10uc29tZShzaWduID0+IHNpZ24gaW4gZW52KSB8fCBlbnYuQ0lfTkFNRSA9PT0gJ2NvZGVzaGlwJykge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1pbjtcblx0fVxuXG5cdGlmICgnVEVBTUNJVFlfVkVSU0lPTicgaW4gZW52KSB7XG5cdFx0cmV0dXJuIC9eKDlcXC4oMCpbMS05XVxcZCopXFwufFxcZHsyLH1cXC4pLy50ZXN0KGVudi5URUFNQ0lUWV9WRVJTSU9OKSA/IDEgOiAwO1xuXHR9XG5cblx0aWYgKGVudi5DT0xPUlRFUk0gPT09ICd0cnVlY29sb3InKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoJ1RFUk1fUFJPR1JBTScgaW4gZW52KSB7XG5cdFx0Y29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KChlbnYuVEVSTV9QUk9HUkFNX1ZFUlNJT04gfHwgJycpLnNwbGl0KCcuJylbMF0sIDEwKTtcblxuXHRcdHN3aXRjaCAoZW52LlRFUk1fUFJPR1JBTSkge1xuXHRcdFx0Y2FzZSAnaVRlcm0uYXBwJzpcblx0XHRcdFx0cmV0dXJuIHZlcnNpb24gPj0gMyA/IDMgOiAyO1xuXHRcdFx0Y2FzZSAnQXBwbGVfVGVybWluYWwnOlxuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdC8vIE5vIGRlZmF1bHRcblx0XHR9XG5cdH1cblxuXHRpZiAoLy0yNTYoY29sb3IpPyQvaS50ZXN0KGVudi5URVJNKSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0aWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8XnZ0MjIwfF5yeHZ0fGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChlbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ09MT1JURVJNJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdHJldHVybiBtaW47XG59XG5cbmZ1bmN0aW9uIGdldFN1cHBvcnRMZXZlbChzdHJlYW0pIHtcblx0Y29uc3QgbGV2ZWwgPSBzdXBwb3J0c0NvbG9yKHN0cmVhbSwgc3RyZWFtICYmIHN0cmVhbS5pc1RUWSk7XG5cdHJldHVybiB0cmFuc2xhdGVMZXZlbChsZXZlbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzdXBwb3J0c0NvbG9yOiBnZXRTdXBwb3J0TGV2ZWwsXG5cdHN0ZG91dDogdHJhbnNsYXRlTGV2ZWwoc3VwcG9ydHNDb2xvcih0cnVlLCB0dHkuaXNhdHR5KDEpKSksXG5cdHN0ZGVycjogdHJhbnNsYXRlTGV2ZWwoc3VwcG9ydHNDb2xvcih0cnVlLCB0dHkuaXNhdHR5KDIpKSlcbn07XG4iLCIvKipcbiAqIE1vZHVsZSB0byBzZXQgdXAgZ2xvYmFsVGhpcyBhbmQgcG9seWZpbGxzIGluIG1haW5cbiAqXG4gKiBUT0RPOiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIG5vcm1hbCBleHBvcnRpbmcgbW9kdWxlIHNvIGl0J3Mgbm90IHVzaW5nIGdsb2JhbFRoaXMgYW5kIHVzaW5nXG4gKiBOb3JtYWxNb2R1bGVSZXBsYWNlbWVudFBsdWdpbiB0byBtYWtlIHN1cmUgdGhlIHJpZ2h0IG9uZSBnZXRzIGltcG9ydGVkIHBlciBwcm9jZXNzLiBJZGVhIGZyb21cbiAqIEJlcmdpIGF0IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82OTk4MjEyMSBTZWVcbiAqIGh0dHBzOi8vd2VicGFjay5qcy5vcmcvcGx1Z2lucy9ub3JtYWwtbW9kdWxlLXJlcGxhY2VtZW50LXBsdWdpbi9cbiAqL1xuXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHBvbHlmaWxsTG9jYWxTdG9yYWdlIH0gZnJvbSAnQG5vZGUvcG9seWZpbGxzL2xvY2FsLXN0b3JhZ2UucG9seWZpbGwnO1xuaW1wb3J0IHsgUHJvY2Vzc1R5cGUgfSBmcm9tICdAc2hhcmVkL2dsb2JhbC10aGlzLm1vZGVsJztcbmltcG9ydCB7IGFwcCB9IGZyb20gJ2VsZWN0cm9uJztcbmltcG9ydCB7IGdldENvbW1hbmRMaW5lQXJndW1lbnQsIENPTU1BTkRfTElORV9BUkdTIH0gZnJvbSAnQG5vZGUvdXRpbHMvY29tbWFuZC1saW5lLnV0aWwnO1xuaW1wb3J0IHsgTG9nTGV2ZWwgfSBmcm9tICdlbGVjdHJvbi1sb2cnO1xuaW1wb3J0IHsgaXNOb2lzeURldk1vZGVFbnZWYXJpYWJsZVNldCB9IGZyb20gJ0Bub2RlL3V0aWxzL3V0aWwnO1xuXG4vLyAjcmVnaW9uIGdsb2JhbFRoaXMgc2V0dXBcblxuZ2xvYmFsVGhpcy5wcm9jZXNzVHlwZSA9IFByb2Nlc3NUeXBlLk1haW47XG5nbG9iYWxUaGlzLmlzUGFja2FnZWQgPSBhcHAuaXNQYWNrYWdlZDtcbmdsb2JhbFRoaXMucmVzb3VyY2VzUGF0aCA9IGFwcC5pc1BhY2thZ2VkID8gcHJvY2Vzcy5yZXNvdXJjZXNQYXRoIDogcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uLy4uLycpO1xuZ2xvYmFsVGhpcy5sb2dMZXZlbCA9XG4gIC8vIEFzc2VydCB0aGUgZXh0cmFjdGVkIHR5cGUuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICAoZ2V0Q29tbWFuZExpbmVBcmd1bWVudChDT01NQU5EX0xJTkVfQVJHUy5Mb2dMZXZlbCkgYXMgTG9nTGV2ZWwpID8/XG4gIChnbG9iYWxUaGlzLmlzUGFja2FnZWQgPyAnaW5mbycgOiAnZGVidWcnKTtcbmdsb2JhbFRoaXMuaXNOb2lzeURldk1vZGVFbmFibGVkID0gaXNOb2lzeURldk1vZGVFbnZWYXJpYWJsZVNldCgpO1xuXG4vLyAjZW5kcmVnaW9uXG5cbi8vICNyZWdpb24gcG9seWZpbGxzXG5cbnBvbHlmaWxsTG9jYWxTdG9yYWdlKCk7XG5cbi8vICNlbmRyZWdpb25cbiIsIi8qKlxuICogVGhpcyBtb2R1bGUgZXhlY3V0ZXMgaW5zaWRlIG9mIGVsZWN0cm9uJ3MgbWFpbiBwcm9jZXNzLiBZb3UgY2FuIHN0YXJ0IGVsZWN0cm9uIHJlbmRlcmVyIHByb2Nlc3NcbiAqIGZyb20gaGVyZSBhbmQgY29tbXVuaWNhdGUgd2l0aCB0aGUgb3RoZXIgcHJvY2Vzc2VzIHRocm91Z2ggSVBDLlxuICpcbiAqIFdoZW4gcnVubmluZyBgbnBtIHJ1biBidWlsZGAgb3IgYG5wbSBydW4gYnVpbGQ6bWFpbmAsIHRoaXMgZmlsZSBpcyBjb21waWxlZCB0byBgLi9zcmMvbWFpbi5qc2BcbiAqIHVzaW5nIHdlYnBhY2suIFRoaXMgZ2l2ZXMgdXMgc29tZSBwZXJmb3JtYW5jZSB3aW5zLlxuICovXG5cbmltcG9ydCBvcyBmcm9tICdvcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGFwcCwgQnJvd3NlcldpbmRvdywgc2hlbGwsIGlwY01haW4sIFJlbmRlclByb2Nlc3NHb25lRGV0YWlscyB9IGZyb20gJ2VsZWN0cm9uJztcbi8vIFJlbW92ZWQgdW50aWwgd2UgaGF2ZSBhIHJlbGVhc2UuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGFyYW5leHQvcGFyYW5leHQtY29yZS9pc3N1ZXMvODNcbi8qIGltcG9ydCB7IGF1dG9VcGRhdGVyIH0gZnJvbSAnZWxlY3Ryb24tdXBkYXRlcic7ICovXG5pbXBvcnQgd2luZG93U3RhdGVLZWVwZXIgZnJvbSAnZWxlY3Ryb24td2luZG93LXN0YXRlJztcbmltcG9ydCAnQG1haW4vZ2xvYmFsLXRoaXMubW9kZWwnO1xuaW1wb3J0IHsgZG90bmV0RGF0YVByb3ZpZGVyIH0gZnJvbSAnQG1haW4vc2VydmljZXMvZG90bmV0LWRhdGEtcHJvdmlkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL2xvZ2dlci5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIG5ldHdvcmtTZXJ2aWNlIGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbmV0d29yay5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIGNvbW1hbmRTZXJ2aWNlIGZyb20gJ0BzaGFyZWQvc2VydmljZXMvY29tbWFuZC5zZXJ2aWNlJztcbmltcG9ydCB7IHJlc29sdmVIdG1sUGF0aCB9IGZyb20gJ0Bub2RlL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHsgZXh0ZW5zaW9uSG9zdFNlcnZpY2UgfSBmcm9tICdAbWFpbi9zZXJ2aWNlcy9leHRlbnNpb24taG9zdC5zZXJ2aWNlJztcbmltcG9ydCB7IG5ldHdvcmtPYmplY3RTZXJ2aWNlIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9uZXR3b3JrLW9iamVjdC5zZXJ2aWNlJztcbmltcG9ydCB7IGV4dGVuc2lvbkFzc2V0UHJvdG9jb2xTZXJ2aWNlIH0gZnJvbSAnQG1haW4vc2VydmljZXMvZXh0ZW5zaW9uLWFzc2V0LXByb3RvY29sLnNlcnZpY2UnO1xuaW1wb3J0IHsgd2FpdCwgc2VyaWFsaXplLCBnZXRFcnJvck1lc3NhZ2UgfSBmcm9tICdwbGF0Zm9ybS1iaWJsZS11dGlscyc7XG5pbXBvcnQgeyBDb21tYW5kTmFtZXMgfSBmcm9tICdwYXBpLXNoYXJlZC10eXBlcyc7XG5pbXBvcnQgeyBTZXJpYWxpemVkUmVxdWVzdFR5cGUgfSBmcm9tICdAc2hhcmVkL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9wcm9qZWN0LWRhdGEtcHJvdmlkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBzdGFydE5ldHdvcmtPYmplY3RTdGF0dXNTZXJ2aWNlIH0gZnJvbSAnQG1haW4vc2VydmljZXMvbmV0d29yay1vYmplY3Qtc3RhdHVzLnNlcnZpY2UtaG9zdCc7XG5pbXBvcnQgeyBERVZfTU9ERV9SRU5ERVJFUl9JTkRJQ0FUT1IgfSBmcm9tICdAc2hhcmVkL2RhdGEvcGxhdGZvcm0uZGF0YSc7XG5pbXBvcnQgeyBzdGFydFByb2plY3RMb29rdXBTZXJ2aWNlIH0gZnJvbSAnQG1haW4vc2VydmljZXMvcHJvamVjdC1sb29rdXAuc2VydmljZS1ob3N0JztcbmltcG9ydCB7IFBST0pFQ1RfSU5URVJGQUNFX1BMQVRGT1JNX0JBU0UgfSBmcm9tICdAc2hhcmVkL21vZGVscy9wcm9qZWN0LWRhdGEtcHJvdmlkZXIubW9kZWwnO1xuaW1wb3J0IHsgR0VUX01FVEhPRFMgfSBmcm9tICdAc2hhcmVkL2RhdGEvcnBjLm1vZGVsJztcbmltcG9ydCB7IEhBTkRMRV9VUklfUkVRVUVTVF9UWVBFIH0gZnJvbSAnQG5vZGUvc2VydmljZXMvZXh0ZW5zaW9uLnNlcnZpY2UtbW9kZWwnO1xuaW1wb3J0IHsgc3RhcnREYXRhUHJvdGVjdGlvblNlcnZpY2UgfSBmcm9tICdAbWFpbi9zZXJ2aWNlcy9kYXRhLXByb3RlY3Rpb24uc2VydmljZS1ob3N0JztcbmltcG9ydCB7IHN1YnNjcmliZUN1cnJlbnRNYWNvc01lbnViYXIgfSBmcm9tICdAbWFpbi9wbGF0Zm9ybS1tYWNvcy1tZW51YmFyLnV0aWwnO1xuaW1wb3J0IHtcbiAgQVBQX05BTUUsXG4gIEFQUF9VUklfU0NIRU1FLFxuICBBUFBfVkVSU0lPTixcbiAgc3RhcnRBcHBTZXJ2aWNlLFxufSBmcm9tICdAbWFpbi9zZXJ2aWNlcy9hcHAuc2VydmljZS1ob3N0JztcbmltcG9ydCB7IHNldHRpbmdzU2VydmljZSB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvc2V0dGluZ3Muc2VydmljZSc7XG5cbi8vICNyZWdpb24gUHJldmVudCBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgdGhlIGFwcC4gVGhpcyBuZWVkcyB0byBzdGF5IGF0IHRoZSB0b3Agb2YgdGhlIGFwcCFcblxuLy8gUHJldmVudCBtdWx0aXBsZSBpbnN0YW5jZXMgYmVjYXVzZSBhbiBpbnN0YW5jZSBsYXVuY2hlZCBhZnRlciB0aGUgZmlyc3QgaXMgbGlrZWx5IGEgVVJMIHJlZGlyZWN0XG4vLyB0byBvdXIgcHJvdG9jb2wgY2xpZW50LiBXZSBoYW5kbGUgVVJJIHJlZGlyZWN0cyBiZWxvdyBpbiBgc2Vjb25kLWluc3RhbmNlYFxuXG4vKiogV2hldGhlciB0aGlzIGlzIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiB0aGlzIGFwcGxpY2F0aW9uLiAqL1xuY29uc3QgaXNGaXJzdEluc3RhbmNlID0gYXBwLnJlcXVlc3RTaW5nbGVJbnN0YW5jZUxvY2soKTtcblxuaWYgKCFpc0ZpcnN0SW5zdGFuY2UpIHtcbiAgbG9nZ2VyLmluZm8oXG4gICAgYEFwcGxpY2F0aW9uIGxhdW5jaGVkIGJ1dCBub3QgZmlyc3QgaW5zdGFuY2UuIEV4aXRpbmcuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhlIGFwcGxpY2F0aW9uIGp1c3QgaGFuZGxlZCBhIFVSTC4gcHJvY2Vzcy5hcmd2OiAke3Byb2Nlc3MuYXJndn1gLFxuICApO1xuICBhcHAuZXhpdCgpO1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbmNvbnN0IFBST0NFU1NfQ0xPU0VfVElNRV9PVVQgPSAyMDAwO1xuLyoqXG4gKiBJZiB0aGlzIGlzIGB0cnVlYCwgd2Ugd2lsbCByZXN0YXJ0IHNvb24uIE5vdCBqdXN0IHVzaW5nIGBpc0Nsb3NpbmdgIGJlY2F1c2Ugd2UgbmVlZCB0byBtYWtlIHN1cmVcbiAqIHdlIG9ubHkgcnVuIGByZWxhdW5jaGAgb25jZSB3aGljaCBoYXMgYSBzbGlnaHRseSBkaWZmZXJlbnQgdXNlIGNhc2UgdGhhbiBgaXNDbG9zaW5nYFxuICovXG5sZXQgd2lsbFJlc3RhcnQgPSBmYWxzZTtcblxuLy8gQWRkIHVuaGFuZGxlZCBleGNlcHRpb24gYW5kIHJlamVjdGlvbiBoYW5kbGVyc1xucHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCAoZXJyb3IpID0+IHtcbiAgbG9nZ2VyLmVycm9yKGBVbmhhbmRsZWQgZXhjZXB0aW9uIGluIG1haW4gcHJvY2VzczogJHtnZXRFcnJvck1lc3NhZ2UoZXJyb3IpfWApO1xufSk7XG5cbnByb2Nlc3Mub24oJ3VuaGFuZGxlZFJlamVjdGlvbicsIChyZWFzb24pID0+IHtcbiAgbG9nZ2VyLmVycm9yKGBVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24gaW4gbWFpbiBwcm9jZXNzLCByZWFzb246ICR7Z2V0RXJyb3JNZXNzYWdlKHJlYXNvbil9YCk7XG59KTtcblxuLyoqXG4gKiBPcGVuIGEgbGluayBpbiB0aGUgYnJvd3NlciBmb2xsb3dpbmcgdGhlIHJlc3RyaWN0aW9ucyB3ZSBwdXQgaW4gcGxhY2UgaW4gUGxhdGZvcm0uQmlibGVcbiAqXG4gKiBNYWtlIHN1cmUgbm90IHRvIGFsbG93IGp1c3QgYW55IGxpbmsuIFNlZVxuICogaHR0cHM6Ly9iZW5qYW1pbi1hbHRwZXRlci5kZS9zaGVsbC1vcGVuZXh0ZXJuYWwtZGFuZ2Vycy9cbiAqL1xuYXN5bmMgZnVuY3Rpb24gb3BlbkV4dGVybmFsKHVybDogc3RyaW5nKSB7XG4gIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykgJiYgIXVybC5zdGFydHNXaXRoKGAke0FQUF9VUklfU0NIRU1FfTovL2ApKVxuICAgIHRocm93IG5ldyBFcnJvcihgRXh0ZXJuYWwgVVJMIG11c3Qgc3RhcnQgd2l0aCAnaHR0cHM6Ly8nIG9yICcke0FQUF9VUklfU0NIRU1FfTovLzogJHt1cmx9YCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgc2hlbGwub3BlbkV4dGVybmFsKHVybCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXIud2FybihnZXRFcnJvck1lc3NhZ2UoZSkpO1xuICAgIHRocm93IGU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbWFpbigpIHtcbiAgLy8gVGhlIG5ldHdvcmsgc2VydmljZSByZWxpZXMgb24gbm90aGluZyBlbHNlLCBhbmQgb3RoZXIgdGhpbmdzIHJlbHkgb24gaXQsIHNvIHN0YXJ0IGl0IGZpcnN0XG4gIGF3YWl0IG5ldHdvcmtTZXJ2aWNlLmluaXRpYWxpemUoKTtcblxuICAvLyBUaGUgbmV0d29yayBvYmplY3Qgc3RhdHVzIHNlcnZpY2UgcmVsaWVzIG9uIHNlZWluZyBldmVyeXRoaW5nIGVsc2Ugc3RhcnQgdXAgbGF0ZXJcbiAgYXdhaXQgc3RhcnROZXR3b3JrT2JqZWN0U3RhdHVzU2VydmljZSgpO1xuXG4gIC8vIFRoZSBwcm9qZWN0IGxvb2t1cCBzZXJ2aWNlIHJlbGllcyBvbiB0aGUgbmV0d29yayBvYmplY3Qgc3RhdHVzIHNlcnZpY2VcbiAgYXdhaXQgc3RhcnRQcm9qZWN0TG9va3VwU2VydmljZSgpO1xuXG4gIC8vIFRoZSAuTkVUIGRhdGEgcHJvdmlkZXIgcmVsaWVzIG9uIHRoZSBuZXR3b3JrIHNlcnZpY2UgYW5kIG5vdGhpbmcgZWxzZVxuICBkb3RuZXREYXRhUHJvdmlkZXIuc3RhcnQoKTtcblxuICAvLyBUT0RPIChtYXliZSk6IFdhaXQgZm9yIHNpZ25hbCBmcm9tIHRoZSAuTkVUIGRhdGEgcHJvdmlkZXIgcHJvY2VzcyB0aGF0IGl0IGlzIHJlYWR5XG5cbiAgLy8gTmVlZCB0byBzdGFydCB0aGUgZGF0YSBwcm90ZWN0aW9uIHNlcnZpY2UgYmVmb3JlIHN0YXJ0aW5nIHRoZSBleHRlbnNpb24gaG9zdCBiZWNhdXNlIGV4dGVuc2lvbnNcbiAgLy8gdXNlIGl0XG4gIGF3YWl0IHN0YXJ0RGF0YVByb3RlY3Rpb25TZXJ2aWNlKCk7XG5cbiAgLy8gTmVlZCB0byBzdGFydCB0aGUgYXBwIHNlcnZpY2UgYmVmb3JlIHN0YXJ0aW5nIHRoZSBleHRlbnNpb24gaG9zdCBiZWNhdXNlIGV4dGVuc2lvbnMgdXNlIGl0XG4gIGF3YWl0IHN0YXJ0QXBwU2VydmljZSgpO1xuXG4gIC8vIFRoZSBleHRlbnNpb24gaG9zdCBzZXJ2aWNlIHJlbGllcyBvbiB0aGUgbmV0d29yayBzZXJ2aWNlLlxuICAvLyBFeHRlbnNpb25zIGluc2lkZSB0aGUgZXh0ZW5zaW9uIGhvc3QgbWlnaHQgcmVseSBvbiB0aGUgLk5FVCBkYXRhIHByb3ZpZGVyIGFuZCBlYWNoIG90aGVyXG4gIC8vIFNvbWUgZXh0ZW5zaW9ucyBpbnNpZGUgdGhlIGV4dGVuc2lvbiBob3N0IHJlbHkgb24gdGhlIHJlbmRlcmVyIHRvIGFjY2VwdCAnZ2V0V2ViVmlldycgY29tbWFuZHMuXG4gIC8vIFRoZSByZW5kZXJlciByZWxpZXMgb24gdGhlIGV4dGVuc2lvbiBob3N0LCBzbyBzb21ldGhpbmcgaGFzIHRvIGJyZWFrIHRoZSBkZXBlbmRlbmN5IGxvb3AuXG4gIC8vIEZvciBub3csIHRoZSBkZXBlbmRlbmN5IGxvb3AgaXMgYnJva2VuIGJ5IHJldHJ5aW5nICdnZXRXZWJWaWV3JyBpbiBhIGxvb3AgZm9yIGEgd2hpbGUuXG4gIGF3YWl0IGV4dGVuc2lvbkhvc3RTZXJ2aWNlLnN0YXJ0KCk7XG5cbiAgLy8gVE9ETyAobWF5YmUpOiBXYWl0IGZvciBzaWduYWwgZnJvbSB0aGUgZXh0ZW5zaW9uIGhvc3QgcHJvY2VzcyB0aGF0IGl0IGlzIHJlYWR5IChleGNlcHQgJ2dldFdlYlZpZXcnKVxuICAvLyBXZSBjb3VsZCB0aGVuIHdhaXQgZm9yIHRoZSByZW5kZXJlciB0byBiZSByZWFkeSBhbmQgc2lnbmFsIHRoZSBleHRlbnNpb24gaG9zdFxuXG4gIC8vIEtlZXAgYSBnbG9iYWwgcmVmZXJlbmNlIG9mIHRoZSB3aW5kb3cgb2JqZWN0LiBJZiB5b3UgZG9uJ3QsIHRoZSB3aW5kb3cgd2lsbFxuICAvLyBiZSBjbG9zZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBKYXZhU2NyaXB0IG9iamVjdCBpcyBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgbGV0IG1haW5XaW5kb3c6IEJyb3dzZXJXaW5kb3cgfCB1bmRlZmluZWQ7XG5cbiAgLy8gI3JlZ2lvbiBTZXQgdXAgdGhlIHByb3RvY29sIGNsaWVudCB0byByZWNlaXZlIG5hdmlnYXRpb24gdG8gdGhpcyBhcHAncyBVUkkgc2NoZW1lXG5cbiAgLy8gTGF1bmNoIHRoZSBwb3J0YWJsZSBhcHAgaWYgd2UncmUgaW4gaXQ7IG90aGVyd2lzZSB1c2UgdGhlIG5vcm1hbCBwYXRoXG4gIGNvbnN0IGxhdW5jaFBhdGggPSBwcm9jZXNzLmVudi5QT1JUQUJMRV9FWEVDVVRBQkxFX0ZJTEUgfHwgcHJvY2Vzcy5leGVjUGF0aDtcbiAgY29uc3QgYXJncyA9IHByb2Nlc3MuYXJndi5zbGljZSgxKTtcblxuICBmdW5jdGlvbiBoYW5kbGVVcmkodXJpOiBzdHJpbmcpIHtcbiAgICBpZiAobWFpbldpbmRvdykge1xuICAgICAgaWYgKG1haW5XaW5kb3cuaXNNaW5pbWl6ZWQoKSkgbWFpbldpbmRvdy5yZXN0b3JlKCk7XG4gICAgICBtYWluV2luZG93LmZvY3VzKCk7XG4gICAgfVxuICAgIGxvZ2dlci5kZWJ1ZyhgTWFpbiBpcyBoYW5kbGluZyB1cmkgJHt1cml9YCk7XG4gICAgLy8gbmVlZCB0byB1c2UgYG5ldyBVUkxgIGluc3RlYWQgb2YgYFVSTC5wYXJzZWAgYmVjYXVzZSBOb2RlPDIyLjEuMCBkb2Vzbid0IGhhdmUgaXQuIENhbiBjaGFuZ2VcbiAgICAvLyB3aGVuIHdlIGdldCB0aGVyZVxuICAgIGxldCB1cmw6IFVSTDtcbiAgICB0cnkge1xuICAgICAgdXJsID0gbmV3IFVSTCh1cmkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYE1haW4gcmVjZWl2ZWQgdXJpICR7dXJpfSBidXQgY291bGQgbm90IHBhcnNlIGl0LiBJZiB0aGlzIGRvZXMgbm90IGxvb2sgbGlrZSBhIHVyaSwgdGhhdCBwcm9iYWJseSBtZWFucyB0aGUgdXNlciB0cmllZCB0byBvcGVuIHRoZSBhcHBsaWNhdGlvbiBhZ2Fpbi4gVGhpcyBpcyBsaWtlbHkgbm90IGEgcHJvYmxlbS4gJHtlfWAsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodXJsLnByb3RvY29sICE9PSBgJHtBUFBfVVJJX1NDSEVNRX06YCkge1xuICAgICAgbG9nZ2VyLndhcm4oYE1haW4gcmVjZWl2ZWQgdXJpICR7dXJpfSBidXQgcHJvdG9jb2wgZG9lcyBub3QgbWF0Y2ggJHtBUFBfVVJJX1NDSEVNRX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbmV0d29ya1NlcnZpY2UucmVxdWVzdChIQU5ETEVfVVJJX1JFUVVFU1RfVFlQRSwgdXJpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYE1haW4gc2VudCByZXF1ZXN0IGZvciBleHRlbnNpb24gc2VydmljZSB0byBoYW5kbGUgdXJpICR7dXJpfSwgYnV0IGl0IHRocmV3LiAke2V9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG4gIC8vIFJlc29sdmUgdGhlIHBhdGggdG8gdGhpcyBmaWxlIGlmIHdlJ3JlIHJ1bm5pbmcgdGhlIGVsZWN0cm9uIGFwcCBpdHNlbGYgYW5kIHBhc3NpbmcgaW4gdGhpcyBmaWxlXG4gIC8vIE5vdGUgdGhhdCB0aGlzIGNvbmRpdGlvbiAoYHByb2Nlc3MuZGVmYXVsdEFwcGApIGlzIG5vdCBxdWl0ZSB0aGUgc2FtZSBhcyB3aGV0aGVyIHdlJ3JlXG4gIC8vIHBhY2thZ2VkLCBzbyB3ZSdyZSBub3QgdXNpbmcgYGdsb2JhbFRoaXMuaXNQYWNrYWdlZGAgaGVyZS5cbiAgaWYgKHByb2Nlc3MuZGVmYXVsdEFwcCAmJiBhcmdzLmxlbmd0aCA+IDIpIGFyZ3NbMl0gPSBwYXRoLnJlc29sdmUoYXJnc1syXSk7XG4gIGFwcC5zZXRBc0RlZmF1bHRQcm90b2NvbENsaWVudChBUFBfVVJJX1NDSEVNRSwgbGF1bmNoUGF0aCwgYXJncyk7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgIC8vIFVzZSBPU1gncyBldmVudCB0byBoYW5kbGUgbmF2aWdhdGlvblxuICAgIGFwcC5vbignb3Blbi11cmwnLCAoX2V2ZW50LCB1cmwpID0+IGhhbmRsZVVyaSh1cmwpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBOb24tT1NYIGF0dGVtcHRzIHRvIGxhdW5jaCBhIHNlY29uZCBpbnN0YW5jZSB0byBoYW5kbGUgbmF2aWdhdGlvbjsgZGV0ZWN0IGFuZCBoYW5kbGVcbiAgICAvLyBhY2NvcmRpbmdseVxuICAgIGFwcC5vbignc2Vjb25kLWluc3RhbmNlJywgKF9ldmVudCwgY29tbWFuZExpbmUpID0+IHtcbiAgICAgIC8vIEhhbmRsZSB0aGUgVVJMXG4gICAgICBjb25zdCB1cmkgPSBjb21tYW5kTGluZVtjb21tYW5kTGluZS5sZW5ndGggLSAxXTtcbiAgICAgIGhhbmRsZVVyaSh1cmkpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gU3RhcnQgdGhlIHJlbmRlcmVyXG5cbiAgLy8gUmVtb3ZlZCB1bnRpbCB3ZSBoYXZlIGEgcmVsZWFzZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXJhbmV4dC9wYXJhbmV4dC1jb3JlL2lzc3Vlcy84M1xuICAvKiBjbGFzcyBBcHBVcGRhdGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgYXV0b1VwZGF0ZXIubG9nZ2VyID0gbG9nZ2VyO1xuICAgIGF1dG9VcGRhdGVyLmNoZWNrRm9yVXBkYXRlc0FuZE5vdGlmeSgpO1xuICB9XG59ICovXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBzb3VyY2VNYXBTdXBwb3J0ID0gYXdhaXQgaW1wb3J0KCdzb3VyY2UtbWFwLXN1cHBvcnQnKTtcbiAgICBzb3VyY2VNYXBTdXBwb3J0Lmluc3RhbGwoKTtcbiAgfVxuXG4gIGNvbnN0IGlzRGVidWcgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyB8fCBwcm9jZXNzLmVudi5ERUJVR19QUk9EID09PSAndHJ1ZSc7XG5cbiAgaWYgKGlzRGVidWcpIHtcbiAgICBjb25zdCBlbGVjdHJvbkRlYnVnID0gYXdhaXQgaW1wb3J0KCdlbGVjdHJvbi1kZWJ1ZycpO1xuICAgIGVsZWN0cm9uRGVidWcuZGVmYXVsdCgpO1xuICB9XG5cbiAgLyoqIEluc3RhbGwgZXh0ZW5zaW9ucyBpbnRvIHRoZSBDaHJvbWl1bSByZW5kZXJlciBwcm9jZXNzICovXG4gIGFzeW5jIGZ1bmN0aW9uIGluc3RhbGxFeHRlbnNpb25zKCkge1xuICAgIGNvbnN0IGluc3RhbGxlciA9IGF3YWl0IGltcG9ydCgnZWxlY3Ryb24tZGV2dG9vbHMtaW5zdGFsbGVyJyk7XG4gICAgY29uc3QgZm9yY2VEb3dubG9hZCA9ICEhcHJvY2Vzcy5lbnYuVVBHUkFERV9FWFRFTlNJT05TO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBbaW5zdGFsbGVyLlJFQUNUX0RFVkVMT1BFUl9UT09MU107XG4gICAgcmV0dXJuIGluc3RhbGxlci5kZWZhdWx0KGV4dGVuc2lvbnMsIGZvcmNlRG93bmxvYWQpLmNhdGNoKGxvZ2dlci5pbmZvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFzc2V0UGF0aCguLi5wYXRoczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIHJldHVybiBwYXRoLmpvaW4oZ2xvYmFsVGhpcy5yZXNvdXJjZXNQYXRoLCAnYXNzZXRzJywgLi4ucGF0aHMpO1xuICB9XG5cbiAgLyoqIFNldHMgdXAgdGhlIGVsZWN0cm9uIEJyb3dzZXJXaW5kb3cgcmVuZGVyZXIgcHJvY2VzcyAqL1xuICBjb25zdCBjcmVhdGVXaW5kb3cgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzRGVidWcpIHtcbiAgICAgIGF3YWl0IGluc3RhbGxFeHRlbnNpb25zKCk7XG4gICAgfVxuXG4gICAgLy8gTG9hZCB0aGUgcHJldmlvdXMgc3RhdGUgd2l0aCBmYWxsYmFjayB0byBkZWZhdWx0c1xuICAgIGNvbnN0IG1haW5XaW5kb3dTdGF0ZSA9IHdpbmRvd1N0YXRlS2VlcGVyKHtcbiAgICAgIGRlZmF1bHRXaWR0aDogMTAyNCxcbiAgICAgIGRlZmF1bHRIZWlnaHQ6IDcyOCxcbiAgICB9KTtcblxuICAgIG1haW5XaW5kb3cgPSBuZXcgQnJvd3NlcldpbmRvdyh7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgeDogbWFpbldpbmRvd1N0YXRlLngsXG4gICAgICB5OiBtYWluV2luZG93U3RhdGUueSxcbiAgICAgIHdpZHRoOiBtYWluV2luZG93U3RhdGUud2lkdGgsXG4gICAgICBoZWlnaHQ6IG1haW5XaW5kb3dTdGF0ZS5oZWlnaHQsXG4gICAgICBtaW5XaWR0aDogODAwLCAvLyBUT0RPOiBSZW1vdmUgdGhpcyB0ZW1wb3JhcnkgZW5mb3JjZW1lbnQgd2hlbiBodHRwczovL3BhcmF0ZXh0c3R1ZGlvLmF0bGFzc2lhbi5uZXQvYnJvd3NlL1BULTIzMzMgaXMgaW1wbGVtZW50ZWRcbiAgICAgIGljb246IGdldEFzc2V0UGF0aCgnaWNvbi5wbmcnKSxcbiAgICAgIC8vIFRPRE86IFJlLWNoZWNrIGxpbnV4IHN1cHBvcnQgd2l0aCBFbGVjdHJvbiAzNCwgc2VlIGh0dHBzOi8vZGlzY29yZC5jb20vY2hhbm5lbHMvMTA2NDkzODM2NDU5NzQzNjQxNi8xMzQ0MzI5MTY2Nzg2NTI3MjMyXG4gICAgICAuLi4ocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ2xpbnV4JyA/IHsgdGl0bGVCYXJTdHlsZTogJ2hpZGRlbicgfSA6IHt9KSxcbiAgICAgIC8vIHJlLWFkZCB3aW5kb3cgY29udHJvbHNcbiAgICAgIC8vIFRPRE86IFJlLWNoZWNrIGxpbnV4IHN1cHBvcnQgd2l0aCBFbGVjdHJvbiAzNCwgc2VlIGh0dHBzOi8vZGlzY29yZC5jb20vY2hhbm5lbHMvMTA2NDkzODM2NDU5NzQzNjQxNi8xMzQ0MzI5MTY2Nzg2NTI3MjMyXG4gICAgICAuLi4ocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ2RhcndpbicgJiYgcHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ2xpbnV4J1xuICAgICAgICA/IHtcbiAgICAgICAgICAgIHRpdGxlQmFyT3ZlcmxheToge1xuICAgICAgICAgICAgICBoZWlnaHQ6IDQ3LFxuICAgICAgICAgICAgICBjb2xvcjogJ2hzbGEoMCwgMCUsIDEwMCUsIDApJywgLy8gdHJhbnNwYXJlbnQgYnV0dG9uIGJhY2tncm91bmQgdW50aWwgaG92ZXJlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG4gICAgICAgIDoge30pLFxuICAgICAgd2ViUHJlZmVyZW5jZXM6IHtcbiAgICAgICAgcHJlbG9hZDogYXBwLmlzUGFja2FnZWRcbiAgICAgICAgICA/IHBhdGguam9pbihfX2Rpcm5hbWUsICdwcmVsb2FkLmpzJylcbiAgICAgICAgICA6IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLi8uLi8uZXJiL2RsbC9wcmVsb2FkLmpzJyksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gU2V0IG91ciBjdXN0b20gcHJvdG9jb2wgaGFuZGxlciB0byBsb2FkIGFzc2V0cyBmcm9tIGV4dGVuc2lvbnNcbiAgICBleHRlbnNpb25Bc3NldFByb3RvY29sU2VydmljZS5pbml0aWFsaXplKCk7XG5cbiAgICAvLyBSZWdpc3RlciBsaXN0ZW5lcnMgb24gdGhlIHdpbmRvdywgc28gdGhlIHN0YXRlIGlzIHVwZGF0ZWQgYXV0b21hdGljYWxseVxuICAgIC8vICh0aGUgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZCB3aGVuIHRoZSB3aW5kb3cgaXMgY2xvc2VkKVxuICAgIC8vIGFuZCByZXN0b3JlIHRoZSBtYXhpbWl6ZWQgb3IgZnVsbCBzY3JlZW4gc3RhdGVcbiAgICBtYWluV2luZG93U3RhdGUubWFuYWdlKG1haW5XaW5kb3cpO1xuXG4gICAgLy8gQWRkIHNldmVyYWwgbGlzdGVuZXJzIHRvIHRoZSBtYWluIHdpbmRvdyB0byBsb2cgZXZlbnRzXG4gICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5vbigndW5yZXNwb25zaXZlJywgKCkgPT4gbG9nZ2VyLndhcm4oJ21haW5XaW5kb3cgdW5yZXNwb25zaXZlJykpO1xuICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMub24oJ3Jlc3BvbnNpdmUnLCAoKSA9PiBsb2dnZXIud2FybignbWFpbldpbmRvdyByZXNwb25zaXZlJykpO1xuICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMub24oJ3JlbmRlci1wcm9jZXNzLWdvbmUnLCAoXywgZGV0YWlsczogUmVuZGVyUHJvY2Vzc0dvbmVEZXRhaWxzKSA9PlxuICAgICAgbG9nZ2VyLndhcm4oYG1haW5XaW5kb3cgcmVuZGVyIHByb2Nlc3MgZ29uZTogJHtKU09OLnN0cmluZ2lmeShkZXRhaWxzKX1gKSxcbiAgICApO1xuICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMub24oXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gVFMgc2VlbXMgY29uZnVzZWQsIGFzIHRoaXMgbWF0Y2hlcyB0aGUgZC50cyBmaWxlIGFuZCB0aGUgZG9jc1xuICAgICAgJ2RpZC1mYWlsLWxvYWQnLFxuICAgICAgKFxuICAgICAgICBfZXZlbnQ6IEV2ZW50LFxuICAgICAgICBlcnJvckNvZGU6IG51bWJlcixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogc3RyaW5nLFxuICAgICAgICB2YWxpZGF0ZWRVUkw6IHN0cmluZyxcbiAgICAgICAgaXNNYWluRnJhbWU6IGJvb2xlYW4sXG4gICAgICApID0+IHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYG1haW5XaW5kb3cgZmFpbGVkIHRvIGxvYWQgXCIke3ZhbGlkYXRlZFVSTH1cIiB3aXRoIGVycm9yIFwiJHtlcnJvckRlc2NyaXB0aW9ufVwiICgke2Vycm9yQ29kZX0pLiBpc01haW5GcmFtZTogJHtpc01haW5GcmFtZX1gLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgbWFpbldpbmRvdy5vbigncmVhZHktdG8tc2hvdycsICgpID0+IHtcbiAgICAgIGxvZ2dlci5pbmZvKCdtYWluV2luZG93IGlzIHJlYWR5IHRvIHNob3cnKTtcbiAgICAgIGlmICghbWFpbldpbmRvdykgdGhyb3cgbmV3IEVycm9yKCdcIm1haW5XaW5kb3dcIiBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52LlNUQVJUX01JTklNSVpFRCkge1xuICAgICAgICBtYWluV2luZG93Lm1pbmltaXplKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWluV2luZG93LnNob3coKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIG1haW5XaW5kb3cub24oJ2Nsb3NlZCcsICgpID0+IHtcbiAgICAgIG1haW5XaW5kb3cgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG5cbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgc3Vic2NyaWJlQ3VycmVudE1hY29zTWVudWJhcigpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKGBGYWlsZWQgdG8gYnVpbGQgdGhlIG1hY09TIG1lbnViYXIgJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHNldHMgdGhlIG1lbnUgb24gV2luZG93cyBhbmQgTGludXhcbiAgICAvLyAnbnVsbCcgdG8gaW50ZXJhY3Qgd2l0aCBleHRlcm5hbCBBUElcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbnVsbC9uby1udWxsXG4gICAgbWFpbldpbmRvdy5zZXRNZW51KG51bGwpO1xuXG4gICAgLy8gT3BlbiB1cmxzIGluIHRoZSB1c2VyJ3MgYnJvd3NlclxuICAgIC8vIE5vdGUgdGhhdCB3ZWJ2aWV3cyBjYW4gZ2V0IHRvIHRoaXMgaGFuZGxlciB3aXRoIHdpbmRvdy5vcGVuIGFuZCBhbmNob3IgdGFncyB3aXRoXG4gICAgLy8gdGFyZ2V0PVwiX2JsYW5rXCIuIFBsZWFzZSByZXZpc2Ugd2ViLXZpZXcuc2VydmljZS1ob3N0LnRzIGFzIG5lY2Vzc2FyeSBpZiB5b3UgbWFrZSBjaGFuZ2VzIGhlcmVcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNldFdpbmRvd09wZW5IYW5kbGVyKChoYW5kbGVyRGV0YWlscykgPT4ge1xuICAgICAgLy8gT25seSBhbGxvdyBodHRwcyB1cmxzXG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9wZW5FeHRlcm5hbChoYW5kbGVyRGV0YWlscy51cmwpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgbWFpbldpbmRvdyBjb3VsZCBub3Qgb3BlbiBleHRlcm5hbCB1cmwgXCIke2hhbmRsZXJEZXRhaWxzLnVybH1cIiBmcm9tIHdpbmRvd09wZW5IYW5kbGVyLiAke2V9YCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuXG4gICAgICByZXR1cm4geyBhY3Rpb246ICdkZW55JyB9O1xuICAgIH0pO1xuXG4gICAgLy8gSWYgdGhlIFVSTCBkb2Vzbid0IGxvYWQsIHdlIG1pZ2h0IG5lZWQgdG8gc2hvdyBzb21ldGhpbmcgdG8gdGhlIHVzZXJcbiAgICBjb25zdCB1cmxUb0xvYWQgPSBgJHtyZXNvbHZlSHRtbFBhdGgoJ2luZGV4Lmh0bWwnKX0ke2dsb2JhbFRoaXMuaXNOb2lzeURldk1vZGVFbmFibGVkID8gREVWX01PREVfUkVOREVSRVJfSU5ESUNBVE9SIDogJyd9YDtcbiAgICBtYWluV2luZG93LmxvYWRVUkwodXJsVG9Mb2FkKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgbG9nZ2VyLmVycm9yKGBtYWluV2luZG93IGNvdWxkIG5vdCBsb2FkIFVSTCBcIiR7dXJsVG9Mb2FkfVwiLiAke2dldEVycm9yTWVzc2FnZShlKX1gKTtcbiAgICB9KTtcblxuICAgIC8vIFJlbW92ZSB0aGlzIGlmIHlvdXIgYXBwIGRvZXMgbm90IHVzZSBhdXRvIHVwZGF0ZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAvLyBSZW1vdmVkIHVudGlsIHdlIGhhdmUgYSByZWxlYXNlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BhcmFuZXh0L3BhcmFuZXh0LWNvcmUvaXNzdWVzLzgzXG4gICAgLy8gbmV3IEFwcFVwZGF0ZXIoKTtcbiAgfTtcblxuICBhcHAub24oJ3dpbmRvdy1hbGwtY2xvc2VkJywgKCkgPT4ge1xuICAgIC8vIFJlc3BlY3QgdGhlIE9TWCBjb252ZW50aW9uIG9mIGhhdmluZyB0aGUgYXBwbGljYXRpb24gaW4gbWVtb3J5IGV2ZW5cbiAgICAvLyBhZnRlciBhbGwgd2luZG93cyBoYXZlIGJlZW4gY2xvc2VkXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICdkYXJ3aW4nKSB7XG4gICAgICBhcHAucXVpdCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGlzQ2xvc2luZyA9IGZhbHNlO1xuICBhcHAub24oJ3dpbGwtcXVpdCcsIGFzeW5jIChlKSA9PiB7XG4gICAgaWYgKCFpc0Nsb3NpbmcpIHtcbiAgICAgIGxvZ2dlci5pbmZvKCdNYWluIHByb2Nlc3MgaXMgcXVpdHRpbmcnKTtcblxuICAgICAgLy8gUHJldmVudCBjbG9zaW5nIGJlZm9yZSBncmFjZWZ1bCBzaHV0ZG93biBpcyBjb21wbGV0ZS5cbiAgICAgIC8vIEFsc28sIGluIHRoZSBmdXR1cmUsIHRoaXMgc2hvdWxkIGFsbG93IGEgXCJhcmUgeW91IHN1cmU/XCIgZGlhbG9nIHRvIGRpc3BsYXkuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpc0Nsb3NpbmcgPSB0cnVlO1xuXG4gICAgICBuZXR3b3JrU2VydmljZS5zaHV0ZG93bigpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBkb3RuZXREYXRhUHJvdmlkZXIud2FpdEZvckNsb3NlKFBST0NFU1NfQ0xPU0VfVElNRV9PVVQpLFxuICAgICAgICBleHRlbnNpb25Ib3N0U2VydmljZS53YWl0Rm9yQ2xvc2UoUFJPQ0VTU19DTE9TRV9USU1FX09VVCksXG4gICAgICBdKTtcblxuICAgICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHRoZSBkb3RuZXQgd2F0Y2hlciB3YXMga2lsbGVkIHNvIHdlIGhhdmUgdG8gd2FpdCBoZXJlLlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIGF3YWl0IHdhaXQoNTAwKTtcblxuICAgICAgYXBwLnF1aXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG90bmV0RGF0YVByb3ZpZGVyLmtpbGwoKTtcbiAgICAgIGV4dGVuc2lvbkhvc3RTZXJ2aWNlLmtpbGwoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFwcFxuICAgIC53aGVuUmVhZHkoKVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL2Fsd2F5cy1yZXR1cm5cbiAgICAudGhlbigoKSA9PiB7XG4gICAgICAvLyBTZXQgdXAgaXBjIGhhbmRsZXJzXG4gICAgICBpcGNNYWluLmhhbmRsZShcbiAgICAgICAgJ2VsZWN0cm9uQVBJOmVudi50ZXN0JyxcbiAgICAgICAgKF9ldmVudCwgbWVzc2FnZTogc3RyaW5nKSA9PiBgRnJvbSBtYWluLnRzOiB0ZXN0ICR7bWVzc2FnZX1gLFxuICAgICAgKTtcblxuICAgICAgY3JlYXRlV2luZG93KCk7XG4gICAgICBhcHAub24oJ2FjdGl2YXRlJywgKCkgPT4ge1xuICAgICAgICAvLyBPbiBtYWNPUyBpdCdzIGNvbW1vbiB0byByZS1jcmVhdGUgYSB3aW5kb3cgaW4gdGhlIGFwcCB3aGVuIHRoZVxuICAgICAgICAvLyBkb2NrIGljb24gaXMgY2xpY2tlZCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIHdpbmRvd3Mgb3Blbi5cbiAgICAgICAgaWYgKCFtYWluV2luZG93KSBjcmVhdGVXaW5kb3coKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pXG4gICAgLmNhdGNoKChlKSA9PiBsb2dnZXIuZXJyb3IoYEVycm9yIGluIGFwcC53aGVuUmVhZHk6ICR7Z2V0RXJyb3JNZXNzYWdlKGUpfWApKTtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBFbnN1cmUgdGhlIHJlcXVlc3QgdGltZW91dCBoYXMgYmVlbiBzZXRcblxuICAvLyBzZXR0aW5nc1NlcnZpY2UgdXBkYXRlcyB0aGUgcmVxdWVzdCB0aW1lb3V0IGR1cmluZyBpbml0aWFsaXphdGlvbiwgc28gdXNpbmcgdGhlIHNlcnZpY2UgaW4gYW55XG4gIC8vIHdheSBlbnN1cmVzIHRoZSB0aW1lb3V0IGlzIHNldFxuICBsb2dnZXIuZGVidWcoYFJlcXVlc3QgdGltZW91dCBpcyAke2F3YWl0IHNldHRpbmdzU2VydmljZS5nZXQoJ3BsYXRmb3JtLnJlcXVlc3RUaW1lb3V0Jyl9IHNlY2ApO1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIFJlZ2lzdGVyIGNvbW1hbmRzXG5cbiAgLy8gYG1haW4udHNgJ3MgY29tbWFuZCBoYW5kbGVyIGRlY2xhcmF0aW9ucyBhcmUgaW4gYHBhcGktc2hhcmVkLXR5cGVzLnRzYCBzbyBwYXBpLWR0cyBzZWVzIHRoZW1cblxuICBjb21tYW5kU2VydmljZS5yZWdpc3RlckNvbW1hbmQoJ3BsYXRmb3JtLnJlc3RhcnRFeHRlbnNpb25Ib3N0JywgcmVzdGFydEV4dGVuc2lvbkhvc3QsIHtcbiAgICBtZXRob2Q6IHtcbiAgICAgIHN1bW1hcnk6ICdSZXN0YXJ0IHRoZSBleHRlbnNpb24gaG9zdCB3aGljaCByZWxvYWRzIGFuZCByZWluaXRpYWxpemVzIFRTL0pTIGV4dGVuc2lvbnMnLFxuICAgICAgcGFyYW1zOiBbXSxcbiAgICAgIHJlc3VsdDoge1xuICAgICAgICBuYW1lOiAncmV0dXJuIHZhbHVlJyxcbiAgICAgICAgc2NoZW1hOiB7IHR5cGU6ICdudWxsJyB9LFxuICAgICAgfSxcbiAgICB9LFxuICB9KTtcblxuICBjb21tYW5kU2VydmljZS5yZWdpc3RlckNvbW1hbmQoXG4gICAgJ3BsYXRmb3JtLnF1aXQnLFxuICAgIGFzeW5jICgpID0+IHtcbiAgICAgIGFwcC5xdWl0KCk7XG4gICAgfSxcbiAgICB7XG4gICAgICBtZXRob2Q6IHtcbiAgICAgICAgc3VtbWFyeTogJ0Nsb3NlIHRoZSBwbGF0Zm9ybSwgaW5jbHVkaW5nIGFsbCBwcm9jZXNzZXMgc3RhcnRlZCBieSBpdCcsXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIG5hbWU6ICdyZXR1cm4gdmFsdWUnLFxuICAgICAgICAgIHNjaGVtYTogeyB0eXBlOiAnbnVsbCcgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgKTtcblxuICBjb21tYW5kU2VydmljZS5yZWdpc3RlckNvbW1hbmQoXG4gICAgJ3BsYXRmb3JtLnJlc3RhcnQnLFxuICAgIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE9ubHkgc2V0IHVwIHRvIHJlc3RhcnQgb25jZS4gVGhpcyBjb3VsZCBhY2NpZGVudGFsbHkgYmUgY2FsbGVkIHR3aWNlIGlmIGBhcHAucXVpdGAgaXNcbiAgICAgIC8vIGNhbmNlbGVkIG9yIGlmIHNvbWVvbmUgcmVxdWVzdGVkIHRvIHJlc3RhcnQgbXVsdGlwbGUgdGltZXMgaW4gdGhlIGZldyBzZWNvbmRzIGl0IHRha2VzXG4gICAgICAvLyBgYXBwLnF1aXRgIHRvIHJ1biBiZWNhdXNlIG9mIHRoZSBgd2lsbC1xdWl0YCBldmVudFxuICAgICAgaWYgKCF3aWxsUmVzdGFydCkge1xuICAgICAgICB3aWxsUmVzdGFydCA9IHRydWU7XG5cbiAgICAgICAgYXBwLnJlbGF1bmNoKHtcbiAgICAgICAgICAvLyBJZiBpbiBwb3J0YWJsZSBhcHAsIHJlbGF1bmNoIHByb3Blcmx5LiBJZiBub3QsIHRha2UgZGVmYXVsdCBhY3Rpb24uIFRoYW5rcyB0byBBcmF4ZXVzIGF0XG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvaXNzdWVzLzQxMTAjaXNzdWVjb21tZW50LTEwNTAxNDk0MjlcbiAgICAgICAgICBleGVjUGF0aDogcHJvY2Vzcy5lbnYuUE9SVEFCTEVfRVhFQ1VUQUJMRV9GSUxFLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFwcC5xdWl0KCk7XG4gICAgfSxcbiAgICB7XG4gICAgICBtZXRob2Q6IHtcbiAgICAgICAgc3VtbWFyeTogJ1Jlc3RhcnQgdGhlIHBsYXRmb3JtLCBpbmNsdWRpbmcgYWxsIHByb2Nlc3NlcyBzdGFydGVkIGJ5IGl0JyxcbiAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgbmFtZTogJ3JldHVybiB2YWx1ZScsXG4gICAgICAgICAgc2NoZW1hOiB7IHR5cGU6ICdudWxsJyB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICApO1xuXG4gIGNvbW1hbmRTZXJ2aWNlLnJlZ2lzdGVyQ29tbWFuZChcbiAgICAncGxhdGZvcm0uZ2V0T1NQbGF0Zm9ybScsXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIG9zLnBsYXRmb3JtKCk7XG4gICAgfSxcbiAgICB7XG4gICAgICBtZXRob2Q6IHtcbiAgICAgICAgc3VtbWFyeTogJ0dldCB0aGUgb3MgcGxhdGZvcm0gKFwid2luMzJcIiwgXCJkYXJ3aW5cIiwgXCJsaW51eFwiKScsXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIG5hbWU6ICdyZXR1cm4gdmFsdWUnLFxuICAgICAgICAgIHNjaGVtYTogeyB0eXBlOiAnbnVsbCcgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgKTtcblxuICBjb21tYW5kU2VydmljZS5yZWdpc3RlckNvbW1hbmQoXG4gICAgJ3BsYXRmb3JtLmlzRnVsbFNjcmVlbicsXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBUT0RPIGltcGxlbWVudDtcbiAgICB9LFxuICAgIHtcbiAgICAgIG1ldGhvZDoge1xuICAgICAgICBzdW1tYXJ5OiAnSWYgcGxhdGZvcm0gcnVucyBpbiBmdWxsIHNjcmVlbiBtb2RlJyxcbiAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgbmFtZTogJ3JldHVybiB2YWx1ZScsXG4gICAgICAgICAgc2NoZW1hOiB7IHR5cGU6ICdudWxsJyB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICApO1xuXG4gIGNvbnN0IGxpdmVEb2NzVXJsID1cbiAgICAnaHR0cHM6Ly9wbGF5Z3JvdW5kLm9wZW4tcnBjLm9yZy8/dHJhbnNwb3J0PXdlYnNvY2tldCZzY2hlbWFVcmw9d3MlM0ElMkYlMkZsb2NhbGhvc3QlM0E4ODc2JTBBJnVpU2NoZW1hW2FwcEJhcl1bdWk6c3BsaXRWaWV3XT1mYWxzZSZ1aVNjaGVtYVthcHBCYXJdW3VpOmlucHV0XT1mYWxzZSZ1aVNjaGVtYVthcHBCYXJdW3VpOmV4YW1wbGVzRHJvcGRvd25dPWZhbHNlJnVpU2NoZW1hW2FwcEJhcl1bdWk6dHJhbnNwb3J0c109ZmFsc2UmdWlTY2hlbWFbYXBwQmFyXVt1aTpkYXJrTW9kZV09dHJ1ZSZ1aVNjaGVtYVthcHBCYXJdW3VpOnRpdGxlXT1QQVBJJztcbiAgY29tbWFuZFNlcnZpY2UucmVnaXN0ZXJDb21tYW5kKFxuICAgICdwbGF0Zm9ybS5vcGVuRGV2ZWxvcGVyRG9jdW1lbnRhdGlvblVybCcsXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgb3BlbkV4dGVybmFsKGxpdmVEb2NzVXJsKTtcbiAgICB9LFxuICAgIHtcbiAgICAgIG1ldGhvZDoge1xuICAgICAgICBzdW1tYXJ5OiAnT3BlbiB0aGUgT3BlblJQQyBkb2N1bWVudGF0aW9uIGluIGEgYnJvd3NlcicsXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIG5hbWU6ICdyZXR1cm4gdmFsdWUnLFxuICAgICAgICAgIHNjaGVtYTogeyB0eXBlOiAnbnVsbCcgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgKTtcblxuICBjb21tYW5kU2VydmljZS5yZWdpc3RlckNvbW1hbmQoXG4gICAgJ3BsYXRmb3JtLm9wZW5XaW5kb3cnLFxuICAgIGFzeW5jICh1cmwpID0+IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgTWFpbiBvcGVuaW5nIHdpbmRvdyB3aXRoIHVybCBmcm9tIGNvbW1hbmQ6ICR7dXJsfWApO1xuICAgICAgYXdhaXQgb3BlbkV4dGVybmFsKHVybCk7XG4gICAgfSxcbiAgICB7XG4gICAgICBtZXRob2Q6IHtcbiAgICAgICAgc3VtbWFyeTogXCJPcGVuIGEgbGluayBpbiB0aGUgdXNlcidzIGRlZmF1bHQgYnJvd3NlclwiLFxuICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAndXJsJyxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgc3VtbWFyeTogJ1RoZSB1cmwgdG8gb3BlbicsXG4gICAgICAgICAgICBzY2hlbWE6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICBuYW1lOiAncmV0dXJuIHZhbHVlJyxcbiAgICAgICAgICBzY2hlbWE6IHsgdHlwZTogJ251bGwnIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICk7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gTm9pc3kgZGV2IHRlc3RzXG5cbiAgaWYgKGdsb2JhbFRoaXMuaXNOb2lzeURldk1vZGVFbmFibGVkKSB7XG4gICAgLy8gUmVnaXN0ZXIgY29tbWFuZHMgb25seSBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgdGVzdENvbW1hbmRIYW5kbGVyczogeyBbY29tbWFuZE5hbWU6IHN0cmluZ106ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55IH0gPSB7XG4gICAgICAndGVzdC5lY2hvJzogYXN5bmMgKG1lc3NhZ2U6IHN0cmluZykgPT4ge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH0sXG4gICAgICAndGVzdC5lY2hvRXh0ZW5zaW9uSG9zdCc6IGFzeW5jIChtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgYXdhaXQgY29tbWFuZFNlcnZpY2Uuc2VuZENvbW1hbmQoJ3Rlc3QuYWRkTWFueScsIDMsIDUsIDcsIDEsIDQpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH0sXG4gICAgICAndGVzdC50aHJvd0Vycm9yJzogYXN5bmMgKG1lc3NhZ2U6IHN0cmluZykgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlc3QgRXJyb3IgdGhyb3duIGluIHRocm93RXJyb3IgY29tbWFuZDogJHttZXNzYWdlfWApO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgT2JqZWN0LmVudHJpZXModGVzdENvbW1hbmRIYW5kbGVycykuZm9yRWFjaCgoW2NvbW1hbmROYW1lLCBoYW5kbGVyXSkgPT4ge1xuICAgICAgLy8gUmUtYXNzZXJ0IHR5cGUgYWZ0ZXIgcGFzc2luZyB0aHJvdWdoIGBmb3JFYWNoYC5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICAgICAgY29tbWFuZFNlcnZpY2UucmVnaXN0ZXJDb21tYW5kKGNvbW1hbmROYW1lIGFzIENvbW1hbmROYW1lcywgaGFuZGxlcik7XG4gICAgfSk7XG5cbiAgICAvLyBDYWxsIGEgdGVzdCBjb21tYW5kIHJlZ2lzdGVyZWQgZWxzZXdoZXJlXG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgIGBBZGQgTWFueSAoZnJvbSBFSCk6ICR7YXdhaXQgY29tbWFuZFNlcnZpY2Uuc2VuZENvbW1hbmQoJ3Rlc3QuYWRkTWFueScsIDIsIDUsIDksIDcpfWAsXG4gICAgICApO1xuICAgIH0sIDIwMDAwKTtcblxuICAgIC8vIFJlZ2lzdGVyIGEgdGVzdCBuZXR3b3JrIG9iamVjdFxuICAgIGNvbnN0IHRlc3RNYWluID0ge1xuICAgICAgZG9TdHVmZjogKHN0dWZmOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYHRlc3RNYWluIGRpZCBzdHVmZjogJHtzdHVmZn0hYDtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Rlc3RNYWluLmRpc3Bvc2UoKSByYW4gaW4gdGVzdE1haW4nKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IHRlc3RNYWluRGlzcG9zZXIgPSBhd2FpdCBuZXR3b3JrT2JqZWN0U2VydmljZS5zZXQoJ3Rlc3RNYWluJywgdGVzdE1haW4pO1xuICAgIHRlc3RNYWluLmRvU3R1ZmYoJ21haW4gdGhpbmdzJyk7XG4gICAgdGVzdE1haW5EaXNwb3Nlci5vbkRpZERpc3Bvc2UoKCkgPT4ge1xuICAgICAgbG9nZ2VyLmRlYnVnKCd0ZXN0TWFpbiBkaXNwb3NlZCBpbiBtYWluIG1lc3NhZ2UgIzEnKTtcbiAgICB9KTtcbiAgICB0ZXN0TWFpbkRpc3Bvc2VyLm9uRGlkRGlzcG9zZSgoKSA9PiB7XG4gICAgICBsb2dnZXIuZGVidWcoJ3Rlc3RNYWluIGRpc3Bvc2VkIGluIG1haW4gbWVzc2FnZSAjMicpO1xuICAgIH0pO1xuXG4gICAgc2V0VGltZW91dCh0ZXN0TWFpbkRpc3Bvc2VyLmRpc3Bvc2UsIDIwMDAwKTtcblxuICAgIC8vIENyZWF0ZSBhIHRlc3QgbmV0d29yayBvYmplY3QgcmVnaXN0ZXJlZCBlbHNld2hlcmVcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB0ZXN0RXh0ZW5zaW9uSG9zdCA9IGF3YWl0IG5ldHdvcmtPYmplY3RTZXJ2aWNlLmdldDx7XG4gICAgICAgIGdldFZlcnNlOiAoKSA9PiBQcm9taXNlPHN0cmluZz47XG4gICAgICB9PigndGVzdEV4dGVuc2lvbkhvc3QnKTtcbiAgICAgIGlmICh0ZXN0RXh0ZW5zaW9uSG9zdCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYGdldCB2ZXJzZTogJHthd2FpdCB0ZXN0RXh0ZW5zaW9uSG9zdC5nZXRWZXJzZSgpfWApO1xuICAgICAgICB0ZXN0RXh0ZW5zaW9uSG9zdC5vbkRpZERpc3Bvc2UoKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZygndGVzdEV4dGVuc2lvbkhvc3QgZGlzcG9zZWQgaW4gbWFpbicpO1xuICAgICAgICAgIHRlc3RFeHRlbnNpb25Ib3N0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBsb2dnZXIuZXJyb3IoJ0NvdWxkIG5vdCBnZXQgdGVzdEV4dGVuc2lvbkhvc3QgZnJvbSBtYWluJyk7XG4gICAgfSwgNTAwMCk7XG5cbiAgICAvLyBEdW1wIGFsbCB0aGUgbmV0d29yayBvYmplY3RzIGFmdGVyIHRoaW5ncyBoYXZlIHNldHRsZWQgYSBiaXRcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICBgQXZhaWxhYmxlIG5ldHdvcmsgcmVxdWVzdCB0eXBlcyBhZnRlciAzMCBzZWNvbmRzOiAke3NlcmlhbGl6ZShcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICBhd2FpdCBuZXR3b3JrU2VydmljZS5yZXF1ZXN0KEdFVF9NRVRIT0RTIGFzIFNlcmlhbGl6ZWRSZXF1ZXN0VHlwZSwge30pLFxuICAgICAgICApfWAsXG4gICAgICApO1xuICAgIH0sIDMwMDAwKTtcblxuICAgIC8vIEdldCBhIGRhdGEgcHJvdmlkZXIgYW5kIGRvIHNvbWV0aGluZyB3aXRoIGl0XG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1c3hQZHAgPSBhd2FpdCBnZXQoXG4gICAgICAgICdwbGF0Zm9ybVNjcmlwdHVyZS5VU1hfQ2hhcHRlcicsXG4gICAgICAgICczMjY2NGRjMzI4OGEyOGRmMmUyYmI3NWRlZDg4N2ZjOGYxN2ExNWZiJyxcbiAgICAgICk7XG4gICAgICBjb25zdCB2ZXJzZSA9IGF3YWl0IHVzeFBkcC5nZXRDaGFwdGVyVVNYKHsgYm9vazogJ0pITicsIGNoYXB0ZXJOdW06IDEsIHZlcnNlTnVtOiAxIH0pO1xuICAgICAgbG9nZ2VyLmluZm8oYEdvdCBQRFAgZGF0YTogJHt2ZXJzZX1gKTtcblxuICAgICAgaWYgKHZlcnNlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGF3YWl0IHVzeFBkcC5zZXRDaGFwdGVyVVNYKHsgYm9vazogJ0pITicsIGNoYXB0ZXJOdW06IDEsIHZlcnNlTnVtOiAxIH0sIHZlcnNlKTtcblxuICAgICAgY29uc3QgYmFzZVBkcCA9IGF3YWl0IGdldChcbiAgICAgICAgUFJPSkVDVF9JTlRFUkZBQ0VfUExBVEZPUk1fQkFTRSxcbiAgICAgICAgJzMyNjY0ZGMzMjg4YTI4ZGYyZTJiYjc1ZGVkODg3ZmM4ZjE3YTE1ZmInLFxuICAgICAgKTtcbiAgICAgIGJhc2VQZHAuc2V0RXh0ZW5zaW9uRGF0YShcbiAgICAgICAgeyBleHRlbnNpb25OYW1lOiAnZm9vJywgZGF0YVF1YWxpZmllcjogJ2Zvb0RhdGEnIH0sXG4gICAgICAgICdUaGlzIGlzIHRoZSBkYXRhIGZyb20gZXh0ZW5zaW9uIGZvbycsXG4gICAgICApO1xuICAgIH0sIDIwMDAwKTtcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzdGFydEV4dGVuc2lvbkhvc3QoKSB7XG4gIGxvZ2dlci5pbmZvKCdSZXN0YXJ0aW5nIGV4dGVuc2lvbiBob3N0Jyk7XG4gIGF3YWl0IGV4dGVuc2lvbkhvc3RTZXJ2aWNlLnJlc3RhcnQoUFJPQ0VTU19DTE9TRV9USU1FX09VVCk7XG59XG5cbihhc3luYyAoKSA9PiB7XG4gIGxvZ2dlci5pbmZvKGBTdGFydGluZyAke0FQUF9OQU1FfSB2ZXJzaW9uICR7QVBQX1ZFUlNJT059YCk7XG4gIGF3YWl0IG1haW4oKTtcbn0pKCkuY2F0Y2gobG9nZ2VyLmVycm9yKTtcbiIsImltcG9ydCB7IE1lbnVJdGVtQ29uc3RydWN0b3JPcHRpb25zIH0gZnJvbSAnZWxlY3Ryb24nO1xuaW1wb3J0IHsgTG9jYWxpemVkLCBMb2NhbGl6ZUtleSB9IGZyb20gJ3BsYXRmb3JtLWJpYmxlLXV0aWxzJztcblxuLyoqXG4gKiBBIGdyb3VwIG9mIFJlZmVyZW5jZWRJdGVtcyBzcGVjaWZpYyB0byB0aGUgcHJlZGVmaW5lZCBtZW51cyBpbiB0aGUgTWFjT1MgbWVudSBiYXIuIElmIHRoZXkgc2V0XG4gKiB0aGVpciBtYWNvc01lbnVLZXkgdG8gJ21hY29zTWVudWJhci5pZ25vcmUnLCB0aGUgaXRlbSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgTWFjT1MgbWVudWJhci5cbiAqL1xuZXhwb3J0IHR5cGUgTWFjb3NNZW51S2V5ID1cbiAgfCAnbWFjb3NNZW51YmFyLmFwcE1lbnUnXG4gIHwgJ21hY29zTWVudWJhci5maWxlTWVudSdcbiAgfCAnbWFjb3NNZW51YmFyLmVkaXRNZW51J1xuICB8ICdtYWNvc01lbnViYXIudmlld01lbnUnXG4gIHwgJ21hY29zTWVudWJhci50YWJNZW51J1xuICB8ICdtYWNvc01lbnViYXIudGV4dE1lbnUnXG4gIHwgJ21hY29zTWVudWJhci5sYXlvdXRNZW51J1xuICB8ICdtYWNvc01lbnViYXIud2luZG93TWVudSdcbiAgfCAnbWFjb3NNZW51YmFyLmhlbHBNZW51JztcblxuLyoqXG4gKiBUaGlzIHR5cGUgZXh0ZW5kcyB0aGUgTWVudUl0ZW1Db25zdHJ1Y3Rvck9wdGlvbnMgdHlwZSBmcm9tIEVsZWN0cm9uIHRvIGluY2x1ZGUgYW4gb3B0aW9uYWwgb3JkZXJcbiAqIHByb3BlcnR5LCBjaGFuZ2UgdGhlIHR5cGVzIG9mIGxhYmVsIGFuZCB0b29sVGlwIHRvIGJlIExvY2FsaXplS2V5cy4gQ2hhbmdlIHRoZSB0eXBlIG9mIGlkIHRvXG4gKiBNYWNvc01lbnVLZXksIHNvIHRoYXQgZXh0ZW5zaW9ucyBjYW4gY29udHJpYnV0ZSBtZW51IGl0ZW1zIGludG8gb3VyIHByZS1leGlzdGluZyBNYWNPUyBtZW51cy5cbiAqL1xuZXhwb3J0IHR5cGUgTWVudUl0ZW1Db25zdHJ1Y3Rvck9wdGlvbnNXaXRoT3JkZXIgPSBNZW51SXRlbUNvbnN0cnVjdG9yT3B0aW9ucyAmIHtcbiAgbGFiZWw/OiBMb2NhbGl6ZUtleTtcbiAgdG9vbFRpcD86IExvY2FsaXplS2V5O1xuICBpZD86IE1hY29zTWVudUtleTtcbiAgb3JkZXI/OiBudW1iZXI7XG4gIHN1Ym1lbnU/OiBPbWl0PE1lbnVJdGVtQ29uc3RydWN0b3JPcHRpb25zLCAnbGFiZWwnPiAmXG4gICAge1xuICAgICAgbGFiZWw/OiBMb2NhbGl6ZUtleTtcbiAgICAgIG9yZGVyPzogbnVtYmVyO1xuICAgICAgdG9vbFRpcD86IExvY2FsaXplS2V5O1xuICAgICAgaXNMYWJlbEZvcm1hdFN0cmluZz86IGJvb2xlYW47XG4gICAgfVtdO1xufTtcblxuZXhwb3J0IHR5cGUgTG9jYWxpemVkTWFjb3NNZW51YmFyID0gTG9jYWxpemVkPE1lbnVJdGVtQ29uc3RydWN0b3JPcHRpb25zV2l0aE9yZGVyPltdO1xuXG4vLyBDYW5ub3QgY29udHJpYnV0ZSB0aGlzIGFzIGlzIGluIG1haW4udHMsIG5lZWQgdG8gY29udmVydCBsYWJlbHMgYW5kIHRvb2x0aXBzIHRvIGxvY2FsaXplZCBzdHJpbmdzIGFuZCByZW1vdmUgb3JkZXIgcHJvcGVydHlcbmV4cG9ydCBjb25zdCBtYWNvc01lbnViYXJPYmplY3Q6IE1lbnVJdGVtQ29uc3RydWN0b3JPcHRpb25zV2l0aE9yZGVyW10gPSBbXG4gIHtcbiAgICByb2xlOiAnYXBwTWVudScsXG4gICAgaWQ6ICdtYWNvc01lbnViYXIuYXBwTWVudScsXG4gICAgc3VibWVudTogW1xuICAgICAge1xuICAgICAgICBsYWJlbDogJyVtYWluTWVudV9oaWRlUHJvZHVjdE5hbWUlJyxcbiAgICAgICAgcm9sZTogJ2hpZGUnLFxuICAgICAgICBpZDogJ2hpZGUnLFxuICAgICAgICBvcmRlcjogMyxcbiAgICAgICAgaXNMYWJlbEZvcm1hdFN0cmluZzogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICB7IHJvbGU6ICdoaWRlT3RoZXJzJywgaWQ6ICdoaWRlT3RoZXJzJywgb3JkZXI6IDQgfSxcbiAgICAgIHtcbiAgICAgICAgbGFiZWw6ICclbWFpbk1lbnVfcXVpdFByb2R1Y3ROYW1lJScsXG4gICAgICAgIHJvbGU6ICdxdWl0JyxcbiAgICAgICAgaWQ6ICdxdWl0JyxcbiAgICAgICAgb3JkZXI6IDUsXG4gICAgICAgIGlzTGFiZWxGb3JtYXRTdHJpbmc6IHRydWUsXG4gICAgICB9LFxuICAgIF0sXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJyVtYWluTWVudV9maWxlJScsXG4gICAgcm9sZTogJ2ZpbGVNZW51JyxcbiAgICBpZDogJ21hY29zTWVudWJhci5maWxlTWVudScsXG4gICAgc3VibWVudTogW3sgcm9sZTogJ2Nsb3NlJywgaWQ6ICdjbG9zZScsIG9yZGVyOiA4IH1dLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICclbWFpbk1lbnVfZWRpdCUnLFxuICAgIHJvbGU6ICdlZGl0TWVudScsXG4gICAgaWQ6ICdtYWNvc01lbnViYXIuZWRpdE1lbnUnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICclbWFpbk1lbnVfdmlldyUnLFxuICAgIHJvbGU6ICd2aWV3TWVudScsXG4gICAgaWQ6ICdtYWNvc01lbnViYXIudmlld01lbnUnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICclbWFpbk1lbnVfdGFiJScsXG4gICAgaWQ6ICdtYWNvc01lbnViYXIudGFiTWVudScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJyVtYWluTWVudV90ZXh0JScsXG4gICAgaWQ6ICdtYWNvc01lbnViYXIudGV4dE1lbnUnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICclbWFpbk1lbnVfbGF5b3V0JScsXG4gICAgaWQ6ICdtYWNvc01lbnViYXIubGF5b3V0TWVudScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJyVtYWluTWVudV93aW5kb3clJyxcbiAgICByb2xlOiAnd2luZG93TWVudScsXG4gICAgaWQ6ICdtYWNvc01lbnViYXIud2luZG93TWVudScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJyVtYWluTWVudV9oZWxwJScsXG4gICAgcm9sZTogJ2hlbHAnLFxuICAgIGlkOiAnbWFjb3NNZW51YmFyLmhlbHBNZW51JyxcbiAgICBzdWJtZW51OiBbXSxcbiAgfSxcbl07XG4iLCJpbXBvcnQge1xuICBNdWx0aUNvbHVtbk1lbnUsXG4gIExvY2FsaXplS2V5LFxuICBNZW51SXRlbUNvbnRhaW5pbmdDb21tYW5kLFxuICBNZW51SXRlbUNvbnRhaW5pbmdTdWJtZW51LFxuICBMb2NhbGl6ZWQsXG4gIEdyb3Vwc0luTXVsdGlDb2x1bW5NZW51LFxuICBmb3JtYXRSZXBsYWNlbWVudFN0cmluZyxcbn0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuaW1wb3J0IHtcbiAgbWFjb3NNZW51YmFyT2JqZWN0LFxuICBMb2NhbGl6ZWRNYWNvc01lbnViYXIsXG4gIE1lbnVJdGVtQ29uc3RydWN0b3JPcHRpb25zV2l0aE9yZGVyLFxufSBmcm9tICdAbWFpbi9wbGF0Zm9ybS1tYWNvcy1tZW51YmFyLmRhdGEnO1xuaW1wb3J0IHsgbWVudURhdGFTZXJ2aWNlIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9tZW51LWRhdGEuc2VydmljZSc7XG5pbXBvcnQgeyBsb2NhbGl6YXRpb25TZXJ2aWNlIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9sb2NhbGl6YXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBNZW51LCBNZW51SXRlbUNvbnN0cnVjdG9yT3B0aW9ucyB9IGZyb20gJ2VsZWN0cm9uJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbG9nZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgaGFuZGxlTWVudUNvbW1hbmQgfSBmcm9tICdAc2hhcmVkL2RhdGEvcGxhdGZvcm0tYmlibGUtbWVudS5jb21tYW5kcyc7XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gdGhlIG1haW4gbWVudSBkYXRhIGFuZCB1cGRhdGUgdGhlIG1hY09TIG1lbnViYXIgYWNjb3JkaW5nbHkuXG4gKlxuICogQWZ0ZXIgc3Vic2NyaWJpbmcsIHdoZW5ldmVyIHRoZSBtYWluIG1lbnUgZGF0YSBjaGFuZ2VzLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIG5ld1xuICogbWVudSBkYXRhLiBUaGUgbmV3IG1lbnUgZGF0YSB3aWxsIGJlIHRyYW5zbGF0ZWQgYW5kIGNvbWJpbmVkIGNvcnJlY3RseSBpbnRvIHRoZSBzdHJ1Y3R1cmVcbiAqIGV4cGVjdGVkIGJ5IHRoZSBFbGVjdHJvbiBNZW51IEFQSSwgYW5kIHRoZW4gdGhlIG1hY09TIG1lbnViYXIgd2lsbCBiZSB1cGRhdGVkIHdpdGggdGhlIG5ldyBtZW51XG4gKiBzdHJ1Y3R1cmUuXG4gKlxuICogSWYgdGhlcmUgaXMgYW4gZXJyb3IgZHVyaW5nIHRoZSB0cmFuc2xhdGlvbiBhbmQgY29tYmluYXRpb24gcHJvY2VzcywgdGhlIGRlZmF1bHQgbWFjT1MgbWVudWJhclxuICogd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJzY3JpYmVDdXJyZW50TWFjb3NNZW51YmFyKCkge1xuICBhd2FpdCBtZW51RGF0YVNlcnZpY2Uuc3Vic2NyaWJlVW5sb2NhbGl6ZWRNYWluTWVudShcbiAgICB1bmRlZmluZWQsXG4gICAgYXN5bmMgKG1lbnVDb250ZW50OiBNdWx0aUNvbHVtbk1lbnUpID0+IHtcbiAgICAgIGxldCBjdXJyZW50TWFjb3NNZW51YmFyVGVtcGxhdGU7XG4gICAgICB0cnkge1xuICAgICAgICBjdXJyZW50TWFjb3NNZW51YmFyVGVtcGxhdGUgPSBhd2FpdCB0cmFuc2xhdGVQbGF0Zm9ybU1lbnVJdGVtc0FuZENvbWJpbmUobWVudUNvbnRlbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICdGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgcGxhdGZvcm0gbWVudXMuIEZhbGxpbmcgYmFjayB0byBkZWZhdWx0IG1hY09TIG1lbnViYXIuJyxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudE1hY29zTWVudWJhclRlbXBsYXRlID0gYXdhaXQgZmFsbGJhY2tUb0RlZmF1bHRNYWNvc01lbnViYXIoKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29yZU1hY29zTWVudWJhciA9IE1lbnUuYnVpbGRGcm9tVGVtcGxhdGUoY3VycmVudE1hY29zTWVudWJhclRlbXBsYXRlKTtcbiAgICAgICAgTWVudS5zZXRBcHBsaWNhdGlvbk1lbnUoY29yZU1hY29zTWVudWJhcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBidWlsZCBjdXJyZW50IG1hY09TIG1lbnViYXInLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gc29ydE1lbnVBbmRSZW1vdmVBZGRlZFByb3BzKGxvY2FsaXplZE1hY29zTWVudWJhcjogTG9jYWxpemVkTWFjb3NNZW51YmFyKSB7XG4gIGxvY2FsaXplZE1hY29zTWVudWJhci5zb3J0KChhLCBiKSA9PiAoYS5vcmRlciA/PyAwKSAtIChiLm9yZGVyID8/IDApKTtcblxuICBsb2NhbGl6ZWRNYWNvc01lbnViYXIuZm9yRWFjaCgobWVudSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1lbnUuc3VibWVudSkpIHtcbiAgICAgIG1lbnUuc3VibWVudS5zb3J0KChhLCBiKSA9PiAoYS5vcmRlciA/PyAwKSAtIChiLm9yZGVyID8/IDApKTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBgb3JkZXJgIHByb3BlcnR5IGZyb20gc3VibWVudSBpdGVtc1xuICAgICAgbWVudS5zdWJtZW51LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgZGVsZXRlIGl0ZW0ub3JkZXI7XG4gICAgICAgIGRlbGV0ZSBpdGVtLmlzTGFiZWxGb3JtYXRTdHJpbmc7XG5cbiAgICAgICAgLy8gSWYgdGhlIHN1Ym1lbnUgaXRlbSBoYXMgaXRzIG93biBzdWJtZW51LCBzb3J0IGl0IHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0uc3VibWVudSkpIHtcbiAgICAgICAgICBpdGVtLnN1Ym1lbnUuc29ydChcbiAgICAgICAgICAgIChhOiBNZW51SXRlbUNvbnN0cnVjdG9yT3B0aW9uc1dpdGhPcmRlciwgYjogTWVudUl0ZW1Db25zdHJ1Y3Rvck9wdGlvbnNXaXRoT3JkZXIpID0+XG4gICAgICAgICAgICAgIChhLm9yZGVyID8/IDApIC0gKGIub3JkZXIgPz8gMCksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpdGVtLnN1Ym1lbnUuZm9yRWFjaChcbiAgICAgICAgICAgIChzdWJJdGVtOiBNZW51SXRlbUNvbnN0cnVjdG9yT3B0aW9uc1dpdGhPcmRlcikgPT4gZGVsZXRlIHN1Ykl0ZW0ub3JkZXIsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRoZSBgb3JkZXJgIHByb3BlcnR5IGZyb20gdGhlIHRvcC1sZXZlbCBtZW51XG4gICAgZGVsZXRlIG1lbnUub3JkZXI7XG4gIH0pO1xuXG4gIC8vIFRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiBNZW51SXRlbUNvbnN0cnVjdG9yT3B0aW9uc1tdIGFuZCBMb2NhbGl6ZWRNYWNvc01lbnViYXIgaXMgdGhlIGBvcmRlcmAgcHJvcGVydHlcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gIHJldHVybiBsb2NhbGl6ZWRNYWNvc01lbnViYXIgYXMgTWVudUl0ZW1Db25zdHJ1Y3Rvck9wdGlvbnNbXTtcbn1cblxuLyoqIFJldHVybnMgdGhlIGRlZmF1bHQgbWFjT1MgbWVudWJhciBhZnRlciBsb2NhbGl6aW5nIGFuZCBmb3JtYXR0aW5nIGl0IGNvcnJlY3RseS4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZhbGxiYWNrVG9EZWZhdWx0TWFjb3NNZW51YmFyKCk6IFByb21pc2U8TWVudUl0ZW1Db25zdHJ1Y3Rvck9wdGlvbnNbXT4ge1xuICByZXR1cm4gc29ydE1lbnVBbmRSZW1vdmVBZGRlZFByb3BzKGF3YWl0IGxvY2FsaXplTWFjb3NNZW51YmFyKG1hY29zTWVudWJhck9iamVjdCkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2NhbGl6ZU1hY29zTWVudWJhcihcbiAgbWFjb3NNZW51YmFyOiBNZW51SXRlbUNvbnN0cnVjdG9yT3B0aW9uc1dpdGhPcmRlcltdLFxuKTogUHJvbWlzZTxMb2NhbGl6ZWRNYWNvc01lbnViYXI+IHtcbiAgY29uc3QgbG9jYWxpemVLZXlzOiBMb2NhbGl6ZUtleVtdID0gWyclcHJvZHVjdF9uYW1lJSddO1xuICBtYWNvc01lbnViYXIuZm9yRWFjaCgobWVudSkgPT4ge1xuICAgIGlmIChtZW51LmxhYmVsKSBsb2NhbGl6ZUtleXMucHVzaChtZW51LmxhYmVsKTtcbiAgICBpZiAobWVudS50b29sVGlwKSBsb2NhbGl6ZUtleXMucHVzaChtZW51LnRvb2xUaXApO1xuICAgIG1lbnUuc3VibWVudT8uZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0ubGFiZWwpIGxvY2FsaXplS2V5cy5wdXNoKGl0ZW0ubGFiZWwpO1xuICAgICAgaWYgKGl0ZW0udG9vbFRpcCkgbG9jYWxpemVLZXlzLnB1c2goaXRlbS50b29sVGlwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgY29uc3QgbmV3U3RyaW5ncyA9IGF3YWl0IGxvY2FsaXphdGlvblNlcnZpY2UuZ2V0TG9jYWxpemVkU3RyaW5ncyh7IGxvY2FsaXplS2V5cyB9KTtcblxuICByZXR1cm4gbWFjb3NNZW51YmFyLm1hcCgobWVudSkgPT4gKHtcbiAgICAuLi5tZW51LFxuICAgIGxhYmVsOiBtZW51LmxhYmVsID8gbmV3U3RyaW5nc1ttZW51LmxhYmVsXSA6IG1lbnUubGFiZWwsXG4gICAgdG9vbFRpcDogbWVudS50b29sVGlwID8gbmV3U3RyaW5nc1ttZW51LnRvb2xUaXBdIDogbWVudS50b29sVGlwLFxuICAgIHN1Ym1lbnU6IG1lbnUuc3VibWVudT8ubWFwKChpdGVtKSA9PiAoe1xuICAgICAgLi4uaXRlbSxcbiAgICAgIGxhYmVsOiAoKCkgPT4ge1xuICAgICAgICBpZiAoIWl0ZW0ubGFiZWwpIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgICBpZiAoaXRlbS5pc0xhYmVsRm9ybWF0U3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdFJlcGxhY2VtZW50U3RyaW5nKG5ld1N0cmluZ3NbaXRlbS5sYWJlbF0sIG5ld1N0cmluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdHJpbmdzW2l0ZW0ubGFiZWxdO1xuICAgICAgfSkoKSxcbiAgICAgIHRvb2xUaXA6IGl0ZW0udG9vbFRpcCA/IG5ld1N0cmluZ3NbaXRlbS50b29sVGlwXSA6IGl0ZW0udG9vbFRpcCxcbiAgICB9KSksXG4gIH0pKTtcbn1cblxuY29uc3QgZ2V0U3ViTWVudUtleUZvcklkID0gKFxuICBncm91cHM6IExvY2FsaXplZDxHcm91cHNJbk11bHRpQ29sdW1uTWVudT4sXG4gIGlkOiBzdHJpbmcsXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZ3JvdXBzKS5maW5kKFxuICAgIChbLCB2YWx1ZV0pID0+ICdtZW51SXRlbScgaW4gdmFsdWUgJiYgdmFsdWUubWVudUl0ZW0gPT09IGlkLFxuICApPy5bMF07XG59O1xuXG5mdW5jdGlvbiBnZXRNZW51YmFyQ29sdW1uQ29udGVudChcbiAgZ3JvdXBzOiBMb2NhbGl6ZWQ8R3JvdXBzSW5NdWx0aUNvbHVtbk1lbnU+LFxuICBpdGVtczogTG9jYWxpemVkPChNZW51SXRlbUNvbnRhaW5pbmdDb21tYW5kIHwgTWVudUl0ZW1Db250YWluaW5nU3VibWVudSlbXT4sXG4gIGNvbHVtbk9yU3ViTWVudUtleTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuKTogTG9jYWxpemVkTWFjb3NNZW51YmFyIHwgW10ge1xuICBpZiAoIWNvbHVtbk9yU3ViTWVudUtleSkgcmV0dXJuIFtdO1xuXG4gIC8vIE9iamVjdC5lbnRyaWVzKCkgdHVybnMgZ3JvdXBzIGludG8gYW4gYXJyYXkgb2Yga2V5IHZhbHVlIHBhaXJzLiBBZnRlciB3ZSBmaWx0ZXIgYW5kIG1hcCB0aGUgaXRlbXMsIGl0IGlzIGEgTG9jYWxpemVkTWFjb3NNZW51YmFyIG9iamVjdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhncm91cHMpXG4gICAgLmZpbHRlcihcbiAgICAgIChba2V5LCBncm91cF0pID0+XG4gICAgICAgICgnY29sdW1uJyBpbiBncm91cCAmJiBncm91cC5jb2x1bW4gPT09IGNvbHVtbk9yU3ViTWVudUtleSkgfHwga2V5ID09PSBjb2x1bW5PclN1Yk1lbnVLZXksXG4gICAgKVxuICAgIC5mbGF0TWFwKChbZ3JvdXBLZXldKSA9PlxuICAgICAgaXRlbXNcbiAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5ncm91cCA9PT0gZ3JvdXBLZXkpXG4gICAgICAgIC5tYXAoKGl0ZW0pID0+XG4gICAgICAgICAgJ2NvbW1hbmQnIGluIGl0ZW1cbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBpdGVtLmxhYmVsLFxuICAgICAgICAgICAgICAgIGNsaWNrOiAoKSA9PiBoYW5kbGVNZW51Q29tbWFuZCh7IGxhYmVsOiBpdGVtLmxhYmVsLCBjb21tYW5kOiBpdGVtLmNvbW1hbmQgfSksXG4gICAgICAgICAgICAgICAgb3JkZXI6IGl0ZW0ub3JkZXIsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBpdGVtLmxhYmVsLFxuICAgICAgICAgICAgICAgIHN1Ym1lbnU6IGdldE1lbnViYXJDb2x1bW5Db250ZW50KFxuICAgICAgICAgICAgICAgICAgZ3JvdXBzLFxuICAgICAgICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICAgICAgICBnZXRTdWJNZW51S2V5Rm9ySWQoZ3JvdXBzLCBpdGVtLmlkKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICApLFxuICAgICkgYXMgTG9jYWxpemVkTWFjb3NNZW51YmFyO1xufVxuXG5hc3luYyBmdW5jdGlvbiB0cmFuc2xhdGVQbGF0Zm9ybU1lbnVJdGVtc0FuZENvbWJpbmUoXG4gIGN1cnJlbnRQbGF0Zm9ybU1haW5NZW51OiBNdWx0aUNvbHVtbk1lbnUsXG4pOiBQcm9taXNlPE1lbnVJdGVtQ29uc3RydWN0b3JPcHRpb25zW10+IHtcbiAgLy8gQ29udmVydCB0aGUgcGxhdGZvcm0tc3BlY2lmaWMgbWFpbiBtZW51IGludG8gdGhlIGNvcnJlY3QgZm9ybWF0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICBjb25zdCBwbGF0Zm9ybU1haW5NZW51Q29udGVudCA9IE9iamVjdC5lbnRyaWVzKGN1cnJlbnRQbGF0Zm9ybU1haW5NZW51LmNvbHVtbnMpXG4gICAgLmZpbHRlcigoWywgY29sdW1uXSkgPT4gdHlwZW9mIGNvbHVtbiA9PT0gJ29iamVjdCcpXG4gICAgLm1hcCgoW2NvbHVtbktleSwgY29sdW1uRGF0YV0pID0+ICh7XG4gICAgICBsYWJlbDogdHlwZW9mIGNvbHVtbkRhdGEgPT09ICdvYmplY3QnID8gY29sdW1uRGF0YS5sYWJlbCA6ICcnLFxuICAgICAgb3JkZXI6IHR5cGVvZiBjb2x1bW5EYXRhID09PSAnb2JqZWN0JyA/IGNvbHVtbkRhdGEub3JkZXIgOiAwLFxuICAgICAgc3VibWVudTogZ2V0TWVudWJhckNvbHVtbkNvbnRlbnQoXG4gICAgICAgIGN1cnJlbnRQbGF0Zm9ybU1haW5NZW51Lmdyb3VwcyxcbiAgICAgICAgY3VycmVudFBsYXRmb3JtTWFpbk1lbnUuaXRlbXMsXG4gICAgICAgIGNvbHVtbktleSxcbiAgICAgICkuZmlsdGVyKChtZW51SXRlbSkgPT4gbWVudUl0ZW0ubGFiZWwgIT09ICclbWFpbk1lbnVfZXhpdCUnKSwgLy8gUmVtb3ZlIGR1cGxpY2F0ZSAnRXhpdCcgaGVyZVxuICAgIH0pKSBhcyBNZW51SXRlbUNvbnN0cnVjdG9yT3B0aW9uc1dpdGhPcmRlcltdO1xuXG4gIGNvbnN0IGNvbWJpbmVkTWVudWJhciA9IFsuLi5tYWNvc01lbnViYXJPYmplY3RdO1xuXG4gIHBsYXRmb3JtTWFpbk1lbnVDb250ZW50LmZvckVhY2goKGNvbHVtbikgPT4ge1xuICAgIGlmICghY29sdW1uLnN1Ym1lbnUgfHwgIUFycmF5LmlzQXJyYXkoY29sdW1uLnN1Ym1lbnUpKSByZXR1cm47XG4gICAgY29uc3QgYXBwTWVudTogTWVudUl0ZW1Db25zdHJ1Y3Rvck9wdGlvbnNXaXRoT3JkZXIgfCB1bmRlZmluZWQgPSBjb21iaW5lZE1lbnViYXIuZmluZChcbiAgICAgIChtZW51KSA9PiBtZW51LmlkID09PSAnbWFjb3NNZW51YmFyLmFwcE1lbnUnLFxuICAgICk7XG4gICAgLy8gTW92ZSAnUGxhdGZvcm0nIG1lbnUgaXRlbXMgdG8gbWFjT1MgZ2VuZXJhdGVkIGFwcCBtZW51IGFuZCByZW1vdmUgZHVwbGljYXRlIGFwcCBtZW51XG4gICAgaWYgKGNvbHVtbi5sYWJlbCA9PT0gJyVwcm9kdWN0X3Nob3J0TmFtZSUnICYmIGFwcE1lbnUpIHtcbiAgICAgIGFwcE1lbnUuc3VibWVudT8ucHVzaCguLi5jb2x1bW4uc3VibWVudSk7XG4gICAgICBjb2x1bW4uc3VibWVudSA9IFtdO1xuICAgICAgY29sdW1uLmxhYmVsID0gJyUlJzsgLy8gSWYgdGhlcmUgaXMgbm8gbGFiZWwsIHRoaXMgbWVudSBpdGVtIHdvbid0IHNob3cgdXBcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBleGlzdGluZ01lbnUgPSBjb21iaW5lZE1lbnViYXIuZmluZChcbiAgICAgIChtZW51KSA9PlxuICAgICAgICBtZW51LmxhYmVsPy50b0xvd2VyQ2FzZSgpID09PSBjb2x1bW4ubGFiZWw/LnRvTG93ZXJDYXNlKCkgfHxcbiAgICAgICAgbWVudS5yb2xlPy50b0xvd2VyQ2FzZSgpID09PSBjb2x1bW4ubGFiZWw/LnRvTG93ZXJDYXNlKCksXG4gICAgKTtcblxuICAgIGlmIChleGlzdGluZ01lbnUpIHtcbiAgICAgIGV4aXN0aW5nTWVudS5zdWJtZW51ID0gY29sdW1uLnN1Ym1lbnU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbWJpbmVkTWVudWJhci5wdXNoKGNvbHVtbik7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBsb2NhbGl6ZWRNZW51ID0gYXdhaXQgbG9jYWxpemVNYWNvc01lbnViYXIoY29tYmluZWRNZW51YmFyKTtcbiAgcmV0dXJuIHNvcnRNZW51QW5kUmVtb3ZlQWRkZWRQcm9wcyhsb2NhbGl6ZWRNZW51KTtcbn1cbiIsImltcG9ydCB7XG4gIEFwcEluZm8sXG4gIGFwcFNlcnZpY2VOZXR3b3JrT2JqZWN0TmFtZSxcbiAgSUFwcFNlcnZpY2UsXG59IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvYXBwLnNlcnZpY2UtbW9kZWwnO1xuaW1wb3J0IHsgbmV0d29ya09iamVjdFNlcnZpY2UgfSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL25ldHdvcmstb2JqZWN0LnNlcnZpY2UnO1xuaW1wb3J0IHBhY2thZ2VJbmZvIGZyb20gJy4uLy4uLy4uL3JlbGVhc2UvYXBwL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgYnVpbGRJbmZvIGZyb20gJy4uLy4uLy4uL3JlbGVhc2UvYXBwL2J1aWxkSW5mby5qc29uJztcblxuLyoqIFNhbWUgYXMge0BsaW5rIEFwcEluZm8ubmFtZX0gKi9cbmV4cG9ydCBjb25zdCBBUFBfTkFNRTogc3RyaW5nID0gcGFja2FnZUluZm8ubmFtZTtcblxuLy8gQ29uc3RydWN0IHRoZSBhcHAgdmVyc2lvbiBhY2NvcmRpbmcgdG8gdGhlIFNlbVZlciBzcGVjaWZpY2F0aW9uIChwcmUtcmVsZWFzZSBJRCBhbHJlYWR5IGluY2x1ZGVkKVxuY29uc3QgeyBidWlsZCB9ID0gYnVpbGRJbmZvO1xuLyoqIFNhbWUgYXMge0BsaW5rIEFwcEluZm8udmVyc2lvbn0gKi9cbmV4cG9ydCBjb25zdCBBUFBfVkVSU0lPTjogc3RyaW5nID0gYCR7cGFja2FnZUluZm8udmVyc2lvbn0ke2J1aWxkID8gYCske2J1aWxkfWAgOiAnJ31gO1xuXG4vKiogU2FtZSBhcyB7QGxpbmsgQXBwSW5mby51cmlTY2hlbWV9ICovXG5leHBvcnQgY29uc3QgQVBQX1VSSV9TQ0hFTUUgPSBBUFBfTkFNRTtcblxuY29uc3QgQVBQX0lORk8gPSBPYmplY3QuZnJlZXplKHtcbiAgbmFtZTogQVBQX05BTUUsXG4gIHZlcnNpb246IEFQUF9WRVJTSU9OLFxuICB1cmlTY2hlbWU6IEFQUF9VUklfU0NIRU1FLFxufSk7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEFwcEluZm8oKTogUHJvbWlzZTxBcHBJbmZvPiB7XG4gIHJldHVybiBBUFBfSU5GTztcbn1cblxuY29uc3QgYXBwU2VydmljZTogSUFwcFNlcnZpY2UgPSB7XG4gIGdldEFwcEluZm8sXG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBuZXR3b3JrIG9iamVjdCB0aGF0IGJhY2tzIHRoaXMgc2VydmljZVxuICpcbiAqIFRvIHVzZSB0aGlzIHNlcnZpY2UsIHlvdSBzaG91bGQgdXNlIGBhcHAuc2VydmljZS50c2BcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0QXBwU2VydmljZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgbmV0d29ya09iamVjdFNlcnZpY2Uuc2V0PElBcHBTZXJ2aWNlPihhcHBTZXJ2aWNlTmV0d29ya09iamVjdE5hbWUsIGFwcFNlcnZpY2UpO1xufVxuIiwiaW1wb3J0IHtcbiAgZGF0YVByb3RlY3Rpb25TZXJ2aWNlTmV0d29ya09iamVjdE5hbWUsXG4gIElEYXRhUHJvdGVjdGlvblNlcnZpY2UsXG59IGZyb20gJ0BzaGFyZWQvbW9kZWxzL2RhdGEtcHJvdGVjdGlvbi5zZXJ2aWNlLW1vZGVsJztcbmltcG9ydCB7IG5ldHdvcmtPYmplY3RTZXJ2aWNlIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9uZXR3b3JrLW9iamVjdC5zZXJ2aWNlJztcbmltcG9ydCB7IHNhZmVTdG9yYWdlIH0gZnJvbSAnZWxlY3Ryb24nO1xuXG4vKiogSWYgZW5jcnlwdGlvbiBpcyBub3QgYXZhaWxhYmxlLCByZXR1cm4gcmVhc29uIHdoeS4gSWYgZW5jcnlwdGlvbiBpcyBhdmFpbGFibGUsIHJldHVybiBgdW5kZWZpbmVkYCAqL1xuZnVuY3Rpb24gZ2V0UmVhc29uRW5jcnlwdGlvbklzTm90QXZhaWxhYmxlKCkge1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4JyAmJiBzYWZlU3RvcmFnZS5nZXRTZWxlY3RlZFN0b3JhZ2VCYWNrZW5kKCkgPT09ICdiYXNpY190ZXh0JylcbiAgICByZXR1cm4gJ3NhZmVTdG9yYWdlIGRpZCBub3QgZmluZCBhIGtleXJpbmcgc2VydmljZSBpdCBjb3VsZCB1c2UgZm9yIGVuY3J5cHRpb24uIFBsZWFzZSBpbnN0YWxsIGEgc3VwcG9ydGVkIHNlcnZpY2UuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGFyYW5leHQvcGFyYW5leHQvd2lraS9Ib3ctdG8tc2V0LXVwLVBsYXRmb3JtLkJpYmxlLW9uLUxpbnV4I2luc3RhbGwtYS1rZXlyaW5nLXNlcnZpY2UgZm9yIG1vcmUgaW5mb3JtYXRpb24nO1xuICBpZiAoIXNhZmVTdG9yYWdlLmlzRW5jcnlwdGlvbkF2YWlsYWJsZSgpKSB7XG4gICAgcmV0dXJuICdzYWZlU3RvcmFnZS5pc0VuY3J5cHRpb25BdmFpbGFibGUgcmV0dXJuZWQgZmFsc2UnO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKiBJZiBlbmNyeXB0aW9uIGlzIG5vdCBhdmFpbGFibGUsIHRocm93ICovXG5mdW5jdGlvbiB2YWxpZGF0ZUVuY3J5cHRpb25BdmFpbGFibGUoKSB7XG4gIGNvbnN0IHJlYXNvbiA9IGdldFJlYXNvbkVuY3J5cHRpb25Jc05vdEF2YWlsYWJsZSgpO1xuICBpZiAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaXNFbmNyeXB0aW9uQXZhaWxhYmxlKCkge1xuICByZXR1cm4gZ2V0UmVhc29uRW5jcnlwdGlvbklzTm90QXZhaWxhYmxlKCkgPT09IHVuZGVmaW5lZDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdFN0cmluZyh0ZXh0OiBzdHJpbmcpIHtcbiAgdmFsaWRhdGVFbmNyeXB0aW9uQXZhaWxhYmxlKCk7XG4gIGNvbnN0IGJ1ZmZlciA9IHNhZmVTdG9yYWdlLmVuY3J5cHRTdHJpbmcodGV4dCk7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0U3RyaW5nKGVuY3J5cHRlZFRleHQ6IHN0cmluZykge1xuICB2YWxpZGF0ZUVuY3J5cHRpb25BdmFpbGFibGUoKTtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZW5jcnlwdGVkVGV4dCwgJ2Jhc2U2NCcpO1xuICByZXR1cm4gc2FmZVN0b3JhZ2UuZGVjcnlwdFN0cmluZyhidWZmZXIpO1xufVxuXG5jb25zdCBkYXRhUHJvdGVjdGlvblNlcnZpY2U6IElEYXRhUHJvdGVjdGlvblNlcnZpY2UgPSB7XG4gIGlzRW5jcnlwdGlvbkF2YWlsYWJsZSxcbiAgZW5jcnlwdFN0cmluZyxcbiAgZGVjcnlwdFN0cmluZyxcbn07XG5cbi8qKiBSZWdpc3RlciB0aGUgbmV0d29yayBvYmplY3QgdGhhdCBiYWNrcyB0aGlzIHNlcnZpY2UgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydERhdGFQcm90ZWN0aW9uU2VydmljZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgbmV0d29ya09iamVjdFNlcnZpY2Uuc2V0PElEYXRhUHJvdGVjdGlvblNlcnZpY2U+KFxuICAgIGRhdGFQcm90ZWN0aW9uU2VydmljZU5ldHdvcmtPYmplY3ROYW1lLFxuICAgIGRhdGFQcm90ZWN0aW9uU2VydmljZSxcbiAgKTtcbn1cbiIsImltcG9ydCB7IENoaWxkUHJvY2Vzc1dpdGhvdXROdWxsU3RyZWFtcywgU3Bhd25PcHRpb25zV2l0aG91dFN0ZGlvLCBzcGF3biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBmb3JtYXRMb2csIGxvZ2dlciB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbG9nZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgd2FpdEZvckR1cmF0aW9uIH0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuXG4vKiogUHJldHR5IG5hbWUgZm9yIHRoZSBwcm9jZXNzIHRoaXMgc2VydmljZSBtYW5hZ2VzLiBVc2VkIGluIGxvZ3MgKi9cbmNvbnN0IERPVE5FVF9EQVRBX1BST1ZJREVSX05BTUUgPSAnZG90bmV0IGRhdGEgcHJvdmlkZXInO1xuXG5sZXQgZG90bmV0OiBDaGlsZFByb2Nlc3NXaXRob3V0TnVsbFN0cmVhbXMgfCB1bmRlZmluZWQ7XG5cbmxldCByZXNvbHZlQ2xvc2U6ICh2YWx1ZTogdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+KSA9PiB2b2lkO1xuY29uc3QgY2xvc2VQcm9taXNlOiBQcm9taXNlPHZvaWQ+ID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgcmVzb2x2ZUNsb3NlID0gcmVzb2x2ZTtcbn0pO1xuXG4vLyBsb2cgZnVuY3Rpb25zIGZvciBpbnNpZGUgdGhlIGRhdGEgcHJvdmlkZXIgcHJvY2Vzc1xuZnVuY3Rpb24gbG9nUHJvY2Vzc0Vycm9yKG1lc3NhZ2U6IHVua25vd24pIHtcbiAgbG9nZ2VyLmVycm9yKGZvcm1hdExvZyhtZXNzYWdlPy50b1N0cmluZygpIHx8ICcnLCBET1RORVRfREFUQV9QUk9WSURFUl9OQU1FLCAnZXJyb3InKSk7XG59XG5mdW5jdGlvbiBsb2dQcm9jZXNzSW5mbyhtZXNzYWdlOiB1bmtub3duKSB7XG4gIGxvZ2dlci5pbmZvKGZvcm1hdExvZyhtZXNzYWdlPy50b1N0cmluZygpIHx8ICcnLCBET1RORVRfREFUQV9QUk9WSURFUl9OQU1FKSk7XG59XG5cbi8qKiBIYXJkIGtpbGxzIHRoZSBEb3RuZXQgRGF0YSBQcm92aWRlci4gKi9cbi8vIFRPRE86IGFkZCBhIG1vcmUgZWxlZ2FudCBzaHV0ZG93biB0byBhdm9pZCB0aGlzIGlmIHdlIHBvc3NpYmx5IGNhblxuZnVuY3Rpb24ga2lsbERvdG5ldERhdGFQcm92aWRlcigpIHtcbiAgaWYgKCFkb3RuZXQpIHJldHVybjtcblxuICBpZiAoZG90bmV0LmtpbGwoKSkge1xuICAgIGxvZ2dlci5pbmZvKCdraWxsZWQgZG90bmV0IGRhdGEgcHJvdmlkZXInKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXIuZXJyb3IoJ2RvdG5ldCBkYXRhIHByb3ZpZGVyIHdhcyBub3Qgc3RvcHBlZCEgSW52ZXN0aWdhdGUgb3RoZXIgLmtpbGwoKSBvcHRpb25zJyk7XG4gIH1cbiAgZG90bmV0Py5zdGRlcnI/LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgbG9nUHJvY2Vzc0Vycm9yKTtcbiAgZG90bmV0Py5zdGRvdXQ/LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgbG9nUHJvY2Vzc0luZm8pO1xuICBkb3RuZXQgPSB1bmRlZmluZWQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JEb3RuZXREYXRhUHJvdmlkZXIobWF4V2FpdFRpbWVJbk1TOiBudW1iZXIpIHtcbiAgY29uc3QgZGlkQ2xvc2UgPSBhd2FpdCB3YWl0Rm9yRHVyYXRpb24oYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGNsb3NlUHJvbWlzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbWF4V2FpdFRpbWVJbk1TKTtcblxuICBpZiAoIWRpZENsb3NlKSBraWxsRG90bmV0RGF0YVByb3ZpZGVyKCk7XG59XG5cbi8qKiBTdGFydHMgdGhlIERvdG5ldCBEYXRhIFByb3ZpZGVyIGlmIGl0IGlzbid0IGFscmVhZHkgcnVubmluZy4gKi9cbmZ1bmN0aW9uIHN0YXJ0RG90bmV0RGF0YVByb3ZpZGVyKCkge1xuICBpZiAoZG90bmV0KSByZXR1cm47XG5cbiAgLy8gZGVmYXVsdCB2YWx1ZXMgZm9yIGRldmVsb3BtZW50XG4gIGxldCBjb21tYW5kID0gJ2RvdG5ldCc7XG4gIGxldCBhcmdzOiBzdHJpbmdbXSA9IFsnd2F0Y2gnLCAnLS1wcm9qZWN0JywgJ2Mtc2hhcnAvUGFyYW5leHREYXRhUHJvdmlkZXIuY3Nwcm9qJ107XG4gIGxldCBvcHRpb25zOiBTcGF3bk9wdGlvbnNXaXRob3V0U3RkaW8gfCB1bmRlZmluZWQ7XG5cbiAgaWYgKGdsb2JhbFRoaXMuaXNQYWNrYWdlZCkge1xuICAgIGNvbnN0IGRvdG5ldFBhdGg6IHN0cmluZyA9IHBhdGguam9pbihwcm9jZXNzLnJlc291cmNlc1BhdGgsICdkb3RuZXQnKTtcbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgY29tbWFuZCA9IHBhdGguam9pbihkb3RuZXRQYXRoLCAnUGFyYW5leHREYXRhUHJvdmlkZXIuZXhlJyk7XG4gICAgICBhcmdzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1hbmQgPSBwYXRoLmpvaW4oZG90bmV0UGF0aCwgJ1BhcmFuZXh0RGF0YVByb3ZpZGVyJyk7XG4gICAgICBhcmdzID0gW107XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7IGN3ZDogZG90bmV0UGF0aCB9O1xuICB9XG5cbiAgZG90bmV0ID0gc3Bhd24oY29tbWFuZCwgYXJncywgb3B0aW9ucyk7XG5cbiAgZG90bmV0LnN0ZG91dC5vbignZGF0YScsIGxvZ1Byb2Nlc3NJbmZvKTtcbiAgZG90bmV0LnN0ZGVyci5vbignZGF0YScsIGxvZ1Byb2Nlc3NFcnJvcik7XG5cbiAgZG90bmV0Lm9uY2UoJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgbG9nZ2VyLmluZm8oYCdleGl0JyBldmVudDogZG90bmV0IGRhdGEgcHJvdmlkZXIgdGVybWluYXRlZCB3aXRoIHNpZ25hbCAke3NpZ25hbH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmluZm8oYCdleGl0JyBldmVudDogZG90bmV0IGRhdGEgcHJvdmlkZXIgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCk7XG4gICAgfVxuICAgIGRvdG5ldD8uc3RkZXJyPy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGxvZ1Byb2Nlc3NFcnJvcik7XG4gICAgZG90bmV0Py5zdGRvdXQ/LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgbG9nUHJvY2Vzc0luZm8pO1xuICAgIGRvdG5ldCA9IHVuZGVmaW5lZDtcbiAgICByZXNvbHZlQ2xvc2UoKTtcbiAgfSk7XG5cbiAgZG90bmV0Lm9uY2UoJ2Nsb3NlJywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgaGFuZGxlcyB0aGUgY2xvc2luZyBvZiB0aGUgZGF0YSBwcm92aWRlci4gSG93ZXZlciwgaW4gZGV2ZWxvcG1lbnQsXG4gICAgLy8gdGhpcyBpcyBoYW5kbGluZyB0aGUgY2xvc2luZyBvZiB0aGUgZG90bmV0IHdhdGNoZXIuXG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgbG9nZ2VyLmluZm8oYCdjbG9zZScgZXZlbnQ6IGRvdG5ldCBkYXRhIHByb3ZpZGVyIHRlcm1pbmF0ZWQgd2l0aCBzaWduYWwgJHtzaWduYWx9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5pbmZvKGAnY2xvc2UnIGV2ZW50OiBkb3RuZXQgZGF0YSBwcm92aWRlciBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX1gKTtcbiAgICB9XG4gICAgZG90bmV0Py5zdGRlcnI/LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgbG9nUHJvY2Vzc0Vycm9yKTtcbiAgICBkb3RuZXQ/LnN0ZG91dD8ucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBsb2dQcm9jZXNzSW5mbyk7XG4gICAgZG90bmV0ID0gdW5kZWZpbmVkO1xuICAgIHJlc29sdmVDbG9zZSgpO1xuICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IGRvdG5ldERhdGFQcm92aWRlciA9IHtcbiAgc3RhcnQ6IHN0YXJ0RG90bmV0RGF0YVByb3ZpZGVyLFxuICBraWxsOiBraWxsRG90bmV0RGF0YVByb3ZpZGVyLFxuICB3YWl0Rm9yQ2xvc2U6IHdhaXRGb3JEb3RuZXREYXRhUHJvdmlkZXIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBkb3RuZXREYXRhUHJvdmlkZXI7XG4iLCJpbXBvcnQgeyBwcm90b2NvbCB9IGZyb20gJ2VsZWN0cm9uJztcbmltcG9ydCB7IFN0YXR1c0NvZGVzIH0gZnJvbSAnaHR0cC1zdGF0dXMtY29kZXMnO1xuaW1wb3J0IHsgZXh0ZW5zaW9uQXNzZXRTZXJ2aWNlIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9leHRlbnNpb24tYXNzZXQuc2VydmljZSc7XG5pbXBvcnQgeyBpbmNsdWRlcywgaW5kZXhPZiwgbGFzdEluZGV4T2YsIHN0cmluZ0xlbmd0aCwgc3Vic3RyaW5nIH0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuXG4vKiogSGVyZSBzb21lIG9mIHRoZSBtb3N0IGNvbW1vbiBNSU1FIHR5cGVzIHRoYXQgd2UgZXhwZWN0IHRvIGhhbmRsZSAqL1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9NSU1FX3R5cGVzL0NvbW1vbl90eXBlc1xuLy8gQW4gZXhhbXBsZSBvZiBhIG1vcmUgY29tcGxldGUgbGlzdDogaHR0cHM6Ly93d3cuZnJlZWZvcm1hdHRlci5jb20vbWltZS10eXBlcy1saXN0Lmh0bWxcbmNvbnN0IGtub3duTWltZVR5cGVzID0ge1xuICAnLmJtcCc6ICdpbWFnZS9ibXAnLFxuICAnLmNzcyc6ICd0ZXh0L2NzcycsXG4gICcuY3N2JzogJ3RleHQvY3N2JyxcbiAgJy5naWYnOiAnaW1hZ2UvZ2lmJyxcbiAgJy5odG0nOiAndGV4dC9odG1sJyxcbiAgJy5odG1sJzogJ3RleHQvaHRtbCcsXG4gICcuaWNvJzogJ2ltYWdlL3ZuZC5taWNyb3NvZnQuaWNvbicsXG4gICcuanBlZyc6ICdpbWFnZS9qcGVnJyxcbiAgJy5qcGcnOiAnaW1hZ2UvanBlZycsXG4gICcuanMnOiAndGV4dC9qYXZhc2NyaXB0JyxcbiAgJy5qc29uJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAnLm1qcyc6ICd0ZXh0L2phdmFzY3JpcHQnLFxuICAnLm1wMyc6ICdhdWRpby9tcGVnJyxcbiAgJy5tcDQnOiAndmlkZW8vbXA0JyxcbiAgJy5tcGVnJzogJ3ZpZGVvL21wZWcnLFxuICAnLnBuZyc6ICdpbWFnZS9wbmcnLFxuICAnLnN2Zyc6ICdpbWFnZS9zdmcreG1sJyxcbiAgJy50eHQnOiAndGV4dC9wbGFpbicsXG4gICcud2F2JzogJ2F1ZGlvL3dhdicsXG59O1xuXG4vKiogTG9va3VwIHRoZSBNSU1FIHR5cGUgdG8gcGFzcyBiYWNrIHRvIHRoZSByZW5kZXJlciAqL1xuZnVuY3Rpb24gZ2V0TWltZVR5cGVGb3JGaWxlTmFtZShmaWxlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZG90SW5kZXggPSBsYXN0SW5kZXhPZihmaWxlTmFtZSwgJy4nKTtcbiAgaWYgKGRvdEluZGV4ID4gMCkge1xuICAgIGNvbnN0IGZpbGVUeXBlOiBzdHJpbmcgPSBzdWJzdHJpbmcoZmlsZU5hbWUsIGRvdEluZGV4KTtcbiAgICAvLyBBc3NlcnQga2V5IHR5cGUgY29uZmlybWVkIGluIGNoZWNrLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICAgIGlmIChmaWxlVHlwZSBpbiBrbm93bk1pbWVUeXBlcykgcmV0dXJuIGtub3duTWltZVR5cGVzW2ZpbGVUeXBlIGFzIGtleW9mIHR5cGVvZiBrbm93bk1pbWVUeXBlc107XG4gIH1cblxuICAvLyBEZWZhdWx0IGlmIHdlIGRvbid0IGZpbmQgc29tZXRoaW5nIGVsc2VcbiAgcmV0dXJuICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xufVxuXG4vKiogQ3JlYXRlIGFuIEhUVFAgcmVzcG9uc2UgdG8gcGFzcyBiYWNrIHRvIHRoZSByZW5kZXJlciAqL1xuZnVuY3Rpb24gZXJyb3JSZXNwb25zZSh1cmw6IHN0cmluZywgaHR0cEVycm9yTnVtYmVyOiBudW1iZXIpOiBSZXNwb25zZSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UoYEZhaWxlZCB0byBsb2FkIHJlc291cmNlOiAke3VybH1gLCB7XG4gICAgc3RhdHVzOiBodHRwRXJyb3JOdW1iZXIsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJyxcbiAgICB9LFxuICB9KTtcbn1cblxuY29uc3QgcHJvdG9jb2xOYW1lOiBzdHJpbmcgPSAncGFwaS1leHRlbnNpb24nO1xuXG4vKiogUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhpcyBzZXJ2aWNlIGlzIGZpbmlzaGVkIGluaXRpYWxpemluZyAqL1xubGV0IGluaXRpYWxpemVQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuXG4vKiogUmVnaXN0ZXIgdGhlIHByb3RvY29sIGhhbmRsZXIgZm9yIGV4dGVuc2lvbiBhc3NldCBsb2FkaW5nICovXG5jb25zdCBpbml0aWFsaXplID0gKCkgPT4ge1xuICBpZiAoaW5pdGlhbGl6ZVByb21pc2UpIHJldHVybiBpbml0aWFsaXplUHJvbWlzZTtcblxuICBpbml0aWFsaXplUHJvbWlzZSA9IChhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgcHJvdG9jb2wuaGFuZGxlKHByb3RvY29sTmFtZSwgYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgIC8vIElkZWFzIHRvIGNvbnNpZGVyOlxuICAgICAgLy8gMSkgQ2hlY2sgdGhlIHJlZmVyZXIgZm9yIGxvY2FsaG9zdCB0byBibG9jayBhcmJpdHJhcnkgaW50ZXJuZXQgY29udGVudCBmcm9tIGdldHRpbmcgZXh0ZW5zaW9uIGFzc2V0cy5cbiAgICAgIC8vIDIpIFVzZSByZXF1ZXN0IGhlYWRlcnMgdG8gcGFzcyBhbG9uZyB0aGUgZXh0ZW5zaW9uIG5hbWUgc28gZXh0ZW5zaW9uIGNvZGUgZG9lc24ndCBoYXZlIHRvIGVtYmVkIGl0cyBuYW1lIGluIFVSTHMuXG5cbiAgICAgIC8vIFJlbW92ZSBcInBhcGktZXh0ZW5zaW9uOi8vXCIgZnJvbSB0aGUgZnJvbnQgb2YgdGhlIFVSTFxuICAgICAgY29uc3QgdXJpOiBzdHJpbmcgPSBzdWJzdHJpbmcocmVxdWVzdC51cmwsIHN0cmluZ0xlbmd0aChgJHtwcm90b2NvbE5hbWV9Oi8vYCkpO1xuXG4gICAgICAvLyBUaGVyZSBoYXZlIHRvIGJlIGF0IGxlYXN0IDIgcGFydHMgdG8gdGhlIFVSSSBkaXZpZGVkIGJ5IGEgc2xhc2hcbiAgICAgIGlmICghaW5jbHVkZXModXJpLCAnLycpKSB7XG4gICAgICAgIHJldHVybiBlcnJvclJlc3BvbnNlKHJlcXVlc3QudXJsLCBTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNsYXNoID0gaW5kZXhPZih1cmksICcvJyk7XG4gICAgICBsZXQgZXh0ZW5zaW9uID0gc3Vic3RyaW5nKHVyaSwgMCwgc2xhc2gpO1xuICAgICAgbGV0IGFzc2V0ID0gc3Vic3RyaW5nKHVyaSwgc2xhc2ggKyAxKTtcbiAgICAgIGlmICghZXh0ZW5zaW9uIHx8ICFhc3NldCkge1xuICAgICAgICByZXR1cm4gZXJyb3JSZXNwb25zZShyZXF1ZXN0LnVybCwgU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpO1xuICAgICAgfVxuXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoZSBleHRlbnNpb24gYW5kL29yIGFzc2V0IHdlcmUgZW5jb2RlZCBiZWNhdXNlIHRoZXkgaGF2ZSBjaGFyYWN0ZXJzIG5vdFxuICAgICAgLy8gYWxsb3dlZCBpbiBVUkxzLiBTbyBsZXQncyBkZWNvZGUgYm90aCBvZiB0aGVtIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gdGhlIGV4dGVuc2lvbiBob3N0LlxuICAgICAgZXh0ZW5zaW9uID0gZGVjb2RlVVJJQ29tcG9uZW50KGV4dGVuc2lvbik7XG4gICAgICBhc3NldCA9IGRlY29kZVVSSUNvbXBvbmVudChhc3NldCk7XG4gICAgICBpZiAoc3RyaW5nTGVuZ3RoKGV4dGVuc2lvbikgPiAxMDAgfHwgc3RyaW5nTGVuZ3RoKGFzc2V0KSA+IDEwMCkge1xuICAgICAgICByZXR1cm4gZXJyb3JSZXNwb25zZShyZXF1ZXN0LnVybCwgU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpO1xuICAgICAgfVxuXG4gICAgICAvLyBBY3R1YWxseSBnZXQgdGhlIGRhdGFcbiAgICAgIGNvbnN0IGJhc2U2NERhdGE6IHN0cmluZyB8IHVuZGVmaW5lZCA9IGF3YWl0IGV4dGVuc2lvbkFzc2V0U2VydmljZS5nZXRFeHRlbnNpb25Bc3NldChcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICBhc3NldCxcbiAgICAgICk7XG4gICAgICBpZiAoIWJhc2U2NERhdGEpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yUmVzcG9uc2UocmVxdWVzdC51cmwsIFN0YXR1c0NvZGVzLk5PVF9GT1VORCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgYmFjayB0aGUgZGF0YSB0byB0aGUgcmVuZGVyZXJcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoQnVmZmVyLmZyb20oYmFzZTY0RGF0YSwgJ2Jhc2U2NCcpLCB7XG4gICAgICAgIHN0YXR1czogU3RhdHVzQ29kZXMuT0ssXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogZ2V0TWltZVR5cGVGb3JGaWxlTmFtZShhc3NldCksXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSkoKTtcblxuICByZXR1cm4gaW5pdGlhbGl6ZVByb21pc2U7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBoYW5kbGVyIGZvciBwcm90b2NvbCBzdHJpbmdzIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIGBwYXBpLWV4dGVuc2lvbjovL2V4dGVuc2lvbi1uYW1lL2Fzc2V0cy9hc3NldC54eXpgIC0+IGxvYWQgXCJhc3NldC54eXpcIiBmcm9tIFwiYXNzZXRzXCIgZGlyZWN0b3J5IGluXG4gKiAgIFwiZXh0ZW5zaW9uLW5hbWVcIlxuICogLSBgcGFwaS1leHRlbnNpb246Ly9leHRlbnNpb24tbmFtZS9hc3NldHMvc3ViZGlyZWN0b3J5L2Fzc2V0Lnh5emAgLT4gbG9hZCBcImFzc2V0Lnh5elwiIGZyb21cbiAqICAgXCJhc3NldHMvc3ViZGlyZWN0b3J5XCIgZGlyZWN0b3J5IGluIFwiZXh0ZW5zaW9uLW5hbWVcIlxuICovXG5leHBvcnQgY29uc3QgZXh0ZW5zaW9uQXNzZXRQcm90b2NvbFNlcnZpY2UgPSB7XG4gIGluaXRpYWxpemUsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBleHRlbnNpb25Bc3NldFByb3RvY29sU2VydmljZTtcbiIsIi8qKiBTZXJ2aWNlIHRoYXQgcnVucyB0aGUgZXh0ZW5zaW9uLWhvc3QgcHJvY2VzcyBmcm9tIHRoZSBtYWluIGZpbGUgKi9cblxuaW1wb3J0IHtcbiAgZ2V0Q29tbWFuZExpbmVBcmd1bWVudHNHcm91cCxcbiAgQ09NTUFORF9MSU5FX0FSR1MsXG4gIGNvbW1hbmRMaW5lQXJndW1lbnRzQWxpYXNlcyxcbn0gZnJvbSAnQG5vZGUvdXRpbHMvY29tbWFuZC1saW5lLnV0aWwnO1xuaW1wb3J0IHsgZm9ybWF0TG9nLCBsb2dnZXIsIFdBUk5fVEFHIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9sb2dnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBBc3luY1ZhcmlhYmxlLCBpbmNsdWRlcywgc3BsaXQsIHdhaXRGb3JEdXJhdGlvbiB9IGZyb20gJ3BsYXRmb3JtLWJpYmxlLXV0aWxzJztcbmltcG9ydCB7IENoaWxkUHJvY2VzcywgQ2hpbGRQcm9jZXNzQnlTdGRpbywgZm9yaywgc3Bhd24gfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IGFwcCB9IGZyb20gJ2VsZWN0cm9uJztcbmltcG9ydCB7IFBhdGhMaWtlIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgRmlsZUhhbmRsZSwgcmVhZEZpbGUgfSBmcm9tICdmcy9wcm9taXNlcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCB7IGdyYWNlZnVsU2h1dGRvd25NZXNzYWdlIH0gZnJvbSAnQG5vZGUvbW9kZWxzL2ludGVycHJvY2Vzcy1tZXNzYWdlcy5tb2RlbCc7XG5cbi8qKiBQcmV0dHkgbmFtZSBmb3IgdGhlIHByb2Nlc3MgdGhpcyBzZXJ2aWNlIG1hbmFnZXMuIFVzZWQgaW4gbG9ncyAqL1xuY29uc3QgRVhURU5TSU9OX0hPU1RfTkFNRSA9ICdleHRlbnNpb24gaG9zdCc7XG5cbmxldCBwcm9jZXNzSW5zdGFuY2VDb3VudGVyID0gMDtcbi8vIFJlc29sdmVzIHRvIHRoZSBjdXJyZW50IHByb2Nlc3MgaW5zdGFuY2UgY291bnRlciB2YWx1ZSBmb3IgZGVidWcgbG9nZ2luZyBwdXJwb3Nlc1xubGV0IHByb2Nlc3NMaWZldGltZVZhcmlhYmxlOiBBc3luY1ZhcmlhYmxlPG51bWJlcj4gfCB1bmRlZmluZWQ7XG5sZXQgZXh0ZW5zaW9uSG9zdDogQ2hpbGRQcm9jZXNzIHwgQ2hpbGRQcm9jZXNzQnlTdGRpbzxudWxsLCBSZWFkYWJsZSwgUmVhZGFibGU+IHwgdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBjcmVhdGVOZXdQcm9jZXNzTGlmZXRpbWVWYXJpYWJsZSgpOiB2b2lkIHtcbiAgaWYgKHByb2Nlc3NMaWZldGltZVZhcmlhYmxlKVxuICAgIHRocm93IG5ldyBFcnJvcignUHJldmlvdXMgaW5zdGFuY2Ugb2YgdGhlIGV4dGVuc2lvbiBob3N0IHByb2Nlc3Mgd2FzIG5vdCBjbGVhbmVkIHVwJyk7XG5cbiAgcHJvY2Vzc0luc3RhbmNlQ291bnRlciArPSAxO1xuICBwcm9jZXNzTGlmZXRpbWVWYXJpYWJsZSA9IG5ldyBBc3luY1ZhcmlhYmxlPG51bWJlcj4oXG4gICAgYGV4dGVuc2lvbiBob3N0IHNodXR0aW5nIGRvd24gIyR7cHJvY2Vzc0luc3RhbmNlQ291bnRlci50b1N0cmluZygpfWAsXG4gICAgLTEsXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQcm9jZXNzTGlmZXRpbWVWYXJpYWJsZSgpOiB2b2lkIHtcbiAgaWYgKCFwcm9jZXNzTGlmZXRpbWVWYXJpYWJsZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBob3N0IHByb2Nlc3MgdHJhY2tpbmcgd2FzIG5vdCBwcm9wZXJseSBpbml0aWFsaXplZCcpO1xuXG4gIHByb2Nlc3NMaWZldGltZVZhcmlhYmxlLnJlc29sdmVUb1ZhbHVlKHByb2Nlc3NJbnN0YW5jZUNvdW50ZXIpO1xuICBwcm9jZXNzTGlmZXRpbWVWYXJpYWJsZSA9IHVuZGVmaW5lZDtcbn1cblxuLy8gbG9nIGZ1bmN0aW9ucyBmb3IgaW5zaWRlIHRoZSBleHRlbnNpb24gaG9zdCBwcm9jZXNzXG5mdW5jdGlvbiBsb2dQcm9jZXNzRXJyb3IobWVzc2FnZTogdW5rbm93bikge1xuICBsZXQgbXNnID0gbWVzc2FnZT8udG9TdHJpbmcoKSA/PyAnJztcbiAgaWYgKGluY2x1ZGVzKG1zZywgV0FSTl9UQUcpKSB7XG4gICAgbXNnID0gc3BsaXQobXNnLCBXQVJOX1RBRykuam9pbignJyk7XG4gICAgbG9nZ2VyLndhcm4oZm9ybWF0TG9nKG1zZywgRVhURU5TSU9OX0hPU1RfTkFNRSwgJ3dhcm5pbmcnKSk7XG4gIH0gZWxzZSBsb2dnZXIuZXJyb3IoZm9ybWF0TG9nKG1zZywgRVhURU5TSU9OX0hPU1RfTkFNRSwgJ2Vycm9yJykpO1xufVxuXG5mdW5jdGlvbiBsb2dQcm9jZXNzSW5mbyhtZXNzYWdlOiB1bmtub3duKSB7XG4gIGxvZ2dlci5pbmZvKGZvcm1hdExvZyhtZXNzYWdlPy50b1N0cmluZygpID8/ICcnLCBFWFRFTlNJT05fSE9TVF9OQU1FKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JFeHRlbnNpb25Ib3N0KG1heFdhaXRUaW1lSW5NUzogbnVtYmVyKSB7XG4gIGxldCBkaWRFeGl0ID0gYXdhaXQgd2FpdEZvckR1cmF0aW9uKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXByb2Nlc3NMaWZldGltZVZhcmlhYmxlKSB7XG4gICAgICBsb2dnZXIud2FybignRXh0ZW5zaW9uIGhvc3QgcHJvY2VzcyBsaWZldGltZSB2YXJpYWJsZSB3YXMgbm90IGluaXRpYWxpemVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRoaXMgZG9lcyBub3RoaW5nIGluIGRldmVsb3BtZW50IGJlY2F1c2Ugbm9kZW1vbiBpcyBpbiB0aGUgd2F5LCBidXQgdGhlIGhhcmQga2lsbCB3aWxsIHdvcmtcbiAgICBleHRlbnNpb25Ib3N0Py5zZW5kKGdyYWNlZnVsU2h1dGRvd25NZXNzYWdlLCAoZXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnJvcikgbG9nZ2VyLndhcm4oYEVycm9yIHNlbmRpbmcgZ3JhY2VmdWwgc2h1dGRvd24gbWVzc2FnZTogJHtlcnJvcn1gKTtcbiAgICB9KTtcbiAgICBhd2FpdCBwcm9jZXNzTGlmZXRpbWVWYXJpYWJsZS5wcm9taXNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBtYXhXYWl0VGltZUluTVMgLyAyKTtcblxuICBpZiAoIWRpZEV4aXQpIGhhcmRLaWxsRXh0ZW5zaW9uSG9zdCgpO1xuXG4gIC8vIEdpdmUgdGhlIGhhcmQgXCJraWxsXCIgdGltZSB0byBjb21wbGV0ZSBiZWZvcmUgcmV0dXJuaW5nIHNvIHdlIGRvbid0IHJlc3RhcnQgdG9vIHNvb25cbiAgZGlkRXhpdCA9IGF3YWl0IHdhaXRGb3JEdXJhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgaWYgKHByb2Nlc3NMaWZldGltZVZhcmlhYmxlKSBhd2FpdCBwcm9jZXNzTGlmZXRpbWVWYXJpYWJsZS5wcm9taXNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBtYXhXYWl0VGltZUluTVMgLyAyKTtcblxuICBpZiAoIWRpZEV4aXQpIGxvZ2dlci53YXJuKGBFeHRlbnNpb24gaG9zdCBkaWQgbm90IGV4aXQgd2l0aGluICR7bWF4V2FpdFRpbWVJbk1TLnRvU3RyaW5nKCl9IG1zYCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc3RhcnRFeHRlbnNpb25Ib3N0KG1heFdhaXRUaW1lSW5NUzogbnVtYmVyKSB7XG4gIGlmIChnbG9iYWxUaGlzLmlzUGFja2FnZWQpIHtcbiAgICBhd2FpdCB3YWl0Rm9yRXh0ZW5zaW9uSG9zdChtYXhXYWl0VGltZUluTVMpO1xuICAgIGxvZ2dlci5kZWJ1ZygnRXh0ZW5zaW9uIGhvc3QgY2xvc2VkLCByZXN0YXJ0aW5nIG5vdycpO1xuICAgIHJldHVybiBzdGFydEV4dGVuc2lvbkhvc3QoKTtcbiAgfVxuICAvLyBUZWxscyBub2RlbW9uIHRvIHJlc3RhcnQgdGhlIHByb2Nlc3MgaHR0cHM6Ly9naXRodWIuY29tL3JlbXkvbm9kZW1vbi9ibG9iL0hFQUQvZG9jL2V2ZW50cy5tZCN1c2luZy1ub2RlbW9uLWFzLWNoaWxkLXByb2Nlc3NcbiAgZXh0ZW5zaW9uSG9zdD8uc2VuZCgncmVzdGFydCcpO1xufVxuXG5mdW5jdGlvbiBoYXJkS2lsbEV4dGVuc2lvbkhvc3QoKSB7XG4gIGlmICghZXh0ZW5zaW9uSG9zdCkgcmV0dXJuO1xuXG4gIC8vIE9uIFBPU0lYIHN5c3RlbXMsIFNJR0tJTEwgc2hvdWxkIGltbWVkaWF0ZWx5IHRlcm1pbmF0ZSB0aGUgcHJvY2VzcyBieSB0aGUgT1MuXG4gIC8vIE9uIFdpbmRvd3MgdGhlIHNpZ25hbCBpcyBpZ25vcmVkLiBOb2RlLmpzIHRyaWVzIHRvIGhhcmQga2lsbCB0aGUgcHJvY2VzcyBpbiBzb21lIG90aGVyIHdheS5cbiAgaWYgKGV4dGVuc2lvbkhvc3Qua2lsbCgnU0lHS0lMTCcpKSB7XG4gICAgbG9nZ2VyLmluZm8oJ3NpZ25hbCBzZW50IHRvIGtpbGwgZXh0ZW5zaW9uIGhvc3QgcHJvY2VzcycpO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlci5lcnJvcignZXh0ZW5zaW9uIGhvc3QgcHJvY2VzcyB3YXMgbm90IHN0b3BwZWQhIEludmVzdGlnYXRlIG90aGVyIC5raWxsKCkgb3B0aW9ucycpO1xuICB9XG4gIGV4dGVuc2lvbkhvc3Q/LnN0ZGVycj8ucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBsb2dQcm9jZXNzRXJyb3IpO1xuICBleHRlbnNpb25Ib3N0Py5zdGRvdXQ/LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgbG9nUHJvY2Vzc0luZm8pO1xuICBleHRlbnNpb25Ib3N0ID0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGNvbW1hbmQtbGluZSBhcmd1bWVudHMgdG8gZm9yd2FyZCBmcm9tIG1haW4gKHdoZW4gbGF1bmNoaW5nIHBhcmFuZXh0KSB0b1xuICogdGhlIGV4dGVuc2lvbiBob3N0IHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIGdldENvbW1hbmRMaW5lQXJndW1lbnRzVG9Gb3J3YXJkKCkge1xuICAvLyBQYXNzIHRocm91Z2ggdGhlIHJlbGV2YW50IGNvbW1hbmQtbGluZSBhcmd1bWVudHMgdG8gdGhlIGV4dGVuc2lvbiBob3N0XG4gIHJldHVybiBbXG4gICAgLi4uZ2V0Q29tbWFuZExpbmVBcmd1bWVudHNHcm91cChDT01NQU5EX0xJTkVfQVJHUy5FeHRlbnNpb25zLCB0cnVlKSxcbiAgICAuLi5nZXRDb21tYW5kTGluZUFyZ3VtZW50c0dyb3VwKENPTU1BTkRfTElORV9BUkdTLkV4dGVuc2lvbnNEaXIsIHRydWUpLFxuICBdO1xufVxuXG4vKipcbiAqIFJlYWQgdGhlIGNvbnRlbnRzIG9mIGEgSlNPTiBmaWxlLlxuICpcbiAqIEBwYXJhbSBmaWxlUGF0aCAtIEEgcGF0aCB0byBhIGZpbGUuIElmIGEgVVJMIGlzIHByb3ZpZGVkLCBpdCBtdXN0IHVzZSB0aGUgZmlsZTogcHJvdG9jb2wuIElmIGFcbiAqICAgRmlsZUhhbmRsZSBpcyBwcm92aWRlZCwgdGhlIHVuZGVybHlpbmcgZmlsZSB3aWxsIG5vdCBiZSBjbG9zZWQgYXV0b21hdGljYWxseS5cbiAqIEByZXR1cm5zIFRoZSBKU09OIGZpbGUgY29udGVudHMuXG4gKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcwNjAxNzMzL2R5bmFtaWMtaW1wb3J0LXdpdGgtanNvbi1maWxlLWRvZXNudC13b3JrLXR5cGVzY3JpcHRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZEpzb25GaWxlKGZpbGVQYXRoOiBQYXRoTGlrZSB8IEZpbGVIYW5kbGUpIHtcbiAgY29uc3QgZmlsZSA9IGF3YWl0IHJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcpO1xuICByZXR1cm4gSlNPTi5wYXJzZShmaWxlKTtcbn1cblxuLyoqIFN0YXJ0cyB0aGUgZXh0ZW5zaW9uIGhvc3QgcHJvY2VzcyBpZiBpdCBpc24ndCBhbHJlYWR5IHJ1bm5pbmcuICovXG5hc3luYyBmdW5jdGlvbiBzdGFydEV4dGVuc2lvbkhvc3QoKSB7XG4gIGlmIChleHRlbnNpb25Ib3N0KSByZXR1cm47XG5cbiAgY3JlYXRlTmV3UHJvY2Vzc0xpZmV0aW1lVmFyaWFibGUoKTtcblxuICAvLyBJbiBwcm9kdWN0aW9uLCBmb3JrIGEgbmV3IHByb2Nlc3MgZm9yIHRoZSBleHRlbnNpb24gaG9zdFxuICAvLyBJbiBkZXZlbG9wbWVudCwgc3Bhd24gbm9kZW1vbiB0byB3YXRjaCB0aGUgZXh0ZW5zaW9uLWhvc3RcbiAgLyoqIEFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBleHRlbnNpb24gaG9zdCBubyBtYXR0ZXIgaG93IHdlIHN0YXJ0IHRoZSBwcm9jZXNzICovXG4gIGNvbnN0IHNoYXJlZEFyZ3MgPSBbXG4gICAgY29tbWFuZExpbmVBcmd1bWVudHNBbGlhc2VzW0NPTU1BTkRfTElORV9BUkdTLlJlc291cmNlc1BhdGhdWzBdLFxuICAgIGdsb2JhbFRoaXMucmVzb3VyY2VzUGF0aCxcbiAgICBjb21tYW5kTGluZUFyZ3VtZW50c0FsaWFzZXNbQ09NTUFORF9MSU5FX0FSR1MuTG9nTGV2ZWxdWzBdLFxuICAgIGdsb2JhbFRoaXMubG9nTGV2ZWwsXG4gICAgLi4uZ2V0Q29tbWFuZExpbmVBcmd1bWVudHNUb0ZvcndhcmQoKSxcbiAgXTtcblxuICBpZiAoYXBwLmlzUGFja2FnZWQpIHtcbiAgICBleHRlbnNpb25Ib3N0ID0gZm9yayhcbiAgICAgIHBhdGguam9pbihfX2Rpcm5hbWUsICcuLi9leHRlbnNpb24taG9zdC9leHRlbnNpb24taG9zdC5qcycpLFxuICAgICAgW1xuICAgICAgICBjb21tYW5kTGluZUFyZ3VtZW50c0FsaWFzZXNbQ09NTUFORF9MSU5FX0FSR1MuUGFja2FnZWRdWzBdLFxuICAgICAgICAuLi4ocHJvY2Vzcy5lbnYuUE9SVEFCTEVfRVhFQ1VUQUJMRV9GSUxFXG4gICAgICAgICAgPyBbY29tbWFuZExpbmVBcmd1bWVudHNBbGlhc2VzW0NPTU1BTkRfTElORV9BUkdTLlBvcnRhYmxlXVswXV1cbiAgICAgICAgICA6IFtdKSxcbiAgICAgICAgLi4uc2hhcmVkQXJncyxcbiAgICAgIF0sXG4gICAgICB7XG4gICAgICAgIHN0ZGlvOiBbJ2lnbm9yZScsICdwaXBlJywgJ3BpcGUnLCAnaXBjJ10sXG4gICAgICB9LFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgd2UgYXJlIGluIGRldmVsb3BtZW50LCBnZXQgdGhlIG5vZGVtb24gd2F0Y2ggY29uZmlnIHNvIHdlIGNhbiBwYXNzIGl0IGluIGFsb25nIHdpdGggdGhlXG4gICAgLy8gZXh0ZXJuYWwgZXh0ZW5zaW9uIGRpcmVjdG9yaWVzLlxuICAgIC8vIEZvciB0aGlzIGRldi1vbmx5IGNvZGUsIGl0IGlzIHVzZWZ1bCB0byBiZSBhYmxlIHRvIGdldCB0aGUgbm9kZW1vbi5qc29uIGZpbGUuXG4gICAgY29uc3Qgbm9kZW1vbkNvbmZpZyA9IGF3YWl0IHJlYWRKc29uRmlsZShwYXRoLmpvaW4oZ2xvYmFsVGhpcy5yZXNvdXJjZXNQYXRoLCAnbm9kZW1vbi5qc29uJykpO1xuICAgIGNvbnN0IG5vZGVtb25XYXRjaFBhdGhzOiBzdHJpbmdbXSA9IG5vZGVtb25Db25maWc/LndhdGNoID8gbm9kZW1vbkNvbmZpZy53YXRjaCA6IFtdO1xuXG4gICAgZXh0ZW5zaW9uSG9zdCA9IHNwYXduKFxuICAgICAgJ25vZGUnLFxuICAgICAgW1xuICAgICAgICAnbm9kZV9tb2R1bGVzL25vZGVtb24vYmluL25vZGVtb24uanMnLFxuICAgICAgICAvLyBQcm92aWRlIHRoZSBub2RlbW9uIGNvbmZpZyBwYXRocyBhbmQgY29tbWFuZC1saW5lIGFyZ3VtZW50IGV4dGVuc2lvbiBwYXRocyBhcyB3YXRjaFxuICAgICAgICAvLyBkaXJlY3RvcmllcyBmb3Igbm9kZW1vblxuICAgICAgICAuLi5ub2RlbW9uV2F0Y2hQYXRocy5mbGF0TWFwKCh3YXRjaFBhdGgpID0+IFsnLS13YXRjaCcsIHdhdGNoUGF0aF0pLFxuICAgICAgICAnLS10cmFuc3BpbGUtb25seScsXG4gICAgICAgICcuL3NyYy9leHRlbnNpb24taG9zdC9leHRlbnNpb24taG9zdC50cycsXG4gICAgICAgICctLScsXG4gICAgICAgIC4uLnNoYXJlZEFyZ3MsXG4gICAgICBdLFxuICAgICAge1xuICAgICAgICBzdGRpbzogWydpZ25vcmUnLCAncGlwZScsICdwaXBlJywgJ2lwYyddLFxuICAgICAgICBlbnY6IHsgLi4ucHJvY2Vzcy5lbnYsIE5PREVfRU5WOiAnZGV2ZWxvcG1lbnQnIH0sXG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICBpZiAoIWV4dGVuc2lvbkhvc3Quc3RkZXJyIHx8ICFleHRlbnNpb25Ib3N0LnN0ZG91dClcbiAgICBsb2dnZXIuZXJyb3IoXG4gICAgICBcIkNvdWxkIG5vdCBjb25uZWN0IHRvIGV4dGVuc2lvbiBob3N0J3Mgc3RkZXJyIG9yIHN0ZG91dCEgWW91IHdpbGwgbm90IHNlZSBleHRlbnNpb24gaG9zdCBjb25zb2xlIGxvZ3MgaGVyZS5cIixcbiAgICApO1xuICBlbHNlIHtcbiAgICBleHRlbnNpb25Ib3N0LnN0ZGVyci5vbignZGF0YScsIGxvZ1Byb2Nlc3NFcnJvcik7XG4gICAgZXh0ZW5zaW9uSG9zdC5zdGRvdXQub24oJ2RhdGEnLCBsb2dQcm9jZXNzSW5mbyk7XG4gIH1cblxuICBleHRlbnNpb25Ib3N0Lm9uY2UoJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgbG9nZ2VyLmluZm8oYCdleGl0JyBldmVudDogZXh0ZW5zaW9uIGhvc3QgcHJvY2VzcyB0ZXJtaW5hdGVkIHdpdGggc2lnbmFsICR7c2lnbmFsfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuaW5mbyhgJ2V4aXQnIGV2ZW50OiBleHRlbnNpb24gaG9zdCBwcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWApO1xuICAgIH1cbiAgICBleHRlbnNpb25Ib3N0Py5zdGRlcnI/LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgbG9nUHJvY2Vzc0Vycm9yKTtcbiAgICBleHRlbnNpb25Ib3N0Py5zdGRvdXQ/LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgbG9nUHJvY2Vzc0luZm8pO1xuICAgIGV4dGVuc2lvbkhvc3QgPSB1bmRlZmluZWQ7XG4gICAgcmVzb2x2ZVByb2Nlc3NMaWZldGltZVZhcmlhYmxlKCk7XG4gIH0pO1xufVxuXG4vKiogU2VydmljZSB0aGF0IHJ1bnMgdGhlIGV4dGVuc2lvbi1ob3N0IHByb2Nlc3MgZnJvbSB0aGUgbWFpbiBmaWxlICovXG5leHBvcnQgY29uc3QgZXh0ZW5zaW9uSG9zdFNlcnZpY2UgPSB7XG4gIHN0YXJ0OiBzdGFydEV4dGVuc2lvbkhvc3QsXG4gIGtpbGw6IGhhcmRLaWxsRXh0ZW5zaW9uSG9zdCxcbiAgd2FpdEZvckNsb3NlOiB3YWl0Rm9yRXh0ZW5zaW9uSG9zdCxcbiAgcmVzdGFydDogcmVzdGFydEV4dGVuc2lvbkhvc3QsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBleHRlbnNpb25Ib3N0U2VydmljZTtcbiIsImltcG9ydCB7IE5ldHdvcmtPYmplY3REZXRhaWxzIH0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvbmV0d29yay1vYmplY3QubW9kZWwnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9sb2dnZXIuc2VydmljZSc7XG5pbXBvcnQge1xuICBOZXR3b3JrT2JqZWN0U3RhdHVzUmVtb3RlU2VydmljZVR5cGUsXG4gIG5ldHdvcmtPYmplY3RTdGF0dXNTZXJ2aWNlTmV0d29ya09iamVjdE5hbWUsXG59IGZyb20gJ0BzaGFyZWQvbW9kZWxzL25ldHdvcmstb2JqZWN0LXN0YXR1cy5zZXJ2aWNlLW1vZGVsJztcbmltcG9ydCB7XG4gIG5ldHdvcmtPYmplY3RTZXJ2aWNlLFxuICBvbkRpZENyZWF0ZU5ldHdvcmtPYmplY3QsXG4gIG9uRGlkRGlzcG9zZU5ldHdvcmtPYmplY3QsXG59IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbmV0d29yay1vYmplY3Quc2VydmljZSc7XG5cbi8vIFdlIGFyZSBhc3N1bWluZyB0aGVzZSBldmVudHMgZ2V0IGhvb2tlZCB1cCBiZWZvcmUgYW55IG5ldHdvcmsgb2JqZWN0cyBnZXQgcmVnaXN0ZXJlZC4gVGhhdCBhbGxvd3Ncbi8vIHVzIHRvIHN0YXJ0IGZyb20gYSBjbGVhbiBtYXAuIElmIHNvbWVob3cgbmV0d29yayBvYmplY3RzIGNhbiBiZSByZWdpc3RlcmVkIGJlZm9yZSB3ZSBob29rIHVwXG4vLyB0aGUgZXZlbnRzLCB0aGVuIHdlIGhhdmUgdG8gZmlndXJlIG91dCBhIHdheSB0byBpbnNlcnQgcHJlLWV4aXN0aW5nIG9iamVjdHMgaW50byB0aGUgbWFwIGluIGEgd2F5XG4vLyB0aGF0IGF2b2lkcyByYWNlIGNvbmRpdGlvbnMgd2l0aCB0aGUgZXZlbnRzIHRoYXQgZmlyZSBhcm91bmQgdGhlIHNhbWUgdGltZS5cbmNvbnN0IG5ldHdvcmtPYmplY3RJRHNUb0RldGFpbHMgPSBuZXcgTWFwPHN0cmluZywgTmV0d29ya09iamVjdERldGFpbHM+KCk7XG5cbm9uRGlkQ3JlYXRlTmV0d29ya09iamVjdCgobmV0d29ya09iamVjdERldGFpbHMpID0+IHtcbiAgaWYgKG5ldHdvcmtPYmplY3RJRHNUb0RldGFpbHMuaGFzKG5ldHdvcmtPYmplY3REZXRhaWxzLmlkKSlcbiAgICBsb2dnZXIud2FybihgUmUtc2F2aW5nIG5ldHdvcmsgb2JqZWN0IGRldGFpbHMgZm9yICR7bmV0d29ya09iamVjdERldGFpbHMuaWR9YCk7XG4gIG5ldHdvcmtPYmplY3RJRHNUb0RldGFpbHMuc2V0KG5ldHdvcmtPYmplY3REZXRhaWxzLmlkLCBuZXR3b3JrT2JqZWN0RGV0YWlscyk7XG59KTtcblxub25EaWREaXNwb3NlTmV0d29ya09iamVjdCgobmV0d29ya09iamVjdElkKSA9PiB7XG4gIGlmICghbmV0d29ya09iamVjdElEc1RvRGV0YWlscy5kZWxldGUobmV0d29ya09iamVjdElkKSlcbiAgICBsb2dnZXIud2FybihgTm90aWZpY2F0aW9uIG9mIGRpc3Bvc2VkIG9iamVjdCAke25ldHdvcmtPYmplY3RJZH0gdGhhdCB3YXMgcHJldmlvdXNseSB1bmtub3duYCk7XG59KTtcblxuLy8gTWFraW5nIHRoaXMgYXN5bmMgdG8gYWxpZ24gd2l0aCB0aGUgc2VydmljZSBtb2RlbCBldmVuIHRob3VnaCBpdCBjb3VsZCByZWFsbHkgYmUgc3luY2hyb25vdXNcbmFzeW5jIGZ1bmN0aW9uIGdldEFsbE5ldHdvcmtPYmplY3REZXRhaWxzKCk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgTmV0d29ya09iamVjdERldGFpbHM+PiB7XG4gIGNvbnN0IGFsbE5ldHdvcmtPYmplY3REZXRhaWxzOiBSZWNvcmQ8c3RyaW5nLCBOZXR3b3JrT2JqZWN0RGV0YWlscz4gPSB7fTtcbiAgbmV0d29ya09iamVjdElEc1RvRGV0YWlscy5mb3JFYWNoKCh2YWx1ZTogTmV0d29ya09iamVjdERldGFpbHMsIGtleTogc3RyaW5nKSA9PiB7XG4gICAgYWxsTmV0d29ya09iamVjdERldGFpbHNba2V5XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhbGxOZXR3b3JrT2JqZWN0RGV0YWlscyk7XG59XG5cbmNvbnN0IG5ldHdvcmtPYmplY3RTdGF0dXNTZXJ2aWNlOiBOZXR3b3JrT2JqZWN0U3RhdHVzUmVtb3RlU2VydmljZVR5cGUgPSB7XG4gIGdldEFsbE5ldHdvcmtPYmplY3REZXRhaWxzLFxufTtcblxuLyoqIFJlZ2lzdGVyIHRoZSBuZXR3b3JrIG9iamVjdCB0aGF0IGJhY2tzIHRoZSBuZXR3b3JrIG9iamVjdCBzdGF0dXMgc2VydmljZSAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0TmV0d29ya09iamVjdFN0YXR1c1NlcnZpY2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IG5ldHdvcmtPYmplY3RTZXJ2aWNlLnNldDxOZXR3b3JrT2JqZWN0U3RhdHVzUmVtb3RlU2VydmljZVR5cGU+KFxuICAgIG5ldHdvcmtPYmplY3RTdGF0dXNTZXJ2aWNlTmV0d29ya09iamVjdE5hbWUsXG4gICAgbmV0d29ya09iamVjdFN0YXR1c1NlcnZpY2UsXG4gICk7XG59XG4iLCJpbXBvcnQge1xuICBORVRXT1JLX09CSkVDVF9OQU1FX1BST0pFQ1RfTE9PS1VQX1NFUlZJQ0UsXG4gIFByb2plY3RMb29rdXBTZXJ2aWNlVHlwZSxcbiAgcHJvamVjdExvb2t1cFNlcnZpY2VCYXNlLFxufSBmcm9tICdAc2hhcmVkL21vZGVscy9wcm9qZWN0LWxvb2t1cC5zZXJ2aWNlLW1vZGVsJztcbmltcG9ydCB7IG5ldHdvcmtPYmplY3RTZXJ2aWNlIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9uZXR3b3JrLW9iamVjdC5zZXJ2aWNlJztcblxuY29uc3QgcHJvamVjdExvb2t1cFNlcnZpY2UgPSBwcm9qZWN0TG9va3VwU2VydmljZUJhc2U7XG5cbi8qKlxuICogUmVnaXN0ZXIgdGhlIG5ldHdvcmsgb2JqZWN0IHRoYXQgbWlycm9ycyB0aGUgbG9jYWxseS1ydW4gcHJvamVjdCBsb29rdXAgc2VydmljZSBleHBvc2VkIG9uIHRoZVxuICogUEFQSSB3ZWJzb2NrZXQuXG4gKlxuICogVGhpcyBzZXJ2aWNlIHJ1bnMgZnVsbHkgbG9jYWxseSBmcm9tIGBwcm9qZWN0LWxvb2t1cC5zZXJ2aWNlLnRzYC4gVGhpcyBpcyBoZXJlIHRvIHByb3ZpZGVcbiAqIGxvb2t1cC1yZWxhdGVkIHNlcnZpY2VzIHRvIG90aGVyIHByb2Nlc3NlcyBvbiB0aGUgUEFQSSB3ZWJzb2NrZXRcbiAqL1xuLy8gVG8gdXNlIHRoaXMgc2VydmljZSwgeW91IHNob3VsZCB1c2UgYHByb2plY3QtbG9va3VwLnNlcnZpY2UudHNgLlxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UHJvamVjdExvb2t1cFNlcnZpY2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IG5ldHdvcmtPYmplY3RTZXJ2aWNlLnNldDxQcm9qZWN0TG9va3VwU2VydmljZVR5cGU+KFxuICAgIE5FVFdPUktfT0JKRUNUX05BTUVfUFJPSkVDVF9MT09LVVBfU0VSVklDRSxcbiAgICBwcm9qZWN0TG9va3VwU2VydmljZSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIHtcbiAgICAgIHN1bW1hcnk6ICdQcm92aWRlcyBtZXRhZGF0YSBmb3IgcHJvamVjdHMga25vd24gYnkgdGhlIHBsYXRmb3JtJyxcbiAgICAgIG1ldGhvZHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdnZXRNZXRhZGF0YUZvckFsbFByb2plY3RzJyxcbiAgICAgICAgICBzdW1tYXJ5OiAnUHJvdmlkZSBtZXRhZGF0YSBmb3IgYWxsIHByb2plY3RzIHRoYXQgaGF2ZSBQRFAgZmFjdG9yaWVzJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICdOb3RlOiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgUERQcyBhdmFpbGFibGUgd2hvc2UgbWV0YWRhdGEgbWF0Y2hlcyB0aGUgY29uZGl0aW9ucyBwcm92aWRlZCBieSB0aGUgcGFyYW1ldGVycywgdGhlaXIgcHJvamVjdCBtZXRhZGF0YSB3aWxsIGFsbCBiZSBjb21iaW5lZCwgc28gYWxsIGF2YWlsYWJsZSBgcHJvamVjdEludGVyZmFjZWBzIHByb3ZpZGVkIGJ5IHRoZSBQRFAgRmFjdG9yeSB3aXRoIHRoZSBtYXRjaGluZyBJRCAob3IgYWxsIFBEUCBGYWN0b3JpZXMgaWYgbm8gSUQgaXMgc3BlY2lmaWVkKSBmb3IgdGhlIHByb2plY3Qgd2lsbCBiZSByZXR1cm5lZC4nLFxuICAgICAgICAgIHBhcmFtczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiAnb3B0aW9ucycsXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgc3VtbWFyeTpcbiAgICAgICAgICAgICAgICAnT3B0aW9ucyBmb3Igc3BlY2lmeWluZyBmaWx0ZXJzIGZvciB0aGUgcHJvamVjdCBtZXRhZGF0YSByZXRyaWV2ZWQuIElmIGEgUERQIEZhY3RvcnkgSUQgZG9lcyBub3QgbWF0Y2ggdGhlIGZpbHRlciwgaXQgd2lsbCBub3QgYmUgY29udGFjdGVkIGF0IGFsbCBmb3IgdGhpcyBmdW5jdGlvbiBjYWxsLiBBcyBhIHJlc3VsdCwgYSBQRFAgZmFjdG9yeSB0aGF0IGludGVuZHMgdG8gbGF5ZXIgb3ZlciBvdGhlciBQRFAgZmFjdG9yaWVzICoqbXVzdCoqIHNwZWNpZnkgaXRzIElEIGluIGBvcHRpb25zLmV4Y2x1ZGVQZHBGYWN0b3J5SWRzYCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wIG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi4nLFxuICAgICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAkcmVmOiAnIy9jb21wb25lbnRzL3NjaGVtYXMvUHJvamVjdE1ldGFkYXRhRmlsdGVyT3B0aW9ucycsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICBuYW1lOiAncmV0dXJuIHZhbHVlJyxcbiAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgICAgICRyZWY6ICcjL2NvbXBvbmVudHMvc2NoZW1hcy9Qcm9qZWN0TWV0YWRhdGEnLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgc2NoZW1hczoge1xuICAgICAgICAgIFByb2plY3RNZXRhZGF0YToge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdJRCBvZiB0aGUgcHJvamVjdCAobXVzdCBiZSB1bmlxdWUgYW5kIGNhc2UgaW5zZW5zaXRpdmUpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcHJvamVjdEludGVyZmFjZXM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgICAgICAgJ0FsbCBgcHJvamVjdEludGVyZmFjZWBzIChha2Egc3RhbmRhcmRpemVkIHNldHMgb2YgbWV0aG9kcyBvbiBhIFBEUCkgdGhhdCBQcm9qZWN0IERhdGEgUHJvdmlkZXJzIGZvciB0aGlzIHByb2plY3Qgc3VwcG9ydC4gSW5kaWNhdGVzIHdoYXQgc29ydCBvZiBwcm9qZWN0IGRhdGEgc2hvdWxkIGJlIGF2YWlsYWJsZSBvbiB0aGlzIHByb2plY3QuJyxcbiAgICAgICAgICAgICAgICBpdGVtczogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwZHBGYWN0b3J5SW5mbzoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW5mb3JtYXRpb24gYWJvdXQgdGhlIFBEUCBGYWN0b3JpZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm9qZWN0LicsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgUHJvamVjdE1ldGFkYXRhRmlsdGVyT3B0aW9uczoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIGluY2x1ZGVQZHBGYWN0b3J5SWRzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0xpc3Qgb2YgUERQIEZhY3RvcnkgSWRzIHRvIGluY2x1ZGUgaW4gdGhlIG1ldGFkYXRhIHJldHJpZXZhbC4nLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBleGNsdWRlUGRwRmFjdG9yeUlkczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdMaXN0IG9mIFBEUCBGYWN0b3J5IElkcyB0byBleGNsdWRlIGZyb20gdGhlIG1ldGFkYXRhIHJldHJpZXZhbC4nLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwcm9qZWN0SWRzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0xpc3Qgb2YgcHJvamVjdCBJZHMgdG8gZmlsdGVyIHRoZSBtZXRhZGF0YSByZXRyaWV2YWwuJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ09wdGlvbnMgZm9yIHNwZWNpZnlpbmcgZmlsdGVycyBmb3IgdGhlIHByb2plY3QgbWV0YWRhdGEgcmV0cmlldmVkLicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgKTtcbn1cbiIsImV4cG9ydCBjb25zdCBncmFjZWZ1bFNodXRkb3duTWVzc2FnZSA9ICdncmFjZWZ1bFNodXRkb3duJztcbmV4cG9ydCBjb25zdCBoZWFydGJlYXRNZXNzYWdlID0gJ2hlYXJ0YmVhdCc7XG4iLCJpbXBvcnQgeyBnZXRBcHBEaXIgfSBmcm9tICdAbm9kZS91dGlscy91dGlsJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZSB9IGZyb20gJ25vZGUtbG9jYWxzdG9yYWdlJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG4vKiogUG9seWZpbGxzIExvY2FsU3RvcmFnZSBpbnRvIG5vZGUgc28geW91IGNhbiB1c2UgbG9jYWxzdG9yYWdlIGp1c3QgbGlrZSBpbiBhIGJyb3dzZXIgKi9cbmV4cG9ydCBjb25zdCBwb2x5ZmlsbExvY2FsU3RvcmFnZSA9ICgpID0+IHtcbiAgLy8gUG9seWZpbGwgbG9naWMgbmVlZHMgbnVsbFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbnVsbC9uby1udWxsXG4gIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID09PSAndW5kZWZpbmVkJyB8fCBsb2NhbFN0b3JhZ2UgPT09IG51bGwpIHtcbiAgICBnbG9iYWwubG9jYWxTdG9yYWdlID0gbmV3IExvY2FsU3RvcmFnZShcbiAgICAgIHBhdGguam9pbihnZXRBcHBEaXIoKSwgYGxvY2FsLXN0b3JhZ2UvJHtnbG9iYWxUaGlzLnByb2Nlc3NUeXBlfS9gKSxcbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwb2x5ZmlsbExvY2FsU3RvcmFnZTtcbiIsImltcG9ydCB7IHNlcmlhbGl6ZVJlcXVlc3RUeXBlIH0gZnJvbSAnQHNoYXJlZC91dGlscy91dGlsJztcblxuLyoqIFByZWZpeCBvbiByZXF1ZXN0cyB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IGlzIHJlbGF0ZWQgdG8gZXh0ZW5zaW9uIHNlcnZpY2Ugb3BlcmF0aW9ucyAqL1xuZXhwb3J0IGNvbnN0IENBVEVHT1JZX0VYVEVOU0lPTl9TRVJWSUNFID0gJ2V4dGVuc2lvblNlcnZpY2UnO1xuXG4vKiogU2VyaWFsaXplZCByZXF1ZXN0IHR5cGUgZm9yIHJlcXVlc3Qgc2VudCBmcm9tIG1haW4gdG8gZXh0ZW5zaW9uIHNlcnZpY2UgdG8gaGFuZGxlIGEgdXJpIHJlZGlyZWN0ICovXG5leHBvcnQgY29uc3QgSEFORExFX1VSSV9SRVFVRVNUX1RZUEUgPSBzZXJpYWxpemVSZXF1ZXN0VHlwZShcbiAgQ0FURUdPUllfRVhURU5TSU9OX1NFUlZJQ0UsXG4gICdoYW5kbGVVcmknLFxuKTtcbiIsImltcG9ydCB7IHN0YXJ0c1dpdGggfSBmcm9tICdwbGF0Zm9ybS1iaWJsZS11dGlscyc7XG5cbi8qKiBBbGwgY29tbWFuZCBsaW5lIGFyZ3VtZW50cyBtYXBwZWQgZnJvbSBhcmd1bWVudCB0eXBlIHRvIGFycmF5IG9mIGFsaWFzZXMgZm9yIHRoZSBhcmd1bWVudCAqL1xudHlwZSBDb21tYW5kTGluZUFyZ3VtZW50QWxpYXNlcyA9IHtcbiAgW2FyZ3VtZW50IGluIENPTU1BTkRfTElORV9BUkdTXTogc3RyaW5nW107XG59O1xuXG4vKipcbiAqIENvbW1hbmQgTGluZSBBcmd1bWVudHNcbiAqXG4gKiAtIEV4dGVuc2lvbnMgLSBDb21tYW5kLWxpbmUgYXJndW1lbnQgdGhhdCBzcGVjaWZpZXMgZXh0cmEgaW5kaXZpZHVhbCBleHRlbnNpb24gZm9sZGVyc1xuICogLSBFeHRlbnNpb25zRGlyIC0gQ29tbWFuZC1saW5lIGFyZ3VtZW50IHRoYXQgc3BlY2lmaWVzIGV4dHJhIGV4dGVuc2lvbiBkaXJlY3RvcmllcyBpbiB3aGljaCB0b1xuICogICBjaGVjayBhbGwgY29udGFpbmVkIGZvbGRlcnMgZm9yIGV4dGVuc2lvbnNcbiAqIC0gTG9nTGV2ZWwgLSBDb21tYW5kLWxpbmUgYXJndW1lbnQgdGhhdCBzcGVjaWZpZXMgbG9nIGxldmVsIHRvIHVzZSBPcHRpb25zOiAnZXJyb3InIHwgJ3dhcm4nIHxcbiAqICAgJ2luZm8nIHwgJ3ZlcmJvc2UnIHwgJ2RlYnVnJ1xuICogLSBSZXNvdXJjZXNQYXRoIC0gQ29tbWFuZC1saW5lIGFyZ3VtZW50IHRoYXQgc3BlY2lmaWVzIHRoZSBwYXRoIHRvIHRoZSByZXNvdXJjZXMgZm9sZGVyXG4gKiAtIFBhY2thZ2VkIC0gQ29tbWFuZC1saW5lIHN3aXRjaCB0aGF0IHNwZWNpZmllcyBpZiB0aGUgYXBwbGljYXRpb24gaXMgcGFja2FnZWQuIE9ubHkgb25cbiAqICAgZXh0ZW5zaW9uLWhvc3RcbiAqIC0gUG9ydGFibGUgLSBDb21tYW5kLWxpbmUgc3dpdGNoIHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBhcHBsaWNhdGlvbiBpcyBhIHdpbmRvd3MgcG9ydGFibGUgYXBwLiBPbmx5XG4gKiAgIG9uIGV4dGVuc2lvbi1ob3N0XG4gKi9cbmV4cG9ydCBlbnVtIENPTU1BTkRfTElORV9BUkdTIHtcbiAgRXh0ZW5zaW9ucyA9ICdleHRlbnNpb25zJyxcbiAgRXh0ZW5zaW9uc0RpciA9ICdleHRlbnNpb25zX2RpcicsXG4gIExvZ0xldmVsID0gJ2xvZ19sZXZlbCcsXG4gIFJlc291cmNlc1BhdGggPSAncmVzb3VyY2VzX3BhdGgnLFxuICBQYWNrYWdlZCA9ICdwYWNrYWdlZCcsXG4gIFBvcnRhYmxlID0gJ3BvcnRhYmxlJyxcbn1cblxuLyoqXG4gKiBBbGlhc2VzIGZvciBlYWNoIGNvbW1hbmQgbGluZSBhcmd1bWVudCBtYXBwZWQgZnJvbSBhcmd1bWVudCB0eXBlIHRvIGFuIGFycmF5IG9mIGFsaWFzZXMgZm9yIHRoYXRcbiAqIGFyZ3VtZW50IHR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbW1hbmRMaW5lQXJndW1lbnRzQWxpYXNlczogQ29tbWFuZExpbmVBcmd1bWVudEFsaWFzZXMgPSB7XG4gIFtDT01NQU5EX0xJTkVfQVJHUy5FeHRlbnNpb25zXTogWyctLWV4dGVuc2lvbnMnLCAnLS1leHRlbnNpb24nLCAnLWUnXSxcbiAgW0NPTU1BTkRfTElORV9BUkdTLkV4dGVuc2lvbnNEaXJdOiBbJy0tZXh0ZW5zaW9uRGlycycsICctLWV4dGVuc2lvbkRpcicsICctZCddLFxuICBbQ09NTUFORF9MSU5FX0FSR1MuTG9nTGV2ZWxdOiBbJy0tbG9nTGV2ZWxzJywgJy0tbG9nTGV2ZWwnLCAnLWwnXSxcbiAgW0NPTU1BTkRfTElORV9BUkdTLlJlc291cmNlc1BhdGhdOiBbJy0tcmVzb3VyY2VzUGF0aCcsICctLXJlc291cmNlUGF0aCcsICctciddLFxuICBbQ09NTUFORF9MSU5FX0FSR1MuUGFja2FnZWRdOiBbJy0tcGFja2FnZWQnLCAnLS1pc1BhY2thZ2VkJywgJy1wJ10sXG4gIFtDT01NQU5EX0xJTkVfQVJHUy5Qb3J0YWJsZV06IFsnLS1wb3J0YWJsZSddLFxufTtcblxuLyoqIEdldCB0aGUgaW5kZXggb2YgdGhlIG5leHQgY29tbWFuZC1saW5lIGFyZ3VtZW50IGFmdGVyIHRoZSBzdGFydEluZGV4ICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5leHRDb21tYW5kTGluZUFyZ3VtZW50SW5kZXgoY3VycmVudEFyZ0luZGV4OiBudW1iZXIpIHtcbiAgbGV0IGVuZE9mRXh0ZW5zaW9uc0luZGV4ID0gcHJvY2Vzcy5hcmd2Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IGN1cnJlbnRBcmdJbmRleCArIDE7IGkgPCBwcm9jZXNzLmFyZ3YubGVuZ3RoOyBpKyspXG4gICAgaWYgKHN0YXJ0c1dpdGgocHJvY2Vzcy5hcmd2W2ldLCAnLScpKSB7XG4gICAgICBlbmRPZkV4dGVuc2lvbnNJbmRleCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBlbmRPZkV4dGVuc2lvbnNJbmRleDtcbn1cblxuLyoqXG4gKiBHZXQgYSBjb21tYW5kLWxpbmUgYXJndW1lbnQncyBncm91cCBvZiBhcmd1bWVudHMuIElmIG5vIGFyZ3VtZW50cyBhcmUgaW4gaXRzIGdyb3VwLCByZXR1cm5cbiAqIG5vdGhpbmdcbiAqXG4gKiBAcGFyYW0gYXJnTmFtZSBOYW1lKHMpIG9mIHRoZSBjb21tYW5kLWxpbmUgYXJndW1lbnQgdG8gc2VhcmNoIGZvclxuICogQHBhcmFtIHNob3VsZEluY2x1ZGVBcmdOYW1lIFdoZXRoZXIgdG8gaW5jbHVkZSBgYXJnTmFtZWAgYXQgdGhlIHN0YXJ0IG9mIHRoZSByZXR1cm5lZCBhcnJheVxuICogQHJldHVybnMgQXJyYXkgb2Ygc3RyaW5ncyBvZiB0aGUgY29tbWFuZC1saW5lIGFyZ3MgaW4gdGhpcyBjb21tYW5kLWxpbmUgYXJndW1lbnQgZ3JvdXBcbiAqXG4gKiAgIEV4OiAnLS10aGluZ3MgYmVuIGNodWNrIGplcnJ5J1xuICpcbiAqICAgLSBgZ2V0Q29tbWFuZExpbmVBcmd1bWVudHNHcm91cCgnLS10aGluZ3MnKWAgcmV0dXJucyBgWydiZW4nLCAnY2h1Y2snLCAnamVycnknXWBcbiAqICAgLSBgZ2V0Q29tbWFuZExpbmVBcmd1bWVudHNHcm91cCgnLS10aGluZ3MnLCB0cnVlKWAgcmV0dXJucyBgWyctLXRoaW5ncycsICdiZW4nLCAnY2h1Y2snLCAnamVycnknXWBcbiAqXG4gKiAgIEV4OiAnLS10aGluZ3MgLS1zdHVmZiBiZW4gY2h1Y2sgamVycnknXG4gKlxuICogICAtIGBnZXRDb21tYW5kTGluZUFyZ3VtZW50c0dyb3VwKCctLXRoaW5ncycpYCByZXR1cm5zIGBbXWBcbiAqICAgLSBgZ2V0Q29tbWFuZExpbmVBcmd1bWVudHNHcm91cCgnLS10aGluZ3MnLCB0cnVlKWAgcmV0dXJucyBgWyctLXRoaW5ncyddYFxuICpcbiAqICAgRXg6ICctLXN0dWZmIGJlbiBjaHVjayBqZXJyeSdcbiAqXG4gKiAgIC0gYGdldENvbW1hbmRMaW5lQXJndW1lbnRzR3JvdXAoJy0tdGhpbmdzJylgIHJldHVybnMgYFtdYFxuICogICAtIGBnZXRDb21tYW5kTGluZUFyZ3VtZW50c0dyb3VwKCctLXRoaW5ncycsIHRydWUpYCByZXR1cm5zIGBbXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1hbmRMaW5lQXJndW1lbnRzR3JvdXAoXG4gIGFyZ05hbWU6IENPTU1BTkRfTElORV9BUkdTLFxuICBzaG91bGRJbmNsdWRlQXJnTmFtZSA9IGZhbHNlLFxuKTogc3RyaW5nW10ge1xuICBjb25zdCBhcmdOYW1lczogc3RyaW5nW10gPSBjb21tYW5kTGluZUFyZ3VtZW50c0FsaWFzZXNbYXJnTmFtZV07XG5cbiAgY29uc3QgYXJndW1lbnRzR3JvdXA6IHN0cmluZ1tdID0gW107XG4gIGFyZ05hbWVzXG4gICAgLmZpbHRlcigobikgPT4gcHJvY2Vzcy5hcmd2LmluZGV4T2YobikgPj0gMClcbiAgICAuZm9yRWFjaCgoYXJnKSA9PiB7XG4gICAgICBjb25zdCBhcmdJbmRleCA9IHByb2Nlc3MuYXJndi5pbmRleE9mKGFyZyk7XG4gICAgICBjb25zdCBiYXNlQXJyYXkgPSBzaG91bGRJbmNsdWRlQXJnTmFtZSA/IFthcmddIDogW107XG5cbiAgICAgIGFyZ3VtZW50c0dyb3VwLnB1c2goXG4gICAgICAgIC4uLihwcm9jZXNzLmFyZ3YubGVuZ3RoID4gYXJnSW5kZXggKyAxXG4gICAgICAgICAgPyBbXG4gICAgICAgICAgICAgIC4uLmJhc2VBcnJheSxcbiAgICAgICAgICAgICAgLi4ucHJvY2Vzcy5hcmd2LnNsaWNlKGFyZ0luZGV4ICsgMSwgZmluZE5leHRDb21tYW5kTGluZUFyZ3VtZW50SW5kZXgoYXJnSW5kZXgpKSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICA6IGJhc2VBcnJheSksXG4gICAgICApO1xuICAgIH0pO1xuXG4gIHJldHVybiBhcmd1bWVudHNHcm91cDtcbn1cblxuLyoqXG4gKiBHZXQgYSBjb21tYW5kLWxpbmUgYXJndW1lbnQncyBhcmd1bWVudC4gSWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBwcmVzZW50LCByZXR1cm4gYHVuZGVmaW5lZGBcbiAqXG4gKiBAcGFyYW0gYXJnTmFtZSBOYW1lIGFuZCBhbGlhc2VzIG9mIHRoZSBjb21tYW5kLWxpbmUgYXJndW1lbnQgdG8gc2VhcmNoIGZvclxuICogQHJldHVybnMgU3RyaW5nIG9mIHRoZSBjb21tYW5kLWxpbmUgYXJnIHByb3ZpZGVkXG4gKlxuICogICBFeDogJy0tdGhpbmcgYmVuJ1xuICpcbiAqICAgLSBgZ2V0Q29tbWFuZExpbmVBcmd1bWVudCgnLS10aGluZycpYCByZXR1cm5zIGAnYmVuJ2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1hbmRMaW5lQXJndW1lbnQoYXJnTmFtZTogQ09NTUFORF9MSU5FX0FSR1MpIHtcbiAgLy8gVE9ETzogSWYgYXJnTmFtZSBoYXMgdHdvIGh5cGhlbnMsIGNoZWNrIGZvciBzaW5nbGUgaHlwaGVuIGFuZCBmaXJzdCBjaGFyICsgY2FwaXRhbHMgaWZcbiAgLy8gdHdvLWh5cGhlbiB2ZXJzaW9uIGRvZXMgbm90IGV4aXN0LiBlZyAtLWV4dGVuc2lvbkRpcnMgLT4gLWVkXG4gIGNvbnN0IGFyZ05hbWVzOiBzdHJpbmdbXSA9IGNvbW1hbmRMaW5lQXJndW1lbnRzQWxpYXNlc1thcmdOYW1lXTtcbiAgY29uc3QgYXJnSW5kaWNlczogbnVtYmVyW10gPSBhcmdOYW1lcy5tYXAoKG5hbWUpID0+IHByb2Nlc3MuYXJndi5pbmRleE9mKG5hbWUpKTtcblxuICBjb25zdCBhcmdJbmRleCA9IGFyZ0luZGljZXMuZmluZChcbiAgICAoaW5kZXgpID0+XG4gICAgICAvLyBXaWxsIGJlIG5lZ2F0aXZlIGlmIG5vdCBmb3VuZFxuICAgICAgaW5kZXggPj0gMCAmJlxuICAgICAgLy8gIEVuc3VyaW5nIGl0IGlzIG5vdCB0aGUgbGFzdCBhcmd1bWVudCAodGhlIGFyZyBuYW1lIHdhcyBmb3VuZCwgYnV0IHRoZXJlIGlzIG5vIGFjdHVhbCBhcmd1bWVudCBwcm92aWRlZClcbiAgICAgIGluZGV4IDwgcHJvY2Vzcy5hcmd2Lmxlbmd0aCAtIDEgJiZcbiAgICAgIC8vIElmIHRoZSBuZXh0IHdvcmQgaXMgYWxzbyBhbiBhcmcgbmFtZSwgdGhlcmUgd2FzIG5vIGFjdHVhbCBhcmd1bWVudCBwcm92aWRlZFxuICAgICAgZmluZE5leHRDb21tYW5kTGluZUFyZ3VtZW50SW5kZXgoaW5kZXgpICE9PSBpbmRleCArIDEsXG4gICk7XG5cbiAgaWYgKGFyZ0luZGV4ID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgcmV0dXJuIHByb2Nlc3MuYXJndlthcmdJbmRleCArIDFdO1xufVxuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIGEgY29tbWFuZC1saW5lIGFyZ3VtZW50IG5hbWUgaXMgcHJlc2VudFxuICpcbiAqIChhIHN3aXRjaCBpcyBhIGNvbW1hbmQtbGluZSBhcmd1bWVudCB3aXRob3V0IGEgdmFsdWUgLSBqdXN0IGEgYm9vbGVhbilcbiAqXG4gKiBAcGFyYW0gYXJnTmFtZSBOYW1lIG9mIHRoZSBzd2l0Y2ggdG8gbG9vayBmb3JcbiAqIEByZXR1cm5zIFRydWUgaWYgcHJlc2VudCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKlxuICogICBFeDogJy0tdGhpbmcgLS1zdHVmZiBib2xvZ25hJ1xuICpcbiAqICAgLSBgZ2V0Q29tbWFuZExpbmVTd2l0Y2goJy0tdGhpbmcnKWAgcmV0dXJucyBgdHJ1ZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1hbmRMaW5lU3dpdGNoKGFyZ05hbWU6IENPTU1BTkRfTElORV9BUkdTKSB7XG4gIGNvbnN0IGFyZ05hbWVzOiBzdHJpbmdbXSA9IGNvbW1hbmRMaW5lQXJndW1lbnRzQWxpYXNlc1thcmdOYW1lXTtcbiAgcmV0dXJuIGFyZ05hbWVzLnNvbWUoKGFsaWFzKSA9PiBwcm9jZXNzLmFyZ3YuaW5jbHVkZXMoYWxpYXMpKTtcbn1cbiIsIi8qKiBVdGlsaXRpZXMgdXNlZnVsIGZvciBub2RlIHByb2Nlc3NlcyAqL1xuaW1wb3J0IHsgVVJMIH0gZnJvbSAndXJsJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IG9zIGZyb20gJ29zJztcbmltcG9ydCB7IFVyaSB9IGZyb20gJ0BzaGFyZWQvZGF0YS9maWxlLXN5c3RlbS5tb2RlbCc7XG5pbXBvcnQgbWVtb2l6ZU9uZSBmcm9tICdtZW1vaXplLW9uZSc7XG5pbXBvcnQgeyBpbmNsdWRlcywgc3BsaXQgfSBmcm9tICdwbGF0Zm9ybS1iaWJsZS11dGlscyc7XG5cbi8vIEZPUiBTQ0hFTUUgRE9DVU1FTlRBVElPTiwgU0VFIFVyaSBKU0RPQ1xuY29uc3QgQVBQX1NDSEVNRSA9ICdhcHAnO1xuY29uc3QgQ0FDSEVfU0NIRU1FID0gJ2NhY2hlJztcbmNvbnN0IENBQ0hFX0RJUl9OQU1FID0gQ0FDSEVfU0NIRU1FO1xuY29uc3QgREFUQV9TQ0hFTUUgPSAnZGF0YSc7XG5jb25zdCBEQVRBX0RJUl9OQU1FID0gREFUQV9TQ0hFTUU7XG5jb25zdCBSRVNPVVJDRVNfU0NIRU1FID0gJ3Jlc291cmNlcyc7XG5jb25zdCBGSUxFX1NDSEVNRSA9ICdmaWxlJztcbmNvbnN0IFBST1RPQ09MX1BBUlQgPSAnOi8vJztcblxuZXhwb3J0IGNvbnN0IEZJTEVfUFJPVE9DT0wgPSBgJHtGSUxFX1NDSEVNRX0ke1BST1RPQ09MX1BBUlR9YDtcbmV4cG9ydCBjb25zdCBSRVNPVVJDRVNfUFJPVE9DT0wgPSBgJHtSRVNPVVJDRVNfU0NIRU1FfSR7UFJPVE9DT0xfUEFSVH1gO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUh0bWxQYXRoKGh0bWxGaWxlTmFtZTogc3RyaW5nKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGNvbnN0IHBvcnQgPSBwcm9jZXNzLmVudi5QT1JUIHx8IDEyMTI7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgaHR0cDovL2xvY2FsaG9zdDoke3BvcnR9YCk7XG4gICAgdXJsLnBhdGhuYW1lID0gaHRtbEZpbGVOYW1lO1xuICAgIHJldHVybiB1cmwuaHJlZjtcbiAgfVxuICByZXR1cm4gYCR7RklMRV9QUk9UT0NPTH0ke3BhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi9yZW5kZXJlci8nLCBodG1sRmlsZU5hbWUpfWA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcGxhdGZvcm0tc3BlY2lmaWMgdXNlciBQbGF0Zm9ybS5CaWJsZSBmb2xkZXIgZm9yIHRoaXMgYXBwbGljYXRpb25cbiAqXG4gKiBXaGVuIHJ1bm5pbmcgaW4gZGV2ZWxvcG1lbnQ6IGA8cmVwb19kaXJlY3Rvcnk+L2Rldi1hcHBkYXRhYFxuICpcbiAqIFdoZW4gcGFja2FnZWQ6IGA8dXNlcl9ob21lX2RpcmVjdG9yeT4vLnBsYXRmb3JtLmJpYmxlYFxuICovXG5leHBvcnQgY29uc3QgZ2V0QXBwRGlyID0gbWVtb2l6ZU9uZSgoKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuaXNQYWNrYWdlZFxuICAgID8gcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgJy8ucGxhdGZvcm0uYmlibGUnKVxuICAgIDogcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uLy4uLy4uL2Rldi1hcHBkYXRhJyk7XG59KTtcblxuLy8gRk9SIFNDSEVNRSBET0NVTUVOVEFUSU9OLCBTRUUgVXJpIEpTRE9DXG4vKiogR2V0IGEgbWFwcGluZyBmcm9tIHNjaGVtZSB0byB0aGUgYWJzb2x1dGUgcGF0aCB0byB0aGF0IHNjaGVtZS4gKi9cbi8vIFRPRE86IHRoaXMgaXMgY3VycmVudGx5IGxhenktbG9hZGVkIGJlY2F1c2UgZ2xvYmFsVGhpcyBkb2Vzbid0IGdldCBwb3B1bGF0ZWQgdW50aWwgYWZ0ZXIgdGhpc1xuLy8gZmlsZSBpcyBpbXBvcnRlZC4gRml4IHRoaXMgdG8gYmUgYSBub3JtYWwgb2JqZWN0IGFmdGVyIGZpeGluZyBnbG9iYWxUaGlzIGltcG9ydCBkZXBlbmRlbmNpZXMuXG5jb25zdCBnZXRTY2hlbWVQYXRocyA9IG1lbW9pemVPbmUoKCk6IHsgW3NjaGVtZTogc3RyaW5nXTogc3RyaW5nIH0gPT4ge1xuICBjb25zdCBhcHBEaXIgPSBnZXRBcHBEaXIoKTtcbiAgcmV0dXJuIHtcbiAgICBbQVBQX1NDSEVNRV06IGFwcERpcixcbiAgICBbQ0FDSEVfU0NIRU1FXTogcGF0aC5qb2luKGFwcERpciwgQ0FDSEVfRElSX05BTUUpLFxuICAgIFtEQVRBX1NDSEVNRV06IHBhdGguam9pbihhcHBEaXIsIERBVEFfRElSX05BTUUpLFxuICAgIFtSRVNPVVJDRVNfU0NIRU1FXTogZ2xvYmFsVGhpcy5yZXNvdXJjZXNQYXRoLFxuICAgIFtGSUxFX1NDSEVNRV06ICcnLFxuICB9O1xufSk7XG5cbi8qKiBQYXJzZSBhIFVSSSBmcm9tIGEgc3RyaW5nIGludG8gaXRzIG9yaWdpbmFsIHBhcnRzLiAqL1xuLy8gVE9ETzogTWFrZSBVUkkgYW4gYWN0dWFsIGNsYXNzLiBXaWxsIGJlIGNoYWxsZW5naW5nIHdoZW4gcGFzc2luZyB0aHJvdWdoIFdlYlNvY2tldFxuZnVuY3Rpb24gZ2V0UGF0aEluZm9Gcm9tVXJpKHVyaTogVXJpKTogeyBzY2hlbWU6IHN0cmluZzsgdXJpUGF0aDogc3RyaW5nIH0ge1xuICAvLyBBZGQgYXBwIHNjaGVtZSB0byB0aGUgdXJpIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgY29uc3QgZnVsbFVyaSA9IGluY2x1ZGVzKHVyaSwgUFJPVE9DT0xfUEFSVCkgPyB1cmkgOiBgJHtBUFBfU0NIRU1FfSR7UFJPVE9DT0xfUEFSVH0ke3VyaX1gO1xuXG4gIGNvbnN0IFtzY2hlbWUsIHVyaVBhdGhdID0gc3BsaXQoZnVsbFVyaSwgUFJPVE9DT0xfUEFSVCk7XG4gIHJldHVybiB7XG4gICAgc2NoZW1lLFxuICAgIHVyaVBhdGgsXG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHVyaSB0byBhIHBhdGhcbiAqXG4gKiBAcGFyYW0gdXJpIFRoZSB1cmkgdG8gcmVzb2x2ZVxuICogQHJldHVybnMgUmVhbCBwYXRoIHRvIHRoZSB1cmkgc3VwcGxpZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhdGhGcm9tVXJpKHVyaTogVXJpKTogc3RyaW5nIHtcbiAgY29uc3QgeyBzY2hlbWUsIHVyaVBhdGggfSA9IGdldFBhdGhJbmZvRnJvbVVyaSh1cmkpO1xuICByZXR1cm4gcGF0aC5qb2luKGdldFNjaGVtZVBhdGhzKClbc2NoZW1lXSwgdXJpUGF0aCk7XG59XG5cbi8qKlxuICogQ29tYmluZXMgdGhlIHVyaSBwYXNzZWQgaW4gd2l0aCB0aGUgcGF0aHMgcGFzc2VkIGluIHRvIG1ha2Ugb25lIHVyaVxuICpcbiAqIEBwYXJhbSB1cmkgVXJpIHRvIHN0YXJ0IGZyb21cbiAqIEBwYXJhbSBwYXRocyBQYXRocyB0byBjb21iaW5lIGludG8gdGhlIHVyaVxuICogQHJldHVybnMgT25lIHVyaSB0aGF0IGNvbWJpbmVzIHRoZSB1cmkgYW5kIHRoZSBwYXRocyBpbiBsZWZ0LXRvLXJpZ2h0IG9yZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqb2luVXJpUGF0aHModXJpOiBVcmksIC4uLnBhdGhzOiBzdHJpbmdbXSk6IFVyaSB7XG4gIGNvbnN0IHsgc2NoZW1lLCB1cmlQYXRoIH0gPSBnZXRQYXRoSW5mb0Zyb21VcmkodXJpKTtcbiAgcmV0dXJuIGAke3NjaGVtZX0ke1BST1RPQ09MX1BBUlR9JHtwYXRoLmpvaW4odXJpUGF0aCwgLi4ucGF0aHMpfWA7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBydW5uaW5nIGluIG5vaXN5IGRldiBtb2RlXG4gKlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIGluIG5vaXN5IGRldiBtb2RlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTm9pc3lEZXZNb2RlRW52VmFyaWFibGVTZXQgPSAoKTogYm9vbGVhbiA9PlxuICAhIXByb2Nlc3MuZW52LkRFVl9OT0lTWSAmJiBwcm9jZXNzLmVudi5ERVZfTk9JU1kgPT09ICd0cnVlJztcbiIsImltcG9ydCAqIGFzIGNvbW1hbmRTZXJ2aWNlIGZyb20gJ0BzaGFyZWQvc2VydmljZXMvY29tbWFuZC5zZXJ2aWNlJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbG9nZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJ3BsYXRmb3JtLWJpYmxlLXJlYWN0JztcbmltcG9ydCB7IENvbW1hbmROYW1lcyB9IGZyb20gJ3BhcGktc2hhcmVkLXR5cGVzJztcblxuLyoqXG4gKiBSdW4gYSBjb21tYW5kIGZyb20gYSBtZW51XG4gKlxuICogQHBhcmFtIGNvbW1hbmQgSW5mbyBhYm91dCB0aGUgY29tbWFuZCB0byBydW5cbiAqIEBwYXJhbSB0YWJJZCBUaGUgaWQgb2YgdGhlIGRvY2sgbGF5b3V0IHRhYiBvbiB3aGljaCB0aGUgbWVudSBjb21tYW5kIGlzIGJlaW5nIHJ1biAoaWYgdGhlIHRhYiBpc1xuICogICBhIHdlYiB2aWV3LCB0aGlzIGlzIHRoZSBzYW1lIGFzIHRoZSB3ZWIgdmlldyBpZCkgb3IgYHVuZGVmaW5lZGAgaWYgcnVuIGZyb20gdGhlIHRvcCBtZW51XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVNZW51Q29tbWFuZChjb21tYW5kOiBDb21tYW5kLCB0YWJJZD86IHN0cmluZykge1xuICBzd2l0Y2ggKGNvbW1hbmQuY29tbWFuZCkge1xuICAgIGNhc2UgJ3BsYXRmb3JtLm9wZW5Qcm9qZWN0RGlhbG9nJzpcbiAgICAgIGxvZ2dlci5pbmZvKGBPcGVuIFByb2plY3QgRGlhbG9nLiB0YWJJZDogJHt0YWJJZH1gKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3BsYXRmb3JtLm9wZW5Eb3dubG9hZFVwZGF0ZVByb2plY3REaWFsb2cnOlxuICAgICAgbG9nZ2VyLmluZm8oYERvd25sb2FkL1VwZGF0ZSBQcm9qZWN0IERpYWxvZy4gdGFiSWQ6ICR7dGFiSWR9YCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwbGF0Zm9ybS5kb3dubG9hZEFuZEluc3RhbGxSZXNvdXJjZXMnOlxuICAgICAgbG9nZ2VyLmluZm8oYFRPRE86IGRpc3BsYXkgVUkgdG8gc2VsZWN0IHJlc291cmNlcy4gdGFiSWQ6ICR7dGFiSWR9YCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwbGF0Zm9ybS5vcGVuVGV4dENvbGxlY3Rpb24nOlxuICAgICAgbG9nZ2VyLmluZm8oYFRPRE86IGRpc3BsYXkgdGV4dCBjb2xsZWN0aW9uIG1vZGFsLiB0YWJJZDogJHt0YWJJZH1gKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3BsYXRmb3JtLnZpc2l0U3VwcG9ydFBhZ2UnOlxuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBc3NlcnQgdGhlIG1vcmUgc3BlY2lmaWMgdHlwZS5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICBhd2FpdCBjb21tYW5kU2VydmljZS5zZW5kQ29tbWFuZCgncGxhdGZvcm0ub3BlbldpbmRvdycsICdodHRwczovL3N1cHBvcnQuYmlibGUnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBoYW5kbGVNZW51Q29tbWFuZCBlcnJvcjogY29tbWFuZDogJHtjb21tYW5kLmNvbW1hbmR9LCB0YWJJZDogJHt0YWJJZH0uICR7ZX1gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwbGF0Zm9ybS5hYm91dCc6XG4gICAgICBsb2dnZXIuaW5mbyhgVE9ETzogZGlzcGxheSBhYm91dC4gdGFiSWQ6ICR7dGFiSWR9YCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBc3NlcnQgdGhlIG1vcmUgc3BlY2lmaWMgdHlwZS5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICBhd2FpdCBjb21tYW5kU2VydmljZS5zZW5kQ29tbWFuZChjb21tYW5kLmNvbW1hbmQgYXMgQ29tbWFuZE5hbWVzLCB0YWJJZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgaGFuZGxlTWVudUNvbW1hbmQgZXJyb3I6IGNvbW1hbmQ6ICR7Y29tbWFuZC5jb21tYW5kfSwgdGFiSWQ6ICR7dGFiSWR9LiAke2V9YCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICB9XG59XG4iLCIvKipcbiAqIE5hbWVzcGFjZSB0byB1c2UgZm9yIGZlYXR1cmVzIGxpa2UgY29tbWFuZHMsIHNldHRpbmdzLCBldGMuIG9uIHRoZSBQQVBJIHRoYXQgYXJlIHByb3ZpZGVkIGJ5XG4gKiBQbGF0Zm9ybS5CaWJsZSBjb3JlXG4gKi9cbmV4cG9ydCBjb25zdCBQTEFURk9STV9OQU1FU1BBQ0UgPSAncGxhdGZvcm0nO1xuXG4vKiogUXVlcnkgc3RyaW5nIHBhc3NlZCB0byB0aGUgcmVuZGVyZXIgd2hlbiBzdGFydGluZyBpZiBpdCBzaG91bGQgZW5hYmxlIG5vaXN5IGRldiBtb2RlICovXG5leHBvcnQgY29uc3QgREVWX01PREVfUkVOREVSRVJfSU5ESUNBVE9SID0gJz9ub2lzeURldk1vZGUnO1xuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9sb2dnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBTZXJpYWxpemVkUmVxdWVzdFR5cGUgfSBmcm9tICdAc2hhcmVkL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHtcbiAgSlNPTlJQQyxcbiAgSlNPTlJQQ0Vycm9yQ29kZSxcbiAgSlNPTlJQQ0Vycm9yUmVzcG9uc2UsXG4gIEpTT05SUENSZXF1ZXN0LFxuICBKU09OUlBDUmVzcG9uc2UsXG4gIEpTT05SUENTdWNjZXNzUmVzcG9uc2UsXG59IGZyb20gJ2pzb24tcnBjLTIuMCc7XG5pbXBvcnQgeyBkZXNlcmlhbGl6ZSwgc2VyaWFsaXplLCB3YWl0IH0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuXG4vKiogUG9ydCB0byB1c2UgZm9yIHRoZSBXZWJTb2NrZXQgKi9cbmV4cG9ydCBjb25zdCBXRUJTT0NLRVRfUE9SVCA9IDg4NzY7XG5cbi8qKiBIb3cgbWFueSB0aW1lcyB0byB0cnkgc2VuZGluZyBhIHJlcXVlc3QgYmVmb3JlIGdpdmluZyB1cCBpZiB0aGUgcmVxdWVzdCBpcyBub3QgeWV0IHJlZ2lzdGVyZWQgKi9cbmNvbnN0IE1BWF9SRVFVRVNUX0FUVEVNUFRTID0gMTA7XG4vKiogSG93IGxvbmcgaW4gbXMgdG8gd2FpdCBiZXR3ZWVuIHJlcXVlc3QgYXR0ZW1wdHMgaWYgdGhlIHJlcXVlc3QgaXMgbm90IHlldCByZWdpc3RlcmVkICovXG5jb25zdCBSRVFVRVNUX0FUVEVNUFRfV0FJVF9USU1FX01TID0gMTAwMDtcblxuLyoqXG4gKiBXaGV0aGVyIGFuIFJQQyBvYmplY3QgaXMgc2V0dGluZyB1cCBvciBoYXMgZmluaXNoZWQgc2V0dGluZyB1cCBpdHMgY29ubmVjdGlvbiBhbmQgaXMgcmVhZHkgdG9cbiAqIGNvbW11bmljYXRlIG9uIHRoZSBuZXR3b3JrXG4gKi9cbmV4cG9ydCBlbnVtIENvbm5lY3Rpb25TdGF0dXMge1xuICAvKiogTm90IGNvbm5lY3RlZCB0byB0aGUgbmV0d29yayAqL1xuICBEaXNjb25uZWN0ZWQsXG4gIC8qKiBBdHRlbXB0aW5nIHRvIGNvbm5lY3QgdG8gdGhlIG5ldHdvcmsgKi9cbiAgQ29ubmVjdGluZyxcbiAgLyoqIEZpbmlzaGVkIHNldHRpbmcgdXAgaXRzIGNvbm5lY3Rpb24gKi9cbiAgQ29ubmVjdGVkLFxufVxuXG4vKiogUGFyYW1ldGVycyBwcm92aWRlZCB0byBhbiBSUEMgcmVxdWVzdCBtZXNzYWdlICovXG4vLyBBbGlnbiB3aXRoIHR5cGVzIGZyb20gdGhlIEpTT04gUlBDIHBhY2thZ2Vcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgdHlwZSBSZXF1ZXN0UGFyYW1zID0gQXJyYXk8YW55PjtcblxuLyoqXG4gKiBGdW5jdGlvbiB0byBjYWxsIGludGVybmFsbHkgd2hlbiBhIHJlcXVlc3QgaXMgcmVjZWl2ZWQuIFRoZSByZXR1cm4gdmFsdWUgaXMgc2VudCBiYWNrIGFzIHRoZVxuICogcmVzcG9uc2UgdG8gdGhlIHJlcXVlc3QuIElmIHRoZSByZXF1ZXN0IHdhcyByZWNlaXZlZCBvdmVyIHRoZSBuZXR3b3JrLCB0aGUgcmVzcG9uc2Ugd2lsbCBiZVxuICogcGFja2FnZWQgaW50byBhIEpTT05SUENTdWNjZXNzUmVzcG9uc2UgbWVzc2FnZS5cbiAqL1xuLy8gQWxpZ24gd2l0aCB0eXBlcyBmcm9tIHRoZSBKU09OIFJQQyBwYWNrYWdlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IHR5cGUgSW50ZXJuYWxSZXF1ZXN0SGFuZGxlciA9ICguLi5yZXF1ZXN0UGFyYW1zOiBSZXF1ZXN0UGFyYW1zKSA9PiBhbnk7XG5cbi8qKiBGdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyBhbiBldmVudCByZWNlaXZlZCBsb2NhbGx5IG9yIG92ZXIgdGhlIG5ldHdvcmsgKi9cbmV4cG9ydCB0eXBlIEV2ZW50SGFuZGxlciA9IDxUPihldmVudFR5cGU6IHN0cmluZywgZXZlbnQ6IFQpID0+IHZvaWQ7XG5cbi8qKlxuICogSUQgb2YgYW4gaW5kaXZpZHVhbCByZXF1ZXN0LiBJdCBtdXN0IGJlIHVuaXF1ZSBiZXR3ZWVuIGFuIFJQQyBjbGllbnQgYW5kIHNlcnZlciBmb3IgYSBzaW5nbGVcbiAqIGNvbm5lY3Rpb24uIE9uY2UgYSBjb25uZWN0aW9uIGhhcyBjbG9zZWQgYW5kIHJlb3BlbnMsIElEcyBjYW4gYmUgcmV1c2VkLlxuICovXG5leHBvcnQgdHlwZSBSZXF1ZXN0SWQgPSBudW1iZXIgfCBzdHJpbmc7XG5cbi8qKlxuICogQ3JlYXRlIGEgSlNPTlJQQ1JlcXVlc3QgbWVzc2FnZVxuICpcbiAqIEBwYXJhbSByZXF1ZXN0VHlwZSBJbmRpY2F0ZXMgd2hhdCB0byBkbyB3aXRoIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0gcmVxdWVzdFBhcmFtcyBQYXJhbWV0ZXJzIHRvIHBhc3MgYWxvbmcgd2hlbiB0aGUgcmVxdWVzdCBpcyBwcm9jZXNzZWRcbiAqIEBwYXJhbSByZXF1ZXN0SWQgVW5pcXVlIElEIGZvciB0aGlzIGNvbm5lY3Rpb24gb2YgdGhpcyByZXF1ZXN0XG4gKiBAcmV0dXJucyBKU09OUlBDUmVxdWVzdCBtZXNzYWdlIHRoYXQgY2FuIGJlIHNlcmlhbGl6ZWQgYW5kIHNlbnQgb3ZlciBhIGNvbm5lY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QoXG4gIHJlcXVlc3RUeXBlOiBTZXJpYWxpemVkUmVxdWVzdFR5cGUsXG4gIHJlcXVlc3RQYXJhbXM6IFJlcXVlc3RQYXJhbXMsXG4gIHJlcXVlc3RJZDogUmVxdWVzdElkLFxuKTogSlNPTlJQQ1JlcXVlc3Qge1xuICByZXR1cm4geyBqc29ucnBjOiBKU09OUlBDLCBpZDogcmVxdWVzdElkLCBtZXRob2Q6IHJlcXVlc3RUeXBlLCBwYXJhbXM6IHJlcXVlc3RQYXJhbXMgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBKU09OUlBDU3VjY2Vzc1Jlc3BvbnNlIG1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0gY29udGVudHMgRGF0YSB0byByZXR1cm4gdG8gdGhlIHJlcXVlc3RlciB3aGVuIHRoZSByZXF1ZXN0IHN1Y2NlZWRzXG4gKiBAcGFyYW0gcmVxdWVzdElkIElEIG9mIHRoZSByZXF1ZXN0IHRoYXQgdGhpcyByZXNwb25zZSBpcyBpbnRlbmRlZCB0byBhZGRyZXNzLiBJZiBubyBJRCB3YXNcbiAqICAgcHJvdmlkZWQsIGRvbid0IHBhc3MgYSB2YWx1ZSB0byB0aGlzIHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIEpTT05SUENTdWNjZXNzUmVzcG9uc2UgbWVzc2FnZSB0aGF0IGNhbiBiZSBzZXJpYWxpemVkIGFuZCBzZW50IG92ZXIgYSBjb25uZWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdWNjZXNzUmVzcG9uc2U8VD4oXG4gIGNvbnRlbnRzOiBULFxuICByZXF1ZXN0SWQ6IFJlcXVlc3RJZCA9IDAsXG4pOiBKU09OUlBDU3VjY2Vzc1Jlc3BvbnNlIHtcbiAgcmV0dXJuIHsganNvbnJwYzogSlNPTlJQQywgaWQ6IHJlcXVlc3RJZCwgcmVzdWx0OiBjb250ZW50cyB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIEpTT05SUENFcnJvclJlc3BvbnNlIG1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0gZXJyb3JNZXNzYWdlIFRleHQgdG8gcHJvdmlkZSB0byB0aGUgcmVxdWVzdGVyIGFib3V0IHdoeSB0aGlzIHJlcXVlc3QgZmFpbGVkXG4gKiBAcGFyYW0gZXJyb3JDb2RlIEpTT05SUENFcnJvckNvZGUgdmFsdWUgdGhhdCBiZXN0IGFsaWducyB3aXRoIHRoZSBwdXJwb3NlIG9mIHRoZSBmYWlsdXJlXG4gKiBAcGFyYW0gcmVxdWVzdElkIElEIG9mIHRoZSByZXF1ZXN0IHRoYXQgdGhpcyByZXNwb25zZSBpcyBpbnRlbmRlZCB0byBhZGRyZXNzLiBJZiBubyBJRCB3YXNcbiAqICAgcHJvdmlkZWQsIGRvbid0IHBhc3MgYSB2YWx1ZSB0byB0aGlzIHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIEpTT05SUENFcnJvclJlc3BvbnNlIG1lc3NhZ2UgdGhhdCBjYW4gYmUgc2VyaWFsaXplZCBhbmQgc2VudCBvdmVyIGEgY29ubmVjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXJyb3JSZXNwb25zZShcbiAgZXJyb3JNZXNzYWdlOiBzdHJpbmcsXG4gIGVycm9yQ29kZTogSlNPTlJQQ0Vycm9yQ29kZSA9IEpTT05SUENFcnJvckNvZGUuSW50ZXJuYWxFcnJvcixcbiAgcmVxdWVzdElkOiBSZXF1ZXN0SWQgPSAwLFxuKTogSlNPTlJQQ0Vycm9yUmVzcG9uc2Uge1xuICByZXR1cm4geyBqc29ucnBjOiBKU09OUlBDLCBpZDogcmVxdWVzdElkLCBlcnJvcjogeyBjb2RlOiBlcnJvckNvZGUsIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSB9IH07XG59XG5cbi8qKiBTZXJpYWxpemUgYSBwYXlsb2FkLCBpZiBuZWVkZWQsIGFuZCBzZW5kIGl0IG92ZXIgdGhlIHByb3ZpZGVkIFdlYlNvY2tldCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbmRQYXlsb2FkVG9XZWJTb2NrZXQod3M6IFdlYlNvY2tldCB8IHVuZGVmaW5lZCwgcGF5bG9hZDogdW5rbm93bik6IHZvaWQge1xuICBpZiAoIXdzKSB0aHJvdyBuZXcgRXJyb3IoYFRyaWVkIHRvIHNlbmQgcGF5bG9hZCB3aGlsZSBub3QgY29ubmVjdGVkYCk7XG4gIGlmIChcbiAgICB0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycgfHxcbiAgICBwYXlsb2FkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICBwYXlsb2FkIGluc3RhbmNlb2YgQmxvYiB8fFxuICAgIEFycmF5QnVmZmVyLmlzVmlldyhwYXlsb2FkKVxuICApIHtcbiAgICB3cy5zZW5kKHBheWxvYWQpO1xuICB9IGVsc2Uge1xuICAgIHdzLnNlbmQoc2VyaWFsaXplKHBheWxvYWQpKTtcbiAgfVxufVxuXG4vKipcbiAqIERlc2VyaWFsaXplIGEgcGF5bG9hZCBmcm9tIHRoZSBuZXR3b3JrIGFuZCByZXR1cm4gaXQgYXMgYSBKU09OUlBDIG1lc3NhZ2Ugb3IgYXJyYXkgb2YgbWVzc2FnZXMuXG4gKiBOb3RlIHRoYXQgYWxsIGBudWxsYCB2YWx1ZXMgZnJvbSB0aGUgcGF5bG9hZCB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIGB1bmRlZmluZWRgIHZhbHVlcyBleGNlcHQgZm9yXG4gKiBgcmVzdWx0YCB2YWx1ZXMgaW4gSlNPTlJQQ1N1Y2Nlc3NSZXNwb25zZSBtZXNzYWdlcy4gQSBgbnVsbGAgdmFsdWUgYXMgdGhlIHJlc3BvbnNlIHRvIGEgcmVxdWVzdFxuICogbXVzdCBub3QgYmUgY29udmVydGVkIHRvIGB1bmRlZmluZWRgIHBlciB0aGUgSlNPTlJQQyBwcm90b2NvbC5cbiAqXG4gKiBBZnRlciBhIHJlcXVlc3QgaGFzIGJlZW4gcHJvY2Vzc2VkIGJ5IHRoZSBwcm90b2NvbCBzdGFjaywgY2FsbCBgZml4dXBSZXNwb25zZWAgdG8gcmVzdG9yZVxuICogYHVuZGVmaW5lZGAgcmVzcG9uc2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemVNZXNzYWdlKFxuICBwYXlsb2FkOiBzdHJpbmcsXG4pOiBKU09OUlBDUmVxdWVzdCB8IEpTT05SUENSZXNwb25zZSB8IEFycmF5PEpTT05SUENSZXF1ZXN0IHwgSlNPTlJQQ1Jlc3BvbnNlPiB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBkZXNlcmlhbGl6ZShwYXlsb2FkKTtcbiAgY29uc3QgbWVzc2FnZVR5cGUgPSB0eXBlb2YgbWVzc2FnZTtcbiAgaWYgKG1lc3NhZ2VUeXBlICE9PSAnb2JqZWN0JykgcmV0dXJuIG1lc3NhZ2U7XG4gIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgbWVzc2FnZS5mb3JFYWNoKChtc2cpID0+IHtcbiAgICAgIC8vIFJlcXVpcmVkIGJ5IHRoZSBwcm90b2NvbCBzaW5jZSB3ZSBjb252ZXJ0IFwidW5kZWZpbmVkXCIgdG8gXCJudWxsXCIgaW4gXCJkZXNlcmlhbGl6ZVwiXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbnVsbC9uby1udWxsXG4gICAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ29iamVjdCcgJiYgJ3Jlc3VsdCcgaW4gbXNnICYmIG1zZy5yZXN1bHQgPT09IHVuZGVmaW5lZCkgbXNnLnJlc3VsdCA9IG51bGw7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoJ3Jlc3VsdCcgaW4gbWVzc2FnZSAmJiBtZXNzYWdlLnJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgIC8vIFJlcXVpcmVkIGJ5IHRoZSBwcm90b2NvbCBzaW5jZSB3ZSBjb252ZXJ0IFwidW5kZWZpbmVkXCIgdG8gXCJudWxsXCIgaW4gXCJkZXNlcmlhbGl6ZVwiXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW51bGwvbm8tbnVsbFxuICAgIG1lc3NhZ2UucmVzdWx0ID0gbnVsbDtcblxuICByZXR1cm4gbWVzc2FnZTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGBudWxsYCByZXN1bHRzIGJhY2sgdG8gYHVuZGVmaW5lZGAgb25jZSB3ZSdyZSBvdXQgb2YgdGhlIHByb3RvY29sIHN0YWNrLlxuICpcbiAqIFRoaXMgd29ya3MgaW4gdGFuZGVtIHdpdGggYGRlc2VyaWFsaXplTWVzc2FnZWAgdG8gcHJvcGVybHkgaGFuZGxlIGBudWxsYCB2YWx1ZXMgaW4gSlNPTlJQQ1xuICogbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXh1cFJlc3BvbnNlKHJlc3BvbnNlOiBKU09OUlBDUmVzcG9uc2UpOiBKU09OUlBDUmVzcG9uc2Uge1xuICAvLyBDb252ZXJ0IFwibnVsbFwiIGJhY2sgdG8gXCJ1bmRlZmluZWRcIiBiZWZvcmUgaXQgZmxvd3MgYmFjayBvdXQgdG8gY2FsbGVyc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbnVsbC9uby1udWxsXG4gIGlmICgncmVzdWx0JyBpbiByZXNwb25zZSAmJiByZXNwb25zZS5yZXN1bHQgPT09IG51bGwpIHJlc3BvbnNlLnJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG4vKipcbiAqIFJ1bnMgdGhlIHJlcXVlc3QgY2FsbGJhY2sgYW5kIHJldHJpZXMgYSBudW1iZXIgb2YgdGltZXMgaWYgYHJlcXVlc3RDYWxsYmFja2AgcmVzb2x2ZXMgdG8gYSBtZXRob2RcbiAqIG5vdCBmb3VuZCBlcnJvclxuICpcbiAqIEBwYXJhbSByZXF1ZXN0Q2FsbGJhY2sgRnVuY3Rpb24gdG8gcnVuIHRvIHNlbmQgYSBKU09OLVJQQyByZXF1ZXN0LiBTaG91bGQgcmV0dXJuIGEgSlNPTlJQQyBlcnJvclxuICogICB3aXRoIGNvZGUge0BsaW5rIEpTT05SUENFcnJvckNvZGUuTWV0aG9kTm90Rm91bmR9IGlmIGl0IGZhaWxzIHRvIGZpbmQgdGhlIG1ldGhvZFxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgaGFuZGxlciBydW5uaW5nIHRoaXMgcmVxdWVzdCBmb3IgbG9nZ2luZyBwdXJwb3Nlc1xuICogQHBhcmFtIHJlcXVlc3RUeXBlIFR5cGUgb2YgcmVxdWVzdCBmb3IgbG9nZ2luZyBwdXJwb3Nlc1xuICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIHJlcXVlc3QgaW5jbHVkaW5nIHRoZSBtZXRob2Qgbm90IGZvdW5kIGVycm9yIGlmIGl0IHRpbWVzIG91dFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdFdpdGhSZXRyeShcbiAgcmVxdWVzdENhbGxiYWNrOiAoKSA9PiBQcm9taXNlPEpTT05SUENSZXNwb25zZT4sXG4gIG5hbWU6IHN0cmluZyxcbiAgcmVxdWVzdFR5cGU6IHN0cmluZyxcbik6IFByb21pc2U8SlNPTlJQQ1Jlc3BvbnNlPiB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXJhbmV4dC9wYXJhbmV4dC1jb3JlL2lzc3Vlcy81MVxuICAvLyBJZiB0aGUgcmVxdWVzdCB0eXBlIGRvZXNuJ3QgaGF2ZSBhIHJlZ2lzdGVyZWQgaGFuZGxlciB5ZXQsIHJldHJ5IGEgZmV3IHRpbWVzIHRvIGhlbHAgd2l0aCByYWNlXG4gIC8vIGNvbmRpdGlvbnMuIFRoaXMgYXBwcm9hY2ggaXMgaGFja3kgYnV0IHdvcmtzIHdlbGwgZW5vdWdoIGZvciBub3cuXG4gIGZvciAobGV0IGF0dGVtcHRzUmVtYWluaW5nID0gTUFYX1JFUVVFU1RfQVRURU1QVFM7IGF0dGVtcHRzUmVtYWluaW5nID4gMDsgYXR0ZW1wdHNSZW1haW5pbmctLSkge1xuICAgIC8vIEludGVudGlvbmFsbHkgYXdhaXRpbmcgaW5zaWRlIGZvciBsb29wIHNvIHdlIGF0dGVtcHQgb25jZSBhdCBhIHRpbWVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdENhbGxiYWNrKCk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLmVycm9yIHx8IHJlc3BvbnNlLmVycm9yLmNvZGUgIT09IEpTT05SUENFcnJvckNvZGUuTWV0aG9kTm90Rm91bmQpIHJldHVybiByZXNwb25zZTtcblxuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBSUEMgaGFuZGxlciAke25hbWV9IGNvdWxkIG5vdCBmaW5kIGEgcmVxdWVzdCBoYW5kbGVyIGZvciByZXF1ZXN0VHlwZSAke3JlcXVlc3RUeXBlfSBvbiBhdHRlbXB0ICR7TUFYX1JFUVVFU1RfQVRURU1QVFMgLSBhdHRlbXB0c1JlbWFpbmluZyArIDF9IG9mICR7TUFYX1JFUVVFU1RfQVRURU1QVFN9LiAke2F0dGVtcHRzUmVtYWluaW5nID09PSAxID8gJ0dpdmluZyB1cC4nIDogJ1JldHJ5aW5nLi4uJ31gLFxuICAgICk7XG5cbiAgICAvLyBObyBuZWVkIHRvIHdhaXQgYWdhaW4gYWZ0ZXIgdGhlIGxhc3QgYXR0ZW1wdCBmYWlscy4gUmV0dXJuIHRoZSBlcnJvciByZXNwb25zZVxuICAgIGlmIChhdHRlbXB0c1JlbWFpbmluZyA9PT0gMSkgcmV0dXJuIHJlc3BvbnNlO1xuXG4gICAgLy8gSW50ZW50aW9uYWxseSBhd2FpdGluZyBpbnNpZGUgZm9yIGxvb3Agc28gd2Ugd2FpdCBhIGJpdCBiZWZvcmUgcmV0cnlpbmdcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgIGF3YWl0IHdhaXQoUkVRVUVTVF9BVFRFTVBUX1dBSVRfVElNRV9NUyk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBSUEMgaGFuZGxlciAke25hbWV9IGRpZCBub3QgcmV0dXJuIGEgcmVzcG9uc2UgYWZ0ZXIgcmV0cnlpbmcgdG8gZmluZCByZXF1ZXN0IGhhbmRsZXIgZm9yIHJlcXVlc3RUeXBlICR7cmVxdWVzdFR5cGV9LiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIFBsZWFzZSBpbnZlc3RpZ2F0ZWAsXG4gICk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBtZXRob2Qgb24gdGhlIG5ldHdvcmsgc28gdGhhdCByZXF1ZXN0cyBvZiB0aGUgZ2l2ZW4gdHlwZSBhcmUgcm91dGVkIHRvIHlvdXIgcmVxdWVzdFxuICogaGFuZGxlci5cbiAqL1xuZXhwb3J0IGNvbnN0IFJFR0lTVEVSX01FVEhPRCA9ICduZXR3b3JrOnJlZ2lzdGVyTWV0aG9kJztcblxuLyoqXG4gKiBVbnJlZ2lzdGVyIGEgbWV0aG9kIG9uIHRoZSBuZXR3b3JrIHNvIHRoYXQgcmVxdWVzdHMgb2YgdGhlIGdpdmVuIHR5cGUgYXJlIG5vIGxvbmdlciByb3V0ZWQgdG9cbiAqIHlvdXIgcmVxdWVzdCBoYW5kbGVyLlxuICovXG5leHBvcnQgY29uc3QgVU5SRUdJU1RFUl9NRVRIT0QgPSAnbmV0d29yazp1bnJlZ2lzdGVyTWV0aG9kJztcblxuLyoqXG4gKiBHZXQgYWxsIG1ldGhvZHMgdGhhdCBhcmUgY3VycmVudGx5IHJlZ2lzdGVyZWQgb24gdGhlIG5ldHdvcmsuIFJlcXVpcmVkIHRvIGJlICdycGMuZGlzY292ZXInIGJ5XG4gKiB0aGUgT3BlblJQQyBzcGVjaWZpY2F0aW9uLlxuICovXG5leHBvcnQgY29uc3QgR0VUX01FVEhPRFMgPSAncnBjLmRpc2NvdmVyJztcblxuLyoqIFByZWZpeCBvbiByZXF1ZXN0cyB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IGlzIGEgY29tbWFuZCAqL1xuZXhwb3J0IGNvbnN0IENBVEVHT1JZX0NPTU1BTkQgPSAnY29tbWFuZCc7XG4iLCJpbXBvcnQgeyBMb2dMZXZlbCB9IGZyb20gJ2VsZWN0cm9uLWxvZyc7XG5pbXBvcnQgeyBGdW5jdGlvbkNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7XG4gIEdldFNhdmVkV2ViVmlld0RlZmluaXRpb24sXG4gIFNhdmVkV2ViVmlld0RlZmluaXRpb24sXG4gIFVwZGF0ZVdlYlZpZXdEZWZpbml0aW9uLFxuICBVc2VXZWJWaWV3U2Nyb2xsR3JvdXBTY3JSZWZIb29rLFxuICBVc2VXZWJWaWV3U3RhdGVIb29rLFxuICBXZWJWaWV3RGVmaW5pdGlvblVwZGF0ZUluZm8sXG4gIFdlYlZpZXdJZCxcbiAgV2ViVmlld1Byb3BzLFxufSBmcm9tICdAc2hhcmVkL21vZGVscy93ZWItdmlldy5tb2RlbCc7XG5cbi8qKlxuICogVmFyaWFibGVzIHRoYXQgYXJlIGRlZmluZWQgaW4gZ2xvYmFsIHNjb3BlLiBUaGVzZSBtdXN0IGJlIGRlZmluZWQgaW4gbWFpbi50cyAobWFpbiksIGluZGV4LnRzXG4gKiAocmVuZGVyZXIpLCBhbmQgZXh0ZW5zaW9uLWhvc3QudHMgKGV4dGVuc2lvbiBob3N0KVxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIHZhcnMtb24tdG9wLCBuby12YXIgKi9cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLyoqIFR5cGUgb2YgcHJvY2VzcyB0aGlzIGlzLiBIZWxwcyB3aXRoIHJ1bm5pbmcgc3BlY2lmaWMgY29kZSBiYXNlZCBvbiB3aGljaCBwcm9jZXNzIHlvdSdyZSBpbiAqL1xuICB2YXIgcHJvY2Vzc1R5cGU6IFByb2Nlc3NUeXBlO1xuICAvKiogV2hldGhlciB0aGlzIHByb2Nlc3MgaXMgcGFja2FnZWQgb3IgcnVubmluZyBmcm9tIHNvdXJjZXMgKi9cbiAgdmFyIGlzUGFja2FnZWQ6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBhcHAncyByZXNvdXJjZXMgZGlyZWN0b3J5LiBUaGlzIGlzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXNvdXJjZXMgdXJpIG9uXG4gICAqIGZyb250ZW5kXG4gICAqL1xuICB2YXIgcmVzb3VyY2VzUGF0aDogc3RyaW5nO1xuICAvKiogSG93IG11Y2ggbG9nZ2luZyBzaG91bGQgYmUgcmVjb3JkZWQuIERlZmF1bHRzIHRvICdkZWJ1ZycgaWYgbm90IHBhY2thZ2VkLCAnaW5mbycgaWYgcGFja2FnZWQgKi9cbiAgdmFyIGxvZ0xldmVsOiBMb2dMZXZlbDtcbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCBlYWNoIFJlYWN0IFdlYlZpZXcgZXh0ZW5zaW9uIG11c3QgcHJvdmlkZSBmb3IgUGFyYW5leHQgdG8gZGlzcGxheSBpdC4gT25seSB1c2VkXG4gICAqIGluIFdlYlZpZXcgaWZyYW1lcy5cbiAgICovXG4gIHZhciB3ZWJWaWV3Q29tcG9uZW50OiBGdW5jdGlvbkNvbXBvbmVudDxXZWJWaWV3UHJvcHM+O1xuICAvKiogVGhlIGlkIG9mIHRoZSBjdXJyZW50IHdlYiB2aWV3LiBPbmx5IHVzZWQgaW4gV2ViVmlldyBpZnJhbWVzLiAqL1xuICB2YXIgd2ViVmlld0lkOiBXZWJWaWV3SWQ7XG4gIC8qKiBKU0RPQyBERVNUSU5BVElPTiBVc2VXZWJWaWV3U3RhdGVIb29rICovXG4gIHZhciB1c2VXZWJWaWV3U3RhdGU6IFVzZVdlYlZpZXdTdGF0ZUhvb2s7XG4gIC8qKiBKU0RPQyBERVNUSU5BVElPTiBVc2VXZWJWaWV3U2Nyb2xsR3JvdXBTY3JSZWZIb29rICovXG4gIHZhciB1c2VXZWJWaWV3U2Nyb2xsR3JvdXBTY3JSZWY6IFVzZVdlYlZpZXdTY3JvbGxHcm91cFNjclJlZkhvb2s7XG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgdmFsdWUgZnJvbSB3ZWIgdmlldyBzdGF0ZSB3aXRoIHRoZSBnaXZlbiAnc3RhdGVLZXknLCBpZiBpdCBleGlzdHMuIE90aGVyd2lzZVxuICAgKiByZXR1cm4gZGVmYXVsdCB2YWx1ZVxuICAgKi9cbiAgdmFyIGdldFdlYlZpZXdTdGF0ZTogPFQ+KHN0YXRlS2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZTogVCkgPT4gVDtcbiAgLyoqIFNldCB0aGUgdmFsdWUgZm9yIGEgZ2l2ZW4ga2V5IGluIHRoZSB3ZWIgdmlldyBzdGF0ZS4gKi9cbiAgdmFyIHNldFdlYlZpZXdTdGF0ZTogPFQ+KHN0YXRlS2V5OiBzdHJpbmcsIHN0YXRlVmFsdWU6IFQpID0+IHZvaWQ7XG4gIC8qKiBSZW1vdmUgdGhlIHZhbHVlIGZvciBhIGdpdmVuIGtleSBpbiB0aGUgd2ViIHZpZXcgc3RhdGUgKi9cbiAgdmFyIHJlc2V0V2ViVmlld1N0YXRlOiAoc3RhdGVLZXk6IHN0cmluZykgPT4gdm9pZDtcbiAgLy8gV2ViIHZpZXcgXCJieSBpZFwiIGZ1bmN0aW9ucyBhcmUgdXNlZCBpbiB0aGUgZGVmYXVsdCBpbXBvcnRzIGZvciBlYWNoIHdlYnZpZXcgaW4gd2ViLXZpZXcuc2VydmljZS50c1xuICAvLyBidXQgcHJvYmFibHkgd291bGRuJ3QgYmUgdXNlZCBpbiBhIHdlYnZpZXdcbiAgLy8gVE9ETzogRmluZCBhIHdheSB0byBtb3ZlIHRoaXMgdG8gYEByZW5kZXJlci9nbG9iYWwtdGhpcy5tb2RlbC50c2Agd2l0aG91dCBjYXVzaW5nIGFuIGVycm9yIG9uXG4gIC8vIGJ1aWxkaW5nIHBhcGkuZC50c1xuICB2YXIgZ2V0U2F2ZWRXZWJWaWV3RGVmaW5pdGlvbkJ5SWQ6ICh3ZWJWaWV3SWQ6IHN0cmluZykgPT4gU2F2ZWRXZWJWaWV3RGVmaW5pdGlvbiB8IHVuZGVmaW5lZDtcbiAgdmFyIHVwZGF0ZVdlYlZpZXdEZWZpbml0aW9uQnlJZDogKFxuICAgIHdlYlZpZXdJZDogc3RyaW5nLFxuICAgIHdlYlZpZXdEZWZpbml0aW9uVXBkYXRlSW5mbzogV2ViVmlld0RlZmluaXRpb25VcGRhdGVJbmZvLFxuICApID0+IGJvb2xlYW47XG4gIC8qKiBKU0RPQyBERVNUSU5BVElPTiBHZXRTYXZlZFdlYlZpZXdEZWZpbml0aW9uICovXG4gIHZhciBnZXRTYXZlZFdlYlZpZXdEZWZpbml0aW9uOiBHZXRTYXZlZFdlYlZpZXdEZWZpbml0aW9uO1xuICAvKiogSlNET0MgREVTVElOQVRJT04gVXBkYXRlV2ViVmlld0RlZmluaXRpb24gKi9cbiAgdmFyIHVwZGF0ZVdlYlZpZXdEZWZpbml0aW9uOiBVcGRhdGVXZWJWaWV3RGVmaW5pdGlvbjtcbiAgLyoqIEluZGljYXRlcyB3aGV0aGVyIHRlc3QgY29kZSBtZWFudCBqdXN0IGZvciBkZXZlbG9wZXJzIHRvIHNlZSBzaG91bGQgYmUgcnVuICovXG4gIHZhciBpc05vaXN5RGV2TW9kZUVuYWJsZWQ6IGJvb2xlYW47XG59XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbi8qKiBUeXBlIG9mIFBhcmFuZXh0IHByb2Nlc3MgKi9cbmV4cG9ydCBlbnVtIFByb2Nlc3NUeXBlIHtcbiAgTWFpbiA9ICdtYWluJyxcbiAgUmVuZGVyZXIgPSAncmVuZGVyZXInLFxuICBFeHRlbnNpb25Ib3N0ID0gJ2V4dGVuc2lvbi1ob3N0Jyxcbn1cbiIsIi8vIEZ1bmN0aW9ucyB0aGF0IGFyZSBleHBvc2VkIHRocm91Z2ggdGhlIG5ldHdvcmsgb2JqZWN0XG4vKiogSlNET0MgREVTVElOQVRJT04gZGF0YVByb3RlY3Rpb25TZXJ2aWNlICovXG5leHBvcnQgaW50ZXJmYWNlIElEYXRhUHJvdGVjdGlvblNlcnZpY2Uge1xuICAvKipcbiAgICogRW5jcnlwdHMgYSBzdHJpbmcgdXNpbmcgRWxlY3Ryb24nc1xuICAgKiBbYHNhZmVTdG9yYWdlYF0oaHR0cHM6Ly93d3cuZWxlY3Ryb25qcy5vcmcvZG9jcy9sYXRlc3QvYXBpL3NhZmUtc3RvcmFnZSkgQVBJLiBUcmFuc2Zvcm1zIHRoZVxuICAgKiByZXR1cm5lZCBidWZmZXIgdG8gYSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgdXNpbmdcbiAgICogW2BidWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpYF0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNidWZ0b3N0cmluZ2VuY29kaW5nLXN0YXJ0LWVuZCkuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHRocm93cyBpZiB0aGUgZW5jcnlwdGlvbiBtZWNoYW5pc20gaXMgbm90IGF2YWlsYWJsZSBzdWNoIGFzIG9uIExpbnV4IHdpdGhvdXQgYVxuICAgKiBzdXBwb3J0ZWQgcGFja2FnZSBpbnN0YWxsZWQuIFNlZVxuICAgKiBbYHNhZmVTdG9yYWdlYF0oaHR0cHM6Ly93d3cuZWxlY3Ryb25qcy5vcmcvZG9jcy9sYXRlc3QvYXBpL3NhZmUtc3RvcmFnZSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGVuY3J5cHRpb24gbWVjaGFuaXNtIGlzIG5vdCB0cmFuc2ZlcnJhYmxlIGJldHdlZW4gY29tcHV0ZXJzLiBXZSByZWNvbW1lbmQgdXNpbmdcbiAgICogaXQgd2l0aCBgcGFwaS5zdG9yYWdlYCBtZXRob2RzIHRvIHN0b3JlIGRhdGEgc2FmZWx5LlxuICAgKlxuICAgKiBXQVJOSU5HOiBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgc2VydmljZSBpcyB0byBlbmFibGUgZXh0ZW5zaW9ucyB0byBlbmNyeXB0IGFuZCBkZWNyeXB0XG4gICAqIGRhdGEgdG8gYmUgc3RvcmVkIHNlY3VyZWx5IGluIGxvY2FsIGZpbGVzLiBJdCBpcyBub3QgaW50ZW5kZWQgdG8gcHJvdGVjdCBkYXRhIHBhc3NlZCBvdmVyIGFcbiAgICogbmV0d29yayBjb25uZWN0aW9uLiBQbGVhc2Ugbm90ZSB0aGF0IHVzaW5nIHRoaXMgc2VydmljZSBwYXNzZXMgdGhlIHVuZW5jcnlwdGVkIHN0cmluZyBiZXR3ZWVuXG4gICAqIGxvY2FsIHByb2Nlc3NlcyB1c2luZyB0aGUgUEFQSSBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB0ZXh0IFN0cmluZyB0byBlbmNyeXB0XG4gICAqIEByZXR1cm5zIEVuY3J5cHRlZCBzdHJpbmcuIFVzZSBgcGFwaS5kYXRhUHJvdGVjdGlvbi5kZWNyeXB0U3RyaW5nYCB0byBkZWNyeXB0XG4gICAqL1xuICBlbmNyeXB0U3RyaW5nKHRleHQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPjtcbiAgLyoqXG4gICAqIERlY3J5cHRzIGEgc3RyaW5nIHVzaW5nIEVsZWN0cm9uJ3NcbiAgICogW2BzYWZlU3RvcmFnZWBdKGh0dHBzOi8vd3d3LmVsZWN0cm9uanMub3JnL2RvY3MvbGF0ZXN0L2FwaS9zYWZlLXN0b3JhZ2UpIEFQSS4gVHJhbnNmb3JtcyB0aGVcbiAgICogaW5wdXQgYmFzZTY0LWVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyIHVzaW5nIFtgQnVmZmVyLmZyb20odGV4dCxcbiAgICogJ2Jhc2U2NCcpYF0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNzdGF0aWMtbWV0aG9kLWJ1ZmZlcmZyb21zdHJpbmctZW5jb2RpbmcpLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB0aHJvd3MgaWYgdGhlIGRlY3J5cHRpb24gbWVjaGFuaXNtIGlzIG5vdCBhdmFpbGFibGUgc3VjaCBhcyBvbiBMaW51eCB3aXRob3V0IGFcbiAgICogc3VwcG9ydGVkIHBhY2thZ2UgaW5zdGFsbGVkLiBTZWVcbiAgICogW2BzYWZlU3RvcmFnZWBdKGh0dHBzOi8vd3d3LmVsZWN0cm9uanMub3JnL2RvY3MvbGF0ZXN0L2FwaS9zYWZlLXN0b3JhZ2UpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBlbmNyeXB0aW9uIG1lY2hhbmlzbSBpcyBub3QgdHJhbnNmZXJyYWJsZSBiZXR3ZWVuIGNvbXB1dGVycy4gV2UgcmVjb21tZW5kIHVzaW5nXG4gICAqIGl0IHdpdGggYHBhcGkuc3RvcmFnZWAgbWV0aG9kcyB0byBzdG9yZSBkYXRhIHNhZmVseS5cbiAgICpcbiAgICogV0FSTklORzogVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIHNlcnZpY2UgaXMgdG8gZW5hYmxlIGV4dGVuc2lvbnMgdG8gZW5jcnlwdCBhbmQgZGVjcnlwdFxuICAgKiBkYXRhIHRvIGJlIHN0b3JlZCBzZWN1cmVseSBpbiBsb2NhbCBmaWxlcy4gSXQgaXMgbm90IGludGVuZGVkIHRvIHByb3RlY3QgZGF0YSBwYXNzZWQgb3ZlciBhXG4gICAqIG5ldHdvcmsgY29ubmVjdGlvbi4gUGxlYXNlIG5vdGUgdGhhdCB1c2luZyB0aGlzIHNlcnZpY2UgcGFzc2VzIHRoZSB1bmVuY3J5cHRlZCBzdHJpbmcgYmV0d2VlblxuICAgKiBsb2NhbCBwcm9jZXNzZXMgdXNpbmcgdGhlIFBBUEkgV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gZW5jcnlwdGVkVGV4dCBTdHJpbmcgdG8gZGVjcnlwdC4gVGhpcyBzdHJpbmcgc2hvdWxkIGhhdmUgYmVlbiBlbmNyeXB0ZWQgYnlcbiAgICogICBgcGFwaS5kYXRhUHJvdGVjdGlvbi5lbmNyeXB0U3RyaW5nYFxuICAgKiBAcmV0dXJucyBEZWNyeXB0ZWQgc3RyaW5nXG4gICAqL1xuICBkZWNyeXB0U3RyaW5nKGVuY3J5cHRlZFRleHQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPjtcbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIGVuY3J5cHRpb24gaXMgY3VycmVudGx5IGF2YWlsYWJsZS4gUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBkZWNyeXB0aW9uXG4gICAqIG1lY2hhbmlzbSBpcyBub3QgYXZhaWxhYmxlIHN1Y2ggYXMgb24gTGludXggd2l0aG91dCBhIHN1cHBvcnRlZCBwYWNrYWdlIGluc3RhbGxlZC4gU2VlXG4gICAqIEVsZWN0cm9uJ3MgW2BzYWZlU3RvcmFnZWBdKGh0dHBzOi8vd3d3LmVsZWN0cm9uanMub3JnL2RvY3MvbGF0ZXN0L2FwaS9zYWZlLXN0b3JhZ2UpIEFQSSBmb3JcbiAgICogbW9yZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogV0FSTklORzogVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIHNlcnZpY2UgaXMgdG8gZW5hYmxlIGV4dGVuc2lvbnMgdG8gZW5jcnlwdCBhbmQgZGVjcnlwdFxuICAgKiBkYXRhIHRvIGJlIHN0b3JlZCBzZWN1cmVseSBpbiBsb2NhbCBmaWxlcy4gSXQgaXMgbm90IGludGVuZGVkIHRvIHByb3RlY3QgZGF0YSBwYXNzZWQgb3ZlciBhXG4gICAqIG5ldHdvcmsgY29ubmVjdGlvbi4gUGxlYXNlIG5vdGUgdGhhdCB1c2luZyB0aGlzIHNlcnZpY2UgcGFzc2VzIHRoZSB1bmVuY3J5cHRlZCBzdHJpbmcgYmV0d2VlblxuICAgKiBsb2NhbCBwcm9jZXNzZXMgdXNpbmcgdGhlIFBBUEkgV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgZW5jcnlwdGlvbiBpcyBjdXJyZW50bHkgYXZhaWxhYmxlOyBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgaXNFbmNyeXB0aW9uQXZhaWxhYmxlKCk6IFByb21pc2U8Ym9vbGVhbj47XG59XG5cbmV4cG9ydCBjb25zdCBkYXRhUHJvdGVjdGlvblNlcnZpY2VOZXR3b3JrT2JqZWN0TmFtZSA9ICdEYXRhUHJvdGVjdGlvblNlcnZpY2UnO1xuIiwiaW1wb3J0IHtcbiAgRGF0YVByb3ZpZGVyRGF0YVR5cGVzLFxuICBEYXRhUHJvdmlkZXJHZXR0ZXJzLFxuICBEYXRhUHJvdmlkZXJVcGRhdGVJbnN0cnVjdGlvbnMsXG4gIERhdGFQcm92aWRlclNldHRlcnMsXG59IGZyb20gJ0BzaGFyZWQvbW9kZWxzL2RhdGEtcHJvdmlkZXIubW9kZWwnO1xuaW1wb3J0IHsgTmV0d29ya2FibGVPYmplY3QgfSBmcm9tICdAc2hhcmVkL21vZGVscy9uZXR3b3JrLW9iamVjdC5tb2RlbCc7XG5cbi8vIE5vdGU6IHRoZSBmb2xsb3dpbmcgY29tbWVudCB1c2VzIO+8oCwgbm90IHRoZSBhY3R1YWwgQCBjaGFyYWN0ZXIsIHRvIGhhY2tpbHkgcHJvdmlkZSBAcGFyYW0gYW5kXG4vLyBzdWNoIG9uIHRoaXMgb2JqZWN0LiBKU0RvYyBkb2VzIG5vdCB1c3VhbGx5IGNhcnJ5IHRoZXNlIHRvIGNsYXNzZXMgaW5oZXJpdGluZyBmcm9tXG4vLyBgRGF0YVByb3ZpZGVyRW5naW5lYCBmb3Igc29tZSByZWFzb24uIE9uZSBkYXksIHdlIG1heSBiZSBhYmxlIHRvIHB1dCB0aGlzIGNvbW1lbnQgb24gYW4gYWN0dWFsXG4vLyBmdW5jdGlvbiwgc28gd2UgY2FuIGZpeCB0aGUgY29tbWVudHMgYmFjayB0byB1c2luZyByZWFsIEBcbi8qKlxuICogSlNET0MgU09VUkNFIERhdGFQcm92aWRlckVuZ2luZU5vdGlmeVVwZGF0ZVxuICpcbiAqIE1ldGhvZCB0byBydW4gdG8gc2VuZCBjbGllbnRzIHVwZGF0ZXMgZm9yIGEgc3BlY2lmaWMgZGF0YSB0eXBlIG91dHNpZGUgb2YgdGhlIGBzZXQ8ZGF0YV90eXBlPmBcbiAqIG1ldGhvZC4gcGFwaSBvdmVyd3JpdGVzIHRoaXMgZnVuY3Rpb24gb24gdGhlIERhdGFQcm92aWRlckVuZ2luZSBpdHNlbGYgdG8gZW1pdCBhbiB1cGRhdGUgYmFzZWQgb25cbiAqIHRoZSBgdXBkYXRlSW5zdHJ1Y3Rpb25zYCBhbmQgdGhlbiBydW4gdGhlIG9yaWdpbmFsIGBub3RpZnlVcGRhdGVNZXRob2RgIGZyb20gdGhlXG4gKiBgRGF0YVByb3ZpZGVyRW5naW5lYC5cbiAqXG4gKiBf77ygZXhhbXBsZV8gVG8gcnVuIGBub3RpZnlVcGRhdGVgIGZ1bmN0aW9uIHNvIGl0IHVwZGF0ZXMgdGhlIFZlcnNlIGFuZCBIZXJlc3kgZGF0YSB0eXBlcyAoaW4gYVxuICogZGF0YSBwcm92aWRlciBlbmdpbmUpOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHRoaXMubm90aWZ5VXBkYXRlKFsnVmVyc2UnLCAnSGVyZXN5J10pO1xuICogYGBgXG4gKlxuICogX++8oGV4YW1wbGVfIFlvdSBjYW4gbG9nIHRoZSBtYW51YWwgdXBkYXRlcyBpbiB5b3VyIGRhdGEgcHJvdmlkZXIgZW5naW5lIGJ5IHNwZWNpZnlpbmcgdGhlXG4gKiBmb2xsb3dpbmcgYG5vdGlmeVVwZGF0ZWAgZnVuY3Rpb24gaW4gdGhlIGRhdGEgcHJvdmlkZXIgZW5naW5lOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIG5vdGlmeVVwZGF0ZSh1cGRhdGVJbnN0cnVjdGlvbnMpIHtcbiAqICAgcGFwaS5sb2dnZXIuaW5mbyh1cGRhdGVJbnN0cnVjdGlvbnMpO1xuICogfVxuICogYGBgXG4gKlxuICogTm90ZTogVGhpcyBmdW5jdGlvbidzIHJldHVybiBpcyB0cmVhdGVkIHRoZSBzYW1lIGFzIHRoZSByZXR1cm4gZnJvbSBgc2V0PGRhdGFfdHlwZT5gXG4gKlxuICogX++8oHBhcmFtXyBgdXBkYXRlSW5zdHJ1Y3Rpb25zYCBJbmZvcm1hdGlvbiB0aGF0IHBhcGkgdXNlcyB0byBpbnRlcnByZXQgd2hldGhlciB0byBzZW5kIG91dFxuICogdXBkYXRlcy4gRGVmYXVsdHMgdG8gYCcqJ2AgKG1lYW5pbmcgc2VuZCB1cGRhdGVzIGZvciBhbGwgZGF0YSB0eXBlcykgaWYgcGFyYW1ldGVyXG4gKiBgdXBkYXRlSW5zdHJ1Y3Rpb25zYCBpcyBub3QgcHJvdmlkZWQgb3IgaXMgdW5kZWZpbmVkLiBPdGhlcndpc2UgcmV0dXJucyBgdXBkYXRlSW5zdHJ1Y3Rpb25zYC5cbiAqIHBhcGkgcGFzc2VzIHRoZSBpbnRlcnByZXRlZCB1cGRhdGUgdmFsdWUgaW50byB0aGlzIGBub3RpZnlVcGRhdGVgIGZ1bmN0aW9uLiBGb3IgZXhhbXBsZSwgcnVubmluZ1xuICogYHRoaXMubm90aWZ5VXBkYXRlKClgIHdpbGwgY2FsbCB0aGUgZGF0YSBwcm92aWRlciBlbmdpbmUncyBgbm90aWZ5VXBkYXRlYCB3aXRoXG4gKiBgdXBkYXRlSW5zdHJ1Y3Rpb25zYCBvZiBgJyonYC5cbiAqXG4gKiBf77ygc2VlXyB7QGxpbmsgRGF0YVByb3ZpZGVyVXBkYXRlSW5zdHJ1Y3Rpb25zfSBmb3IgbW9yZSBpbmZvIG9uIHRoZSBgdXBkYXRlSW5zdHJ1Y3Rpb25zYCBwYXJhbWV0ZXJcbiAqXG4gKiBXQVJOSU5HOiBEbyBub3QgdXBkYXRlIGEgZGF0YSB0eXBlIGluIGl0cyBgZ2V0PGRhdGFfdHlwZT5gIG1ldGhvZCAodW5sZXNzIHlvdSBtYWtlIGEgYmFzZSBjYXNlKSFcbiAqIEl0IHdpbGwgY3JlYXRlIGEgZGVzdHJ1Y3RpdmUgaW5maW5pdGUgbG9vcC5cbiAqL1xuZXhwb3J0IHR5cGUgRGF0YVByb3ZpZGVyRW5naW5lTm90aWZ5VXBkYXRlPFREYXRhVHlwZXMgZXh0ZW5kcyBEYXRhUHJvdmlkZXJEYXRhVHlwZXM+ID0gKFxuICB1cGRhdGVJbnN0cnVjdGlvbnM/OiBEYXRhUHJvdmlkZXJVcGRhdGVJbnN0cnVjdGlvbnM8VERhdGFUeXBlcz4sXG4pID0+IHZvaWQ7XG5cbi8qKlxuICogQWRkb24gdHlwZSBmb3IgSURhdGFQcm92aWRlckVuZ2luZSB0byBzcGVjaWZ5IHRoYXQgdGhlcmUgaXMgYSBgbm90aWZ5VXBkYXRlYCBtZXRob2Qgb24gdGhlIGRhdGFcbiAqIHByb3ZpZGVyIGVuZ2luZS4gWW91IGRvIG5vdCBuZWVkIHRvIHNwZWNpZnkgdGhpcyB0eXBlIHVubGVzcyB5b3UgYXJlIGNyZWF0aW5nIGFuIG9iamVjdCB0aGF0IGlzXG4gKiB0byBiZSByZWdpc3RlcmVkIGFzIGEgZGF0YSBwcm92aWRlciBlbmdpbmUgYW5kIHlvdSBuZWVkIHRvIHVzZSBgbm90aWZ5VXBkYXRlYC5cbiAqXG4gKiBAc2VlIHtAbGluayBEYXRhUHJvdmlkZXJFbmdpbmVOb3RpZnlVcGRhdGV9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGBub3RpZnlVcGRhdGVgLlxuICogQHNlZSB7QGxpbmsgSURhdGFQcm92aWRlckVuZ2luZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdXNpbmcgdGhpcyB0eXBlLlxuICovXG5leHBvcnQgdHlwZSBXaXRoTm90aWZ5VXBkYXRlPFREYXRhVHlwZXMgZXh0ZW5kcyBEYXRhUHJvdmlkZXJEYXRhVHlwZXM+ID0ge1xuICAvKiogSlNET0MgREVTVElOQVRJT04gRGF0YVByb3ZpZGVyRW5naW5lTm90aWZ5VXBkYXRlICovXG4gIG5vdGlmeVVwZGF0ZTogRGF0YVByb3ZpZGVyRW5naW5lTm90aWZ5VXBkYXRlPFREYXRhVHlwZXM+O1xufTtcblxuLyoqXG4gKiBUaGUgb2JqZWN0IHRvIHJlZ2lzdGVyIHdpdGggdGhlIERhdGFQcm92aWRlclNlcnZpY2UgdG8gY3JlYXRlIGEgZGF0YSBwcm92aWRlci4gVGhlXG4gKiBEYXRhUHJvdmlkZXJTZXJ2aWNlIGNyZWF0ZXMgYW4ge0BsaW5rIElEYXRhUHJvdmlkZXJ9IG9uIHRoZSBwYXBpIHRoYXQgbGF5ZXJzIG92ZXIgdGhpcyBlbmdpbmUsXG4gKiBwcm92aWRpbmcgc3BlY2lhbCBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIFNlZSB7QGxpbmsgRGF0YVByb3ZpZGVyRGF0YVR5cGVzfSBmb3IgaW5mb3JtYXRpb24gb24gaG93IHRvIG1ha2UgcG93ZXJmdWwgdHlwZXMgdGhhdCB3b3JrIHdlbGxcbiAqIHdpdGggSW50ZWxsaXNlbnNlLlxuICpcbiAqIE5vdGU6IHBhcGkgY3JlYXRlcyBhIGBub3RpZnlVcGRhdGVgIGZ1bmN0aW9uIG9uIHRoZSBkYXRhIHByb3ZpZGVyIGVuZ2luZSBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLFxuICogc28gaXQgaXMgbm90IG5lY2Vzc2FyeSB0byBwcm92aWRlIG9uZSBpbiBvcmRlciB0byBjYWxsIGB0aGlzLm5vdGlmeVVwZGF0ZWAuIEhvd2V2ZXIsIFR5cGVTY3JpcHRcbiAqIGRvZXMgbm90IHVuZGVyc3RhbmQgdGhhdCBwYXBpIHdpbGwgY3JlYXRlIG9uZSBhcyB5b3UgYXJlIHdyaXRpbmcgeW91ciBkYXRhIHByb3ZpZGVyIGVuZ2luZSwgc29cbiAqIHlvdSBjYW4gYXZvaWQgdHlwZSBlcnJvcnMgd2l0aCBvbmUgb2YgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuICpcbiAqIDEuIElmIHlvdSBhcmUgdXNpbmcgYSBjbGFzcyB0byBjcmVhdGUgYSBkYXRhIHByb3ZpZGVyIGVuZ2luZSwgeW91IGNhbiBleHRlbmQgdGhlXG4gKiAgICB7QGxpbmsgRGF0YVByb3ZpZGVyRW5naW5lfSBjbGFzcywgYW5kIGl0IHdpbGwgcHJvdmlkZSBgbm90aWZ5VXBkYXRlYCBmb3IgeW91OlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNsYXNzIE15RFBFIGV4dGVuZHMgRGF0YVByb3ZpZGVyRW5naW5lPE15RGF0YVR5cGVzPiBpbXBsZW1lbnRzIElEYXRhUHJvdmlkZXJFbmdpbmU8TXlEYXRhVHlwZXM+IHtcbiAqICAgLi4uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAyLiBJZiB5b3UgYXJlIHVzaW5nIGFuIG9iamVjdCBvciBjbGFzcyBub3QgZXh0ZW5kaW5nIHtAbGluayBEYXRhUHJvdmlkZXJFbmdpbmV9IHRvIGNyZWF0ZSBhIGRhdGFcbiAqICAgIHByb3ZpZGVyIGVuZ2luZSwgeW91IGNhbiBhZGQgYSBgbm90aWZ5VXBkYXRlYCBmdW5jdGlvbiAoYW5kLCB3aXRoIGFuIG9iamVjdCwgYWRkIHRoZVxuICogICAge0BsaW5rIFdpdGhOb3RpZnlVcGRhdGV9IHR5cGUpIHRvIHlvdXIgZGF0YSBwcm92aWRlciBlbmdpbmUgbGlrZSBzbzpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBteURQRTogSURhdGFQcm92aWRlckVuZ2luZTxNeURhdGFUeXBlcz4gJiBXaXRoTm90aWZ5VXBkYXRlPE15RGF0YVR5cGVzPiA9IHtcbiAqICAgbm90aWZ5VXBkYXRlKHVwZGF0ZUluc3RydWN0aW9ucykge30sXG4gKiAgIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogT1JcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBNeURQRSBpbXBsZW1lbnRzIElEYXRhUHJvdmlkZXJFbmdpbmU8TXlEYXRhVHlwZXM+IHtcbiAqICAgbm90aWZ5VXBkYXRlKHVwZGF0ZUluc3RydWN0aW9ucz86IERhdGFQcm92aWRlckVuZ2luZU5vdGlmeVVwZGF0ZTxNeURhdGFUeXBlcz4pIHt9XG4gKiAgIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogQHR5cGUgYFREYXRhVHlwZXNgIC0gVGhlIGRhdGEgdHlwZXMgdGhhdCB0aGlzIGRhdGEgcHJvdmlkZXIgZW5naW5lIHNlcnZlcy4gRm9yIGVhY2ggZGF0YSB0eXBlXG4gKiAgIGRlZmluZWQsIHRoZSBlbmdpbmUgbXVzdCBoYXZlIGNvcnJlc3BvbmRpbmcgYGdldDxkYXRhX3R5cGU+YCBhbmQgYHNldDxkYXRhX3R5cGU+IGZ1bmN0aW9uYFxuICogICBmdW5jdGlvbnMuXG4gKi9cbi8vIFRyeSB1c2luZyBEYXRhUHJvdmlkZXJOYW1lIGhlcmUgaW5zdGVhZCBvZiBURGF0YVR5cGVzP1xuZXhwb3J0IHR5cGUgSURhdGFQcm92aWRlckVuZ2luZTxURGF0YVR5cGVzIGV4dGVuZHMgRGF0YVByb3ZpZGVyRGF0YVR5cGVzID0gRGF0YVByb3ZpZGVyRGF0YVR5cGVzPiA9XG4gIE5ldHdvcmthYmxlT2JqZWN0ICZcbiAgICAvKipcbiAgICAgKiBTZXQgb2YgYWxsIGBzZXQ8ZGF0YV90eXBlPmAgbWV0aG9kcyB0aGF0IGEgZGF0YSBwcm92aWRlciBlbmdpbmUgbXVzdCBwcm92aWRlIGFjY29yZGluZyB0byBpdHNcbiAgICAgKiBkYXRhIHR5cGVzLiBwYXBpIG92ZXJ3cml0ZXMgdGhpcyBmdW5jdGlvbiBvbiB0aGUgRGF0YVByb3ZpZGVyRW5naW5lIGl0c2VsZiB0byBlbWl0IGFuIHVwZGF0ZVxuICAgICAqIGFmdGVyIHJ1bm5pbmcgdGhlIGRlZmluZWQgYHNldDxkYXRhX3R5cGU+YCBtZXRob2QgaW4gdGhlIERhdGFQcm92aWRlckVuZ2luZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IHBhcGkgcmVxdWlyZXMgdGhhdCBlYWNoIGBzZXQ8ZGF0YV90eXBlPmAgbWV0aG9kIGhhcyBhIGNvcnJlc3BvbmRpbmcgYGdldDxkYXRhX3R5cGU+YFxuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRvIG1ha2UgYSBkYXRhIHR5cGUgcmVhZC1vbmx5LCB5b3UgY2FuIGFsd2F5cyByZXR1cm4gZmFsc2Ugb3IgdGhyb3cgZnJvbVxuICAgICAqIGBzZXQ8ZGF0YV90eXBlPmAuXG4gICAgICpcbiAgICAgKiBXQVJOSU5HOiBEbyBub3QgcnVuIHRoaXMgcmVjdXJzaXZlbHkgaW4gaXRzIG93biBgc2V0PGRhdGFfdHlwZT5gIG1ldGhvZCEgSXQgd2lsbCBjcmVhdGUgYXNcbiAgICAgKiBtYW55IHVwZGF0ZXMgYXMgeW91IHJ1biBgc2V0PGRhdGFfdHlwZT5gIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBEYXRhUHJvdmlkZXJTZXR0ZXJ9IGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgRGF0YVByb3ZpZGVyU2V0dGVyczxURGF0YVR5cGVzPiAmXG4gICAgLyoqXG4gICAgICogU2V0IG9mIGFsbCBgZ2V0PGRhdGFfdHlwZT5gIG1ldGhvZHMgdGhhdCBhIGRhdGEgcHJvdmlkZXIgZW5naW5lIG11c3QgcHJvdmlkZSBhY2NvcmRpbmcgdG8gaXRzXG4gICAgICogZGF0YSB0eXBlcy4gUnVuIGJ5IHRoZSBkYXRhIHByb3ZpZGVyIG9uIGBnZXQ8ZGF0YV90eXBlPmBcbiAgICAgKlxuICAgICAqIE5vdGU6IHBhcGkgcmVxdWlyZXMgdGhhdCBlYWNoIGBzZXQ8ZGF0YV90eXBlPmAgbWV0aG9kIGhhcyBhIGNvcnJlc3BvbmRpbmcgYGdldDxkYXRhX3R5cGU+YFxuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIERhdGFQcm92aWRlckdldHRlcn0gZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBEYXRhUHJvdmlkZXJHZXR0ZXJzPFREYXRhVHlwZXM+ICZcbiAgICBQYXJ0aWFsPFdpdGhOb3RpZnlVcGRhdGU8VERhdGFUeXBlcz4+O1xuXG5leHBvcnQgZGVmYXVsdCBJRGF0YVByb3ZpZGVyRW5naW5lO1xuXG4vKipcbiAqIEpTRE9DIFNPVVJDRSBEYXRhUHJvdmlkZXJFbmdpbmVcbiAqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHByb3ZpZGVzIGEgcGxhY2Vob2xkZXIgYG5vdGlmeVVwZGF0ZWAgZm9yIGRhdGEgcHJvdmlkZXIgZW5naW5lIGNsYXNzZXMuIElmIGFcbiAqIGRhdGEgcHJvdmlkZXIgZW5naW5lIGNsYXNzIGV4dGVuZHMgdGhpcyBjbGFzcywgaXQgZG9lc24ndCBoYXZlIHRvIHNwZWNpZnkgaXRzIG93biBgbm90aWZ5VXBkYXRlYFxuICogZnVuY3Rpb24gaW4gb3JkZXIgdG8gdXNlIGBub3RpZnlVcGRhdGVgLlxuICpcbiAqIEBzZWUge0BsaW5rIElEYXRhUHJvdmlkZXJFbmdpbmV9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGV4dGVuZGluZyB0aGlzIGNsYXNzLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0YVByb3ZpZGVyRW5naW5lPFREYXRhVHlwZXMgZXh0ZW5kcyBEYXRhUHJvdmlkZXJEYXRhVHlwZXM+XG4gIGltcGxlbWVudHMgV2l0aE5vdGlmeVVwZGF0ZTxURGF0YVR5cGVzPlxue1xuICAvLyBUaGlzIGlzIGp1c3QgYSBwbGFjZWhvbGRlciBhbmQgd2lsbCBiZSBsYXllcmVkIG92ZXIgYnkgcGFwaS4gV2UgZG9uJ3QgbmVlZCBpdCB0byBkbyBhbnl0aGluZ1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIHRzKDYxMzMpIGB1cGRhdGVJbnN0cnVjdGlvbnNgIGlzIG5vdCB1c2VkIGluIHRoaXMgbWV0aG9kLCBidXQgd2UgZG9uJ3QgY2FyZVxuICAvLyBiZWNhdXNlIHdlIHdhbnQgaW5oZXJpdGluZyBjbGFzc2VzIHRvIGJlIGFibGUgdG8gZ2V0IHRoaXMgbWV0aG9kIHdpdGggSW50ZWxsaXNlbnNlIHdpdGhvdXRcbiAgLy8gYW4gdW5kZXJzY29yZSB0aGF0IGluZGljYXRlcyB0byBUeXBlU2NyaXB0IHRoYXQgd2UgYXJlbid0IHVzaW5nIHRoZSBwYXJhbWV0ZXJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jbGFzcy1tZXRob2RzLXVzZS10aGlzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgbm90aWZ5VXBkYXRlKHVwZGF0ZUluc3RydWN0aW9ucz86IERhdGFQcm92aWRlclVwZGF0ZUluc3RydWN0aW9uczxURGF0YVR5cGVzPik6IHZvaWQge31cbn1cbiIsImltcG9ydCB7XG4gIHN0cmluZ0xlbmd0aCxcbiAgVW5zdWJzY3JpYmVyQXN5bmMsXG4gIFBsYXRmb3JtRXZlbnRIYW5kbGVyLFxuICBzdWJzdHJpbmcsXG4gIHN0YXJ0c1dpdGgsXG59IGZyb20gJ3BsYXRmb3JtLWJpYmxlLXV0aWxzJztcbmltcG9ydCB7IE5ldHdvcmthYmxlT2JqZWN0IH0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvbmV0d29yay1vYmplY3QubW9kZWwnO1xuXG4vKiogVmFyaW91cyBvcHRpb25zIHRvIGFkanVzdCBob3cgdGhlIGRhdGEgcHJvdmlkZXIgc3Vic2NyaWJlciBlbWl0cyB1cGRhdGVzICovXG5leHBvcnQgdHlwZSBEYXRhUHJvdmlkZXJTdWJzY3JpYmVyT3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gaW1tZWRpYXRlbHkgcmV0cmlldmUgdGhlIGRhdGEgZm9yIHRoaXMgc3Vic2NyaWJlciBhbmQgcnVuIHRoZSBjYWxsYmFjayBhcyBzb29uIGFzXG4gICAqIHBvc3NpYmxlLlxuICAgKlxuICAgKiBUaGlzIGFsbG93cyBhIHN1YnNjcmliZXIgdG8gc2ltcGx5IHN1YnNjcmliZSBhbmQgcHJvdmlkZSBhIGNhbGxiYWNrIGluc3RlYWQgb2Ygc3Vic2NyaWJpbmcsXG4gICAqIHJ1bm5pbmcgYGdldGAsIGFuZCBtYW5hZ2luZyB0aGUgcmFjZSBjb25kaXRpb24gb2YgYW4gZXZlbnQgY29taW5nIGluIHRvIHVwZGF0ZSB0aGUgZGF0YSBhbmQgdGhlXG4gICAqIGluaXRpYWwgYGdldGAgY29taW5nIGJhY2sgaW4uXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJldHJpZXZlRGF0YUltbWVkaWF0ZWx5PzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFVuZGVyIHdoaWNoIGNvbmRpdGlvbnMgdG8gcnVuIHRoZSBjYWxsYmFjayB3aGVuIHdlIHJlY2VpdmUgdXBkYXRlcyB0byB0aGUgZGF0YS5cbiAgICpcbiAgICogLSBgJ2RlZXBseS1lcXVhbCdgIC0gb25seSBydW4gdGhlIHVwZGF0ZSBjYWxsYmFjayB3aGVuIHRoZSBkYXRhIGF0IHRoaXMgc2VsZWN0b3IgaGFzIGNoYW5nZWQuXG4gICAqXG4gICAqICAgRm9yIGV4YW1wbGUsIHN1cHBvc2UgeW91ciBzZWxlY3RvciBpcyB0YXJnZXRpbmcgSm9obiAzOjUsIGFuZCB0aGUgZGF0YSBwcm92aWRlciB1cGRhdGVzIGl0c1xuICAgKiAgIGRhdGEgZm9yIEx1a2UgNTozLiBZb3VyIGRhdGEgYXQgSm9obiAzOjUgZG9lcyBub3QgY2hhbmdlLCBhbmQgeW91ciBjYWxsYmFjayB3aWxsIG5vdCBydW4uXG4gICAqIC0gYCcqJ2AgLSBydW4gdGhlIHVwZGF0ZSBjYWxsYmFjayBldmVyeSB0aW1lIHRoZSBkYXRhIGhhcyBiZWVuIHVwZGF0ZWQgd2hldGhlciBvciBub3QgdGhlIGRhdGEgYXRcbiAgICogICB0aGlzIHNlbGVjdG9yIGhhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiAgIEZvciBleGFtcGxlLCBzdXBwb3NlIHlvdXIgc2VsZWN0b3IgaXMgdGFyZ2V0aW5nIEpvaG4gMzo1LCBhbmQgdGhlIGRhdGEgcHJvdmlkZXIgdXBkYXRlcyBpdHNcbiAgICogICBkYXRhIGZvciBMdWtlIDU6My4gWW91ciBkYXRhIGF0IEpvaG4gMzo1IGRvZXMgbm90IGNoYW5nZSwgYnV0IHlvdXIgY2FsbGJhY2sgd2lsbCBydW4gYWdhaW5cbiAgICogICB3aXRoIHRoZSBzYW1lIGRhdGEgYW55d2F5LlxuICAgKlxuICAgKiBAZGVmYXVsdCAnZGVlcGx5LWVxdWFsJ1xuICAgKi9cbiAgd2hpY2hVcGRhdGVzPzogJ2RlZXBseS1lcXVhbCcgfCAnKic7XG59O1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIHRoYXQgcGFwaSB1c2VzIHRvIGludGVycHJldCB3aGV0aGVyIHRvIHNlbmQgb3V0IHVwZGF0ZXMgb24gYSBkYXRhIHByb3ZpZGVyIHdoZW4gdGhlXG4gKiBlbmdpbmUgcnVucyBgc2V0PGRhdGFfdHlwZT5gIG9yIGBub3RpZnlVcGRhdGVgLlxuICpcbiAqIC0gYCcqJ2AgdXBkYXRlIHN1YnNjcmlwdGlvbnMgZm9yIGFsbCBkYXRhIHR5cGVzIG9uIHRoaXMgZGF0YSBwcm92aWRlclxuICogLSBgc3RyaW5nYCBuYW1lIG9mIGRhdGEgdHlwZSAtIHVwZGF0ZSBzdWJzY3JpcHRpb25zIGZvciB0aGlzIGRhdGEgdHlwZVxuICogLSBgc3RyaW5nW11gIG5hbWVzIG9mIGRhdGEgdHlwZXMgLSB1cGRhdGUgc3Vic2NyaXB0aW9ucyBmb3IgdGhlIGRhdGEgdHlwZXMgaW4gdGhlIGFycmF5XG4gKiAtIGB0cnVlYCAob3Igb3RoZXIgdHJ1dGh5IHZhbHVlcyBvdGhlciB0aGFuIHN0cmluZ3MgYW5kIGFycmF5cylcbiAqXG4gKiAgIC0gSW4gYHNldDxkYXRhX3R5cGU+YCAtIHVwZGF0ZSBzdWJzY3JpcHRpb25zIGZvciB0aGlzIGRhdGEgdHlwZVxuICogICAtIEluIGBub3RpZnlVcGRhdGVgIC0gc2FtZSBhcyAnKidcbiAqIC0gYGZhbHNlYCAob3IgZmFsc3kpIGRvIG5vdCB1cGRhdGUgc3Vic2NyaXB0aW9uc1xuICovXG5leHBvcnQgdHlwZSBEYXRhUHJvdmlkZXJVcGRhdGVJbnN0cnVjdGlvbnM8VERhdGFUeXBlcyBleHRlbmRzIERhdGFQcm92aWRlckRhdGFUeXBlcz4gPVxuICB8ICcqJ1xuICB8IERhdGFUeXBlTmFtZXM8VERhdGFUeXBlcz5cbiAgfCBEYXRhVHlwZU5hbWVzPFREYXRhVHlwZXM+W11cbiAgfCBib29sZWFuO1xuXG4vKipcbiAqIFNldCBhIHN1YnNldCBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgc2VsZWN0b3IuXG4gKlxuICogTm90ZTogaWYgYSBkYXRhIHByb3ZpZGVyIGVuZ2luZSBkb2VzIG5vdCBwcm92aWRlIGBzZXRgIChwb3NzaWJseSBpbmRpY2F0aW5nIGl0IGlzIHJlYWQtb25seSksXG4gKiB0aGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICpcbiAqIEBwYXJhbSBzZWxlY3RvciBUZWxscyB0aGUgcHJvdmlkZXIgd2hhdCBzdWJzZXQgb2YgZGF0YSBpcyBiZWluZyBzZXRcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRoYXQgZGV0ZXJtaW5lcyB3aGF0IHRvIHNldCBhdCB0aGUgc2VsZWN0b3JcbiAqIEByZXR1cm5zIEluZm9ybWF0aW9uIHRoYXQgcGFwaSB1c2VzIHRvIGludGVycHJldCB3aGV0aGVyIHRvIHNlbmQgb3V0IHVwZGF0ZXMuIERlZmF1bHRzIHRvIGB0cnVlYFxuICogICAobWVhbmluZyBzZW5kIHVwZGF0ZXMgb25seSBmb3IgdGhpcyBkYXRhIHR5cGUpLlxuICogQHNlZSB7QGxpbmsgRGF0YVByb3ZpZGVyVXBkYXRlSW5zdHJ1Y3Rpb25zfSBmb3IgbW9yZSBpbmZvIG9uIHdoYXQgdG8gcmV0dXJuXG4gKi9cbmV4cG9ydCB0eXBlIERhdGFQcm92aWRlclNldHRlcjxcbiAgVERhdGFUeXBlcyBleHRlbmRzIERhdGFQcm92aWRlckRhdGFUeXBlcyxcbiAgRGF0YVR5cGUgZXh0ZW5kcyBrZXlvZiBURGF0YVR5cGVzLFxuPiA9IChcbiAgc2VsZWN0b3I6IFREYXRhVHlwZXNbRGF0YVR5cGVdWydzZWxlY3RvciddLFxuICBkYXRhOiBURGF0YVR5cGVzW0RhdGFUeXBlXVsnc2V0RGF0YSddLFxuKSA9PiBQcm9taXNlPERhdGFQcm92aWRlclVwZGF0ZUluc3RydWN0aW9uczxURGF0YVR5cGVzPj47XG5cbi8qKlxuICogR2V0IGEgc3Vic2V0IG9mIGRhdGEgZnJvbSB0aGUgcHJvdmlkZXIgYWNjb3JkaW5nIHRvIHRoZSBzZWxlY3Rvci5cbiAqXG4gKiBOb3RlOiBUaGlzIGlzIGdvb2QgZm9yIHJldHJpZXZpbmcgZGF0YSBmcm9tIGEgcHJvdmlkZXIgb25jZS4gSWYgeW91IHdhbnQgdG8ga2VlcCB0aGUgZGF0YVxuICogdXAtdG8tZGF0ZSwgdXNlIGBzdWJzY3JpYmVgIGluc3RlYWQsIHdoaWNoIGNhbiBpbW1lZGlhdGVseSBnaXZlIHlvdSB0aGUgZGF0YSBhbmQga2VlcCBpdFxuICogdXAtdG8tZGF0ZS5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgVGVsbHMgdGhlIHByb3ZpZGVyIHdoYXQgc3Vic2V0IG9mIGRhdGEgdG8gZ2V0XG4gKiBAcmV0dXJucyBUaGUgc3Vic2V0IG9mIGRhdGEgcmVwcmVzZW50ZWQgYnkgdGhlIHNlbGVjdG9yXG4gKi9cbmV4cG9ydCB0eXBlIERhdGFQcm92aWRlckdldHRlcjxURGF0YVR5cGUgZXh0ZW5kcyBEYXRhUHJvdmlkZXJEYXRhVHlwZT4gPSAoXG4gIHNlbGVjdG9yOiBURGF0YVR5cGVbJ3NlbGVjdG9yJ10sXG4pID0+IFByb21pc2U8VERhdGFUeXBlWydnZXREYXRhJ10+O1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byByZWNlaXZlIHVwZGF0ZXMgcmVsZXZhbnQgdG8gdGhlIHByb3ZpZGVkIHNlbGVjdG9yIGZyb20gdGhpcyBkYXRhIHByb3ZpZGVyIGZvciBhXG4gKiBzcGVjaWZpYyBkYXRhIHR5cGUuXG4gKlxuICogTm90ZTogQnkgZGVmYXVsdCwgdGhpcyBgc3Vic2NyaWJlPGRhdGFfdHlwZT5gIGZ1bmN0aW9uIGF1dG9tYXRpY2FsbHkgcmV0cmlldmVzIHRoZSBjdXJyZW50IHN0YXRlXG4gKiBvZiB0aGUgZGF0YSBhbmQgcnVucyB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgYXMgc29vbiBhcyBwb3NzaWJsZS4gVGhhdCB3YXksIGlmIHlvdSB3YW50IHRvIGtlZXBcbiAqIHlvdXIgZGF0YSB1cC10by1kYXRlLCB5b3UgZG8gbm90IGFsc28gaGF2ZSB0byBydW4gYGdldDxkYXRhX3R5cGU+YC4gWW91IGNhbiB0dXJuIHRoaXNcbiAqIGZ1bmN0aW9uYWxpdHkgb2ZmIGluIHRoZSBgb3B0aW9uc2AgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSBzZWxlY3RvciBUZWxscyB0aGUgcHJvdmlkZXIgd2hhdCBkYXRhIHRoaXMgbGlzdGVuZXIgaXMgbGlzdGVuaW5nIGZvclxuICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIHJ1biB3aXRoIHRoZSB1cGRhdGVkIGRhdGEgZm9yIHRoaXMgc2VsZWN0b3JcbiAqIEBwYXJhbSBvcHRpb25zIFZhcmlvdXMgb3B0aW9ucyB0byBhZGp1c3QgaG93IHRoZSBzdWJzY3JpYmVyIGVtaXRzIHVwZGF0ZXNcbiAqIEByZXR1cm5zIFVuc3Vic2NyaWJlciB0byBzdG9wIGxpc3RlbmluZyBmb3IgdXBkYXRlc1xuICovXG5leHBvcnQgdHlwZSBEYXRhUHJvdmlkZXJTdWJzY3JpYmVyPFREYXRhVHlwZSBleHRlbmRzIERhdGFQcm92aWRlckRhdGFUeXBlPiA9IChcbiAgc2VsZWN0b3I6IFREYXRhVHlwZVsnc2VsZWN0b3InXSxcbiAgY2FsbGJhY2s6IFBsYXRmb3JtRXZlbnRIYW5kbGVyPFREYXRhVHlwZVsnZ2V0RGF0YSddPixcbiAgb3B0aW9ucz86IERhdGFQcm92aWRlclN1YnNjcmliZXJPcHRpb25zLFxuKSA9PiBQcm9taXNlPFVuc3Vic2NyaWJlckFzeW5jPjtcblxuLyoqXG4gKiBBIGhlbHBlciB0eXBlIGRlc2NyaWJpbmcgdGhlIHR5cGVzIGFzc29jaWF0ZWQgd2l0aCBhIGRhdGEgcHJvdmlkZXIncyBtZXRob2RzIGZvciBhIHNwZWNpZmljIGRhdGFcbiAqIHR5cGUgaXQgaGFuZGxlcy5cbiAqXG4gKiBAdHlwZSBgVFNlbGVjdG9yYCAtIFRoZSB0eXBlIG9mIHNlbGVjdG9yIHVzZWQgdG8gZ2V0IHNvbWUgZGF0YSBmcm9tIHRoaXMgcHJvdmlkZXIgYXQgdGhpcyBkYXRhXG4gKiAgIHR5cGUuIEEgc2VsZWN0b3IgaXMgYW4gb2JqZWN0IGEgY2FsbGVyIHByb3ZpZGVzIHRvIHRoZSBkYXRhIHByb3ZpZGVyIHRvIHRlbGwgdGhlIHByb3ZpZGVyIHdoYXRcbiAqICAgc3Vic2V0IG9mIGRhdGEgaXQgd2FudHMgYXQgdGhpcyBkYXRhIHR5cGUuXG4gKiBAdHlwZSBgVEdldERhdGFgIC0gVGhlIHR5cGUgb2YgZGF0YSBwcm92aWRlZCBieSB0aGlzIGRhdGEgcHJvdmlkZXIgd2hlbiB5b3UgcnVuIGBnZXQ8ZGF0YV90eXBlPmBcbiAqICAgYmFzZWQgb24gYSBwcm92aWRlZCBzZWxlY3RvclxuICogQHR5cGUgYFRTZXREYXRhYCAtIFRoZSB0eXBlIG9mIGRhdGEgaW5nZXN0ZWQgYnkgdGhpcyBkYXRhIHByb3ZpZGVyIHdoZW4geW91IHJ1biBgc2V0PGRhdGFfdHlwZT5gXG4gKiAgIGJhc2VkIG9uIGEgcHJvdmlkZWQgc2VsZWN0b3JcbiAqL1xuZXhwb3J0IHR5cGUgRGF0YVByb3ZpZGVyRGF0YVR5cGU8VFNlbGVjdG9yID0gdW5rbm93biwgVEdldERhdGEgPSBUU2VsZWN0b3IsIFRTZXREYXRhID0gVEdldERhdGE+ID0ge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2Ygc2VsZWN0b3IgdXNlZCB0byBnZXQgc29tZSBkYXRhIGZyb20gdGhpcyBwcm92aWRlciBhdCB0aGlzIGRhdGEgdHlwZS4gQSBzZWxlY3RvciBpc1xuICAgKiBhbiBvYmplY3QgYSBjYWxsZXIgcHJvdmlkZXMgdG8gdGhlIGRhdGEgcHJvdmlkZXIgdG8gdGVsbCB0aGUgcHJvdmlkZXIgd2hhdCBzdWJzZXQgb2YgZGF0YSBpdFxuICAgKiB3YW50cyBhdCB0aGlzIGRhdGEgdHlwZS5cbiAgICovXG4gIHNlbGVjdG9yOiBUU2VsZWN0b3I7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBkYXRhIHByb3ZpZGVkIGJ5IHRoaXMgZGF0YSBwcm92aWRlciB3aGVuIHlvdSBydW4gYGdldDxkYXRhX3R5cGU+YCBiYXNlZCBvbiBhXG4gICAqIHByb3ZpZGVkIHNlbGVjdG9yXG4gICAqL1xuICBnZXREYXRhOiBUR2V0RGF0YTtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGRhdGEgaW5nZXN0ZWQgYnkgdGhpcyBkYXRhIHByb3ZpZGVyIHdoZW4geW91IHJ1biBgc2V0PGRhdGFfdHlwZT5gIGJhc2VkIG9uIGFcbiAgICogcHJvdmlkZWQgc2VsZWN0b3JcbiAgICovXG4gIHNldERhdGE6IFRTZXREYXRhO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciB0eXBlIGRlc2NyaWJpbmcgYWxsIHRoZSBkYXRhIHR5cGVzIGEgZGF0YSBwcm92aWRlciBoYW5kbGVzLiBFYWNoIHByb3BlcnR5IG9uIHRoaXMgdHlwZVxuICogKGNvbnNpc3Rpbmcgb2YgYSBEYXRhUHJvdmlkZXJEYXRhVHlwZSwgd2hpY2ggZGVzY3JpYmVzIHRoZSB0eXBlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhhdCBkYXRhXG4gKiB0eXBlKSBkZXNjcmliZXMgYSBkYXRhIHR5cGUgdGhhdCB0aGUgZGF0YSBwcm92aWRlciBoYW5kbGVzLiBUaGUgZGF0YSBwcm92aWRlciBoYXMgYVxuICogYHNldDxkYXRhX3R5cGU+YCwgYGdldDxkYXRhX3R5cGU+YCwgYW5kIGBzdWJzY3JpYmU8ZGF0YV90eXBlPmAgZm9yIGVhY2ggcHJvcGVydHkgKGFrYSBkYXRhIHR5cGUpXG4gKiBsaXN0ZWQgaW4gdGhpcyB0eXBlLlxuICpcbiAqIEBleGFtcGxlIEEgZGF0YSBwcm92aWRlciB0aGF0IGhhbmRsZXMgZ3JlZXRpbmcgc3RyaW5ncyBhbmQgYWdlIG51bWJlcnMgKGFzIHdlbGwgYXMgYW4gQWxsIGRhdGFcbiAqIHR5cGUgdGhhdCBqdXN0IHByb3ZpZGVzIGFsbCB0aGUgZGF0YSkgY291bGQgaGF2ZSBhIERhdGFQcm92aWRlckRhdGFUeXBlcyB0aGF0IGxvb2tzIGxpa2UgdGhlXG4gKiBmb2xsb3dpbmc6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICoge1xuICogR3JlZXRpbmc6IERhdGFQcm92aWRlckRhdGFUeXBlPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkLCBzdHJpbmc+O1xuICogQWdlOiBEYXRhUHJvdmlkZXJEYXRhVHlwZTxzdHJpbmcsIG51bWJlciB8IHVuZGVmaW5lZCwgbnVtYmVyPjtcbiAqIEFsbDogRGF0YVByb3ZpZGVyRGF0YVR5cGU8dW5kZWZpbmVkLCB7IGdyZWV0aW5nOiBzdHJpbmcsIGFnZTogbnVtYmVyIH0sIG5ldmVyPjtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgdHlwZSBEYXRhUHJvdmlkZXJEYXRhVHlwZXMgPSB7XG4gIFtkYXRhVHlwZTogc3RyaW5nXTogRGF0YVByb3ZpZGVyRGF0YVR5cGU7XG59O1xuXG4vKipcbiAqIE5hbWVzIG9mIGRhdGEgdHlwZXMgaW4gYSBEYXRhUHJvdmlkZXJEYXRhVHlwZXMgdHlwZS4gSW5kaWNhdGVzIHRoZSBkYXRhIHR5cGVzIHRoYXQgYSBkYXRhXG4gKiBwcm92aWRlciBjYW4gaGFuZGxlIChzbyBpdCB3aWxsIGhhdmUgbWV0aG9kcyB3aXRoIHRoZXNlIG5hbWVzIGxpa2UgYHNldDxkYXRhX3R5cGU+YClcbiAqXG4gKiBAc2VlIHtAbGluayBEYXRhUHJvdmlkZXJEYXRhVHlwZXN9IGZvciBtb3JlIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIERhdGFUeXBlTmFtZXM8VERhdGFUeXBlcyBleHRlbmRzIERhdGFQcm92aWRlckRhdGFUeXBlcyA9IERhdGFQcm92aWRlckRhdGFUeXBlcz4gPVxuICBrZXlvZiBURGF0YVR5cGVzICYgc3RyaW5nO1xuXG4vKipcbiAqIFNldCBvZiBhbGwgYHNldDxkYXRhX3R5cGU+YCBtZXRob2RzIHRoYXQgYSBkYXRhIHByb3ZpZGVyIHByb3ZpZGVzIGFjY29yZGluZyB0byBpdHMgZGF0YSB0eXBlcy5cbiAqXG4gKiBAc2VlIHtAbGluayBEYXRhUHJvdmlkZXJTZXR0ZXJ9IGZvciBtb3JlIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIERhdGFQcm92aWRlclNldHRlcnM8VERhdGFUeXBlcyBleHRlbmRzIERhdGFQcm92aWRlckRhdGFUeXBlcz4gPSB7XG4gIFtEYXRhVHlwZSBpbiBrZXlvZiBURGF0YVR5cGVzIGFzIGBzZXQke0RhdGFUeXBlICYgc3RyaW5nfWBdOiBEYXRhUHJvdmlkZXJTZXR0ZXI8XG4gICAgVERhdGFUeXBlcyxcbiAgICBEYXRhVHlwZVxuICA+O1xufTtcblxuLyoqXG4gKiBTZXQgb2YgYWxsIGBnZXQ8ZGF0YV90eXBlPmAgbWV0aG9kcyB0aGF0IGEgZGF0YSBwcm92aWRlciBwcm92aWRlcyBhY2NvcmRpbmcgdG8gaXRzIGRhdGEgdHlwZXMuXG4gKlxuICogQHNlZSB7QGxpbmsgRGF0YVByb3ZpZGVyR2V0dGVyfSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgdHlwZSBEYXRhUHJvdmlkZXJHZXR0ZXJzPFREYXRhVHlwZXMgZXh0ZW5kcyBEYXRhUHJvdmlkZXJEYXRhVHlwZXM+ID0ge1xuICBbRGF0YVR5cGUgaW4ga2V5b2YgVERhdGFUeXBlcyBhcyBgZ2V0JHtEYXRhVHlwZSAmIHN0cmluZ31gXTogRGF0YVByb3ZpZGVyR2V0dGVyPFxuICAgIFREYXRhVHlwZXNbRGF0YVR5cGVdXG4gID47XG59O1xuXG4vKipcbiAqIFNldCBvZiBhbGwgYHN1YnNjcmliZTxkYXRhX3R5cGU+YCBtZXRob2RzIHRoYXQgYSBkYXRhIHByb3ZpZGVyIHByb3ZpZGVzIGFjY29yZGluZyB0byBpdHMgZGF0YVxuICogdHlwZXMuXG4gKlxuICogQHNlZSB7QGxpbmsgRGF0YVByb3ZpZGVyU3Vic2NyaWJlcn0gZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IHR5cGUgRGF0YVByb3ZpZGVyU3Vic2NyaWJlcnM8VERhdGFUeXBlcyBleHRlbmRzIERhdGFQcm92aWRlckRhdGFUeXBlcz4gPSB7XG4gIFtEYXRhVHlwZSBpbiBrZXlvZiBURGF0YVR5cGVzIGFzIGBzdWJzY3JpYmUke0RhdGFUeXBlICYgc3RyaW5nfWBdOiBEYXRhUHJvdmlkZXJTdWJzY3JpYmVyPFxuICAgIFREYXRhVHlwZXNbRGF0YVR5cGVdXG4gID47XG59O1xuXG4vKipcbiAqIEFuIGludGVybmFsIG9iamVjdCBjcmVhdGVkIGxvY2FsbHkgd2hlbiBzb21lb25lIHJ1bnMgZGF0YVByb3ZpZGVyU2VydmljZS5yZWdpc3RlckVuZ2luZS4gVGhpc1xuICogb2JqZWN0IGxheWVycyBvdmVyIHRoZSBkYXRhIHByb3ZpZGVyIGVuZ2luZSBhbmQgcnVucyBpdHMgbWV0aG9kcyBhbG9uZyB3aXRoIG90aGVyIG1ldGhvZHMuIFRoaXNcbiAqIG9iamVjdCBpcyB0cmFuc2Zvcm1lZCBpbnRvIGFuIElEYXRhUHJvdmlkZXIgYnkgbmV0d29ya09iamVjdFNlcnZpY2Uuc2V0LlxuICpcbiAqIEBzZWUge0BsaW5rIElEYXRhUHJvdmlkZXJ9XG4gKi9cbmV4cG9ydCB0eXBlIERhdGFQcm92aWRlckludGVybmFsPFREYXRhVHlwZXMgZXh0ZW5kcyBEYXRhUHJvdmlkZXJEYXRhVHlwZXMgPSBEYXRhUHJvdmlkZXJEYXRhVHlwZXM+ID1cbiAgTmV0d29ya2FibGVPYmplY3Q8XG4gICAgRGF0YVByb3ZpZGVyU2V0dGVyczxURGF0YVR5cGVzPiAmXG4gICAgICBEYXRhUHJvdmlkZXJHZXR0ZXJzPFREYXRhVHlwZXM+ICZcbiAgICAgIERhdGFQcm92aWRlclN1YnNjcmliZXJzPFREYXRhVHlwZXM+XG4gID47XG5cbi8qKiBUaGUgZnVuY3Rpb25zIHRoYXQgYSBkYXRhIHByb3ZpZGVyIGhhcyBmb3IgZWFjaCBkYXRhIHR5cGUgKi9cbmNvbnN0IGRhdGFQcm92aWRlckZ1bmN0aW9uUHJlZml4ZXMgPSBbJ3NldCcsICdnZXQnLCAnc3Vic2NyaWJlJ107XG5cbi8qKlxuICogR2V0IHRoZSBkYXRhIHR5cGUgZm9yIGEgZGF0YSBwcm92aWRlciBmdW5jdGlvbiBiYXNlZCBvbiBpdHMgbmFtZVxuICpcbiAqIEBwYXJhbSBmbk5hbWUgTmFtZSBvZiBkYXRhIHByb3ZpZGVyIGZ1bmN0aW9uIGUuZy4gYGdldFZlcnNlYFxuICogQHJldHVybnMgRGF0YSB0eXBlIGZvciB0aGF0IGRhdGEgcHJvdmlkZXIgZnVuY3Rpb24gZS5nLiBgVmVyc2VgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhUHJvdmlkZXJEYXRhVHlwZUZyb21GdW5jdGlvbk5hbWU8XG4gIFREYXRhVHlwZXMgZXh0ZW5kcyBEYXRhUHJvdmlkZXJEYXRhVHlwZXMgPSBEYXRhUHJvdmlkZXJEYXRhVHlwZXMsXG4+KGZuTmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IGZuUHJlZml4ID0gZGF0YVByb3ZpZGVyRnVuY3Rpb25QcmVmaXhlcy5maW5kKChwcmVmaXgpID0+IHN0YXJ0c1dpdGgoZm5OYW1lLCBwcmVmaXgpKTtcbiAgaWYgKCFmblByZWZpeCkgdGhyb3cgbmV3IEVycm9yKGAke2ZuTmFtZX0gaXMgbm90IGEgZGF0YSBwcm92aWRlciBkYXRhIHR5cGUgZnVuY3Rpb25gKTtcblxuICAvLyBBc3NlcnQgdGhlIGV4cGVjdGVkIHJldHVybiB0eXBlLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgcmV0dXJuIHN1YnN0cmluZyhmbk5hbWUsIHN0cmluZ0xlbmd0aChmblByZWZpeCkpIGFzIERhdGFUeXBlTmFtZXM8VERhdGFUeXBlcz47XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFQcm92aWRlckludGVybmFsO1xuIiwiaW1wb3J0IHsgTmV0d29ya09iamVjdERldGFpbHMgfSBmcm9tICdAc2hhcmVkL21vZGVscy9uZXR3b3JrLW9iamVjdC5tb2RlbCc7XG4vLyBMaW5rZWQgaW4gVFNEb2Ncbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7IGlzU3Vic2V0IH0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuXG4vLyBGdW5jdGlvbnMgdGhhdCBhcmUgZXhwb3NlZCB0aHJvdWdoIHRoZSBuZXR3b3JrIG9iamVjdFxuZXhwb3J0IGludGVyZmFjZSBOZXR3b3JrT2JqZWN0U3RhdHVzUmVtb3RlU2VydmljZVR5cGUge1xuICAvKipcbiAgICogR2V0IGRldGFpbHMgYWJvdXQgYWxsIGF2YWlsYWJsZSBuZXR3b3JrIG9iamVjdHNcbiAgICpcbiAgICogQHJldHVybnMgT2JqZWN0IHdob3NlIGtleXMgYXJlIHRoZSBuYW1lcyBvZiB0aGUgbmV0d29yayBvYmplY3RzIGFuZCB3aG9zZSB2YWx1ZXMgYXJlIHRoZVxuICAgKiAgIHtAbGluayBOZXR3b3JrT2JqZWN0RGV0YWlsc30gZm9yIGVhY2ggbmV0d29yayBvYmplY3RcbiAgICovXG4gIGdldEFsbE5ldHdvcmtPYmplY3REZXRhaWxzOiAoKSA9PiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIE5ldHdvcmtPYmplY3REZXRhaWxzPj47XG59XG5cbi8vIEZ1bmN0aW9ucyB0aGF0IGFyZSBhZGRlZCBpbiB0aGUgc2VydmljZSBjbGllbnQgb24gdG9wIG9mIHdoYXQgaXMgcHJvdmlkZWQgYnkgdGhlIG5ldHdvcmsgb2JqZWN0XG4vKiogSlNET0MgREVTVElOQVRJT04gbmV0d29ya09iamVjdFN0YXR1c1NlcnZpY2UgKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya09iamVjdFN0YXR1c1NlcnZpY2VUeXBlIGV4dGVuZHMgTmV0d29ya09iamVjdFN0YXR1c1JlbW90ZVNlcnZpY2VUeXBlIHtcbiAgLyoqXG4gICAqIEdldCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGEgbmV0d29yayBvYmplY3QgaXMgcmVnaXN0ZXJlZCBvciByZWplY3RzIGlmIGEgdGltZW91dCBpcyBoaXRcbiAgICpcbiAgICogQHBhcmFtIG9iamVjdERldGFpbHNUb01hdGNoIFN1YnNldCBvZiBvYmplY3QgZGV0YWlscyBvbiB0aGUgbmV0d29yayBvYmplY3QgdG8gd2FpdCBmb3IuXG4gICAqICAgQ29tcGFyZWQgdG8gb2JqZWN0IGRldGFpbHMgdXNpbmcge0BsaW5rIGlzU3Vic2V0fVxuICAgKiBAcGFyYW0gdGltZW91dEluTVMgTWF4IGR1cmF0aW9uIHRvIHdhaXQgZm9yIHRoZSBuZXR3b3JrIG9iamVjdC4gSWYgbm90IHByb3ZpZGVkLCBpdCB3aWxsIHdhaXRcbiAgICogICBpbmRlZmluaXRlbHlcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IGVpdGhlciByZXNvbHZlcyB0byB0aGUge0BsaW5rIE5ldHdvcmtPYmplY3REZXRhaWxzfSBmb3IgYSBuZXR3b3JrIG9iamVjdFxuICAgKiAgIG9uY2UgdGhlIG5ldHdvcmsgb2JqZWN0IGlzIHJlZ2lzdGVyZWQsIG9yIHJlamVjdHMgaWYgYSB0aW1lb3V0IGlzIHByb3ZpZGVkIGFuZCB0aGUgdGltZW91dCBpc1xuICAgKiAgIHJlYWNoZWQgYmVmb3JlIHRoZSBuZXR3b3JrIG9iamVjdCBpcyByZWdpc3RlcmVkXG4gICAqL1xuICB3YWl0Rm9yTmV0d29ya09iamVjdDogKFxuICAgIG9iamVjdERldGFpbHNUb01hdGNoOiBQYXJ0aWFsPE5ldHdvcmtPYmplY3REZXRhaWxzPixcbiAgICB0aW1lb3V0SW5NUz86IG51bWJlcixcbiAgKSA9PiBQcm9taXNlPE5ldHdvcmtPYmplY3REZXRhaWxzPjtcbn1cblxuZXhwb3J0IGNvbnN0IG5ldHdvcmtPYmplY3RTdGF0dXNTZXJ2aWNlTmV0d29ya09iamVjdE5hbWUgPSAnTmV0d29ya09iamVjdFN0YXR1c1NlcnZpY2UnO1xuIiwiaW1wb3J0IHsgQ29tbWFuZEhhbmRsZXJzIH0gZnJvbSAncGFwaS1zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IHsgTG9jYWxpemVLZXkgfSBmcm9tICdwbGF0Zm9ybS1iaWJsZS11dGlscyc7XG5cbmV4cG9ydCB0eXBlIFNldmVyaXR5ID0gJ2luZm8nIHwgJ3dhcm5pbmcnIHwgJ2Vycm9yJztcblxuLyoqIERhdGEgbmVlZGVkIHRvIGRpc3BsYXkgYSBub3RpZmljYXRpb24gdG8gdGhlIHVzZXIgKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGxhdGZvcm1Ob3RpZmljYXRpb24ge1xuICAvKipcbiAgICogVGV4dCB0byBkaXNwbGF5IHRvIHRoZSB1c2VyLlxuICAgKlxuICAgKiBBdXRvbWF0aWNhbGx5IGxvY2FsaXplZCBpZiB0aGlzIGlzIGEge0BsaW5rIExvY2FsaXplS2V5fS5cbiAgICovXG4gIG1lc3NhZ2U6IHN0cmluZyB8IExvY2FsaXplS2V5O1xuICAvKiogU2V2ZXJpdHkgb2YgdGhlIG5vdGlmaWNhdGlvbiAqL1xuICBzZXZlcml0eTogU2V2ZXJpdHk7XG4gIC8qKlxuICAgKiBPcHRpb25hbCBsYWJlbCBmb3IgdXNlcnMgdG8gY2xpY2sgd2hlbiB0aGUgbm90aWZpY2F0aW9uIHNob3dzLlxuICAgKlxuICAgKiBBdXRvbWF0aWNhbGx5IGxvY2FsaXplZCBpZiB0aGlzIGlzIGEge0BsaW5rIExvY2FsaXplS2V5fS5cbiAgICovXG4gIGNsaWNrQ29tbWFuZExhYmVsPzogc3RyaW5nIHwgTG9jYWxpemVLZXk7XG4gIC8qKiBPcHRpb25hbCBjb21tYW5kIHRvIHJ1biBpZiB1c2VycyBjbGljayBvbiB0aGUgbGFiZWwgaW4gdGhlIG5vdGlmaWNhdGlvbiAqL1xuICBjbGlja0NvbW1hbmQ/OiBrZXlvZiBDb21tYW5kSGFuZGxlcnM7XG4gIC8qKiBPcHRpb25hbCBJRCBvZiBhIHByZXZpb3VzIG5vdGlmaWNhdGlvbiB0byB1cGRhdGUgaW5zdGVhZCBvZiBzaG93aW5nIGEgbmV3IG5vdGlmaWNhdGlvbiAqL1xuICBub3RpZmljYXRpb25JZD86IHN0cmluZyB8IG51bWJlcjtcbn1cblxuLyoqIEpTRE9DIERFU1RJTkFUSU9OIG5vdGlmaWNhdGlvblNlcnZpY2UgKi9cbmV4cG9ydCBpbnRlcmZhY2UgSU5vdGlmaWNhdGlvblNlcnZpY2Uge1xuICAvKipcbiAgICogU2VuZCBhIG5vdGlmaWNhdGlvbiB0byB0aGUgdXNlci4gSWYgYSBub3RpZmljYXRpb24gd2l0aCB0aGUgc2FtZSBJRCBpcyBhbHJlYWR5IHNob3dpbmcsIGl0IHdpbGxcbiAgICogYmUgdXBkYXRlZCB3aXRoIHRoZSBuZXcgbm90aWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbm90aWZpY2F0aW9uIE5vdGlmaWNhdGlvbiB0byBzZW5kXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBJRCBvZiB0aGUgbm90aWZpY2F0aW9uXG4gICAqL1xuICBzZW5kKG5vdGlmaWNhdGlvbjogUGxhdGZvcm1Ob3RpZmljYXRpb24pOiBQcm9taXNlPHN0cmluZyB8IG51bWJlcj47XG59XG5cbmV4cG9ydCBjb25zdCBOb3RpZmljYXRpb25TZXJ2aWNlTmV0d29ya09iamVjdE5hbWUgPSAnTm90aWZpY2F0aW9uU2VydmljZSc7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5pbXBvcnQgeyBXRUJTT0NLRVRfUE9SVCB9IGZyb20gJ0BzaGFyZWQvZGF0YS9ycGMubW9kZWwnO1xuaW1wb3J0IHR5cGUgeyBKU09OU2NoZW1hNyB9IGZyb20gJ2pzb24tc2NoZW1hJztcblxuLy8gI3JlZ2lvbiBPcGVuUlBDIHR5cGVzIHRyYW5zbGF0ZWQgZnJvbSBKU09OIFNjaGVtYSB0byBUeXBlU2NyaXB0XG5cbi8qKlxuICogRGVzY3JpYmVzIEFQSXMgYXZhaWxhYmxlIHRvIGNhbGwgdXNpbmcgSlNPTi1SUEMgMi4wXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXJwYy9tZXRhLXNjaGVtYS9yZWxlYXNlcyAtIFJlbGVhc2UgMS4xNC4yIGFsaWducyB3aXRoIE9wZW5SUEMgMS4yLjYuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi1ycGMvbWV0YS1zY2hlbWEvcmVsZWFzZXMvZG93bmxvYWQvMS4xNC4yL29wZW4tcnBjLW1ldGEtc2NoZW1hLmpzb25cbiAqXG4gKiBXZSBkb24ndCB3YW50IHRvIGdvIHBhc3QgMS4yLjYgYmVjYXVzZSBodHRwczovL3BsYXlncm91bmQub3Blbi1ycGMub3JnLyBkb2Vzbid0IHN1cHBvcnQgYW55dGhpbmdcbiAqIHBhc3QgMS4yLjYgZm9yIG5vdy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXJwYy9wbGF5Z3JvdW5kL2lzc3Vlcy82MDYuXG4gKlxuICogTm90ZSB0aGF0IHRoZSB0eXBlcyBmcm9tIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL0BvcGVuLXJwYy9tZXRhLXNjaGVtYS92LzEuMTQuMiBhcmUgbm90XG4gKiB2ZXJ5IGdvb2QuIEZvciBleGFtcGxlLCBhbGwgdGhlIHByb3BlcnRpZXMgb2YgYENvbXBvbmVudHNgIGFyZSBvZiB0eXBlIGBhbnlgIGluc3RlYWQgb2YgdGhlXG4gKiBzcGVjaWZpYyB0eXBlcyB0aGV5IHNob3VsZCBiZSwgYW5kIHRoZXkgcmVkZWZpbmUgdHlwZXMgZm9yIEpTT04gU2NoZW1hLiBTbyB3ZSdyZSB1c2luZyBvdXIgb3duXG4gKiB0eXBlcyBoZXJlIGluc3RlYWQuXG4gKi9cbmV4cG9ydCB0eXBlIE9wZW5ScGMgPSB7XG4gIG9wZW5ycGM6IHN0cmluZztcbiAgaW5mbzogSW5mbztcbiAgc2VydmVycz86IFNlcnZlcltdO1xuICBtZXRob2RzOiBNZXRob2RbXTtcbiAgY29tcG9uZW50cz86IENvbXBvbmVudHM7XG4gIGV4dGVybmFsRG9jcz86IEV4dGVybmFsRG9jdW1lbnRhdGlvbjtcbn07XG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHMgPSB7XG4gIHNjaGVtYXM/OiB7IFtrZXk6IHN0cmluZ106IFNjaGVtYSB9O1xuICBjb250ZW50RGVzY3JpcHRvcnM/OiB7IFtrZXk6IHN0cmluZ106IENvbnRlbnREZXNjcmlwdG9yIH07XG4gIGV4YW1wbGVzPzogeyBba2V5OiBzdHJpbmddOiBFeGFtcGxlIH07XG4gIGxpbmtzPzogeyBba2V5OiBzdHJpbmddOiBMaW5rIH07XG4gIGVycm9ycz86IHsgW2tleTogc3RyaW5nXTogRXJyb3IgfTtcbiAgdGFncz86IHsgW2tleTogc3RyaW5nXTogVGFnIH07XG59O1xuXG5leHBvcnQgdHlwZSBDb21wb25lbnRzUmVmZXJlbmNlID0gYCMvY29tcG9uZW50cy8ke3N0cmluZ31gO1xuXG5leHBvcnQgdHlwZSBDb250YWN0ID0ge1xuICBuYW1lPzogc3RyaW5nO1xuICBlbWFpbD86IHN0cmluZztcbiAgdXJsPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgQ29udGVudERlc2NyaXB0b3IgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgc2NoZW1hOiBTY2hlbWE7XG4gIHJlcXVpcmVkPzogYm9vbGVhbjtcbiAgc3VtbWFyeT86IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGRlcHJlY2F0ZWQ/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgRXJyb3IgPSB7XG4gIGNvZGU6IG51bWJlcjtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBkYXRhPzogYW55O1xufTtcblxuZXhwb3J0IHR5cGUgRXhhbXBsZSA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICB2YWx1ZTogYW55O1xuICBzdW1tYXJ5Pzogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEV4YW1wbGVQYWlyaW5nT2JqZWN0ID0ge1xuICBuYW1lOiBzdHJpbmc7XG4gIHBhcmFtczogKEV4YW1wbGUgfCBSZWZlcmVuY2UpW107XG4gIHJlc3VsdDogRXhhbXBsZSB8IFJlZmVyZW5jZTtcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBFeHRlcm5hbERvY3VtZW50YXRpb24gPSB7XG4gIHVybDogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEluZm8gPSB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHZlcnNpb246IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIHRlcm1zT2ZTZXJ2aWNlPzogc3RyaW5nO1xuICBjb250YWN0PzogQ29udGFjdDtcbiAgbGljZW5zZT86IExpY2Vuc2U7XG59O1xuXG5leHBvcnQgdHlwZSBMaWNlbnNlID0ge1xuICBuYW1lOiBzdHJpbmc7XG4gIHVybD86IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIExpbmsgPSB7XG4gIG5hbWU/OiBzdHJpbmc7XG4gIHN1bW1hcnk/OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBtZXRob2Q/OiBzdHJpbmc7XG4gIHBhcmFtcz86IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIHNlcnZlcj86IFNlcnZlcjtcbn07XG5cbmV4cG9ydCB0eXBlIE1ldGhvZCA9IHtcbiAgLyoqIFRoZSBjYW5vbmljYWwgbmFtZSBmb3IgdGhlIG1ldGhvZC4gVGhlIG5hbWUgTVVTVCBiZSB1bmlxdWUgd2l0aGluIHRoZSBtZXRob2RzIGFycmF5LiAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIHBhcmFtczogKENvbnRlbnREZXNjcmlwdG9yIHwgUmVmZXJlbmNlKVtdO1xuICByZXN1bHQ6IENvbnRlbnREZXNjcmlwdG9yIHwgUmVmZXJlbmNlO1xuICAvKiogQSBzaG9ydCBzdW1tYXJ5IG9mIHdoYXQgdGhlIG1ldGhvZCBkb2VzLiAqL1xuICBzdW1tYXJ5Pzogc3RyaW5nO1xuICAvKipcbiAgICogQSB2ZXJib3NlIGV4cGxhbmF0aW9uIG9mIHRoZSBtZXRob2QgYmVoYXZpb3IuIEdpdEh1YiBGbGF2b3JlZCBNYXJrZG93biBzeW50YXggTUFZIGJlIHVzZWQgZm9yXG4gICAqIHJpY2ggdGV4dCByZXByZXNlbnRhdGlvbi5cbiAgICovXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBkZXByZWNhdGVkPzogYm9vbGVhbjtcbiAgc2VydmVycz86IFNlcnZlcltdO1xuICB0YWdzPzogKFRhZyB8IFJlZmVyZW5jZSlbXTtcbiAgLyoqIEZvcm1hdCB0aGUgc2VydmVyIGV4cGVjdHMgdGhlIHBhcmFtcy4gRGVmYXVsdHMgdG8gJ2VpdGhlcicuICovXG4gIHBhcmFtU3RydWN0dXJlPzogJ2J5LW5hbWUnIHwgJ2J5LXBvc2l0aW9uJyB8ICdlaXRoZXInO1xuICBlcnJvcnM/OiAoRXJyb3IgfCBSZWZlcmVuY2UpW107XG4gIGxpbmtzPzogKExpbmsgfCBSZWZlcmVuY2UpW107XG4gIGV4YW1wbGVzPzogKEV4YW1wbGVQYWlyaW5nT2JqZWN0IHwgUmVmZXJlbmNlKVtdO1xuICBleHRlcm5hbERvY3M/OiBFeHRlcm5hbERvY3VtZW50YXRpb247XG59O1xuXG5leHBvcnQgdHlwZSBSZWZlcmVuY2UgPSB7XG4gICRyZWY6IENvbXBvbmVudHNSZWZlcmVuY2U7XG59O1xuXG5leHBvcnQgdHlwZSBTZXJ2ZXIgPSB7XG4gIHVybDogc3RyaW5nO1xuICBuYW1lPzogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgc3VtbWFyeT86IHN0cmluZztcbiAgdmFyaWFibGVzPzogeyBba2V5OiBzdHJpbmddOiBTZXJ2ZXJWYXJpYWJsZSB9O1xufTtcblxuZXhwb3J0IHR5cGUgU2VydmVyVmFyaWFibGUgPSB7XG4gIGRlZmF1bHQ6IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGVudW0/OiBzdHJpbmdbXTtcbn07XG5cbmV4cG9ydCB0eXBlIFNjaGVtYSA9IEpTT05TY2hlbWE3O1xuXG5leHBvcnQgdHlwZSBUYWcgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGV4dGVybmFsRG9jcz86IEV4dGVybmFsRG9jdW1lbnRhdGlvbjtcbn07XG5cbi8vICNlbmRyZWdpb25cblxuZXhwb3J0IHR5cGUgTWV0aG9kRG9jdW1lbnRhdGlvbldpdGhvdXROYW1lID0gT21pdDxNZXRob2QsICduYW1lJz47XG5cbi8qKiBEb2N1bWVudGF0aW9uIGFib3V0IGEgc2luZ2xlIG1ldGhvZCAqL1xuZXhwb3J0IHR5cGUgU2luZ2xlTWV0aG9kRG9jdW1lbnRhdGlvbiA9IHtcbiAgbWV0aG9kOiBNZXRob2REb2N1bWVudGF0aW9uV2l0aG91dE5hbWU7XG4gIGNvbXBvbmVudHM/OiBDb21wb25lbnRzO1xufTtcblxuLyoqIERvY3VtZW50YXRpb24gYWJvdXQgYWxsIG1ldGhvZHMgb24gYSBuZXR3b3JrIG9iamVjdCAqL1xuZXhwb3J0IHR5cGUgTmV0d29ya09iamVjdERvY3VtZW50YXRpb24gPSB7XG4gIHN1bW1hcnk/OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBtZXRob2RzPzogTWV0aG9kW107XG4gIGNvbXBvbmVudHM/OiBDb21wb25lbnRzO1xufTtcblxuLyoqIENyZWF0ZSBhbiBvYmplY3Qgb2YgdHlwZSB7QGxpbmsgT3BlblJwY30gdG8gaG9sZCBkb2N1bWVudGF0aW9uIGZvciBQQVBJIHdlYnNvY2tldCBtZXRob2RzICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1wdHlPcGVuUnBjKHBhcGlWZXJzaW9uOiBzdHJpbmcpOiBPcGVuUnBjIHtcbiAgcmV0dXJuIHtcbiAgICBvcGVucnBjOiAnMS4yLjYnLFxuICAgIGluZm86IHtcbiAgICAgIHZlcnNpb246IHBhcGlWZXJzaW9uLFxuICAgICAgdGl0bGU6ICdMaXZlIFBBUEkgZG9jdW1lbnRhdGlvbicsXG4gICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgJ0FsbCBtZXRob2RzIGN1cnJlbnRseSByZWdpc3RlcmVkIHdpdGggUEFQSS4gVGhleSBjaGFuZ2UgZHluYW1pY2FsbHkgYXMgbWV0aG9kcyBhcmUgcmVnaXN0ZXJlZCBhbmQgdW5yZWdpc3RlcmVkLiBUaGlzIHBhZ2UgZG9lcyBub3QgYXV0b21hdGljYWxseSByZWZyZXNoIHRvIHNob3cgYW55IGNoYW5nZXMuXFxuXFxuU2VlIGFkZGl0aW9uYWwgaGVscGZ1bCBkb2N1bWVudGF0aW9uIGZvciBbZXh0ZW5zaW9uIGRldmVsb3BlcnNdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXJhbmV4dC9wYXJhbmV4dC1leHRlbnNpb24tdGVtcGxhdGUvd2lraSkuJyxcbiAgICAgIGNvbnRhY3Q6IHtcbiAgICAgICAgbmFtZTogJ1BsYXRmb3JtLkJpYmxlIFRlYW0nLFxuICAgICAgICB1cmw6ICdodHRwczovL2Rpc2NvcmQuZ2cvdHp3MjJQVUVBWScsXG4gICAgICB9LFxuICAgICAgbGljZW5zZToge1xuICAgICAgICBuYW1lOiAnTUlUJyxcbiAgICAgICAgdXJsOiAnaHR0cHM6Ly9naXRodWIuY29tL3BhcmFuZXh0L3BhcmFuZXh0LWNvcmUvYmxvYi9tYWluL0xJQ0VOU0UnLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHNlcnZlcnM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ1BsYXRmb3JtLkJpYmxlIGFuZCBQYXJhdGV4dCAxMCBTdHVkaW8gV2lraScsXG4gICAgICAgIHVybDogJ2h0dHBzOi8vZ2l0aHViLmNvbS9wYXJhbmV4dC9wYXJhbmV4dC1jb3JlL3dpa2kvUGxhdGZvcm0uQmlibGUtYW5kLVBhcmF0ZXh0LTEwLVN0dWRpbycsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnVHlwZVNjcmlwdCBkb2NzIGZvciBQQVBJIFJlYWN0IGNvbXBvbmVudHMsIGdlbmVyYWwgbGlicmFyeSBjb21wb25lbnRzLCBhbmQgQVBJIGNhbGxzJyxcbiAgICAgICAgdXJsOiAnaHR0cHM6Ly9wYXJhbmV4dC5naXRodWIuaW8vcGFyYW5leHQtY29yZS8nLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ1BBUEkgd2Vic29ja2V0JyxcbiAgICAgICAgdXJsOiBgd3M6Ly9sb2NhbGhvc3Q6JHtXRUJTT0NLRVRfUE9SVH1gLFxuICAgICAgfSxcbiAgICBdLFxuICAgIG1ldGhvZHM6IFtdLFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICB9O1xufVxuXG5jb25zdCBlbXB0eURvY3M6IE1ldGhvZERvY3VtZW50YXRpb25XaXRob3V0TmFtZSA9IHtcbiAgc3VtbWFyeTogJycsXG4gIGRlc2NyaXB0aW9uOiAnTm8gZG9jdW1lbnRhdGlvbiBwcm92aWRlZCcsXG4gIHBhcmFtczogW10sXG4gIHJlc3VsdDoge1xuICAgIG5hbWU6ICdyZXR1cm4gdmFsdWUnLFxuICAgIHNjaGVtYToge30sXG4gIH0sXG59O1xuT2JqZWN0LmZyZWV6ZShlbXB0eURvY3MpO1xuT2JqZWN0LmZyZWV6ZShlbXB0eURvY3MucGFyYW1zKTtcbk9iamVjdC5mcmVlemUoZW1wdHlEb2NzLnJlc3VsdCk7XG4vLyBAdHMtZXhwZWN0LWVycm9yIDIzMzkgLSBUUyBkb2Vzbid0IHVuZGVyc3RhbmQgdGhhdCAnc2NoZW1hJyBpcyBwYXJ0IG9mICdyZXN1bHQnXG5PYmplY3QuZnJlZXplKGVtcHR5RG9jcy5yZXN1bHQuc2NoZW1hKTtcblxuLyoqXG4gKiBHZXQgYW4gZW1wdHkge0BsaW5rIE9wZW5ScGN9IG1ldGhvZCBkb2N1bWVudCBvYmplY3QuIFVzZWZ1bCBmb3IgcG9wdWxhdGluZyBkb2N1bWVudGF0aW9uIGZvclxuICogbWV0aG9kcyB0aGF0IGRpZG4ndCBoYXZlIHRoZWlyIG93biBkb2N1bWVudGF0aW9uIHByb3ZpZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW1wdHlNZXRob2REb2NzKCk6IE1ldGhvZERvY3VtZW50YXRpb25XaXRob3V0TmFtZSB7XG4gIHJldHVybiBlbXB0eURvY3M7XG59XG4iLCJpbXBvcnQgeyBQbGF0Zm9ybUV2ZW50SGFuZGxlciwgUGxhdGZvcm1FdmVudEVtaXR0ZXIgfSBmcm9tICdwbGF0Zm9ybS1iaWJsZS11dGlscyc7XG5cbi8qKlxuICogTmV0d29ya2VkIHZlcnNpb24gb2YgRXZlbnRFbWl0dGVyIC0gYWNjZXB0cyBzdWJzY3JpcHRpb25zIHRvIGFuIGV2ZW50IGFuZCBydW5zIHRoZSBzdWJzY3JpcHRpb25cbiAqIGNhbGxiYWNrcyB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkLiBFdmVudHMgb24gTmV0d29ya0V2ZW50RW1pdHRlcnMgY2FuIGJlIGVtaXR0ZWQgYWNyb3NzXG4gKiBwcm9jZXNzZXMuIFRoZXkgYXJlIGNvb3JkaW5hdGVkIGJldHdlZW4gcHJvY2Vzc2VzIGJ5IHRoZWlyIHR5cGUuIFVzZSBldmVudEVtaXR0ZXIuZXZlbnQoY2FsbGJhY2spXG4gKiB0byBzdWJzY3JpYmUgdG8gdGhlIGV2ZW50LiBVc2UgZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnQpIHRvIHJ1biB0aGUgc3Vic2NyaXB0aW9ucy4gR2VuZXJhbGx5LCB0aGlzXG4gKiBFdmVudEVtaXR0ZXIgc2hvdWxkIGJlIHByaXZhdGUsIGFuZCBpdHMgZXZlbnQgc2hvdWxkIGJlIHB1YmxpYy4gVGhhdCB3YXksIHRoZSBlbWl0dGVyIGlzIG5vdFxuICogcHVibGljaXplZCwgYnV0IGFueW9uZSBjYW4gc3Vic2NyaWJlIHRvIHRoZSBldmVudC5cbiAqXG4gKiBXQVJOSU5HOiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHkgb3V0c2lkZSBvZiBOZXR3b3JrU2VydmljZSwgb3IgaXQgd2lsbCBub3QgZG8gd2hhdCB5b3VcbiAqIGV4cGVjdC4gVXNlIE5ldHdvcmtTZXJ2aWNlLmNyZWF0ZU5ldHdvcmtFdmVudEVtaXR0ZXIuXG4gKlxuICogV0FSTklORzogWW91IGNhbm5vdCBlbWl0IGV2ZW50cyB3aXRoIGNvbXBsZXggdHlwZXMgb24gdGhlIG5ldHdvcmsuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXBpTmV0d29ya0V2ZW50RW1pdHRlcjxUPiBleHRlbmRzIFBsYXRmb3JtRXZlbnRFbWl0dGVyPFQ+IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOZXR3b3JrRXZlbnRFbWl0dGVyXG4gICAqXG4gICAqIEBwYXJhbSBuZXR3b3JrU3Vic2NyaWJlciBDYWxsYmFjayB0aGF0IGFjY2VwdHMgdGhlIGV2ZW50IGFuZCBlbWl0cyBpdCB0byBvdGhlciBwcm9jZXNzZXNcbiAgICogQHBhcmFtIG5ldHdvcmtEaXNwb3NlciBDYWxsYmFjayB0aGF0IHVubGlua3MgdGhpcyBlbWl0dGVyIGZyb20gdGhlIG5ldHdvcmtcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBDYWxsYmFjayB0aGF0IHNlbmRzIHRoZSBldmVudCB0byBvdGhlciBwcm9jZXNzZXMgb24gdGhlIG5ldHdvcmsgd2hlbiBpdCBpcyBlbWl0dGVkICovXG4gICAgcHJpdmF0ZSBuZXR3b3JrU3Vic2NyaWJlcjogUGxhdGZvcm1FdmVudEhhbmRsZXI8VD4sXG4gICAgLyoqIENhbGxiYWNrIHRoYXQgcnVucyB3aGVuIHRoZSBlbWl0dGVyIGlzIGRpc3Bvc2VkIC0gc2hvdWxkIGhhbmRsZSB1bmxpbmtpbmcgZnJvbSB0aGUgbmV0d29yayAqL1xuICAgIHByaXZhdGUgbmV0d29ya0Rpc3Bvc2VyOiAoKSA9PiB2b2lkLFxuICApIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgb3ZlcnJpZGUgZW1pdCA9IChldmVudDogVCkgPT4ge1xuICAgIHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKTtcblxuICAgIGlmICh0aGlzLm5ldHdvcmtTdWJzY3JpYmVyKSB0aGlzLm5ldHdvcmtTdWJzY3JpYmVyKGV2ZW50KTtcbiAgICB0aGlzLmVtaXRMb2NhbChldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJ1bnMgb25seSB0aGUgc3Vic2NyaXB0aW9ucyBmb3IgdGhlIGV2ZW50IHRoYXQgYXJlIG9uIHRoaXMgcHJvY2Vzcy4gRG9lcyBub3Qgc2VuZCBvdmVyIG5ldHdvcmtcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IEV2ZW50IGRhdGEgdG8gcHJvdmlkZSB0byBzdWJzY3JpYmVkIGNhbGxiYWNrc1xuICAgKi9cbiAgZW1pdExvY2FsKGV2ZW50OiBUKSB7XG4gICAgdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO1xuXG4gICAgc3VwZXIuZW1pdEZuKGV2ZW50KTtcbiAgfVxuXG4gIG92ZXJyaWRlIGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgY29uc3QgcmV0VmFsID0gc3VwZXIuZGlzcG9zZUZuKCk7XG4gICAgLy8gVE9ETzogRG8gd2UgbmVlZCB0byBzZXQgbmV0d29ya1N1YnNjcmliZXIgdG8gdW5kZWZpbmVkPyBIYWQgdG8gcmVtb3ZlIHJlYWRvbmx5IGZyb20gaXQgdG8gZG8gdGhpc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICAgIHRoaXMubmV0d29ya1N1YnNjcmliZXIgPSB1bmRlZmluZWQgYXMgdW5rbm93biBhcyBQbGF0Zm9ybUV2ZW50SGFuZGxlcjxUPjtcbiAgICB0aGlzLm5ldHdvcmtEaXNwb3NlcigpO1xuICAgIHJldHVybiByZXRWYWw7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhcGlOZXR3b3JrRXZlbnRFbWl0dGVyO1xuIiwiaW1wb3J0IHsgRGlzcG9zZSwgTW9kaWZpZXJQcm9qZWN0IH0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuaW1wb3J0IHsgUHJvamVjdE1ldGFkYXRhV2l0aG91dEZhY3RvcnlJbmZvIH0gZnJvbSAnLi9wcm9qZWN0LW1ldGFkYXRhLm1vZGVsJztcblxuZXhwb3J0IGNvbnN0IFBEUF9GQUNUT1JZX09CSkVDVF9UWVBFOiBzdHJpbmcgPSAncGRwRmFjdG9yeSc7XG5cbmV4cG9ydCB0eXBlIFByb2plY3RNZXRhZGF0YUZpbHRlck9wdGlvbnMgPSBNb2RpZmllclByb2plY3QgJiB7XG4gIC8qKiBQcm9qZWN0IElEcyB0byBpbmNsdWRlICovXG4gIGluY2x1ZGVQcm9qZWN0SWRzPzogc3RyaW5nIHwgc3RyaW5nW107XG4gIC8qKiBQcm9qZWN0IElEcyB0byBleGNsdWRlICovXG4gIGV4Y2x1ZGVQcm9qZWN0SWRzPzogc3RyaW5nIHwgc3RyaW5nW107XG59O1xuXG4vKipcbiAqIE5ldHdvcmsgb2JqZWN0IHRoYXQgY3JlYXRlcyBQcm9qZWN0IERhdGEgUHJvdmlkZXJzIG9mIGEgc3BlY2lmaWMgc2V0IG9mIGBwcm9qZWN0SW50ZXJmYWNlYHMgYXNcbiAqIHJlcXVlc3RlZCBvbiB0aGUgYHBhcGlgLiBUaGVzZSBhcmUgY3JlYXRlZCBpbnRlcm5hbGx5IHdpdGhpbiB0aGUgcGxhdGZvcm0gdG8gbGF5ZXIgb3ZlclxuICogVHlwZVNjcmlwdC1leHRlbnNpb24tcHJvdmlkZWQge0BsaW5rIElQcm9qZWN0RGF0YVByb3ZpZGVyRW5naW5lRmFjdG9yeX0gb3IgYXJlIGNyZWF0ZWQgYnlcbiAqIGluZGVwZW5kZW50IHByb2Nlc3NlcyBvbiB0aGUgYHBhcGlgLlxuICpcbiAqIEEgUERQIEZhY3RvcnkgY2FuIHByb3ZpZGUgaXRzIG93biB1bmlxdWUgcHJvamVjdCBpZHMgKEJhc2UgUERQIEZhY3RvcnkpIG9yIGxheWVyIG92ZXIgb3RoZXIgUERQRnNcbiAqIGFuZCBwcm92aWRlIGFkZGl0aW9uYWwgYHByb2plY3RJbnRlcmZhY2VgcyBvbiB0aG9zZSBwcm9qZWN0cyAoTGF5ZXJpbmcgUERQIEZhY3RvcnkpLiBCYXNlIFBEUFxuICogRmFjdG9yaWVzIG11c3QgY3JlYXRlIFBEUHMgdGhhdCBzdXBwb3J0IHRoZSBgcGxhdGZvcm0uYmFzZWAgYHByb2plY3RJbnRlcmZhY2VgLiBTZWVcbiAqIHtAbGluayBJQmFzZVByb2plY3REYXRhUHJvdmlkZXJ9IGFuZCB7QGxpbmsgUHJvamVjdERhdGFQcm92aWRlckludGVyZmFjZXN9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElQcm9qZWN0RGF0YVByb3ZpZGVyRmFjdG9yeSBleHRlbmRzIERpc3Bvc2Uge1xuICAvKipcbiAgICogSlNET0MgU09VUkNFIElQcm9qZWN0RGF0YVByb3ZpZGVyRmFjdG9yeUdldEF2YWlsYWJsZVByb2plY3RzXG4gICAqXG4gICAqIEdldCBtZXRhZGF0YSBhYm91dCBhbGwgcHJvamVjdHMgdGhhdCBjYW4gYmUgc2VydmVkIGJ5IFBEUHMgY3JlYXRlZCBieSB0aGlzIFBEUCBmYWN0b3J5LlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIGEgQmFzZSBQRFAgRmFjdG9yeSwgdGhpcyBtZXRob2Qgc2hvdWxkIHJldHVybiB0aGlzIFBEUCBGYWN0b3J5J3Mgb3duIHVuaXF1ZSBwcm9qZWN0XG4gICAqIElEcy5cbiAgICpcbiAgICogSWYgdGhpcyBpcyBhIExheWVyaW5nIFBEUCBGYWN0b3J5LCB0aGlzIG1ldGhvZCBzaG91bGQgY2FsbFxuICAgKiBgcGFwaS5wcm9qZWN0TG9va3VwLmdldE1ldGFkYXRhRm9yQWxsUHJvamVjdHNgIHdpdGggc29tZSBzZXQgb2YgbWV0YWRhdGEgZmlsdGVycyBpbiBvcmRlciB0b1xuICAgKiBkZXRlcm1pbmUgd2hpY2ggcHJvamVjdHMgaXQgY2FuIGxheWVyIG92ZXIuIFRoZSBzZXQgb2YgbWV0YWRhdGEgZmlsdGVycyByZWxldmFudCB0byB0aGlzIFBEUFxuICAgKiBGYWN0b3J5ICoqYWJzb2x1dGVseSBtdXN0KiogYmUgbWVyZ2VkIHdpdGggdGhlIGBsYXllcmluZ0ZpbHRlcnNgIHByb3ZpZGVkIHVzaW5nXG4gICAqIGBwYXBpLnByb2plY3RMb29rdXAubWVyZ2VNZXRhZGF0YUZpbHRlcnNgLCBvciBpdCB3aWxsIGdldCBpbnRvIGFuIGluZmluaXRlIGxvb3Agb2YgY2FsbGluZ1xuICAgKiBvdGhlciBsYXllcmluZyBQRFBzLlxuICAgKlxuICAgKiBXQVJOSU5HOiBJZiB0aGlzIGlzIGEgTGF5ZXJpbmcgUERQIEZhY3RvcnksIGl0ICoqYWJzb2x1dGVseSBtdXN0KiogbWVyZ2UgaXRzIG1ldGFkYXRhIGZpbHRlcnNcbiAgICogd2l0aCBgbGF5ZXJpbmdGaWx0ZXJzYCBwcm92aWRlZCB1c2luZyBgcGFwaS5wcm9qZWN0TG9va3VwLm1lcmdlTWV0YWRhdGFGaWx0ZXJzYCEgT3RoZXJ3aXNlIHlvdVxuICAgKiB3aWxsIGNhdXNlIGFuIGluZmluaXRlIGxvb3AgdGhhdCB3aWxsIGJyZWFrIHRoaW5ncy5cbiAgICpcbiAgICogQHBhcmFtIGxheWVyaW5nRmlsdGVycyBJZiBhcHBsaWNhYmxlLCBmaWx0ZXJzIHVzZWQgdG8gcHJldmVudCB0aGlzIExheWVyaW5nIFBEUCBGYWN0b3J5IGZyb21cbiAgICogICBlbnRlcmluZyBhbiBpbmZpbml0ZSBsb29wIHdpdGggYW5vdGhlciBMYXllcmluZyBQRFAgRmFjdG9yeS4gWW91ICoqYWJzb2x1dGVseSBtdXN0KiogbWVyZ2VcbiAgICogICB0aGVzZSBmaWx0ZXJzIHdpdGggeW91ciBvd24gZmlsdGVycyB1c2luZyBgcGFwaS5wcm9qZWN0TG9va3VwLm1lcmdlTWV0YWRhdGFGaWx0ZXJzYCB3aGVuXG4gICAqICAgY2FsbGluZyBgcGFwaS5wcm9qZWN0TG9va3VwLmdldE1ldGFkYXRhRm9yQWxsUHJvamVjdHNgIGluc2lkZSB0aGlzIG1ldGhvZC4gSWYgeW91IGFyZSBub3RcbiAgICogICBjYWxsaW5nIGBnZXRNZXRhZGF0YUZvckFsbFByb2plY3RzYCBpbnNpZGUgdGhpcyBtZXRob2QgKGxpa2VseSBpZiB0aGlzIGlzIGEgQmFzZSBQRFBGKSwgeW91XG4gICAqICAgY2FuIHNhZmVseSBpZ25vcmUgdGhpcyBwYXJhbWV0ZXIuXG4gICAqL1xuICBnZXRBdmFpbGFibGVQcm9qZWN0cyhcbiAgICBsYXllcmluZ0ZpbHRlcnM/OiBQcm9qZWN0TWV0YWRhdGFGaWx0ZXJPcHRpb25zLFxuICApOiBQcm9taXNlPFByb2plY3RNZXRhZGF0YVdpdGhvdXRGYWN0b3J5SW5mb1tdPjtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlZ2lzdGVyZWQgbmV0d29yayBvYmplY3QgbmFtZSBvZiBhIFBEUCBmb3IgdGhlIGdpdmVuIHByb2plY3QgSUQuIENhbGxlZCBieSB0aGVcbiAgICogcGxhdGZvcm0gd2hlbiBzb21lb25lIHVzZXMgdGhlIHByb2plY3QgZGF0YSBwcm92aWRlciBzZXJ2aWNlIHRvIGFjY2VzcyBhIHByb2plY3QncyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvamVjdElkIElkIG9mIHRoZSBwcm9qZWN0IGZvciB3aGljaCB0byByZXR1cm4gYSBwcm9qZWN0IGRhdGEgcHJvdmlkZXIuXG4gICAqIEByZXR1cm5zIElkIG9mIHRoZSBwcm9qZWN0IGRhdGEgcHJvdmlkZXIgdGhpcyBgSVByb2plY3REYXRhUHJvdmlkZXJGYWN0b3J5YCBjcmVhdGVkIGZvciB0aGlzXG4gICAqICAgcHJvamVjdCBpZC4gSXQgc2hvdWxkIHJldHVybiB0aGUgc2FtZSBwcm9qZWN0IGRhdGEgcHJvdmlkZXIgZm9yIHRoZSBzYW1lIGNvbWJpbmF0aW9uIG9mXG4gICAqICAgcGFyYW1ldGVycyB0aHJvdWdob3V0IG9uZSBzZXNzaW9uIChpbiBvdGhlciB3b3JkcywgaW4gZ2VuZXJhbCwgdGhlcmUgc2hvdWxkIGp1c3QgYmUgb25lXG4gICAqICAgcHJvamVjdCBkYXRhIHByb3ZpZGVyIGZvciBvbmUgcHJvamVjdCBpZCkuXG4gICAqL1xuICBnZXRQcm9qZWN0RGF0YVByb3ZpZGVySWQocHJvamVjdElkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47XG59XG5cbmV4cG9ydCBkZWZhdWx0IElQcm9qZWN0RGF0YVByb3ZpZGVyRmFjdG9yeTtcbiIsImltcG9ydCB0eXBlIHtcbiAgRGF0YVByb3ZpZGVyRGF0YVR5cGUsXG4gIERhdGFQcm92aWRlckRhdGFUeXBlcyxcbiAgRGF0YVByb3ZpZGVyVXBkYXRlSW5zdHJ1Y3Rpb25zLFxufSBmcm9tICdAc2hhcmVkL21vZGVscy9kYXRhLXByb3ZpZGVyLm1vZGVsJztcblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgYHByb2plY3RJbnRlcmZhY2VgIHJlcHJlc2VudGluZyB0aGUgZXNzZW50aWFsIG1ldGhvZHMgZXZlcnkgQmFzZSBQcm9qZWN0IERhdGFcbiAqIFByb3ZpZGVyIG11c3QgaW1wbGVtZW50XG4gKi9cbmV4cG9ydCBjb25zdCBQUk9KRUNUX0lOVEVSRkFDRV9QTEFURk9STV9CQVNFID0gJ3BsYXRmb3JtLmJhc2UnO1xuXG4vKiogSW5kaWNhdGVzIHRvIGEgUERQIHdoYXQgZXh0ZW5zaW9uIGRhdGEgaXMgYmVpbmcgcmVmZXJlbmNlZCAqL1xuZXhwb3J0IHR5cGUgRXh0ZW5zaW9uRGF0YVNjb3BlID0ge1xuICAvKiogTmFtZSBvZiBhbiBleHRlbnNpb24gYXMgcHJvdmlkZWQgaW4gaXRzIG1hbmlmZXN0ICovXG4gIGV4dGVuc2lvbk5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIE5hbWUgb2YgYSB1bmlxdWUgcGFydGl0aW9uIG9yIHNlZ21lbnQgb2YgZGF0YSB3aXRoaW4gdGhlIGV4dGVuc2lvbi4gU29tZSBleGFtcGxlcyBpbmNsdWRlIChidXRcbiAgICogYXJlIG5vdCBsaW1pdGVkIHRvKTpcbiAgICpcbiAgICogLSBOYW1lIG9mIGFuIGltcG9ydGFudCBkYXRhIHN0cnVjdHVyZSB0aGF0IGlzIG1haW50YWluZWQgaW4gYSBwcm9qZWN0XG4gICAqIC0gTmFtZSBvZiBhIGRvd25sb2FkZWQgZGF0YSBzZXQgdGhhdCBpcyBiZWluZyBjYWNoZWRcbiAgICogLSBOYW1lIG9mIGEgcmVzb3VyY2UgY3JlYXRlZCBieSBhIHVzZXIgdGhhdCBzaG91bGQgYmUgbWFpbnRhaW5lZCBpbiBhIHByb2plY3RcbiAgICpcbiAgICogVGhpcyBpcyB0aGUgc21hbGxlc3QgbGV2ZWwgb2YgZ3JhbnVsYXJpdHkgcHJvdmlkZWQgYnkgYSBQRFAgZm9yIGFjY2Vzc2luZyBleHRlbnNpb24gZGF0YS4gVGhlcmVcbiAgICogaXMgbm8gd2F5IHRvIGdldCBvciBzZXQganVzdCBhIHBvcnRpb24gb2YgZGF0YSBpZGVudGlmaWVkIGJ5IGEgc2luZ2xlIGBkYXRhUXVhbGlmaWVyYCB2YWx1ZS5cbiAgICovXG4gIGRhdGFRdWFsaWZpZXI6IHN0cmluZztcbn07XG5cbi8qKlxuICogYERhdGFQcm92aWRlckRhdGFUeXBlc2AgdGhhdCBlYWNoIHByb2plY3QgZGF0YSBwcm92aWRlciAqKm11c3QqKiBpbXBsZW1lbnQuIFRoZXkgYXJlIGFzc3VtZWQgdG9cbiAqIGV4aXN0IGFuZCBhcmUgdXNlZCBieSBvdGhlciBkYXRhIHByb3ZpZGVycy5cbiAqXG4gKiAgICAgLS0tXG4gKlxuICogIyMjIFNldHRpbmdcbiAqXG4gKiBUaGUgYFNldHRpbmdgIGRhdGEgdHlwZSBoYW5kbGVzIGdldHRpbmcgYW5kIHNldHRpbmcgcHJvamVjdCBzZXR0aW5ncy4gQWxsIFByb2plY3QgRGF0YSBQcm92aWRlcnNcbiAqIG11c3QgaW1wbGVtZW50IHRoZXNlIG1ldGhvZHMgYGdldFNldHRpbmdgIGFuZCBgc2V0U2V0dGluZ2AgYXMgd2VsbCBhcyBgcmVzZXRTZXR0aW5nYCBpbiBvcmRlciB0b1xuICogcHJvcGVybHkgc3VwcG9ydCBwcm9qZWN0IHNldHRpbmdzLlxuICpcbiAqIE5vdGU6IHRoZSBgU2V0dGluZ2AgZGF0YSB0eXBlIGlzIG5vdCBhY3R1YWxseSBwYXJ0IG9mIHtAbGluayBNYW5kYXRvcnlQcm9qZWN0RGF0YVR5cGVzfSBiZWNhdXNlXG4gKiB0aGUgbWV0aG9kcyB3b3VsZCBub3QgYmUgYWJsZSB0byBjcmVhdGUgYSBnZW5lcmljIHR5cGUgZXh0ZW5kaW5nIGZyb20gYFByb2plY3RTZXR0aW5nTmFtZXNgIGluXG4gKiBvcmRlciB0byByZXR1cm4gdGhlIHNwZWNpZmljIHNldHRpbmcgdHlwZSBiZWluZyByZXF1ZXN0ZWQuIEFzIHN1Y2gsIGBnZXRTZXR0aW5nYCwgYHNldFNldHRpbmdgLFxuICogYW5kIGBzdWJzY3JpYmVTZXR0aW5nYCBhcmUgYWxsIHNwZWNpZmllZCBvbiB7QGxpbmsgSVByb2plY3REYXRhUHJvdmlkZXJ9IGluc3RlYWQuIFVuZm9ydHVuYXRlbHksXG4gKiBhcyBhIHJlc3VsdCwgdXNpbmcgSW50ZWxsaXNlbnNlIHdpdGggYHVzZVByb2plY3REYXRhYCB3aWxsIG5vdCBzaG93IGBTZXR0aW5nYCBhcyBhIGRhdGEgdHlwZVxuICogb3B0aW9uLCBidXQgeW91IGNhbiB1c2UgYHVzZVByb2plY3RTZXR0aW5nYCBpbnN0ZWFkLiBIb3dldmVyLCBkbyBub3RlIHRoYXQgdGhlIGBTZXR0aW5nYCBkYXRhXG4gKiB0eXBlIGlzIGZ1bGx5IGZ1bmN0aW9uYWwuXG4gKlxuICogVGhlIGNsb3Nlc3QgcG9zc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBTZXR0aW5nYCBkYXRhIHR5cGUgZm9sbG93czpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBTZXR0aW5nOiBEYXRhUHJvdmlkZXJEYXRhVHlwZTxcbiAqICAgUHJvamVjdFNldHRpbmdOYW1lcyxcbiAqICAgUHJvamVjdFNldHRpbmdUeXBlc1tQcm9qZWN0U2V0dGluZ05hbWVzXSxcbiAqICAgUHJvamVjdFNldHRpbmdUeXBlc1tQcm9qZWN0U2V0dGluZ05hbWVzXVxuICogPjtcbiAqIGBgYFxuICpcbiAqIFdBUk5JTkc6IEVhY2ggUHJvamVjdCBEYXRhIFByb3ZpZGVyICoqbXVzdCoqIGZ1bGZpbGwgdGhlIGZvbGxvd2luZyByZXF1aXJlbWVudHMgZm9yIGl0c1xuICogc2V0dGluZ3MtcmVsYXRlZCBtZXRob2RzOlxuICpcbiAqIC0gYGdldFNldHRpbmdgOiBpZiBhIHByb2plY3Qgc2V0dGluZyB2YWx1ZSBpcyBwcmVzZW50IGZvciB0aGUga2V5IHJlcXVlc3RlZCwgcmV0dXJuIGl0LiBPdGhlcndpc2UsXG4gKiAgIHlvdSBtdXN0IGNhbGwgYHBhcGkucHJvamVjdFNldHRpbmdzLmdldERlZmF1bHRgIHRvIGdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvciB0aHJvdyBpZiB0aGF0IGNhbGxcbiAqICAgdGhyb3dzLiBUaGlzIGZ1bmN0aW9uYWxpdHkgcHJlc2VydmVzIHRoZSBpbnRlbmRlZCB0eXBlIG9mIHRoZSBzZXR0aW5nIGFuZCBhdm9pZHMgcmV0dXJuaW5nXG4gKiAgIGB1bmRlZmluZWRgIHVuZXhwZWN0ZWRseS5cbiAqIC0gYHNldFNldHRpbmdgOiBtdXN0IGNhbGwgYHBhcGkucHJvamVjdFNldHRpbmdzLmlzVmFsaWRgIGJlZm9yZSBzZXR0aW5nIHRoZSB2YWx1ZSBhbmQgc2hvdWxkIHJldHVyblxuICogICBmYWxzZSBpZiB0aGUgY2FsbCByZXR1cm5zIGBmYWxzZWAgYW5kIHRocm93IGlmIHRoZSBjYWxsIHRocm93cy4gVGhpcyBmdW5jdGlvbmFsaXR5IHByZXNlcnZlc1xuICogICB0aGUgaW50ZW5kZWQgaW50ZW5kZWQgdHlwZSBvZiB0aGUgc2V0dGluZyBhbmQgYXZvaWRzIGFsbG93aW5nIHRoZSBzZXR0aW5nIHRvIGJlIHNldCB0byB0aGVcbiAqICAgd3JvbmcgdHlwZS5cbiAqIC0gYHJlc2V0U2V0dGluZ2A6IGRlbGV0ZXMgdGhlIHZhbHVlIGF0IHRoZSBrZXkgYW5kIHNlbmRzIGEgc2V0dGluZyB1cGRhdGUgZXZlbnQuIEFmdGVyIHRoaXMsXG4gKiAgIGBnZXRTZXR0aW5nYCBzaG91bGQgYWdhaW4gc2VlIHRoZSBzZXR0aW5nIHZhbHVlIGlzIG5vdCBwcmVzZW50LCBjYWxsXG4gKiAgIGBwYXBpLnByb2plY3RTZXR0aW5ncy5nZXREZWZhdWx0YCwgYW5kIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIC0gTm90ZTogc2VlIHtAbGluayBXaXRoUHJvamVjdERhdGFQcm92aWRlckVuZ2luZVNldHRpbmdNZXRob2RzfSBmb3IgbWV0aG9kIHNpZ25hdHVyZXMgZm9yIHRoZXNlXG4gKiAgIHRocmVlIG1ldGhvZHMuXG4gKlxuICogICAuLS0tXG4gKlxuICogIyMjIEV4dGVuc2lvbkRhdGFcbiAqXG4gKiBBbGwgUHJvamVjdCBEYXRhIFByb3ZpZGVyIGRhdGEgdHlwZXMgbXVzdCBoYXZlIGFuIGBFeHRlbnNpb25EYXRhYCB0eXBlLiBXZSBzdHJvbmdseSByZWNvbW1lbmQgYWxsXG4gKiBQcm9qZWN0IERhdGEgUHJvdmlkZXIgZGF0YSB0eXBlcyBleHRlbmQgZnJvbSB0aGlzIHR5cGUgaW4gb3JkZXIgdG8gc3RhbmRhcmRpemUgdGhlXG4gKiBgRXh0ZW5zaW9uRGF0YWAgdHlwZXMuXG4gKlxuICogQmVuZWZpdHMgb2YgZm9sbG93aW5nIHRoaXMgc3RhbmRhcmQ6XG4gKlxuICogLSBJZiBhbiBleHRlbnNpb24gdXNlcyB0aGUgYEV4dGVuc2lvbkRhdGFgIGVuZHBvaW50IGZvciBhbnkgcHJvamVjdCwgaXQgd2lsbCBsaWtlbHkgdXNlIHRoaXNcbiAqICAgc3RhbmRhcmRpemVkIGludGVyZmFjZSwgc28gdXNpbmcgdGhpcyBpbnRlcmZhY2Ugb24geW91ciBQcm9qZWN0IERhdGEgUHJvdmlkZXIgZGF0YSB0eXBlc1xuICogICBlbmFibGVzIHlvdXIgUERQIHRvIHN1cHBvcnQgZ2VuZXJpYyBleHRlbnNpb24gZGF0YVxuICogLSBJbiB0aGUgZnV0dXJlLCB3ZSBtYXkgZW5mb3JjZSB0aGF0IGNhbGxlcnMgdG8gYEV4dGVuc2lvbkRhdGFgIGVuZHBvaW50cyBpbmNsdWRlIGBleHRlbnNpb25OYW1lYCxcbiAqICAgc28gZm9sbG93aW5nIHRoaXMgaW50ZXJmYWNlIGVuc3VyZXMgeW91ciBQRFAgd2lsbCBub3QgYnJlYWsgaWYgc3VjaCBhIHJlcXVpcmVtZW50IGlzXG4gKiAgIGltcGxlbWVudGVkLlxuICovXG5leHBvcnQgdHlwZSBNYW5kYXRvcnlQcm9qZWN0RGF0YVR5cGVzID0ge1xuICBFeHRlbnNpb25EYXRhOiBEYXRhUHJvdmlkZXJEYXRhVHlwZTxFeHRlbnNpb25EYXRhU2NvcGUsIHN0cmluZyB8IHVuZGVmaW5lZCwgc3RyaW5nPjtcbn07XG5cbi8qKlxuICogVGhlIGBFeHRlbnNpb25EYXRhYCBtZXRob2RzIHJlcXVpcmVkIGZvciBhIFByb2plY3QgRGF0YSBQcm92aWRlciBFbmdpbmUgdG8gZnVsZmlsbCB0aGVcbiAqIHJlcXVpcmVtZW50cyBvZiB7QGxpbmsgTWFuZGF0b3J5UHJvamVjdERhdGFUeXBlc30ncyBgRXh0ZW5zaW9uRGF0YWAgZGF0YSB0eXBlLlxuICpcbiAqIE5vdGU6IFRoZXNlIG1ldGhvZHMgYXJlIGFscmVhZHkgY292ZXJlZCBieSB7QGxpbmsgTWFuZGF0b3J5UHJvamVjdERhdGFUeXBlc30sIGJ1dCB0aGlzIHR5cGUgYWRkc1xuICogSlNEb2NzIGZvciB0aGVtLlxuICovXG5leHBvcnQgdHlwZSBXaXRoUHJvamVjdERhdGFQcm92aWRlckVuZ2luZUV4dGVuc2lvbkRhdGFNZXRob2RzPFxuICBUUHJvamVjdERhdGFUeXBlcyBleHRlbmRzIERhdGFQcm92aWRlckRhdGFUeXBlcyxcbj4gPSB7XG4gIC8qKlxuICAgKiBHZXRzIGFuIGV4dGVuc2lvbidzIHByb2plY3QgZGF0YSBpZGVudGlmaWVkIGJ5IGBkYXRhU2NvcGVgIGluIHRoaXMgcHJvamVjdFxuICAgKlxuICAgKiBAcGFyYW0gZGF0YVNjb3BlIEluZm9ybWF0aW9uIGFib3V0IHdoYXQgZGF0YSBpcyBiZWluZyByZWZlcmVuY2VkIGJ5IHRoZSBjYWxsaW5nIGV4dGVuc2lvbiBnaXZlblxuICAgKiAgIHRvIHRoaXMgUHJvamVjdCBEYXRhIFByb3ZpZGVyXG4gICAqIEByZXR1cm5zIEV4dGVuc2lvbiBwcm9qZWN0IGRhdGEgaW4gdGhpcyBwcm9qZWN0IGZvciBhbiBleHRlbnNpb24gdG8gdXNlIGluIHNlcnZpbmcgaXRzXG4gICAqICAgZXh0ZW5zaW9uIHByb2plY3QgZGF0YVxuICAgKi9cbiAgZ2V0RXh0ZW5zaW9uRGF0YShkYXRhU2NvcGU6IEV4dGVuc2lvbkRhdGFTY29wZSk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIFNldHMgYW4gZXh0ZW5zaW9uJ3MgcHJvamVjdCBkYXRhIGlkZW50aWZpZWQgYnkgYGRhdGFTY29wZWAgaW4gdGhpcyBwcm9qZWN0XG4gICAqXG4gICAqIEBwYXJhbSBkYXRhU2NvcGUgSW5mb3JtYXRpb24gYWJvdXQgd2hhdCBkYXRhIGlzIGJlaW5nIHJlZmVyZW5jZWQgYnkgdGhlIGNhbGxpbmcgZXh0ZW5zaW9uIGdpdmVuXG4gICAqICAgdG8gdGhpcyBQcm9qZWN0IERhdGEgUHJvdmlkZXJcbiAgICogQHBhcmFtIGRhdGEgVXBkYXRlZCB2YWx1ZSBvZiBleHRlbnNpb24gcHJvamVjdCBkYXRhIGluIHRoaXMgcHJvamVjdCB0byBzZXRcbiAgICogQHJldHVybnMgSW5mb3JtYXRpb24gdGhhdCBwYXBpIHVzZXMgdG8gaW50ZXJwcmV0IHdoZXRoZXIgdG8gc2VuZCBvdXQgdXBkYXRlcy4gRGVmYXVsdHMgdG9cbiAgICogICBgdHJ1ZWAgKG1lYW5pbmcgc2VuZCB1cGRhdGVzIG9ubHkgZm9yIHRoaXMgZGF0YSB0eXBlKS5cbiAgICogQHNlZSB7QGxpbmsgRGF0YVByb3ZpZGVyVXBkYXRlSW5zdHJ1Y3Rpb25zfSBmb3IgbW9yZSBpbmZvIG9uIHdoYXQgdG8gcmV0dXJuXG4gICAqL1xuICBzZXRFeHRlbnNpb25EYXRhKFxuICAgIGRhdGFTY29wZTogRXh0ZW5zaW9uRGF0YVNjb3BlLFxuICAgIGRhdGE6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxEYXRhUHJvdmlkZXJVcGRhdGVJbnN0cnVjdGlvbnM8VFByb2plY3REYXRhVHlwZXM+Pjtcbn07XG4iLCJpbXBvcnQgeyBuZXR3b3JrT2JqZWN0U2VydmljZSB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbmV0d29yay1vYmplY3Quc2VydmljZSc7XG5pbXBvcnQge1xuICBQcm9qZWN0RGF0YVByb3ZpZGVyRmFjdG9yeU1ldGFkYXRhSW5mbyxcbiAgUHJvamVjdE1ldGFkYXRhLFxuICBQcm9qZWN0TWV0YWRhdGFXaXRob3V0RmFjdG9yeUluZm8sXG59IGZyb20gJ0BzaGFyZWQvbW9kZWxzL3Byb2plY3QtbWV0YWRhdGEubW9kZWwnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9sb2dnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBuZXR3b3JrT2JqZWN0U3RhdHVzU2VydmljZSB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbmV0d29yay1vYmplY3Qtc3RhdHVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgUHJvamVjdEludGVyZmFjZXMgfSBmcm9tICdwYXBpLXNoYXJlZC10eXBlcyc7XG5pbXBvcnQge1xuICBJUHJvamVjdERhdGFQcm92aWRlckZhY3RvcnksXG4gIFBEUF9GQUNUT1JZX09CSkVDVF9UWVBFLFxuICBQcm9qZWN0TWV0YWRhdGFGaWx0ZXJPcHRpb25zLFxufSBmcm9tICdAc2hhcmVkL21vZGVscy9wcm9qZWN0LWRhdGEtcHJvdmlkZXItZmFjdG9yeS5pbnRlcmZhY2UnO1xuaW1wb3J0IHtcbiAgZGVlcENsb25lLFxuICBlbmRzV2l0aCxcbiAgZW5zdXJlQXJyYXksXG4gIGVzY2FwZVN0cmluZ1JlZ2V4cCxcbiAgc2xpY2UsXG4gIHRyYW5zZm9ybUFuZEVuc3VyZVJlZ0V4cEFycmF5LFxuICB0cmFuc2Zvcm1BbmRFbnN1cmVSZWdFeHBSZWdFeHBBcnJheSxcbiAgd2FpdCxcbn0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgTkVUV09SS19PQkpFQ1RfTkFNRV9QUk9KRUNUX0xPT0tVUF9TRVJWSUNFID0gJ1Byb2plY3RMb29rdXBTZXJ2aWNlJztcblxuLy8gI3JlZ2lvbiBQcm9qZWN0IGRhdGEgcHJvdmlkZXIgZmFjdG9yeSB1dGlsaXRpZXNcblxuLyoqXG4gKiBTdWZmaXggb24gbmV0d29yayBvYmplY3RzIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIG5ldHdvcmsgb2JqZWN0IGlzIGEgcHJvamVjdCBkYXRhIHByb3ZpZGVyXG4gKiBmYWN0b3J5XG4gKi9cbmNvbnN0IFBEUF9GQUNUT1JZX0xBQkVMID0gJy1wZHBmJztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHdlbGwta25vd24gcGRwIGZhY3RvcnkgaWQgaW50byBhbiBpZCBmb3IgaXRzIG5ldHdvcmsgb2JqZWN0IHRvIHVzZVxuICpcbiAqIEBwYXJhbSBwZHBGYWN0b3J5SWQgSWQgZXh0ZW5zaW9ucyB1c2UgdG8gaWRlbnRpZnkgdGhpcyBwZHAgZmFjdG9yeVxuICogQHJldHVybnMgSWQgZm9yIHRoZW4gbmV0d29yayBvYmplY3QgZm9yIHRoaXMgcGRwIGZhY3RvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBEUEZhY3RvcnlOZXR3b3JrT2JqZWN0TmFtZUZyb21JZChwZHBGYWN0b3J5SWQ6IHN0cmluZykge1xuICByZXR1cm4gZW5kc1dpdGgocGRwRmFjdG9yeUlkLCBQRFBfRkFDVE9SWV9MQUJFTClcbiAgICA/IHBkcEZhY3RvcnlJZFxuICAgIDogYCR7cGRwRmFjdG9yeUlkfSR7UERQX0ZBQ1RPUllfTEFCRUx9YDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBuZXR3b3JrIG9iamVjdCBpZCBmb3IgYSBwZHAgZmFjdG9yeSBpbnRvIGl0cyB3ZWxsLWtub3duIHBkcCBmYWN0b3J5IGlkXG4gKlxuICogQHBhcmFtIHBkcEZhY3RvcnlOZXR3b3JrT2JqZWN0TmFtZSBJZCBmb3IgdGhlbiBuZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBwZHAgZmFjdG9yeVxuICogQHJldHVybnMgSWQgZXh0ZW5zaW9ucyB1c2UgdG8gaWRlbnRpZnkgdGhpcyBwZHAgZmFjdG9yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UERQRmFjdG9yeUlkRnJvbU5ldHdvcmtPYmplY3ROYW1lKHBkcEZhY3RvcnlOZXR3b3JrT2JqZWN0TmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiBlbmRzV2l0aChwZHBGYWN0b3J5TmV0d29ya09iamVjdE5hbWUsIFBEUF9GQUNUT1JZX0xBQkVMKVxuICAgID8gc2xpY2UocGRwRmFjdG9yeU5ldHdvcmtPYmplY3ROYW1lLCAwLCAtUERQX0ZBQ1RPUllfTEFCRUwubGVuZ3RoKVxuICAgIDogcGRwRmFjdG9yeU5ldHdvcmtPYmplY3ROYW1lO1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8vICNyZWdpb24gUHJvamVjdCBsb29rdXAgc2VydmljZVxuXG4vKipcbiAqIEpTRE9DIFNPVVJDRSBwcm9qZWN0TG9va3VwU2VydmljZVxuICpcbiAqIFByb3ZpZGVzIG1ldGFkYXRhIGZvciBwcm9qZWN0cyBrbm93biBieSB0aGUgcGxhdGZvcm1cbiAqXG4gKiBOb3RlOiB0aGlzIHNlcnZpY2UgcnVucyBsb2NhbGx5IGV2ZXJ5d2hlcmUgaW4gdGhlIFR5cGVTY3JpcHQgcHJvY2Vzc2VzLiBJdCBpcyBhbHNvIGV4cG9zZWQgb24gdGhlXG4gKiBQQVBJIHdlYnNvY2tldC4gTm90ZSB0aGVzZSBmdW5jdGlvbnMgYXJlIGFsbCBhc3luY2hyb25vdXMgb24gdGhlIFBBUEkgd2Vic29ja2V0IHJlZ2FyZGxlc3Mgb2YgaWZcbiAqIHRoZWlyIHR5cGVzIGFyZSBzeW5jaHJvbm91cyBsb2NhbGx5LlxuICovXG5leHBvcnQgdHlwZSBQcm9qZWN0TG9va3VwU2VydmljZVR5cGUgPSB7XG4gIC8qKlxuICAgKiBQcm92aWRlIG1ldGFkYXRhIGZvciBhbGwgcHJvamVjdHMgdGhhdCBoYXZlIFBEUCBmYWN0b3JpZXNcbiAgICpcbiAgICogTm90ZTogSWYgdGhlcmUgYXJlIG11bHRpcGxlIFBEUHMgYXZhaWxhYmxlIHdob3NlIG1ldGFkYXRhIG1hdGNoZXMgdGhlIGNvbmRpdGlvbnMgcHJvdmlkZWQgYnlcbiAgICogdGhlIHBhcmFtZXRlcnMsIHRoZWlyIHByb2plY3QgbWV0YWRhdGEgd2lsbCBhbGwgYmUgY29tYmluZWQsIHNvIGFsbCBhdmFpbGFibGVcbiAgICogYHByb2plY3RJbnRlcmZhY2VgcyBwcm92aWRlZCBieSB0aGUgUERQIEZhY3Rvcnkgd2l0aCB0aGUgbWF0Y2hpbmcgSUQgKG9yIGFsbCBQRFAgRmFjdG9yaWVzIGlmXG4gICAqIG5vIElEIGlzIHNwZWNpZmllZCkgZm9yIHRoZSBwcm9qZWN0IHdpbGwgYmUgcmV0dXJuZWQuIElmIHlvdSBuZWVkIGBwcm9qZWN0SW50ZXJmYWNlYHMgc3VwcG9ydGVkXG4gICAqIGJ5IHNwZWNpZmljIFBEUCBGYWN0b3JpZXMsIHlvdSBjYW4gYWNjZXNzIGl0IGF0IHtAbGluayBQcm9qZWN0TWV0YWRhdGEucGRwRmFjdG9yeUluZm99LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBzcGVjaWZ5aW5nIGZpbHRlcnMgZm9yIHRoZSBwcm9qZWN0IG1ldGFkYXRhIHJldHJpZXZlZC4gSWYgYSBQRFBcbiAgICogICBGYWN0b3J5IElEIGRvZXMgbm90IG1hdGNoIHRoZSBmaWx0ZXIsIGl0IHdpbGwgbm90IGJlIGNvbnRhY3RlZCBhdCBhbGwgZm9yIHRoaXMgZnVuY3Rpb24gY2FsbC5cbiAgICogICBBcyBhIHJlc3VsdCwgYSBQRFAgZmFjdG9yeSB0aGF0IGludGVuZHMgdG8gbGF5ZXIgb3ZlciBvdGhlciBQRFAgZmFjdG9yaWVzICoqbXVzdCoqIHNwZWNpZnlcbiAgICogICBpdHMgSUQgaW4gYG9wdGlvbnMuZXhjbHVkZVBkcEZhY3RvcnlJZHNgIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3Agb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJucyBQcm9qZWN0TWV0YWRhdGEgZm9yIGFsbCBwcm9qZWN0cyBzdG9yZWQgb24gdGhlIGxvY2FsIHN5c3RlbVxuICAgKi9cbiAgZ2V0TWV0YWRhdGFGb3JBbGxQcm9qZWN0cyhvcHRpb25zPzogUHJvamVjdE1ldGFkYXRhRmlsdGVyT3B0aW9ucyk6IFByb21pc2U8UHJvamVjdE1ldGFkYXRhW10+O1xuICAvKipcbiAgICogTG9vayB1cCBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBwcm9qZWN0IElEXG4gICAqXG4gICAqIE5vdGU6IElmIHRoZXJlIGFyZSBtdWx0aXBsZSBQRFBzIGF2YWlsYWJsZSB3aG9zZSBtZXRhZGF0YSBtYXRjaGVzIHRoZSBjb25kaXRpb25zIHByb3ZpZGVkIGJ5XG4gICAqIHRoZSBwYXJhbWV0ZXJzLCB0aGVpciBwcm9qZWN0IG1ldGFkYXRhIHdpbGwgYWxsIGJlIGNvbWJpbmVkLCBzbyBhbGwgYXZhaWxhYmxlXG4gICAqIGBwcm9qZWN0SW50ZXJmYWNlYHMgcHJvdmlkZWQgYnkgdGhlIFBEUCBGYWN0b3J5IHdpdGggdGhlIG1hdGNoaW5nIGlkIChvciBhbGwgUERQIEZhY3RvcmllcyBpZlxuICAgKiBubyBpZCBpcyBzcGVjaWZpZWQpIGZvciB0aGUgcHJvamVjdCB3aWxsIGJlIHJldHVybmVkLiBJZiB5b3UgbmVlZCBgcHJvamVjdEludGVyZmFjZWBzIHN1cHBvcnRlZFxuICAgKiBieSBzcGVjaWZpYyBQRFAgRmFjdG9yaWVzLCB5b3UgY2FuIGFjY2VzcyBpdCBhdCB7QGxpbmsgUHJvamVjdE1ldGFkYXRhLnBkcEZhY3RvcnlJbmZvfS5cbiAgICpcbiAgICogQHBhcmFtIHByb2plY3RJZCBJRCBvZiB0aGUgcHJvamVjdCB0byBsb2FkXG4gICAqIEBwYXJhbSBwcm9qZWN0SW50ZXJmYWNlIE9wdGlvbmFsIGBwcm9qZWN0SW50ZXJmYWNlYCBvZiB0aGUgcHJvamVjdCB0byBsb2FkLiBJZiBub3QgcHJvdmlkZWQsXG4gICAqICAgdGhlbiBsb29rIGF0IGFsbCBgcHJvamVjdEludGVyZmFjZWBzIGZvciB0aGUgZ2l2ZW4gcHJvamVjdCBJRC5cbiAgICogQHBhcmFtIHBkcEZhY3RvcnlJZCBPcHRpb25hbCBJRCBvZiB0aGUgUERQIGZhY3Rvcnkgd2hlcmUgdGhlIHByb2plY3QgSUQgc2hvdWxkIGJlIGxvYWRlZC4gSWZcbiAgICogICBub3QgcHJvdmlkZWQsIHRoZW4gbG9vayBpbiBhbGwgYXZhaWxhYmxlIFBEUCBmYWN0b3JpZXMgZm9yIHRoZSBnaXZlbiBwcm9qZWN0IElELlxuICAgKiBAcmV0dXJucyBQcm9qZWN0TWV0YWRhdGEgZm9yIHRoZSBnaXZlbiBwcm9qZWN0XG4gICAqL1xuICBnZXRNZXRhZGF0YUZvclByb2plY3QoXG4gICAgcHJvamVjdElkOiBzdHJpbmcsXG4gICAgcHJvamVjdEludGVyZmFjZT86IFByb2plY3RJbnRlcmZhY2VzLFxuICAgIHBkcEZhY3RvcnlJZD86IHN0cmluZyxcbiAgKTogUHJvbWlzZTxQcm9qZWN0TWV0YWRhdGE+O1xuICAvKipcbiAgICogQ29tcGFyZSB0d28gcHJvamVjdCBpZHMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWFsXG4gICAqXG4gICAqIFdlJ3JlIHRyZWF0aW5nIHByb2plY3QgSURzIGFzIGNhc2UgaW5zZW5zaXRpdmUgc3RyaW5ncy5cbiAgICpcbiAgICogRnJvbVxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnRsL0NvbGxhdG9yL0NvbGxhdG9yOlxuICAgKlxuICAgKiBPbmx5IHN0cmluZ3MgdGhhdCBkaWZmZXIgaW4gYmFzZSBsZXR0ZXJzIG9yIGFjY2VudHMgYW5kIG90aGVyIGRpYWNyaXRpYyBtYXJrcyBjb21wYXJlIGFzXG4gICAqIHVuZXF1YWwuIEV4YW1wbGVzOiBhIOKJoCBiLCBhIOKJoCDDoSwgYSA9IEEuXG4gICAqL1xuICBhcmVQcm9qZWN0SWRzRXF1YWwocHJvamVjdElkQTogc3RyaW5nLCBwcm9qZWN0SWRCOiBzdHJpbmcpOiBib29sZWFuO1xuICAvKiogRmlsdGVyIGFuIGFycmF5IG9mIHtAbGluayBQcm9qZWN0TWV0YWRhdGF9IGluIHZhcmlvdXMgd2F5cyAqL1xuICBmaWx0ZXJQcm9qZWN0c01ldGFkYXRhKFxuICAgIHByb2plY3RzTWV0YWRhdGE6IFByb2plY3RNZXRhZGF0YVtdLFxuICAgIG9wdGlvbnM6IFByb2plY3RNZXRhZGF0YUZpbHRlck9wdGlvbnMsXG4gICk6IFByb2plY3RNZXRhZGF0YVtdO1xuICAvKiogQ29tYmluZXMgdHdvIHByb2plY3QgbWV0YWRhdGEgZmlsdGVycywgcmVtb3ZpbmcgZHVwbGljYXRlIGl0ZW1zICovXG4gIG1lcmdlTWV0YWRhdGFGaWx0ZXJzKFxuICAgIG1ldGFkYXRhRmlsdGVyMTogUHJvamVjdE1ldGFkYXRhRmlsdGVyT3B0aW9ucyB8IHVuZGVmaW5lZCxcbiAgICBtZXRhZGF0YUZpbHRlcjI6IFByb2plY3RNZXRhZGF0YUZpbHRlck9wdGlvbnMgfCB1bmRlZmluZWQsXG4gICk6IFByb2plY3RNZXRhZGF0YUZpbHRlck9wdGlvbnM7XG4gIC8qKlxuICAgKiBHZXQgdGhlIFBEUCBGYWN0b3J5IGluZm8gd2hvc2UgYHByb2plY3RJbnRlcmZhY2VgcyBhcmUgbW9zdCBtaW5pbWFsbHkgbWF0Y2hpbmcgdG8gdGhlIHByb3ZpZGVkXG4gICAqIGBwcm9qZWN0SW50ZXJmYWNlYFxuICAgKlxuICAgKiBIb3BlZnVsbHkgdGhpcyB3aWxsIGFsbG93IHVzIHRvIGdldCB0aGUgUERQIHRoYXQgbW9zdCBjbG9zZWx5IG1hdGNoZXMgdGhlIGBwcm9qZWN0SW50ZXJmYWNlYHNcbiAgICogdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVkaXJlY3RzIHRocm91Z2ggbGF5ZXJlZCBQRFBzXG4gICAqXG4gICAqIEBwYXJhbSBwcm9qZWN0TWV0YWRhdGEgTWV0YWRhdGEgZm9yIHByb2plY3QgZm9yIHdoaWNoIHRvIGdldCBtaW5pbWFsbHkgbWF0Y2hpbmcgUERQRlxuICAgKiBAcGFyYW0gcHJvamVjdEludGVyZmFjZSBXaGljaCBgcHJvamVjdEludGVyZmFjZWAgdG8gbWluaW1hbGx5IG1hdGNoIGZvclxuICAgKiBAcmV0dXJucyBQRFAgRmFjdG9yeSBpZCB3aG9zZSBgcHJvamVjdEludGVyZmFjZWBzIG1pbmltYWxseSBtYXRjaCB0aGUgcHJvdmlkZWRcbiAgICogICBgcHJvamVjdEludGVyZmFjZWAgaWYgYXQgbGVhc3Qgb25lIFBEUCBGYWN0b3J5IHdhcyBmb3VuZCB0aGF0IHN1cHBvcnRzIHRoZSBgcHJvamVjdEludGVyZmFjZWBcbiAgICogICBwcm92aWRlZFxuICAgKi9cbiAgZ2V0TWluaW1hbE1hdGNoUGRwRmFjdG9yeUlkKFxuICAgIHByb2plY3RNZXRhZGF0YTogUHJvamVjdE1ldGFkYXRhLFxuICAgIHByb2plY3RJbnRlcmZhY2U6IFByb2plY3RJbnRlcmZhY2VzLFxuICApOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG4vKiogTG9jYWwgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBydW4gbG9jYWxseSBvbiBlYWNoIHByb2Nlc3MgYXMgcGFydCBvZiB0aGUgcHJvamVjdCBsb29rdXAgc2VydmljZSAqL1xuZXhwb3J0IGNvbnN0IHByb2plY3RMb29rdXBTZXJ2aWNlQmFzZTogUHJvamVjdExvb2t1cFNlcnZpY2VUeXBlID0ge1xuICBhc3luYyBnZXRNZXRhZGF0YUZvckFsbFByb2plY3RzKFxuICAgIG9wdGlvbnM6IFByb2plY3RNZXRhZGF0YUZpbHRlck9wdGlvbnMgPSB7fSxcbiAgKTogUHJvbWlzZTxQcm9qZWN0TWV0YWRhdGFbXT4ge1xuICAgIHJldHVybiBpbnRlcm5hbEdldE1ldGFkYXRhV2l0aFJldHJpZXMob3B0aW9ucyk7XG4gIH0sXG4gIGFzeW5jIGdldE1ldGFkYXRhRm9yUHJvamVjdChcbiAgICBwcm9qZWN0SWQ6IHN0cmluZyxcbiAgICBwcm9qZWN0SW50ZXJmYWNlPzogUHJvamVjdEludGVyZmFjZXMsXG4gICAgcGRwRmFjdG9yeUlkPzogc3RyaW5nLFxuICApOiBQcm9taXNlPFByb2plY3RNZXRhZGF0YT4ge1xuICAgIC8vIFdhaXQgZm9yIGFuIGFwcHJvcHJpYXRlIFBEUCBmYWN0b3J5IHRvIGJlIHJlZ2lzdGVyZWRcbiAgICBjb25zdCB0aW1lb3V0SW5NUyA9IDIwICogMTAwMDtcbiAgICBpZiAocGRwRmFjdG9yeUlkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBuZXR3b3JrT2JqZWN0U3RhdHVzU2VydmljZS53YWl0Rm9yTmV0d29ya09iamVjdChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvYmplY3RUeXBlOiBQRFBfRkFDVE9SWV9PQkpFQ1RfVFlQRSxcbiAgICAgICAgICAgIGlkOiBnZXRQRFBGYWN0b3J5TmV0d29ya09iamVjdE5hbWVGcm9tSWQocGRwRmFjdG9yeUlkKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpbWVvdXRJbk1TLFxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldE1ldGFkYXRhRm9yUHJvamVjdCB3YWl0IGZvciBQRFBGICR7cGRwRmFjdG9yeUlkfSB0aHJldyEgJHtlfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvamVjdEludGVyZmFjZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbmV0d29ya09iamVjdFN0YXR1c1NlcnZpY2Uud2FpdEZvck5ldHdvcmtPYmplY3QoXG4gICAgICAgICAge1xuICAgICAgICAgICAgb2JqZWN0VHlwZTogUERQX0ZBQ1RPUllfT0JKRUNUX1RZUEUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IHByb2plY3RJbnRlcmZhY2VzOiBbcHJvamVjdEludGVyZmFjZV0gfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpbWVvdXRJbk1TLFxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldE1ldGFkYXRhRm9yUHJvamVjdCB3YWl0IGZvciBQRFBGIHdpdGggJHtwcm9qZWN0SW50ZXJmYWNlfSB0aHJldyEgJHtlfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBuZXR3b3JrT2JqZWN0U3RhdHVzU2VydmljZS53YWl0Rm9yTmV0d29ya09iamVjdChcbiAgICAgICAgICB7IG9iamVjdFR5cGU6IFBEUF9GQUNUT1JZX09CSkVDVF9UWVBFIH0sXG4gICAgICAgICAgdGltZW91dEluTVMsXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZ2V0TWV0YWRhdGFGb3JQcm9qZWN0IHdhaXQgZm9yIGFueSBQRFBGIHRocmV3ISAke2V9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBpbnRlcm5hbEdldE1ldGFkYXRhV2l0aFJldHJpZXMoXG4gICAgICB0cmFuc2Zvcm1HZXRNZXRhZGF0YUZvclByb2plY3RQYXJhbWV0ZXJzVG9GaWx0ZXIocHJvamVjdElkLCBwcm9qZWN0SW50ZXJmYWNlLCBwZHBGYWN0b3J5SWQpLFxuICAgICk7XG5cbiAgICAvLyBHZXQgdGhlIG1vc3QgbWluaW1hbCBtYXRjaCB0byB0aGUgcHJvamVjdEludGVyZmFjZSBpbiBxdWVzdGlvbi4gSG9wZWZ1bGx5IHRoaXMgd2lsbCBnaXZlIHVzIHRoZVxuICAgIC8vIFBEUCB0aGF0IG1vc3QgY2xvc2VseSBtYXRjaGVzIHRoZSBwcm9qZWN0SW50ZXJmYWNlcyB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZWRpcmVjdHMgdGhyb3VnaFxuICAgIC8vIGxheWVyZWQgUERQc1xuICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5sZW5ndGggPiAwKSByZXR1cm4gbWV0YWRhdGFbMF07XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE5vIHByb2plY3QgZm91bmQgd2l0aCBJRCAke3Byb2plY3RJZH0ke3Byb2plY3RJbnRlcmZhY2UgPyBgIGFuZCBwcm9qZWN0IGludGVyZmFjZSAke3Byb2plY3RJbnRlcmZhY2V9YCA6ICcnfSR7cGRwRmFjdG9yeUlkID8gYCBmcm9tICR7cGRwRmFjdG9yeUlkfWAgOiAnJ31gLFxuICAgICk7XG4gIH0sXG4gIGFyZVByb2plY3RJZHNFcXVhbCxcbiAgZmlsdGVyUHJvamVjdHNNZXRhZGF0YShcbiAgICBwcm9qZWN0c01ldGFkYXRhOiBQcm9qZWN0TWV0YWRhdGFbXSxcbiAgICBvcHRpb25zOiBQcm9qZWN0TWV0YWRhdGFGaWx0ZXJPcHRpb25zLFxuICApOiBQcm9qZWN0TWV0YWRhdGFbXSB7XG4gICAgaWYgKCFvcHRpb25zKSByZXR1cm4gWy4uLnByb2plY3RzTWV0YWRhdGFdO1xuXG4gICAgaWYgKFxuICAgICAgIW9wdGlvbnMuZXhjbHVkZVByb2plY3RJZHMgJiZcbiAgICAgICFvcHRpb25zLmluY2x1ZGVQcm9qZWN0SWRzICYmXG4gICAgICAhb3B0aW9ucy5pbmNsdWRlUHJvamVjdEludGVyZmFjZXMgJiZcbiAgICAgICFvcHRpb25zLmV4Y2x1ZGVQcm9qZWN0SW50ZXJmYWNlcyAmJlxuICAgICAgIW9wdGlvbnMuaW5jbHVkZVBkcEZhY3RvcnlJZHMgJiZcbiAgICAgICFvcHRpb25zLmV4Y2x1ZGVQZHBGYWN0b3J5SWRzXG4gICAgKVxuICAgICAgcmV0dXJuIFsuLi5wcm9qZWN0c01ldGFkYXRhXTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGV4Y2x1ZGVQcm9qZWN0SWRzLFxuICAgICAgaW5jbHVkZVByb2plY3RJZHMsXG4gICAgICBpbmNsdWRlUHJvamVjdEludGVyZmFjZXMsXG4gICAgICBleGNsdWRlUHJvamVjdEludGVyZmFjZXMsXG4gICAgICBpbmNsdWRlUGRwRmFjdG9yeUlkcyxcbiAgICAgIGV4Y2x1ZGVQZHBGYWN0b3J5SWRzLFxuICAgIH0gPSBlbnN1cmVQb3B1bGF0ZWRNZXRhZGF0YUZpbHRlcihvcHRpb25zKTtcblxuICAgIHJldHVybiBwcm9qZWN0c01ldGFkYXRhLmZpbHRlcigocHJvamVjdE1ldGFkYXRhKSA9PiB7XG4gICAgICAvLyBJZiB0aGUgcHJvamVjdCBJRCBpc24ndCBpbiB0aGUgZmlsdGVycywgaXQncyBvdXRcbiAgICAgIGlmICghaXNQcm9qZWN0SWRJbmNsdWRlZChwcm9qZWN0TWV0YWRhdGEuaWQsIGluY2x1ZGVQcm9qZWN0SWRzLCBleGNsdWRlUHJvamVjdElkcykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gSWYgdGhlIGBwcm9qZWN0SW50ZXJmYWNlYHMgZG9uJ3QgbWF0Y2ggdGhlIGZpbHRlcnMsIGl0J3Mgb3V0XG4gICAgICBpZiAoXG4gICAgICAgICFhcmVQcm9qZWN0SW50ZXJmYWNlc0luY2x1ZGVkKFxuICAgICAgICAgIHByb2plY3RNZXRhZGF0YS5wcm9qZWN0SW50ZXJmYWNlcyxcbiAgICAgICAgICBpbmNsdWRlUHJvamVjdEludGVyZmFjZXMsXG4gICAgICAgICAgZXhjbHVkZVByb2plY3RJbnRlcmZhY2VzLFxuICAgICAgICApXG4gICAgICApXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gSWYgdGhlIHBkcCBmYWN0b3J5IGluZm8gZG9lc24ndCBtYXRjaCB0aGUgZmlsdGVycywgaXQncyBvdXRcbiAgICAgIGNvbnN0IHBkcEZhY3RvcnlJZHMgPSBPYmplY3Qua2V5cyhwcm9qZWN0TWV0YWRhdGEucGRwRmFjdG9yeUluZm8pO1xuICAgICAgaWYgKCFhcmVQZHBGYWN0b3J5SWRzSW5jbHVkZWQocGRwRmFjdG9yeUlkcywgaW5jbHVkZVBkcEZhY3RvcnlJZHMsIGV4Y2x1ZGVQZHBGYWN0b3J5SWRzKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfSxcbiAgbWVyZ2VNZXRhZGF0YUZpbHRlcnMoXG4gICAgbWV0YWRhdGFGaWx0ZXIxOiBQcm9qZWN0TWV0YWRhdGFGaWx0ZXJPcHRpb25zIHwgdW5kZWZpbmVkLFxuICAgIG1ldGFkYXRhRmlsdGVyMjogUHJvamVjdE1ldGFkYXRhRmlsdGVyT3B0aW9ucyB8IHVuZGVmaW5lZCxcbiAgKSB7XG4gICAgY29uc3QgbWVyZ2VkRmlsdGVyOiBQcm9qZWN0TWV0YWRhdGFGaWx0ZXJPcHRpb25zID0ge307XG5cbiAgICBpZiAobWV0YWRhdGFGaWx0ZXIxPy5pbmNsdWRlUHJvamVjdElkcyB8fCBtZXRhZGF0YUZpbHRlcjI/LmluY2x1ZGVQcm9qZWN0SWRzKVxuICAgICAgbWVyZ2VkRmlsdGVyLmluY2x1ZGVQcm9qZWN0SWRzID0gW1xuICAgICAgICAuLi5uZXcgU2V0KFtcbiAgICAgICAgICAuLi5lbnN1cmVBcnJheShtZXRhZGF0YUZpbHRlcjE/LmluY2x1ZGVQcm9qZWN0SWRzKSxcbiAgICAgICAgICAuLi5lbnN1cmVBcnJheShtZXRhZGF0YUZpbHRlcjI/LmluY2x1ZGVQcm9qZWN0SWRzKSxcbiAgICAgICAgXSksXG4gICAgICBdO1xuICAgIGlmIChtZXRhZGF0YUZpbHRlcjE/LmV4Y2x1ZGVQcm9qZWN0SWRzIHx8IG1ldGFkYXRhRmlsdGVyMj8uZXhjbHVkZVByb2plY3RJZHMpXG4gICAgICBtZXJnZWRGaWx0ZXIuZXhjbHVkZVByb2plY3RJZHMgPSBbXG4gICAgICAgIC4uLm5ldyBTZXQoW1xuICAgICAgICAgIC4uLmVuc3VyZUFycmF5KG1ldGFkYXRhRmlsdGVyMT8uZXhjbHVkZVByb2plY3RJZHMpLFxuICAgICAgICAgIC4uLmVuc3VyZUFycmF5KG1ldGFkYXRhRmlsdGVyMj8uZXhjbHVkZVByb2plY3RJZHMpLFxuICAgICAgICBdKSxcbiAgICAgIF07XG5cbiAgICBpZiAobWV0YWRhdGFGaWx0ZXIxPy5pbmNsdWRlUHJvamVjdEludGVyZmFjZXMgfHwgbWV0YWRhdGFGaWx0ZXIyPy5pbmNsdWRlUHJvamVjdEludGVyZmFjZXMpXG4gICAgICBtZXJnZWRGaWx0ZXIuaW5jbHVkZVByb2plY3RJbnRlcmZhY2VzID0gW1xuICAgICAgICAuLi5uZXcgU2V0KFtcbiAgICAgICAgICAuLi5lbnN1cmVBcnJheShtZXRhZGF0YUZpbHRlcjE/LmluY2x1ZGVQcm9qZWN0SW50ZXJmYWNlcyksXG4gICAgICAgICAgLi4uZW5zdXJlQXJyYXkobWV0YWRhdGFGaWx0ZXIyPy5pbmNsdWRlUHJvamVjdEludGVyZmFjZXMpLFxuICAgICAgICBdKSxcbiAgICAgIF07XG4gICAgaWYgKG1ldGFkYXRhRmlsdGVyMT8uZXhjbHVkZVByb2plY3RJbnRlcmZhY2VzIHx8IG1ldGFkYXRhRmlsdGVyMj8uZXhjbHVkZVByb2plY3RJbnRlcmZhY2VzKVxuICAgICAgbWVyZ2VkRmlsdGVyLmV4Y2x1ZGVQcm9qZWN0SW50ZXJmYWNlcyA9IFtcbiAgICAgICAgLi4ubmV3IFNldChbXG4gICAgICAgICAgLi4uZW5zdXJlQXJyYXkobWV0YWRhdGFGaWx0ZXIxPy5leGNsdWRlUHJvamVjdEludGVyZmFjZXMpLFxuICAgICAgICAgIC4uLmVuc3VyZUFycmF5KG1ldGFkYXRhRmlsdGVyMj8uZXhjbHVkZVByb2plY3RJbnRlcmZhY2VzKSxcbiAgICAgICAgXSksXG4gICAgICBdO1xuXG4gICAgaWYgKG1ldGFkYXRhRmlsdGVyMT8uaW5jbHVkZVBkcEZhY3RvcnlJZHMgfHwgbWV0YWRhdGFGaWx0ZXIyPy5pbmNsdWRlUGRwRmFjdG9yeUlkcylcbiAgICAgIG1lcmdlZEZpbHRlci5pbmNsdWRlUGRwRmFjdG9yeUlkcyA9IFtcbiAgICAgICAgLi4ubmV3IFNldChbXG4gICAgICAgICAgLi4uZW5zdXJlQXJyYXkobWV0YWRhdGFGaWx0ZXIxPy5pbmNsdWRlUGRwRmFjdG9yeUlkcyksXG4gICAgICAgICAgLi4uZW5zdXJlQXJyYXkobWV0YWRhdGFGaWx0ZXIyPy5pbmNsdWRlUGRwRmFjdG9yeUlkcyksXG4gICAgICAgIF0pLFxuICAgICAgXTtcbiAgICBpZiAobWV0YWRhdGFGaWx0ZXIxPy5leGNsdWRlUGRwRmFjdG9yeUlkcyB8fCBtZXRhZGF0YUZpbHRlcjI/LmV4Y2x1ZGVQZHBGYWN0b3J5SWRzKVxuICAgICAgbWVyZ2VkRmlsdGVyLmV4Y2x1ZGVQZHBGYWN0b3J5SWRzID0gW1xuICAgICAgICAuLi5uZXcgU2V0KFtcbiAgICAgICAgICAuLi5lbnN1cmVBcnJheShtZXRhZGF0YUZpbHRlcjE/LmV4Y2x1ZGVQZHBGYWN0b3J5SWRzKSxcbiAgICAgICAgICAuLi5lbnN1cmVBcnJheShtZXRhZGF0YUZpbHRlcjI/LmV4Y2x1ZGVQZHBGYWN0b3J5SWRzKSxcbiAgICAgICAgXSksXG4gICAgICBdO1xuXG4gICAgcmV0dXJuIG1lcmdlZEZpbHRlcjtcbiAgfSxcbiAgZ2V0TWluaW1hbE1hdGNoUGRwRmFjdG9yeUlkKFxuICAgIHByb2plY3RNZXRhZGF0YTogUHJvamVjdE1ldGFkYXRhLFxuICAgIHByb2plY3RJbnRlcmZhY2U6IFByb2plY3RJbnRlcmZhY2VzLFxuICApOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IG1pbmltYWxNYXRjaCA9IE9iamVjdC5lbnRyaWVzKHByb2plY3RNZXRhZGF0YS5wZHBGYWN0b3J5SW5mbykucmVkdWNlKFxuICAgICAgKHByZXZpb3VzUGRwZkluZm9FbnRyeSwgbmV4dFBkcGZJbmZvRW50cnkpID0+XG4gICAgICAgIG5leHRQZHBmSW5mb0VudHJ5WzFdPy5wcm9qZWN0SW50ZXJmYWNlcy5pbmNsdWRlcyhwcm9qZWN0SW50ZXJmYWNlKSAmJlxuICAgICAgICBjb21wYXJlUHJvamVjdERhdGFQcm92aWRlckZhY3RvcnlNZXRhZGF0YUluZm9NaW5pbWFsTWF0Y2goXG4gICAgICAgICAgcHJldmlvdXNQZHBmSW5mb0VudHJ5WzFdLFxuICAgICAgICAgIG5leHRQZHBmSW5mb0VudHJ5WzFdLFxuICAgICAgICApID4gMFxuICAgICAgICAgID8gbmV4dFBkcGZJbmZvRW50cnlcbiAgICAgICAgICA6IHByZXZpb3VzUGRwZkluZm9FbnRyeSxcbiAgICAgIFsnJywgdW5kZWZpbmVkXSxcbiAgICApO1xuXG4gICAgcmV0dXJuIG1pbmltYWxNYXRjaFswXSAmJiBtaW5pbWFsTWF0Y2hbMV0gPyBtaW5pbWFsTWF0Y2hbMF0gOiB1bmRlZmluZWQ7XG4gIH0sXG59O1xuXG4vLyAjZW5kcmVnaW9uXG5cbi8vICNyZWdpb24gUHJvamVjdCBMb29rdXAgU2VydmljZSB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4vKipcbiAqIEhvdyBsb25nIHNpbmNlIHN0YXJ0IG9mIHRoZSBjdXJyZW50IHByb2Nlc3MgdG8gY291bnQgYXMgdGltZSB0aGF0IHRoZSBQRFBGcyBwb3NzaWJseSBzdGlsbFxuICogaGF2ZW4ndCBhbGwgc3RhcnRlZCB1cFxuICovXG5jb25zdCBMT0FEX1RJTUVfR1JBQ0VfUEVSSU9EX01TID0gMzAgKiAxMDAwO1xuLyoqXG4gKiBIb3cgbG9uZyB0byB3YWl0IGluLWJldHdlZW4gYXR0ZW1wdHMgdG8gZ2V0IHByb2plY3QgbWV0YWRhdGEgZHVyaW5nIHRoZSB0aW1lIHNpbmNlIHRoZSBjdXJyZW50XG4gKiBwcm9jZXNzIHN0YXJ0ZWRcbiAqL1xuY29uc3QgR1JBQ0VfUEVSSU9EX1dBSVRfVElNRV9NUyA9IDEgKiAxMDAwO1xuXG4vKipcbiAqIEdldHMgcHJvamVjdCBtZXRhZGF0YSBmcm9tIFBEUEZzIGZpbHRlcmVkIGRvd24gYnkgdmFyaW91cyBmaWx0ZXJpbmcgb3B0aW9uc1xuICpcbiAqIE5vdGU6IElmIHRoZXJlIGFyZSBtdWx0aXBsZSBQRFBzIGF2YWlsYWJsZSB3aG9zZSBtZXRhZGF0YSBtYXRjaGVzIHRoZSBjb25kaXRpb25zIHByb3ZpZGVkIGJ5IHRoZVxuICogcGFyYW1ldGVycywgdGhlaXIgcHJvamVjdCBtZXRhZGF0YSB3aWxsIGFsbCBiZSBjb21iaW5lZCwgc28gYWxsIGF2YWlsYWJsZSBgcHJvamVjdEludGVyZmFjZWBzXG4gKiBwcm92aWRlZCBieSB0aGUgUERQIEZhY3Rvcnkgd2l0aCB0aGUgbWF0Y2hpbmcgaWQgKG9yIGFsbCBQRFAgRmFjdG9yaWVzIGlmIG5vIGlkIGlzIHNwZWNpZmllZCkgZm9yXG4gKiB0aGUgcHJvamVjdCB3aWxsIGJlIHJldHVybmVkLiBJZiB5b3UgbmVlZCBgcHJvamVjdEludGVyZmFjZWBzIHN1cHBvcnRlZCBieSBzcGVjaWZpYyBQRFBcbiAqIEZhY3RvcmllcywgeW91IGNhbiBhY2Nlc3MgaXQgYXQge0BsaW5rIFByb2plY3RNZXRhZGF0YS5wZHBGYWN0b3J5SW5mb30uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGludGVybmFsR2V0TWV0YWRhdGEoXG4gIG9wdGlvbnM6IFByb2plY3RNZXRhZGF0YUZpbHRlck9wdGlvbnMgPSB7fSxcbik6IFByb21pc2U8UHJvamVjdE1ldGFkYXRhW10+IHtcbiAgY29uc3Qge1xuICAgIGV4Y2x1ZGVQcm9qZWN0SWRzLFxuICAgIGluY2x1ZGVQcm9qZWN0SWRzLFxuICAgIGluY2x1ZGVQcm9qZWN0SW50ZXJmYWNlcyxcbiAgICBleGNsdWRlUHJvamVjdEludGVyZmFjZXMsXG4gICAgaW5jbHVkZVBkcEZhY3RvcnlJZHMsXG4gICAgZXhjbHVkZVBkcEZhY3RvcnlJZHMsXG4gIH0gPSBlbnN1cmVQb3B1bGF0ZWRNZXRhZGF0YUZpbHRlcihvcHRpb25zKTtcblxuICAvLyBHZXQgYWxsIHJlZ2lzdGVyZWQgUERQIGZhY3RvcmllcyBhbmQgZmlsdGVyIGRvd24gdG8ganVzdCB0aGUgaW5jbHVkZWQgb25lc1xuICBjb25zdCBuZXR3b3JrT2JqZWN0cyA9IGF3YWl0IG5ldHdvcmtPYmplY3RTdGF0dXNTZXJ2aWNlLmdldEFsbE5ldHdvcmtPYmplY3REZXRhaWxzKCk7XG4gIGNvbnN0IHBkcEZhY3RvcnlJZHMgPSBPYmplY3Qua2V5cyhuZXR3b3JrT2JqZWN0cylcbiAgICAuZmlsdGVyKChwZHBmTmV0d29ya09iamVjdE5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSBuZXR3b3JrT2JqZWN0c1twZHBmTmV0d29ya09iamVjdE5hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICBkZXRhaWxzLm9iamVjdFR5cGUgPT09IFBEUF9GQUNUT1JZX09CSkVDVF9UWVBFICYmXG4gICAgICAgIC8vIElmIGEgcGRwIGZhY3RvcnkgaWQgd2FzIHNwZWNpZmllZCwgb25seSBnZXQgbWV0YWRhdGEgZnJvbSB0aGF0IHBkcCBmYWN0b3J5IGlkLlxuICAgICAgICAvLyBUaGlzIG1lYW5zIHRoZSBQcm9qZWN0TWV0YWRhdGEgY291bGQgYmUgcGFydGlhbCBpbiBzb21lIHNlbnNlIGJlY2F1c2Ugbm90IGFsbCBwcm9qZWN0SW50ZXJmYWNlc1xuICAgICAgICAvLyBhdmFpbGFibGUgZm9yIHRoYXQgcHJvamVjdCB3aWxsIGJlIGluIHRoZSBQcm9qZWN0TWV0YWRhdGFcbiAgICAgICAgYXJlUGRwRmFjdG9yeUlkc0luY2x1ZGVkKFxuICAgICAgICAgIFtnZXRQRFBGYWN0b3J5SWRGcm9tTmV0d29ya09iamVjdE5hbWUocGRwZk5ldHdvcmtPYmplY3ROYW1lKV0sXG4gICAgICAgICAgaW5jbHVkZVBkcEZhY3RvcnlJZHMsXG4gICAgICAgICAgZXhjbHVkZVBkcEZhY3RvcnlJZHMsXG4gICAgICAgIClcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSlcbiAgICAubWFwKGdldFBEUEZhY3RvcnlJZEZyb21OZXR3b3JrT2JqZWN0TmFtZSk7XG5cbiAgLy8gRm9yIGVhY2ggUERQIGZhY3RvcnksIGdldCBhbGwgYXZhaWxhYmxlIHByb2plY3RzXG4gIGNvbnN0IGFsbFByb2plY3RzTWV0YWRhdGEgPSBuZXcgTWFwPHN0cmluZywgUHJvamVjdE1ldGFkYXRhPigpO1xuICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBwZHBGYWN0b3J5SWRzLm1hcChhc3luYyAocGRwRmFjdG9yeUlkKSA9PiB7XG4gICAgICBjb25zdCBwZHBGYWN0b3J5ID0gYXdhaXQgbmV0d29ya09iamVjdFNlcnZpY2UuZ2V0PElQcm9qZWN0RGF0YVByb3ZpZGVyRmFjdG9yeT4oXG4gICAgICAgIGdldFBEUEZhY3RvcnlOZXR3b3JrT2JqZWN0TmFtZUZyb21JZChwZHBGYWN0b3J5SWQpLFxuICAgICAgKTtcbiAgICAgIC8vIEdldCBhbGwgcHJvamVjdHMgZnJvbSB0aGUgUERQIGZhY3RvcnksIGFuZCBwYXNzIGluIHRoZSBpbmNsdWRlL2V4Y2x1ZGUgUERQIGZhY3RvcnkgaWRzIHRvXG4gICAgICAvLyBtYWtlIHN1cmUgdHdvIGxheWVyaW5nIFBEUEZzIGRvbid0IGdldCBpbnRvIGFuIGluZmluaXRlIGxvb3AgdG9nZXRoZXIuIEVhY2ggbGF5ZXJpbmcgUERQXG4gICAgICAvLyBmYWN0b3J5IHNob3VsZCBjYWxsIGFsbCBvdGhlciBwZHAgZmFjdG9yaWVzIG1hdGNoaW5nIHRoaXMgZmlsdGVyIG1lcmdlZCB3aXRoIGl0cyBvd25cbiAgICAgIC8vIGZpbHRlci4gV2UgbmVlZCB0byBwYXNzIHRoZXNlIGJ1dCBub3QgdGhlIG90aGVyIGZpbHRlciBwcm9wZXJ0aWVzIGJlY2F1c2Ugd2UgY2FuIGZpbHRlciB0aGVcbiAgICAgIC8vIG90aGVyIHByb3BlcnRpZXMgbGF0ZXIgaW4gdGhpcyBmdW5jdGlvbiAoYW5kIGRvaW5nIHNvIGdpdmVzIHVzIHRoZSBmdWxsIG1ldGFkYXRhIGZvciBlYWNoXG4gICAgICAvLyBwcm9qZWN0KSwgYnV0IHdlIGNhbm5vdCBmaWx0ZXIgdGhlc2UgcHJvcGVydGllcyBmb3IgYW55IGxheWVyaW5nIFBEUCBmYWN0b3J5IHdlJ3JlIGNhbGxpbmdcbiAgICAgIGNvbnN0IHByb2plY3RzTWV0YWRhdGEgPSBhd2FpdCBwZHBGYWN0b3J5Py5nZXRBdmFpbGFibGVQcm9qZWN0cyh7XG4gICAgICAgIGluY2x1ZGVQZHBGYWN0b3J5SWRzOiBvcHRpb25zLmluY2x1ZGVQZHBGYWN0b3J5SWRzLFxuICAgICAgICAvLyBBZGQgdGhpcyBwZHAgZmFjdG9yeSBpZCBvbnRvIHRoZSBleGNsdWRlZCBQRFAgZmFjdG9yeSBJRHMgdG8gYmUgc3VyZSB0aGUgTGF5ZXJpbmcgUERQRlxuICAgICAgICAvLyBkb2Vzbid0IGdldCBpbnRvIGFuIGluZmluaXRlIGxvb3Agd2l0aCBpdHNlbGYuIFRoZW4gaXQgc2hvdWxkIHBhc3MgdGhlc2UgYmFjayBpbnRvIHRoaXNcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gcGFzcyB0byBvdGhlciBsYXllcmluZyBQRFBGcyBzbyB0aGV5IGRvbid0IGNhbGwgZWFjaCBvdGhlciBpbmZpbml0ZWx5XG4gICAgICAgIGV4Y2x1ZGVQZHBGYWN0b3J5SWRzOiBbXG4gICAgICAgICAgLi4uZW5zdXJlQXJyYXkob3B0aW9ucy5leGNsdWRlUGRwRmFjdG9yeUlkcyksXG4gICAgICAgICAgZXNjYXBlU3RyaW5nUmVnZXhwKHBkcEZhY3RvcnlJZCksXG4gICAgICAgIF0sXG4gICAgICB9KTtcbiAgICAgIGlmIChwcm9qZWN0c01ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFByb2plY3RzTWV0YWRhdGEgPSBkZWVwQ2xvbmUocHJvamVjdHNNZXRhZGF0YSk7XG4gICAgICAgIGNsb25lZFByb2plY3RzTWV0YWRhdGEuZm9yRWFjaCgobWQpID0+IHtcbiAgICAgICAgICAvLyBUaGUgbWV0YWRhdGEgdGhhdCBjb21lcyBpbiBmcm9tIFBEUHMgY291bGQgaGF2ZSBleHRyYSBwZHBGYWN0b3J5SW5mbyBvbiBpdCwgYnV0IHdlXG4gICAgICAgICAgLy8gd2FudCB0byBidWlsZCBpdCBvdXJzZWx2ZXMuIFNvIHdlIHdhbnQgdG8gZGVsZXRlIGl0IHdoZW4gaXQgY29tZXMgaW5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICBkZWxldGUgKG1kIGFzIFByb2plY3RNZXRhZGF0YVdpdGhvdXRGYWN0b3J5SW5mbyAmIFBhcnRpYWw8UHJvamVjdE1ldGFkYXRhPilcbiAgICAgICAgICAgIC5wZHBGYWN0b3J5SW5mbztcblxuICAgICAgICAgIC8vIFR5cGUgYXNzZXJ0IHRvIGFkZCB0aGUgZmFjdG9yeSBpbmZvIHRvIHRoZSBvYmplY3RcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICBjb25zdCBlbnJpY2hlZE1kID0gYWxsUHJvamVjdHNNZXRhZGF0YS5nZXQobWQuaWQpID8/IChtZCBhcyBQcm9qZWN0TWV0YWRhdGEpO1xuICAgICAgICAgIGlmICghZW5yaWNoZWRNZC5wZHBGYWN0b3J5SW5mbykgZW5yaWNoZWRNZC5wZHBGYWN0b3J5SW5mbyA9IHt9O1xuXG4gICAgICAgICAgaWYgKHBkcEZhY3RvcnlJZCBpbiBlbnJpY2hlZE1kLnBkcEZhY3RvcnlJbmZvKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgYFByb2plY3QgJHttZC5pZH0gYWxyZWFkeSBoYXMgbWV0YWRhdGEgZnJvbSBwZHAgZmFjdG9yeSAke3BkcEZhY3RvcnlJZH0uIFNraXBwaW5nIGFkZGl0aW9uYWwgbWV0YWRhdGE6ICR7SlNPTi5zdHJpbmdpZnkobWQpfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZpbHRlciBvdXQgbWV0YWRhdGEgd2l0aCB0aGUgd3JvbmcgcHJvamVjdCBpZFxuICAgICAgICAgIGlmICghaXNQcm9qZWN0SWRJbmNsdWRlZChtZC5pZCwgaW5jbHVkZVByb2plY3RJZHMsIGV4Y2x1ZGVQcm9qZWN0SWRzKSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gV2FpdCB0byBmaWx0ZXIgbWV0YWRhdGEgYnkgYHByb2plY3RJbnRlcmZhY2VgIGJlY2F1c2Ugd2Ugd2FudCB0byByZXR1cm4gUHJvamVjdE1ldGFkYXRhXG4gICAgICAgICAgLy8gZm9yIGEgcHJvamVjdCBpbmNsdWRpbmcgYWxsIGF2YWlsYWJsZSBgcHJvamVjdEludGVyZmFjZWBzLCBub3QganVzdCBgcHJvamVjdEludGVyZmFjZWBzXG4gICAgICAgICAgLy8gcHJvdmlkZWQgYnkgUERQRnMgdGhhdCBwcm92aWRlIHRoYXQgYHByb2plY3RJbnRlcmZhY2VgXG5cbiAgICAgICAgICAvLyBUaGlzIHByb2plY3QgbWV0YWRhdGEgcGFzc2VzIHByb2plY3QgaWQgYW5kIHBkcGYgaWQhIE1lcmdlIGl0IGludG8gdGhlIGV4aXN0aW5nIG1ldGFkYXRhXG4gICAgICAgICAgLy8gUHV0IHRoZSBmYWN0b3J5IGluZm8gb25cbiAgICAgICAgICBlbnJpY2hlZE1kLnBkcEZhY3RvcnlJbmZvW3BkcEZhY3RvcnlJZF0gPSB7XG4gICAgICAgICAgICBwcm9qZWN0SW50ZXJmYWNlczogWy4uLm1kLnByb2plY3RJbnRlcmZhY2VzXSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG1ldGFkYXRhIGFscmVhZHkgaW4gdGhlIG1hcCwgYWRkIHRoZSBuZXcgYHByb2plY3RJbnRlcmZhY2Vgc1xuICAgICAgICAgIGlmIChhbGxQcm9qZWN0c01ldGFkYXRhLmhhcyhtZC5pZCkpIHtcbiAgICAgICAgICAgIG1kLnByb2plY3RJbnRlcmZhY2VzLmZvckVhY2goKG5ld1Byb2plY3RJbnRlcmZhY2UpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFlbnJpY2hlZE1kLnByb2plY3RJbnRlcmZhY2VzLmluY2x1ZGVzKG5ld1Byb2plY3RJbnRlcmZhY2UpKVxuICAgICAgICAgICAgICAgIGVucmljaGVkTWQucHJvamVjdEludGVyZmFjZXMucHVzaChuZXdQcm9qZWN0SW50ZXJmYWNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBhbGxQcm9qZWN0c01ldGFkYXRhLnNldChtZC5pZCwgZW5yaWNoZWRNZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLFxuICApO1xuXG4gIGxldCBhbGxQcm9qZWN0c01ldGFkYXRhQXJyYXkgPSBBcnJheS5mcm9tKGFsbFByb2plY3RzTWV0YWRhdGEudmFsdWVzKCkpO1xuXG4gIC8vIEZpbHRlciBvdXQgbWV0YWRhdGEgd2l0aG91dCB0aGUgcmlnaHQgYHByb2plY3RJbnRlcmZhY2VgXG4gIGlmIChpbmNsdWRlUHJvamVjdEludGVyZmFjZXMubGVuZ3RoID4gMCB8fCBleGNsdWRlUHJvamVjdEludGVyZmFjZXMubGVuZ3RoID4gMCkge1xuICAgIGFsbFByb2plY3RzTWV0YWRhdGFBcnJheSA9IGFsbFByb2plY3RzTWV0YWRhdGFBcnJheS5maWx0ZXIoKHByb2plY3RNZXRhZGF0YSkgPT5cbiAgICAgIGFyZVByb2plY3RJbnRlcmZhY2VzSW5jbHVkZWQoXG4gICAgICAgIHByb2plY3RNZXRhZGF0YS5wcm9qZWN0SW50ZXJmYWNlcyxcbiAgICAgICAgaW5jbHVkZVByb2plY3RJbnRlcmZhY2VzLFxuICAgICAgICBleGNsdWRlUHJvamVjdEludGVyZmFjZXMsXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gYWxsUHJvamVjdHNNZXRhZGF0YUFycmF5O1xufVxuXG4vKipcbiAqIEdldHMgcHJvamVjdCBtZXRhZGF0YSBmcm9tIFBEUEZzIGZpbHRlcmVkIGRvd24gYnkgdmFyaW91cyBmaWx0ZXJpbmcgb3B0aW9ucy4gSWYgdGhpcyBwcm9jZXNzXG4gKiBzdGFydGVkIHJlY2VudGx5IGFuZCB0aGlzIGZpbmRzIG5vIHByb2plY3QgbWV0YWRhdGEsIHdhaXRzIGEgYml0IGFuZCB0cmllcyBhZ2FpbiBiZWNhdXNlIGl0IG1heVxuICogYmUgdGhhdCBub3QgYWxsIFBEUEZzIGhhdmUgc3RhcnRlZCB5ZXQuXG4gKlxuICogTm90ZTogSWYgdGhlcmUgYXJlIG11bHRpcGxlIFBEUHMgYXZhaWxhYmxlIHdob3NlIG1ldGFkYXRhIG1hdGNoZXMgdGhlIGNvbmRpdGlvbnMgcHJvdmlkZWQgYnkgdGhlXG4gKiBwYXJhbWV0ZXJzLCB0aGVpciBwcm9qZWN0IG1ldGFkYXRhIHdpbGwgYWxsIGJlIGNvbWJpbmVkLCBzbyBhbGwgYXZhaWxhYmxlIGBwcm9qZWN0SW50ZXJmYWNlYHNcbiAqIHByb3ZpZGVkIGJ5IHRoZSBQRFAgRmFjdG9yeSB3aXRoIHRoZSBtYXRjaGluZyBpZCAob3IgYWxsIFBEUCBGYWN0b3JpZXMgaWYgbm8gaWQgaXMgc3BlY2lmaWVkKSBmb3JcbiAqIHRoZSBwcm9qZWN0IHdpbGwgYmUgcmV0dXJuZWQuIElmIHlvdSBuZWVkIGBwcm9qZWN0SW50ZXJmYWNlYHMgc3VwcG9ydGVkIGJ5IHNwZWNpZmljIFBEUFxuICogRmFjdG9yaWVzLCB5b3UgY2FuIGFjY2VzcyBpdCBhdCB7QGxpbmsgUHJvamVjdE1ldGFkYXRhLnBkcEZhY3RvcnlJbmZvfS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW50ZXJuYWxHZXRNZXRhZGF0YVdpdGhSZXRyaWVzKFxuICBvcHRpb25zOiBQcm9qZWN0TWV0YWRhdGFGaWx0ZXJPcHRpb25zID0ge30sXG4pOiBQcm9taXNlPFByb2plY3RNZXRhZGF0YVtdPiB7XG4gIGxldCBhbGxQcm9qZWN0c01ldGFkYXRhQXJyYXk6IFByb2plY3RNZXRhZGF0YVtdID0gYXdhaXQgaW50ZXJuYWxHZXRNZXRhZGF0YShvcHRpb25zKTtcblxuICAvLyBJZiB3ZSdyZSBpbiB0aGUgZmlyc3QgbGl0dGxlIHdoaWxlIG9mIHRoZSBwcm9jZXNzLCB0aGVyZSdzIGEgY2hhbmNlIG5vdCBhbGwgdGhlIFBEUEZzIGhhdmVcbiAgLy8gbG9hZGVkLiBMZXQncyB3YWl0IGEgYml0IGFuZCB0cnkgYWdhaW4gaWYgd2UgZ290IG5vIG1hdGNoaW5nIHByb2plY3QgbWV0YWRhdGFcbiAgbGV0IHJldHJ5VGltZXMgPSAwO1xuICB3aGlsZSAoYWxsUHJvamVjdHNNZXRhZGF0YUFycmF5Lmxlbmd0aCA9PT0gMCAmJiBwZXJmb3JtYW5jZS5ub3coKSA8IExPQURfVElNRV9HUkFDRV9QRVJJT0RfTVMpIHtcbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgRGlkIG5vdCBmaW5kIGFueSBwcm9qZWN0IG1ldGFkYXRhIGFyb3VuZCAke3BlcmZvcm1hbmNlLm5vdygpfSBmb3IgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zKX0uIFdpbGwgcmV0cnlgLFxuICAgICk7XG4gICAgLy8gSW50ZW50aW9uYWxseSBzdG9wcGluZyB0aGlzIG1ldGhvZCBleGVjdXRpb24gdG8gd2FpdCBzb21lIHRpbWVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgIGF3YWl0IHdhaXQoR1JBQ0VfUEVSSU9EX1dBSVRfVElNRV9NUyk7XG4gICAgLy8gSW50ZW50aW9uYWxseSBzdG9wcGluZyB0aGlzIG1ldGhvZCBleGVjdXRpb24gdG8gdHJ5IGdldHRpbmcgcHJvamVjdCBtZXRhZGF0YSBhZ2FpblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgYWxsUHJvamVjdHNNZXRhZGF0YUFycmF5ID0gYXdhaXQgaW50ZXJuYWxHZXRNZXRhZGF0YShvcHRpb25zKTtcbiAgICByZXRyeVRpbWVzICs9IDE7XG4gICAgaWYgKGFsbFByb2plY3RzTWV0YWRhdGFBcnJheS5sZW5ndGggPiAwKVxuICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICBgRmluYWxseSBmb3VuZCBwcm9qZWN0IG1ldGFkYXRhIG9uIHJldHJ5ICR7cmV0cnlUaW1lc30gYXJvdW5kICR7cGVyZm9ybWFuY2Uubm93KCl9IGZvciAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMpfSEgJHtKU09OLnN0cmluZ2lmeShhbGxQcm9qZWN0c01ldGFkYXRhQXJyYXkpfWAsXG4gICAgICApO1xuICB9XG4gIGlmIChhbGxQcm9qZWN0c01ldGFkYXRhQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgbG9nZ2VyLndhcm4oXG4gICAgICBgRGlkIG5vdCBmaW5kIGFueSBwcm9qZWN0IG1ldGFkYXRhJHtyZXRyeVRpbWVzID4gMCA/IGAgb24gcmV0cnkgJHtyZXRyeVRpbWVzfWAgOiAnJ30gZm9yICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucyl9IGFmdGVyIHRoZSBncmFjZSBwZXJpb2QuIElmIHlvdSBleHBlY3RlZCB0byBmaW5kIHByb2plY3RzIGZvciB0aGVzZSBmaWx0ZXJzLCB0aGlzIHByb2JhYmx5IGluZGljYXRlcyBhIHByb2JsZW0uIE1heWJlIG5vdCBhbGwgUERQRnMgbG9hZGVkIGluIHRpbWUuYCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGFsbFByb2plY3RzTWV0YWRhdGFBcnJheTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtR2V0TWV0YWRhdGFGb3JQcm9qZWN0UGFyYW1ldGVyc1RvRmlsdGVyKFxuICBwcm9qZWN0SWQ/OiBzdHJpbmcsXG4gIHByb2plY3RJbnRlcmZhY2U/OiBQcm9qZWN0SW50ZXJmYWNlcyxcbiAgcGRwRmFjdG9yeUlkPzogc3RyaW5nLFxuKSB7XG4gIC8vIEVzY2FwZSBgcHJvamVjdEludGVyZmFjZWAgYW5kIGBwZHBGYWN0b3J5SWRgIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCByZWdleHAgbWF0Y2hpbmcuIFRoZXNlXG4gIC8vIGZpZWxkcyBzaG91bGQgbWF0Y2ggZXhhY3RseVxuICByZXR1cm4ge1xuICAgIGluY2x1ZGVQcm9qZWN0SWRzOiBwcm9qZWN0SWQsXG4gICAgaW5jbHVkZVByb2plY3RJbnRlcmZhY2VzOiBwcm9qZWN0SW50ZXJmYWNlXG4gICAgICA/IGVzY2FwZVN0cmluZ1JlZ2V4cChwcm9qZWN0SW50ZXJmYWNlKVxuICAgICAgOiBwcm9qZWN0SW50ZXJmYWNlLFxuICAgIGluY2x1ZGVQZHBGYWN0b3J5SWRzOiBwZHBGYWN0b3J5SWQgPyBlc2NhcGVTdHJpbmdSZWdleHAocGRwRmFjdG9yeUlkKSA6IHBkcEZhY3RvcnlJZCxcbiAgfTtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vLyAjcmVnaW9uIFNtYWxsZXIgcHJvamVjdCB1dGlsaXRpZXNcblxuZnVuY3Rpb24gZW5zdXJlUG9wdWxhdGVkTWV0YWRhdGFGaWx0ZXIob3B0aW9uczogUHJvamVjdE1ldGFkYXRhRmlsdGVyT3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgZXhjbHVkZVByb2plY3RJZHMsXG4gICAgaW5jbHVkZVByb2plY3RJZHMsXG4gICAgaW5jbHVkZVByb2plY3RJbnRlcmZhY2VzLFxuICAgIGV4Y2x1ZGVQcm9qZWN0SW50ZXJmYWNlcyxcbiAgICBpbmNsdWRlUGRwRmFjdG9yeUlkcyxcbiAgICBleGNsdWRlUGRwRmFjdG9yeUlkcyxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgLy8gR2V0IGFycmF5IG9mIGV4Y2x1ZGVQcm9qZWN0SWRzXG4gIGNvbnN0IGV4Y2x1ZGVQcm9qZWN0SWRzQXJyYXkgPSBlbnN1cmVBcnJheShleGNsdWRlUHJvamVjdElkcyk7XG5cbiAgLy8gR2V0IGFycmF5IG9mIGluY2x1ZGVQcm9qZWN0SWRzXG4gIGNvbnN0IGluY2x1ZGVQcm9qZWN0SWRzQXJyYXkgPSBlbnN1cmVBcnJheShpbmNsdWRlUHJvamVjdElkcyk7XG5cbiAgLy8gR2V0IGFycmF5IG9mIGV4Y2x1ZGVQcm9qZWN0SW50ZXJmYWNlcyBSZWdFeHBzXG4gIGNvbnN0IGV4Y2x1ZGVQcm9qZWN0SW50ZXJmYWNlc1JlZ0V4cHMgPVxuICAgIHRyYW5zZm9ybUFuZEVuc3VyZVJlZ0V4cFJlZ0V4cEFycmF5KGV4Y2x1ZGVQcm9qZWN0SW50ZXJmYWNlcyk7XG5cbiAgLy8gR2V0IGFycmF5IG9mIGluY2x1ZGVQcm9qZWN0SW50ZXJmYWNlcyBSZWdFeHBzXG4gIGNvbnN0IGluY2x1ZGVQcm9qZWN0SW50ZXJmYWNlc1JlZ0V4cHMgPVxuICAgIHRyYW5zZm9ybUFuZEVuc3VyZVJlZ0V4cFJlZ0V4cEFycmF5KGluY2x1ZGVQcm9qZWN0SW50ZXJmYWNlcyk7XG5cbiAgLy8gR2V0IGFycmF5IG9mIGluY2x1ZGVQZHBGYWN0b3J5SWRzIFJlZ0V4cHNcbiAgY29uc3QgaW5jbHVkZVBkcEZhY3RvcnlJZHNSZWdFeHBzID0gdHJhbnNmb3JtQW5kRW5zdXJlUmVnRXhwQXJyYXkoaW5jbHVkZVBkcEZhY3RvcnlJZHMpO1xuXG4gIC8vIEdldCBhcnJheSBvZiBleGNsdWRlUGRwRmFjdG9yeUlkcyBSZWdFeHBzXG4gIGNvbnN0IGV4Y2x1ZGVQZHBGYWN0b3J5SWRzUmVnRXhwcyA9IHRyYW5zZm9ybUFuZEVuc3VyZVJlZ0V4cEFycmF5KGV4Y2x1ZGVQZHBGYWN0b3J5SWRzKTtcblxuICByZXR1cm4ge1xuICAgIGV4Y2x1ZGVQcm9qZWN0SWRzOiBleGNsdWRlUHJvamVjdElkc0FycmF5LFxuICAgIGluY2x1ZGVQcm9qZWN0SWRzOiBpbmNsdWRlUHJvamVjdElkc0FycmF5LFxuICAgIGluY2x1ZGVQcm9qZWN0SW50ZXJmYWNlczogaW5jbHVkZVByb2plY3RJbnRlcmZhY2VzUmVnRXhwcyxcbiAgICBleGNsdWRlUHJvamVjdEludGVyZmFjZXM6IGV4Y2x1ZGVQcm9qZWN0SW50ZXJmYWNlc1JlZ0V4cHMsXG4gICAgaW5jbHVkZVBkcEZhY3RvcnlJZHM6IGluY2x1ZGVQZHBGYWN0b3J5SWRzUmVnRXhwcyxcbiAgICBleGNsdWRlUGRwRmFjdG9yeUlkczogZXhjbHVkZVBkcEZhY3RvcnlJZHNSZWdFeHBzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBhcmVQcm9qZWN0SWRzRXF1YWwocHJvamVjdElkQTogc3RyaW5nLCBwcm9qZWN0SWRCOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHByb2plY3RJZEEubG9jYWxlQ29tcGFyZShwcm9qZWN0SWRCLCB1bmRlZmluZWQsIHsgc2Vuc2l0aXZpdHk6ICdhY2NlbnQnIH0pID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc1Byb2plY3RJZEluY2x1ZGVkKFxuICBwcm9qZWN0SWQ6IHN0cmluZyxcbiAgaW5jbHVkZVByb2plY3RJZHM6IHN0cmluZ1tdLFxuICBleGNsdWRlUHJvamVjdElkczogc3RyaW5nW10sXG4pIHtcbiAgLy8gSWYgdGhlIHByb2plY3QgSUQgaXMgZXhjbHVkZWQsIGl0J3Mgb3V0XG4gIGlmIChcbiAgICBleGNsdWRlUHJvamVjdElkcy5sZW5ndGggPiAwICYmXG4gICAgZXhjbHVkZVByb2plY3RJZHMuc29tZSgoZXhjbHVkZVByb2plY3RJZCkgPT4gYXJlUHJvamVjdElkc0VxdWFsKGV4Y2x1ZGVQcm9qZWN0SWQsIHByb2plY3RJZCkpXG4gIClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlIHByb2plY3QgSUQgaXMgbm90IGluY2x1ZGVkLCBpdCdzIG91dFxuICBpZiAoXG4gICAgaW5jbHVkZVByb2plY3RJZHMubGVuZ3RoID4gMCAmJlxuICAgICFpbmNsdWRlUHJvamVjdElkcy5zb21lKChpbmNsdWRlUHJvamVjdElkKSA9PiBhcmVQcm9qZWN0SWRzRXF1YWwoaW5jbHVkZVByb2plY3RJZCwgcHJvamVjdElkKSlcbiAgKVxuICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHByb2plY3QgaW50ZXJmYWNlcyBhcmUgaW5jbHVkZWQgYmFzZWQgb24gc3BlY2lmaWVkIGluY2x1c2lvbiBhbmRcbiAqIGV4Y2x1c2lvbiBydWxlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiBhIHNldCBvZiBwcm9qZWN0IGludGVyZmFjZXMgbWVldHMgdGhlIGNyaXRlcmlhIGRlZmluZWQgYnkgcmVndWxhclxuICogZXhwcmVzc2lvbnMgZm9yIGluY2x1c2lvbiBhbmQgZXhjbHVzaW9uLlxuICpcbiAqIC0gQSBwcm9qZWN0IGludGVyZmFjZSBpcyBleGNsdWRlZCBpZiBpdCBtYXRjaGVzIGFueSBvZiB0aGUgcHJvdmlkZWQgZXhjbHVzaW9uIHBhdHRlcm5zLlxuICogLSBBIHByb2plY3QgaW50ZXJmYWNlIGlzIGluY2x1ZGVkIG9ubHkgaWYgaXQgbWF0Y2hlcyBhdCBsZWFzdCBvbmUgb2YgdGhlIHByb3ZpZGVkIGluY2x1c2lvblxuICogICBwYXR0ZXJucy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdEludGVyZmFjZXMgLSBBbiBhcnJheSBvZiBwcm9qZWN0IGludGVyZmFjZXMgdG8gZXZhbHVhdGUgYWdhaW5zdCB0aGUgaW5jbHVzaW9uIGFuZFxuICogICBleGNsdXNpb24gcGF0dGVybnMuXG4gKiBAcGFyYW0gaW5jbHVkZVByb2plY3RJbnRlcmZhY2VzIC0gQW4gYXJyYXkgb2YgcmVndWxhciBleHByZXNzaW9ucyBvciBhcnJheXMgb2YgcmVndWxhclxuICogICBleHByZXNzaW9ucyBkZWZpbmluZyB3aGljaCBpbnRlcmZhY2VzIHNob3VsZCBiZSBpbmNsdWRlZC5cbiAqIEBwYXJhbSBleGNsdWRlUHJvamVjdEludGVyZmFjZXMgLSBBbiBhcnJheSBvZiByZWd1bGFyIGV4cHJlc3Npb25zIG9yIGFycmF5cyBvZiByZWd1bGFyXG4gKiAgIGV4cHJlc3Npb25zIGRlZmluaW5nIHdoaWNoIGludGVyZmFjZXMgc2hvdWxkIGJlIGV4Y2x1ZGVkLlxuICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgcHJvamVjdCBpbnRlcmZhY2VzIHNhdGlzZnkgdGhlIGluY2x1c2lvbiBhbmRcbiAqICAgZXhjbHVzaW9uIGNyaXRlcmlhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJlUHJvamVjdEludGVyZmFjZXNJbmNsdWRlZChcbiAgcHJvamVjdEludGVyZmFjZXM6IFByb2plY3RJbnRlcmZhY2VzW10sXG4gIGluY2x1ZGVQcm9qZWN0SW50ZXJmYWNlczogKFJlZ0V4cCB8IFJlZ0V4cFtdKVtdLFxuICBleGNsdWRlUHJvamVjdEludGVyZmFjZXM6IChSZWdFeHAgfCBSZWdFeHBbXSlbXSxcbikge1xuICAvLyBJZiB0aGUgcHJvamVjdCBpbnRlcmZhY2UgaXMgZXhjbHVkZWQsIGl0J3Mgb3V0XG4gIGlmIChcbiAgICBleGNsdWRlUHJvamVjdEludGVyZmFjZXMubGVuZ3RoID4gMCAmJlxuICAgIGV4Y2x1ZGVQcm9qZWN0SW50ZXJmYWNlcy5zb21lKChleGNsdWRlUmVnRXhwKSA9PlxuICAgICAgQXJyYXkuaXNBcnJheShleGNsdWRlUmVnRXhwKVxuICAgICAgICA/IGV4Y2x1ZGVSZWdFeHAuZXZlcnkoKHN1YkV4Y2x1ZGVSZWdFeHApID0+XG4gICAgICAgICAgICBwcm9qZWN0SW50ZXJmYWNlcy5zb21lKChwcm9qZWN0SW50ZXJmYWNlKSA9PiBzdWJFeGNsdWRlUmVnRXhwLnRlc3QocHJvamVjdEludGVyZmFjZSkpLFxuICAgICAgICAgIClcbiAgICAgICAgOiBwcm9qZWN0SW50ZXJmYWNlcy5zb21lKChwcm9qZWN0SW50ZXJmYWNlKSA9PiBleGNsdWRlUmVnRXhwLnRlc3QocHJvamVjdEludGVyZmFjZSkpLFxuICAgIClcbiAgKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGUgcHJvamVjdCBpbnRlcmZhY2UgaXNuJ3QgaW5jbHVkZWQsIGl0J3Mgb3V0XG4gIGlmIChcbiAgICBpbmNsdWRlUHJvamVjdEludGVyZmFjZXMubGVuZ3RoID4gMCAmJlxuICAgICFpbmNsdWRlUHJvamVjdEludGVyZmFjZXMuc29tZSgoaW5jbHVkZVJlZ0V4cCkgPT5cbiAgICAgIEFycmF5LmlzQXJyYXkoaW5jbHVkZVJlZ0V4cClcbiAgICAgICAgPyBpbmNsdWRlUmVnRXhwLmV2ZXJ5KChzdWJJbmNsdWRlUmVnRXhwKSA9PlxuICAgICAgICAgICAgcHJvamVjdEludGVyZmFjZXMuc29tZSgocHJvamVjdEludGVyZmFjZSkgPT4gc3ViSW5jbHVkZVJlZ0V4cC50ZXN0KHByb2plY3RJbnRlcmZhY2UpKSxcbiAgICAgICAgICApXG4gICAgICAgIDogcHJvamVjdEludGVyZmFjZXMuc29tZSgocHJvamVjdEludGVyZmFjZSkgPT4gaW5jbHVkZVJlZ0V4cC50ZXN0KHByb2plY3RJbnRlcmZhY2UpKSxcbiAgICApXG4gIClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKiBBbGwgd29ya3Mgd2l0aCB0aGUgd2VsbC1rbm93biBQRFAgZmFjdG9yeSBpZHMsIG5vdCB0aGUgbmV0d29yayBvYmplY3QgbmFtZXMgKi9cbmZ1bmN0aW9uIGFyZVBkcEZhY3RvcnlJZHNJbmNsdWRlZChcbiAgcGRwRmFjdG9yeUlkczogc3RyaW5nW10sXG4gIGluY2x1ZGVQZHBGYWN0b3J5SWRzOiBSZWdFeHBbXSxcbiAgZXhjbHVkZVBkcEZhY3RvcnlJZHM6IFJlZ0V4cFtdLFxuKSB7XG4gIC8vIElmIGFueSBvZiB0aGUgUERQIEZhY3RvcnkgSWQgYXJlIGV4Y2x1ZGVkLCBpdCdzIG91dFxuICBpZiAoXG4gICAgZXhjbHVkZVBkcEZhY3RvcnlJZHMubGVuZ3RoID4gMCAmJlxuICAgIGV4Y2x1ZGVQZHBGYWN0b3J5SWRzLnNvbWUoKGV4Y2x1ZGVSZWdFeHApID0+XG4gICAgICBwZHBGYWN0b3J5SWRzLnNvbWUoKHBkcEZhY3RvcnlJZCkgPT4gZXhjbHVkZVJlZ0V4cC50ZXN0KHBkcEZhY3RvcnlJZCkpLFxuICAgIClcbiAgKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBub25lIG9mIHRoZSBQRFAgRmFjdG9yeSBJZHMgYXJlIGluY2x1ZGVkLCBpdCdzIG91dFxuICBpZiAoXG4gICAgaW5jbHVkZVBkcEZhY3RvcnlJZHMubGVuZ3RoID4gMCAmJlxuICAgIChwZHBGYWN0b3J5SWRzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgIWluY2x1ZGVQZHBGYWN0b3J5SWRzLnNvbWUoKGluY2x1ZGVSZWdFeHApID0+XG4gICAgICAgIHBkcEZhY3RvcnlJZHMuc29tZSgocGRwRmFjdG9yeUlkKSA9PiBpbmNsdWRlUmVnRXhwLnRlc3QocGRwRmFjdG9yeUlkKSksXG4gICAgICApKVxuICApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmUgZnVuY3Rpb24gKGZvciBhcnJheSBzb3J0aW5nIGFuZCBzdWNoKSB0aGF0IGNvbXBhcmVzIHR3byBQRFBGIE1ldGFkYXRhIGluZm9zIGJ5IG1vc3RcbiAqIG1pbmltYWwgbWF0Y2ggdG8gdGhlIGBwcm9qZWN0SW50ZXJmYWNlYCBpbiBxdWVzdGlvbi5cbiAqXG4gKiBIb3BlZnVsbHkgdGhpcyB3aWxsIGFsbG93IHVzIHRvIGdldCB0aGUgUERQIHRoYXQgbW9zdCBjbG9zZWx5IG1hdGNoZXMgdGhlIGBwcm9qZWN0SW50ZXJmYWNlYHMgdG9cbiAqIGF2b2lkIHVubmVjZXNzYXJ5IHJlZGlyZWN0cyB0aHJvdWdoIGxheWVyZWQgUERQc1xuICpcbiAqIEBwYXJhbSBwZHBGTWV0YWRhdGFJbmZvQSBGaXJzdCBQcm9qZWN0RGF0YVByb3ZpZGVyRmFjdG9yeU1ldGFkYXRhSW5mbyB0byBjb21wYXJlXG4gKiBAcGFyYW0gcGRwRk1ldGFkYXRhSW5mb0IgU2Vjb25kIFByb2plY3REYXRhUHJvdmlkZXJGYWN0b3J5TWV0YWRhdGFJbmZvIHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIC0xIGlmIGEgaXMgbGVzcyB0aGFuIGIsIDAgaWYgZXF1YWwsIGFuZCAxIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBjb21wYXJlUHJvamVjdERhdGFQcm92aWRlckZhY3RvcnlNZXRhZGF0YUluZm9NaW5pbWFsTWF0Y2goXG4gIHBkcEZNZXRhZGF0YUluZm9BOiBQcm9qZWN0RGF0YVByb3ZpZGVyRmFjdG9yeU1ldGFkYXRhSW5mbyB8IHVuZGVmaW5lZCxcbiAgcGRwRk1ldGFkYXRhSW5mb0I6IFByb2plY3REYXRhUHJvdmlkZXJGYWN0b3J5TWV0YWRhdGFJbmZvIHwgdW5kZWZpbmVkLFxuKTogLTEgfCAwIHwgMSB7XG4gIGlmICghcGRwRk1ldGFkYXRhSW5mb0EpIHtcbiAgICBpZiAoIXBkcEZNZXRhZGF0YUluZm9CKSByZXR1cm4gMDtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAoIXBkcEZNZXRhZGF0YUluZm9CKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIC8vIE5vdGU6IHdlIGNvdWxkIGNvbnZlcnQgdGhlc2UgYXJyYXlzIHRvIHNldHMgZmlyc3QgdG8gZW5zdXJlIG5vIGR1cGxpY2F0ZXMgdG8gbWFrZSBzdXJlXG4gIC8vIHRoZXNlIGNvbXBhcmlzb25zIGFyZSBhY2N1cmF0ZSwgYnV0IGxldCdzIGp1c3Qgc2F5IGV4dGVuc2lvbiBkZXZlbG9wZXJzIHNob3VsZCB3cml0ZSB0aGVtXG4gIC8vIHdpdGggbm8gZHVwbGljYXRlcyB1bnRpbCB3ZSBoYXZlIGEgcmVhc29uIHRvIHNheSBzb21ldGhpbmcgZWxzZVxuICBjb25zdCBsZW5ndGhBID0gcGRwRk1ldGFkYXRhSW5mb0EucHJvamVjdEludGVyZmFjZXMubGVuZ3RoO1xuICBjb25zdCBsZW5ndGhCID0gcGRwRk1ldGFkYXRhSW5mb0IucHJvamVjdEludGVyZmFjZXMubGVuZ3RoO1xuXG4gIC8vIElmIG9uZSBvbmx5IGhhcyB0aGUgb3JpZ2luYWwgaW50ZXJmYWNlIG9yIGlzIHNtYWxsZXIgdGhhbiB0aGUgb3RoZXIsIGl0IHNob3VsZCBiZSBmaXJzdFxuICBpZiAobGVuZ3RoQSA9PT0gMSB8fCBsZW5ndGhBIDwgbGVuZ3RoQikgcmV0dXJuIC0xO1xuICBpZiAobGVuZ3RoQiA9PT0gMSB8fCBsZW5ndGhCIDwgbGVuZ3RoQSkgcmV0dXJuIDE7XG4gIC8vIE90aGVyd2lzZSB0aGV5IGFyZSBwcmV0dHkgbXVjaCB0aGUgc2FtZSBhcyBmYXIgYXMgd2UgY2FuIHRlbGxcbiAgcmV0dXJuIDA7XG59XG5cbi8vICNlbmRyZWdpb25cblxuLy8gI3JlZ2lvbiB0ZXN0aW5nXG5cbi8qKiBUaGlzIGlzIGFuIGludGVybmFsLW9ubHkgZXhwb3J0IGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgaW4gZGV2ZWxvcG1lbnQgKi9cbmV4cG9ydCBjb25zdCB0ZXN0aW5nUHJvamVjdExvb2t1cFNlcnZpY2UgPSB7XG4gIGludGVybmFsR2V0TWV0YWRhdGEsXG4gIGNvbXBhcmVQcm9qZWN0RGF0YVByb3ZpZGVyRmFjdG9yeU1ldGFkYXRhSW5mb01pbmltYWxNYXRjaCxcbiAgdHJhbnNmb3JtR2V0TWV0YWRhdGFGb3JQcm9qZWN0UGFyYW1ldGVyc1RvRmlsdGVyLFxuICBMT0FEX1RJTUVfR1JBQ0VfUEVSSU9EX01TLFxufTtcblxuLy8gI2VuZHJlZ2lvblxuIiwiLy8gVXNlZCBpbiBKU0RvY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuaW1wb3J0IHR5cGUgeyBFbGV2YXRlZFByaXZpbGVnZXMgfSBmcm9tICdAc2hhcmVkL21vZGVscy9lbGV2YXRlZC1wcml2aWxlZ2VzLm1vZGVsJztcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgYXBwIHRoYXQgaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gKlxuICogQWxsIG9mIHRoZSBpbmZvcm1hdGlvbiBpbiB0aGlzIG9iamVjdCBpcyBzdGF0aWMgYW5kIGlzIGRldGVybWluZWQgYXQgYnVpbGQgdGltZS4gSXQgd2lsbCBub3RcbiAqIGNoYW5nZSB0aHJvdWdob3V0IHRoZSBsaWZldGltZSBvZiB0aGUgYXBwIG9yIGFjcm9zcyBydW5zIG9mIHRoZSBzYW1lIGJ1aWxkLlxuICovXG4vLyBXQVJOSU5HOiBORVZFUiBQVVQgQU5ZIElORk9STUFUSU9OIElOIFRISVMgT0JKRUNUIFRIQVQgSVMgTk9UIFNUQVRJQ0FMTFkgREVURVJNSU5BQkxFIEFUIEJVSUxEIFRJTUVcbmV4cG9ydCB0eXBlIEFwcEluZm8gPSBSZWFkb25seTx7XG4gIC8qKlxuICAgKiBQcm9ncmFtbWF0aWMgbmFtZSBvZiB0aGUgYXBwbGljYXRpb25cbiAgICpcbiAgICogQGV4YW1wbGUgYHBsYXRmb3JtLWJpYmxlYC5cbiAgICpcbiAgICogTm90ZTogdGhpcyBpcyBhbiBpZGVudGlmaWVyIGZvciB0aGUgYXBwbGljYXRpb24sIG5vdCB0aGlzIGFwcGxpY2F0aW9uJ3MgZXhlY3V0YWJsZSBmaWxlIG5hbWVcbiAgICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFZlcnNpb24gb2YgdGhlIGFwcC4gVGhpcyBpcyBpbiBbc2VtdmVyXShodHRwczovL3NlbXZlci5vcmcvKSBmb3JtYXQuXG4gICAqXG4gICAqIEBleGFtcGxlIGAwLjMuMGBcbiAgICpcbiAgICogQGV4YW1wbGUgYDEuMi4zLW9yZGVyZWQuaW5mby5oZXJlK2FkZGl0aW9uYWwudW5vcmRlcmVkLmluZm8uaGVyZTEyM2BcbiAgICovXG4gIHZlcnNpb246IHN0cmluZztcbiAgLyoqXG4gICAqIFVSSSBzY2hlbWUgdGhhdCB0aGlzIGFwcGxpY2F0aW9uIGhhbmRsZXMuIE5hdmlnYXRpbmcgdG8gYSBVUkkgd2l0aCB0aGlzIHNjaGVtZSB3aWxsIG9wZW4gdGhpc1xuICAgKiBhcHBsaWNhdGlvbi4gVGhpcyBhcHBsaWNhdGlvbiB3aWxsIGhhbmRsZSB0aGUgVVJJIGFzIGl0IHNlZXMgZml0LiBGb3IgZXhhbXBsZSwgdGhlIFVSSSBtYXkgYmVcbiAgICogaGFuZGxlZCBieSBhbiBleHRlbnNpb24gLSBzZWUge0BsaW5rIEVsZXZhdGVkUHJpdmlsZWdlcy5oYW5kbGVVcmkgfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogVGhpcyBpcyB0aGUgc2FtZSBhcyB7QGxpbmsgQXBwSW5mby5uYW1lfS5cbiAgICovXG4gIHVyaVNjaGVtZTogc3RyaW5nO1xufT47XG5cbi8qKiBKU0RPQyBERVNUSU5BVElPTiBhcHBTZXJ2aWNlICovXG5leHBvcnQgaW50ZXJmYWNlIElBcHBTZXJ2aWNlIHtcbiAgLyoqIFJldHJpZXZlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhcHBsaWNhdGlvbiB0aGF0IGlzIGN1cnJlbnRseSBydW5uaW5nIGxpa2UgbmFtZSBhbmQgdmVyc2lvbi4gKi9cbiAgZ2V0QXBwSW5mbygpOiBQcm9taXNlPEFwcEluZm8+O1xufVxuXG5leHBvcnQgY29uc3QgYXBwU2VydmljZU5ldHdvcmtPYmplY3ROYW1lID0gJ0FwcFNlcnZpY2UnO1xuIiwiLyoqXG4gKiBIYW5kbGVzIHJlZ2lzdGVyaW5nLCBzZW5kaW5nLCBhbmQgcmVjZWl2aW5nIGNvbW1hbmRzIHdpdGggdGhlIFBhcmF0ZXh0IGJhY2tlbmQgaW4gYSB1bmlmaWVkXG4gKiBmb3JtYXQuIEV4cG9zZWQgb24gcGFwaVxuICovXG5cbmltcG9ydCAqIGFzIG5ldHdvcmtTZXJ2aWNlIGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbmV0d29yay5zZXJ2aWNlJztcbmltcG9ydCB7IFVuc3Vic2NyaWJlckFzeW5jIH0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuaW1wb3J0IHsgc2VyaWFsaXplUmVxdWVzdFR5cGUgfSBmcm9tICdAc2hhcmVkL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHsgQ29tbWFuZEhhbmRsZXJzLCBDb21tYW5kTmFtZXMgfSBmcm9tICdwYXBpLXNoYXJlZC10eXBlcyc7XG5pbXBvcnQgeyBDQVRFR09SWV9DT01NQU5EIH0gZnJvbSAnQHNoYXJlZC9kYXRhL3JwYy5tb2RlbCc7XG5pbXBvcnQgeyBTaW5nbGVNZXRob2REb2N1bWVudGF0aW9uIH0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvb3BlbnJwYy5tb2RlbCc7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBjb21tYW5kIG9uIHRoZSBwYXBpIHRvIGJlIGhhbmRsZWQgaGVyZVxuICpcbiAqIEBwYXJhbSBjb21tYW5kTmFtZSBDb21tYW5kIG5hbWUgdG8gcmVnaXN0ZXIgZm9yIGhhbmRsaW5nIGhlcmVcbiAqXG4gKiAgIC0gTm90ZTogQ29tbWFuZCBuYW1lcyBtdXN0IGNvbnNpc3Qgb2YgdHdvIHN0cmluZyBzZXBhcmF0ZWQgYnkgYXQgbGVhc3Qgb25lIHBlcmlvZC4gV2UgcmVjb21tZW5kIG9uZVxuICogICAgICAgcGVyaW9kIGFuZCBsb3dlciBjYW1lbCBjYXNlIGluIGNhc2Ugd2UgZXhwYW5kIHRoZSBhcGkgaW4gdGhlIGZ1dHVyZSB0byBhbGxvdyBkb3Qgbm90YXRpb24uXG4gKlxuICogQHBhcmFtIGhhbmRsZXIgRnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIGNvbW1hbmQgaXMgaW52b2tlZFxuICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIGlmIHRoZSBjb21tYW5kIHN1Y2Nlc3NmdWxseSByZWdpc3RlcmVkIGFuZCB1bnN1YnNjcmliZXIgZnVuY3Rpb25cbiAqICAgdG8gcnVuIHRvIHN0b3AgdGhlIHBhc3NlZC1pbiBmdW5jdGlvbiBmcm9tIGhhbmRsaW5nIGNvbW1hbmRzXG4gKi9cbmV4cG9ydCBjb25zdCByZWdpc3RlckNvbW1hbmQgPSA8Q29tbWFuZE5hbWUgZXh0ZW5kcyBDb21tYW5kTmFtZXM+KFxuICBjb21tYW5kTmFtZTogQ29tbWFuZE5hbWUsXG4gIGhhbmRsZXI6IENvbW1hbmRIYW5kbGVyc1tDb21tYW5kTmFtZV0sXG4gIGNvbW1hbmREb2NzPzogU2luZ2xlTWV0aG9kRG9jdW1lbnRhdGlvbixcbik6IFByb21pc2U8VW5zdWJzY3JpYmVyQXN5bmM+ID0+IHtcbiAgcmV0dXJuIG5ldHdvcmtTZXJ2aWNlLnJlZ2lzdGVyUmVxdWVzdEhhbmRsZXIoXG4gICAgc2VyaWFsaXplUmVxdWVzdFR5cGUoQ0FURUdPUllfQ09NTUFORCwgY29tbWFuZE5hbWUpLFxuICAgIGhhbmRsZXIsXG4gICAgY29tbWFuZERvY3MsXG4gICk7XG59O1xuXG4vKiogU2VuZCBhIGNvbW1hbmQgdG8gdGhlIGJhY2tlbmQuICovXG5leHBvcnQgY29uc3Qgc2VuZENvbW1hbmQgPSBhc3luYyA8Q29tbWFuZE5hbWUgZXh0ZW5kcyBDb21tYW5kTmFtZXM+KFxuICBjb21tYW5kTmFtZTogQ29tbWFuZE5hbWUsXG4gIC4uLmFyZ3M6IFBhcmFtZXRlcnM8Q29tbWFuZEhhbmRsZXJzW0NvbW1hbmROYW1lXT5cbik6IFByb21pc2U8QXdhaXRlZDxSZXR1cm5UeXBlPENvbW1hbmRIYW5kbGVyc1tDb21tYW5kTmFtZV0+Pj4gPT4ge1xuICAvLyBUaGlzIHR5cGUgYXNzZXJ0aW9uIGlzIG5lZWRlZCB3aGVuIHRoZSByZXR1cm4gdHlwZSBpcyB1bmtub3duIG9yIHdoZW4gaXQncyBub3QgQXdhaXRlZDwuLi4+LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uLCBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICByZXR1cm4gbmV0d29ya1NlcnZpY2UucmVxdWVzdChcbiAgICBzZXJpYWxpemVSZXF1ZXN0VHlwZShDQVRFR09SWV9DT01NQU5ELCBjb21tYW5kTmFtZSksXG4gICAgLi4uYXJncyxcbiAgKSBhcyBQcm9taXNlPEF3YWl0ZWQ8UmV0dXJuVHlwZTxDb21tYW5kSGFuZGxlcnNbQ29tbWFuZE5hbWVdPj4+O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyBhIGNvbW1hbmQgZnVuY3Rpb24gd2l0aCBhIGJha2VkIGNvbW1hbmROYW1lLiBUaGlzIGlzIGFsc28gbmljZSBiZWNhdXNlXG4gKiB5b3UgZ2V0IFR5cGVTY3JpcHQgdHlwZSBzdXBwb3J0IHVzaW5nIHRoaXMgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGNvbW1hbmROYW1lIENvbW1hbmQgbmFtZSBmb3IgY29tbWFuZCBmdW5jdGlvblxuICogQHJldHVybnMgRnVuY3Rpb24gdG8gY2FsbCB3aXRoIGFyZ3VtZW50cyBvZiBjb21tYW5kIHRoYXQgc2VuZHMgdGhlIGNvbW1hbmQgYW5kIHJlc29sdmVzIHdpdGggdGhlXG4gKiAgIHJlc3VsdCBvZiB0aGUgY29tbWFuZFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlU2VuZENvbW1hbmRGdW5jdGlvbiA9IDxDb21tYW5kTmFtZSBleHRlbmRzIENvbW1hbmROYW1lcz4oXG4gIGNvbW1hbmROYW1lOiBDb21tYW5kTmFtZSxcbikgPT4ge1xuICByZXR1cm4gYXN5bmMgKFxuICAgIC4uLmFyZ3M6IFBhcmFtZXRlcnM8Q29tbWFuZEhhbmRsZXJzW0NvbW1hbmROYW1lXT5cbiAgKTogUHJvbWlzZTxBd2FpdGVkPFJldHVyblR5cGU8Q29tbWFuZEhhbmRsZXJzW0NvbW1hbmROYW1lXT4+PiA9PlxuICAgIHNlbmRDb21tYW5kKGNvbW1hbmROYW1lLCAuLi5hcmdzKTtcbn07XG5cbi8qKlxuICogSlNET0MgU09VUkNFIGNvbW1hbmRTZXJ2aWNlXG4gKlxuICogVGhlIGNvbW1hbmQgc2VydmljZSBhbGxvd3MgeW91IHRvIGV4Y2hhbmdlIG1lc3NhZ2VzIHdpdGggb3RoZXIgY29tcG9uZW50cyBpbiB0aGUgcGxhdGZvcm0uIFlvdVxuICogY2FuIHJlZ2lzdGVyIGEgY29tbWFuZCB0aGF0IG90aGVyIHNlcnZpY2VzIGFuZCBleHRlbnNpb25zIGNhbiBzZW5kIHlvdS4gWW91IGNhbiBzZW5kIGNvbW1hbmRzIHRvXG4gKiBvdGhlciBzZXJ2aWNlcyBhbmQgZXh0ZW5zaW9ucyB0aGF0IGhhdmUgcmVnaXN0ZXJlZCBjb21tYW5kcy5cbiAqL1xuZXhwb3J0IHR5cGUgbW9kdWxlU3VtbWFyeUNvbW1lbnRzID0ge307XG4iLCIvKiogSGFuZGxlcyByZWdpc3RlcmluZyBkYXRhIHByb3ZpZGVycyBhbmQgc2VydmluZyBkYXRhIGFyb3VuZCB0aGUgcGFwaS4gRXhwb3NlZCBvbiB0aGUgcGFwaS4gKi9cblxuaW1wb3J0IHtcbiAgRGF0YVByb3ZpZGVyRGF0YVR5cGVzLFxuICBEYXRhUHJvdmlkZXJHZXR0ZXIsXG4gIERhdGFQcm92aWRlckludGVybmFsLFxuICBEYXRhUHJvdmlkZXJVcGRhdGVJbnN0cnVjdGlvbnMsXG4gIERhdGFQcm92aWRlclNldHRlcixcbiAgRGF0YVByb3ZpZGVyU3Vic2NyaWJlcixcbiAgRGF0YVByb3ZpZGVyU3Vic2NyaWJlck9wdGlvbnMsXG4gIERhdGFUeXBlTmFtZXMsXG4gIGdldERhdGFQcm92aWRlckRhdGFUeXBlRnJvbUZ1bmN0aW9uTmFtZSxcbiAgRGF0YVByb3ZpZGVyRGF0YVR5cGUsXG59IGZyb20gJ0BzaGFyZWQvbW9kZWxzL2RhdGEtcHJvdmlkZXIubW9kZWwnO1xuaW1wb3J0IHsgRGF0YVByb3ZpZGVyRW5naW5lLCBJRGF0YVByb3ZpZGVyRW5naW5lIH0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvZGF0YS1wcm92aWRlci1lbmdpbmUubW9kZWwnO1xuaW1wb3J0IHtcbiAgQXN5bmNWYXJpYWJsZSxcbiAgQ2Fubm90SGF2ZU9uRGlkRGlzcG9zZSxcbiAgUGxhdGZvcm1FdmVudCxcbiAgUGxhdGZvcm1FdmVudEVtaXR0ZXIsXG4gIGRlZXBFcXVhbCxcbiAgZW5kc1dpdGgsXG4gIGdldEFsbE9iamVjdEZ1bmN0aW9uTmFtZXMsXG4gIGdldEVycm9yTWVzc2FnZSxcbiAgZ3JvdXBCeSxcbiAgaXNFcnJvck1lc3NhZ2VBYm91dFBhcmF0ZXh0QmxvY2tpbmdJbnRlcm5ldEFjY2VzcyxcbiAgaXNFcnJvck1lc3NhZ2VBYm91dFJlZ2lzdHJ5QXV0aEZhaWx1cmUsXG4gIGlzU3RyaW5nLFxuICBuZXdQbGF0Zm9ybUVycm9yLFxuICBzdGFydHNXaXRoLFxufSBmcm9tICdwbGF0Zm9ybS1iaWJsZS11dGlscyc7XG5pbXBvcnQgKiBhcyBuZXR3b3JrU2VydmljZSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL25ldHdvcmsuc2VydmljZSc7XG5pbXBvcnQgeyBzZXJpYWxpemVSZXF1ZXN0VHlwZSB9IGZyb20gJ0BzaGFyZWQvdXRpbHMvdXRpbCc7XG5pbXBvcnQgeyBMb2NhbE9iamVjdFRvUHJveHlDcmVhdG9yIH0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvbmV0d29yay1vYmplY3QubW9kZWwnO1xuaW1wb3J0IHsgbmV0d29ya09iamVjdFNlcnZpY2UsIG92ZXJyaWRlRGlzcG9zZSB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbmV0d29yay1vYmplY3Quc2VydmljZSc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL2xvZ2dlci5zZXJ2aWNlJztcbmltcG9ydCB7XG4gIENvbW1hbmRIYW5kbGVycyxcbiAgRGF0YVByb3ZpZGVyTmFtZXMsXG4gIERhdGFQcm92aWRlclR5cGVzLFxuICBEYXRhUHJvdmlkZXJzLFxuICBEaXNwb3NhYmxlRGF0YVByb3ZpZGVycyxcbn0gZnJvbSAncGFwaS1zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IHsgSURhdGFQcm92aWRlciwgSURpc3Bvc2FibGVEYXRhUHJvdmlkZXIgfSBmcm9tICdAc2hhcmVkL21vZGVscy9kYXRhLXByb3ZpZGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBub3RpZmljYXRpb25TZXJ2aWNlIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9ub3RpZmljYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBQbGF0Zm9ybU5vdGlmaWNhdGlvbiB9IGZyb20gJ0BzaGFyZWQvbW9kZWxzL25vdGlmaWNhdGlvbi5zZXJ2aWNlLW1vZGVsJztcblxuLyoqIFN1ZmZpeCBvbiBuZXR3b3JrIG9iamVjdHMgdGhhdCBpbmRpY2F0ZXMgdGhhdCB0aGUgbmV0d29yayBvYmplY3QgaXMgYSBkYXRhIHByb3ZpZGVyICovXG5jb25zdCBEQVRBX1BST1ZJREVSX0xBQkVMID0gJ2RhdGEnO1xuXG4vKiogRXZlbnQgdHlwZSBmb3IgZGF0YSBwcm92aWRlciB1cGRhdGUgZXZlbnQgKi9cbmNvbnN0IE9OX0RJRF9VUERBVEUgPSAnb25EaWRVcGRhdGUnO1xuXG4vKipcbiAqIEFuIG9iamVjdCByZWZlcmVuY2UgdGhhdCBpcyBhIHBsYWNlaG9sZGVyIGZvciB1cGRhdGVzIGZvciBkYXRhIHByb3ZpZGVyIHN1YnNjcmliZXJzLiBXZSB3YW50IHRvXG4gKiBtYWtlIGFic29sdXRlbHkgc3VyZSB1cGRhdGVzIHRoYXQgY29tZSBpbiBhcmUgc2VudCB0byBzdWJzY3JpYmVycywgc28gd2UgdXNlIHRoaXMgb2JqZWN0XG4gKiByZWZlcmVuY2UgdG8gdGVsbCBpZiB3ZSBoYXZlIG5ldmVyIGhhZCBhbiB1cGRhdGUgYmVmb3JlLlxuICovXG5jb25zdCBTVUJTQ1JJQkVfUExBQ0VIT0xERVIgPSB7fTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpZCBmb3IgdGhlIGRhdGEgcHJvdmlkZXIgbmV0d29yayBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBEb24ndCBhZGQgdGhlIHN1ZmZpeCB0byB0aGVcbiAqIHByb3ZpZGVyIG5hbWUgaWYgaXQncyBhbHJlYWR5IHRoZXJlIHRvIGF2b2lkIGR1cGxpY2F0aW9uXG4gKi9cbmNvbnN0IGdldERhdGFQcm92aWRlck9iamVjdElkID0gKHByb3ZpZGVyTmFtZTogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBlbmRzV2l0aChwcm92aWRlck5hbWUsIGAtJHtEQVRBX1BST1ZJREVSX0xBQkVMfWApXG4gICAgPyBwcm92aWRlck5hbWVcbiAgICA6IGAke3Byb3ZpZGVyTmFtZX0tJHtEQVRBX1BST1ZJREVSX0xBQkVMfWA7XG59O1xuXG4vKiogV2hldGhlciB0aGlzIHNlcnZpY2UgaGFzIGZpbmlzaGVkIHNldHRpbmcgdXAgKi9cbmxldCBpc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8qKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGlzIHNlcnZpY2UgaXMgZmluaXNoZWQgaW5pdGlhbGl6aW5nICovXG5sZXQgaW5pdGlhbGl6ZVByb21pc2U6IFByb21pc2U8dm9pZD4gfCB1bmRlZmluZWQ7XG5cbi8qKiBTZXRzIHVwIHRoZSBzZXJ2aWNlLiBPbmx5IHJ1bnMgb25jZSBhbmQgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgcHJvbWlzZSBhZnRlciB0aGF0ICovXG5jb25zdCBpbml0aWFsaXplID0gKCkgPT4ge1xuICBpZiAoaW5pdGlhbGl6ZVByb21pc2UpIHJldHVybiBpbml0aWFsaXplUHJvbWlzZTtcblxuICBpbml0aWFsaXplUHJvbWlzZSA9IChhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKGlzSW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBhd2FpdCBuZXR3b3JrU2VydmljZS5pbml0aWFsaXplKCk7XG4gICAgaXNJbml0aWFsaXplZCA9IHRydWU7XG4gIH0pKCk7XG5cbiAgcmV0dXJuIGluaXRpYWxpemVQcm9taXNlO1xufTtcblxuLyoqXG4gKiBKU0RPQyBTT1VSQ0UgRGF0YVByb3ZpZGVyU2VydmljZUhhc0tub3duXG4gKlxuICogSW5kaWNhdGUgaWYgd2UgYXJlIGF3YXJlIG9mIGFuIGV4aXN0aW5nIGRhdGEgcHJvdmlkZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gSWYgYSBkYXRhIHByb3ZpZGVyXG4gKiB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzIHNvbWV3aGVyZSBlbHNlIG9uIHRoZSBuZXR3b3JrLCB0aGlzIGZ1bmN0aW9uIHdvbid0IHRlbGwgeW91IGFib3V0IGl0XG4gKiB1bmxlc3Mgc29tZXRoaW5nIGVsc2UgaW4gdGhlIGV4aXN0aW5nIHByb2Nlc3MgaXMgc3Vic2NyaWJlZCB0byBpdC5cbiAqL1xuZnVuY3Rpb24gaGFzS25vd24ocHJvdmlkZXJOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIG5ldHdvcmtPYmplY3RTZXJ2aWNlLmhhc0tub3duKGdldERhdGFQcm92aWRlck9iamVjdElkKHByb3ZpZGVyTmFtZSkpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RFcnJvck5vdGlmaWNhdGlvbihleGNlcHRpb246IHVua25vd24pOiBQbGF0Zm9ybU5vdGlmaWNhdGlvbiB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHJldFZhbDogUGxhdGZvcm1Ob3RpZmljYXRpb24gPSB7XG4gICAgc2V2ZXJpdHk6ICdlcnJvcicsXG4gICAgbWVzc2FnZTogJycsXG4gICAgY2xpY2tDb21tYW5kTGFiZWw6ICclZ2VuZXJhbF9vcGVuJScsXG4gICAgLy8gVFMgZG9lc24ndCByZWFsaXplIHRoaXMgaXMgYSB2YWxpZCBjb21tYW5kIGhhbmRsZXIga2V5IHNpbmNlIGl0IGlzIGRlZmluZWQgaW4gYW4gZXh0ZW5zaW9uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gICAgY2xpY2tDb21tYW5kOiAncGFyYXRleHRSZWdpc3RyYXRpb24uc2hvd1BhcmF0ZXh0UmVnaXN0cmF0aW9uJyBhcyBrZXlvZiBDb21tYW5kSGFuZGxlcnMsXG4gIH07XG5cbiAgaWYgKGlzRXJyb3JNZXNzYWdlQWJvdXRQYXJhdGV4dEJsb2NraW5nSW50ZXJuZXRBY2Nlc3MoZXhjZXB0aW9uKSkge1xuICAgIHJldFZhbC5tZXNzYWdlID0gJyVkYXRhX2xvYWRpbmdfZXJyb3JfcGFyYXRleHREYXRhX2ludGVybmV0X2Rpc2FibGVkJSc7XG4gIH0gZWxzZSBpZiAoaXNFcnJvck1lc3NhZ2VBYm91dFJlZ2lzdHJ5QXV0aEZhaWx1cmUoZXhjZXB0aW9uKSkge1xuICAgIHJldFZhbC5tZXNzYWdlID0gJyVkYXRhX2xvYWRpbmdfZXJyb3JfcGFyYXRleHREYXRhX2F1dGhfZmFpbHVyZSUnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gcmV0VmFsO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdWJzY3JpYmUgZnVuY3Rpb24gZm9yIGEgZGF0YSBwcm92aWRlciB0byBhbGxvdyBzdWJzY3JpYmluZyB0byB1cGRhdGVzIG9uIHRoZSBkYXRhXG4gKlxuICogQHBhcmFtIGRhdGFQcm92aWRlclByb21pc2UgUHJvbWlzZSB0byB0aGUgZGF0YSBwcm92aWRlcidzIG5ldHdvcmsgb2JqZWN0XG4gKiBAcGFyYW0gb25EaWRVcGRhdGUgVGhlIGV2ZW50IHRvIGxpc3RlbiB0byBmb3IgdXBkYXRlcyBvbiB0aGUgZGF0YVxuICogQHBhcmFtIGRhdGFUeXBlIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbnMgdG8gdXNlIChleDogYGRhdGFQcm92aWRlci5zdWJzY3JpYmVCb29rYCAtPlxuICogICBgZGF0YVByb3ZpZGVyLmdldEJvb2tgKVxuICogQHJldHVybnMgU3Vic2NyaWJlIGZ1bmN0aW9uIGZvciBhIGRhdGEgcHJvdmlkZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGF0YVByb3ZpZGVyU3Vic2NyaWJlcjxEYXRhUHJvdmlkZXJOYW1lIGV4dGVuZHMgRGF0YVByb3ZpZGVyTmFtZXM+KFxuICBkYXRhUHJvdmlkZXJQcm9taXNlOiBQcm9taXNlPERhdGFQcm92aWRlcnNbRGF0YVByb3ZpZGVyTmFtZV0+LFxuICBvbkRpZFVwZGF0ZTogUGxhdGZvcm1FdmVudDxEYXRhUHJvdmlkZXJVcGRhdGVJbnN0cnVjdGlvbnM8RGF0YVByb3ZpZGVyVHlwZXNbRGF0YVByb3ZpZGVyTmFtZV0+PixcbiAgZGF0YVR5cGU6IERhdGFUeXBlTmFtZXM8RGF0YVByb3ZpZGVyVHlwZXNbRGF0YVByb3ZpZGVyTmFtZV0+LFxuICAvLyBTYWRseSBgRGF0YVByb3ZpZGVyU3Vic2NyaWJlcjxEYXRhUHJvdmlkZXJUeXBlc1tEYXRhUHJvdmlkZXJOYW1lXVt0eXBlb2YgZGF0YVR5cGVdPmAgZGlkIG5vdFxuICAvLyB3b3JrLiBNYXliZSBUeXBlU2NyaXB0IHJlZnVzZXMgdG8gbG9vayBhdCBhbGwgcHJvcGVydGllcyBpbiBlYWNoIG1lbWJlciBvZiBgRGF0YVByb3ZpZGVyVHlwZXNgXG4gIC8vIGFuZCB0ZWxsIHRoYXQgdGhleSdyZSBhbGwgYERhdGFQcm92aWRlckRhdGFUeXBlYHMuXG4pOiBEYXRhUHJvdmlkZXJTdWJzY3JpYmVyPERhdGFQcm92aWRlckRhdGFUeXBlPHVua25vd24sIHVua25vd24sIHVua25vd24+PiB7XG4gIHJldHVybiBhc3luYyAoc2VsZWN0b3IsIGNhbGxiYWNrLCBvcHRpb25zPzogRGF0YVByb3ZpZGVyU3Vic2NyaWJlck9wdGlvbnMpID0+IHtcbiAgICAvLyBXZSBuZWVkIGFuIHVudHlwZWQgdmVyc2lvbiBvZiB0aGUgRFAgc28gd2UgY2FuIHVzZSBzdHJpbmctdGVtcGxhdGUtbWFwcGVkLXR5cGUgcHJvcGVydGllc1xuICAgIC8vIG9uIGl0IGV2ZW4gdGhvdWdoIHRoZSBzdHJpbmdzIHRoYXQgZ2V0IHRlbXBsYXRlZCBhcmUgb25lIG9mIG1hbnkgcG9zc2liaWxpdGllcy4gSXQgc2VlbXNcbiAgICAvLyBUeXBlU2NyaXB0IGlzIHVuYWJsZSB0byBkaXN0aW5ndWlzaCB0aGF0IGBEYXRhVHlwZU5hbWVzPERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdPmBcbiAgICAvLyBpcyBvbmUgc3BlY2lmaWMgc2V0IG9mIG5hbWVzIG9mIGRhdGEgdHlwZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICBjb25zdCBkYXRhUHJvdmlkZXJVbnR5cGVkID0gKGF3YWl0IGRhdGFQcm92aWRlclByb21pc2UpIGFzIEF3YWl0ZWQ8XG4gICAgICB0eXBlb2YgZGF0YVByb3ZpZGVyUHJvbWlzZVxuICAgID4gJiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgW2tleTogc3RyaW5nXTogYW55O1xuICAgIH07XG5cbiAgICAvLyBEZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBzdWJzY3JpYmVyT3B0aW9uczogRGF0YVByb3ZpZGVyU3Vic2NyaWJlck9wdGlvbnMgPSB7XG4gICAgICByZXRyaWV2ZURhdGFJbW1lZGlhdGVseTogdHJ1ZSxcbiAgICAgIHdoaWNoVXBkYXRlczogJ2RlZXBseS1lcXVhbCcsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG5cbiAgICBjb25zdCB7IHJldHJpZXZlRGF0YUltbWVkaWF0ZWx5LCB3aGljaFVwZGF0ZXMgfSA9IHN1YnNjcmliZXJPcHRpb25zO1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB3aGV0aGVyIHdlIHNob3VsZCBjYWxsIHRoZSBjYWxsYmFjayB3aGVuIHdlIHJlY2VpdmUgYSByZXN1bHQgb3IgaWYgdGhleSBoYXZlIGFscmVhZHkgdW5zdWJzY3JpYmVkXG4gICAgLy8gSW1wb3J0YW50IGJlY2F1c2UgYSBwcm9taXNlIGNvdWxkIHJlc29sdmUgYWZ0ZXIgdGhleSBoYXZlIHVuc3Vic2NyaWJlZFxuICAgIGxldCBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgcmVjZW50IGRhdGEgYmVmb3JlIHRoZSBuZXdlc3QgdXBkYXRlLiBVc2VkIGZvciBkZWVwIGNvbXBhcmlzb24gY2hlY2tzIHRvIHByZXZlbnRcbiAgICAgKiB1c2VsZXNzIHVwZGF0ZXNcbiAgICAgKi9cbiAgICAvLyBTdGFydCB0aGlzIG91dCBhcyBhIHBsYWNlaG9sZGVyIHNvIHVwZGF0ZXMgZGVmaW5pdGVseSBydW4gdGhlIGNhbGxiYWNrIChpbmNsdWRpbmcgaWYgdGhlIGRhdGEgaXMgdW5kZWZpbmVkIG9yIGFuIGVtcHR5IG9iamVjdClcbiAgICAvLyBUT0RPOiBjcmVhdGUgYSBjYWNoZSBmb3IgdGhlIGRhdGEgcHJvdmlkZXIgdGhhdCBob2xkcyBkYXRhIHJldHVybmVkIHBlciBzZWxlY3RvciBhbmQgc2hhcmVzIHRoYXQgY2FjaGUgaGVyZVxuICAgIGxldCBkYXRhUHJldmlvdXM6IHVua25vd24gPSBTVUJTQ1JJQkVfUExBQ0VIT0xERVI7XG5cbiAgICAvLyBDcmVhdGUgYSBsYXllciBvdmVyIHRoZSBwcm92aWRlZCBjYWxsYmFjayB0aGF0IGxldHMgdXMga25vdyBpZiB3ZSByZWNlaXZlZCBhbiB1cGRhdGUgc28gd2UgZG9uJ3QgcnVuIHRoZSBjYWxsYmFjayB3aXRoIG9sZCBkYXRhIGFmdGVyIHVwZGF0aW5nXG4gICAgLyoqXG4gICAgICogV2hldGhlciB3ZSBoYXZlIGFscmVhZHkgcmVjZWl2ZWQgYW4gdXBkYXRlIGV2ZW50LCBtZWFuaW5nIG91ciBpbml0aWFsIGBnZXRgIHdpbGwgcmV0dXJuIG9sZFxuICAgICAqIGRhdGFcbiAgICAgKi9cbiAgICBsZXQgcmVjZWl2ZWRVcGRhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBjYWxsYmFja1dpdGhVcGRhdGUgPSBhc3luYyAoXG4gICAgICB1cGRhdGVFdmVudFJlc3VsdDogRGF0YVByb3ZpZGVyVXBkYXRlSW5zdHJ1Y3Rpb25zPERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdPixcbiAgICApID0+IHtcbiAgICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgdW5zdWJzY3JpYmVkIHNvbWVob3csIGRvbid0IHdhbnQgdG8gcnVuIHRoaXNcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSByZXR1cm47XG5cbiAgICAgIGlmIChcbiAgICAgICAgdXBkYXRlRXZlbnRSZXN1bHQgIT09ICcqJyAmJlxuICAgICAgICAoIUFycmF5LmlzQXJyYXkodXBkYXRlRXZlbnRSZXN1bHQpIHx8ICF1cGRhdGVFdmVudFJlc3VsdC5pbmNsdWRlcyhkYXRhVHlwZSkpXG4gICAgICApXG4gICAgICAgIC8vIFRoZSB1cGRhdGUgZG9lcyBub3QgYXBwbHkgdG8gdGhpcyBkYXRhIHR5cGUuIElnbm9yZVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoZSB1cGRhdGUgaXMgcmVsZXZhbnQgdG8gdGhpcyBkYXRhIHR5cGUsIHNvIGNvbnRpbnVlIHdpdGggdGhpcyBzdWJzY3JpcHRpb25cbiAgICAgICAgLy8gR2V0IHRoZSBkYXRhIGF0IG91ciBzZWxlY3RvciB3aGVuIHdlIHJlY2VpdmUgbm90aWZpY2F0aW9uIHRoYXQgdGhlIGRhdGEgdXBkYXRlZFxuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgc2VsZWN0b3IgZXZlbnRzIHNvIHdlIGNhbiByZWNlaXZlIHRoZSBuZXcgZGF0YSB3aXRoIHRoZSB1cGRhdGUgaW5zdGVhZCBvZiByZWFjaGluZyBiYWNrIG91dCBmb3IgaXRcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBzZWVtcyB0byBiZSB1bmFibGUgdG8gZmlndXJlIG91dCB0aGVzZSBgZ2V0JHtkYXRhVHlwZX1gIHR5cGVzIHdoZW4gd2Ugd3JhcFxuICAgICAgICAvLyBEYXRhUHJvdmlkZXJJbnRlcm5hbCBpbiBOZXR3b3JrT2JqZWN0IHRvIG1ha2UgSURhdGFQcm92aWRlciwgc28gd2UgaGF2ZSB0byBkbyBhbGwgdGhpcyB3b3JrXG4gICAgICAgIC8vIHRvIHNwZWNpZnkgdGhlIHNwZWNpZmljIHR5cGVzXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uICovXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCAoXG4gICAgICAgICAgZGF0YVByb3ZpZGVyVW50eXBlZFtcbiAgICAgICAgICAgIGBnZXQke2RhdGFUeXBlfWBcbiAgICAgICAgICAgIC8vIFNhZGx5IERhdGFQcm92aWRlckdldHRlcjxEYXRhUHJvdmlkZXJUeXBlc1tEYXRhUHJvdmlkZXJOYW1lXVt0eXBlb2YgZGF0YVR5cGVdPiBkb2Vzbid0XG4gICAgICAgICAgICAvLyB3b3JrIGhlcmUuIFNlZSBjb21tZW50IGluIGZ1bmN0aW9uIHNpZ25hdHVyZSBmb3IgbW9yZSBpbmZvXG4gICAgICAgICAgXSBhcyBEYXRhUHJvdmlkZXJHZXR0ZXI8RGF0YVByb3ZpZGVyRGF0YVR5cGU8dW5rbm93biwgdW5rbm93biwgdW5rbm93bj4+XG4gICAgICAgICkoc2VsZWN0b3IpO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgICAgIC8vIFRha2Ugbm90ZSB0aGF0IHdlIGhhdmUgcmVjZWl2ZWQgYW4gdXBkYXRlIHNvIHdlIGRvbid0IHJ1biB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgb2xkIGRhdGEgYmVsb3cgaW4gdGhlIGByZXRyaWV2ZURhdGFJbW1lZGlhdGVseWAgY29kZVxuICAgICAgICByZWNlaXZlZFVwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgLy8gSWYgd2UgdW5zdWJzY3JpYmVkIHdoaWxlIHdlIHdlcmUgYXdhaXRpbmcgdGhlIHByb21pc2UgdG8gZ2V0IGRhdGEsIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIGlmICghaXNTdWJzY3JpYmVkKSByZXR1cm47XG5cbiAgICAgICAgLy8gT25seSB1cGRhdGUgaWYgd2Ugc2hvdWxkIGxpc3RlbiB0byBhbGwgdXBkYXRlcywgaWYgdGhlIG9sZCBkYXRhIGlzIHRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGRhdGEsIG9yIHRoZSBkYXRhIGlzIG5vdCBkZWVwbHkgZXF1YWxcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHdoaWNoVXBkYXRlcyA9PT0gJyonIHx8XG4gICAgICAgICAgZGF0YVByZXZpb3VzID09PSBTVUJTQ1JJQkVfUExBQ0VIT0xERVIgfHxcbiAgICAgICAgICAhZGVlcEVxdWFsKGRhdGFQcmV2aW91cywgZGF0YSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGF0YVByZXZpb3VzID0gZGF0YTtcbiAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvckRldGFpbHMgPSBKU09OLnN0cmluZ2lmeShzZWxlY3RvcikgPz8gJzx1bmRlZmluZWQ+JztcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYFRyaWVkIHRvIHJldHJpZXZlIGRhdGEgYWZ0ZXIgYW4gdXBkYXRlIGV2ZW50IGZvciAke2RhdGFUeXBlfSB3aXRoIHNlbGVjdG9yICR7c2VsZWN0b3JEZXRhaWxzLnN1YnN0cmluZygwLCAxMjApfSwgYnV0IGl0IHRocmV3LiAke2dldEVycm9yTWVzc2FnZShlKX1gLFxuICAgICAgICApO1xuICAgICAgICBjYWxsYmFjayhuZXdQbGF0Zm9ybUVycm9yKGUpKTtcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gY29uc3RydWN0RXJyb3JOb3RpZmljYXRpb24oZSk7XG4gICAgICAgIGlmIChub3RpZmljYXRpb24pIG5vdGlmaWNhdGlvblNlcnZpY2Uuc2VuZChub3RpZmljYXRpb24pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IG9uRGlkVXBkYXRlKGNhbGxiYWNrV2l0aFVwZGF0ZSk7XG5cbiAgICAvLyBJZiB0aGUgc3Vic2NyaWJlciB3YW50cyB0byBnZXQgdGhlIGRhdGEgYXMgc29vbiBhcyBwb3NzaWJsZSBpbiBhZGRpdGlvbiB0byBydW5uaW5nIHRoZSBjYWxsYmFjayBvbiB1cGRhdGVzLCBnZXQgdGhlIGRhdGFcbiAgICBpZiAocmV0cmlldmVEYXRhSW1tZWRpYXRlbHkpIHtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBkYXRhIHRvIHJ1biB0aGUgY2FsbGJhY2sgaW1tZWRpYXRlbHkgc28gaXQgaGFzIHRoZSBkYXRhXG4gICAgICAgICAgLy8gVHlwZVNjcmlwdCBzZWVtcyB0byBiZSB1bmFibGUgdG8gZmlndXJlIG91dCB0aGVzZSBgZ2V0JHtkYXRhVHlwZX1gIHR5cGVzIHdoZW4gd2Ugd3JhcFxuICAgICAgICAgIC8vIERhdGFQcm92aWRlckludGVybmFsIGluIE5ldHdvcmtPYmplY3QgdG8gbWFrZSBJRGF0YVByb3ZpZGVyLCBzbyB3ZSBoYXZlIHRvIGRvIGFsbCB0aGlzIHdvcmtcbiAgICAgICAgICAvLyB0byBzcGVjaWZ5IHRoZSBzcGVjaWZpYyB0eXBlc1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uICovXG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IChcbiAgICAgICAgICAgIGRhdGFQcm92aWRlclVudHlwZWRbXG4gICAgICAgICAgICAgIGBnZXQke2RhdGFUeXBlfWBcbiAgICAgICAgICAgICAgLy8gU2FkbHkgRGF0YVByb3ZpZGVyR2V0dGVyPERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdW3R5cGVvZiBkYXRhVHlwZV0+IGRvZXNuJ3RcbiAgICAgICAgICAgICAgLy8gd29yayBoZXJlLiBTZWUgY29tbWVudCBpbiBmdW5jdGlvbiBzaWduYXR1cmUgZm9yIG1vcmUgaW5mb1xuICAgICAgICAgICAgXSBhcyBEYXRhUHJvdmlkZXJHZXR0ZXI8RGF0YVByb3ZpZGVyRGF0YVR5cGU8dW5rbm93biwgdW5rbm93biwgdW5rbm93bj4+XG4gICAgICAgICAgKShzZWxlY3Rvcik7XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgICAgIC8vIE9ubHkgcnVuIHRoZSBjYWxsYmFjayB3aXRoIHRoaXMgdXBkYXRlZCBkYXRhIGlmIHdlIGhhdmUgbm90IGFscmVhZHkgcmVjZWl2ZWQgYW4gdXBkYXRlIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBvdmVyd3JpdGUgdGhlIG5ld2x5IHVwZGF0ZWQgZGF0YSB3aXRoIG9sZCBkYXRhXG4gICAgICAgICAgLy8gQW5kIGRvbid0IHJ1biB0aGUgY2FsbGJhY2sgaWYgd2UgaGF2ZSBhbHJlYWR5IHVuc3Vic2NyaWJlZFxuICAgICAgICAgIGlmICghcmVjZWl2ZWRVcGRhdGUgJiYgaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZWNlaXZlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICBkYXRhUHJldmlvdXMgPSBkYXRhO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0b3JEZXRhaWxzID0gSlNPTi5zdHJpbmdpZnkoc2VsZWN0b3IpID8/ICc8dW5kZWZpbmVkPic7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgVHJpZWQgdG8gcmV0cmlldmUgZGF0YSBpbW1lZGlhdGVseSBmb3IgJHtkYXRhVHlwZX0gd2l0aCBzZWxlY3RvciAke3NlbGVjdG9yRGV0YWlscy5zdWJzdHJpbmcoMCwgMTIwKX0sIGJ1dCBpdCB0aHJldy4gJHtnZXRFcnJvck1lc3NhZ2UoZSl9YCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNhbGxiYWNrKG5ld1BsYXRmb3JtRXJyb3IoZSkpO1xuICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IGNvbnN0cnVjdEVycm9yTm90aWZpY2F0aW9uKGUpO1xuICAgICAgICAgIGlmIChub3RpZmljYXRpb24pIG5vdGlmaWNhdGlvblNlcnZpY2Uuc2VuZChub3RpZmljYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIC8vIEZvcmNpbmcgdGhlIHVuc3Vic2NyaWJlIHRvIGJlIGFzeW5jaHJvbm91cyB0byBzdXBwb3J0IHNlbGVjdG9yIGV2ZW50cyBpbiB0aGUgZnV0dXJlXG4gICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGRpZFN1Y2Nlc3NmdWxseVVuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChkaWRTdWNjZXNzZnVsbHlVbnN1YnNjcmliZSkgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gZGlkU3VjY2Vzc2Z1bGx5VW5zdWJzY3JpYmU7XG4gICAgfTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZGF0YSBwcm92aWRlciBwcm94eSB3aXRoIGBzdWJzY3JpYmU8ZGF0YV90eXBlPmAgZnVuY3Rpb25zLiBSdW5zIGxvY2FsbHkgYW5kIHJlbW90ZVxuICpcbiAqIEBwYXJhbSBkYXRhUHJvdmlkZXJFbmdpbmUgRW5naW5lIHRvIG1ha2UgdGhlIGRhdGEgcHJvdmlkZXIgcHJveHkgb3ZlciBpZiBsb2NhbC4gYHVuZGVmaW5lZGAgaWZcbiAqICAgcmVtb3RlXG4gKiBAcGFyYW0gZGF0YVByb3ZpZGVyUHJvbWlzZSBQcm9taXNlIHRvIHRoZSBkYXRhIHByb3ZpZGVyJ3MgbmV0d29yayBvYmplY3RcbiAqIEBwYXJhbSBvbkRpZFVwZGF0ZSBUaGUgZXZlbnQgdG8gbGlzdGVuIHRvIGZvciB1cGRhdGVzIG9uIHRoZSBkYXRhXG4gKiBAcmV0dXJucyBEYXRhIHByb3ZpZGVyIHByb3h5IHdpdGggYHN1YnNjcmliZTxkYXRhX3R5cGU+YCBmdW5jdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGF0YVByb3ZpZGVyUHJveHk8RGF0YVByb3ZpZGVyTmFtZSBleHRlbmRzIERhdGFQcm92aWRlck5hbWVzPihcbiAgZGF0YVByb3ZpZGVyRW5naW5lOiBJRGF0YVByb3ZpZGVyRW5naW5lPERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdPiB8IHVuZGVmaW5lZCxcbiAgZGF0YVByb3ZpZGVyUHJvbWlzZTogUHJvbWlzZTxEYXRhUHJvdmlkZXJzW0RhdGFQcm92aWRlck5hbWVdPixcbiAgb25EaWRVcGRhdGU6IFBsYXRmb3JtRXZlbnQ8RGF0YVByb3ZpZGVyVXBkYXRlSW5zdHJ1Y3Rpb25zPERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdPj4sXG4pOiBEYXRhUHJvdmlkZXJJbnRlcm5hbDxEYXRhUHJvdmlkZXJUeXBlc1tEYXRhUHJvdmlkZXJOYW1lXT4ge1xuICAvLyBPYmplY3Qgd2hvc2UgbWV0aG9kcyB0byBydW4gZmlyc3Qgd2hlbiB0aGUgZGF0YSBwcm92aWRlcidzIG1ldGhvZCBpcyBjYWxsZWQgaWYgdGhleSBleGlzdCBoZXJlXG4gIC8vIGJlZm9yZSBmYWxsaW5nIGJhY2sgdG8gdGhlIGRhdGFQcm92aWRlckVuZ2luZSdzIG1ldGhvZHMuIENhY2hlcyBzdWJzY3JpYmUgZnVuY3Rpb25zIGFuZCBib3VuZFxuICAvLyBkYXRhIHByb3ZpZGVyIGVuZ2luZSBtZXRob2RzLlxuICAvLyBUT0RPOiB1cGRhdGUgbmV0d29yayBvYmplY3RzIHNvIHJlbW90ZSBvYmplY3RzIGtub3cgd2hlbiBtZXRob2RzIGRvIG5vdCBleGlzdCwgdGhlbiBtYWtlIElEYXRhUHJvdmlkZXIuc2V0IG9wdGlvbmFsXG4gIGNvbnN0IGRhdGFQcm92aWRlckludGVybmFsOiBQYXJ0aWFsPERhdGFQcm92aWRlckludGVybmFsPERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdPj4gPVxuICAgIHt9O1xuXG4gIC8vIENyZWF0ZSBhIHByb3h5IHRoYXQgcnVucyB0aGUgZGF0YSBwcm92aWRlciBtZXRob2QgaWYgaXQgZXhpc3RzIG9yIHJ1bnMgdGhlIGVuZ2luZSBtZXRob2RcbiAgLy8gb3RoZXJ3aXNlLlxuICAvLyBUeXBlIGFzc2VydCB0aGUgZGF0YSBwcm92aWRlciBlbmdpbmUgcHJveHkgYmVjYXVzZSBpdCBpcyBhIERhdGFQcm92aWRlckludGVybmFsLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgY29uc3QgZGF0YVByb3ZpZGVyID0gbmV3IFByb3h5KFxuICAgIGRhdGFQcm92aWRlckVuZ2luZSA/P1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gICAgICAoZGF0YVByb3ZpZGVySW50ZXJuYWwgYXMgSURhdGFQcm92aWRlckVuZ2luZTxEYXRhUHJvdmlkZXJUeXBlc1tEYXRhUHJvdmlkZXJOYW1lXT4pLFxuICAgIHtcbiAgICAgIGdldChvYmosIHByb3ApIHtcbiAgICAgICAgLy8gUGFzcyBwcm9taXNlcyB0aHJvdWdoLiBBc3NlcnQgdHlwZSBvZiBgcHJvcGAgdG8gaW5kZXggYG9iamAuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICAgICAgICBpZiAocHJvcCA9PT0gJ3RoZW4nKSByZXR1cm4gb2JqW3Byb3AgYXMga2V5b2YgdHlwZW9mIG9ial07XG5cbiAgICAgICAgLy8gRG8gbm90IGxldCBhbnlvbmUgYnV0IHRoZSBkYXRhIHByb3ZpZGVyIGVuZ2luZSBzZW5kIHVwZGF0ZXNcbiAgICAgICAgaWYgKGlzU3RyaW5nKHByb3ApICYmIHByb3AgPT09ICdub3RpZnlVcGRhdGUnKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJ1biBub3RpZnlVcGRhdGUgb3V0c2lkZSBvZiBkYXRhIHByb3ZpZGVyIGVuZ2luZScpO1xuXG4gICAgICAgIC8vIElmIHRoZSBkYXRhIHByb3ZpZGVyIGFscmVhZHkgaGFzIHRoZSBtZXRob2QsIHJ1biBpdFxuICAgICAgICBpZiAocHJvcCBpbiBkYXRhUHJvdmlkZXJJbnRlcm5hbClcbiAgICAgICAgICAvLyBBc3NlcnQgdHlwZSBvZiBgcHJvcGAgdG8gaW5kZXggYGRhdGFQcm92aWRlckludGVybmFsYC5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICByZXR1cm4gZGF0YVByb3ZpZGVySW50ZXJuYWxbcHJvcCBhcyBrZXlvZiB0eXBlb2YgZGF0YVByb3ZpZGVySW50ZXJuYWxdO1xuXG4gICAgICAgIC8qKiBGaWd1cmUgb3V0IHRoZSBtZXRob2QgdGhhdCB3aWxsIGdvIG9uIHRoZSBkYXRhIHByb3ZpZGVyIHRvIHJ1biAqL1xuICAgICAgICAvLyBBbnkgYmVjYXVzZSB3ZSB3YW50IHRoaXMgbWV0aG9kIHRvIGJlIGFueSBtZXRob2Qgb24gdGhlIGRhdGEgcHJvdmlkZXIgdHlwZVxuICAgICAgICBsZXQgbmV3RGF0YVByb3ZpZGVyTWV0aG9kOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBEYXRhUHJvdmlkZXJJbnRlcm5hbDxEYXRhUHJvdmlkZXJUeXBlc1tEYXRhUHJvdmlkZXJOYW1lXT5bYW55XSB8IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBJZiB0aGV5IHdhbnQgYSBzdWJzY3JpYmVyLCBidWlsZCBhIHN1YnNjcmliZSBmdW5jdGlvbiBzcGVjaWZpYyB0byB0aGUgZGF0YSB0eXBlIHVzZWRcbiAgICAgICAgaWYgKGlzU3RyaW5nKHByb3ApICYmIHN0YXJ0c1dpdGgocHJvcCwgJ3N1YnNjcmliZScpKSB7XG4gICAgICAgICAgY29uc3QgZGF0YVR5cGUgPVxuICAgICAgICAgICAgZ2V0RGF0YVByb3ZpZGVyRGF0YVR5cGVGcm9tRnVuY3Rpb25OYW1lPERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdPihwcm9wKTtcbiAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gcnVuIHRoZSBjYWxsYmFjayB3aGVuIGRhdGEgY2hhbmdlcy4gQWxzbyBpbW1lZGlhdGVseSBjYWxscyBjYWxsYmFjayB3aXRoIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgbmV3RGF0YVByb3ZpZGVyTWV0aG9kID0gY3JlYXRlRGF0YVByb3ZpZGVyU3Vic2NyaWJlcjxEYXRhUHJvdmlkZXJOYW1lPihcbiAgICAgICAgICAgIGRhdGFQcm92aWRlclByb21pc2UsXG4gICAgICAgICAgICBvbkRpZFVwZGF0ZSxcbiAgICAgICAgICAgIGRhdGFUeXBlLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgaXQncyBub3QgYSBzdWJzY3JpYmUgYW5kIHRoZSBkYXRhIHByb3ZpZGVyIGVuZ2luZSBpcyBwcm92aWRlZCAobWVhbmluZyB0aGlzIHByb3h5IGlzXG4gICAgICAgIC8vIGJlaW5nIGNyZWF0ZWQgZm9yIGEgbG9jYWwgZGF0YSBwcm92aWRlciksIHRyeSB0byBnZXQgdGhlIGVuZ2luZSBtZXRob2RcbiAgICAgICAgZWxzZSBpZiAoZGF0YVByb3ZpZGVyRW5naW5lKSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBnZXQgdGhlIGVuZ2luZSBtZXRob2QgYW5kIGJpbmQgaXRcbiAgICAgICAgICAvLyBUaGVyZSBpc24ndCBpbmRleGluZyBvbiBJRGF0YVByb3ZpZGVyRW5naW5lIHNvIG5vcm1hbCBvYmplY3RzIGNvdWxkIGJlIHVzZWQsXG4gICAgICAgICAgLy8gYnV0IG5vdyBtZW1iZXJzIGNhbid0IGJlIGFjY2Vzc2VkIGJ5IGluZGV4aW5nIGluIERhdGFQcm92aWRlclNlcnZpY2VcbiAgICAgICAgICAvLyBUT0RPOiBmaXggaXQgc28gaXQgaXMgaW5kZXhhYmxlIGJ1dCBjYW4gaGF2ZSBzcGVjaWZpYyBtZW1iZXJzXG4gICAgICAgICAgbmV3RGF0YVByb3ZpZGVyTWV0aG9kID1cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uICovXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIG9ialtwcm9wIGFzIGtleW9mIHR5cGVvZiBvYmpdIGFzIElEYXRhUHJvdmlkZXJFbmdpbmU8XG4gICAgICAgICAgICAgICAgRGF0YVByb3ZpZGVyVHlwZXNbRGF0YVByb3ZpZGVyTmFtZV1cbiAgICAgICAgICAgICAgPlthbnldXG4gICAgICAgICAgICApPy5iaW5kKGRhdGFQcm92aWRlckVuZ2luZSk7XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZSB0aGUgYm91bmQgZW5naW5lIG1ldGhvZCBvbiB0aGUgZGF0YSBwcm92aWRlciB0byBiZSBydW4gbGF0ZXJcbiAgICAgICAgaWYgKG5ld0RhdGFQcm92aWRlck1ldGhvZCkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzbid0IGluZGV4aW5nIG9uIElEYXRhUHJvdmlkZXJFbmdpbmUgc28gbm9ybWFsIG9iamVjdHMgY291bGQgYmUgdXNlZCxcbiAgICAgICAgICAvLyBidXQgbm93IG1lbWJlcnMgY2FuJ3QgYmUgYWNjZXNzZWQgYnkgaW5kZXhpbmcgaW4gRGF0YVByb3ZpZGVyU2VydmljZVxuICAgICAgICAgIC8vIFRPRE86IGZpeCBpdCBzbyBpdCBpcyBpbmRleGFibGUgYnV0IGNhbiBoYXZlIHNwZWNpZmljIG1lbWJlcnNcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICAoZGF0YVByb3ZpZGVySW50ZXJuYWwgYXMgYW55KVtwcm9wXSA9IG5ld0RhdGFQcm92aWRlck1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RGF0YVByb3ZpZGVyTWV0aG9kO1xuICAgICAgfSxcbiAgICAgIHNldChvYmosIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIC8vIFdlIGNyZWF0ZSBgc3Vic2NyaWJlPGRhdGFfdHlwZT5gIGFuZCBgbm90aWZ5VXBkYXRlYCBmb3IgZXh0ZW5zaW9ucywgYW5kXG4gICAgICAgIC8vIGBzdWJzY3JpYmU8ZGF0YV90eXBlPmAgdXNlcyBgZ2V0PGRhdGFfdHlwZT5gIGludGVybmFsbHksIHNvIHRob3NlIDMgcHJvcGVydGllcyBjYW4ndFxuICAgICAgICAvLyBjaGFuZ2UgYWZ0ZXIgdGhlIGRhdGEgcHJvdmlkZXIgaGFzIGJlZW4gY3JlYXRlZCBvciBiYWQgdGhpbmdzIHdpbGwgaGFwcGVuLlxuICAgICAgICAvLyBMb2NhbGx5IHRoZSBkYXRhIHByb3ZpZGVyIGVuZ2luZSBoYXMgZ2V0dGVycyBhbmQgdGhlIGRhdGEgcHJvdmlkZXIgc2VydmljZSBjcmVhdGVzIHRoZVxuICAgICAgICAvLyBzdWJzY3JpYmVycyBhbmQgbm90aWZ5VXBkYXRlLlxuICAgICAgICAvLyBSZW1vdGVseSB0aGlzIHByb3h5IGNyZWF0ZXMgc3Vic2NyaWJlcnMsIHRoZXJlIGlzIG5vIG5lZWQgZm9yIG5vdGlmeVVwZGF0ZSwgYW5kIHRoZVxuICAgICAgICAvLyBuZXR3b3JrIG9iamVjdCBzZXJ2aWNlIHNldHMgZ2V0dGVycyBhcyBuZXR3b3JrIHJlcXVlc3QgZnVuY3Rpb25zIHRocm91Z2ggdGhpcyBwcm94eS5cbiAgICAgICAgLy8gVGhlc2UgcmVxdWVzdCBmdW5jdGlvbnMgc2hvdWxkIG5vdCBoYXZlIHRvIGNoYW5nZSBhZnRlciB0aGV5J3JlIHNldCBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc1N0cmluZyhwcm9wKSAmJlxuICAgICAgICAgIChzdGFydHNXaXRoKHByb3AsICdnZXQnKSB8fCBzdGFydHNXaXRoKHByb3AsICdzdWJzY3JpYmUnKSB8fCBwcm9wID09PSAnbm90aWZ5VXBkYXRlJykgJiZcbiAgICAgICAgICAocHJvcCBpbiBvYmogfHwgcHJvcCBpbiBkYXRhUHJvdmlkZXJJbnRlcm5hbClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBJZiB3ZSBjYWNoZWQgYSBwcm9wZXJ0eSBwcmV2aW91c2x5LCBwdXJnZSB0aGUgY2FjaGUgZm9yIHRoYXQgcHJvcGVydHkgc2luY2UgaXQgaXMgY2hhbmdpbmcuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICAgICAgICBpZiAoKGRhdGFQcm92aWRlckludGVybmFsIGFzIGFueSlbcHJvcF0pIGRlbGV0ZSAoZGF0YVByb3ZpZGVySW50ZXJuYWwgYXMgYW55KVtwcm9wXTtcblxuICAgICAgICAvLyBBY3R1YWxseSBzZXQgdGhlIHByb3ZpZGVkIHByb3BlcnR5XG4gICAgICAgIFJlZmxlY3Quc2V0KG9iaiwgcHJvcCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBoYXMob2JqLCBwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wIGluIGRhdGFQcm92aWRlckludGVybmFsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gVGhpcyBwcm94eSBwcm92aWRlcyBzdWJzY3JpYmUgbWV0aG9kcywgc28gbWFrZSBzdXJlIHRoZXkgc2VlbSB0byBleGlzdFxuICAgICAgICBpZiAoaXNTdHJpbmcocHJvcCkgJiYgc3RhcnRzV2l0aChwcm9wLCAnc3Vic2NyaWJlJykpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gcHJvcCBpbiBvYmo7XG4gICAgICB9LFxuICAgIH0sXG4gICkgYXMgRGF0YVByb3ZpZGVySW50ZXJuYWw8RGF0YVByb3ZpZGVyVHlwZXNbRGF0YVByb3ZpZGVyTmFtZV0+O1xuXG4gIHJldHVybiBkYXRhUHJvdmlkZXI7XG59XG5cbi8qKlxuICogTWFwcyBmcm9tIHVwZGF0ZSBpbnN0cnVjdGlvbnMgcmV0dXJuZWQgZnJvbSBgbm90aWZ5VXBkYXRlYCBvciBhIGBzZXQ8ZGF0YV90eXBlPmAgZnVuY3Rpb24gdG8gYW5cbiAqIHVwZGF0ZSBldmVudCB0byBzZW5kIG92ZXIgdGhlIG5ldHdvcmsgdG8gaW5mb3JtIHN1YnNjcmliZXJzIHRvIHVwZGF0ZSB0aGVpciBkYXRhXG4gKlxuICogQHBhcmFtIHVwZGF0ZUluc3RydWN0aW9ucyBVcGRhdGUgaW5zdHJ1Y3Rpb25zIHRvIHJlZm9ybWF0IGludG8gYW4gdXBkYXRlIGV2ZW50XG4gKiBAcGFyYW0gZGF0YVR5cGUgVGhlIGRhdGEgdHlwZSBvZiB0aGUgdXBkYXRlIGluc3RydWN0aW9ucyAoZS5nLiAnVmVyc2UnIGlmIHVwZGF0ZSBpbnN0cnVjdGlvbnNcbiAqICAgY2FtZSBmcm9tIGBzZXRWZXJzZWApIG9yIGB1bmRlZmluZWRgIGlmIGJlaW5nIG1hcHBlZCBmb3IgYG5vdGlmeVVwZGF0ZWAsIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhXG4gKiAgIGRhdGEgdHlwZVxuICogQHJldHVybnMgVXBkYXRlIGV2ZW50IGluZm9ybWF0aW9uIHRvIHNlbmQgaW4gdGhlIGBvbkRpZFVwZGF0ZWAgZXZlbnQgZW1pdHRlciB0byB0ZWxsIHN1YnNjcmliZXJzXG4gKiAgIHRvIHVwZGF0ZVxuICovXG5mdW5jdGlvbiBtYXBVcGRhdGVJbnN0cnVjdGlvbnNUb1VwZGF0ZUV2ZW50PFREYXRhVHlwZXMgZXh0ZW5kcyBEYXRhUHJvdmlkZXJEYXRhVHlwZXM+KFxuICB1cGRhdGVJbnN0cnVjdGlvbnM6IERhdGFQcm92aWRlclVwZGF0ZUluc3RydWN0aW9uczxURGF0YVR5cGVzPiB8IHVuZGVmaW5lZCxcbiAgZGF0YVR5cGU6IERhdGFUeXBlTmFtZXM8VERhdGFUeXBlcz4gfCB1bmRlZmluZWQsXG4pOiBEYXRhUHJvdmlkZXJVcGRhdGVJbnN0cnVjdGlvbnM8VERhdGFUeXBlcz4ge1xuICAvLyBJZiB0aGV5IHdhbnQgdG8gdXBkYXRlIGFsbCBkYXRhIHR5cGVzLCBsZXQgdGhlbSBkbyBpdFxuICBpZiAodXBkYXRlSW5zdHJ1Y3Rpb25zID09PSAnKicpIHJldHVybiB1cGRhdGVJbnN0cnVjdGlvbnM7XG4gIC8vIElmIHRoZSB1cGRhdGUgaW5zdHJ1Y3Rpb25zIGFyZSBhIHN0cmluZyBvdGhlciB0aGFuICcqJyAoaG9wZWZ1bGx5IG9uZSBvZiB0aGUgZGF0YSB0eXBlcyksIHNlbmRcbiAgLy8gYW4gdXBkYXRlIHNwZWNpZmljYWxseSBmb3IgdGhhdCBkYXRhIHR5cGVcbiAgaWYgKGlzU3RyaW5nKHVwZGF0ZUluc3RydWN0aW9ucykpIHJldHVybiBbdXBkYXRlSW5zdHJ1Y3Rpb25zXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlSW5zdHJ1Y3Rpb25zKSkge1xuICAgIC8vIElmIHRoZSB1cGRhdGUgaW5zdHJ1Y3Rpb25zIGFyZSBhIG5vbi1lbXB0eSBhcnJheSwgc2VuZCBpdFxuICAgIGlmICh1cGRhdGVJbnN0cnVjdGlvbnMubGVuZ3RoID4gMCkgcmV0dXJuIHVwZGF0ZUluc3RydWN0aW9ucztcbiAgICAvLyBJZiB0aGUgdXBkYXRlIGluc3RydWN0aW9ucyBhcmUgYW4gZW1wdHkgYXJyYXksIGRvbid0IHVwZGF0ZSAoY291bnQgYXMgZmFsc3kpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIElmIHRoZSB1cGRhdGUgaW5zdHJ1Y3Rpb25zIGFyZSB0cnV0aHkgYnV0IG5laXRoZXIgYW4gYXJyYXkgb3IgYSBzdHJpbmcgb3IgJyonLCBpdCBtZWFucyB3ZSBzaG91bGQganVzdCBzZW5kIGFuIHVwZGF0ZSBmb3IgaXRzIG93biBkYXRhIHR5cGVcbiAgLy8gSG93ZXZlciwgd2UgZG9uJ3QgaGF2ZSBhIGRhdGEgdHlwZSBpZiB3ZSdyZSBtYXBwaW5nIGZvciBgbm90aWZ5VXBkYXRlYCwgc28ganVzdCByZXR1cm4gJyonIHRvIHVwZGF0ZSBldmVyeXRoaW5nLlxuICBpZiAodXBkYXRlSW5zdHJ1Y3Rpb25zKSByZXR1cm4gZGF0YVR5cGUgIT09IHVuZGVmaW5lZCA/IFtkYXRhVHlwZV0gOiAnKic7XG4gIC8vIElmIHRoZSB1cGRhdGUgaW5zdHJ1Y3Rpb25zIGFyZSBmYWxzeSwgZG8gbm90IHVwZGF0ZVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSlNET0MgU09VUkNFIERhdGFQcm92aWRlclNlcnZpY2VEZWNvcmF0b3JzSWdub3JlXG4gKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIHRoYXQgbWFya3MgYSBkYXRhIHByb3ZpZGVyIGVuZ2luZSBgc2V0X19fYCBvciBgZ2V0X19fYCBtZXRob2QgdG8gYmUgaWdub3JlZC5cbiAqIHBhcGkgd2lsbCBub3QgbGF5ZXIgb3ZlciB0aGVzZSBtZXRob2RzIG9yIGNvbnNpZGVyIHRoZW0gdG8gYmUgZGF0YSB0eXBlIG1ldGhvZHNcbiAqXG4gKiBAZXhhbXBsZSBVc2UgdGhpcyBhcyBhIGRlY29yYXRvciBvbiBhIGNsYXNzJ3MgbWV0aG9kOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNsYXNzIE15RGF0YVByb3ZpZGVyRW5naW5lIHtcbiAqIO+8oHBhcGkuZGF0YVByb3ZpZGVycy5kZWNvcmF0b3JzLmlnbm9yZVxuICogYXN5bmMgZ2V0SW50ZXJuYWwoKSB7fVxuICogfVxuICogYGBgXG4gKlxuICogV0FSTklORzogRG8gbm90IGNvcHkgYW5kIHBhc3RlIHRoaXMgZXhhbXBsZS4gVGhlIGBAYCBzeW1ib2wgZG9lcyBub3QgcmVuZGVyIGNvcnJlY3RseSBpbiBKU0RvY1xuICogY29kZSBibG9ja3MsIHNvIGEgZGlmZmVyZW50IHVuaWNvZGUgY2hhcmFjdGVyIHdhcyB1c2VkLiBQbGVhc2UgdXNlIGEgbm9ybWFsIGBAYCB3aGVuIHVzaW5nIGFcbiAqIGRlY29yYXRvci5cbiAqXG4gKiBPUlxuICpcbiAqIEBleGFtcGxlIENhbGwgdGhpcyBmdW5jdGlvbiBzaWduYXR1cmUgb24gYW4gb2JqZWN0J3MgbWV0aG9kOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IG15RGF0YVByb3ZpZGVyRW5naW5lID0ge1xuICogICBhc3luYyBnZXRJbnRlcm5hbCgpIHt9LFxuICogfTtcbiAqIHBhcGkuZGF0YVByb3ZpZGVycy5kZWNvcmF0b3JzLmlnbm9yZShkYXRhUHJvdmlkZXJFbmdpbmUuZ2V0SW50ZXJuYWwpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG1ldGhvZCBUaGUgbWV0aG9kIHRvIGlnbm9yZVxuICovXG5mdW5jdGlvbiBpZ25vcmUobWV0aG9kOiBGdW5jdGlvbiAmIHsgaXNJZ25vcmVkPzogYm9vbGVhbiB9KTogdm9pZDtcbi8qKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIHRoYXQgbWFya3MgYSBkYXRhIHByb3ZpZGVyIGVuZ2luZSBgc2V0X19fYCBvciBgZ2V0X19fYCBtZXRob2QgdG8gYmUgaWdub3JlZC5cbiAqIHBhcGkgd2lsbCBub3QgbGF5ZXIgb3ZlciB0aGVzZSBtZXRob2RzIG9yIGNvbnNpZGVyIHRoZW0gdG8gYmUgZGF0YSB0eXBlIG1ldGhvZHNcbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSBjbGFzcyB0aGF0IGhhcyB0aGUgbWV0aG9kIHRvIGlnbm9yZVxuICogQHBhcmFtIG1lbWJlciBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGlnbm9yZVxuICpcbiAqICAgTm90ZTogdGhpcyBpcyB0aGUgc2lnbmF0dXJlIHRoYXQgcHJvdmlkZXMgdGhlIGFjdHVhbCBkZWNvcmF0b3IgZnVuY3Rpb25hbGl0eS4gSG93ZXZlciwgc2luY2VcbiAqICAgdXNlcnMgd2lsbCBub3QgYmUgdXNpbmcgdGhpcyBzaWduYXR1cmUsIHRoZSBleGFtcGxlIHVzYWdlIGlzIHByb3ZpZGVkIGluIHRoZSBzaWduYXR1cmUgYWJvdmUuXG4gKi9cbmZ1bmN0aW9uIGlnbm9yZSh0YXJnZXQ6IG9iamVjdCwgbWVtYmVyOiBzdHJpbmcpOiB2b2lkO1xuLy8gV2UgZG9uJ3QgY2FyZSB3aGF0IHR5cGUgdGhlIGRlY29yYXRlZCBvYmplY3QgaXMuIEp1c3Qgd2FudCB0byBzZXQgc29tZSBmdW5jdGlvbiBtZXRhZGF0YVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGlnbm9yZSh0YXJnZXQ6IGFueSwgbWVtYmVyPzogc3RyaW5nKTogdm9pZCB7XG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGFyZ2V0LmlzSWdub3JlZCA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFtZW1iZXIpIHJldHVybjtcblxuICB0YXJnZXRbbWVtYmVyXS5pc0lnbm9yZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIEpTRE9DIFNPVVJDRSBEYXRhUHJvdmlkZXJTZXJ2aWNlRGVjb3JhdG9yc0RvTm90Tm90aWZ5XG4gKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIHRoYXQgbWFya3MgYSBkYXRhIHByb3ZpZGVyIGVuZ2luZSBgc2V0PGRhdGFfdHlwZT5gIG1ldGhvZCBub3QgdG8gYXV0b21hdGljYWxseVxuICogZW1pdCBhbiB1cGRhdGUgYW5kIG5vdGlmeSBzdWJzY3JpYmVycyBvZiBhIGNoYW5nZSB0byB0aGUgZGF0YS4gcGFwaSB3aWxsIHN0aWxsIGNvbnNpZGVyIHRoZVxuICogYHNldDxkYXRhX3R5cGU+YCBtZXRob2QgdG8gYmUgYSBkYXRhIHR5cGUgbWV0aG9kLCBidXQgaXQgd2lsbCBub3QgbGF5ZXIgb3ZlciBpdCB0byBlbWl0IHVwZGF0ZXMuXG4gKlxuICogQGV4YW1wbGUgVXNlIHRoaXMgYXMgYSBkZWNvcmF0b3Igb24gYSBjbGFzcydzIG1ldGhvZDpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBNeURhdGFQcm92aWRlckVuZ2luZSB7XG4gKiDvvKBwYXBpLmRhdGFQcm92aWRlcnMuZGVjb3JhdG9ycy5kb05vdE5vdGlmeVxuICogYXN5bmMgc2V0VmVyc2UoKSB7fVxuICogfVxuICogYGBgXG4gKlxuICogV0FSTklORzogRG8gbm90IGNvcHkgYW5kIHBhc3RlIHRoaXMgZXhhbXBsZS4gVGhlIGBAYCBzeW1ib2wgZG9lcyBub3QgcmVuZGVyIGNvcnJlY3RseSBpbiBKU0RvY1xuICogY29kZSBibG9ja3MsIHNvIGEgZGlmZmVyZW50IHVuaWNvZGUgY2hhcmFjdGVyIHdhcyB1c2VkLiBQbGVhc2UgdXNlIGEgbm9ybWFsIGBAYCB3aGVuIHVzaW5nIGFcbiAqIGRlY29yYXRvci5cbiAqXG4gKiBPUlxuICpcbiAqIEBleGFtcGxlIENhbGwgdGhpcyBmdW5jdGlvbiBzaWduYXR1cmUgb24gYW4gb2JqZWN0J3MgbWV0aG9kOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IG15RGF0YVByb3ZpZGVyRW5naW5lID0ge1xuICogICBhc3luYyBzZXRWZXJzZSgpIHt9LFxuICogfTtcbiAqIHBhcGkuZGF0YVByb3ZpZGVycy5kZWNvcmF0b3JzLmlnbm9yZShkYXRhUHJvdmlkZXJFbmdpbmUuc2V0VmVyc2UpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG1ldGhvZCBUaGUgbWV0aG9kIG5vdCB0byBsYXllciBvdmVyIHRvIHNlbmQgYW4gYXV0b21hdGljIHVwZGF0ZVxuICovXG5mdW5jdGlvbiBkb05vdE5vdGlmeShtZXRob2Q6IEZ1bmN0aW9uICYgeyBkb05vdE5vdGlmeT86IGJvb2xlYW4gfSk6IHZvaWQ7XG4vKipcbiAqIERlY29yYXRvciBmdW5jdGlvbiB0aGF0IG1hcmtzIGEgZGF0YSBwcm92aWRlciBlbmdpbmUgYHNldDxkYXRhX3R5cGU+YCBtZXRob2Qgbm90IHRvIGF1dG9tYXRpY2FsbHlcbiAqIGVtaXQgYW4gdXBkYXRlIGFuZCBub3RpZnkgc3Vic2NyaWJlcnMgb2YgYSBjaGFuZ2UgdG8gdGhlIGRhdGEuIHBhcGkgd2lsbCBzdGlsbCBjb25zaWRlciB0aGVcbiAqIGBzZXQ8ZGF0YV90eXBlPmAgbWV0aG9kIHRvIGJlIGEgZGF0YSB0eXBlIG1ldGhvZCwgYnV0IGl0IHdpbGwgbm90IGxheWVyIG92ZXIgaXQgdG8gZW1pdCB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgVGhlIGNsYXNzIHRoYXQgaGFzIHRoZSBtZXRob2Qgbm90IHRvIGxheWVyIG92ZXIgdG8gc2VuZCBhbiBhdXRvbWF0aWMgdXBkYXRlXG4gKiBAcGFyYW0gbWVtYmVyIFRoZSBuYW1lIG9mIHRoZSBtZXRob2Qgbm90IHRvIGxheWVyIG92ZXIgdG8gc2VuZCBhbiBhdXRvbWF0aWMgdXBkYXRlXG4gKlxuICogICBOb3RlOiB0aGlzIGlzIHRoZSBzaWduYXR1cmUgdGhhdCBwcm92aWRlcyB0aGUgYWN0dWFsIGRlY29yYXRvciBmdW5jdGlvbmFsaXR5LiBIb3dldmVyLCBzaW5jZVxuICogICB1c2VycyB3aWxsIG5vdCBiZSB1c2luZyB0aGlzIHNpZ25hdHVyZSwgdGhlIGV4YW1wbGUgdXNhZ2UgaXMgcHJvdmlkZWQgaW4gdGhlIHNpZ25hdHVyZSBhYm92ZS5cbiAqL1xuZnVuY3Rpb24gZG9Ob3ROb3RpZnkodGFyZ2V0OiBvYmplY3QsIG1lbWJlcjogc3RyaW5nKTogdm9pZDtcbi8vIFdlIGRvbid0IGNhcmUgd2hhdCB0eXBlIHRoZSBkZWNvcmF0ZWQgb2JqZWN0IGlzLiBKdXN0IHdhbnQgdG8gc2V0IHNvbWUgZnVuY3Rpb24gbWV0YWRhdGFcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBkb05vdE5vdGlmeSh0YXJnZXQ6IGFueSwgbWVtYmVyPzogc3RyaW5nKTogdm9pZCB7XG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGFyZ2V0LmRvTm90Tm90aWZ5ID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIW1lbWJlcikgcmV0dXJuO1xuXG4gIHRhcmdldFttZW1iZXJdLmRvTm90Tm90aWZ5ID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBKU0RPQyBTT1VSQ0UgRGF0YVByb3ZpZGVyU2VydmljZURlY29yYXRvcnNcbiAqXG4gKiBBIGNvbGxlY3Rpb24gb2YgZGVjb3JhdG9ycyB0byBiZSB1c2VkIHdpdGggdGhlIGRhdGEgcHJvdmlkZXIgc2VydmljZVxuICpcbiAqIEBleGFtcGxlIFRvIHVzZSB0aGUgYGlnbm9yZWAgYSBkZWNvcmF0b3Igb24gYSBjbGFzcydzIG1ldGhvZDpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBNeURhdGFQcm92aWRlckVuZ2luZSB7XG4gKiDvvKBwYXBpLmRhdGFQcm92aWRlcnMuZGVjb3JhdG9ycy5pZ25vcmVcbiAqIGFzeW5jIGdldEludGVybmFsKCkge31cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdBUk5JTkc6IERvIG5vdCBjb3B5IGFuZCBwYXN0ZSB0aGlzIGV4YW1wbGUuIFRoZSBgQGAgc3ltYm9sIGRvZXMgbm90IHJlbmRlciBjb3JyZWN0bHkgaW4gSlNEb2NcbiAqIGNvZGUgYmxvY2tzLCBzbyBhIGRpZmZlcmVudCB1bmljb2RlIGNoYXJhY3RlciB3YXMgdXNlZC4gUGxlYXNlIHVzZSBhIG5vcm1hbCBgQGAgd2hlbiB1c2luZyBhXG4gKiBkZWNvcmF0b3IuXG4gKi9cbmNvbnN0IGRlY29yYXRvcnMgPSB7XG4gIC8qKiBKU0RPQyBERVNUSU5BVElPTiBEYXRhUHJvdmlkZXJTZXJ2aWNlRGVjb3JhdG9yc0lnbm9yZSAqL1xuICBpZ25vcmUsXG4gIC8qKiBKU0RPQyBERVNUSU5BVElPTiBEYXRhUHJvdmlkZXJTZXJ2aWNlRGVjb3JhdG9yc0RvTm90Tm90aWZ5ICovXG4gIGRvTm90Tm90aWZ5LFxufTtcblxuLyoqXG4gKiBXcmFwIGEgZGF0YSBwcm92aWRlciBlbmdpbmUgdG8gY3JlYXRlIGEgZGF0YSBwcm92aWRlciB0aGF0IGhhbmRsZXMgc3Vic2NyaXB0aW9ucyBmb3IgaXQuXG4gKlxuICogTm90ZTogVGhpcyBzaG91bGQgb25seSBydW4gbG9jYWxseSB3aGVuIHlvdSBoYXZlIHRoZSBkYXRhIHByb3ZpZGVyIGVuZ2luZS4gVGhlIHJlbW90ZSBkYXRhXG4gKiBwcm92aWRlciBpcyBwcmV0dHkgbXVjaCBqdXN0IGEgbmV0d29yayBvYmplY3RcbiAqXG4gKiBXQVJOSU5HOiB0aGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHByb3ZpZGVkIG9iamVjdC4gSXRzIGBub3RpZnlVcGRhdGVgIGFuZCBgc2V0PGRhdGFfdHlwZT5gXG4gKiBtZXRob2RzIGFyZSBsYXllcmVkIG92ZXIgdG8gZmFjaWxpdGF0ZSBkYXRhIHByb3ZpZGVyIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIGRhdGFQcm92aWRlckVuZ2luZSBQcm92aWRlciBlbmdpbmUgdGhhdCBoYW5kbGVzIHNldHRpbmcgYW5kIGdldHRpbmcgZGF0YSBhcyB3ZWxsIGFzXG4gKiAgIGluZm9ybWluZyB3aGljaCBsaXN0ZW5lcnMgc2hvdWxkIGdldCB3aGF0IHVwZGF0ZXNcbiAqIEBwYXJhbSBkYXRhUHJvdmlkZXJQcm9taXNlIFByb21pc2UgdG8gdGhlIGRhdGEgcHJvdmlkZXIncyBuZXR3b3JrIG9iamVjdFxuICogQHBhcmFtIG9uRGlkVXBkYXRlRW1pdHRlciBFdmVudCBlbWl0dGVyIHRvIHVzZSBmb3IgaW5mb3JtaW5nIHN1YnNjcmliZXJzIG9mIHVwZGF0ZXMuIFRoZSBldmVudFxuICogICBqdXN0IHJldHVybnMgd2hhdCBzZXQgcmV0dXJucyAoc2hvdWxkIGJlIHRydWUgYWNjb3JkaW5nIHRvIElEYXRhUHJvdmlkZXJFbmdpbmUpXG4gKiBAcmV0dXJucyBEYXRhIHByb3ZpZGVyIGxheWVyaW5nIG92ZXIgdGhlIHByb3ZpZGVkIGRhdGEgcHJvdmlkZXIgZW5naW5lXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRGF0YVByb3ZpZGVyPERhdGFQcm92aWRlck5hbWUgZXh0ZW5kcyBEYXRhUHJvdmlkZXJOYW1lcz4oXG4gIGRhdGFQcm92aWRlckVuZ2luZTogSURhdGFQcm92aWRlckVuZ2luZTxEYXRhUHJvdmlkZXJUeXBlc1tEYXRhUHJvdmlkZXJOYW1lXT4sXG4gIGRhdGFQcm92aWRlclByb21pc2U6IFByb21pc2U8RGF0YVByb3ZpZGVyc1tEYXRhUHJvdmlkZXJOYW1lXT4sXG4gIG9uRGlkVXBkYXRlRW1pdHRlcjogUGxhdGZvcm1FdmVudEVtaXR0ZXI8XG4gICAgRGF0YVByb3ZpZGVyVXBkYXRlSW5zdHJ1Y3Rpb25zPERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdPlxuICA+LFxuKTogRGF0YVByb3ZpZGVySW50ZXJuYWw8RGF0YVByb3ZpZGVyVHlwZXNbRGF0YVByb3ZpZGVyTmFtZV0+IHtcbiAgLy8gV2UgbmVlZCBhbiB1bnR5cGVkIHZlcnNpb24gb2YgdGhlIERQRSBzbyB3ZSBjYW4gZ2V0IGFuZCBzZXQgc3RyaW5nLXRlbXBsYXRlLW1hcHBlZC10eXBlXG4gIC8vIHByb3BlcnRpZXMgb24gaXQgZXZlbiB0aG91Z2ggdGhlIHN0cmluZ3MgdGhhdCBnZXQgdGVtcGxhdGVkIGFyZSBvbmUgb2YgbWFueSBwb3NzaWJpbGl0aWVzLlxuICAvLyBJdCBzZWVtcyBUeXBlU2NyaXB0IGlzIHVuYWJsZSB0byBkaXN0aW5ndWlzaCB0aGF0XG4gIC8vIGBEYXRhVHlwZU5hbWVzPERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdPmAgaXMgb25lIHNwZWNpZmljIHNldCBvZiBuYW1lcyBvZiBkYXRhIHR5cGVzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICBjb25zdCBkYXRhUHJvdmlkZXJFbmdpbmVVbnR5cGVkID0gZGF0YVByb3ZpZGVyRW5naW5lIGFzIHR5cGVvZiBkYXRhUHJvdmlkZXJFbmdpbmUgJiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBba2V5OiBzdHJpbmddOiBhbnk7XG4gIH07XG4gIC8vIEZpZ3VyZSBvdXQgdGhlIGF2YWlsYWJsZSBnZXQvc2V0IG1ldGhvZHMnIGRhdGEgdHlwZXNcbiAgY29uc3QgZGF0YVR5cGVzID0gZ3JvdXBCeTxcbiAgICBzdHJpbmcsXG4gICAgJ2dldCcgfCAnc2V0JyB8ICdvdGhlcicsXG4gICAgRGF0YVR5cGVOYW1lczxEYXRhUHJvdmlkZXJUeXBlc1tEYXRhUHJvdmlkZXJOYW1lXT5cbiAgPihcbiAgICBbLi4uZ2V0QWxsT2JqZWN0RnVuY3Rpb25OYW1lcyhkYXRhUHJvdmlkZXJFbmdpbmUpXSxcbiAgICAoZm5OYW1lKSA9PiB7XG4gICAgICAvLyBJZiB0aGUgZnVuY3Rpb24gd2FzIGRlY29yYXRlZCB3aXRoIEBpZ25vcmUsIGRvIG5vdCBjb25zaWRlciBpdCBhIHNwZWNpYWwgZnVuY3Rpb25cbiAgICAgIGlmIChkYXRhUHJvdmlkZXJFbmdpbmVVbnR5cGVkW2ZuTmFtZV0uaXNJZ25vcmVkKSByZXR1cm4gJ290aGVyJztcblxuICAgICAgaWYgKHN0YXJ0c1dpdGgoZm5OYW1lLCAnZ2V0JykpIHJldHVybiAnZ2V0JztcbiAgICAgIGlmIChzdGFydHNXaXRoKGZuTmFtZSwgJ3NldCcpKSByZXR1cm4gJ3NldCc7XG4gICAgICByZXR1cm4gJ290aGVyJztcbiAgICB9LFxuICAgIChmbk5hbWUsIGZuVHlwZSkgPT4ge1xuICAgICAgLy8gSWYgaXQncyBub3QgYSBnZXQgb3IgYSBzZXQsIGp1c3QgcmV0dXJuIGFuIGVtcHR5IHN0cmluZy4gV2UgYXJlbid0IHBsYW5uaW5nIHRvIHVzZSB0aGlzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICAgIGlmIChmblR5cGUgPT09ICdvdGhlcicpIHJldHVybiAnJyBhcyBEYXRhVHlwZU5hbWVzPERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdPjtcblxuICAgICAgLy8gR3JhYiB0aGUgZGF0YSB0eXBlIG91dCBvZiB0aGUgZnVuY3Rpb24gbmFtZXNcbiAgICAgIHJldHVybiBnZXREYXRhUHJvdmlkZXJEYXRhVHlwZUZyb21GdW5jdGlvbk5hbWU8RGF0YVByb3ZpZGVyVHlwZXNbRGF0YVByb3ZpZGVyTmFtZV0+KGZuTmFtZSk7XG4gICAgfSxcbiAgKTtcblxuICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBkYXRhIHByb3ZpZGVyIGVuZ2luZSBoYXMgbWF0Y2hpbmcgZ2V0IGFuZCBzZXQgZnVuY3Rpb25zXG4gIGlmIChcbiAgICBkYXRhVHlwZXMuZ2V0KCdnZXQnKT8ubGVuZ3RoICE9PSBkYXRhVHlwZXMuZ2V0KCdzZXQnKT8ubGVuZ3RoIHx8XG4gICAgZGF0YVR5cGVzLmdldCgnZ2V0Jyk/LnNvbWUoKGdldERhdGFUeXBlKSA9PiAhZGF0YVR5cGVzLmdldCgnc2V0Jyk/LmluY2x1ZGVzKGdldERhdGFUeXBlKSlcbiAgKVxuICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBwcm92aWRlciBlbmdpbmUgZG9lcyBub3QgaGF2ZSBtYXRjaGluZyBnZXQgYW5kIHNldCBmdW5jdGlvbnMhJyk7XG5cbiAgLy8gTGF5ZXIgb3ZlciBkYXRhIHByb3ZpZGVyIGVuZ2luZSBtZXRob2RzIHRvIGdpdmUgaXQgY29udHJvbCBvdmVyIGVtaXR0aW5nIHVwZGF0ZXNcblxuICAvLyBMYXllciBvdmVyIHRoZSBkYXRhIHByb3ZpZGVyIGVuZ2luZSdzIG5vdGlmeVVwZGF0ZSB3aXRoIG9uZSB0aGF0IGFjdHVhbGx5IGVtaXRzIGFuIHVwZGF0ZVxuICAvLyBvciBpZiB0aGUgZHBlIGRvZXNuJ3QgaGF2ZSBub3RpZnlVcGRhdGUsIGdpdmUgaXQgb25lXG4gIGNvbnN0IGRwZU5vdGlmeVVwZGF0ZSA9IGRhdGFQcm92aWRlckVuZ2luZS5ub3RpZnlVcGRhdGVcbiAgICA/IGRhdGFQcm92aWRlckVuZ2luZS5ub3RpZnlVcGRhdGUuYmluZChkYXRhUHJvdmlkZXJFbmdpbmUpXG4gICAgOiB1bmRlZmluZWQ7XG4gIGRhdGFQcm92aWRlckVuZ2luZS5ub3RpZnlVcGRhdGUgPSAodXBkYXRlSW5zdHJ1Y3Rpb25zID0gdHJ1ZSwgLi4uYXJncykgPT4ge1xuICAgIC8vIGVtaXQgYW4gdXBkYXRlIGlmIHVwZGF0ZUluc3RydWN0aW9ucyBpbmRpY2F0ZSB0byBkbyBzb1xuICAgIGNvbnN0IHVwZGF0ZUV2ZW50UmVzdWx0ID0gbWFwVXBkYXRlSW5zdHJ1Y3Rpb25zVG9VcGRhdGVFdmVudDxcbiAgICAgIERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdXG4gICAgPih1cGRhdGVJbnN0cnVjdGlvbnMsIHVuZGVmaW5lZCk7XG4gICAgLy8gUnVuIHRoZSBkYXRhIHByb3ZpZGVyIGVuZ2luZSdzIG9yaWdpbmFsIGBub3RpZnlVcGRhdGVgIHdpdGggdGhlIHVwZGF0ZSByZXN1bHQgYmVmb3JlIHdlIHNlbmQgdGhlIHVwZGF0ZVxuICAgIGlmIChkcGVOb3RpZnlVcGRhdGUpIGRwZU5vdGlmeVVwZGF0ZSh1cGRhdGVFdmVudFJlc3VsdCwgLi4uYXJncyk7XG4gICAgaWYgKHVwZGF0ZUV2ZW50UmVzdWx0KSBvbkRpZFVwZGF0ZUVtaXR0ZXIuZW1pdCh1cGRhdGVFdmVudFJlc3VsdCk7XG4gIH07XG5cbiAgLy8gTGF5ZXIgb3ZlciB0aGUgZGF0YSBwcm92aWRlciBlbmdpbmUncyBzZXQgbWV0aG9kcyB3aXRoIHNldCBtZXRob2RzIHRoYXQgYWN0dWFsbHkgZW1pdCBhbiB1cGRhdGVcbiAgLy8gaWYgdGhleSByZXR1cm4gdHJ1ZVxuICBkYXRhVHlwZXMuZ2V0KCdzZXQnKT8uZm9yRWFjaCgoZGF0YVR5cGUpID0+IHtcbiAgICAvLyBJZiB0aGUgZnVuY3Rpb24gd2FzIGRlY29yYXRlZCB3aXRoIEBkb05vdE5vdGlmeSwgZG8gbm90IG92ZXJ3cml0ZSBpdCB0byBhdXRvbWF0aWNhbGx5IGVtaXQgYW4gdXBkYXRlXG4gICAgaWYgKFxuICAgICAgZGF0YVByb3ZpZGVyRW5naW5lVW50eXBlZFtgc2V0JHtkYXRhVHlwZX1gXSAmJlxuICAgICAgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCB0eXBlcy4gV2UganVzdCB3YW50IHRvIGNoZWNrIHRoZSBkZWNvcmF0b3JcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICAgICAgIShkYXRhUHJvdmlkZXJFbmdpbmVVbnR5cGVkW2BzZXQke2RhdGFUeXBlfWBdIGFzIGFueSkuZG9Ob3ROb3RpZnlcbiAgICApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uICovXG4gICAgICAvKiogU2F2ZWQgYm91bmQgdmVyc2lvbiBvZiB0aGUgZGF0YSBwcm92aWRlciBlbmdpbmUncyBzZXQgc28gd2UgY2FuIGNhbGwgaXQgZnJvbSBoZXJlICovXG4gICAgICBjb25zdCBkcGVTZXQgPSAoXG4gICAgICAgIGRhdGFQcm92aWRlckVuZ2luZVVudHlwZWRbYHNldCR7ZGF0YVR5cGV9YF0gYXMgRGF0YVByb3ZpZGVyU2V0dGVyPFxuICAgICAgICAgIERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdLFxuICAgICAgICAgIHR5cGVvZiBkYXRhVHlwZVxuICAgICAgICA+XG4gICAgICApLmJpbmQoZGF0YVByb3ZpZGVyRW5naW5lKTtcbiAgICAgIC8qKiBMYXllcmVkIHNldCB0aGF0IGVtaXRzIGFuIHVwZGF0ZSBldmVudCBhZnRlciBydW5uaW5nIHRoZSBlbmdpbmUncyBzZXQgKi9cbiAgICAgIChkYXRhUHJvdmlkZXJFbmdpbmVVbnR5cGVkW2BzZXQke2RhdGFUeXBlfWBdIGFzIERhdGFQcm92aWRlclNldHRlcjxcbiAgICAgICAgRGF0YVByb3ZpZGVyVHlwZXNbRGF0YVByb3ZpZGVyTmFtZV0sXG4gICAgICAgIHR5cGVvZiBkYXRhVHlwZVxuICAgICAgPikgPVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgICAgIGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgY29uc3QgZHBlU2V0UmVzdWx0ID0gYXdhaXQgZHBlU2V0KC4uLmFyZ3MpO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZUV2ZW50UmVzdWx0ID0gbWFwVXBkYXRlSW5zdHJ1Y3Rpb25zVG9VcGRhdGVFdmVudDxcbiAgICAgICAgICAgIERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdXG4gICAgICAgICAgPihkcGVTZXRSZXN1bHQsIGRhdGFUeXBlKTtcbiAgICAgICAgICBpZiAodXBkYXRlRXZlbnRSZXN1bHQpIG9uRGlkVXBkYXRlRW1pdHRlci5lbWl0KHVwZGF0ZUV2ZW50UmVzdWx0KTtcbiAgICAgICAgICByZXR1cm4gZHBlU2V0UmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gTGF5ZXIgb3ZlciB0aGUgZGF0YSBwcm92aWRlciBlbmdpbmUncyBkaXNwb3NlIG1ldGhvZCB0byBtYWtlIHN1cmUgaXRzIHVwZGF0ZSBlbWl0dGVyIGlzXG4gIC8vIGRpc3Bvc2VkIHdoZW4gaXQgaXMgZGlzcG9zZWQuXG4gIG92ZXJyaWRlRGlzcG9zZShkYXRhUHJvdmlkZXJFbmdpbmUsIGFzeW5jICgpID0+IG9uRGlkVXBkYXRlRW1pdHRlci5kaXNwb3NlKCkpO1xuXG4gIHJldHVybiBjcmVhdGVEYXRhUHJvdmlkZXJQcm94eShkYXRhUHJvdmlkZXJFbmdpbmUsIGRhdGFQcm92aWRlclByb21pc2UsIG9uRGlkVXBkYXRlRW1pdHRlci5ldmVudCk7XG59XG5cbi8qKlxuICogSlNET0MgU09VUkNFIERhdGFQcm92aWRlclNlcnZpY2VSZWdpc3RlckVuZ2luZVxuICpcbiAqIENyZWF0ZXMgYSBkYXRhIHByb3ZpZGVyIHRvIGJlIHNoYXJlZCBvbiB0aGUgbmV0d29yayBsYXllcmluZyBvdmVyIHRoZSBwcm92aWRlZCBkYXRhIHByb3ZpZGVyXG4gKiBlbmdpbmUuXG4gKlxuICogQHBhcmFtIHByb3ZpZGVyTmFtZSBOYW1lIHRoaXMgZGF0YSBwcm92aWRlciBzaG91bGQgYmUgY2FsbGVkIG9uIHRoZSBuZXR3b3JrXG4gKiBAcGFyYW0gZGF0YVByb3ZpZGVyRW5naW5lIFRoZSBvYmplY3QgdG8gbGF5ZXIgb3ZlciB3aXRoIGEgbmV3IGRhdGEgcHJvdmlkZXIgb2JqZWN0XG4gKiBAcGFyYW0gZGF0YVByb3ZpZGVyVHlwZSBTdHJpbmcgdG8gc2VuZCBpbiBhIG5ldHdvcmsgZXZlbnQgdG8gY2xhcmlmeSB3aGF0IHR5cGUgb2YgZGF0YSBwcm92aWRlclxuICogICBpcyByZXByZXNlbnRlZCBieSB0aGlzIGVuZ2luZS4gRm9yIGdlbmVyaWMgZGF0YSBwcm92aWRlcnMsIHRoZSBkZWZhdWx0IHZhbHVlIG9mIGBkYXRhUHJvdmlkZXJgXG4gKiAgIGNhbiBiZSB1c2VkLiBGb3IgZGF0YSBwcm92aWRlciB0eXBlcyB0aGF0IGhhdmUgbXVsdGlwbGUgaW5zdGFuY2VzIChlLmcuLCBwcm9qZWN0IGRhdGFcbiAqICAgcHJvdmlkZXJzKSwgYSB1bmlxdWUgdHlwZSBuYW1lIHNob3VsZCBiZSB1c2VkIHRvIGRpc3Rpbmd1aXNoIGZyb20gZ2VuZXJpYyBkYXRhIHByb3ZpZGVycy5cbiAqIEBwYXJhbSBkYXRhUHJvdmlkZXJBdHRyaWJ1dGVzIE9wdGlvbmFsIG9iamVjdCB0aGF0IHdpbGwgYmUgc2VudCBpbiBhIG5ldHdvcmsgZXZlbnQgdG8gcHJvdmlkZVxuICogICBhZGRpdGlvbmFsIG1ldGFkYXRhIGFib3V0IHRoZSBkYXRhIHByb3ZpZGVyIHJlcHJlc2VudGVkIGJ5IHRoaXMgZW5naW5lLlxuICpcbiAqICAgV0FSTklORzogcmVnaXN0ZXJpbmcgYSBkYXRhUHJvdmlkZXJFbmdpbmUgbXV0YXRlcyB0aGUgcHJvdmlkZWQgb2JqZWN0LiBJdHMgYG5vdGlmeVVwZGF0ZWAgYW5kXG4gKiAgIGBzZXRgIG1ldGhvZHMgYXJlIGxheWVyZWQgb3ZlciB0byBmYWNpbGl0YXRlIGRhdGEgcHJvdmlkZXIgc3Vic2NyaXB0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkYXRhIHByb3ZpZGVyIGluY2x1ZGluZyBjb250cm9sIG92ZXIgZGlzcG9zaW5nIG9mIGl0LiBOb3RlIHRoYXQgdGhpcyBkYXRhIHByb3ZpZGVyXG4gKiAgIGlzIGEgbmV3IG9iamVjdCBkaXN0aW5jdCBmcm9tIHRoZSBkYXRhIHByb3ZpZGVyIGVuZ2luZSBwYXNzZWQgaW4uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlZ2lzdGVyRW5naW5lPERhdGFQcm92aWRlck5hbWUgZXh0ZW5kcyBEYXRhUHJvdmlkZXJOYW1lcz4oXG4gIHByb3ZpZGVyTmFtZTogRGF0YVByb3ZpZGVyTmFtZSxcbiAgZGF0YVByb3ZpZGVyRW5naW5lOiBJRGF0YVByb3ZpZGVyRW5naW5lPERhdGFQcm92aWRlclR5cGVzW0RhdGFQcm92aWRlck5hbWVdPixcbiAgZGF0YVByb3ZpZGVyVHlwZTogc3RyaW5nID0gJ2RhdGFQcm92aWRlcicsXG4gIGRhdGFQcm92aWRlckF0dHJpYnV0ZXM6IHsgW3Byb3BlcnR5OiBzdHJpbmddOiB1bmtub3duIH0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4pOiBQcm9taXNlPERpc3Bvc2FibGVEYXRhUHJvdmlkZXJzW0RhdGFQcm92aWRlck5hbWVdPiB7XG4gIGF3YWl0IGluaXRpYWxpemUoKTtcblxuICBpZiAoaGFzS25vd24ocHJvdmlkZXJOYW1lKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGEgcHJvdmlkZXIgd2l0aCBuYW1lICR7cHJvdmlkZXJOYW1lfSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRgKTtcblxuICAvLyBXZSBhcmUgZ29vZCB0byBnbyEgQ3JlYXRlIHRoZSBkYXRhIHByb3ZpZGVyXG5cbiAgLy8gR2V0IHRoZSBvYmplY3QgaWQgZm9yIHRoaXMgZGF0YSBwcm92aWRlciBuYW1lXG4gIGNvbnN0IGRhdGFQcm92aWRlck9iamVjdElkID0gZ2V0RGF0YVByb3ZpZGVyT2JqZWN0SWQocHJvdmlkZXJOYW1lKTtcblxuICAvKipcbiAgICogVmFyaWFibGUgdG8gaG9sZCBhIHByb21pc2UgdG8gdGhlIGZpbmFsIGRhdGEgcHJvdmlkZXIncyBuZXR3b3JrIG9iamVjdCBzbyB0aGUgbG9jYWwgb2JqZWN0IGNhblxuICAgKiByZWZlcmVuY2UgdGhlIG5ldHdvcmsgb2JqZWN0IGluIGl0cyBmdW5jdGlvbnNcbiAgICovXG4gIGNvbnN0IGRhdGFQcm92aWRlclZhcmlhYmxlID0gbmV3IEFzeW5jVmFyaWFibGU8RGF0YVByb3ZpZGVyc1tEYXRhUHJvdmlkZXJOYW1lXT4oXG4gICAgYERhdGFQcm92aWRlci0ke3Byb3ZpZGVyTmFtZX1gLFxuICApO1xuXG4gIC8vIENyZWF0ZSBhIG5ldHdvcmtlZCB1cGRhdGUgZXZlbnRcbiAgY29uc3Qgb25EaWRVcGRhdGVFbWl0dGVyID0gbmV0d29ya1NlcnZpY2UuY3JlYXRlTmV0d29ya0V2ZW50RW1pdHRlcjxcbiAgICBEYXRhUHJvdmlkZXJVcGRhdGVJbnN0cnVjdGlvbnM8RGF0YVByb3ZpZGVyVHlwZXNbRGF0YVByb3ZpZGVyTmFtZV0+XG4gID4oc2VyaWFsaXplUmVxdWVzdFR5cGUoZGF0YVByb3ZpZGVyT2JqZWN0SWQsIE9OX0RJRF9VUERBVEUpKTtcblxuICAvLyBCdWlsZCB0aGUgZGF0YSBwcm92aWRlclxuICBjb25zdCBkYXRhUHJvdmlkZXJJbnRlcm5hbCA9IGJ1aWxkRGF0YVByb3ZpZGVyKFxuICAgIGRhdGFQcm92aWRlckVuZ2luZSxcbiAgICBkYXRhUHJvdmlkZXJWYXJpYWJsZS5wcm9taXNlLFxuICAgIG9uRGlkVXBkYXRlRW1pdHRlcixcbiAgKTtcblxuICAvLyBTZXQgdXAgdGhlIGRhdGEgcHJvdmlkZXIgdG8gYmUgYSBuZXR3b3JrIG9iamVjdCBzbyBvdGhlciBwcm9jZXNzZXMgY2FuIHVzZSBpdFxuICAvLyBOb3cgdGhhdCB3ZSBhcmUgdXNpbmcgc2hhcmVkIGludGVyZmFjZSB0eXBlcyBmb3IgZGF0YSBwcm92aWRlcnMsIGBuZXR3b3JrT2JqZWN0U2VydmljZS5zZXRgIGlzXG4gIC8vIG1lc3NpbmcgdXAgYWxsIHRoZSBzdHJpbmcgdGVtcGxhdGUgdHlwZXMgd2hlbiBpdCBydW5zIGl0IHRocm91Z2ggYERpc3Bvc2FibGVOZXR3b3JrT2JqZWN0YFxuICAvLyB3aGljaCBoYXMgYE9taXRgLiBTbyB3ZSBuZWVkIHRvIHBhc3MgdGhyb3VnaCBgdW5rbm93bmAgdG8gZ2V0IHRvIHRoZSBjb3JyZWN0IHR5cGVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gIGNvbnN0IGRpc3Bvc2FibGVEYXRhUHJvdmlkZXIgPSAoYXdhaXQgbmV0d29ya09iamVjdFNlcnZpY2Uuc2V0KFxuICAgIGRhdGFQcm92aWRlck9iamVjdElkLFxuICAgIGRhdGFQcm92aWRlckludGVybmFsLFxuICAgIGRhdGFQcm92aWRlclR5cGUsXG4gICAgZGF0YVByb3ZpZGVyQXR0cmlidXRlcyxcbiAgKSkgYXMgdW5rbm93biBhcyBEaXNwb3NhYmxlRGF0YVByb3ZpZGVyc1tEYXRhUHJvdmlkZXJOYW1lXTtcblxuICAvLyBHZXQgdGhlIGxvY2FsIG5ldHdvcmsgb2JqZWN0IHByb3h5IGZvciB0aGUgZGF0YSBwcm92aWRlciBzbyB0aGUgcHJvdmlkZXIgY2FuJ3QgYmUgZGlzcG9zZWRcbiAgLy8gb3V0c2lkZSB0aGUgc2VydmljZSB0aGF0IHJlZ2lzdGVyZWQgdGhlIHByb3ZpZGVyIGVuZ2luZS4gQXNzZXJ0IHR5cGUgd2l0aG91dCBOZXR3b3JrT2JqZWN0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgY29uc3QgZGF0YVByb3ZpZGVyID0gKGF3YWl0IG5ldHdvcmtPYmplY3RTZXJ2aWNlLmdldDxEYXRhUHJvdmlkZXJzW0RhdGFQcm92aWRlck5hbWVdPihcbiAgICBkYXRhUHJvdmlkZXJPYmplY3RJZCxcbiAgKSkgYXMgRGF0YVByb3ZpZGVyc1tEYXRhUHJvdmlkZXJOYW1lXTtcblxuICAvLyBVcGRhdGUgdGhlIGRhdGFQcm92aWRlclZhcmlhYmxlIHNvIHRoZSBpbnRlcm5hbCBkYXRhIHByb3ZpZGVyIChzcGVjaWZpY2FsbHkgaXRzIHN1YnNjcmliZVxuICAvLyBmdW5jdGlvbikgY2FuIGFjY2VzcyB0aGUgZGF0YVByb3ZpZGVyIGFwcHJvcHJpYXRlbHlcbiAgaWYgKGRhdGFQcm92aWRlcikgZGF0YVByb3ZpZGVyVmFyaWFibGUucmVzb2x2ZVRvVmFsdWUoZGF0YVByb3ZpZGVyKTtcbiAgZWxzZSB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGdldCBuZXR3b3JrIG9iamVjdCBmb3IgZGF0YSBwcm92aWRlcjogJHtkYXRhUHJvdmlkZXJPYmplY3RJZH1gKTtcblxuICByZXR1cm4gZGlzcG9zYWJsZURhdGFQcm92aWRlcjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZGF0YSBwcm92aWRlciB0byBiZSBzaGFyZWQgb24gdGhlIG5ldHdvcmsgbGF5ZXJpbmcgb3ZlciB0aGUgcHJvdmlkZWQgZGF0YSBwcm92aWRlclxuICogZW5naW5lLlxuICpcbiAqIEB0eXBlIGBURGF0YVR5cGVzYCAtIFRoZSBkYXRhIHByb3ZpZGVyIGRhdGEgdHlwZXMgc2VydmVkIGJ5IHRoZSBkYXRhIHByb3ZpZGVyIHRvIGNyZWF0ZS5cbiAqXG4gKiAgIFRoaXMgaXMgbm90IGV4cG9zZWQgb24gdGhlIHBhcGkgYXMgaXQgaXMgYSBoZWxwZXIgZnVuY3Rpb24gdG8gZW5hYmxlIG90aGVyIHNlcnZpY2VzIHRvIGxheWVyIG92ZXJcbiAqICAgdGhpcyBzZXJ2aWNlIGFuZCBjcmVhdGUgdGhlaXIgb3duIHN1YnNldHMgb2YgZGF0YSBwcm92aWRlcnMgd2l0aCBvdGhlciB0eXBlcyB0aGFuXG4gKiAgIGBEYXRhUHJvdmlkZXJzYCB0eXBlcyB1c2luZyB0aGlzIGZ1bmN0aW9uIGFuZCB7QGxpbmsgZ2V0QnlUeXBlfVxuICogQHBhcmFtIHByb3ZpZGVyTmFtZSBOYW1lIHRoaXMgZGF0YSBwcm92aWRlciBzaG91bGQgYmUgY2FsbGVkIG9uIHRoZSBuZXR3b3JrXG4gKiBAcGFyYW0gZGF0YVByb3ZpZGVyRW5naW5lIFRoZSBvYmplY3QgdG8gbGF5ZXIgb3ZlciB3aXRoIGEgbmV3IGRhdGEgcHJvdmlkZXIgb2JqZWN0XG4gKiBAcGFyYW0gZGF0YVByb3ZpZGVyVHlwZSBTdHJpbmcgdG8gc2VuZCBpbiBhIG5ldHdvcmsgZXZlbnQgdG8gY2xhcmlmeSB3aGF0IHR5cGUgb2YgZGF0YSBwcm92aWRlclxuICogICBpcyByZXByZXNlbnRlZCBieSB0aGlzIGVuZ2luZS4gRm9yIGdlbmVyaWMgZGF0YSBwcm92aWRlcnMsIHRoZSBkZWZhdWx0IHZhbHVlIG9mIGBkYXRhUHJvdmlkZXJgXG4gKiAgIGNhbiBiZSB1c2VkLiBGb3IgZGF0YSBwcm92aWRlciB0eXBlcyB0aGF0IGhhdmUgbXVsdGlwbGUgaW5zdGFuY2VzIChlLmcuLCBwcm9qZWN0IGRhdGFcbiAqICAgcHJvdmlkZXJzKSwgYSB1bmlxdWUgdHlwZSBuYW1lIHNob3VsZCBiZSB1c2VkIHRvIGRpc3Rpbmd1aXNoIGZyb20gZ2VuZXJpYyBkYXRhIHByb3ZpZGVycy5cbiAqIEBwYXJhbSBkYXRhUHJvdmlkZXJBdHRyaWJ1dGVzIE9wdGlvbmFsIG9iamVjdCB0aGF0IHdpbGwgYmUgc2VudCBpbiBhIG5ldHdvcmsgZXZlbnQgdG8gcHJvdmlkZVxuICogICBhZGRpdGlvbmFsIG1ldGFkYXRhIGFib3V0IHRoZSBkYXRhIHByb3ZpZGVyIHJlcHJlc2VudGVkIGJ5IHRoaXMgZW5naW5lLlxuICpcbiAqICAgV0FSTklORzogcmVnaXN0ZXJpbmcgYSBkYXRhUHJvdmlkZXJFbmdpbmUgbXV0YXRlcyB0aGUgcHJvdmlkZWQgb2JqZWN0LiBJdHMgYG5vdGlmeVVwZGF0ZWAgYW5kXG4gKiAgIGBzZXRgIG1ldGhvZHMgYXJlIGxheWVyZWQgb3ZlciB0byBmYWNpbGl0YXRlIGRhdGEgcHJvdmlkZXIgc3Vic2NyaXB0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkYXRhIHByb3ZpZGVyIGluY2x1ZGluZyBjb250cm9sIG92ZXIgZGlzcG9zaW5nIG9mIGl0LiBOb3RlIHRoYXQgdGhpcyBkYXRhIHByb3ZpZGVyXG4gKiAgIGlzIGEgbmV3IG9iamVjdCBkaXN0aW5jdCBmcm9tIHRoZSBkYXRhIHByb3ZpZGVyIGVuZ2luZSBwYXNzZWQgaW4uXG4gKi9cbi8vIFNlZW1zIFR5cGVTY3JpcHQgZG9lc24ndCBsaWtlIHVzaW5nIGEgZ2VuZXJpYyBzdHJpbmcgdG8gaW5kZXggRGF0YVByb3ZpZGVyRGF0YVR5cGVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZ2lzdGVyRW5naW5lQnlUeXBlPFREYXRhVHlwZXMgZXh0ZW5kcyBEYXRhUHJvdmlkZXJEYXRhVHlwZXM+KFxuICBwcm92aWRlck5hbWU6IHN0cmluZyxcbiAgZGF0YVByb3ZpZGVyRW5naW5lOiBJRGF0YVByb3ZpZGVyRW5naW5lPFREYXRhVHlwZXM+LFxuICBkYXRhUHJvdmlkZXJUeXBlOiBzdHJpbmcgPSAnZGF0YVByb3ZpZGVyJyxcbiAgZGF0YVByb3ZpZGVyQXR0cmlidXRlczogeyBbcHJvcGVydHk6IHN0cmluZ106IHVua25vd24gfSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbik6IFByb21pc2U8SURpc3Bvc2FibGVEYXRhUHJvdmlkZXI8SURhdGFQcm92aWRlcjxURGF0YVR5cGVzPj4+IHtcbiAgLy8gQWxsIHRoZSB0eXBlcyBvbiB0aGlzIGZ1bmN0aW9uIGFuZCBgcmVnaXN0ZXJFbmdpbmVgIGFyZSBqdXN0IFR5cGVTY3JpcHQgaGVscGVycy4gVGhleSBkbyBub3RcbiAgLy8gc2VydmUgdXMgd2VsbCBpbiB0aGlzIHBhcnRpY3VsYXIgY2FzZSwgc28gd2UncmUgaWdub3JpbmcgdGhlIHR5cGVzIGFuZCB1c2luZyBvdXIgb3duIHNpbmNlIHdlXG4gIC8vIGFyZSBtYWtpbmcgb3RoZXIga2luZHMgb2YgZGF0YSBwcm92aWRlcnMgdGhhdCBhcmUgbm90IGluIGBEYXRhUHJvdmlkZXJzYFxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICByZXR1cm4gcmVnaXN0ZXJFbmdpbmUoXG4gICAgcHJvdmlkZXJOYW1lIGFzIGFueSxcbiAgICBkYXRhUHJvdmlkZXJFbmdpbmUgYXMgYW55LFxuICAgIGRhdGFQcm92aWRlclR5cGUsXG4gICAgZGF0YVByb3ZpZGVyQXR0cmlidXRlcyxcbiAgKTtcbiAgLyogZXNsaW50LWVuYWJsZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG1vY2sgbG9jYWwgZGF0YSBwcm92aWRlciBvYmplY3QgZm9yIGNvbm5lY3RpbmcgdG8gdGhlIHJlbW90ZSBkYXRhIHByb3ZpZGVyLiBUaGlzIG9iamVjdFxuICogaGFzIHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSBsb2NhbCBkYXRhIHByb3ZpZGVyIG9iamVjdCB0aGF0IGFyZSBub3Qgc3RyaWN0bHkgbmV0d29yayBvYmplY3RcbiAqIGZ1bmN0aW9ucyB0aGF0IGp1c3Qgc2VuZCByZXF1ZXN0cyBhY3Jvc3MgdGhlIG5ldHdvcmsuIEZvciBleGFtcGxlLCB0aGlzIG9iamVjdCBoYXMgYWxsIHRoZVxuICogYHN1YnNjcmliZSR7ZGF0YVR5cGV9YCBmdW5jdGlvbnMgb24gaXQgc2luY2UgdGhvc2UgcnVuIGNvZGUgb24gdGhlIGxvY2FsIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIGRhdGFQcm92aWRlck9iamVjdElkIE5ldHdvcmsgb2JqZWN0IGlkIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBkYXRhIHByb3ZpZGVyXG4gKiBAcGFyYW0gZGF0YVByb3ZpZGVyQ29udGFpbmVyIENvbnRhaW5lciB0aGF0IGhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoZSBkYXRhIHByb3ZpZGVyIHNvIHRoaXNcbiAqICAgc3Vic2NyaWJlIGZ1bmN0aW9uIGNhbiByZWZlcmVuY2UgdGhlIGRhdGEgcHJvdmlkZXJcbiAqIEByZXR1cm5zIExvY2FsIGRhdGEgcHJvdmlkZXIgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIHJlbW90ZSBkYXRhIHByb3ZpZGVyXG4gKi9cbi8vIFRoaXMgZ2VuZXJpYyB0eXBlIHNob3VsZCBiZSBEYXRhUHJvdmlkZXJJbnRlcm5hbCBiZWNhdXNlIHdlIGFyZSBtYWtpbmcgcGFydCBvZiBhIGxvY2FsL2ludGVybmFsIGRhdGEgcHJvdmlkZXJcbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsRGF0YVByb3ZpZGVyVG9Qcm94eTxEYXRhUHJvdmlkZXJOYW1lIGV4dGVuZHMgRGF0YVByb3ZpZGVyTmFtZXM+KFxuICBkYXRhUHJvdmlkZXJPYmplY3RJZDogRGF0YVByb3ZpZGVyTmFtZSxcbiAgZGF0YVByb3ZpZGVyUHJvbWlzZTogUHJvbWlzZTxEYXRhUHJvdmlkZXJzW0RhdGFQcm92aWRlck5hbWVdPixcbik6IFBhcnRpYWw8RGF0YVByb3ZpZGVySW50ZXJuYWw8RGF0YVByb3ZpZGVyVHlwZXNbRGF0YVByb3ZpZGVyTmFtZV0+PiB7XG4gIC8vIENyZWF0ZSBhIG5ldHdvcmtlZCB1cGRhdGUgZXZlbnRcbiAgY29uc3Qgb25EaWRVcGRhdGUgPSBuZXR3b3JrU2VydmljZS5nZXROZXR3b3JrRXZlbnQ8Ym9vbGVhbj4oXG4gICAgc2VyaWFsaXplUmVxdWVzdFR5cGUoZGF0YVByb3ZpZGVyT2JqZWN0SWQsIE9OX0RJRF9VUERBVEUpLFxuICApO1xuXG4gIHJldHVybiBjcmVhdGVEYXRhUHJvdmlkZXJQcm94eSh1bmRlZmluZWQsIGRhdGFQcm92aWRlclByb21pc2UsIG9uRGlkVXBkYXRlKTtcbn1cblxuLyoqXG4gKiBKU0RPQyBTT1VSQ0UgRGF0YVByb3ZpZGVyU2VydmljZUdldFxuICpcbiAqIEdldCBhIGRhdGEgcHJvdmlkZXIgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIHNldCB1cFxuICpcbiAqIEBwYXJhbSBwcm92aWRlck5hbWUgTmFtZSBvZiB0aGUgZGVzaXJlZCBkYXRhIHByb3ZpZGVyXG4gKiBAcmV0dXJucyBUaGUgZGF0YSBwcm92aWRlciB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIG9uZSBleGlzdHMsIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0PERhdGFQcm92aWRlck5hbWUgZXh0ZW5kcyBEYXRhUHJvdmlkZXJOYW1lcz4oXG4gIHByb3ZpZGVyTmFtZTogRGF0YVByb3ZpZGVyTmFtZSxcbik6IFByb21pc2U8RGF0YVByb3ZpZGVyc1tEYXRhUHJvdmlkZXJOYW1lXSB8IHVuZGVmaW5lZD4ge1xuICBhd2FpdCBpbml0aWFsaXplKCk7XG5cbiAgLy8gR2V0IHRoZSBvYmplY3QgaWQgZm9yIHRoaXMgZGF0YSBwcm92aWRlciBuYW1lXG4gIGNvbnN0IGRhdGFQcm92aWRlck9iamVjdElkID0gZ2V0RGF0YVByb3ZpZGVyT2JqZWN0SWQocHJvdmlkZXJOYW1lKTtcblxuICAvLyBHZXQgdGhlIG5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGRhdGEgcHJvdmlkZXIuIEFzc2VydCB0byBzcGVjaWZpZWQgZ2VuZXJpYyB0eXBlLlxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvbiAqL1xuICBjb25zdCBkYXRhUHJvdmlkZXIgPSAoYXdhaXQgbmV0d29ya09iamVjdFNlcnZpY2UuZ2V0PFxuICAgIERhdGFQcm92aWRlcnNbRGF0YVByb3ZpZGVyTmFtZV0gJiBDYW5ub3RIYXZlT25EaWREaXNwb3NlXG4gID4oXG4gICAgZGF0YVByb3ZpZGVyT2JqZWN0SWQsXG4gICAgY3JlYXRlTG9jYWxEYXRhUHJvdmlkZXJUb1Byb3h5IGFzIExvY2FsT2JqZWN0VG9Qcm94eUNyZWF0b3I8XG4gICAgICBEYXRhUHJvdmlkZXJzW0RhdGFQcm92aWRlck5hbWVdICYgQ2Fubm90SGF2ZU9uRGlkRGlzcG9zZVxuICAgID4sXG4gICkpIGFzIERhdGFQcm92aWRlcnNbRGF0YVByb3ZpZGVyTmFtZV0gfCB1bmRlZmluZWQ7XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuICBpZiAoIWRhdGFQcm92aWRlcikge1xuICAgIGxvZ2dlci5pbmZvKGBObyBkYXRhIHByb3ZpZGVyIGZvdW5kIHdpdGggbmFtZSA9ICR7cHJvdmlkZXJOYW1lfWApO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gZGF0YVByb3ZpZGVyO1xufVxuXG4vKipcbiAqIEdldCBhIGRhdGEgcHJvdmlkZXIgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIHNldCB1cFxuICpcbiAqIEB0eXBlIGBUYCAtIFRoZSB0eXBlIG9mIGRhdGEgcHJvdmlkZXIgdG8gZ2V0LiBVc2UgYElEYXRhUHJvdmlkZXI8VERhdGFQcm92aWRlckRhdGFUeXBlcz5gLFxuICogICBzcGVjaWZ5aW5nIHlvdXIgb3duIHR5cGVzLCBvciBwcm92aWRlIGEgY3VzdG9tIGRhdGEgcHJvdmlkZXIgdHlwZVxuICpcbiAqICAgVGhpcyBpcyBub3QgZXhwb3NlZCBvbiB0aGUgcGFwaSBhcyBpdCBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBlbmFibGUgb3RoZXIgc2VydmljZXMgdG8gbGF5ZXIgb3ZlclxuICogICB0aGlzIHNlcnZpY2UgYW5kIGNyZWF0ZSB0aGVpciBvd24gc3Vic2V0cyBvZiBkYXRhIHByb3ZpZGVycyB3aXRoIG90aGVyIHR5cGVzIHRoYW5cbiAqICAgYERhdGFQcm92aWRlcnNgIHR5cGVzIHVzaW5nIHRoaXMgZnVuY3Rpb24gYW5kIHtAbGluayByZWdpc3RlckVuZ2luZUJ5VHlwZX1cbiAqIEBwYXJhbSBwcm92aWRlck5hbWUgTmFtZSBvZiB0aGUgZGVzaXJlZCBkYXRhIHByb3ZpZGVyXG4gKiBAcmV0dXJucyBUaGUgZGF0YSBwcm92aWRlciB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIG9uZSBleGlzdHMsIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAqL1xuLy8gU2VlbXMgVHlwZVNjcmlwdCBkb2Vzbid0IGxpa2UgdXNpbmcgYSBnZW5lcmljIHN0cmluZyB0byBpbmRleCBEYXRhUHJvdmlkZXJEYXRhVHlwZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QnlUeXBlPFQgZXh0ZW5kcyBJRGF0YVByb3ZpZGVyPGFueT4+KFxuICBwcm92aWRlck5hbWU6IHN0cmluZyxcbik6IFByb21pc2U8VCB8IHVuZGVmaW5lZD4ge1xuICAvLyBBbGwgdGhlIHR5cGVzIG9uIHRoaXMgZnVuY3Rpb24gYW5kIGBnZXRgIGFyZSBqdXN0IFR5cGVTY3JpcHQgaGVscGVycy4gVGhleSBkbyBub3Qgc2VydmUgdXMgd2VsbFxuICAvLyBpbiB0aGlzIHBhcnRpY3VsYXIgY2FzZSwgc28gd2UncmUgaWdub3JpbmcgdGhlIHR5cGVzIGFuZCB1c2luZyBvdXIgb3duIHNpbmNlIHdlIGFyZSBnZXR0aW5nXG4gIC8vIG90aGVyIGtpbmRzIG9mIGRhdGEgcHJvdmlkZXJzIHRoYXQgYXJlIG5vdCBpbiBgRGF0YVByb3ZpZGVyc2BcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHJldHVybiBnZXQocHJvdmlkZXJOYW1lIGFzIGFueSk7XG59XG5cbi8vIERlY2xhcmUgYW4gaW50ZXJmYWNlIGZvciB0aGUgb2JqZWN0IHdlJ3JlIGV4cG9ydGluZyBzbyB0aGF0IEpTRG9jIGNvbW1lbnRzIHByb3BhZ2F0ZVxuZXhwb3J0IGludGVyZmFjZSBEYXRhUHJvdmlkZXJTZXJ2aWNlIHtcbiAgLyoqIEpTRE9DIERFU1RJTkFUSU9OIERhdGFQcm92aWRlclNlcnZpY2VIYXNLbm93biAqL1xuICBoYXNLbm93bjogdHlwZW9mIGhhc0tub3duO1xuICAvKiogSlNET0MgREVTVElOQVRJT04gRGF0YVByb3ZpZGVyU2VydmljZVJlZ2lzdGVyRW5naW5lICovXG4gIHJlZ2lzdGVyRW5naW5lOiB0eXBlb2YgcmVnaXN0ZXJFbmdpbmU7XG4gIC8qKiBKU0RPQyBERVNUSU5BVElPTiBEYXRhUHJvdmlkZXJTZXJ2aWNlR2V0ICovXG4gIGdldDogdHlwZW9mIGdldDtcbiAgLyoqIEpTRE9DIERFU1RJTkFUSU9OIERhdGFQcm92aWRlclNlcnZpY2VEZWNvcmF0b3JzICovXG4gIGRlY29yYXRvcnM6IHR5cGVvZiBkZWNvcmF0b3JzO1xuICAvKiogSlNET0MgREVTVElOQVRJT04gRGF0YVByb3ZpZGVyRW5naW5lICovXG4gIERhdGFQcm92aWRlckVuZ2luZTogdHlwZW9mIERhdGFQcm92aWRlckVuZ2luZTtcbn1cblxuLyoqXG4gKiBKU0RPQyBTT1VSQ0UgZGF0YVByb3ZpZGVyU2VydmljZVxuICpcbiAqIFNlcnZpY2UgdGhhdCBhbGxvd3MgZXh0ZW5zaW9ucyB0byBzZW5kIGFuZCByZWNlaXZlIGRhdGEgdG8vZnJvbSBvdGhlciBleHRlbnNpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBkYXRhUHJvdmlkZXJTZXJ2aWNlOiBEYXRhUHJvdmlkZXJTZXJ2aWNlID0ge1xuICBoYXNLbm93bixcbiAgcmVnaXN0ZXJFbmdpbmUsXG4gIGdldCxcbiAgZGVjb3JhdG9ycyxcbiAgRGF0YVByb3ZpZGVyRW5naW5lLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZGF0YVByb3ZpZGVyU2VydmljZTtcbiIsImltcG9ydCB7IGlzRXh0ZW5zaW9uSG9zdCB9IGZyb20gJ0BzaGFyZWQvdXRpbHMvaW50ZXJuYWwtdXRpbCc7XG5pbXBvcnQgKiBhcyBuZXR3b3JrU2VydmljZSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL25ldHdvcmsuc2VydmljZSc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL2xvZ2dlci5zZXJ2aWNlJztcbmltcG9ydCB0eXBlIHsgR2V0QXNzZXQgfSBmcm9tICdAZXh0ZW5zaW9uLWhvc3Qvc2VydmljZXMvYXNzZXQtcmV0cmlldmFsLnNlcnZpY2UnO1xuaW1wb3J0IHsgc2VyaWFsaXplUmVxdWVzdFR5cGUgfSBmcm9tICdAc2hhcmVkL3V0aWxzL3V0aWwnO1xuXG5sZXQgZ2V0QXNzZXQ6IEdldEFzc2V0O1xubGV0IGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbmxldCBpbml0aWFsaXplUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcblxuLyoqIFByZWZpeCBvbiByZXF1ZXN0cyB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IGlzIG9uIHRoZSBleHRlbnNpb24gYXNzZXQgc2VydmljZSAqL1xuZXhwb3J0IGNvbnN0IENBVEVHT1JZX0VYVEVOU0lPTl9BU1NFVCA9ICdleHRlbnNpb25Bc3NldCc7XG4vKiogTmFtZSBmb3IgcmVxdWVzdCB0byBnZXQgYW4gZXh0ZW5zaW9uIGFzc2V0ICovXG5jb25zdCBHRVRfRVhURU5TSU9OX0FTU0VUX1JFUVVFU1QgPSAnZ2V0RXh0ZW5zaW9uQXNzZXQnO1xuXG4vKipcbiAqIExvYWQgYW4gYXNzZXQgZnJvbSB0aGUgZ2l2ZW4gZXh0ZW5zaW9uJ3MgaW5zdGFsbGF0aW9uIGRpcmVjdG9yeVxuICpcbiAqIEBwYXJhbSBleHRlbnNpb25OYW1lIE5hbWUgb2YgdGhlIGV4dGVuc2lvblxuICogQHBhcmFtIGFzc2V0TmFtZSBOYW1lIG9mIHRoZSBhc3NldCBpbmNsdWRpbmcgYW55IHBhdGggaW5mb3JtYXRpb25cbiAqIEByZXR1cm5zIEJhc2UgNjQgZW5jb2RlZCB2YWx1ZSBvZiB0aGUgYXNzZXQgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgdW5kZWZpbmVkXG4gKi9cbmNvbnN0IGdldEV4dGVuc2lvbkFzc2V0ID0gYXN5bmMgKFxuICBleHRlbnNpb25OYW1lOiBzdHJpbmcsXG4gIGFzc2V0TmFtZTogc3RyaW5nLFxuKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0+IHtcbiAgaWYgKGlzRXh0ZW5zaW9uSG9zdCgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoYXdhaXQgZ2V0QXNzZXQoZXh0ZW5zaW9uTmFtZSwgYXNzZXROYW1lKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYENvdWxkIG5vdCBnZXQgYXNzZXQgXCIke2Fzc2V0TmFtZX1cIiBmcm9tIFwiJHtleHRlbnNpb25OYW1lfVwiOiAke2Vycm9yfWApO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldHdvcmtTZXJ2aWNlLnJlcXVlc3QoXG4gICAgICBzZXJpYWxpemVSZXF1ZXN0VHlwZShDQVRFR09SWV9FWFRFTlNJT05fQVNTRVQsIEdFVF9FWFRFTlNJT05fQVNTRVRfUkVRVUVTVCksXG4gICAgICBleHRlbnNpb25OYW1lLFxuICAgICAgYXNzZXROYW1lLFxuICAgICk7XG4gIH1cbn07XG5cbi8qKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBieSB0aGUgZXh0ZW5zaW9uIGhvc3QuICovXG5jb25zdCBpbml0aWFsaXplID0gYXN5bmMgKCkgPT4ge1xuICBpZiAoaW5pdGlhbGl6ZVByb21pc2UpIHJldHVybiBpbml0aWFsaXplUHJvbWlzZTtcbiAgaWYgKCFpc0V4dGVuc2lvbkhvc3QoKSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBpbml0aWFsaXplUHJvbWlzZSA9IChhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKGlzSW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBnZXRBc3NldCA9IChhd2FpdCBpbXBvcnQoJ0BleHRlbnNpb24taG9zdC9zZXJ2aWNlcy9hc3NldC1yZXRyaWV2YWwuc2VydmljZScpKS5kZWZhdWx0O1xuICAgIGNvbnN0IHJlcXVlc3RUeXBlID0gc2VyaWFsaXplUmVxdWVzdFR5cGUoQ0FURUdPUllfRVhURU5TSU9OX0FTU0VULCBHRVRfRVhURU5TSU9OX0FTU0VUX1JFUVVFU1QpO1xuICAgIGF3YWl0IG5ldHdvcmtTZXJ2aWNlLnJlZ2lzdGVyUmVxdWVzdEhhbmRsZXIoXG4gICAgICByZXF1ZXN0VHlwZSxcbiAgICAgIGFzeW5jIChleHRlbnNpb25OYW1lOiBzdHJpbmcsIGFzc2V0TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiBnZXRFeHRlbnNpb25Bc3NldChleHRlbnNpb25OYW1lLCBhc3NldE5hbWUpO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiB7XG4gICAgICAgICAgc3VtbWFyeTogJ0dldCBhbiBhc3NldCBmcm9tIGFuIGV4dGVuc2lvbicsXG4gICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6ICdleHRlbnNpb25OYW1lJyxcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHN1bW1hcnk6ICdOYW1lIG9mIHRoZSBleHRlbnNpb24gdG8gZ2V0IHRoZSBhc3NldCBmcm9tJyxcbiAgICAgICAgICAgICAgc2NoZW1hOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiAnYXNzZXROYW1lJyxcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHN1bW1hcnk6ICdOYW1lIG9mIHRoZSBhc3NldCB0byBnZXQnLFxuICAgICAgICAgICAgICBzY2hlbWE6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgIG5hbWU6ICdyZXR1cm4gdmFsdWUnLFxuICAgICAgICAgICAgc3VtbWFyeTogJ0Jhc2U2NCBlbmNvZGVkIGFzc2V0IGlmIGl0IGV4aXN0cycsXG4gICAgICAgICAgICBzY2hlbWE6IHsgb25lT2Y6IFt7IHR5cGU6ICdzdHJpbmcnIH0sIHsgdHlwZTogJ251bGwnIH1dIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9KSgpO1xuXG4gIHJldHVybiBpbml0aWFsaXplUHJvbWlzZTtcbn07XG5cbi8vIERlY2xhcmUgYW4gaW50ZXJmYWNlIGZvciB0aGUgb2JqZWN0IHdlJ3JlIGV4cG9ydGluZyBzbyB0aGF0IEpTRG9jIGNvbW1lbnRzIHByb3BhZ2F0ZVxuZXhwb3J0IGludGVyZmFjZSBFeHRlbnNpb25Bc3NldFNlcnZpY2Uge1xuICBpbml0aWFsaXplOiB0eXBlb2YgaW5pdGlhbGl6ZTtcbiAgZ2V0RXh0ZW5zaW9uQXNzZXQ6IHR5cGVvZiBnZXRFeHRlbnNpb25Bc3NldDtcbn1cblxuZXhwb3J0IGNvbnN0IGV4dGVuc2lvbkFzc2V0U2VydmljZTogRXh0ZW5zaW9uQXNzZXRTZXJ2aWNlID0ge1xuICBpbml0aWFsaXplLFxuICBnZXRFeHRlbnNpb25Bc3NldCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGV4dGVuc2lvbkFzc2V0U2VydmljZTtcbiIsImltcG9ydCB7IElEYXRhUHJvdmlkZXIgfSBmcm9tICdAc2hhcmVkL21vZGVscy9kYXRhLXByb3ZpZGVyLmludGVyZmFjZSc7XG5pbXBvcnQge1xuICBEYXRhUHJvdmlkZXJEYXRhVHlwZSxcbiAgRGF0YVByb3ZpZGVyVXBkYXRlSW5zdHJ1Y3Rpb25zLFxufSBmcm9tICdAc2hhcmVkL21vZGVscy9kYXRhLXByb3ZpZGVyLm1vZGVsJztcbmltcG9ydCB7IExhbmd1YWdlSW5mbyB9IGZyb20gJ3BsYXRmb3JtLWJpYmxlLXJlYWN0JztcbmltcG9ydCB7XG4gIExhbmd1YWdlU3RyaW5ncyxcbiAgTG9jYWxpemVkU3RyaW5nRGF0YUNvbnRyaWJ1dGlvbixcbiAgTG9jYWxpemVLZXksXG4gIE9uRGlkRGlzcG9zZSxcbn0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBMb2NhbGl6YXRpb25EYXRhID0gTGFuZ3VhZ2VTdHJpbmdzO1xuXG5leHBvcnQgdHlwZSBMb2NhbGl6YXRpb25TZWxlY3RvciA9IHsgbG9jYWxpemVLZXk6IExvY2FsaXplS2V5OyBsb2NhbGVzPzogc3RyaW5nW10gfTtcblxuZXhwb3J0IHR5cGUgTG9jYWxpemF0aW9uU2VsZWN0b3JzID0geyBsb2NhbGl6ZUtleXM6IExvY2FsaXplS2V5W107IGxvY2FsZXM/OiBzdHJpbmdbXSB9O1xuXG4vKiogSlNET0MgREVTVElOQVRJT04gbG9jYWxpemF0aW9uU2VydmljZVByb3ZpZGVyTmFtZSAqL1xuZXhwb3J0IGNvbnN0IGxvY2FsaXphdGlvblNlcnZpY2VQcm92aWRlck5hbWUgPSAncGxhdGZvcm0ubG9jYWxpemF0aW9uRGF0YVNlcnZpY2VEYXRhUHJvdmlkZXInO1xuZXhwb3J0IGNvbnN0IGxvY2FsaXphdGlvblNlcnZpY2VPYmplY3RUb1Byb3h5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC8qKlxuICAgKiBKU0RPQyBTT1VSQ0UgbG9jYWxpemF0aW9uU2VydmljZVByb3ZpZGVyTmFtZVxuICAgKlxuICAgKiBUaGlzIG5hbWUgaXMgdXNlZCB0byByZWdpc3RlciB0aGUgbG9jYWxpemF0aW9uIGRhdGEgcHJvdmlkZXIgb24gdGhlIHBhcGkuIFlvdSBjYW4gdXNlIHRoaXMgbmFtZVxuICAgKiB0byBmaW5kIHRoZSBkYXRhIHByb3ZpZGVyIHdoZW4gYWNjZXNzaW5nIGl0IHVzaW5nIHRoZSB1c2VEYXRhIGhvb2tcbiAgICovXG4gIGRhdGFQcm92aWRlck5hbWU6IGxvY2FsaXphdGlvblNlcnZpY2VQcm92aWRlck5hbWUsXG59KTtcblxuLy8gRGF0YSBUeXBlIHRvIGluaXRpYWxpemUgZGF0YSBwcm92aWRlciBlbmdpbmUgd2l0aFxuZXhwb3J0IHR5cGUgTG9jYWxpemF0aW9uRGF0YURhdGFUeXBlcyA9IHtcbiAgTG9jYWxpemVkU3RyaW5nOiBEYXRhUHJvdmlkZXJEYXRhVHlwZTxMb2NhbGl6YXRpb25TZWxlY3Rvciwgc3RyaW5nLCBuZXZlcj47XG4gIExvY2FsaXplZFN0cmluZ3M6IERhdGFQcm92aWRlckRhdGFUeXBlPExvY2FsaXphdGlvblNlbGVjdG9ycywgTG9jYWxpemF0aW9uRGF0YSwgbmV2ZXI+O1xuICBBdmFpbGFibGVJbnRlcmZhY2VMYW5ndWFnZXM6IERhdGFQcm92aWRlckRhdGFUeXBlPHVuZGVmaW5lZCwgUmVjb3JkPHN0cmluZywgTGFuZ3VhZ2VJbmZvPiwgbmV2ZXI+O1xufTtcblxuZGVjbGFyZSBtb2R1bGUgJ3BhcGktc2hhcmVkLXR5cGVzJyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRGF0YVByb3ZpZGVycyB7XG4gICAgW2xvY2FsaXphdGlvblNlcnZpY2VQcm92aWRlck5hbWVdOiBJTG9jYWxpemF0aW9uU2VydmljZTtcbiAgfVxufVxuXG4vKipcbiAqIEpTRE9DIFNPVVJDRSBsb2NhbGl6YXRpb25EYXRhU2VydmljZVxuICpcbiAqIFNlcnZpY2UgdGhhdCBhbGxvd3MgdG8gZ2V0IGFuZCBzdG9yZSBsb2NhbGl6YXRpb25zXG4gKi9cbmV4cG9ydCB0eXBlIElMb2NhbGl6YXRpb25TZXJ2aWNlID0ge1xuICAvKipcbiAgICogTG9vayB1cCBsb2NhbGl6ZWQgc3RyaW5nIGZvciBzcGVjaWZpYyBsb2NhbGl6ZUtleVxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgTWFkZSB1cCBvZiBhIHN0cmluZyBrZXkgdGhhdCBjb3JyZXNwb25kcyB0byBhIGxvY2FsaXplZCB2YWx1ZSBhbmQgYW4gYXJyYXkgb2ZcbiAgICogICBCQ1AgNDcgbGFuZ3VhZ2UgY29kZXNcbiAgICogQHJldHVybnMgTG9jYWxpemVkIHN0cmluZ1xuICAgKi9cbiAgZ2V0TG9jYWxpemVkU3RyaW5nOiAoc2VsZWN0b3I6IExvY2FsaXphdGlvblNlbGVjdG9yKSA9PiBQcm9taXNlPHN0cmluZz47XG4gIC8qKlxuICAgKiBMb29rIHVwIGxvY2FsaXplZCBzdHJpbmdzIGZvciBhbGwgbG9jYWxpemVLZXlzIHByb3ZpZGVkXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3RvcnMgQW4gYXJyYXkgb2YgTG9jYWxpemF0aW9uU2VsZWN0b3JzLiBBIExvY2FsaXphdGlvblNlbGVjdG9yIGlzIG1hZGUgdXAgb2YgYVxuICAgKiAgIHN0cmluZyBrZXkgdGhhdCBjb3JyZXNwb25kcyB0byBhIGxvY2FsaXplZCB2YWx1ZSBhbmQgYW4gYXJyYXkgb2YgQkNQIDQ3IGxhbmd1YWdlIGNvZGVzXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aG9zZSBrZXlzIGFyZSBsb2NhbGl6ZUtleXMgYW5kIHZhbHVlcyBhcmUgbG9jYWxpemVkIHN0cmluZ3NcbiAgICovXG4gIGdldExvY2FsaXplZFN0cmluZ3M6IChzZWxlY3RvcnM6IExvY2FsaXphdGlvblNlbGVjdG9ycykgPT4gUHJvbWlzZTxMb2NhbGl6YXRpb25EYXRhPjtcbiAgLyoqXG4gICAqIEdldCBhIGNvbGxlY3Rpb24gb2Yga25vd24gdXNlci1pbnRlcmZhY2UgbGFuZ3VhZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIEFsbCB1c2VyLWludGVyZmFjZSBsYW5ndWFnZXNcbiAgICovXG4gIGdldEF2YWlsYWJsZUludGVyZmFjZUxhbmd1YWdlczogKCkgPT4gUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBMYW5ndWFnZUluZm8+PjtcbiAgLyoqXG4gICAqIEdldCBhbGwgbG9jYWxpemVkIHN0cmluZyBkYXRhIGN1cnJlbnRseSBsb2FkZWQgYnkgdGhlIHBsYXRmb3JtXG4gICAqXG4gICAqIEByZXR1cm5zIEFsbCBsb2NhbGl6ZWQgc3RyaW5nIGRhdGEgZnJvbSBhbGwgc291cmNlcyBmb3JtYXR0ZWQgYSBzaW5nbGUsIGNvbWJpbmVkIGNvbnRyaWJ1dGlvblxuICAgKi9cbiAgcmV0cmlldmVDdXJyZW50TG9jYWxpemVkU3RyaW5nRGF0YTogKCkgPT4gUHJvbWlzZTxMb2NhbGl6ZWRTdHJpbmdEYXRhQ29udHJpYnV0aW9uPjtcbiAgLyoqXG4gICAqIFRoaXMgZGF0YSBjYW5ub3QgYmUgY2hhbmdlZC4gVHJ5aW5nIHRvIHVzZSB0aGlzIHNldHRlciB0aGlzIHdpbGwgYWx3YXlzIHRocm93XG4gICAqXG4gICAqIEByZXR1cm5zIFVuc3Vic2NyaWJlciBmdW5jdGlvblxuICAgKi9cbiAgc2V0TG9jYWxpemVkU3RyaW5nKCk6IFByb21pc2U8RGF0YVByb3ZpZGVyVXBkYXRlSW5zdHJ1Y3Rpb25zPExvY2FsaXphdGlvbkRhdGFEYXRhVHlwZXM+PjtcbiAgLyoqXG4gICAqIFRoaXMgZGF0YSBjYW5ub3QgYmUgY2hhbmdlZC4gVHJ5aW5nIHRvIHVzZSB0aGlzIHNldHRlciB0aGlzIHdpbGwgYWx3YXlzIHRocm93XG4gICAqXG4gICAqIEByZXR1cm5zIFVuc3Vic2NyaWJlciBmdW5jdGlvblxuICAgKi9cbiAgc2V0TG9jYWxpemVkU3RyaW5ncygpOiBQcm9taXNlPERhdGFQcm92aWRlclVwZGF0ZUluc3RydWN0aW9uczxMb2NhbGl6YXRpb25EYXRhRGF0YVR5cGVzPj47XG4gIC8qKlxuICAgKiBUaGlzIGRhdGEgY2Fubm90IGJlIGNoYW5nZWQuIFRyeWluZyB0byB1c2UgdGhpcyBzZXR0ZXIgdGhpcyB3aWxsIGFsd2F5cyB0aHJvd1xuICAgKlxuICAgKiBAcmV0dXJucyBVbnN1YnNjcmliZXIgZnVuY3Rpb25cbiAgICovXG4gIHNldEF2YWlsYWJsZUludGVyZmFjZUxhbmd1YWdlcygpOiBQcm9taXNlPFxuICAgIERhdGFQcm92aWRlclVwZGF0ZUluc3RydWN0aW9uczxMb2NhbGl6YXRpb25EYXRhRGF0YVR5cGVzPlxuICA+O1xufSAmIE9uRGlkRGlzcG9zZSAmXG4gIHR5cGVvZiBsb2NhbGl6YXRpb25TZXJ2aWNlT2JqZWN0VG9Qcm94eSAmIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdGFrZSBhIGJvb2sgbnVtYmVyIGZyb20gYSB2ZXJzZSByZWYgYW5kIHJldHVybiB0aGUgbG9jYWxpemVkIG5hbWUgb2ZcbiAgICAgKiB0aGUgYm9vayBzbyB0aGF0IHRoZSBib29rIG5hbWUgY2FuIGJlIGRpc3BsYXllZCBpbiB0aGUgVUkgbGFuZ3VhZ2Ugd2l0aGluIHRoZSBVSVxuICAgICAqL1xuICAgIGdldExvY2FsaXplZElkRnJvbUJvb2tOdW1iZXIoYm9va051bTogbnVtYmVyLCBsb2NhbGl6YXRpb25MYW5ndWFnZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+O1xuICB9ICYgSURhdGFQcm92aWRlcjxMb2NhbGl6YXRpb25EYXRhRGF0YVR5cGVzPjtcbiIsImltcG9ydCB7IGRhdGFQcm92aWRlclNlcnZpY2UgfSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL2RhdGEtcHJvdmlkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBjcmVhdGVTeW5jUHJveHlGb3JBc3luY09iamVjdCwgZ2V0TG9jYWxpemVkSWRGcm9tQm9va051bWJlciB9IGZyb20gJ3BsYXRmb3JtLWJpYmxlLXV0aWxzJztcbmltcG9ydCB7XG4gIElMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICBsb2NhbGl6YXRpb25TZXJ2aWNlUHJvdmlkZXJOYW1lLFxuICBsb2NhbGl6YXRpb25TZXJ2aWNlT2JqZWN0VG9Qcm94eSxcbn0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9sb2NhbGl6YXRpb24uc2VydmljZS1tb2RlbCc7XG5cbmxldCBkYXRhUHJvdmlkZXI6IElMb2NhbGl6YXRpb25TZXJ2aWNlO1xubGV0IGluaXRpYWxpemF0aW9uUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcbmFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmICghaW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZXhlY3V0b3IgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBkYXRhUHJvdmlkZXJTZXJ2aWNlLmdldChsb2NhbGl6YXRpb25TZXJ2aWNlUHJvdmlkZXJOYW1lKTtcbiAgICAgICAgICBpZiAoIXByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsaXphdGlvbiBzZXJ2aWNlIHVuZGVmaW5lZCcpO1xuICAgICAgICAgIGRhdGFQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXhlY3V0b3IoKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xufVxuXG5leHBvcnQgY29uc3QgbG9jYWxpemF0aW9uU2VydmljZSA9IGNyZWF0ZVN5bmNQcm94eUZvckFzeW5jT2JqZWN0PElMb2NhbGl6YXRpb25TZXJ2aWNlPihcbiAgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGluaXRpYWxpemUoKTtcbiAgICByZXR1cm4gZGF0YVByb3ZpZGVyO1xuICB9LFxuICB7XG4gICAgLi4ubG9jYWxpemF0aW9uU2VydmljZU9iamVjdFRvUHJveHksXG4gICAgZ2V0TG9jYWxpemVkSWRGcm9tQm9va051bWJlcihib29rTnVtOiBudW1iZXIsIGxvY2FsaXphdGlvbkxhbmd1YWdlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgcmV0dXJuIGdldExvY2FsaXplZElkRnJvbUJvb2tOdW1iZXIoXG4gICAgICAgIGJvb2tOdW0sXG4gICAgICAgIGxvY2FsaXphdGlvbkxhbmd1YWdlLFxuICAgICAgICAoeyBsb2NhbGl6ZUtleSwgLi4ub3B0aW9ucyB9KSA9PlxuICAgICAgICAgIGxvY2FsaXphdGlvblNlcnZpY2UuZ2V0TG9jYWxpemVkU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBsb2NhbGl6ZUtleTogYCUke2xvY2FsaXplS2V5fSVgLFxuICAgICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9LFxuICB9LFxuKTtcblxuZXhwb3J0IGRlZmF1bHQgbG9jYWxpemF0aW9uU2VydmljZTtcbiIsImltcG9ydCBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgbG9nLCB7IExvZ0xldmVsIH0gZnJvbSAnZWxlY3Ryb24tbG9nJztcbmltcG9ydCB7IGdldFByb2Nlc3NUeXBlLCBpc0NsaWVudCwgaXNFeHRlbnNpb25Ib3N0LCBpc1JlbmRlcmVyIH0gZnJvbSAnQHNoYXJlZC91dGlscy9pbnRlcm5hbC11dGlsJztcbmltcG9ydCB7IGluY2x1ZGVzLCBzcGxpdCB9IGZyb20gJ3BsYXRmb3JtLWJpYmxlLXV0aWxzJztcblxuZXhwb3J0IGNvbnN0IFdBUk5fVEFHID0gJzxXQVJOPic7XG5cbi8qKiBSZXByZXNlbnRzIGRldGFpbHMgdGhhdCBjYW4gYmUgcGFyc2VkIGZyb20gYSBzaW5nbGUgbGluZSBvZiBhbiBFcnJvciBvYmplY3QgKi9cbnR5cGUgcGFyc2VkRXJyb3JMaW5lID1cbiAgfCB7XG4gICAgICBmdW5jdGlvbk5hbWU6IHN0cmluZztcbiAgICAgIGZpbGVOYW1lOiBzdHJpbmc7XG4gICAgICBsaW5lTnVtYmVyOiBudW1iZXI7XG4gICAgICBjb2x1bW5OdW1iZXI6IG51bWJlcjtcbiAgICB9XG4gIHwgdW5kZWZpbmVkO1xuXG4vKipcbiAqIERlc3RydWN0dXJlIGEgbGluZSBmcm9tIGFuIEVycm9yIG9iamVjdFxuICpcbiAqIEBwYXJhbSBlcnJvckxpbmUgU2luZ2xlIGxpbmUgZnJvbSBhbiBFcnJvciBvYmplY3Qgc3RyaW5nXG4gKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyB0aGUgZnVuY3Rpb24gbmFtZSwgZmlsZSBuYW1lLCBsaW5lIG51bWJlciwgYW5kIGNvbHVtbiBudW1iZXIgZnJvbSB0aGVcbiAqICAgbGluZSBvZiB0aGUgRXJyb3Igb2JqZWN0IHN0cmluZy4gSWYgdGhlIGxpbmUgY291bGRuJ3QgYmUgcGFyc2VkLCB0aGVuIHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VFcnJvckxpbmUoZXJyb3JMaW5lOiBzdHJpbmcpOiBwYXJzZWRFcnJvckxpbmUge1xuICAvLyBBIGZldyBleGFtcGxlIGxpbmVzIHRvIHBhcnNlOlxuICAvLyBcIiAgICBhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lLmpzOjE1OjI3KVwiXG4gIC8vIFwiYXQgL2hvbWUvdXNlcm5hbWUvcGFyYW5leHQtY29yZS9zcmMvc2hhcmVkL3NlcnZpY2VzL2xvZ2dlci5zZXJ2aWNlLnRzOjExOToyMlwiXG4gIC8vIFwiICAgICBhdCBUaW1lb3V0LmkgW2FzIF9vblRpbWVvdXRdICgvaG9tZS91c2VybmFtZS9wYXJhbmV4dC1jb3JlL2V4dGVuc2lvbnMvZGlzdC9ldmlsL2V2aWwuanM6MTo1OTEpXCJcbiAgY29uc3QgcmVnZXggPSAvYXRbXFxzK10/KFtcXHcgLltcXF08Pl0rKT9cXHMrXFwoPyguKj8pOihcXGQrKTooXFxkKylcXCk/JC87XG4gIGNvbnN0IG1hdGNoZXMgPSBlcnJvckxpbmUubWF0Y2gocmVnZXgpO1xuXG4gIC8vIFRoaXMgY29uc29sZSBsb2cgaXMgaGVscGZ1bCBpZiB5b3UgbmVlZCB0byBzZWUgd2h5IHNvbWUgRXJyb3IgbGluZSBpc24ndCBwYXJzaW5nIGFzIGV4cGVjdGVkXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIC8vIGNvbnNvbGUubG9nKGAqKioqIExJTkU6ICR7ZXJyb3JMaW5lfVxcblJlc3VsdGluZyBmaWxlbmFtZTogJHttYXRjaGVzPy5hdCgyKX1gKTtcblxuICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA9PT0gNSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBjb25zdCBbXywgZnVuY3Rpb25OYW1lLCBmaWxlTmFtZSwgbGluZU51bWJlciwgY29sdW1uTnVtYmVyXSA9IG1hdGNoZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgIGZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogcGFyc2VJbnQobGluZU51bWJlciwgMTApLFxuICAgICAgY29sdW1uTnVtYmVyOiBwYXJzZUludChjb2x1bW5OdW1iZXIsIDEwKSxcbiAgICB9O1xuICB9XG4gIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID09PSA0KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGNvbnN0IFtfLCBmaWxlTmFtZSwgbGluZU51bWJlciwgY29sdW1uTnVtYmVyXSA9IG1hdGNoZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZ1bmN0aW9uTmFtZTogJycsXG4gICAgICBmaWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHBhcnNlSW50KGxpbmVOdW1iZXIsIDEwKSxcbiAgICAgIGNvbHVtbk51bWJlcjogcGFyc2VJbnQoY29sdW1uTnVtYmVyLCAxMCksXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEV4YW1pbmUgdGhlIGNhbGwgc3RhY2sgYW5kIHJldHVybiBhIHBhcnNlZCBzdHJpbmcgY29udGFpbmluZyB0aGUgZnVuY3Rpb24gbmFtZSwgZmlsZSBuYW1lLCBsaW5lXG4gKiBudW1iZXIsIGFuZCBjb2x1bW4gbnVtYmVyIHdoZXJlIHRoZSBjYWxsIHRvIHRoZSBsb2dnZXIgd2FzIG1hZGUuXG4gKlxuICogQHJldHVybnMgU3RyaW5nIHRoYXQgaXMgc3VpdGFibGUgdG8gYXR0YWNoIHRvIGxvZyBvdXRwdXQgdG8gaW5kaWNhdGUgd2hvIHdoYXQgY29kZSB3YW50cyB0byBsb2dcbiAqL1xuZnVuY3Rpb24gaWRlbnRpZnlDYWxsZXIoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgeyBzdGFjayB9ID0gbmV3IEVycm9yKCk7XG4gIGlmICghc3RhY2spIHJldHVybiB1bmRlZmluZWQ7XG4gIGxldCBkZXRhaWxzOiBwYXJzZWRFcnJvckxpbmU7XG4gIGNvbnN0IGxpbmVzID0gc3BsaXQoc3RhY2ssICdcXG4nKTtcbiAgLy8gU3RhcnQgYXQgMyB0byBza2lwIHRoZSBcIkVycm9yXCIgbGluZSwgdGhpcyBmdW5jdGlvbidzIHN0YWNrIGZyYW1lLCBhbmQgdGhpcyBmdW5jdGlvbidzIGNhbGxlclxuICBmb3IgKGxldCBsaW5lTnVtYmVyID0gMzsgbGluZU51bWJlciA8IGxpbmVzLmxlbmd0aDsgbGluZU51bWJlciArPSAxKSB7XG4gICAgLy8gU2tpcCBvdmVyIGFsbCBsb2dnaW5nIGxpYnJhcnkgZnJhbWVzIHRvIGdldCB0byB0aGUgcmVhbCBjYWxsXG4gICAgaWYgKCFpbmNsdWRlcyhsaW5lc1tsaW5lTnVtYmVyXSwgJ25vZGVfbW9kdWxlcycpICYmICFpbmNsdWRlcyhsaW5lc1tsaW5lTnVtYmVyXSwgJ25vZGU6JykpIHtcbiAgICAgIGRldGFpbHMgPSBwYXJzZUVycm9yTGluZShsaW5lc1tsaW5lTnVtYmVyXSk7XG4gICAgICBpZiAoZGV0YWlscykgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghZGV0YWlscykgcmV0dXJuICcnO1xuICBjb25zdCBmdW5jdGlvbk5hbWUgPSBkZXRhaWxzLmZ1bmN0aW9uTmFtZSA/IGAke2RldGFpbHMuZnVuY3Rpb25OYW1lfSBgIDogJyc7XG4gIGNvbnN0IGZpbGVQYXRoID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IGRldGFpbHMuZmlsZU5hbWUgOiBgZmlsZTovLyR7ZGV0YWlscy5maWxlTmFtZX1gO1xuICByZXR1cm4gYFthdCAke2Z1bmN0aW9uTmFtZX0ke2ZpbGVQYXRofToke2RldGFpbHMubGluZU51bWJlcn06JHtkZXRhaWxzLmNvbHVtbk51bWJlcn1dYDtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBzdHJpbmcgb2YgYSBzZXJ2aWNlIG1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIGZyb20gdGhlIHNlcnZpY2VcbiAqIEBwYXJhbSBzZXJ2aWNlTmFtZSBOYW1lIG9mIHRoZSBzZXJ2aWNlIHRvIHNob3cgaW4gdGhlIGxvZ1xuICogQHBhcmFtIHRhZyBPcHRpb25hbCB0YWcgYXQgdGhlIGVuZCBvZiB0aGUgc2VydmljZSBuYW1lXG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgc3RyaW5nIG9mIGEgc2VydmljZSBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRMb2cobWVzc2FnZTogc3RyaW5nLCBzZXJ2aWNlTmFtZTogc3RyaW5nLCB0YWcgPSAnJykge1xuICAvLyBSZW1vdmUgdGhlIG5ldyBsaW5lIGF0IHRoZSBlbmQgb2YgZXZlcnkgbWVzc2FnZSBjb21pbmcgZnJvbSBzdGRvdXQgZnJvbSBvdGhlciBwcm9jZXNzZXNcbiAgY29uc3QgbWVzc2FnZVRyaW1tZWQgPSBtZXNzYWdlLnRyaW1FbmQoKTtcbiAgY29uc3Qgb3BlblRhZyA9IGBbJHtzZXJ2aWNlTmFtZX0ke3RhZyA/ICcgJyA6ICcnfSR7dGFnfV1gO1xuICBpZiAoaW5jbHVkZXMobWVzc2FnZVRyaW1tZWQsICdcXG4nKSkge1xuICAgIGNvbnN0IGNsb3NlVGFnID0gYFsvJHtzZXJ2aWNlTmFtZX0ke3RhZyA/ICcgJyA6ICcnfSR7dGFnfV1gO1xuICAgIC8vIE11bHRpLWxpbmVcbiAgICByZXR1cm4gYFxcbiR7b3BlblRhZ31cXG4ke21lc3NhZ2VUcmltbWVkfVxcbiR7Y2xvc2VUYWd9YDtcbiAgfVxuICByZXR1cm4gYCR7b3BlblRhZ30gJHttZXNzYWdlVHJpbW1lZH1gO1xufVxuXG4vKiogQWJzdHJhY3QgYW5kIHNoaW0gdGhlIGxvZ2dlciAqL1xuXG5pZiAoaXNDbGllbnQoKSkge1xuICBsb2cudHJhbnNwb3J0cy5jb25zb2xlLmxldmVsID0gZ2xvYmFsVGhpcy5sb2dMZXZlbDtcbiAgaWYgKGlzUmVuZGVyZXIoKSlcbiAgICAvLyBPbiB0aGUgcmVuZGVyZXIsIGluc2VydCBmb3JtYXR0aW5nIGJlZm9yZSBzZW5kaW5nXG4gICAgbG9nLmhvb2tzLnB1c2goKG1lc3NhZ2UpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxlciA9IGlkZW50aWZ5Q2FsbGVyKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICBkYXRhOiBtZXNzYWdlLmRhdGEubWFwKChsb2dMaW5lKSA9PlxuICAgICAgICAgIGZvcm1hdExvZyhcbiAgICAgICAgICAgIGNhbGxlciA/IGAke2xvZ0xpbmV9ICR7Y2FsbGVyfWAgOiBgJHtsb2dMaW5lfWAsXG4gICAgICAgICAgICBnZXRQcm9jZXNzVHlwZSgpLFxuICAgICAgICAgICAgLy8gUmVuZGVyZXIgc2VuZHMgYmFjayB3aXRoIGxvZyBsZXZlbCBvZiBsb2cuIE5vdCBzdXJlIHdoeSBpdCdzIG5vdCBpbiB0aGUgdHlwZVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgICAgICAobWVzc2FnZS5sZXZlbCBhcyBMb2dMZXZlbCB8ICdsb2cnKSA9PT0gJ2xvZycgPyB1bmRlZmluZWQgOiBtZXNzYWdlLmxldmVsLFxuICAgICAgICAgICksXG4gICAgICAgICksXG4gICAgICB9O1xuICAgIH0pO1xuICBlbHNlIGlmIChpc0V4dGVuc2lvbkhvc3QoKSlcbiAgICAvLyBBZGQgYSB0YWcgZm9yIHdhcm5pbmdzIHNvIHdlIGNhbiByZWNvZ25pemUgdGhlbSBvdXRzaWRlIHRoZSBwcm9jZXNzLlxuICAgIGxvZy5ob29rcy5wdXNoKChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCBjYWxsZXIgPSBpZGVudGlmeUNhbGxlcigpO1xuICAgICAgY29uc3QgbGluZUVuZCA9IGNhbGxlciA/IGAgJHtjYWxsZXJ9YCA6ICcnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgZGF0YTogbWVzc2FnZS5kYXRhLm1hcCgobG9nTGluZSkgPT5cbiAgICAgICAgICBtZXNzYWdlLmxldmVsID09PSAnd2FybicgPyBgJHtXQVJOX1RBR30ke2xvZ0xpbmV9JHtsaW5lRW5kfWAgOiBgJHtsb2dMaW5lfSR7bGluZUVuZH1gLFxuICAgICAgICApLFxuICAgICAgfTtcbiAgICB9KTtcbiAgZWxzZSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oY2hhbGsueWVsbG93KGBVbmV4cGVjdGVkIHByb2Nlc3MgdHlwZTogJHtnbG9iYWxUaGlzLnByb2Nlc3NUeXBlfWApKTtcbiAgfVxufSBlbHNlIHtcbiAgbG9nLmluaXRpYWxpemUoKTtcbiAgbG9nLnRyYW5zcG9ydHMuY29uc29sZS5sZXZlbCA9IGdsb2JhbFRoaXMubG9nTGV2ZWw7XG4gIGxvZy50cmFuc3BvcnRzLmNvbnNvbGUuZm9ybWF0ID0gJ3tofTp7aX06e3N9IHt0ZXh0fSc7XG4gIGxvZy50cmFuc3BvcnRzLmNvbnNvbGUud3JpdGVGbiA9ICh7IG1lc3NhZ2U6IG1zZyB9KSA9PiB7XG4gICAgbGV0IG1lc3NhZ2UgPSBgJHttc2cuZGF0YX1gO1xuICAgIC8vIElmIHdlJ3JlIHBpcGluZyB0aHJvdWdoIGEgbG9nIG1lc3NhZ2UgZnJvbSBhbm90aGVyIHNlcnZpY2UsIGRvbid0IGFkZCBhbm90aGVyIGZpbGUgcGF0aFxuICAgIC8vIE1lc3NhZ2VzIGZyb20gb3RoZXIgc2VydmljZXMgYWxsIHN0YXJ0IHdpdGggXCJbc2VydmljZSBuYW1lXVwiXG4gICAgaWYgKCEvXFxbW1xcdyBdK1xcXS8udGVzdChtZXNzYWdlKSkge1xuICAgICAgY29uc3QgY2FsbGVyID0gaWRlbnRpZnlDYWxsZXIoKTtcbiAgICAgIG1lc3NhZ2UgPSBjYWxsZXIgPyBgJHttZXNzYWdlfSAke2NhbGxlcn1gIDogYCR7bWVzc2FnZX1gO1xuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICBzd2l0Y2ggKG1zZy5sZXZlbCkge1xuICAgICAgY2FzZSAnaW5mbyc6XG4gICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dhcm4nOlxuICAgICAgICBjb25zb2xlLmxvZyhjaGFsay55ZWxsb3cobWVzc2FnZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgY29uc29sZS5sb2coY2hhbGsucmVkKG1lc3NhZ2UpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgfTtcbiAgbG9nLnRyYW5zcG9ydHMuZmlsZS5sZXZlbCA9IGdsb2JhbFRoaXMubG9nTGV2ZWw7XG59XG5cbi8qKlxuICogSlNET0MgU09VUkNFIGxvZ2dlclxuICpcbiAqIEFsbCBleHRlbnNpb25zIGFuZCBzZXJ2aWNlcyBzaG91bGQgdXNlIHRoaXMgbG9nZ2VyIHRvIHByb3ZpZGUgYSB1bmlmaWVkIG91dHB1dCBvZiBsb2dzXG4gKi9cbmV4cG9ydCBjb25zdCBsb2dnZXIgPSBsb2c7XG5leHBvcnQgZGVmYXVsdCBsb2dnZXI7XG4iLCJpbXBvcnQge1xuICBPbkRpZERpc3Bvc2UsXG4gIFVuc3Vic2NyaWJlckFzeW5jLFxuICBNdWx0aUNvbHVtbk1lbnUsXG4gIFJlZmVyZW5jZWRJdGVtLFxuICBXZWJWaWV3TWVudSxcbiAgTG9jYWxpemVkLFxufSBmcm9tICdwbGF0Zm9ybS1iaWJsZS11dGlscyc7XG5pbXBvcnQge1xuICBEYXRhUHJvdmlkZXJEYXRhVHlwZSxcbiAgRGF0YVByb3ZpZGVyU3Vic2NyaWJlck9wdGlvbnMsXG4gIERhdGFQcm92aWRlclVwZGF0ZUluc3RydWN0aW9ucyxcbn0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvZGF0YS1wcm92aWRlci5tb2RlbCc7XG5pbXBvcnQgeyBJRGF0YVByb3ZpZGVyIH0gZnJvbSAnLi9wYXBpLWNvcmUuc2VydmljZSc7XG5cbi8qKiBKU0RPQyBERVNUSU5BVElPTiBtZW51RGF0YVNlcnZpY2VQcm92aWRlck5hbWUgKi9cbmV4cG9ydCBjb25zdCBtZW51RGF0YVNlcnZpY2VQcm92aWRlck5hbWUgPSAncGxhdGZvcm0ubWVudURhdGFTZXJ2aWNlRGF0YVByb3ZpZGVyJztcbmV4cG9ydCBjb25zdCBtZW51RGF0YVNlcnZpY2VPYmplY3RUb1Byb3h5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC8qKlxuICAgKiBKU0RPQyBTT1VSQ0UgbWVudURhdGFTZXJ2aWNlUHJvdmlkZXJOYW1lXG4gICAqXG4gICAqIFRoaXMgbmFtZSBpcyB1c2VkIHRvIHJlZ2lzdGVyIHRoZSBtZW51IGRhdGEgZGF0YSBwcm92aWRlciBvbiB0aGUgcGFwaS4gWW91IGNhbiB1c2UgdGhpcyBuYW1lIHRvXG4gICAqIGZpbmQgdGhlIGRhdGEgcHJvdmlkZXIgd2hlbiBhY2Nlc3NpbmcgaXQgdXNpbmcgdGhlIHVzZURhdGEgaG9va1xuICAgKi9cbiAgZGF0YVByb3ZpZGVyTmFtZTogbWVudURhdGFTZXJ2aWNlUHJvdmlkZXJOYW1lLFxufSk7XG5cbi8vIERhdGEgVHlwZSB0byBpbml0aWFsaXplIGRhdGEgcHJvdmlkZXIgZW5naW5lIHdpdGhcbmV4cG9ydCB0eXBlIE1lbnVEYXRhRGF0YVR5cGVzID0ge1xuICBNYWluTWVudTogRGF0YVByb3ZpZGVyRGF0YVR5cGU8dW5kZWZpbmVkLCBMb2NhbGl6ZWQ8TXVsdGlDb2x1bW5NZW51PiwgbmV2ZXI+O1xuICBVbmxvY2FsaXplZE1haW5NZW51OiBEYXRhUHJvdmlkZXJEYXRhVHlwZTx1bmRlZmluZWQsIE11bHRpQ29sdW1uTWVudSwgbmV2ZXI+O1xuICBXZWJWaWV3TWVudTogRGF0YVByb3ZpZGVyRGF0YVR5cGU8UmVmZXJlbmNlZEl0ZW0sIExvY2FsaXplZDxXZWJWaWV3TWVudT4sIG5ldmVyPjtcbn07XG5cbmRlY2xhcmUgbW9kdWxlICdwYXBpLXNoYXJlZC10eXBlcycge1xuICBleHBvcnQgaW50ZXJmYWNlIERhdGFQcm92aWRlcnMge1xuICAgIFttZW51RGF0YVNlcnZpY2VQcm92aWRlck5hbWVdOiBJTWVudURhdGFTZXJ2aWNlO1xuICB9XG59XG5cbi8qKlxuICogSlNET0MgU09VUkNFIG1lbnVEYXRhU2VydmljZVxuICpcbiAqIFNlcnZpY2UgdGhhdCBhbGxvd3MgdG8gZ2V0IGFuZCBzdG9yZSBtZW51IGRhdGFcbiAqL1xuZXhwb3J0IHR5cGUgSU1lbnVEYXRhU2VydmljZSA9IHtcbiAgLyoqIFJlYnVpbGQgdGhlIG1lbnVzIHdpdGggdGhlIGxhdGVzdCBpbnB1dHMgZnJvbSBhbGwgZXh0ZW5zaW9ucy4gKi9cbiAgcmVidWlsZE1lbnVzKCk6IFByb21pc2U8dm9pZD47XG4gIC8qKlxuICAgKiBKU0RPQyBTT1VSQ0UgZ2V0TWFpbk1lbnVcbiAgICpcbiAgICogR2V0IGxvY2FsaXplZCBtZW51IGNvbnRlbnQgZm9yIHRoZSBtYWluIG1lbnVcbiAgICpcbiAgICogQHBhcmFtIG1haW5NZW51VHlwZSBEb2VzIG5vdCBoYXZlIHRvIGJlIGRlZmluZWRcbiAgICogQHJldHVybnMgTXVsdGlDb2x1bW5NZW51IG9iamVjdCBvZiBsb2NhbGl6ZWQgbWFpbiBtZW51IGNvbnRlbnRcbiAgICovXG4gIGdldE1haW5NZW51KG1haW5NZW51VHlwZTogdW5kZWZpbmVkKTogUHJvbWlzZTxMb2NhbGl6ZWQ8TXVsdGlDb2x1bW5NZW51Pj47XG4gIC8qKiBKU0RPQyBERVNUSU5BVElPTiBnZXRNYWluTWVudSAqL1xuICBnZXRNYWluTWVudSgpOiBQcm9taXNlPExvY2FsaXplZDxNdWx0aUNvbHVtbk1lbnU+PjtcbiAgLyoqXG4gICAqIFRoaXMgZGF0YSBjYW5ub3QgYmUgY2hhbmdlZC4gVHJ5aW5nIHRvIHVzZSB0aGlzIHNldHRlciB0aGlzIHdpbGwgYWx3YXlzIHRocm93XG4gICAqXG4gICAqIEBwYXJhbSBtYWluTWVudVR5cGUgRG9lcyBub3QgaGF2ZSB0byBiZSBkZWZpbmVkXG4gICAqIEBwYXJhbSB2YWx1ZSBNdWx0aUNvbHVtbk1lbnUgb2JqZWN0IHRvIHNldCBhcyB0aGUgbG9jYWxpemVkIG1haW4gbWVudVxuICAgKiBAcmV0dXJucyBVbnN1YnNjcmliZXIgZnVuY3Rpb25cbiAgICovXG4gIHNldE1haW5NZW51KFxuICAgIG1haW5NZW51VHlwZTogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiBuZXZlcixcbiAgKTogUHJvbWlzZTxEYXRhUHJvdmlkZXJVcGRhdGVJbnN0cnVjdGlvbnM8TWVudURhdGFEYXRhVHlwZXM+PjtcbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBydW4gYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBsb2NhbGl6ZWQgbWFpbiBtZW51IGRhdGEgaXMgY2hhbmdlZFxuICAgKlxuICAgKiBAcGFyYW0gbWFpbk1lbnVUeXBlIERvZXMgbm90IGhhdmUgdG8gYmUgZGVmaW5lZFxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gcnVuIHdpdGggdGhlIHVwZGF0ZWQgbG9jYWxpemVkIG1lbnVDb250ZW50IGZvciB0aGlzIHNlbGVjdG9yXG4gICAqIEBwYXJhbSBvcHRpb25zIFZhcmlvdXMgb3B0aW9ucyB0byBhZGp1c3QgaG93IHRoZSBzdWJzY3JpYmVyIGVtaXRzIHVwZGF0ZXNcbiAgICogQHJldHVybnMgVW5zdWJzY3JpYmVyIGZ1bmN0aW9uIChydW4gdG8gdW5zdWJzY3JpYmUgZnJvbSBsaXN0ZW5pbmcgZm9yIHVwZGF0ZXMpXG4gICAqL1xuICBzdWJzY3JpYmVNYWluTWVudShcbiAgICBtYWluTWVudVR5cGU6IHVuZGVmaW5lZCxcbiAgICBjYWxsYmFjazogKG1lbnVDb250ZW50OiBMb2NhbGl6ZWQ8TXVsdGlDb2x1bW5NZW51PikgPT4gdm9pZCxcbiAgICBvcHRpb25zPzogRGF0YVByb3ZpZGVyU3Vic2NyaWJlck9wdGlvbnMsXG4gICk6IFByb21pc2U8VW5zdWJzY3JpYmVyQXN5bmM+O1xuICAvKipcbiAgICogSlNET0MgU09VUkNFIGdldFVubG9jYWxpemVkTWFpbk1lbnVcbiAgICpcbiAgICogR2V0IHVubG9jYWxpemVkIG1lbnUgY29udGVudCBmb3IgdGhlIG1haW4gbWVudVxuICAgKlxuICAgKiBAcGFyYW0gbWFpbk1lbnVUeXBlIERvZXMgbm90IGhhdmUgdG8gYmUgZGVmaW5lZFxuICAgKiBAcmV0dXJucyBNdWx0aUNvbHVtbk1lbnUgb2JqZWN0IG9mIHVubG9jYWxpemVkIG1haW4gbWVudSBjb250ZW50XG4gICAqL1xuICBnZXRVbmxvY2FsaXplZE1haW5NZW51KG1haW5NZW51VHlwZTogdW5kZWZpbmVkKTogUHJvbWlzZTxNdWx0aUNvbHVtbk1lbnU+O1xuICAvKiogSlNET0MgREVTVElOQVRJT04gZ2V0VW5sb2NhbGl6ZWRNYWluTWVudSAqL1xuICBnZXRVbmxvY2FsaXplZE1haW5NZW51KCk6IFByb21pc2U8TXVsdGlDb2x1bW5NZW51PjtcbiAgLyoqXG4gICAqIFRoaXMgZGF0YSBjYW5ub3QgYmUgY2hhbmdlZC4gVHJ5aW5nIHRvIHVzZSB0aGlzIHNldHRlciB0aGlzIHdpbGwgYWx3YXlzIHRocm93XG4gICAqXG4gICAqIEBwYXJhbSBtYWluTWVudVR5cGUgRG9lcyBub3QgaGF2ZSB0byBiZSBkZWZpbmVkXG4gICAqIEBwYXJhbSB2YWx1ZSBNdWx0aUNvbHVtbk1lbnUgb2JqZWN0IHRvIHNldCBhcyB0aGUgdW5sb2NhbGl6ZWQgbWFpbiBtZW51XG4gICAqIEByZXR1cm5zIFVuc3Vic2NyaWJlciBmdW5jdGlvblxuICAgKi9cbiAgc2V0VW5sb2NhbGl6ZWRNYWluTWVudShcbiAgICBtYWluTWVudVR5cGU6IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogbmV2ZXIsXG4gICk6IFByb21pc2U8RGF0YVByb3ZpZGVyVXBkYXRlSW5zdHJ1Y3Rpb25zPE1lbnVEYXRhRGF0YVR5cGVzPj47XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gcnVuIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgdW5sb2NhbGl6ZWQgbWFpbiBtZW51IGRhdGEgaXMgY2hhbmdlZFxuICAgKlxuICAgKiBAcGFyYW0gbWFpbk1lbnVUeXBlIERvZXMgbm90IGhhdmUgdG8gYmUgZGVmaW5lZFxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gcnVuIHdpdGggdGhlIHVwZGF0ZWQgdW5sb2NhbGl6ZWQgbWVudUNvbnRlbnQgZm9yIHRoaXMgc2VsZWN0b3JcbiAgICogQHBhcmFtIG9wdGlvbnMgVmFyaW91cyBvcHRpb25zIHRvIGFkanVzdCBob3cgdGhlIHN1YnNjcmliZXIgZW1pdHMgdXBkYXRlc1xuICAgKiBAcmV0dXJucyBVbnN1YnNjcmliZXIgZnVuY3Rpb24gKHJ1biB0byB1bnN1YnNjcmliZSBmcm9tIGxpc3RlbmluZyBmb3IgdXBkYXRlcylcbiAgICovXG4gIHN1YnNjcmliZVVubG9jYWxpemVkTWFpbk1lbnUoXG4gICAgbWFpbk1lbnVUeXBlOiB1bmRlZmluZWQsXG4gICAgY2FsbGJhY2s6IChtZW51Q29udGVudDogTXVsdGlDb2x1bW5NZW51KSA9PiB2b2lkLFxuICAgIG9wdGlvbnM/OiBEYXRhUHJvdmlkZXJTdWJzY3JpYmVyT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxVbnN1YnNjcmliZXJBc3luYz47XG4gIC8qKlxuICAgKiBHZXQgbG9jYWxpemVkIG1lbnUgY29udGVudCBmb3IgYSB3ZWIgdmlld1xuICAgKlxuICAgKiBAcGFyYW0gd2ViVmlld1R5cGUgVGhlIHR5cGUgb2Ygd2VidmlldyBmb3Igd2hpY2ggYSBtZW51IHNob3VsZCBiZSByZXRyaWV2ZWRcbiAgICogQHJldHVybnMgV2ViVmlld01lbnUgb2JqZWN0IG9mIHdlYiB2aWV3IG1lbnUgY29udGVudFxuICAgKi9cbiAgZ2V0V2ViVmlld01lbnUod2ViVmlld1R5cGU6IFJlZmVyZW5jZWRJdGVtKTogUHJvbWlzZTxMb2NhbGl6ZWQ8V2ViVmlld01lbnU+PjtcbiAgLyoqXG4gICAqIFRoaXMgZGF0YSBjYW5ub3QgYmUgY2hhbmdlZC4gVHJ5aW5nIHRvIHVzZSB0aGlzIHNldHRlciB0aGlzIHdpbGwgYWx3YXlzIHRocm93XG4gICAqXG4gICAqIEBwYXJhbSB3ZWJWaWV3VHlwZSBUaGUgdHlwZSBvZiB3ZWJ2aWV3IGZvciB3aGljaCBhIG1lbnUgc2hvdWxkIGJlIHNldFxuICAgKiBAcGFyYW0gdmFsdWUgTWVudSBvZiBzcGVjaWZpZWQgd2ViVmlld1R5cGVcbiAgICogQHJldHVybnMgVW5zdWJzY3JpYmVyIGZ1bmN0aW9uXG4gICAqL1xuICBzZXRXZWJWaWV3TWVudShcbiAgICB3ZWJWaWV3VHlwZTogUmVmZXJlbmNlZEl0ZW0sXG4gICAgdmFsdWU6IG5ldmVyLFxuICApOiBQcm9taXNlPERhdGFQcm92aWRlclVwZGF0ZUluc3RydWN0aW9uczxNZW51RGF0YURhdGFUeXBlcz4+O1xuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHJ1biBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGxvY2FsaXplZCB3ZWIgdmlldyBtZW51IGRhdGEgaXMgY2hhbmdlZFxuICAgKlxuICAgKiBAcGFyYW0gd2ViVmlld1R5cGUgVGhlIHR5cGUgb2Ygd2VidmlldyBmb3Igd2hpY2ggYSBtZW51IHNob3VsZCBiZSBzdWJzY3JpYmVkXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBydW4gd2l0aCB0aGUgdXBkYXRlZCBtZW51Q29udGVudCBmb3IgdGhpcyBzZWxlY3RvclxuICAgKiBAcGFyYW0gb3B0aW9ucyBWYXJpb3VzIG9wdGlvbnMgdG8gYWRqdXN0IGhvdyB0aGUgc3Vic2NyaWJlciBlbWl0cyB1cGRhdGVzXG4gICAqIEByZXR1cm5zIFVuc3Vic2NyaWJlciBmdW5jdGlvbiAocnVuIHRvIHVuc3Vic2NyaWJlIGZyb20gbGlzdGVuaW5nIGZvciB1cGRhdGVzKVxuICAgKi9cbiAgc3Vic2NyaWJlV2ViVmlld01lbnUoXG4gICAgd2ViVmlld1R5cGU6IFJlZmVyZW5jZWRJdGVtLFxuICAgIGNhbGxiYWNrOiAobWVudUNvbnRlbnQ6IExvY2FsaXplZDxXZWJWaWV3TWVudT4pID0+IHZvaWQsXG4gICAgb3B0aW9ucz86IERhdGFQcm92aWRlclN1YnNjcmliZXJPcHRpb25zLFxuICApOiBQcm9taXNlPFVuc3Vic2NyaWJlckFzeW5jPjtcbn0gJiBPbkRpZERpc3Bvc2UgJlxuICB0eXBlb2YgbWVudURhdGFTZXJ2aWNlT2JqZWN0VG9Qcm94eSAmXG4gIElEYXRhUHJvdmlkZXI8TWVudURhdGFEYXRhVHlwZXM+O1xuIiwiaW1wb3J0IHsgZGF0YVByb3ZpZGVyU2VydmljZSB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvZGF0YS1wcm92aWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IGNyZWF0ZVN5bmNQcm94eUZvckFzeW5jT2JqZWN0IH0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuaW1wb3J0IHtcbiAgSU1lbnVEYXRhU2VydmljZSxcbiAgbWVudURhdGFTZXJ2aWNlT2JqZWN0VG9Qcm94eSxcbiAgbWVudURhdGFTZXJ2aWNlUHJvdmlkZXJOYW1lLFxufSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL21lbnUtZGF0YS5zZXJ2aWNlLW1vZGVsJztcblxubGV0IGRhdGFQcm92aWRlcjogSU1lbnVEYXRhU2VydmljZTtcbmxldCBpbml0aWFsaXphdGlvblByb21pc2U6IFByb21pc2U8dm9pZD47XG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICBpZiAoIWluaXRpYWxpemF0aW9uUHJvbWlzZSkge1xuICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGV4ZWN1dG9yID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZGF0YVByb3ZpZGVyU2VydmljZS5nZXQobWVudURhdGFTZXJ2aWNlUHJvdmlkZXJOYW1lKTtcbiAgICAgICAgICBpZiAoIXByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ01lbnUgZGF0YSBzZXJ2aWNlIHVuZGVmaW5lZCcpO1xuICAgICAgICAgIGRhdGFQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXhlY3V0b3IoKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xufVxuXG5leHBvcnQgY29uc3QgbWVudURhdGFTZXJ2aWNlID0gY3JlYXRlU3luY1Byb3h5Rm9yQXN5bmNPYmplY3Q8SU1lbnVEYXRhU2VydmljZT4oYXN5bmMgKCkgPT4ge1xuICBhd2FpdCBpbml0aWFsaXplKCk7XG4gIHJldHVybiBkYXRhUHJvdmlkZXI7XG59LCBtZW51RGF0YVNlcnZpY2VPYmplY3RUb1Byb3h5KTtcblxuZXhwb3J0IGRlZmF1bHQgbWVudURhdGFTZXJ2aWNlO1xuIiwiaW1wb3J0IHsgTmV0d29ya09iamVjdERldGFpbHMgfSBmcm9tICdAc2hhcmVkL21vZGVscy9uZXR3b3JrLW9iamVjdC5tb2RlbCc7XG5pbXBvcnQge1xuICBuZXR3b3JrT2JqZWN0U3RhdHVzU2VydmljZU5ldHdvcmtPYmplY3ROYW1lLFxuICBOZXR3b3JrT2JqZWN0U3RhdHVzUmVtb3RlU2VydmljZVR5cGUsXG4gIE5ldHdvcmtPYmplY3RTdGF0dXNTZXJ2aWNlVHlwZSxcbn0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvbmV0d29yay1vYmplY3Qtc3RhdHVzLnNlcnZpY2UtbW9kZWwnO1xuaW1wb3J0IHtcbiAgbmV0d29ya09iamVjdFNlcnZpY2UsXG4gIG9uRGlkQ3JlYXRlTmV0d29ya09iamVjdCxcbn0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9uZXR3b3JrLW9iamVjdC5zZXJ2aWNlJztcbmltcG9ydCB7IEFzeW5jVmFyaWFibGUsIGlzU3Vic2V0IH0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuXG5sZXQgbmV0d29ya09iamVjdDogTmV0d29ya09iamVjdFN0YXR1c1JlbW90ZVNlcnZpY2VUeXBlO1xubGV0IGluaXRpYWxpemF0aW9uUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcbmFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmICghaW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZXhlY3V0b3IgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbG9jYWxOZXR3b3JrT2JqZWN0U3RhdHVzU2VydmljZSA9XG4gICAgICAgICAgICBhd2FpdCBuZXR3b3JrT2JqZWN0U2VydmljZS5nZXQ8TmV0d29ya09iamVjdFN0YXR1c1NlcnZpY2VUeXBlPihcbiAgICAgICAgICAgICAgbmV0d29ya09iamVjdFN0YXR1c1NlcnZpY2VOZXR3b3JrT2JqZWN0TmFtZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFsb2NhbE5ldHdvcmtPYmplY3RTdGF0dXNTZXJ2aWNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgJHtuZXR3b3JrT2JqZWN0U3RhdHVzU2VydmljZU5ldHdvcmtPYmplY3ROYW1lfSBpcyBub3QgYXZhaWxhYmxlIGFzIGEgbmV0d29yayBvYmplY3RgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBuZXR3b3JrT2JqZWN0ID0gbG9jYWxOZXR3b3JrT2JqZWN0U3RhdHVzU2VydmljZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGV4ZWN1dG9yKCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGluaXRpYWxpemF0aW9uUHJvbWlzZTtcbn1cblxuLy8gSWYgd2UgZXZlciB3YW50IHRvIGJlIG1vcmUgY2xldmVyLCB3ZSBjb3VsZCBqdXN0IGtlZXAgYSBsb2NhbCAodG8gdGhpcyBwcm9jZXNzKSBjYWNoZSBvZiB0aGVcbi8vIGFjdGl2ZSBuZXR3b3JrIG9iamVjdHMuIElmIHdlIGRvIHRoYXQsIHdlJ2xsIGhhdmUgdG8gZGVhbCB3aXRoIGluaXRpYWwgcmFjZSBjb25kaXRpb25zIGFyb3VuZFxuLy8gZ2V0dGluZyBhIG5ldHdvcmsgb2JqZWN0IGRpc3Bvc2VkIG1lc3NhZ2UgaW4gdGhpcyBwcm9jZXNzIGJlZm9yZSBoYW5kbGluZyB0aGUgc25hcHNob3QgZnJvbVxuLy8gdGhlIHNlcnZpY2UgaG9zdCB0aGF0IGluY2x1ZGVzIHRoZSAobm93IGRpc3Bvc2VkKSBuZXR3b3JrIG9iamVjdC4gSnVzdCBhc2tpbmcgdGhlIHJlbW90ZSBzZXJ2aWNlXG4vLyBpcyBsZXNzIGVycm9yIHByb25lLCBidXQgc2xvd2VyLCB3aGVuZXZlciB3ZSBnZXQgYSByZXF1ZXN0IGZvciB0aGUgbGF0ZXN0IG5ldHdvcmsgb2JqZWN0cy5cbmFzeW5jIGZ1bmN0aW9uIGdldEFsbE5ldHdvcmtPYmplY3REZXRhaWxzKCk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgTmV0d29ya09iamVjdERldGFpbHM+PiB7XG4gIGF3YWl0IGluaXRpYWxpemUoKTtcbiAgcmV0dXJuIG5ldHdvcmtPYmplY3QuZ2V0QWxsTmV0d29ya09iamVjdERldGFpbHMoKTtcbn1cblxuLy8gSWRlYWxseSB3ZSB3b3VsZCB1c2UgdGhpcyBpbnNpZGUgdGhlIG5ldHdvcmsgb2JqZWN0IHNlcnZpY2UgdG8gYmUgZXZlbnQtYmFzZWQgaW5zdGVhZCBvZiBwb2xsaW5nXG4vLyB3aGlsZSB3YWl0aW5nIGZvciBuZXR3b3JrIG9iamVjdHMgdG8gYmUgY3JlYXRlZC4gVGhhdCB3b3VsZCBjcmVhdGUgYSBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW5cbi8vIHRoaXMgc2VydmljZSBhbmQgdGhlIG5ldHdvcmsgb2JqZWN0IHNlcnZpY2UsIHRob3VnaCwgd2hpY2ggaXMgbW9zdCBlYXNpbHkgcmVzb2x2ZWQgYnkgbWVyZ2luZ1xuLy8gdGhpcyBjb2RlIGludG8gdGhlIG5ldHdvcmsgb2JqZWN0IHNlcnZpY2UuIFRoYXQgc2VydmljZSBpcyBwcmV0dHkgYmlnIGFzIGl0IGlzLCBzbyB0byBvcHRpbWl6ZVxuLy8gZm9yIGNvZGUgdW5kZXJzdGFuZGFiaWxpdHkgd2UnbGwganVzdCBsZWF2ZSBpdCBhcy1pcyBhbmQgcG9sbCBpbnNpZGUgdGhlIG5ldHdvcmsgb2JqZWN0IHNlcnZpY2Vcbi8vIGBnZXRgIGZvciBub3cuIE90aGVyIHNlcnZpY2VzIHdpbGwgaGF2ZSB0byBjYWxsIHRoaXMgZGlyZWN0bHkgaWYgdGhleSB3YW50IHRvIGJlIGV2ZW50IGJhc2VkLlxuYXN5bmMgZnVuY3Rpb24gd2FpdEZvck5ldHdvcmtPYmplY3QoXG4gIG9iamVjdERldGFpbHNUb01hdGNoOiBQYXJ0aWFsPE5ldHdvcmtPYmplY3REZXRhaWxzPixcbiAgdGltZW91dEluTVM/OiBudW1iZXIsXG4pOiBQcm9taXNlPE5ldHdvcmtPYmplY3REZXRhaWxzPiB7XG4gIGNvbnN0IGFzeW5jVmFyID0gbmV3IEFzeW5jVmFyaWFibGU8TmV0d29ya09iamVjdERldGFpbHM+KFxuICAgIGB3YWl0LWZvci1uZXQtb2JqIHdpdGggZGV0YWlscyAke0pTT04uc3RyaW5naWZ5KG9iamVjdERldGFpbHNUb01hdGNoKX1gLFxuICAgIHRpbWVvdXRJbk1TID8/IC0xLFxuICApO1xuICB0cnkge1xuICAgIC8vIFdhdGNoIHRoZSBzdHJlYW0gb2YgaW5jb21pbmcgbmV0d29yayBvYmplY3RzIGJlZm9yZSBnZXR0aW5nIGEgc25hcHNob3QgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgY29uc3QgdW5zdWIgPSBvbkRpZENyZWF0ZU5ldHdvcmtPYmplY3QoKG5ldHdvcmtPYmplY3REZXRhaWxzKSA9PiB7XG4gICAgICBpZiAoIWFzeW5jVmFyLmhhc1NldHRsZWQgJiYgaXNTdWJzZXQobmV0d29ya09iamVjdERldGFpbHMsIG9iamVjdERldGFpbHNUb01hdGNoKSkge1xuICAgICAgICBhc3luY1Zhci5yZXNvbHZlVG9WYWx1ZShuZXR3b3JrT2JqZWN0RGV0YWlscywgZmFsc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGFzeW5jVmFyLmhhc1NldHRsZWQpIHtcbiAgICAgICAgdW5zdWIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBOb3cgY2hlY2sgaWYgdGhlIG5lZWRlZCBuZXR3b3JrIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICBjb25zdCBleGlzdGluZ05ldHdvcmtPYmplY3REZXRhaWxzID0gYXdhaXQgZ2V0QWxsTmV0d29ya09iamVjdERldGFpbHMoKTtcbiAgICBpZiAoIWFzeW5jVmFyLmhhc1NldHRsZWQpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gT2JqZWN0LnZhbHVlcyhleGlzdGluZ05ldHdvcmtPYmplY3REZXRhaWxzKS5maW5kKChuZXR3b3JrT2JqZWN0RGV0YWlscykgPT5cbiAgICAgICAgaXNTdWJzZXQobmV0d29ya09iamVjdERldGFpbHMsIG9iamVjdERldGFpbHNUb01hdGNoKSxcbiAgICAgICk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgYXN5bmNWYXIucmVzb2x2ZVRvVmFsdWUobWF0Y2gsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYHdhaXRGb3JOZXR3b3JrT2JqZWN0IGZhaWxlZCBmb3IgZGV0YWlscyAke0pTT04uc3RyaW5naWZ5KG9iamVjdERldGFpbHNUb01hdGNoKX0hICR7ZX1gO1xuICAgIGFzeW5jVmFyLnJlamVjdFdpdGhSZWFzb24obWVzc2FnZSwgdHJ1ZSk7XG4gICAgdGhyb3cgZTtcbiAgfVxuICByZXR1cm4gYXN5bmNWYXIucHJvbWlzZTtcbn1cblxuLyoqXG4gKiBKU0RPQyBTT1VSQ0UgbmV0d29ya09iamVjdFN0YXR1c1NlcnZpY2VcbiAqXG4gKiBQcm92aWRlcyBmdW5jdGlvbnMgcmVsYXRlZCB0byB0aGUgc2V0IG9mIGF2YWlsYWJsZSBuZXR3b3JrIG9iamVjdHNcbiAqL1xuZXhwb3J0IGNvbnN0IG5ldHdvcmtPYmplY3RTdGF0dXNTZXJ2aWNlOiBOZXR3b3JrT2JqZWN0U3RhdHVzU2VydmljZVR5cGUgPSB7XG4gIGdldEFsbE5ldHdvcmtPYmplY3REZXRhaWxzLFxuICB3YWl0Rm9yTmV0d29ya09iamVjdCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5ldHdvcmtPYmplY3RTdGF0dXNTZXJ2aWNlO1xuIiwiLy8gI3JlZ2lvbiBpbXBvcnRzXG5cbmltcG9ydCAqIGFzIG5ldHdvcmtTZXJ2aWNlIGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbmV0d29yay5zZXJ2aWNlJztcbmltcG9ydCB7IHNlcmlhbGl6ZVJlcXVlc3RUeXBlIH0gZnJvbSAnQHNoYXJlZC91dGlscy91dGlsJztcbmltcG9ydCB7XG4gIEFzeW5jVmFyaWFibGUsXG4gIFBsYXRmb3JtRXZlbnQsXG4gIFBsYXRmb3JtRXZlbnRFbWl0dGVyLFxuICBhZ2dyZWdhdGVVbnN1YnNjcmliZXJBc3luY3MsXG4gIHNlcmlhbGl6ZSxcbiAgVW5zdWJzY3JpYmVyQXN5bmMsXG4gIGdldEFsbE9iamVjdEZ1bmN0aW9uTmFtZXMsXG4gIGlzU3RyaW5nLFxuICBDYW5IYXZlT25EaWREaXNwb3NlLFxuICBNdXRleE1hcCxcbiAgc3RhcnRzV2l0aCxcbn0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuaW1wb3J0IHtcbiAgTmV0d29ya09iamVjdCxcbiAgRGlzcG9zYWJsZU5ldHdvcmtPYmplY3QsXG4gIE5ldHdvcmthYmxlT2JqZWN0LFxuICBMb2NhbE9iamVjdFRvUHJveHlDcmVhdG9yLFxuICBOZXR3b3JrT2JqZWN0RGV0YWlscyxcbn0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvbmV0d29yay1vYmplY3QubW9kZWwnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9sb2dnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBnZXRFbXB0eU1ldGhvZERvY3MsIE5ldHdvcmtPYmplY3REb2N1bWVudGF0aW9uIH0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvb3BlbnJwYy5tb2RlbCc7XG5cbi8vICNlbmRyZWdpb25cblxuLy8gI3JlZ2lvbiBpbml0aWFsaXplXG5cbi8qKiBXaGV0aGVyIHRoaXMgc2VydmljZSBoYXMgZmluaXNoZWQgc2V0dGluZyB1cCAqL1xubGV0IGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLyoqIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoaXMgc2VydmljZSBpcyBmaW5pc2hlZCBpbml0aWFsaXppbmcgKi9cbmxldCBpbml0aWFsaXplUHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcblxuLyoqIFNldHMgdXAgdGhlIHNlcnZpY2UuIE9ubHkgcnVucyBvbmNlIGFuZCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSBwcm9taXNlIGFmdGVyIHRoYXQgKi9cbmNvbnN0IGluaXRpYWxpemUgPSAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmIChpbml0aWFsaXplUHJvbWlzZSkgcmV0dXJuIGluaXRpYWxpemVQcm9taXNlO1xuXG4gIGluaXRpYWxpemVQcm9taXNlID0gKGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoaXNJbml0aWFsaXplZCkgcmV0dXJuO1xuXG4gICAgLy8gVE9ETzogTWlnaHQgYmUgYmVzdCB0byBtYWtlIGEgc2luZ2xldG9uIG9yIHNvbWV0aGluZ1xuICAgIGF3YWl0IG5ldHdvcmtTZXJ2aWNlLmluaXRpYWxpemUoKTtcblxuICAgIGlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9KSgpO1xuXG4gIHJldHVybiBpbml0aWFsaXplUHJvbWlzZTtcbn07XG5cbi8vICNlbmRyZWdpb25cblxuLy8gI3JlZ2lvbiBIZWxwZXJzIGZvciB0YWxraW5nIHRvIHRoZSBuZXR3b3JrIGFib3V0IG9iamVjdHNcblxuLyoqIFByZWZpeCBvbiByZXF1ZXN0cyB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IGlzIHJlbGF0ZWQgdG8gYSBuZXR3b3JrIG9iamVjdCAqL1xuY29uc3QgQ0FURUdPUllfTkVUV09SS19PQkpFQ1QgPSAnb2JqZWN0JztcblxuLyoqXG4gKiBHZXRzIGEgcmVxdWVzdCB0eXBlIGZvciBuZXR3b3JrIHJlcXVlc3RzIGZvciB0aGUgc3BlY2lmaWVkIG5ldHdvcmsgb2JqZWN0IElEIGFuZCBmdW5jdGlvbiBuYW1lXG4gKiAoaWYgcHJvdmlkZWQpXG4gKi9cbmNvbnN0IGdldE5ldHdvcmtPYmplY3RSZXF1ZXN0VHlwZSA9IChpZDogc3RyaW5nLCBmdW5jdGlvbk5hbWU/OiBzdHJpbmcpID0+XG4gIHNlcmlhbGl6ZVJlcXVlc3RUeXBlKENBVEVHT1JZX05FVFdPUktfT0JKRUNULCBgJHtpZH0ke2Z1bmN0aW9uTmFtZSA/IGAuJHtmdW5jdGlvbk5hbWV9YCA6ICcnfWApO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIG5ldHdvcmsgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBJRCBleGlzdHMgcmVtb3RlbHkgKGRvZXMgbm90IGNoZWNrIGxvY2FsbHkpXG4gKlxuICogQHBhcmFtIGlkIElEIG9mIHRoZSBuZXR3b3JrIG9iamVjdCAtIGFsbCBwcm9jZXNzZXMgbXVzdCB1c2UgdGhpcyBJRCB0byBsb29rIHVwIHRoaXMgbmV0d29ya1xuICogICBvYmplY3RcbiAqIEBwYXJhbSByZXRyeSBXaGV0aGVyIG9yIG5vdCB0aGUgbmV0d29yayBzZXJ2aWNlIHNob3VsZCByZXRyeSBmYWlsZWQgcmVxdWVzdHMgc2V2ZXJhbCB0aW1lc1xuICogQHJldHVybnMgRW1wdHkgYXJyYXkgaWYgdGhlcmUgaXMgYSByZW1vdGUgbmV0d29yayBvYmplY3Qgd2l0aCB0aGlzIElELCB1bmRlZmluZWQgb3RoZXJ3aXNlLiBUT0RPOlxuICogICByZXR1cm4gYXJyYXkgb2YgYWxsIGVsaWdpYmxlIGZ1bmN0aW9uc1xuICovXG5jb25zdCBnZXRSZW1vdGVOZXR3b3JrT2JqZWN0RnVuY3Rpb25zID0gYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4gfCB1bmRlZmluZWQ+ID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgbmV0d29ya1NlcnZpY2UucmVxdWVzdDxbXSwgYm9vbGVhbj4oZ2V0TmV0d29ya09iamVjdFJlcXVlc3RUeXBlKGlkKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBObyBwcm9jZXNzZXMgYXJlIHJlZ2lzdGVyZWQgdG8gaGFuZGxlIHRoaXMgZ2V0IHJlcXVlc3QsIG1lYW5pbmcgYSBuZXR3b3JrIG9iamVjdCB3aXRoIHRoaXMgSUQgZG9lcyBub3QgZXhpc3RcbiAgICAvLyBUT0RPOiBjaGVjayB0aGUgbWVzc2FnZSBhbmQgdGhyb3cgdGhlIGVycm9yIGlmIGl0IGlzIG5vdCB0aGUgcmlnaHQgbWVzc2FnZT9cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG4vKiogVGhpcyBzZXJ2aWNlIHN0b3JlcyBib3RoIGxvY2FsIGFuZCByZW1vdGUgbmV0d29yayBvYmplY3RzIHRvZ2V0aGVyICovXG5lbnVtIE5ldHdvcmtPYmplY3RSZWdpc3RyYXRpb25UeXBlIHtcbiAgTG9jYWwgPSAnbG9jYWwnLFxuICBSZW1vdGUgPSAncmVtb3RlJyxcbn1cblxuLyoqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBuZXR3b3JrIG9iamVjdCBhbmQgaG93IHRvIHVzZSBpdCBpbiB0aGlzIHNlcnZpY2UgKi9cbnR5cGUgTmV0d29ya09iamVjdFJlZ2lzdHJhdGlvbiA9IHtcbiAgLyoqIExvY2FsIG9yIFJlbW90ZSAqL1xuICByZWdpc3RyYXRpb25UeXBlOiBOZXR3b3JrT2JqZWN0UmVnaXN0cmF0aW9uVHlwZTtcbiAgLyoqIFByb3h5IG9iamVjdCBzaGFyZWQgd2l0aCBzZXJ2aWNlcyB0aGF0IGRvbid0IG93biB0aGUgYWN0dWFsIG9iamVjdCAtIHJldHVybmVkIGJ5IFwiZ2V0XCIgKi9cbiAgbmV0d29ya09iamVjdDogTmV0d29ya09iamVjdDxOZXR3b3JrYWJsZU9iamVjdD47XG4gIC8qKlxuICAgKiBFbWl0dGVyIHRoYXQgaW5kaWNhdGVzIGxvY2FsbHkgd2hlbiB0aGUgbmV0d29yayBvYmplY3Qgd2FzIGRpc3Bvc2VkLiBSdW4gd2hlbiB0aGUgbmV0d29ya1xuICAgKiBkaXNwb3NhbCBlbWl0dGVyIHJ1bnMgZm9yIHRoaXMgcmVnaXN0cmF0aW9uJ3MgSUQuXG4gICAqL1xuICBvbkRpZERpc3Bvc2VFbWl0dGVyOiBQbGF0Zm9ybUV2ZW50RW1pdHRlcjx2b2lkPjtcbiAgLyoqIEZ1bmN0aW9uIHRvIG1ha2UgdGhlIHByb3h5IHN0b3Agd29ya2luZy4gU2hvdWxkIGJlIHJ1biBvbiBkaXNwb3NpbmcgdGhpcyBuZXR3b3JrIG9iamVjdC4gKi9cbiAgcmV2b2tlUHJveHk6ICgpID0+IHZvaWQ7XG59O1xuXG4vKiogTWFwIG9mIElEIHRvIG5ldHdvcmsgb2JqZWN0ICovXG5jb25zdCBuZXR3b3JrT2JqZWN0UmVnaXN0cmF0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBOZXR3b3JrT2JqZWN0UmVnaXN0cmF0aW9uPigpO1xuXG4vKipcbiAqIFNlYXJjaCBsb2NhbGx5IGtub3duIG5ldHdvcmsgb2JqZWN0cyBmb3IgdGhlIGdpdmVuIElELiBEb24ndCBsb29rIG9uIHRoZSBuZXR3b3JrIGZvciBtb3JlXG4gKiBvYmplY3RzLlxuICpcbiAqIEByZXR1cm5zIFdoZXRoZXIgd2Uga25vdyBvZiBhbiBleGlzdGluZyBuZXR3b3JrIG9iamVjdCB3aXRoIHRoZSBwcm92aWRlZCBJRCBhbHJlYWR5IG9uIHRoZVxuICogICBuZXR3b3JrXG4gKi9cbmNvbnN0IGhhc0tub3duID0gKGlkOiBzdHJpbmcpOiBib29sZWFuID0+IG5ldHdvcmtPYmplY3RSZWdpc3RyYXRpb25zLmhhcyhpZCk7XG5cbi8qKlxuICogRW1pdHRlciBmb3Igd2hlbiBhIG5ldHdvcmsgb2JqZWN0IGlzIGNyZWF0ZWQuIEluY2x1ZGVzIHRoZSBsaXN0IG9mIGZ1bmN0aW9ucyBleHBvc2VkIGJ5IHRoZVxuICogbmV0d29yayBvYmplY3QuXG4gKi9cbmNvbnN0IG9uRGlkQ3JlYXRlTmV0d29ya09iamVjdEVtaXR0ZXIgPVxuICBuZXR3b3JrU2VydmljZS5jcmVhdGVOZXR3b3JrRXZlbnRFbWl0dGVyPE5ldHdvcmtPYmplY3REZXRhaWxzPihcbiAgICBzZXJpYWxpemVSZXF1ZXN0VHlwZShDQVRFR09SWV9ORVRXT1JLX09CSkVDVCwgJ29uRGlkQ3JlYXRlTmV0d29ya09iamVjdCcpLFxuICApO1xuXG4vKipcbiAqIEV2ZW50IHRoYXQgZmlyZXMgd2hlbiBhIG5ldyBvYmplY3QgaGFzIGJlZW4gY3JlYXRlZCBvbiB0aGUgbmV0d29yayAobG9jYWxseSBvciByZW1vdGVseSkuIFRoZVxuICogZXZlbnQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG5ldyBuZXR3b3JrIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IG9uRGlkQ3JlYXRlTmV0d29ya09iamVjdCA9IG9uRGlkQ3JlYXRlTmV0d29ya09iamVjdEVtaXR0ZXIuZXZlbnQ7XG5cbi8qKlxuICogRW1pdHRlciBmb3Igd2hlbiBhIG5ldHdvcmsgb2JqZWN0IGlzIGRpc3Bvc2VkLiBQcm92aWRlcyB0aGUgSUQgc28gdGhhdCB0aGUgbG9jYWwgZW1pdHRlciBzcGVjaWZpY1xuICogdG8gdGhhdCBvYmplY3QgY2FuIGJlIHJ1bi5cbiAqXG4gKiBPbmx5IHJ1biBvbiBsb2NhbCBuZXR3b3JrIG9iamVjdCByZWdpc3RyYXRpb24hIFByb2Nlc3NlcyBzaG91bGQgb25seSBkaXNwb3NlIHRoZWlyIG93biBuZXR3b3JrXG4gKiBvYmplY3RzXG4gKi9cbmNvbnN0IG9uRGlkRGlzcG9zZU5ldHdvcmtPYmplY3RFbWl0dGVyID0gbmV0d29ya1NlcnZpY2UuY3JlYXRlTmV0d29ya0V2ZW50RW1pdHRlcjxzdHJpbmc+KFxuICBzZXJpYWxpemVSZXF1ZXN0VHlwZShDQVRFR09SWV9ORVRXT1JLX09CSkVDVCwgJ29uRGlkRGlzcG9zZU5ldHdvcmtPYmplY3QnKSxcbik7XG5cbi8qKiBFdmVudCB0aGF0IGZpcmVzIHdpdGggYSBuZXR3b3JrIG9iamVjdCBJRCB3aGVuIHRoYXQgb2JqZWN0IGlzIGRpc3Bvc2VkIGxvY2FsbHkgb3IgcmVtb3RlbHkgKi9cbmV4cG9ydCBjb25zdCBvbkRpZERpc3Bvc2VOZXR3b3JrT2JqZWN0ID0gb25EaWREaXNwb3NlTmV0d29ya09iamVjdEVtaXR0ZXIuZXZlbnQ7XG5cbi8qKiBSdW5zIHRvIGRpc3Bvc2Ugb2YgbG9jYWwgYW5kIHJlbW90ZSBuZXR3b3JrIG9iamVjdHMgd2hlbiB3ZSByZWNlaXZlIGV2ZW50cyB0ZWxsaW5nIHVzIHRvIGRvIHNvICovXG5vbkRpZERpc3Bvc2VOZXR3b3JrT2JqZWN0KChpZDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IG5ldHdvcmtPYmplY3RSZWdpc3RyYXRpb24gPSBuZXR3b3JrT2JqZWN0UmVnaXN0cmF0aW9ucy5nZXQoaWQpO1xuXG4gIGlmIChuZXR3b3JrT2JqZWN0UmVnaXN0cmF0aW9uKSB7XG4gICAgLy8gQWxlcnQgdXNlcnMgb2YgdGhpcyBzcGVjaWZpYyBuZXR3b3JrIG9iamVjdCB0aGF0IGl0IHdhcyBkaXNwb3NlZFxuICAgIG5ldHdvcmtPYmplY3RSZWdpc3RyYXRpb24ub25EaWREaXNwb3NlRW1pdHRlci5lbWl0KCk7XG5cbiAgICAvLyBEaXNwb3NlIG9mIHRoZSBuZXR3b3JrIG9iamVjdCByZWdpc3RyYXRpb24gaXRzZWxmXG4gICAgbmV0d29ya09iamVjdFJlZ2lzdHJhdGlvbi5vbkRpZERpc3Bvc2VFbWl0dGVyLmRpc3Bvc2UoKTtcblxuICAgIC8vIERpc3Bvc2Ugb2YgdGhlIHByb3h5XG4gICAgbmV0d29ya09iamVjdFJlZ2lzdHJhdGlvbi5yZXZva2VQcm94eSgpO1xuXG4gICAgLy8gRGlzcG9zZSBvZiB0aGUgbmV0d29yayBvYmplY3QgcmVnaXN0cmF0aW9uXG4gICAgbmV0d29ya09iamVjdFJlZ2lzdHJhdGlvbnMuZGVsZXRlKGlkKTtcbiAgfVxufSk7XG5cbi8vICNlbmRyZWdpb25cblxuLy8gI3JlZ2lvbiBIZWxwZXJzIGZvciBnZXQgYW5kIHNldFxuXG4vLyBXZSBuZWVkIHRoaXMgdG8gcHJvdGVjdCBzaW11bHRhbmVvdXMgY2FsbHMgdG8gZ2V0IGFuZC9vciBzZXQgdGhlIHNhbWUgbmV0d29yayBvYmplY3RzXG5jb25zdCBnZXR0ZXJNdXRleE1hcCA9IG5ldyBNdXRleE1hcCgpO1xuY29uc3Qgc2V0dGVyTXV0ZXhNYXAgPSBuZXcgTXV0ZXhNYXAoKTtcblxuLyoqIFRoaXMgcHJveHkgZW5hYmxlcyBjYWxsaW5nIGZ1bmN0aW9ucyBvbiBhIG5ldHdvcmsgb2JqZWN0IHRoYXQgZXhpc3RzIGluIGEgZGlmZmVyZW50IHByb2Nlc3MgKi9cbmNvbnN0IGNyZWF0ZVJlbW90ZVByb3h5ID0gKFxuICBpZDogc3RyaW5nLFxuICBiYXNlOiBvYmplY3QgfCB1bmRlZmluZWQsXG4pOiB7XG4gIC8vIFRoZSBmdWxsICdyZW1vdGUnIG5ldHdvcmsgb2JqZWN0IHdoaWNoIGFjY2Vzc2VzIGxvY2FsIHByb3BlcnRpZXMgYW5kIHNlbmRzIHJlcXVlc3RzIGZvciByZW1vdGUgZnVuY3Rpb25zXG4gIHByb3h5OiBvYmplY3Q7XG4gIC8vIEZ1bmN0aW9uIHRvIHJldm9rZSB0aGUgcHJveHkuIFNob3VsZCB1c2Ugb24gZGlzcG9zaW5nIHRoZSBuZXR3b3JrIG9iamVjdC5cbiAgcmV2b2tlOiAoKSA9PiB2b2lkO1xufSA9PlxuICBQcm94eS5yZXZvY2FibGUoYmFzZSA/PyB7fSwge1xuICAgIGdldDogKHRhcmdldCwga2V5KSA9PiB7XG4gICAgICAvLyBCbG9jayBhY2Nlc3MgdG8gY29uc3RydWN0b3JzIGFuZCBkaXNwb3NlXG4gICAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ2Rpc3Bvc2UnKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgLy8gQXNzZXJ0IHR5cGUgb2YgYGtleWAgdG8gaW5kZXggYHRhcmdldGAuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICAgIGlmIChrZXkgPT09ICd0aGVuJyB8fCBrZXkgaW4gdGFyZ2V0KSByZXR1cm4gdGFyZ2V0W2tleSBhcyBrZXlvZiB0eXBlb2YgdGFyZ2V0XTtcbiAgICAgIC8vIElmIHRoZSBwcm9wIHJlcXVlc3RlZCBpcyBhIHN5bWJvbCwgdGhhdCBkb2Vzbid0IHdvcmsgb3ZlciB0aGUgbmV0d29yay4gUmVqZWN0XG4gICAgICBpZiAoIWlzU3RyaW5nKGtleSkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAvLyBEb24ndCBjcmVhdGUgcmVtb3RlIHByb3hpZXMgZm9yIGV2ZW50c1xuICAgICAgaWYgKHN0YXJ0c1dpdGgoa2V5LCAnb24nKSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgLy8gSWYgdGhlIGxvY2FsIG5ldHdvcmsgb2JqZWN0IGRvZXNuJ3QgaGF2ZSB0aGUgcHJvcGVydHksIGJ1aWxkIGEgcmVxdWVzdCBmb3IgaXRcbiAgICAgIGNvbnN0IHJlcXVlc3RGdW5jdGlvbiA9ICguLi5hcmdzOiB1bmtub3duW10pID0+XG4gICAgICAgIG5ldHdvcmtTZXJ2aWNlLnJlcXVlc3QoZ2V0TmV0d29ya09iamVjdFJlcXVlc3RUeXBlKGlkLCBrZXkpLCAuLi5hcmdzKTtcblxuICAgICAgLy8gU2F2ZSB0aGUgbmV3IHJlcXVlc3QgZnVuY3Rpb24gYXMgdGhlIGFjdHVhbCBmdW5jdGlvbiBvbiB0aGUgb2JqZWN0IHNvIHdlIGRvbid0IGhhdmUgdG9cbiAgICAgIC8vIGNyZWF0ZSB0aGlzIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzLlxuICAgICAgLy8gVE9ETzogVHJ5IG1ha2luZyBhIHNlcGFyYXRlIGFycmF5IG9mIGxhenkgbG9hZGVkIHJlcXVlc3QgZnVuY3Rpb25zIGluc3RlYWQgb2YgcHV0dGluZyB0aGVtXG4gICAgICAvLyBvbiB0aGUgb2JqZWN0IGFuZCB0aGVyZWJ5IHJlZHVjaW5nIHRoZSB1c2VmdWxuZXNzIG9mIHJldm9rZVByb3h5XG4gICAgICAvLyBUb29rIHRoZSBpbmRleGluZyBvZmYgb2YgTmV0d29ya2FibGVPYmplY3Qgc28gbm9ybWFsIG9iamVjdHMgY291bGQgYmUgdXNlZCxcbiAgICAgIC8vIGJ1dCBub3cgbWVtYmVycyBjYW4ndCBiZSBhY2Nlc3NlZCBieSBpbmRleGluZyBpbiBOZXR3b3JrT2JqZWN0U2VydmljZVxuICAgICAgLy8gVE9ETzogZml4IGl0IHNvIGl0IGlzIGluZGV4YWJsZSBidXQgY2FuIGhhdmUgc3BlY2lmaWMgbWVtYmVyc1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gICAgICAodGFyZ2V0IGFzIGFueSlba2V5XSA9IHJlcXVlc3RGdW5jdGlvbjtcbiAgICAgIHJldHVybiByZXF1ZXN0RnVuY3Rpb247XG4gICAgfSxcbiAgICBzZXQob2JqLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgLy8gSWYgd2UgY2FjaGVkIGEgcHJvcGVydHkgcHJldmlvdXNseSwgcHVyZ2UgdGhlIGNhY2hlIGZvciB0aGF0IHByb3BlcnR5IHNpbmNlIGl0IGlzIGNoYW5naW5nLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gICAgICBpZiAoKG9iaiBhcyBhbnkpW3Byb3BdKSBkZWxldGUgKG9iaiBhcyBhbnkpW3Byb3BdO1xuXG4gICAgICAvLyBBY3R1YWxseSBzZXQgdGhlIHByb3ZpZGVkIHByb3BlcnR5XG4gICAgICBSZWZsZWN0LnNldChvYmosIHByb3AsIHZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gIH0pO1xuXG4vKipcbiAqIFRoaXMgcHJveHkgZW5hYmxlcyBjYWxsaW5nIGZ1bmN0aW9ucyBvbiBhIG5ldHdvcmsgb2JqZWN0IHRoYXQgZXhpc3RzIGluIHRoZSBzYW1lIHByb2Nlc3MsIGJ1dCBpc1xuICogb3duZWQgYnkgc29tZSBvdGhlciBzZXJ2aWNlLiBXZSBvbmx5IGdpdmUgdGhlIGFjdHVhbCBuZXR3b3JrIG9iamVjdCB0byB0aGUgb3duaW5nIHNlcnZpY2UuXG4gKi9cbmNvbnN0IGNyZWF0ZUxvY2FsUHJveHkgPSAoXG4gIG9iamVjdEJlaW5nU2V0OiBvYmplY3QsXG4pOiB7XG4gIC8vIFRoaW4gbGF5ZXIgb3ZlciB0aGUgb2JqZWN0IGJlaW5nIHNldFxuICBwcm94eTogb2JqZWN0O1xuICAvLyBGdW5jdGlvbiB0byByZXZva2UgdGhlIHByb3h5LiBTaG91bGQgdXNlIG9uIGRpc3Bvc2luZyB0aGUgbmV0d29yayBvYmplY3RcbiAgcmV2b2tlOiAoKSA9PiB2b2lkO1xufSA9PlxuICBQcm94eS5yZXZvY2FibGUob2JqZWN0QmVpbmdTZXQsIHtcbiAgICBnZXQ6ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgLy8gQmxvY2sgYWNjZXNzIHRvIGNvbnN0cnVjdG9ycyBhbmQgZGlzcG9zZVxuICAgICAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdkaXNwb3NlJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIC8vIERvbid0IHByb3h5IGV2ZW50cyBleGNlcHQgXCJvbkRpZERpc3Bvc2VcIiBzaW5jZSB0aGF0J3MgdGhlIG9ubHkgd2F5IGZvciBjYWxsZXJzIHRvXG4gICAgICAvLyByZWdpc3RlciBmdW5jdGlvbnMgdG8gcnVuIHdoZW4gdGhlIG9iamVjdCBpcyBnb2luZyBhd2F5XG4gICAgICBpZiAoaXNTdHJpbmcoa2V5KSAmJiBzdGFydHNXaXRoKGtleSwgJ29uJykgJiYga2V5ICE9PSAnb25EaWREaXNwb3NlJykgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCBvYmplY3RCZWluZ1NldCk7XG4gICAgfSxcbiAgfSk7XG5cbi8qKiBDb25zdHJ1Y3QgZGV0YWlscyBhYm91dCBhbiBvYmplY3QgdGhhdCBpcyBiZWNvbWluZyBhIG5ldHdvcmsgb2JqZWN0ICovXG5mdW5jdGlvbiBjcmVhdGVOZXR3b3JrT2JqZWN0RGV0YWlscyhcbiAgaWQ6IHN0cmluZyxcbiAgb2JqZWN0VHlwZTogc3RyaW5nLFxuICBvYmplY3RUb1NoYXJlOiB7IFtwcm9wZXJ0eTogc3RyaW5nXTogdW5rbm93biB9LFxuICBvYmplY3RBdHRyaWJ1dGVzOiB7IFtwcm9wZXJ0eTogc3RyaW5nXTogdW5rbm93biB9IHwgdW5kZWZpbmVkLFxuKTogTmV0d29ya09iamVjdERldGFpbHMge1xuICBjb25zdCBvYmplY3RGdW5jdGlvbk5hbWVzID0gZ2V0QWxsT2JqZWN0RnVuY3Rpb25OYW1lcyhvYmplY3RUb1NoYXJlLCBpZCk7XG5cbiAgLy8gUmVtb3ZlIGZ1bmN0aW9ucyB3ZSBkb24ndCBhbGxvdyB0byBiZSBjYWxsZWQgcmVtb3RlbHkgb24gbmV0d29yayBvYmplY3RzXG4gIG9iamVjdEZ1bmN0aW9uTmFtZXMuZGVsZXRlKCdjb25zdHJ1Y3RvcicpO1xuICBvYmplY3RGdW5jdGlvbk5hbWVzLmRlbGV0ZSgnZGlzcG9zZScpO1xuICBvYmplY3RGdW5jdGlvbk5hbWVzLmZvckVhY2goKGZ1bmN0aW9uTmFtZSkgPT4ge1xuICAgIC8vIElmIHdlIGNvbWUgdXAgd2l0aCBzb21lIGJldHRlciB3YXkgdG8gaWRlbnRpZnkgZXZlbnRzLCB3ZSBjYW4gcmVtb3ZlIHRoaXMgYW5kIHJlbGF0ZWQgY2hlY2tzXG4gICAgaWYgKHN0YXJ0c1dpdGgoZnVuY3Rpb25OYW1lLCAnb24nKSkgb2JqZWN0RnVuY3Rpb25OYW1lcy5kZWxldGUoZnVuY3Rpb25OYW1lKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaWQsXG4gICAgb2JqZWN0VHlwZSxcbiAgICBmdW5jdGlvbk5hbWVzOiBbLi4ub2JqZWN0RnVuY3Rpb25OYW1lc10uc29ydCgpLFxuICAgIGF0dHJpYnV0ZXM6IG9iamVjdEF0dHJpYnV0ZXMsXG4gIH07XG59XG5cbmludGVyZmFjZSBJT25EaWREaXNwb3NhYmxlT2JqZWN0IHtcbiAgb25EaWREaXNwb3NlPzogUGxhdGZvcm1FdmVudDx2b2lkPjtcbn1cblxuLyoqIFNldCBhbiBgb25EaWREaXNwb3NlYCBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0IHRvIG11dGF0ZS4gVGhyb3cgaWYgb25lIGFscmVhZHkgZXhpc3RzLiAqL1xuY29uc3Qgb3ZlcnJpZGVPbkRpZERpc3Bvc2UgPSAoXG4gIG9iamVjdElkOiBzdHJpbmcsXG4gIG9iamVjdFRvTXV0YXRlOiBJT25EaWREaXNwb3NhYmxlT2JqZWN0LFxuICBuZXdPbkRpZERpc3Bvc2U6IFBsYXRmb3JtRXZlbnQ8dm9pZD4sXG4pOiB2b2lkID0+IHtcbiAgaWYgKG9iamVjdFRvTXV0YXRlLm9uRGlkRGlzcG9zZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBZb3UgY2FuJ3QgcmVnaXN0ZXIgXCIke29iamVjdElkfVwiIGFzIGEgbmV0d29yayBvYmplY3Qgc2luY2UgaXQgYWxyZWFkeSBoYXMgYW4gb25EaWREaXNwb3NlIHByb3BlcnR5YCxcbiAgICApO1xuICB9XG5cbiAgb2JqZWN0VG9NdXRhdGUub25EaWREaXNwb3NlID0gbmV3T25EaWREaXNwb3NlO1xufTtcblxuaW50ZXJmYWNlIElEaXNwb3NhYmxlT2JqZWN0IHtcbiAgZGlzcG9zZT86IFVuc3Vic2NyaWJlckFzeW5jO1xufVxuXG4vKiogSWYgYGRpc3Bvc2VgIGFscmVhZHkgZXhpc3RzIG9uIGBvYmplY3RUb011dGF0ZWAsIHdlIHdpbGwgY2FsbCBpdCBpbiBhZGRpdGlvbiB0byBgbmV3RGlzcG9zZWAgKi9cbmV4cG9ydCBmdW5jdGlvbiBvdmVycmlkZURpc3Bvc2UoXG4gIG9iamVjdFRvTXV0YXRlOiBJRGlzcG9zYWJsZU9iamVjdCxcbiAgbmV3RGlzcG9zZTogVW5zdWJzY3JpYmVyQXN5bmMsXG4pOiB2b2lkIHtcbiAgaWYgKG9iamVjdFRvTXV0YXRlLmRpc3Bvc2UpIHtcbiAgICBjb25zdCBvbGREaXNwb3NlID0gb2JqZWN0VG9NdXRhdGUuZGlzcG9zZS5iaW5kKG9iamVjdFRvTXV0YXRlKTtcblxuICAgIG9iamVjdFRvTXV0YXRlLmRpc3Bvc2UgPSBhZ2dyZWdhdGVVbnN1YnNjcmliZXJBc3luY3MoW29sZERpc3Bvc2UsIG5ld0Rpc3Bvc2VdKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RUb011dGF0ZS5kaXNwb3NlID0gbmV3RGlzcG9zZTtcbiAgfVxufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8vICNyZWdpb24gZ2V0XG5cbi8qKlxuICogR2V0IGEgbmV0d29yayBvYmplY3QgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIHNldCB1cCB0byBiZSBzaGFyZWQgb24gdGhlIG5ldHdvcmsuIEEgbmV0d29ya1xuICogb2JqZWN0IGlzIGEgcHJveHkgdG8gYW4gb2JqZWN0IGxpdmluZyBzb21ld2hlcmUgZWxzZSB0aGF0IGxvY2FsIGNvZGUgY2FuIHVzZS5cbiAqXG4gKiBSdW5uaW5nIHRoaXMgZnVuY3Rpb24gdHdpY2Ugd2l0aCB0aGUgc2FtZSBpbnB1dHMgeWllbGRzIHRoZSBzYW1lIG5ldHdvcmsgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBpZCBJRCBvZiB0aGUgbmV0d29yayBvYmplY3QgLSBhbGwgcHJvY2Vzc2VzIG11c3QgdXNlIHRoaXMgSUQgdG8gbG9vayB1cCB0aGlzIG5ldHdvcmtcbiAqICAgb2JqZWN0XG4gKiBAcGFyYW0gY3JlYXRlTG9jYWxPYmplY3RUb1Byb3h5IEZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhbiBvYmplY3QgdGhhdCB0aGUgbmV0d29yayBvYmplY3QgcHJveHlcbiAqICAgd2lsbCBiZSBiYXNlZCB1cG9uLiBUaGUgb2JqZWN0IHRoaXMgZnVuY3Rpb24gY3JlYXRlcyBjYW5ub3QgaGF2ZSBhbiBgb25EaWREaXNwb3NlYCBwcm9wZXJ0eS5cbiAqICAgVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgZm9yIHNldHRpbmcgdXAgbmV0d29yayBldmVudHMgb24gYSBuZXR3b3JrIG9iamVjdC5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSBmb3IgdGhlIG5ldHdvcmsgb2JqZWN0IHdpdGggc3BlY2lmaWVkIElEIGlmIG9uZSBleGlzdHMsIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAqL1xuY29uc3QgZ2V0ID0gYXN5bmMgPFQgZXh0ZW5kcyBvYmplY3Q+KFxuICBpZDogc3RyaW5nLFxuICBjcmVhdGVMb2NhbE9iamVjdFRvUHJveHk/OiBMb2NhbE9iamVjdFRvUHJveHlDcmVhdG9yPFQ+LFxuKTogUHJvbWlzZTxOZXR3b3JrT2JqZWN0PFQ+IHwgdW5kZWZpbmVkPiA9PiB7XG4gIGF3YWl0IGluaXRpYWxpemUoKTtcblxuICAvLyBEb24ndCBhbGxvdyBzaW11bHRhbmVvdXMgZ2V0cyB0byBydW4gZm9yIHRoZSBzYW1lIG5ldHdvcmsgb2JqZWN0XG4gIGNvbnN0IGxvY2sgPSBnZXR0ZXJNdXRleE1hcC5nZXQoaWQpO1xuICByZXR1cm4gbG9jay5ydW5FeGNsdXNpdmUoYXN5bmMgKCkgPT4ge1xuICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIG5ldHdvcmsgb2JqZWN0LCByZXR1cm4gaXRcbiAgICBjb25zdCBuZXR3b3JrT2JqZWN0UmVnaXN0cmF0aW9uID0gbmV0d29ya09iamVjdFJlZ2lzdHJhdGlvbnMuZ2V0KGlkKTtcbiAgICBpZiAobmV0d29ya09iamVjdFJlZ2lzdHJhdGlvbilcbiAgICAgIC8vIEFzc2VydCB0byBzcGVjaWZpZWQgZ2VuZXJpYyB0eXBlLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gICAgICByZXR1cm4gbmV0d29ya09iamVjdFJlZ2lzdHJhdGlvbi5uZXR3b3JrT2JqZWN0IGFzIE5ldHdvcmtPYmplY3Q8VD47XG5cbiAgICAvLyBXZSBkb24ndCBhbHJlYWR5IGhhdmUgdGhpcyBuZXR3b3JrIG9iamVjdC4gU2VlIGlmIGl0IGV4aXN0cyBzb21ld2hlcmUgZWxzZS5cbiAgICBjb25zdCBuZXR3b3JrT2JqZWN0RnVuY3Rpb25zID0gYXdhaXQgZ2V0UmVtb3RlTmV0d29ya09iamVjdEZ1bmN0aW9ucyhpZCk7XG4gICAgaWYgKCFuZXR3b3JrT2JqZWN0RnVuY3Rpb25zKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgLy8gQmVmb3JlIHdlIGNyZWF0ZSBhIHJlbW90ZSBwcm94eSwgc2VlIGlmIHRoZXJlIHdhcyBhIHJhY2UgY29uZGl0aW9uIGZvciBhIGxvY2FsIHByb3h5LlxuICAgIC8vIEl0IGlzIHBvc3NpYmxlIHdlIGNhbGxlZCBgZ2V0YCwgdGhlbiB3aGlsZSBhd2FpdGluZyB0aGUgbmV0d29yayByZXNwb25zZSBzb21ldGhpbmcgZWxzZSBpblxuICAgIC8vIHRoaXMgcHJvY2VzcyBjYWxsZWQgYHNldGAgb24gdGhlIG9iamVjdCB3ZSB3ZXJlIGxvb2tpbmcgZm9yLlxuICAgIGNvbnN0IG5ldHdvcmtPYmplY3RSZWdpc3RyYXRpb25TZWNvbmRDaGFuY2UgPSBuZXR3b3JrT2JqZWN0UmVnaXN0cmF0aW9ucy5nZXQoaWQpO1xuICAgIGlmIChuZXR3b3JrT2JqZWN0UmVnaXN0cmF0aW9uU2Vjb25kQ2hhbmNlKVxuICAgICAgLy8gQXNzZXJ0IHRvIHNwZWNpZmllZCBnZW5lcmljIHR5cGUuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICAgIHJldHVybiBuZXR3b3JrT2JqZWN0UmVnaXN0cmF0aW9uU2Vjb25kQ2hhbmNlLm5ldHdvcmtPYmplY3QgYXMgTmV0d29ya09iamVjdDxUPjtcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBvYmplY3QgZXhpc3RzIHJlbW90ZWx5IGJ1dCBkb2VzIG5vdCB5ZXQgZXhpc3QgbG9jYWxseS5cblxuICAgIC8vIFRoZSBiYXNlIG9iamVjdCBjcmVhdGVkIGJlbG93IG1pZ2h0IG5lZWQgYSByZWZlcmVuY2UgdG8gdGhlIGZpbmFsIG5ldHdvcmsgb2JqZWN0LiBTaW5jZSB0aGVcbiAgICAvLyBuZXR3b3JrIG9iamVjdCBkb2Vzbid0IGV4aXN0IHlldCwgY3JlYXRlIGFuIGFzeW5jIHZhcmlhYmxlIG5vdyBhbmQgZmlsbCBpdCBpbiBhZnRlciB0aGVcbiAgICAvLyBuZXR3b3JrIG9iamVjdCBpcyBjcmVhdGVkLlxuICAgIGNvbnN0IG5ldHdvcmtPYmplY3RWYXJpYWJsZTogQXN5bmNWYXJpYWJsZTxOZXR3b3JrT2JqZWN0PFQ+PiA9IG5ldyBBc3luY1ZhcmlhYmxlKFxuICAgICAgYE5ldHdvcmtPYmplY3QtJHtpZH1gLFxuICAgICk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGJhc2Ugb2JqZWN0IHRoYXQgd2lsbCBiZSBwcm94aWVkIGZvciByZW1vdGUgY2FsbHMuXG4gICAgLy8gSWYgYSBwcm9wZXJ0eSBleGlzdHMgb24gdGhlIGJhc2Ugb2JqZWN0LCB3ZSB1c2UgaXQgYW5kIHdvbid0IGxvb2sgZm9yIGl0IG9uIHRoZSByZW1vdGUgb2JqZWN0LlxuICAgIC8vIElmIGEgcHJvcGVydHkgZG9lcyBub3QgZXhpc3Qgb24gdGhlIGJhc2Ugb2JqZWN0LCBpdCBpcyBhc3N1bWVkIHRvIGV4aXN0IG9uIHRoZSByZW1vdGUgb2JqZWN0LlxuICAgIGNvbnN0IGJhc2VPYmplY3Q6IFBhcnRpYWw8VD4gPSBjcmVhdGVMb2NhbE9iamVjdFRvUHJveHlcbiAgICAgID8gLy8gQXNzZXJ0IHRvIHNwZWNpZmllZCBnZW5lcmljIHR5cGUuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICAgICAgICAoY3JlYXRlTG9jYWxPYmplY3RUb1Byb3h5KGlkLCBuZXR3b3JrT2JqZWN0VmFyaWFibGUucHJvbWlzZSkgYXMgUGFydGlhbDxUPilcbiAgICAgIDoge307XG5cbiAgICAvLyBDcmVhdGUgYSBwcm94eSB3aXRoIGZ1bmN0aW9ucyB0aGF0IHdpbGwgc2VuZCByZXF1ZXN0cyB0byB0aGUgcmVtb3RlIG9iamVjdFxuICAgIGNvbnN0IHJlbW90ZVByb3h5ID0gY3JlYXRlUmVtb3RlUHJveHkoaWQsIGJhc2VPYmplY3QpO1xuXG4gICAgLy8gU2V0dXAgb25EaWREaXNwb3NlIHNvIHRoYXQgc2VydmljZXMgd2lsbCBrbm93IHdoZW4gdGhlIHByb3h5IGlzIGRlYWRcbiAgICBjb25zdCBldmVudEVtaXR0ZXIgPSBuZXcgUGxhdGZvcm1FdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBvdmVycmlkZU9uRGlkRGlzcG9zZShpZCwgcmVtb3RlUHJveHkucHJveHksIGV2ZW50RW1pdHRlci5ldmVudCk7XG5cbiAgICAvLyBUaGUgbmV0d29yayBvYmplY3QgaXMgZmluaXNoZWQhIFJlbmFtZSBpdCBzbyB3ZSBrbm93IGl0IGlzIGZpbmlzaGVkLlxuICAgIC8vIEFzc2VydCB0byBzcGVjaWZpZWQgZ2VuZXJpYyB0eXBlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICAgIGNvbnN0IG5ldHdvcmtPYmplY3QgPSByZW1vdGVQcm94eS5wcm94eSBhcyBOZXR3b3JrT2JqZWN0PFQ+O1xuXG4gICAgLy8gU2F2ZSB0aGUgbmV0d29yayBvYmplY3QgZm9yIGZ1dHVyZSBsb29rdXBzXG4gICAgbmV0d29ya09iamVjdFJlZ2lzdHJhdGlvbnMuc2V0KGlkLCB7XG4gICAgICByZWdpc3RyYXRpb25UeXBlOiBOZXR3b3JrT2JqZWN0UmVnaXN0cmF0aW9uVHlwZS5SZW1vdGUsXG4gICAgICBvbkRpZERpc3Bvc2VFbWl0dGVyOiBldmVudEVtaXR0ZXIsXG4gICAgICBuZXR3b3JrT2JqZWN0LFxuICAgICAgcmV2b2tlUHJveHk6IHJlbW90ZVByb3h5LnJldm9rZSxcbiAgICB9KTtcblxuICAgIC8vIFJlc29sdmUgdGhlIHByb21pc2UgdG8gdGhlIG5ldHdvcmsgb2JqZWN0IHNvIHByb21pc2UgaG9sZGVycyBjYW4gY29tcGxldGUgdGhlaXIgd29ya1xuICAgIG5ldHdvcmtPYmplY3RWYXJpYWJsZS5yZXNvbHZlVG9WYWx1ZShuZXR3b3JrT2JqZWN0KTtcblxuICAgIHJldHVybiBuZXR3b3JrT2JqZWN0O1xuICB9KTtcbn07XG5cbi8vICNlbmRyZWdpb25cblxuLy8gI3JlZ2lvbiBzZXRcblxuLyoqXG4gKiBTZXQgdXAgYW4gb2JqZWN0IHRvIGJlIHNoYXJlZCBvbiB0aGUgbmV0d29yay5cbiAqXG4gKiBAcGFyYW0gaWQgSUQgb2YgdGhlIG9iamVjdCB0byBzaGFyZSBvbiB0aGUgbmV0d29yay4gQWxsIHByb2Nlc3NlcyBtdXN0IHVzZSB0aGlzIElEIHRvIGxvb2sgaXQgdXAuXG4gKiBAcGFyYW0gb2JqZWN0VG9TaGFyZSBUaGUgb2JqZWN0IHRvIHNldCB1cCBhcyBhIG5ldHdvcmsgb2JqZWN0LiBJdCB3aWxsIGhhdmUgYW4gZXZlbnQgbmFtZWRcbiAqICAgYG9uRGlkRGlzcG9zZWAgYWRkZWQgdG8gaXRzIHByb3BlcnRpZXMuIEFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGlmIHRoZSBvYmplY3QgYWxyZWFkeSBoYWQgYW5cbiAqICAgYG9uRGlkRGlzcG9zZWAgcHJvcGVydHkgb24gaXQuIElmIHRoZSBvYmplY3QgYWxyZWFkeSBjb250YWluZWQgYSBgZGlzcG9zZWAgZnVuY3Rpb24sIGEgbmV3XG4gKiAgIGBkaXNwb3NlYCBmdW5jdGlvbiB3aWxsIGJlIHNldCB0aGF0IGNhbGxzIHRoZSBleGlzdGluZyBmdW5jdGlvbiAoYW1vbmdzdCBvdGhlciB0aGluZ3MpLiBJZiB0aGVcbiAqICAgb2JqZWN0IGRpZCBub3QgYWxyZWFkeSBkZWZpbmUgYSBgZGlzcG9zZWAgZnVuY3Rpb24sIG9uZSB3aWxsIGJlIGFkZGVkLlxuICpcbiAqICAgV0FSTklORzogc2V0dGluZyBhIG5ldHdvcmsgb2JqZWN0IG11dGF0ZXMgdGhlIHByb3ZpZGVkIG9iamVjdC5cbiAqIEByZXR1cm5zIGBvYmplY3RUb1NoYXJlYCBtb2RpZmllZCB0byBiZSBhIG5ldHdvcmsgb2JqZWN0XG4gKi9cblxuY29uc3Qgc2V0ID0gYXN5bmMgPFQgZXh0ZW5kcyBOZXR3b3JrYWJsZU9iamVjdD4oXG4gIGlkOiBzdHJpbmcsXG4gIG9iamVjdFRvU2hhcmU6IFQsXG4gIG9iamVjdFR5cGU6IHN0cmluZyA9ICdvYmplY3QnLFxuICBvYmplY3RBdHRyaWJ1dGVzOiB7IFtwcm9wZXJ0eTogc3RyaW5nXTogdW5rbm93biB9IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkLFxuICBvYmplY3REb2N1bWVudGF0aW9uOiBOZXR3b3JrT2JqZWN0RG9jdW1lbnRhdGlvbiA9IHt9LFxuKTogUHJvbWlzZTxEaXNwb3NhYmxlTmV0d29ya09iamVjdDxUPj4gPT4ge1xuICBhd2FpdCBpbml0aWFsaXplKCk7XG5cbiAgLy8gRG9uJ3QgYWxsb3cgc2ltdWx0YW5lb3VzIHNldHMgdG8gcnVuIGZvciB0aGUgc2FtZSBuZXR3b3JrIG9iamVjdFxuICBjb25zdCBsb2NrID0gc2V0dGVyTXV0ZXhNYXAuZ2V0KGlkKTtcbiAgcmV0dXJuIGxvY2sucnVuRXhjbHVzaXZlKGFzeW5jICgpID0+IHtcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgYWxyZWFkeSBrbm93IHRoZXJlIGlzIGEgbmV0d29yayBvYmplY3Qgd2l0aCB0aGlzIElELlxuICAgIGlmIChoYXNLbm93bihpZCkpIHRocm93IG5ldyBFcnJvcihgTmV0d29yayBvYmplY3Qgd2l0aCBpZCAke2lkfSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRgKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgbmV0d29yayBvYmplY3Qgd2l0aCB0aGlzIElEIHJlbW90ZWx5IGJ5IHRyeWluZyB0byByZWdpc3RlciBpdFxuICAgIGNvbnN0IHVuc3ViUHJvbWlzZXMgPSBbXG4gICAgICBuZXR3b3JrU2VydmljZS5yZWdpc3RlclJlcXVlc3RIYW5kbGVyKFxuICAgICAgICBnZXROZXR3b3JrT2JqZWN0UmVxdWVzdFR5cGUoaWQpLFxuICAgICAgICAoKSA9PiBQcm9taXNlLnJlc29sdmUodHJ1ZSksXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6IHtcbiAgICAgICAgICAgIHN1bW1hcnk6IG9iamVjdERvY3VtZW50YXRpb24uc3VtbWFyeSA/PyAnJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBvYmplY3REb2N1bWVudGF0aW9uLmRlc2NyaXB0aW9uID8/ICcnLFxuICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICBuYW1lOiAncmV0dXJuIHZhbHVlJyxcbiAgICAgICAgICAgICAgc3VtbWFyeTogJ0RvZXMgdGhlIG5ldHdvcmsgb2JqZWN0IGV4aXN0PycsXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcG9uZW50czogb2JqZWN0RG9jdW1lbnRhdGlvbi5jb21wb25lbnRzLFxuICAgICAgICB9LFxuICAgICAgKSxcbiAgICBdO1xuXG4gICAgLy8gQWxzbyBjaGVjayBpZiB3ZSBjYW4gcmVnaXN0ZXIgYWxsIG9mIHRoZSBuZXR3b3JrIG9iamVjdCdzIGZ1bmN0aW9uc1xuICAgIGNvbnN0IG5ldE9iakRldGFpbHMgPSBjcmVhdGVOZXR3b3JrT2JqZWN0RGV0YWlscyhcbiAgICAgIGlkLFxuICAgICAgb2JqZWN0VHlwZSxcbiAgICAgIC8vIE5ldHdvcmthYmxlT2JqZWN0IGlzbid0IHNwZWNpZmljIGVub3VnaCBhbmQgY2hhbmdpbmcgaXQgaXMgcGFpbmZ1bFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gICAgICBvYmplY3RUb1NoYXJlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICAgb2JqZWN0QXR0cmlidXRlcyxcbiAgICApO1xuXG4gICAgbmV0T2JqRGV0YWlscy5mdW5jdGlvbk5hbWVzLmZvckVhY2goKGZ1bmN0aW9uTmFtZSkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdFR5cGUgPSBnZXROZXR3b3JrT2JqZWN0UmVxdWVzdFR5cGUoaWQsIGZ1bmN0aW9uTmFtZSk7XG4gICAgICBjb25zdCBtZXRob2REb2NzID1cbiAgICAgICAgb2JqZWN0RG9jdW1lbnRhdGlvbi5tZXRob2RzPy5maW5kKChtZXRob2QpID0+IG1ldGhvZC5uYW1lID09PSBmdW5jdGlvbk5hbWUpID8/XG4gICAgICAgIGdldEVtcHR5TWV0aG9kRG9jcygpO1xuICAgICAgY29uc3QgdW5zdWIgPSBuZXR3b3JrU2VydmljZS5yZWdpc3RlclJlcXVlc3RIYW5kbGVyKFxuICAgICAgICByZXF1ZXN0VHlwZSxcbiAgICAgICAgLy8gQXNzZXJ0IGFzIGFueSB0byBhbGxvdyBpbmRleGluZyBvbiB0aGUgZnVuY3Rpb24gbmFtZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICAgICAgKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gUHJvbWlzZS5yZXNvbHZlKChvYmplY3RUb1NoYXJlIGFzIGFueSlbZnVuY3Rpb25OYW1lXSguLi5hcmdzKSksXG4gICAgICAgIHsgbWV0aG9kOiBtZXRob2REb2NzIH0sXG4gICAgICApO1xuICAgICAgdW5zdWJQcm9taXNlcy5wdXNoKHVuc3ViKTtcbiAgICB9KTtcblxuICAgIC8vIEF3YWl0IGFsbCBvZiB0aGUgcmVnaXN0cmF0aW9ucyBmaW5pc2hpbmcsIHN1Y2Nlc3NmdWwgb3Igbm90XG4gICAgY29uc3QgcmVnaXN0cmF0aW9uUmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHVuc3ViUHJvbWlzZXMpO1xuICAgIGNvbnN0IGRpZFN1Y2Nlc3NmdWxseVJlZ2lzdGVyID0gcmVnaXN0cmF0aW9uUmVzcG9uc2VzLmV2ZXJ5KFxuICAgICAgKHJlc3BvbnNlKSA9PiByZXNwb25zZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnLFxuICAgICk7XG5cbiAgICBpZiAoIWRpZFN1Y2Nlc3NmdWxseVJlZ2lzdGVyKSB7XG4gICAgICAvLyBDbGVhbiB1cCBieSB1bnJlZ2lzdGVyaW5nIGFueSBzdWNjZXNzZnVsIHJlcXVlc3QgaGFuZGxlcnNcbiAgICAgIGNvbnN0IHJlamVjdGVkUmVxdWVzdEhhbmRsZXJSZWFzb25zOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHJlZ2lzdHJhdGlvblJlc3BvbnNlcy5tYXAoYXN5bmMgKHJlc3BvbnNlLCByZWdpc3RyYXRpb25JbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKVxuICAgICAgICAgICAgLy8gUnVuIHRoZSB1bnN1YnNjcmliZXIgZm9yIHRoaXMgcmVnaXN0cmF0aW9uXG4gICAgICAgICAgICAoYXdhaXQgdW5zdWJQcm9taXNlc1tyZWdpc3RyYXRpb25JbmRleF0pKCk7XG4gICAgICAgICAgLy8gQ29sbGVjdCB0aGUgcmVhc29ucyBmb3IgZmFpbHVyZSBzbyB3ZSBjYW4gdGhyb3cgYSB1c2VmdWwgZXJyb3JcbiAgICAgICAgICBlbHNlIHJlamVjdGVkUmVxdWVzdEhhbmRsZXJSZWFzb25zLnB1c2gocmVzcG9uc2UucmVhc29uKTtcbiAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBVbmFibGUgdG8gcmVnaXN0ZXIgbmV0d29yayBvYmplY3Qgd2l0aCBpZCAke2lkfTpcXG5cXHQke3JlamVjdGVkUmVxdWVzdEhhbmRsZXJSZWFzb25zLmpvaW4oXG4gICAgICAgICAgJ1xcblxcdCcsXG4gICAgICAgICl9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIG5ldHdvcmsgb2JqZWN0IGhhcyBiZWVuIHJlZ2lzdGVyZWRcbiAgICAvLyBDcmVhdGUgYSBwcm94eSBvYmplY3QgdGhhdCBibG9ja3MgZnVuY3Rpb25zIGxpa2UgXCJkaXNwb3NlXCIgZm9yIG90aGVycyBpbiB0aGUgc2FtZSBwcm9jZXNzXG4gICAgY29uc3QgbG9jYWxQcm94eSA9IGNyZWF0ZUxvY2FsUHJveHkob2JqZWN0VG9TaGFyZSk7XG5cbiAgICAvLyBTZXR1cCBvbkRpZERpc3Bvc2Ugc28gdGhhdCBzZXJ2aWNlcyB3aWxsIGtub3cgd2hlbiB0aGUgcHJveHkgaXMgZGVhZFxuICAgIGNvbnN0IG9uRGlkRGlzcG9zZUxvY2FsRW1pdHRlciA9IG5ldyBQbGF0Zm9ybUV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAgIG92ZXJyaWRlT25EaWREaXNwb3NlKGlkLCBvYmplY3RUb1NoYXJlLCBvbkRpZERpc3Bvc2VMb2NhbEVtaXR0ZXIuZXZlbnQpO1xuXG4gICAgLy8gT3ZlcnJpZGUgZGlzcG9zZSBvbiB0aGUgb2JqZWN0IHBhc3NlZCBpbiB0byBjbGVhbiB1cCB0aGUgbmV0d29yayBvYmplY3RcbiAgICBvdmVycmlkZURpc3Bvc2Uob2JqZWN0VG9TaGFyZSwgYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgICAgLy8gVW5zdWJzY3JpYmUgYWxsIHJlcXVlc3RzIGZvciB0aGlzIG5ldHdvcmsgb2JqZWN0XG4gICAgICBjb25zdCB1bnN1YnNjcmliZXJzID0gYWdncmVnYXRlVW5zdWJzY3JpYmVyQXN5bmNzKGF3YWl0IFByb21pc2UuYWxsKHVuc3ViUHJvbWlzZXMpKTtcbiAgICAgIGlmICghKGF3YWl0IHVuc3Vic2NyaWJlcnMoKSkpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gdW5zdWJzY3JpYmUgYWxsIHJlcXVlc3RzIGZvciAke2lkfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlbmQgYW4gZXZlbnQgbm90aWZ5aW5nIGV2ZXJ5b25lIHRoYXQgdGhpcyBuZXR3b3JrIG9iamVjdCBpcyBubyBsb25nZXIgYXZhaWxhYmxlXG4gICAgICAvLyBUaGUgZXZlbnQgbGlzdGVuZXIgcmVtb3ZlcyB0aGUgbmV0d29yayBvYmplY3QgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIG1hcFxuICAgICAgb25EaWREaXNwb3NlTmV0d29ya09iamVjdEVtaXR0ZXIuZW1pdChpZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIFNldCB0aGUgbmV0d29yayBvYmplY3QgbG9jYWxseVxuICAgIG5ldHdvcmtPYmplY3RSZWdpc3RyYXRpb25zLnNldChpZCwge1xuICAgICAgcmVnaXN0cmF0aW9uVHlwZTogTmV0d29ya09iamVjdFJlZ2lzdHJhdGlvblR5cGUuTG9jYWwsXG4gICAgICBvbkRpZERpc3Bvc2VFbWl0dGVyOiBvbkRpZERpc3Bvc2VMb2NhbEVtaXR0ZXIsXG4gICAgICAvLyBBc3NlcnQgdG8gc3BlY2lmaWVkIGdlbmVyaWMgdHlwZS5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICAgICAgbmV0d29ya09iamVjdDogbG9jYWxQcm94eS5wcm94eSBhcyBOZXR3b3JrT2JqZWN0PFQ+LFxuICAgICAgcmV2b2tlUHJveHk6IGxvY2FsUHJveHkucmV2b2tlLFxuICAgIH0pO1xuXG4gICAgLy8gTm90aWZ5IHRoYXQgdGhlIG5ldHdvcmsgb2JqZWN0IHdhcyBzdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZFxuICAgIGxvZ2dlci5kZWJ1ZyhgTmV0d29yayBvYmplY3QgcmVnaXN0ZXJlZDogJHtzZXJpYWxpemUobmV0T2JqRGV0YWlscyl9YCk7XG4gICAgb25EaWRDcmVhdGVOZXR3b3JrT2JqZWN0RW1pdHRlci5lbWl0KG5ldE9iakRldGFpbHMpO1xuXG4gICAgLy8gT3ZlcnJpZGUgb2JqZWN0VG9TaGFyZSdzIHR5cGUncyBmb3JjZS11bmRlZmluZWQgb25EaWREaXNwb3NlIHRvIERpc3Bvc2FibGVOZXR3b3JrT2JqZWN0J3NcbiAgICAvLyBvbkRpZERpc3Bvc2UgdHlwZSBiZWNhdXNlIGl0IGhhZCBhbiBvbkRpZERpc3Bvc2UgYWRkZWQgaW4gb3ZlcnJpZGVPbkRpZERpc3Bvc2UuXG4gICAgLy8gQXNzZXJ0IHRvIHNwZWNpZmllZCBnZW5lcmljIHR5cGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gICAgcmV0dXJuIG9iamVjdFRvU2hhcmUgYXMgT21pdDxDYW5IYXZlT25EaWREaXNwb3NlPFQ+LCAnZGlzcG9zZSc+IGFzIERpc3Bvc2FibGVOZXR3b3JrT2JqZWN0PFQ+O1xuICB9KTtcbn07XG5cbi8vICNlbmRyZWdpb25cblxuLy8gRGVjbGFyZSBhbiBpbnRlcmZhY2UgZm9yIHRoZSBvYmplY3Qgd2Ugd2lsbCBleHBvcnQgdG8gUEFQSVxuZXhwb3J0IGludGVyZmFjZSBNaW5pbWFsTmV0d29ya09iamVjdFNlcnZpY2Uge1xuICBnZXQ6IHR5cGVvZiBnZXQ7XG4gIHNldDogdHlwZW9mIHNldDtcbiAgb25EaWRDcmVhdGVOZXR3b3JrT2JqZWN0OiB0eXBlb2Ygb25EaWRDcmVhdGVOZXR3b3JrT2JqZWN0O1xufVxuXG4vLyBEZWNsYXJlIGFuIGludGVyZmFjZSBmb3IgdGhlIG9iamVjdCB3ZSdyZSBleHBvcnRpbmcgc28gdGhhdCBKU0RvYyBjb21tZW50cyBwcm9wYWdhdGVcbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya09iamVjdFNlcnZpY2UgZXh0ZW5kcyBNaW5pbWFsTmV0d29ya09iamVjdFNlcnZpY2Uge1xuICBpbml0aWFsaXplOiB0eXBlb2YgaW5pdGlhbGl6ZTtcbiAgaGFzS25vd246IHR5cGVvZiBoYXNLbm93bjtcbn1cblxuLyoqXG4gKiBKU0RPQyBTT1VSQ0UgbmV0d29ya09iamVjdFNlcnZpY2VcbiAqXG4gKiBOZXR3b3JrIG9iamVjdHMgYXJlIGRpc3RyaWJ1dGVkIG9iamVjdHMgd2l0aGluIFBBUEkgZm9yIFRTL0pTIG9iamVjdHMuIEBzZWVcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RyaWJ1dGVkX29iamVjdFxuICpcbiAqIE9iamVjdHMgcmVnaXN0ZXJlZCB2aWEge0BsaW5rIG5ldHdvcmtPYmplY3RTZXJ2aWNlLnNldH0gYXJlIHJldHJpZXZhYmxlIHVzaW5nXG4gKiB7QGxpbmsgbmV0d29ya09iamVjdFNlcnZpY2UuZ2V0fS5cbiAqXG4gKiBGdW5jdGlvbiBjYWxscyBtYWRlIG9uIG5ldHdvcmsgb2JqZWN0cyByZXRyaWV2ZWQgdmlhIHtAbGluayBuZXR3b3JrT2JqZWN0U2VydmljZS5nZXR9IGFyZSBwcm94aWVkXG4gKiBhbmQgc2VudCB0byB0aGUgb3JpZ2luYWwgb2JqZWN0cyByZWdpc3RlcmVkIHZpYSB7QGxpbmsgbmV0d29ya09iamVjdFNlcnZpY2Uuc2V0fS4gQWxsIGZ1bmN0aW9ucyBvblxuICogdGhlIHJlZ2lzdGVyZWQgb2JqZWN0IGFyZSBwcm94aWVkIGV4Y2VwdCBmb3IgY29uc3RydWN0b3JzLCBgZGlzcG9zZWAsIGFuZCBmdW5jdGlvbnMgc3RhcnRpbmcgd2l0aFxuICogYG9uYCBzaW5jZSB0aG9zZSBzaG91bGQgYmUgZXZlbnRzICh3aGljaCBhcmUgbm90IGludGVuZGVkIHRvIGJlIHByb3hpZWQpIGJhc2VkIG9uIG91ciBuYW1pbmdcbiAqIGNvbnZlbnRpb24uIElmIHlvdSBkb24ndCB3YW50IGEgZnVuY3Rpb24gdG8gYmUgcHJveGllZCwgZG9uJ3QgbWFrZSBpdCBhIHByb3BlcnR5IG9mIHRoZVxuICogcmVnaXN0ZXJlZCBvYmplY3QuXG4gKlxuICogRnVuY3Rpb25zIG9uIGEgbmV0d29yayBvYmplY3Qgd2lsbCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkgYnkgb3RoZXIgcHJvY2Vzc2VzIHJlZ2FyZGxlc3Mgb2ZcbiAqIHdoZXRoZXIgdGhlIGZ1bmN0aW9ucyBhcmUgc3luY2hyb25vdXMgb3IgYXN5bmNocm9ub3VzLCBzbyBpdCBpcyBiZXN0IHRvIG1ha2UgdGhlbSBhbGxcbiAqIGFzeW5jaHJvbm91cy4gQWxsIHNoYXJlZCBmdW5jdGlvbnMnIGFyZ3VtZW50cyBhbmQgcmV0dXJuIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZSB0byBiZSBjYWxsZWRcbiAqIGFjcm9zcyBwcm9jZXNzZXMuXG4gKlxuICogV2hlbiBhIHNlcnZpY2UgcmVnaXN0ZXJzIGFuIG9iamVjdCB2aWEge0BsaW5rIG5ldHdvcmtPYmplY3RTZXJ2aWNlLnNldH0sIGl0IGlzIHRoZSByZXNwb25zaWJpbGl0eVxuICogb2YgdGhhdCBzZXJ2aWNlLCBhbmQgb25seSB0aGF0IHNlcnZpY2UsIHRvIGNhbGwgYGRpc3Bvc2VgIG9uIHRoYXQgb2JqZWN0IHdoZW4gaXQgaXMgbm8gbG9uZ2VyXG4gKiBpbnRlbmRlZCB0byBiZSBzaGFyZWQgd2l0aCBvdGhlciBzZXJ2aWNlcy5cbiAqXG4gKiBXaGVuIGFuIG9iamVjdCBpcyBkaXNwb3NlZCBieSBjYWxsaW5nIGBkaXNwb3NlYCwgYWxsIGZ1bmN0aW9ucyByZWdpc3RlcmVkIHdpdGggdGhlIGBvbkRpZERpc3Bvc2VgXG4gKiBldmVudCBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkLiBBZnRlciBhbiBvYmplY3QgaXMgZGlzcG9zZWQsIGNhbGxzIHRvIGl0cyBmdW5jdGlvbnMgd2lsbCBubyBsb25nZXJcbiAqIGJlIHByb3hpZWQgdG8gdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IG5ldHdvcmtPYmplY3RTZXJ2aWNlOiBOZXR3b3JrT2JqZWN0U2VydmljZSA9IHtcbiAgaW5pdGlhbGl6ZSxcbiAgaGFzS25vd24sXG4gIGdldCxcbiAgc2V0LFxuICBvbkRpZENyZWF0ZU5ldHdvcmtPYmplY3QsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXR3b3JrT2JqZWN0U2VydmljZTtcblxuLy8gVGhpcyBpcyBvbmx5IGludGVuZGVkIGZvciB1c2Ugb24gUEFQSVxuLyoqIEpTRE9DIERFU1RJTkFUSU9OIG5ldHdvcmtPYmplY3RTZXJ2aWNlICovXG5leHBvcnQgY29uc3QgbWluaW1hbE5ldHdvcmtPYmplY3RTZXJ2aWNlOiBNaW5pbWFsTmV0d29ya09iamVjdFNlcnZpY2UgPSB7XG4gIGdldCxcbiAgc2V0LFxuICBvbkRpZENyZWF0ZU5ldHdvcmtPYmplY3QsXG59O1xuIiwiLyoqXG4gKiBIYW5kbGVzIHJlcXVlc3RzLCByZXNwb25zZXMsIHN1YnNjcmlwdGlvbnMsIGV0Yy4gdG8gdGhlIGJhY2tlbmQuIExpa2VseSBzaG91bGRuJ3QgbmVlZC93YW50IHRvXG4gKiBleHBvc2UgdGhpcyB3aG9sZSBzZXJ2aWNlIG9uIHBhcGksIGJ1dCB0aGVyZSBhcmUgYSBmZXcgdGhpbmdzIHRoYXQgYXJlIGV4cG9zZWQgdmlhXG4gKiBwYXBpTmV0d29ya1NlcnZpY2VcbiAqL1xuXG5pbXBvcnQge1xuICBDQVRFR09SWV9DT01NQU5ELFxuICBFdmVudEhhbmRsZXIsXG4gIGZpeHVwUmVzcG9uc2UsXG4gIEdFVF9NRVRIT0RTLFxuICBJbnRlcm5hbFJlcXVlc3RIYW5kbGVyLFxufSBmcm9tICdAc2hhcmVkL2RhdGEvcnBjLm1vZGVsJztcbmltcG9ydCB7XG4gIGluZGV4T2YsXG4gIGlzUGxhdGZvcm1FcnJvcixcbiAgTXV0ZXgsXG4gIG5ld1BsYXRmb3JtRXJyb3IsXG4gIFBsYXRmb3JtRXZlbnQsXG4gIFBsYXRmb3JtRXZlbnRFbWl0dGVyLFxuICBzdHJpbmdMZW5ndGgsXG4gIFVuc3Vic2NyaWJlckFzeW5jLFxufSBmcm9tICdwbGF0Zm9ybS1iaWJsZS11dGlscyc7XG5pbXBvcnQgeyBkZXNlcmlhbGl6ZVJlcXVlc3RUeXBlLCBTZXJpYWxpemVkUmVxdWVzdFR5cGUgfSBmcm9tICdAc2hhcmVkL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHsgUGFwaU5ldHdvcmtFdmVudEVtaXR0ZXIgfSBmcm9tICdAc2hhcmVkL21vZGVscy9wYXBpLW5ldHdvcmstZXZlbnQtZW1pdHRlci5tb2RlbCc7XG5pbXBvcnQgeyBJUnBjTWV0aG9kUmVnaXN0cmFyIH0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvcnBjLmludGVyZmFjZSc7XG5pbXBvcnQgeyBjcmVhdGVScGNIYW5kbGVyIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9ycGMtaGFuZGxlci5mYWN0b3J5JztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbG9nZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2luZ2xlTWV0aG9kRG9jdW1lbnRhdGlvbiB9IGZyb20gJ0BzaGFyZWQvbW9kZWxzL29wZW5ycGMubW9kZWwnO1xuaW1wb3J0IHsgSlNPTlJQQ1Jlc3BvbnNlIH0gZnJvbSAnQG5vZGVfbW9kdWxlcy9qc29uLXJwYy0yLjAvZGlzdCc7XG5cbi8vICNyZWdpb24gTG9jYWwgZXZlbnQgaGFuZGxpbmdcblxuLyoqXG4gKiBNYXAgZnJvbSBldmVudCB0eXBlIHRvIHRoZSBlbWl0dGVyIGZvciB0aGF0IHR5cGUgYXMgd2VsbCBhcyBpZiB0aGF0IGVtaXR0ZXIgaXMgXCJyZWdpc3RlcmVkXCIgYWthXG4gKiBvbmUgcmVmZXJlbmNlIHRvIHRoYXQgZW1pdHRlciBoYXMgYmVlbiBwcm92aWRlZCBzb21ld2hlcmUgc3VjaCB0aGF0IHRoYXQgZXZlbnQgY2FuIGJlIGVtaXR0ZWRcbiAqIGZyb20gdGhhdCBvbmUgcGxhY2UuIE5ldHdvcmtFdmVudEVtaXR0ZXIgdHlwZXMgc2hvdWxkIG5vdCBvY2N1ciBtdWx0aXBsZSB0aW1lcyBzbyBleHRlbnNpb25zXG4gKiBjYW5ub3QgZW1pdCBldmVudHMgdGhleSBzaG91bGRuJ3QsIHNvIHdlIGhhdmUgYSBxdWljayBhbmQgZWFzeSBubyBzaGFyaW5nIGluIHByb2Nlc3MgcnVsZSBpblxuICogY3JlYXRlTmV0d29ya0V2ZW50RW1pdHRlci5cbiAqL1xuLy8gVE9ETzogc3luYyB0aGVzZSBiZXR3ZWVuIHByb2Nlc3Nlc1xuY29uc3QgZXZlbnRFbWl0dGVyc0J5RXZlbnRUeXBlID0gbmV3IE1hcDxcbiAgc3RyaW5nLFxuICB7IGVtaXR0ZXI6IFBhcGlOZXR3b3JrRXZlbnRFbWl0dGVyPHVua25vd24+OyBpc1JlZ2lzdGVyZWQ6IGJvb2xlYW4gfVxuPigpO1xuXG4vKipcbiAqIEVtaXRzIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGV2ZW50IG9uIHRoaXMgcHJvY2VzcyBhY2NvcmRpbmcgdG8gdGhlIGV2ZW50IHR5cGVcbiAqXG4gKiBAcGFyYW0gZXZlbnRUeXBlIFR5cGUgb2YgZXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IGRhdGEgdG8gZW1pdFxuICovXG5jb25zdCBoYW5kbGVFdmVudEZyb21OZXR3b3JrOiBFdmVudEhhbmRsZXIgPSA8VD4oZXZlbnRUeXBlOiBzdHJpbmcsIGV2ZW50OiBUKSA9PiB7XG4gIGV2ZW50RW1pdHRlcnNCeUV2ZW50VHlwZS5nZXQoZXZlbnRUeXBlKT8uZW1pdHRlci5lbWl0TG9jYWwoZXZlbnQpO1xufTtcblxuLy8gI2VuZHJlZ2lvblxuXG4vLyAjcmVnaW9uIFNlcnZpY2UgaW5pdGlhbGl6YXRpb24gYW5kIHNodXRkb3duXG5cbmNvbnN0IGNvbm5lY3Rpb25NdXRleCA9IG5ldyBNdXRleCgpO1xubGV0IGpzb25ScGM6IElScGNNZXRob2RSZWdpc3RyYXIgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICBpZiAoanNvblJwYykgcmV0dXJuO1xuICBhd2FpdCBjb25uZWN0aW9uTXV0ZXgucnVuRXhjbHVzaXZlKGFzeW5jICgpID0+IHtcbiAgICBpZiAoanNvblJwYykgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGpzb25ScGMgPSBhd2FpdCBjcmVhdGVScGNIYW5kbGVyKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uU2VydmljZTogRmFpbGVkIHRvIGNyZWF0ZSBOZXR3b3JrQ29ubmVjdG9yIG9iamVjdDogJHtlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbm5lY3RlZCA9IGF3YWl0IGpzb25ScGMuY29ubmVjdChoYW5kbGVFdmVudEZyb21OZXR3b3JrKTtcbiAgICBpZiAoIWNvbm5lY3RlZCkgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY29ubmVjdCBwcm90b2NvbCBoYW5kbGVyYCk7XG4gIH0pO1xufVxuXG4vKiogQ2xvc2VzIHRoZSBuZXR3b3JrIHNlcnZpY2VzIGdyYWNlZnVsbHkgKi9cbmV4cG9ydCBjb25zdCBzaHV0ZG93biA9IGFzeW5jICgpID0+IHtcbiAgaWYgKCFqc29uUnBjKSByZXR1cm47XG4gIGF3YWl0IGNvbm5lY3Rpb25NdXRleC5ydW5FeGNsdXNpdmUoYXN5bmMgKCkgPT4ge1xuICAgIGlmICghanNvblJwYykgcmV0dXJuO1xuXG4gICAgYXdhaXQganNvblJwYy5kaXNjb25uZWN0KCk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBbLi4uZXZlbnRFbWl0dGVyc0J5RXZlbnRUeXBlLnZhbHVlcygpXS5tYXAoYXN5bmMgKGVtaXR0ZXIpID0+IHtcbiAgICAgICAgYXdhaXQgZW1pdHRlci5lbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgIH0pLFxuICAgICk7XG4gICAgZXZlbnRFbWl0dGVyc0J5RXZlbnRUeXBlLmNsZWFyKCk7XG4gICAganNvblJwYyA9IHVuZGVmaW5lZDtcbiAgfSk7XG59O1xuXG4vLyAjZW5kcmVnaW9uXG5cbi8vICNyZWdpb24gUmVxdWVzdCBoYW5kbGluZ1xuXG4vLyBUaGlzIGlzIGEgaGFyZCBjb2RlZCBkZWZhdWx0IHRoYXQgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgc2V0dGluZ3MgdmFsdWUgYWZ0ZXIgaXQgbG9hZHNcbmxldCByZXF1ZXN0VGltZW91dE1zID0gMzAwMDA7XG5cbi8vIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3QganVzdCBjYWxsIHRoZSBzZXR0aW5ncyBzZXJ2aWNlIHRvIHJlYWQgdGhlIHRpbWVvdXQuIFRoYXQncyBiZWNhdXNlIHRoZVxuLy8gc2V0dGluZ3Mgc2VydmljZSBkZXBlbmRzIG9uIHRoZSBuZXR3b3JrIHNlcnZpY2UgKGluZGlyZWN0bHkpLiBDcmVhdGluZyBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcbi8vIGJldHdlZW4gdGhlIHR3byBzZXJ2aWNlcyB3b3VsZCBiZSBiYWQuIFNvIHdlIHVzZSBhIGhhcmQgY29kZWQgZGVmYXVsdCBhbmQgdGhlbiBsZXQgc29tZXRoaW5nIGVsc2Vcbi8vIHNldCB0aGUgdGltZW91dCBhZnRlciB0aGUgbmV0d29yayBzZXJ2aWNlIGFuZCBzZXR0aW5ncyBzZXJ2aWNlIGFyZSBib3RoIGluaXRpYWxpemVkLlxuLyoqIFNldCB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdGhhdCBuZXR3b3JrIHJlcXVlc3RzIGluIHRoaXMgcHJvY2VzcyBzaG91bGQgd2FpdCBiZWZvcmUgdGltaW5nIG91dCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFJlcXVlc3RUaW1lb3V0KHRpbWVvdXRTZWNvbmRzOiBudW1iZXIpIHtcbiAgaWYgKHRpbWVvdXRTZWNvbmRzIDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVxdWVzdCB0aW1lb3V0ICR7dGltZW91dFNlY29uZHN9OiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcmApO1xuICByZXF1ZXN0VGltZW91dE1zID0gdGltZW91dFNlY29uZHMgKiAxMDAwOyAvLyBjb252ZXJ0IHRvIG1pbGxpc2Vjb25kc1xuICBsb2dnZXIuaW5mbyhgWyR7Z2xvYmFsVGhpcy5wcm9jZXNzVHlwZX1dIFJlcXVlc3QgdGltZW91dCBzZXQgdG8gJHtyZXF1ZXN0VGltZW91dE1zfW1zYCk7XG59XG5cbi8qKiBJbnNwZWN0IGEgdmFsdWUgdG8gc2VlIGlmIHdlIHNob3VsZCBwcm9jZXNzIGl0IGFzIGEgSlNPTlJQQ1Jlc3BvbnNlIG9mIHNvbWUgc29ydCAqL1xuZnVuY3Rpb24gaXNKc29uUnBjUmVzcG9uc2UocmVzcG9uc2U6IHVua25vd24pOiByZXNwb25zZSBpcyBKU09OUlBDUmVzcG9uc2Uge1xuICByZXR1cm4gISFyZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UgPT09ICdvYmplY3QnICYmICdqc29ucnBjJyBpbiByZXNwb25zZTtcbn1cblxuLyoqIEVuc3VyZSB0aGUgY29tbWFuZCBuYW1lIGNvbnNpc3RzIG9mIHR3byBzdHJpbmdzIHNlcGFyYXRlZCBieSBhdCBsZWFzdCBvbmUgcGVyaW9kICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbW1hbmRGb3JtYXR0aW5nKGNvbW1hbmROYW1lOiBzdHJpbmcpIHtcbiAgaWYgKCFjb21tYW5kTmFtZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29tbWFuZCBuYW1lICR7Y29tbWFuZE5hbWV9OiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ2ApO1xuICBjb25zdCBwZXJpb2RJbmRleCA9IGluZGV4T2YoY29tbWFuZE5hbWUsICcuJyk7XG4gIGlmIChwZXJpb2RJbmRleCA8IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbW1hbmQgbmFtZSAke2NvbW1hbmROYW1lfTogbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBwZXJpb2RgKTtcbiAgaWYgKHBlcmlvZEluZGV4ID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGNvbW1hbmQgbmFtZSAke2NvbW1hbmROYW1lfTogbXVzdCBoYXZlIG5vbi1lbXB0eSBzdHJpbmcgYmVmb3JlIGEgcGVyaW9kYCxcbiAgICApO1xuICBpZiAocGVyaW9kSW5kZXggPj0gc3RyaW5nTGVuZ3RoKGNvbW1hbmROYW1lKSAtIDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgY29tbWFuZCBuYW1lICR7Y29tbWFuZE5hbWV9OiBtdXN0IGhhdmUgYSBub24tZW1wdHkgc3RyaW5nIGFmdGVyIGEgcGVyaW9kYCxcbiAgICApO1xufVxuXG4vKiogQ2hlY2sgdG8gbWFrZSBzdXJlIHRoZSByZXF1ZXN0IGZvbGxvd3MgYW55IHJlcXVlc3QgcmVnaXN0cmF0aW9uIHJ1bGVzICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJlcXVlc3RUeXBlRm9ybWF0dGluZyhyZXF1ZXN0VHlwZTogU2VyaWFsaXplZFJlcXVlc3RUeXBlKSB7XG4gIC8vIFRoaXMgcmVxdWVzdCB0eXBlIGRvZXNuJ3QgY29uZm9ybSB0byB0aGUgbm9ybWFsIGZvcm1hdCBidXQgaXMgcmVxdWlyZWQgYnkgT3BlblJQQ1xuICBpZiAocmVxdWVzdFR5cGUudG9TdHJpbmcoKSA9PT0gR0VUX01FVEhPRFMpIHJldHVybjtcbiAgY29uc3QgeyBjYXRlZ29yeSwgZGlyZWN0aXZlIH0gPSBkZXNlcmlhbGl6ZVJlcXVlc3RUeXBlKHJlcXVlc3RUeXBlKTtcbiAgaWYgKGNhdGVnb3J5ID09PSBDQVRFR09SWV9DT01NQU5EKSB7XG4gICAgdmFsaWRhdGVDb21tYW5kRm9ybWF0dGluZyhkaXJlY3RpdmUpO1xuICB9XG59XG5cbi8qKlxuICogU2VuZCBhIHJlcXVlc3Qgb24gdGhlIG5ldHdvcmsgYW5kIHJlc29sdmUgdGhlIHJlc3BvbnNlIGNvbnRlbnRzLlxuICpcbiAqIEBwYXJhbSByZXF1ZXN0VHlwZSBUaGUgdHlwZSBvZiByZXF1ZXN0XG4gKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gc2VuZCBpbiB0aGUgcmVxdWVzdCAocHV0IGluIHJlcXVlc3QuY29udGVudHMpXG4gKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxuICovXG5leHBvcnQgY29uc3QgcmVxdWVzdCA9IGFzeW5jIDxUUGFyYW0gZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgVFJldHVybj4oXG4gIHJlcXVlc3RUeXBlOiBTZXJpYWxpemVkUmVxdWVzdFR5cGUsXG4gIC4uLmFyZ3M6IFRQYXJhbVxuKTogUHJvbWlzZTxUUmV0dXJuPiA9PiB7XG4gIHZhbGlkYXRlUmVxdWVzdFR5cGVGb3JtYXR0aW5nKHJlcXVlc3RUeXBlKTtcbiAgYXdhaXQgaW5pdGlhbGl6ZSgpO1xuICBpZiAoIWpzb25ScGMpIHRocm93IG5ldyBFcnJvcignUlBDIGhhbmRsZXIgbm90IHNldCcpO1xuICBsZXQgdGltZW91dE9jY3VycmVkID0gZmFsc2U7XG4gIGxldCByZXNwb25zZTogdW5rbm93bjtcbiAgLy8gSWYgdGhlIHJlcXVlc3QgdGFrZXMgbG9uZ2VyIHRoYW4gdGhlIGNvbmZpZ3VyZWQgdGltZW91dCwgdGhyb3cgYW4gZXJyb3JcbiAgaWYgKHJlcXVlc3RUaW1lb3V0TXMgPiAwKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBmaXh1cFJlc3BvbnNlKGF3YWl0IGpzb25ScGMucmVxdWVzdChyZXF1ZXN0VHlwZSwgYXJncykpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBuZXdQbGF0Zm9ybUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9KSgpLFxuICAgICAgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZW91dE9jY3VycmVkID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIHJlcXVlc3RUaW1lb3V0TXMpO1xuICAgICAgfSksXG4gICAgXSk7XG4gIH1cbiAgLy8gVGhlcmUgaXMgbm8gdGltZW91dCBzbyB3ZSBjYW4gcnVuIHRoZSByZXF1ZXN0IG5vcm1hbGx5XG4gIGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IGZpeHVwUmVzcG9uc2UoYXdhaXQganNvblJwYy5yZXF1ZXN0KHJlcXVlc3RUeXBlLCBhcmdzKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzcG9uc2UgPSBuZXdQbGF0Zm9ybUVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0pzb25ScGNSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICBpZiAoIXJlc3BvbnNlLmVycm9yKSByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICAgIHJlc3BvbnNlID0gYEpTT04tUlBDIFJlcXVlc3QgZXJyb3IgKCR7cmVzcG9uc2UuZXJyb3IuY29kZX0pOiAke3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2V9YDtcbiAgfSBlbHNlIGlmIChpc1BsYXRmb3JtRXJyb3IocmVzcG9uc2UpKSB7XG4gICAgbG9nZ2VyLmRlYnVnKHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgIHRocm93IHJlc3BvbnNlO1xuICB9IGVsc2Uge1xuICAgIHJlc3BvbnNlID0gdGltZW91dE9jY3VycmVkXG4gICAgICA/IGBKU09OLVJQQyBSZXF1ZXN0IHRpbWVkIG91dDogJHtyZXF1ZXN0VHlwZX0gJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gXG4gICAgICA6IGBJbnZhbGlkIEpTT04tUlBDIFJlc3BvbnNlOiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlKX1gO1xuICB9XG4gIGxvZ2dlci5kZWJ1ZyhyZXNwb25zZSk7XG4gIHRocm93IG5ld1BsYXRmb3JtRXJyb3IocmVzcG9uc2UpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGxvY2FsIHJlcXVlc3QgaGFuZGxlciB0byBydW4gb24gcmVxdWVzdHMuXG4gKlxuICogQHBhcmFtIHJlcXVlc3RUeXBlIFRoZSB0eXBlIG9mIHJlcXVlc3Qgb24gd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGhhbmRsZXJcbiAqIEBwYXJhbSBoYW5kbGVyIEZ1bmN0aW9uIHRvIHJlZ2lzdGVyIHRvIHJ1biBvbiByZXF1ZXN0c1xuICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIGlmIHRoZSByZXF1ZXN0IHN1Y2Nlc3NmdWxseSByZWdpc3RlcmVkIGFuZCB1bnN1YnNjcmliZXIgZnVuY3Rpb25cbiAqICAgdG8gcnVuIHRvIHN0b3AgdGhlIHBhc3NlZC1pbiBmdW5jdGlvbiBmcm9tIGhhbmRsaW5nIHJlcXVlc3RzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWdpc3RlclJlcXVlc3RIYW5kbGVyKFxuICByZXF1ZXN0VHlwZTogU2VyaWFsaXplZFJlcXVlc3RUeXBlLFxuICByZXF1ZXN0SGFuZGxlcjogSW50ZXJuYWxSZXF1ZXN0SGFuZGxlcixcbiAgcmVxdWVzdERvY3M/OiBTaW5nbGVNZXRob2REb2N1bWVudGF0aW9uLFxuKTogUHJvbWlzZTxVbnN1YnNjcmliZXJBc3luYz4ge1xuICBhd2FpdCBpbml0aWFsaXplKCk7XG4gIGlmICghanNvblJwYykgdGhyb3cgbmV3IEVycm9yKCdSUEMgaGFuZGxlciBub3Qgc2V0Jyk7XG4gIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBqc29uUnBjLnJlZ2lzdGVyTWV0aG9kKHJlcXVlc3RUeXBlLCByZXF1ZXN0SGFuZGxlciwgcmVxdWVzdERvY3MpO1xuICBpZiAoIXN1Y2Nlc3MpIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJlZ2lzdGVyIHJlcXVlc3QgaGFuZGxlciBmb3IgJHtyZXF1ZXN0VHlwZX1gKTtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWpzb25ScGMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4ganNvblJwYy51bnJlZ2lzdGVyTWV0aG9kKHJlcXVlc3RUeXBlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyBhIHJlcXVlc3QgZnVuY3Rpb24gd2l0aCBhIGJha2VkIHJlcXVlc3RUeXBlLiBUaGlzIGlzIGFsc28gbmljZSBiZWNhdXNlXG4gKiB5b3UgZ2V0IFR5cGVTY3JpcHQgdHlwZSBzdXBwb3J0IHVzaW5nIHRoaXMgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHJlcXVlc3RUeXBlIFJlcXVlc3RUeXBlIGZvciByZXF1ZXN0IGZ1bmN0aW9uXG4gKiBAcmV0dXJucyBGdW5jdGlvbiB0byBjYWxsIHdpdGggYXJndW1lbnRzIG9mIHJlcXVlc3QgdGhhdCBwZXJmb3JtcyB0aGUgcmVxdWVzdCBhbmQgcmVzb2x2ZXMgd2l0aFxuICogICB0aGUgcmVzcG9uc2UgY29udGVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlcXVlc3RGdW5jdGlvbiA9IDxUUGFyYW0gZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgVFJldHVybj4oXG4gIHJlcXVlc3RUeXBlOiBTZXJpYWxpemVkUmVxdWVzdFR5cGUsXG4pID0+IHtcbiAgcmV0dXJuIGFzeW5jICguLi5hcmdzOiBUUGFyYW0pID0+IHJlcXVlc3Q8VFBhcmFtLCBUUmV0dXJuPihyZXF1ZXN0VHlwZSwgLi4uYXJncyk7XG59O1xuXG4vLyAjZW5kcmVnaW9uXG5cbi8vICNyZWdpb24gRXZlbnQgaGFuZGxpbmdcblxuLyoqXG4gKiBTZW5kcyBhbiBldmVudCB0byBvdGhlciBjb25uZWN0aW9ucy4gRG9lcyBOT1QgcnVuIHRoZSBsb2NhbCBldmVudCBzdWJzY3JpcHRpb25zIGFzIHRoZXkgc2hvdWxkIGJlXG4gKiBydW4gYnkgTmV0d29ya0V2ZW50RW1pdHRlciBhZnRlciBzZW5kaW5nIG9uIG5ldHdvcmsuXG4gKlxuICogQHBhcmFtIGV2ZW50VHlwZSBVbmlxdWUgbmV0d29yayBldmVudCB0eXBlIGZvciBjb29yZGluYXRpbmcgYmV0d2VlbiBjb25uZWN0aW9uc1xuICogQHBhcmFtIGV2ZW50IEV2ZW50IHRvIGVtaXQgb24gdGhlIG5ldHdvcmtcbiAqL1xuY29uc3QgZW1pdEV2ZW50T25OZXR3b3JrID0gYXN5bmMgPFQ+KGV2ZW50VHlwZTogc3RyaW5nLCBldmVudDogVCkgPT4ge1xuICBhd2FpdCBpbml0aWFsaXplKCk7XG4gIGlmICghanNvblJwYykgdGhyb3cgbmV3IEVycm9yKCdSUEMgaGFuZGxlciBub3Qgc2V0Jyk7XG4gIGpzb25ScGMuZW1pdEV2ZW50T25OZXR3b3JrKGV2ZW50VHlwZSwgZXZlbnQpO1xufTtcblxuY29uc3QgY3JlYXRlTmV0d29ya0V2ZW50RW1pdHRlckludGVybmFsID0gPFQ+KFxuICBldmVudFR5cGU6IHN0cmluZyxcbiAgcmVnaXN0ZXJFbWl0dGVyOiBib29sZWFuLFxuKTogUGxhdGZvcm1FdmVudEVtaXR0ZXI8VD4gPT4ge1xuICBsZXQgZW1pdHRlclJlY29yZCA9IGV2ZW50RW1pdHRlcnNCeUV2ZW50VHlwZS5nZXQoZXZlbnRUeXBlKTtcbiAgaWYgKCFlbWl0dGVyUmVjb3JkKSB7XG4gICAgZW1pdHRlclJlY29yZCA9IHtcbiAgICAgIC8vIE1hdGNoIHRoZSBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICAgICAgZW1pdHRlcjogbmV3IFBhcGlOZXR3b3JrRXZlbnRFbWl0dGVyPFQ+KFxuICAgICAgICAoZXZlbnQpID0+IGVtaXRFdmVudE9uTmV0d29yayhldmVudFR5cGUsIGV2ZW50KSxcbiAgICAgICAgKCkgPT4gZXZlbnRFbWl0dGVyc0J5RXZlbnRUeXBlLmRlbGV0ZShldmVudFR5cGUpLFxuICAgICAgKSBhcyBQYXBpTmV0d29ya0V2ZW50RW1pdHRlcjx1bmtub3duPixcbiAgICAgIGlzUmVnaXN0ZXJlZDogZmFsc2UsXG4gICAgfTtcbiAgICBldmVudEVtaXR0ZXJzQnlFdmVudFR5cGUuc2V0KGV2ZW50VHlwZSwgZW1pdHRlclJlY29yZCk7XG4gIH1cblxuICBpZiAocmVnaXN0ZXJFbWl0dGVyKSB7XG4gICAgaWYgKGVtaXR0ZXJSZWNvcmQuaXNSZWdpc3RlcmVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eXBlICR7ZXZlbnRUeXBlfSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgdG8gYSBuZXR3b3JrIGV2ZW50IGVtaXR0ZXJgKTtcblxuICAgIGVtaXR0ZXJSZWNvcmQuaXNSZWdpc3RlcmVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIEFzc2VydCBhcyBlbWl0dGVyIHdpdGggYW4gdW5rbm93biB0eXBlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICByZXR1cm4gZW1pdHRlclJlY29yZC5lbWl0dGVyIGFzIFBsYXRmb3JtRXZlbnRFbWl0dGVyPFQ+O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IGVtaXR0ZXIgdGhhdCB3b3JrcyBwcm9wZXJseSBvdmVyIHRoZSBuZXR3b3JrLiBPdGhlciBjb25uZWN0aW9ucyByZWNlaXZlIHRoaXNcbiAqIGV2ZW50IHdoZW4gaXQgaXMgZW1pdHRlZC5cbiAqXG4gKiBXQVJOSU5HOiBZb3UgY2FuIG9ubHkgY3JlYXRlIGEgbmV0d29yayBldmVudCBlbWl0dGVyIG9uY2UgcGVyIGV2ZW50VHlwZSB0byBwcmV2ZW50IGhpamFja2VkIGV2ZW50XG4gKiBlbWl0dGVycy5cbiAqXG4gKiBAcGFyYW0gZXZlbnRUeXBlIFVuaXF1ZSBuZXR3b3JrIGV2ZW50IHR5cGUgZm9yIGNvb3JkaW5hdGluZyBiZXR3ZWVuIGNvbm5lY3Rpb25zXG4gKiBAcmV0dXJucyBFdmVudCBlbWl0dGVyIHdob3NlIGV2ZW50IHdvcmtzIGJldHdlZW4gY29ubmVjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU5ldHdvcmtFdmVudEVtaXR0ZXIgPSA8VD4oZXZlbnRUeXBlOiBzdHJpbmcpOiBQbGF0Zm9ybUV2ZW50RW1pdHRlcjxUPiA9PlxuICBjcmVhdGVOZXR3b3JrRXZlbnRFbWl0dGVySW50ZXJuYWwoZXZlbnRUeXBlLCB0cnVlKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuZXR3b3JrIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCB0eXBlLiBDcmVhdGVzIHRoZSBlbWl0dGVyIGlmIGl0IGRvZXMgbm90IGV4aXN0XG4gKlxuICogQHBhcmFtIGV2ZW50VHlwZSBVbmlxdWUgbmV0d29yayBldmVudCB0eXBlIGZvciBjb29yZGluYXRpbmcgYmV0d2VlbiBjb25uZWN0aW9uc1xuICogQHJldHVybnMgRXZlbnQgZm9yIHRoZSBldmVudCB0eXBlIHRoYXQgcnVucyB0aGUgY2FsbGJhY2sgcHJvdmlkZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZFxuICovXG5leHBvcnQgY29uc3QgZ2V0TmV0d29ya0V2ZW50ID0gPFQ+KGV2ZW50VHlwZTogc3RyaW5nKTogUGxhdGZvcm1FdmVudDxUPiA9PiB7XG4gIC8vIFJldHVybiBldmVudCB3aXRoIHRoZSBnZW5lcmljIHR5cGUuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvblxuICByZXR1cm4gY3JlYXRlTmV0d29ya0V2ZW50RW1pdHRlckludGVybmFsKGV2ZW50VHlwZSwgZmFsc2UpLmV2ZW50IGFzIFBsYXRmb3JtRXZlbnQ8VD47XG59O1xuXG4vLyAjZW5kcmVnaW9uXG5cbi8vIERlY2xhcmUgYW4gaW50ZXJmYWNlIGZvciB0aGUgb2JqZWN0IHdlJ3JlIGV4cG9ydGluZyBzbyB0aGF0IEpTRG9jIGNvbW1lbnRzIHByb3BhZ2F0ZVxuZXhwb3J0IGludGVyZmFjZSBQYXBpTmV0d29ya1NlcnZpY2Uge1xuICBjcmVhdGVOZXR3b3JrRXZlbnRFbWl0dGVyOiB0eXBlb2YgY3JlYXRlTmV0d29ya0V2ZW50RW1pdHRlcjtcbiAgZ2V0TmV0d29ya0V2ZW50OiB0eXBlb2YgZ2V0TmV0d29ya0V2ZW50O1xufVxuXG4vKipcbiAqIEpTRE9DIFNPVVJDRSBwYXBpTmV0d29ya1NlcnZpY2VcbiAqXG4gKiBTZXJ2aWNlIHRoYXQgcHJvdmlkZXMgYSB3YXkgdG8gc2VuZCBhbmQgcmVjZWl2ZSBuZXR3b3JrIGV2ZW50c1xuICovXG5leHBvcnQgY29uc3QgcGFwaU5ldHdvcmtTZXJ2aWNlOiBQYXBpTmV0d29ya1NlcnZpY2UgPSB7XG4gIGNyZWF0ZU5ldHdvcmtFdmVudEVtaXR0ZXIsXG4gIGdldE5ldHdvcmtFdmVudCxcbn07XG4iLCJpbXBvcnQge1xuICBOb3RpZmljYXRpb25TZXJ2aWNlTmV0d29ya09iamVjdE5hbWUsXG4gIHR5cGUgSU5vdGlmaWNhdGlvblNlcnZpY2UsXG59IGZyb20gJ0BzaGFyZWQvbW9kZWxzL25vdGlmaWNhdGlvbi5zZXJ2aWNlLW1vZGVsJztcbmltcG9ydCB7IG5ldHdvcmtPYmplY3RTZXJ2aWNlIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9uZXR3b3JrLW9iamVjdC5zZXJ2aWNlJztcbmltcG9ydCB7IGNyZWF0ZVN5bmNQcm94eUZvckFzeW5jT2JqZWN0IH0gZnJvbSAncGxhdGZvcm0tYmlibGUtdXRpbHMnO1xuXG5sZXQgbmV0d29ya09iamVjdDogSU5vdGlmaWNhdGlvblNlcnZpY2U7XG5sZXQgaW5pdGlhbGl6YXRpb25Qcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKCFpbml0aWFsaXphdGlvblByb21pc2UpIHtcbiAgICBpbml0aWFsaXphdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBleGVjdXRvciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBsb2NhbE5vdGlmaWNhdGlvblNlcnZpY2UgPSBhd2FpdCBuZXR3b3JrT2JqZWN0U2VydmljZS5nZXQ8SU5vdGlmaWNhdGlvblNlcnZpY2U+KFxuICAgICAgICAgICAgTm90aWZpY2F0aW9uU2VydmljZU5ldHdvcmtPYmplY3ROYW1lLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFsb2NhbE5vdGlmaWNhdGlvblNlcnZpY2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGAke05vdGlmaWNhdGlvblNlcnZpY2VOZXR3b3JrT2JqZWN0TmFtZX0gaXMgbm90IGF2YWlsYWJsZSBhcyBhIG5ldHdvcmsgb2JqZWN0YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbmV0d29ya09iamVjdCA9IGxvY2FsTm90aWZpY2F0aW9uU2VydmljZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGV4ZWN1dG9yKCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGluaXRpYWxpemF0aW9uUHJvbWlzZTtcbn1cblxuLyoqXG4gKiBKU0RPQyBTT1VSQ0Ugbm90aWZpY2F0aW9uU2VydmljZVxuICpcbiAqIFNlcnZpY2UgdGhhdCBzZW5kcyBub3RpZmljYXRpb25zIHRvIHVzZXJzIGluIHRoZSBVSVxuICovXG5leHBvcnQgY29uc3Qgbm90aWZpY2F0aW9uU2VydmljZSA9IGNyZWF0ZVN5bmNQcm94eUZvckFzeW5jT2JqZWN0PElOb3RpZmljYXRpb25TZXJ2aWNlPihhc3luYyAoKSA9PiB7XG4gIGF3YWl0IGluaXRpYWxpemUoKTtcbiAgcmV0dXJuIG5ldHdvcmtPYmplY3Q7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbm90aWZpY2F0aW9uU2VydmljZTtcbiIsImltcG9ydCB7XG4gIFByb2plY3RJbnRlcmZhY2VzLFxuICBQcm9qZWN0SW50ZXJmYWNlRGF0YVR5cGVzLFxuICBQcm9qZWN0RGF0YVByb3ZpZGVySW50ZXJmYWNlcyxcbn0gZnJvbSAncGFwaS1zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IHsgSVByb2plY3REYXRhUHJvdmlkZXJFbmdpbmUgfSBmcm9tICdAc2hhcmVkL21vZGVscy9wcm9qZWN0LWRhdGEtcHJvdmlkZXItZW5naW5lLm1vZGVsJztcbmltcG9ydCB7IG5ldHdvcmtPYmplY3RTZXJ2aWNlIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9uZXR3b3JrLW9iamVjdC5zZXJ2aWNlJztcbmltcG9ydCB7IGdldEJ5VHlwZSwgcmVnaXN0ZXJFbmdpbmVCeVR5cGUgfSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL2RhdGEtcHJvdmlkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBuZXdOb25jZSB9IGZyb20gJ0BzaGFyZWQvdXRpbHMvdXRpbCc7XG5pbXBvcnQge1xuICBEaXNwb3NlLFxuICBNdXRleE1hcCxcbiAgVW5pb25Ub0ludGVyc2VjdGlvbixcbiAgVW5zdWJzY3JpYmVyQXN5bmNMaXN0LFxufSBmcm9tICdwbGF0Zm9ybS1iaWJsZS11dGlscyc7XG5pbXBvcnQge1xuICBJUHJvamVjdERhdGFQcm92aWRlckZhY3RvcnksXG4gIFBEUF9GQUNUT1JZX09CSkVDVF9UWVBFLFxuICBQcm9qZWN0TWV0YWRhdGFGaWx0ZXJPcHRpb25zLFxufSBmcm9tICdAc2hhcmVkL21vZGVscy9wcm9qZWN0LWRhdGEtcHJvdmlkZXItZmFjdG9yeS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgcHJvamVjdExvb2t1cFNlcnZpY2UgfSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL3Byb2plY3QtbG9va3VwLnNlcnZpY2UnO1xuaW1wb3J0IHsgUHJvamVjdE1ldGFkYXRhV2l0aG91dEZhY3RvcnlJbmZvIH0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvcHJvamVjdC1tZXRhZGF0YS5tb2RlbCc7XG5pbXBvcnQgeyBQUk9KRUNUX0lOVEVSRkFDRV9QTEFURk9STV9CQVNFIH0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvcHJvamVjdC1kYXRhLXByb3ZpZGVyLm1vZGVsJztcbmltcG9ydCB7IGdldFBEUEZhY3RvcnlOZXR3b3JrT2JqZWN0TmFtZUZyb21JZCB9IGZyb20gJ0BzaGFyZWQvbW9kZWxzL3Byb2plY3QtbG9va3VwLnNlcnZpY2UtbW9kZWwnO1xuaW1wb3J0IHsgSVByb2plY3REYXRhUHJvdmlkZXJFbmdpbmVGYWN0b3J5IH0gZnJvbSAnQHNoYXJlZC9tb2RlbHMvcHJvamVjdC1kYXRhLXByb3ZpZGVyLWVuZ2luZS1mYWN0b3J5Lm1vZGVsJztcblxuLyoqXG4gKiBDbGFzcyB0aGF0IGNyZWF0ZXMgUHJvamVjdCBEYXRhIFByb3ZpZGVycyBvZiBhIHNwZWNpZmljIHNldCBvZiBgcHJvamVjdEludGVyZmFjZWBzLiBMYXllcnMgb3ZlclxuICogZXh0ZW5zaW9uLXByb3ZpZGVkIHtAbGluayBJUHJvamVjdERhdGFQcm92aWRlckVuZ2luZUZhY3Rvcnl9LiBJbnRlcm5hbCBvbmx5XG4gKi9cbmNsYXNzIFByb2plY3REYXRhUHJvdmlkZXJGYWN0b3J5PFN1cHBvcnRlZFByb2plY3RJbnRlcmZhY2VzIGV4dGVuZHMgUHJvamVjdEludGVyZmFjZXNbXT5cbiAgaW1wbGVtZW50cyBJUHJvamVjdERhdGFQcm92aWRlckZhY3RvcnlcbntcbiAgcHJpdmF0ZSByZWFkb25seSBwZHBJZHNNdXRleE1hcCA9IG5ldyBNdXRleE1hcCgpO1xuICBwcml2YXRlIHJlYWRvbmx5IHBkcElkczogTWFwPHN0cmluZywgc3RyaW5nPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBwZHBGYWN0b3J5SWQ6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBwcm9qZWN0SW50ZXJmYWNlczogU3VwcG9ydGVkUHJvamVjdEludGVyZmFjZXM7XG4gIHByaXZhdGUgcmVhZG9ubHkgcGRwQ2xlYW51cExpc3Q6IFVuc3Vic2NyaWJlckFzeW5jTGlzdDtcbiAgcHJpdmF0ZSByZWFkb25seSBwZHBFbmdpbmVGYWN0b3J5OiBJUHJvamVjdERhdGFQcm92aWRlckVuZ2luZUZhY3Rvcnk8U3VwcG9ydGVkUHJvamVjdEludGVyZmFjZXM+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUERQIGZhY3RvcnkgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSBQRFBzXG4gICAqXG4gICAqIEBwYXJhbSBwcm9qZWN0SW50ZXJmYWNlcyBBbGwgdGhlIGBwcm9qZWN0SW50ZXJmYWNlYHMgdGhpcyBQRFAgZmFjdG9yeSdzIFBEUHMgY2FuIHN1cHBvcnRcbiAgICogQHBhcmFtIHBkcEVuZ2luZUZhY3RvcnkgT2JqZWN0IHRoYXQgY2FuIGNyZWF0ZSB0aGUgZW5naW5lcyBmb3IgUERQc1xuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcGRwRmFjdG9yeUlkOiBzdHJpbmcsXG4gICAgcHJvamVjdEludGVyZmFjZXM6IFN1cHBvcnRlZFByb2plY3RJbnRlcmZhY2VzLFxuICAgIHBkcEVuZ2luZUZhY3Rvcnk6IElQcm9qZWN0RGF0YVByb3ZpZGVyRW5naW5lRmFjdG9yeTxTdXBwb3J0ZWRQcm9qZWN0SW50ZXJmYWNlcz4sXG4gICkge1xuICAgIHRoaXMucGRwRmFjdG9yeUlkID0gcGRwRmFjdG9yeUlkO1xuICAgIHRoaXMucHJvamVjdEludGVyZmFjZXMgPSBwcm9qZWN0SW50ZXJmYWNlcztcbiAgICB0aGlzLnBkcENsZWFudXBMaXN0ID0gbmV3IFVuc3Vic2NyaWJlckFzeW5jTGlzdChgUERQIEZhY3RvcnkgZm9yICR7cHJvamVjdEludGVyZmFjZXN9YCk7XG4gICAgdGhpcy5wZHBFbmdpbmVGYWN0b3J5ID0gcGRwRW5naW5lRmFjdG9yeTtcbiAgfVxuXG4gIGdldEF2YWlsYWJsZVByb2plY3RzKFxuICAgIGxheWVyaW5nRmlsdGVycz86IFByb2plY3RNZXRhZGF0YUZpbHRlck9wdGlvbnMsXG4gICk6IFByb21pc2U8UHJvamVjdE1ldGFkYXRhV2l0aG91dEZhY3RvcnlJbmZvW10+IHtcbiAgICByZXR1cm4gdGhpcy5wZHBFbmdpbmVGYWN0b3J5LmdldEF2YWlsYWJsZVByb2plY3RzKGxheWVyaW5nRmlsdGVycyk7XG4gIH1cblxuICAvKiogRGlzcG9zZXMgb2YgYWxsIFBEUHMgdGhhdCB3ZXJlIGNyZWF0ZWQgYnkgdGhpcyBQRFAgRmFjdG9yeSAqL1xuICBhc3luYyBkaXNwb3NlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRoaXMucGRwSWRzLmNsZWFyKCk7XG4gICAgcmV0dXJuIHRoaXMucGRwQ2xlYW51cExpc3QucnVuQWxsVW5zdWJzY3JpYmVycygpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIHJlZ2lzdGVyZWQgbmV0d29yayBvYmplY3QgbmFtZSBvZiBhIFBEUCBmb3IgdGhlIGdpdmVuIHByb2plY3QgSUQgKi9cbiAgYXN5bmMgZ2V0UHJvamVjdERhdGFQcm92aWRlcklkKHByb2plY3RJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBrZXkgPSBwcm9qZWN0SWQ7XG4gICAgLy8gRG9uJ3QgYWxsb3cgc2ltdWx0YW5lb3VzIGdldHMgdG8gcnVuIGZvciB0aGUgc2FtZSBwcm9qZWN0IGRhdGEgcHJvdmlkZXIgaWQgYXMgYW4gZWFzeSB3YXkgdG9cbiAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgY3JlYXRlIG11bHRpcGxlIG9mIHRoZSBzYW1lIFBEUFxuICAgIGNvbnN0IGxvY2sgPSB0aGlzLnBkcElkc011dGV4TWFwLmdldChrZXkpO1xuICAgIHJldHVybiBsb2NrLnJ1bkV4Y2x1c2l2ZShhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcGRwSWQgPSB0aGlzLnBkcElkcy5nZXQoa2V5KTtcbiAgICAgIGlmICghcGRwSWQpIHtcbiAgICAgICAgcGRwSWQgPSBhd2FpdCB0aGlzLnJlZ2lzdGVyUHJvamVjdERhdGFQcm92aWRlcihcbiAgICAgICAgICBhd2FpdCB0aGlzLnBkcEVuZ2luZUZhY3RvcnkuY3JlYXRlUHJvamVjdERhdGFQcm92aWRlckVuZ2luZShwcm9qZWN0SWQpLFxuICAgICAgICAgIHByb2plY3RJZCxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFwZHBJZCkgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmVnaXN0ZXIgcHJvamVjdCBkYXRhIHByb3ZpZGVyIGZvciAke3Byb2plY3RJZH1gKTtcbiAgICAgICAgdGhpcy5wZHBJZHMuc2V0KGtleSwgcGRwSWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBkcElkO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIENvbnZlcnQgdGhlIFBEUCBlbmdpbmUgaW50byBhIFBEUCB1c2luZyB0aGUgZGF0YSBwcm92aWRlciBzZXJ2aWNlICovXG4gIHByaXZhdGUgYXN5bmMgcmVnaXN0ZXJQcm9qZWN0RGF0YVByb3ZpZGVyKFxuICAgIHByb2plY3REYXRhUHJvdmlkZXJFbmdpbmU6IElQcm9qZWN0RGF0YVByb3ZpZGVyRW5naW5lPFN1cHBvcnRlZFByb2plY3RJbnRlcmZhY2VzPixcbiAgICBwcm9qZWN0SWQ6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAvLyBDaGVjayB0byBtYWtlIHN1cmUgbmV3IEJhc2UgUERQcyBmdWxmaWxsIHRoZSByZXF1aXJlbWVudHMgb2YgdGhlIGBwbGF0Zm9ybS5iYXNlYCBgcHJvamVjdEludGVyZmFjZWBcbiAgICBpZiAoXG4gICAgICB0aGlzLnByb2plY3RJbnRlcmZhY2VzLmluY2x1ZGVzKFBST0pFQ1RfSU5URVJGQUNFX1BMQVRGT1JNX0JBU0UpICYmXG4gICAgICAoISgnZ2V0RXh0ZW5zaW9uRGF0YScgaW4gcHJvamVjdERhdGFQcm92aWRlckVuZ2luZSkgfHxcbiAgICAgICAgISgnZ2V0U2V0dGluZycgaW4gcHJvamVjdERhdGFQcm92aWRlckVuZ2luZSkpXG4gICAgKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgXFxgQmFzZVByb2plY3REYXRhUHJvdmlkZXJFbmdpbmVcXGAgd2l0aCBwcm9qZWN0IGlkICR7cHJvamVjdElkfSBjcmVhdGVkIGJ5IFBEUCBGYWN0b3J5IHdpdGggaWQgJHt0aGlzLnBkcEZhY3RvcnlJZH0gbXVzdCBpbXBsZW1lbnQgXFxgJHtQUk9KRUNUX0lOVEVSRkFDRV9QTEFURk9STV9CQVNFfVxcYCBcXGBwcm9qZWN0SW50ZXJmYWNlXFxgLiBTZWUgXFxgSUJhc2VQcm9qZWN0RGF0YVByb3ZpZGVyXFxgIGZvciBtb3JlIGluZm9ybWF0aW9uYCxcbiAgICAgICk7XG4gICAgLy8gRU5IQU5DRU1FTlQ6IFJlLWFkZCBhIGNoZWNrIGZvciBuZXcgUERQcyB0byBtYWtlIHN1cmUgdGhlcmUgaXMgc29tZSBQRFAgc29tZXdoZXJlIHRoYXRcbiAgICAvLyBmdWxmaWxscyBgcGxhdGZvcm0uYmFzZWBcblxuICAgIGNvbnN0IHBkcElkOiBzdHJpbmcgPSBgJHtuZXdOb25jZSgpfS1wZHBgO1xuICAgIGNvbnN0IHBkcCA9IGF3YWl0IHJlZ2lzdGVyRW5naW5lQnlUeXBlPFxuICAgICAgVW5pb25Ub0ludGVyc2VjdGlvbjxQcm9qZWN0SW50ZXJmYWNlRGF0YVR5cGVzW1N1cHBvcnRlZFByb2plY3RJbnRlcmZhY2VzW251bWJlcl1dPiAmIHt9XG4gICAgPihwZHBJZCwgcHJvamVjdERhdGFQcm92aWRlckVuZ2luZSwgJ3BkcCcsIHtcbiAgICAgIHByb2plY3RJZCxcbiAgICAgIHByb2plY3RJbnRlcmZhY2VzOiB0aGlzLnByb2plY3RJbnRlcmZhY2VzLFxuICAgIH0pO1xuICAgIHRoaXMucGRwQ2xlYW51cExpc3QuYWRkKHBkcCk7XG4gICAgcmV0dXJuIHBkcElkO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IFByb2plY3QgRGF0YSBQcm92aWRlciBGYWN0b3J5IHRvIFBBUEkgdGhhdCB1c2VzIHRoZSBnaXZlbiBlbmdpbmUuXG4gKlxuICogQHBhcmFtIHBkcEZhY3RvcnlJZCBVbmlxdWUgaWQgZm9yIHRoaXMgUERQIGZhY3RvcnlcbiAqIEBwYXJhbSBwcm9qZWN0SW50ZXJmYWNlcyBUaGUgc3RhbmRhcmRpemVkIHNldHMgb2YgbWV0aG9kcyAoYHByb2plY3RJbnRlcmZhY2Vgcykgc3VwcG9ydGVkIGJ5IHRoZVxuICogICBQcm9qZWN0IERhdGEgUHJvdmlkZXIgRW5naW5lcyBwcm9kdWNlZCBieSB0aGlzIGZhY3RvcnkuIEluZGljYXRlcyB3aGF0IHNvcnQgb2YgcHJvamVjdCBkYXRhXG4gKiAgIHNob3VsZCBiZSBhdmFpbGFibGUgb24gdGhlIFBEUEVzIGNyZWF0ZWQgYnkgdGhpcyBmYWN0b3J5LlxuICogQHBhcmFtIHBkcEVuZ2luZUZhY3RvcnkgVXNlZCBpbiBhIFByb2plY3REYXRhUHJvdmlkZXJGYWN0b3J5IHRvIGNyZWF0ZSBQcm9qZWN0RGF0YVByb3ZpZGVyc1xuICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgZGlzcG9zYWJsZSBvYmplY3Qgd2hlbiB0aGUgcmVnaXN0cmF0aW9uIG9wZXJhdGlvbiBjb21wbGV0ZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZ2lzdGVyUHJvamVjdERhdGFQcm92aWRlckVuZ2luZUZhY3Rvcnk8XG4gIFN1cHBvcnRlZFByb2plY3RJbnRlcmZhY2VzIGV4dGVuZHMgUHJvamVjdEludGVyZmFjZXNbXSxcbj4oXG4gIHBkcEZhY3RvcnlJZDogc3RyaW5nLFxuICBwcm9qZWN0SW50ZXJmYWNlczogU3VwcG9ydGVkUHJvamVjdEludGVyZmFjZXMsXG4gIHBkcEVuZ2luZUZhY3Rvcnk6IElQcm9qZWN0RGF0YVByb3ZpZGVyRW5naW5lRmFjdG9yeTxTdXBwb3J0ZWRQcm9qZWN0SW50ZXJmYWNlcz4sXG4pOiBQcm9taXNlPERpc3Bvc2U+IHtcbiAgY29uc3QgZmFjdG9yeU5ldHdvcmtPYmplY3RJZCA9IGdldFBEUEZhY3RvcnlOZXR3b3JrT2JqZWN0TmFtZUZyb21JZChwZHBGYWN0b3J5SWQpO1xuICBjb25zdCBmYWN0b3J5ID0gbmV3IFByb2plY3REYXRhUHJvdmlkZXJGYWN0b3J5KHBkcEZhY3RvcnlJZCwgcHJvamVjdEludGVyZmFjZXMsIHBkcEVuZ2luZUZhY3RvcnkpO1xuICByZXR1cm4gbmV0d29ya09iamVjdFNlcnZpY2Uuc2V0PFByb2plY3REYXRhUHJvdmlkZXJGYWN0b3J5PFN1cHBvcnRlZFByb2plY3RJbnRlcmZhY2VzPj4oXG4gICAgZmFjdG9yeU5ldHdvcmtPYmplY3RJZCxcbiAgICBmYWN0b3J5LFxuICAgIFBEUF9GQUNUT1JZX09CSkVDVF9UWVBFLFxuICAgIHsgcHJvamVjdEludGVyZmFjZXMgfSxcbiAgKTtcbn1cblxuLyoqXG4gKiBHZXQgYSBQcm9qZWN0IERhdGEgUHJvdmlkZXIgZm9yIHRoZSBnaXZlbiBwcm9qZWN0IElELlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcGRwID0gYXdhaXQgZ2V0KCdwbGF0Zm9ybVNjcmlwdHVyZS5VU0ZNX1ZlcnNlJywgJ1Byb2plY3RJRDEyMzQ1Jyk7XG4gKiBwZHAuZ2V0VmVyc2VVU0ZNKHsgYm9vazogJ0pITicsIGNoYXB0ZXJOdW06IDEsIHZlcnNlTnVtOiAxIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHByb2plY3RJbnRlcmZhY2UgYHByb2plY3RJbnRlcmZhY2VgIHRoYXQgdGhlIHByb2plY3QgdG8gbG9hZCBtdXN0IHN1cHBvcnQuIFRoZSBUeXBlU2NyaXB0XG4gKiAgIHR5cGUgZm9yIHRoZSByZXR1cm5lZCBwcm9qZWN0IGRhdGEgcHJvdmlkZXIgd2lsbCBoYXZlIHRoZSBwcm9qZWN0IGRhdGEgcHJvdmlkZXIgaW50ZXJmYWNlIHR5cGVcbiAqICAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYHByb2plY3RJbnRlcmZhY2VgLiBJZiB0aGUgcHJvamVjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhpc1xuICogICBgcHJvamVjdEludGVyZmFjZWAgKGFjY29yZGluZyB0byBpdHMgbWV0YWRhdGEpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBwcm9qZWN0SWQgSUQgZm9yIHRoZSBwcm9qZWN0IHRvIGxvYWRcbiAqIEBwYXJhbSBwZHBGYWN0b3J5SWQgT3B0aW9uYWwgSUQgb2YgdGhlIFBEUCBmYWN0b3J5IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBwcm9qZWN0IGRhdGEgcHJvdmlkZXIgaWZcbiAqICAgdGhlIFBEUCBmYWN0b3J5IHN1cHBvcnRzIHRoaXMgcHJvamVjdCBpZCBhbmQgcHJvamVjdCBpbnRlcmZhY2UuIElmIG5vdCBwcm92aWRlZCwgdGhlbiBsb29rIGluXG4gKiAgIGFsbCBhdmFpbGFibGUgUERQIGZhY3RvcmllcyBmb3IgdGhlIGdpdmVuIHByb2plY3QgSUQuXG4gKiBAcmV0dXJucyBQcm9qZWN0IGRhdGEgcHJvdmlkZXIgd2l0aCB0eXBlcyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGBwcm9qZWN0SW50ZXJmYWNlYFxuICogQHRocm93cyBJZiBkaWQgbm90IGZpbmQgYSBwcm9qZWN0IGRhdGEgcHJvdmlkZXIgZm9yIHRoZSBwcm9qZWN0IGlkIHRoYXQgc3VwcG9ydHMgdGhlIHJlcXVlc3RlZFxuICogICBgcHJvamVjdEludGVyZmFjZWAgKGFuZCBmcm9tIHRoZSByZXF1ZXN0ZWQgUERQIGZhY3RvcnkgaWYgc3BlY2lmaWVkKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0PFByb2plY3RJbnRlcmZhY2UgZXh0ZW5kcyBQcm9qZWN0SW50ZXJmYWNlcz4oXG4gIHByb2plY3RJbnRlcmZhY2U6IFByb2plY3RJbnRlcmZhY2UsXG4gIHByb2plY3RJZDogc3RyaW5nLFxuICBwZHBGYWN0b3J5SWQ/OiBzdHJpbmcsXG4pOiBQcm9taXNlPFByb2plY3REYXRhUHJvdmlkZXJJbnRlcmZhY2VzW1Byb2plY3RJbnRlcmZhY2VdPiB7XG4gIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgcHJvamVjdExvb2t1cFNlcnZpY2UuZ2V0TWV0YWRhdGFGb3JQcm9qZWN0KFxuICAgIHByb2plY3RJZCxcbiAgICBwcm9qZWN0SW50ZXJmYWNlLFxuICAgIHBkcEZhY3RvcnlJZCxcbiAgKTtcblxuICBjb25zdCBtaW5pbWFsTWF0Y2hQZHBGYWN0b3J5SWQgPSBwcm9qZWN0TG9va3VwU2VydmljZS5nZXRNaW5pbWFsTWF0Y2hQZHBGYWN0b3J5SWQoXG4gICAgbWV0YWRhdGEsXG4gICAgcHJvamVjdEludGVyZmFjZSxcbiAgKTtcblxuICBpZiAoIW1pbmltYWxNYXRjaFBkcEZhY3RvcnlJZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgcGRwU2VydmljZS5nZXQoJHtwcm9qZWN0SW50ZXJmYWNlfSwgJHtwcm9qZWN0SWR9LCAke3BkcEZhY3RvcnlJZH0pOiBTb21laG93IHRoZXJlIHdhcyBhIHByb2plY3Qgd2l0aCB0aGUgaWQgYW5kIHByb3ZpZGVkIHByb2plY3RJbnRlcmZhY2UsIGJ1dCBjb3VsZCBub3QgZmluZCBhIFBEUEYgdGhhdCBwcm92aWRlZCB0aGUgcHJvamVjdEludGVyZmFjZS4gVGhpcyBzaG91bGQgbm90IGhhcHBlbi5gLFxuICAgICk7XG5cbiAgY29uc3QgcGRwRmFjdG9yeSA9IGF3YWl0IG5ldHdvcmtPYmplY3RTZXJ2aWNlLmdldDxQcm9qZWN0RGF0YVByb3ZpZGVyRmFjdG9yeTxbUHJvamVjdEludGVyZmFjZV0+PihcbiAgICBnZXRQRFBGYWN0b3J5TmV0d29ya09iamVjdE5hbWVGcm9tSWQobWluaW1hbE1hdGNoUGRwRmFjdG9yeUlkKSxcbiAgKTtcbiAgaWYgKCFwZHBGYWN0b3J5KVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBwZHBTZXJ2aWNlLmdldCgke3Byb2plY3RJbnRlcmZhY2V9LCAke3Byb2plY3RJZH0sICR7cGRwRmFjdG9yeUlkfSk6IENhbm5vdCBnZXQgcHJvamVjdCBkYXRhIHByb3ZpZGVycyB3aXRoIHByb2plY3RJbnRlcmZhY2UgJHtwcm9qZWN0SW50ZXJmYWNlfTogQ291bGQgbm90IGdldCBwZHBmIHdpdGggaWQgJHttaW5pbWFsTWF0Y2hQZHBGYWN0b3J5SWR9YCxcbiAgICApO1xuXG4gIGNvbnN0IHBkcElkID0gYXdhaXQgcGRwRmFjdG9yeS5nZXRQcm9qZWN0RGF0YVByb3ZpZGVySWQocHJvamVjdElkKTtcbiAgY29uc3QgcGRwID0gYXdhaXQgZ2V0QnlUeXBlPFByb2plY3REYXRhUHJvdmlkZXJJbnRlcmZhY2VzW1Byb2plY3RJbnRlcmZhY2VdPihwZHBJZCk7XG4gIGlmICghcGRwKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBwZHBTZXJ2aWNlLmdldCgke3Byb2plY3RJbnRlcmZhY2V9LCAke3Byb2plY3RJZH0sICR7cGRwRmFjdG9yeUlkfSk6IENhbm5vdCBnZXQgcHJvamVjdCBkYXRhIHByb3ZpZGVyIGZvciBwcm9qZWN0IElEICR7cHJvamVjdElkfWAsXG4gICAgKTtcbiAgcmV0dXJuIHBkcDtcbn1cblxuLy8gRGVjbGFyZSBhbiBpbnRlcmZhY2UgZm9yIHRoZSBvYmplY3Qgd2UncmUgZXhwb3J0aW5nIHNvIHRoYXQgSlNEb2MgY29tbWVudHMgcHJvcGFnYXRlXG5leHBvcnQgaW50ZXJmYWNlIFBhcGlCYWNrZW5kUHJvamVjdERhdGFQcm92aWRlclNlcnZpY2Uge1xuICByZWdpc3RlclByb2plY3REYXRhUHJvdmlkZXJFbmdpbmVGYWN0b3J5OiB0eXBlb2YgcmVnaXN0ZXJQcm9qZWN0RGF0YVByb3ZpZGVyRW5naW5lRmFjdG9yeTtcbiAgZ2V0OiB0eXBlb2YgZ2V0O1xufVxuXG4vKipcbiAqIEpTRE9DIFNPVVJDRSBwYXBpQmFja2VuZFByb2plY3REYXRhUHJvdmlkZXJTZXJ2aWNlXG4gKlxuICogU2VydmljZSB0aGF0IHJlZ2lzdGVycyBhbmQgZ2V0cyBwcm9qZWN0IGRhdGEgcHJvdmlkZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBwYXBpQmFja2VuZFByb2plY3REYXRhUHJvdmlkZXJTZXJ2aWNlOiBQYXBpQmFja2VuZFByb2plY3REYXRhUHJvdmlkZXJTZXJ2aWNlID0ge1xuICByZWdpc3RlclByb2plY3REYXRhUHJvdmlkZXJFbmdpbmVGYWN0b3J5LFxuICBnZXQsXG59O1xuXG4vLyBEZWNsYXJlIGFuIGludGVyZmFjZSBmb3IgdGhlIG9iamVjdCB3ZSdyZSBleHBvcnRpbmcgc28gdGhhdCBKU0RvYyBjb21tZW50cyBwcm9wYWdhdGVcbmV4cG9ydCBpbnRlcmZhY2UgUGFwaUZyb250ZW5kUHJvamVjdERhdGFQcm92aWRlclNlcnZpY2Uge1xuICBnZXQ6IHR5cGVvZiBnZXQ7XG59XG5cbi8qKlxuICogSlNET0MgU09VUkNFIHBhcGlGcm9udGVuZFByb2plY3REYXRhUHJvdmlkZXJTZXJ2aWNlXG4gKlxuICogU2VydmljZSB0aGF0IGdldHMgcHJvamVjdCBkYXRhIHByb3ZpZGVyc1xuICovXG5leHBvcnQgY29uc3QgcGFwaUZyb250ZW5kUHJvamVjdERhdGFQcm92aWRlclNlcnZpY2UgPSB7XG4gIGdldCxcbn07XG4iLCJpbXBvcnQgeyBwcm9qZWN0TG9va3VwU2VydmljZUJhc2UgfSBmcm9tICdAc2hhcmVkL21vZGVscy9wcm9qZWN0LWxvb2t1cC5zZXJ2aWNlLW1vZGVsJztcblxuZXhwb3J0IGNvbnN0IHByb2plY3RMb29rdXBTZXJ2aWNlID0gcHJvamVjdExvb2t1cFNlcnZpY2VCYXNlO1xuXG5leHBvcnQgZGVmYXVsdCBwcm9qZWN0TG9va3VwU2VydmljZTtcbiIsImltcG9ydCB7IGlzQ2xpZW50IH0gZnJvbSAnQHNoYXJlZC91dGlscy9pbnRlcm5hbC11dGlsJztcbmltcG9ydCB7IElScGNNZXRob2RSZWdpc3RyYXIgfSBmcm9tICdAc2hhcmVkL21vZGVscy9ycGMuaW50ZXJmYWNlJztcblxuLyoqIENyZWF0ZXMgYSBzZXJ2ZXIgb3IgY2xpZW50IFJQQyBoYW5kbGVyIGRlcGVuZGluZyBvbiBpZiB3ZSdyZSBpbiBtYWluIG9yIHNvbWUgb3RoZXIgcHJvY2VzcyAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJwY0hhbmRsZXIgPSBhc3luYyAoKTogUHJvbWlzZTxJUnBjTWV0aG9kUmVnaXN0cmFyPiA9PiB7XG4gIGlmIChpc0NsaWVudCgpKSB7XG4gICAgY29uc3QgUnBjQ2xpZW50ID0gKGF3YWl0IGltcG9ydCgnQGNsaWVudC9zZXJ2aWNlcy9ycGMtY2xpZW50JykpLmRlZmF1bHQ7XG4gICAgcmV0dXJuIG5ldyBScGNDbGllbnQoKTtcbiAgfVxuICBjb25zdCBScGNXZWJTb2NrZXRMaXN0ZW5lciA9IChhd2FpdCBpbXBvcnQoJ0BtYWluL3NlcnZpY2VzL3JwYy13ZWJzb2NrZXQtbGlzdGVuZXInKSkuZGVmYXVsdDtcbiAgcmV0dXJuIG5ldyBScGNXZWJTb2NrZXRMaXN0ZW5lcigpO1xufTtcbiIsImltcG9ydCAqIGFzIG5ldHdvcmtTZXJ2aWNlIGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbmV0d29yay5zZXJ2aWNlJztcbmltcG9ydCB7IFNldHRpbmdOYW1lcywgU2V0dGluZ1R5cGVzIH0gZnJvbSAncGFwaS1zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IHsgT25EaWREaXNwb3NlLCBVbnN1YnNjcmliZXJBc3luYyB9IGZyb20gJ3BsYXRmb3JtLWJpYmxlLXV0aWxzJztcbmltcG9ydCB7IHNlcmlhbGl6ZVJlcXVlc3RUeXBlIH0gZnJvbSAnQHNoYXJlZC91dGlscy91dGlsJztcbmltcG9ydCB7IElEYXRhUHJvdmlkZXIgfSBmcm9tICdAc2hhcmVkL21vZGVscy9kYXRhLXByb3ZpZGVyLmludGVyZmFjZSc7XG5pbXBvcnQge1xuICBEYXRhUHJvdmlkZXJTdWJzY3JpYmVyT3B0aW9ucyxcbiAgRGF0YVByb3ZpZGVyVXBkYXRlSW5zdHJ1Y3Rpb25zLFxufSBmcm9tICdAc2hhcmVkL21vZGVscy9kYXRhLXByb3ZpZGVyLm1vZGVsJztcbmltcG9ydCB7IExvY2FsaXplZFNldHRpbmdzQ29udHJpYnV0aW9uSW5mbyB9IGZyb20gJ0BzaGFyZWQvdXRpbHMvc2V0dGluZ3MtZG9jdW1lbnQtY29tYmluZXItYmFzZSc7XG5cbi8qKiBOYW1lIHByZWZpeCBmb3IgcmVnaXN0ZXJlZCBjb21tYW5kcyB0aGF0IGNhbGwgc2V0dGluZ3MgdmFsaWRhdG9ycyAqL1xuZXhwb3J0IGNvbnN0IENBVEVHT1JZX0VYVEVOU0lPTl9TRVRUSU5HX1ZBTElEQVRPUiA9ICdleHRlbnNpb25TZXR0aW5nVmFsaWRhdG9yJztcblxuLyoqIEpTRE9DIERFU1RJTkFUSU9OIHNldHRpbmdzU2VydmljZURhdGFQcm92aWRlck5hbWUgKi9cbmV4cG9ydCBjb25zdCBzZXR0aW5nc1NlcnZpY2VEYXRhUHJvdmlkZXJOYW1lID0gJ3BsYXRmb3JtLnNldHRpbmdzU2VydmljZURhdGFQcm92aWRlcic7XG5leHBvcnQgY29uc3Qgc2V0dGluZ3NTZXJ2aWNlT2JqZWN0VG9Qcm94eSA9IE9iamVjdC5mcmVlemUoe1xuICAvKipcbiAgICogSlNET0MgU09VUkNFIHNldHRpbmdzU2VydmljZURhdGFQcm92aWRlck5hbWVcbiAgICpcbiAgICogVGhpcyBuYW1lIGlzIHVzZWQgdG8gcmVnaXN0ZXIgdGhlIHNldHRpbmdzIHNlcnZpY2UgZGF0YSBwcm92aWRlciBvbiB0aGUgcGFwaS4gWW91IGNhbiB1c2UgdGhpc1xuICAgKiBuYW1lIHRvIGZpbmQgdGhlIGRhdGEgcHJvdmlkZXIgd2hlbiBhY2Nlc3NpbmcgaXQgdXNpbmcgdGhlIHVzZURhdGEgaG9va1xuICAgKi9cbiAgZGF0YVByb3ZpZGVyTmFtZTogc2V0dGluZ3NTZXJ2aWNlRGF0YVByb3ZpZGVyTmFtZSxcblxuICAvKipcbiAgICogSlNET0MgU09VUkNFIHNldHRpbmdzU2VydmljZVJlZ2lzdGVyVmFsaWRhdG9yXG4gICAqXG4gICAqIFJlZ2lzdGVycyBhIGZ1bmN0aW9uIHRoYXQgdmFsaWRhdGVzIHdoZXRoZXIgYSBuZXcgc2V0dGluZyB2YWx1ZSBpcyBhbGxvd2VkIHRvIGJlIHNldC5cbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUgc3RyaW5nIGlkIG9mIHRoZSBzZXR0aW5nIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSB2YWxpZGF0b3IgRnVuY3Rpb24gdG8gY2FsbCB0byB2YWxpZGF0ZSB0aGUgbmV3IHNldHRpbmcgdmFsdWVcbiAgICogQHJldHVybnMgVW5zdWJzY3JpYmVyIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgcHJvdmlkaW5nIGV4dGVuc2lvbiBpcyBkZWFjdGl2YXRlZFxuICAgKi9cbiAgcmVnaXN0ZXJWYWxpZGF0b3I6IGFzeW5jIDxTZXR0aW5nTmFtZSBleHRlbmRzIFNldHRpbmdOYW1lcz4oXG4gICAga2V5OiBTZXR0aW5nTmFtZSxcbiAgICB2YWxpZGF0b3I6IFNldHRpbmdWYWxpZGF0b3I8U2V0dGluZ05hbWU+LFxuICApOiBQcm9taXNlPFVuc3Vic2NyaWJlckFzeW5jPiA9PiB7XG4gICAgcmV0dXJuIG5ldHdvcmtTZXJ2aWNlLnJlZ2lzdGVyUmVxdWVzdEhhbmRsZXIoXG4gICAgICBzZXJpYWxpemVSZXF1ZXN0VHlwZShDQVRFR09SWV9FWFRFTlNJT05fU0VUVElOR19WQUxJREFUT1IsIGtleSksXG4gICAgICB2YWxpZGF0b3IsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDoge1xuICAgICAgICAgIHN1bW1hcnk6IGBWYWxpZGF0ZSB3aGV0aGVyIGEgZ2l2ZW4gdmFsdWUgaXMgYWxsb3dlZCBmb3Igc2V0dGluZyBcIiR7a2V5fVwiYCxcbiAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogJ25ld1ZhbHVlJyxcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHN1bW1hcnk6ICdUaGUgbmV3IHZhbHVlIHRvIHZhbGlkYXRlJyxcbiAgICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgb25lT2Y6IFtcbiAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ29iamVjdCcgfSxcbiAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ2Jvb2xlYW4nIH0sXG4gICAgICAgICAgICAgICAgICB7IHR5cGU6ICdhcnJheScgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogJ2N1cnJlbnRWYWx1ZScsXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICBzdW1tYXJ5OiAnVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHNldHRpbmcnLFxuICAgICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICBvbmVPZjogW1xuICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnb2JqZWN0JyB9LFxuICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnYm9vbGVhbicgfSxcbiAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ2FycmF5JyB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiAnYWxsQ2hhbmdlcycsXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICBzdW1tYXJ5OiAnQWxsIGNoYW5nZXMgdG8gdGhlIHNldHRpbmdzJyxcbiAgICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgb25lT2Y6IFtcbiAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ29iamVjdCcgfSxcbiAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ2Jvb2xlYW4nIH0sXG4gICAgICAgICAgICAgICAgICB7IHR5cGU6ICdhcnJheScgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgbmFtZTogJ3JldHVybiB2YWx1ZScsXG4gICAgICAgICAgICBzdW1tYXJ5OiAnV2hldGhlciB0aGUgbmV3IHNldHRpbmcgdmFsdWUgaXMgdmFsaWQnLFxuICAgICAgICAgICAgc2NoZW1hOiB7IHR5cGU6ICdib29sZWFuJyB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICk7XG4gIH0sXG59KTtcbi8qKlxuICogU2V0dGluZ0RhdGFUeXBlcyBoYW5kbGVzIGdldHRpbmcgYW5kIHNldHRpbmcgUGxhdGZvcm0uQmlibGUgY29yZSBhcHBsaWNhdGlvbiBhbmQgZXh0ZW5zaW9uXG4gKiBzZXR0aW5ncy5cbiAqXG4gKiBOb3RlOiB0aGUgdW5uYW1lZCAoYCcnYCkgZGF0YSB0eXBlIGlzIG5vdCBhY3R1YWxseSBwYXJ0IG9mIGBTZXR0aW5nRGF0YVR5cGVzYCBiZWNhdXNlIHRoZSBtZXRob2RzXG4gKiB3b3VsZCBub3QgYmUgYWJsZSB0byBjcmVhdGUgYSBnZW5lcmljIHR5cGUgZXh0ZW5kaW5nIGZyb20gYFNldHRpbmdOYW1lc2AgaW4gb3JkZXIgdG8gcmV0dXJuIHRoZVxuICogc3BlY2lmaWMgc2V0dGluZyB0eXBlIGJlaW5nIHJlcXVlc3RlZC4gQXMgc3VjaCwgYGdldGAsIGBzZXRgLCBgcmVzZXRgIGFuZCBgc3Vic2NyaWJlYCBhcmUgYWxsXG4gKiBzcGVjaWZpZWQgb24ge0BsaW5rIElTZXR0aW5nc1NlcnZpY2V9IGluc3RlYWQuIFVuZm9ydHVuYXRlbHksIGFzIGEgcmVzdWx0LCB1c2luZyBJbnRlbGxpc2Vuc2Ugd2l0aFxuICogYHVzZURhdGFgIHdpbGwgbm90IHNob3cgdGhlIHVubmFtZWQgZGF0YSB0eXBlIChgJydgKSBhcyBhbiBvcHRpb24sIGJ1dCB5b3UgY2FuIHVzZSBgdXNlU2V0dGluZ2BcbiAqIGluc3RlYWQuIEhvd2V2ZXIsIGRvIG5vdGUgdGhhdCB0aGUgdW5uYW1lZCBkYXRhIHR5cGUgKGAnJ2ApIGlzIGZ1bGx5IGZ1bmN0aW9uYWwuXG4gKlxuICogVGhlIGNsb3Nlc3QgcG9zc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVubmFtZWQgKGBgYGApIGRhdGEgdHlwZSBmb2xsb3dzOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICcnOiBEYXRhUHJvdmlkZXJEYXRhVHlwZTxTZXR0aW5nTmFtZSwgU2V0dGluZ1R5cGVzW1NldHRpbmdOYW1lXSwgU2V0dGluZ1R5cGVzW1NldHRpbmdOYW1lXT47XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHR5cGUgU2V0dGluZ0RhdGFUeXBlcyA9IHt9O1xuXG5leHBvcnQgdHlwZSBBbGxTZXR0aW5nc0RhdGEgPSB7XG4gIFtTZXR0aW5nTmFtZSBpbiBTZXR0aW5nTmFtZXNdOiBTZXR0aW5nVHlwZXNbU2V0dGluZ05hbWVdO1xufTtcblxuLyoqIEZ1bmN0aW9uIHRoYXQgdmFsaWRhdGVzIHdoZXRoZXIgYSBuZXcgc2V0dGluZyB2YWx1ZSBzaG91bGQgYmUgYWxsb3dlZCB0byBiZSBzZXQgKi9cbmV4cG9ydCB0eXBlIFNldHRpbmdWYWxpZGF0b3I8U2V0dGluZ05hbWUgZXh0ZW5kcyBTZXR0aW5nTmFtZXM+ID0gKFxuICBuZXdWYWx1ZTogU2V0dGluZ1R5cGVzW1NldHRpbmdOYW1lXSxcbiAgY3VycmVudFZhbHVlOiBTZXR0aW5nVHlwZXNbU2V0dGluZ05hbWVdLFxuICBhbGxDaGFuZ2VzOiBQYXJ0aWFsPFNldHRpbmdUeXBlcz4sXG4pID0+IFByb21pc2U8Ym9vbGVhbj47XG5cbi8qKiBWYWxpZGF0b3JzIGZvciBhbGwgc2V0dGluZ3MuIEtleXMgYXJlIHNldHRpbmcga2V5cywgdmFsdWVzIGFyZSBmdW5jdGlvbnMgdG8gdmFsaWRhdGUgbmV3IHNldHRpbmdzICovXG5leHBvcnQgdHlwZSBBbGxTZXR0aW5nc1ZhbGlkYXRvcnMgPSB7XG4gIFtTZXR0aW5nTmFtZSBpbiBTZXR0aW5nTmFtZXNdOiBTZXR0aW5nVmFsaWRhdG9yPFNldHRpbmdOYW1lPjtcbn07XG5cbmRlY2xhcmUgbW9kdWxlICdwYXBpLXNoYXJlZC10eXBlcycge1xuICBleHBvcnQgaW50ZXJmYWNlIERhdGFQcm92aWRlcnMge1xuICAgIFtzZXR0aW5nc1NlcnZpY2VEYXRhUHJvdmlkZXJOYW1lXTogSVNldHRpbmdzU2VydmljZTtcbiAgfVxufVxuXG4vKiogSlNET0MgU09VUkNFIHNldHRpbmdzU2VydmljZSAqL1xuZXhwb3J0IHR5cGUgSVNldHRpbmdzU2VydmljZSA9IHtcbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBzZXR0aW5nXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIHN0cmluZyBpZCBvZiB0aGUgc2V0dGluZyBmb3Igd2hpY2ggdGhlIHZhbHVlIGlzIGJlaW5nIHJldHJpZXZlZFxuICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBzZXR0aW5nLCBwYXJzZWQgdG8gYW4gb2JqZWN0LiBSZXR1cm5zIGRlZmF1bHQgc2V0dGluZyBpZlxuICAgKiAgIHNldHRpbmcgZG9lcyBub3QgZXhpc3RcbiAgICogQHRocm93cyBJZiBubyBkZWZhdWx0IHZhbHVlIGlzIGF2YWlsYWJsZSBmb3IgdGhlIHNldHRpbmcuXG4gICAqL1xuICBnZXQ8U2V0dGluZ05hbWUgZXh0ZW5kcyBTZXR0aW5nTmFtZXM+KGtleTogU2V0dGluZ05hbWUpOiBQcm9taXNlPFNldHRpbmdUeXBlc1tTZXR0aW5nTmFtZV0+O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIHNldHRpbmcgYXQgdGhlIGdpdmVuIGtleSB3aXRoIHRoZSBuZXcgdmFsdWUgcHJvdmlkZWRcbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUgc3RyaW5nIGlkIG9mIHRoZSBzZXR0aW5nIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSBuZXdWYWx1ZSBUaGUgdmFsdWUgdG8gdmFsaWRhdGVcbiAgICogQHBhcmFtIGN1cnJlbnRWYWx1ZSBUaGUgdmFsdWUgYWxyZWFkeSBzZXQgdG8gdGhlIHNldHRpbmdcbiAgICogQHBhcmFtIGFsbENoYW5nZXNcbiAgICovXG4gIHZhbGlkYXRlU2V0dGluZzxTZXR0aW5nTmFtZSBleHRlbmRzIFNldHRpbmdOYW1lcz4oXG4gICAga2V5OiBTZXR0aW5nTmFtZSxcbiAgICBuZXdWYWx1ZTogU2V0dGluZ1R5cGVzW1NldHRpbmdOYW1lXSxcbiAgICBjdXJyZW50VmFsdWU6IFNldHRpbmdUeXBlc1tTZXR0aW5nTmFtZV0sXG4gICAgYWxsQ2hhbmdlcz86IFBhcnRpYWw8U2V0dGluZ1R5cGVzPixcbiAgKTogUHJvbWlzZTxib29sZWFuPjtcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBzZXR0aW5nXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIHN0cmluZyBpZCBvZiB0aGUgc2V0dGluZyBmb3Igd2hpY2ggdGhlIHZhbHVlIGlzIGJlaW5nIHNldFxuICAgKiBAcGFyYW0gbmV3U2V0dGluZyBUaGUgdmFsdWUgdGhhdCBpcyB0byBiZSBzZXQgZm9yIHRoZSBzcGVjaWZpZWQga2V5XG4gICAqIEByZXR1cm5zIEluZm9ybWF0aW9uIHRoYXQgcGFwaSB1c2VzIHRvIGludGVycHJldCB3aGV0aGVyIHRvIHNlbmQgb3V0IHVwZGF0ZXMuIERlZmF1bHRzIHRvXG4gICAqICAgYHRydWVgIChtZWFuaW5nIHNlbmQgdXBkYXRlcyBvbmx5IGZvciB0aGlzIGRhdGEgdHlwZSkuXG4gICAqIEBzZWUge0BsaW5rIERhdGFQcm92aWRlclVwZGF0ZUluc3RydWN0aW9uc30gZm9yIG1vcmUgaW5mbyBvbiB3aGF0IHRvIHJldHVyblxuICAgKi9cbiAgc2V0PFNldHRpbmdOYW1lIGV4dGVuZHMgU2V0dGluZ05hbWVzPihcbiAgICBrZXk6IFNldHRpbmdOYW1lLFxuICAgIG5ld1NldHRpbmc6IFNldHRpbmdUeXBlc1tTZXR0aW5nTmFtZV0sXG4gICk6IFByb21pc2U8RGF0YVByb3ZpZGVyVXBkYXRlSW5zdHJ1Y3Rpb25zPFNldHRpbmdEYXRhVHlwZXM+PjtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc2V0dGluZyBmcm9tIG1lbW9yeSBhbmQgcmVzZXRzIGl0IHRvIGl0cyBkZWZhdWx0IHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIHN0cmluZyBpZCBvZiB0aGUgc2V0dGluZyBmb3Igd2hpY2ggdGhlIHZhbHVlIGlzIGJlaW5nIHJlbW92ZWRcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHN1Y2Nlc3NmdWxseSByZXNldCB0aGUgcHJvamVjdCBzZXR0aW5nLiBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgcmVzZXQ8U2V0dGluZ05hbWUgZXh0ZW5kcyBTZXR0aW5nTmFtZXM+KGtleTogU2V0dGluZ05hbWUpOiBQcm9taXNlPGJvb2xlYW4+O1xuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIHRvIHVwZGF0ZXMgb2YgdGhlIHNwZWNpZmllZCBzZXR0aW5nLiBXaGVuZXZlciB0aGUgdmFsdWUgb2YgdGhlIHNldHRpbmcgY2hhbmdlcywgdGhlXG4gICAqIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBzdHJpbmcgaWQgb2YgdGhlIHNldHRpbmcgZm9yIHdoaWNoIHRoZSB2YWx1ZSBpcyBiZWluZyBzdWJzY3JpYmVkIHRvXG4gICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc3BlY2lmaWVkIHNldHRpbmcgaXMgdXBkYXRlZFxuICAgKiBAcGFyYW0gb3B0aW9ucyBWYXJpb3VzIG9wdGlvbnMgdG8gYWRqdXN0IGhvdyB0aGUgc3Vic2NyaWJlciBlbWl0cyB1cGRhdGVzXG4gICAqIEByZXR1cm5zIFVuc3Vic2NyaWJlciB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHN1YnNjcmlwdGlvbiBzaG91bGQgYmUgZGVsZXRlZFxuICAgKi9cbiAgc3Vic2NyaWJlPFNldHRpbmdOYW1lIGV4dGVuZHMgU2V0dGluZ05hbWVzPihcbiAgICBrZXk6IFNldHRpbmdOYW1lLFxuICAgIGNhbGxiYWNrOiAobmV3U2V0dGluZzogU2V0dGluZ1R5cGVzW1NldHRpbmdOYW1lXSkgPT4gdm9pZCxcbiAgICBvcHRpb25zPzogRGF0YVByb3ZpZGVyU3Vic2NyaWJlck9wdGlvbnMsXG4gICk6IFByb21pc2U8VW5zdWJzY3JpYmVyQXN5bmM+O1xuXG4gIC8qKiBKU0RPQyBERVNUSU5BVElPTiBzZXR0aW5nc1NlcnZpY2VSZWdpc3RlclZhbGlkYXRvciAqL1xuICByZWdpc3RlclZhbGlkYXRvcjxTZXR0aW5nTmFtZSBleHRlbmRzIFNldHRpbmdOYW1lcz4oXG4gICAga2V5OiBTZXR0aW5nTmFtZSxcbiAgICB2YWxpZGF0b3I6IFNldHRpbmdWYWxpZGF0b3I8U2V0dGluZ05hbWU+LFxuICApOiBQcm9taXNlPFVuc3Vic2NyaWJlckFzeW5jPjtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHNldCBvZiBzZXR0aW5ncyBjb250cmlidXRpb24gaW5mbyBnaXZlbiBhbGwgdGhlIGlucHV0IGRvY3VtZW50cyB3aXRoIGFsbFxuICAgKiBsb2NhbGl6ZWQgc3RyaW5nIGtleXMgbG9jYWxpemVkIHByb3Blcmx5LlxuICAgKlxuICAgKiBAcmV0dXJucyBMb2NhbGl6ZWQgcHJvamVjdCBzZXR0aW5ncyBjb250cmlidXRpb24gaW5mbyBvciB1bmRlZmluZWRcbiAgICovXG4gIGdldExvY2FsaXplZFNldHRpbmdzQ29udHJpYnV0aW9uSW5mbygpOiBQcm9taXNlPExvY2FsaXplZFNldHRpbmdzQ29udHJpYnV0aW9uSW5mbyB8IHVuZGVmaW5lZD47XG59ICYgT25EaWREaXNwb3NlICZcbiAgSURhdGFQcm92aWRlcjxTZXR0aW5nRGF0YVR5cGVzPiAmXG4gIHR5cGVvZiBzZXR0aW5nc1NlcnZpY2VPYmplY3RUb1Byb3h5O1xuIiwiaW1wb3J0ICogYXMgbmV0d29ya1NlcnZpY2UgZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9uZXR3b3JrLnNlcnZpY2UnO1xuaW1wb3J0IHsgY3JlYXRlU3luY1Byb3h5Rm9yQXN5bmNPYmplY3QgfSBmcm9tICdwbGF0Zm9ybS1iaWJsZS11dGlscyc7XG5pbXBvcnQgeyBkYXRhUHJvdmlkZXJTZXJ2aWNlIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9kYXRhLXByb3ZpZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHtcbiAgSVNldHRpbmdzU2VydmljZSxcbiAgc2V0dGluZ3NTZXJ2aWNlRGF0YVByb3ZpZGVyTmFtZSxcbiAgc2V0dGluZ3NTZXJ2aWNlT2JqZWN0VG9Qcm94eSxcbn0gZnJvbSAnLi9zZXR0aW5ncy5zZXJ2aWNlLW1vZGVsJztcblxubGV0IGRhdGFQcm92aWRlcjogSVNldHRpbmdzU2VydmljZTtcbmxldCBpbml0aWFsaXphdGlvblByb21pc2U6IFByb21pc2U8dm9pZD47XG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICBpZiAoIWluaXRpYWxpemF0aW9uUHJvbWlzZSkge1xuICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGV4ZWN1dG9yID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZGF0YVByb3ZpZGVyU2VydmljZS5nZXQoc2V0dGluZ3NTZXJ2aWNlRGF0YVByb3ZpZGVyTmFtZSk7XG4gICAgICAgICAgaWYgKCFwcm92aWRlcikgdGhyb3cgbmV3IEVycm9yKCdTZXR0aW5ncyBzZXJ2aWNlIHVuZGVmaW5lZCcpO1xuICAgICAgICAgIGRhdGFQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgIC8vIEluamVjdCB0aGUgbmV0d29yayB0aW1lb3V0IGludG8gZXZlcnkgSlMgcHJvY2VzcyBvbmNlIHRoZSBzZXR0aW5ncyBzZXJ2aWNlIGlzIGF2YWlsYWJsZVxuICAgICAgICAgIC8vIFdlIGNhbid0IHB1bGwgZnJvbSB3aXRoaW4gdGhlIG5ldHdvcmsgc2VydmljZSBhcyBpdCB3b3VsZCBjcmVhdGUgYSBkZXBlbmRlbmN5IGxvb3BcbiAgICAgICAgICBkYXRhUHJvdmlkZXIuc3Vic2NyaWJlKCdwbGF0Zm9ybS5yZXF1ZXN0VGltZW91dCcsIChuZXdUaW1lb3V0OiBudW1iZXIpID0+XG4gICAgICAgICAgICBuZXR3b3JrU2VydmljZS5zZXRSZXF1ZXN0VGltZW91dChuZXdUaW1lb3V0KSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXhlY3V0b3IoKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xufVxuXG5leHBvcnQgY29uc3Qgc2V0dGluZ3NTZXJ2aWNlID0gY3JlYXRlU3luY1Byb3h5Rm9yQXN5bmNPYmplY3Q8SVNldHRpbmdzU2VydmljZT4oYXN5bmMgKCkgPT4ge1xuICBhd2FpdCBpbml0aWFsaXplKCk7XG4gIHJldHVybiBkYXRhUHJvdmlkZXI7XG59LCBzZXR0aW5nc1NlcnZpY2VPYmplY3RUb1Byb3h5KTtcblxuZXhwb3J0IGRlZmF1bHQgc2V0dGluZ3NTZXJ2aWNlO1xuIiwiLyoqIFV0aWxpdHkgZnVuY3Rpb25zIHNwZWNpZmljIHRvIHRoZSBpbnRlcm5hbCB0ZWNobm9sb2dpZXMgd2UgYXJlIHVzaW5nLiAqL1xuXG5pbXBvcnQgeyBQcm9jZXNzVHlwZSB9IGZyb20gJ0BzaGFyZWQvZ2xvYmFsLXRoaXMubW9kZWwnO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBydW5uaW5nIG9uIGEgY2xpZW50IHByb2Nlc3MgKHJlbmRlcmVyLCBleHRlbnNpb24taG9zdCkgb3Igb24gdGhlIHNlcnZlci5cbiAqXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgcnVubmluZyBvbiBhIGNsaWVudCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBjb25zdCBpc0NsaWVudCA9ICgpID0+IGdsb2JhbFRoaXMucHJvY2Vzc1R5cGUgIT09IFByb2Nlc3NUeXBlLk1haW47XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHJ1bm5pbmcgb24gdGhlIHNlcnZlciBwcm9jZXNzIChtYWluKVxuICpcbiAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiBydW5uaW5nIG9uIHRoZSBzZXJ2ZXIsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgY29uc3QgaXNTZXJ2ZXIgPSAoKSA9PiAhaXNDbGllbnQoKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgcnVubmluZyBvbiB0aGUgcmVuZGVyZXIgcHJvY2Vzc1xuICpcbiAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiBydW5uaW5nIG9uIHRoZSByZW5kZXJlciwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBjb25zdCBpc1JlbmRlcmVyID0gKCkgPT4gZ2xvYmFsVGhpcy5wcm9jZXNzVHlwZSA9PT0gUHJvY2Vzc1R5cGUuUmVuZGVyZXI7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHJ1bm5pbmcgb24gdGhlIGV4dGVuc2lvbiBob3N0XG4gKlxuICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIHJ1bm5pbmcgb24gdGhlIGV4dGVuc2lvbiBob3N0LCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRXh0ZW5zaW9uSG9zdCA9ICgpID0+IGdsb2JhbFRoaXMucHJvY2Vzc1R5cGUgPT09IFByb2Nlc3NUeXBlLkV4dGVuc2lvbkhvc3Q7XG5cbi8qKlxuICogR2V0cyB3aGljaCBraW5kIG9mIHByb2Nlc3MgdGhpcyBpcyAobWFpbiwgcmVuZGVyZXIsIGV4dGVuc2lvbi1ob3N0KVxuICpcbiAqIEByZXR1cm5zIFByb2Nlc3NUeXBlIGZvciB0aGlzIHByb2Nlc3NcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFByb2Nlc3NUeXBlID0gKCk6IFByb2Nlc3NUeXBlID0+IGdsb2JhbFRoaXMucHJvY2Vzc1R5cGU7XG4iLCJpbXBvcnQgeyBQcm9jZXNzVHlwZSB9IGZyb20gJ0BzaGFyZWQvZ2xvYmFsLXRoaXMubW9kZWwnO1xuaW1wb3J0IHsgY2hhckF0LCBpbmRleE9mLCBpc1N0cmluZywgc3RyaW5nTGVuZ3RoLCBzdWJzdHJpbmcgfSBmcm9tICdwbGF0Zm9ybS1iaWJsZS11dGlscyc7XG5cbmNvbnN0IE5PTkNFX0NIQVJTID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JztcbmNvbnN0IE5PTkNFX0NIQVJTX0xFTkdUSCA9IHN0cmluZ0xlbmd0aChOT05DRV9DSEFSUyk7XG4vKipcbiAqIENyZWF0ZSBhIG5vbmNlIHRoYXQgaXMgYXQgbGVhc3QgMTI4IGJpdHMgbG9uZyBhbmQgc2hvdWxkIGJlIChpcyBub3QgY3VycmVudGx5KSBjcnlwdG9ncmFwaGljYWxseVxuICogcmFuZG9tLiBTZWUgbm9uY2Ugc3BlYyBhdCBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWNzcC8jc2VjdXJpdHktbm9uY2VzXG4gKlxuICogV0FSTklORzogVEhJUyBJUyBOT1QgQ1VSUkVOVExZIENSWVBUT0dSQVBISUNBTExZIFNFQ1VSRSEgVE9ETzogTWFrZSB0aGlzIGNyeXB0b2dyYXBoaWNhbGx5XG4gKiByYW5kb20hIFVzZSBzb21lIHBvbHltb3JwaGljIGxpYnJhcnkgdGhhdCB3b3JrcyBpbiBhbGwgY29udGV4dHM/XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3J5cHRvL2dldFJhbmRvbVZhbHVlcyBvbmx5IHdvcmtzIGluIGJyb3dzZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5ld05vbmNlKCk6IHN0cmluZyB7XG4gIGxldCBub25jZSA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspXG4gICAgbm9uY2UgKz0gY2hhckF0KE5PTkNFX0NIQVJTLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBOT05DRV9DSEFSU19MRU5HVEgpKTtcbiAgcmV0dXJuIG5vbmNlO1xufVxuXG4vLyAjcmVnaW9uIE1vZHVsZSBsb2FkaW5nXG5cbi8qKlxuICogTW9kdWxlcyB0aGF0IHNvbWVvbmUgbWlnaHQgdHJ5IHRvIHJlcXVpcmUgaW4gdGhlaXIgZXh0ZW5zaW9ucyB0aGF0IHdlIGhhdmUgc2ltaWxhciBhcGlzIGZvci4gV2hlblxuICogYW4gZXh0ZW5zaW9uIHJlcXVpcmVzIHRoZXNlIG1vZHVsZXMsIGFuIGVycm9yIHRocm93cyB0aGF0IGxldHMgdGhlbSBrbm93IGFib3V0IG91ciBzaW1pbGFyIGFwaS5cbiAqL1xuZXhwb3J0IGNvbnN0IE1PRFVMRV9TSU1JTEFSX0FQSVM6IFJlYWRvbmx5PHtcbiAgW21vZHVsZU5hbWU6IHN0cmluZ106IHN0cmluZyB8IHsgW3Byb2Nlc3MgaW4gUHJvY2Vzc1R5cGUgfCAnZGVmYXVsdCddPzogc3RyaW5nIH0gfCB1bmRlZmluZWQ7XG59PiA9IE9iamVjdC5mcmVlemUoe1xuICBodHRwOiAnZmV0Y2gnLFxuICBodHRwczogJ2ZldGNoJyxcbiAgZnM6IHtcbiAgICBbUHJvY2Vzc1R5cGUuUmVuZGVyZXJdOiAndGhlIHBhcGktZXh0ZW5zaW9uOiBwcm90b2NvbCcsXG4gICAgW1Byb2Nlc3NUeXBlLkV4dGVuc2lvbkhvc3RdOiAncGFwaS5zdG9yYWdlJyxcbiAgfSxcbiAgY2hpbGRfcHJvY2VzczogJ2NyZWF0ZVByb2Nlc3MgKHJlcXVpcmVzIHJlcXVlc3RpbmcgaW4gZWxldmF0ZWRQcml2aWxlZ2VzKScsXG59KTtcblxuLyoqXG4gKiBHZXQgYSBtZXNzYWdlIHRoYXQgc2F5cyB0aGUgbW9kdWxlIGltcG9ydCB3YXMgcmVqZWN0ZWQgYW5kIHRvIHRyeSBhIHNpbWlsYXIgYXBpIGlmIGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0gbW9kdWxlTmFtZSBOYW1lIG9mIGByZXF1aXJlYGQgbW9kdWxlIHRoYXQgd2FzIHJlamVjdGVkXG4gKiBAcmV0dXJucyBTdHJpbmcgdGhhdCBzYXlzIHRoZSBpbXBvcnQgd2FzIHJlamVjdGVkIGFuZCBhIHNpbWlsYXIgYXBpIHRvIHRyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9kdWxlU2ltaWxhckFwaU1lc3NhZ2UobW9kdWxlTmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IHNpbWlsYXJBcGkgPSBNT0RVTEVfU0lNSUxBUl9BUElTW21vZHVsZU5hbWVdIHx8IE1PRFVMRV9TSU1JTEFSX0FQSVNbYG5vZGU6JHttb2R1bGVOYW1lfWBdO1xuICBsZXQgc2ltaWxhckFwaU5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgaWYgKHNpbWlsYXJBcGkpXG4gICAgaWYgKGlzU3RyaW5nKHNpbWlsYXJBcGkpKSB7XG4gICAgICBzaW1pbGFyQXBpTmFtZSA9IHNpbWlsYXJBcGk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpbWlsYXJBcGlOYW1lID0gc2ltaWxhckFwaVtnbG9iYWxUaGlzLnByb2Nlc3NUeXBlXSB8fCBzaW1pbGFyQXBpLmRlZmF1bHQ7XG4gICAgfVxuICByZXR1cm4gYFJlamVjdGVkIHJlcXVpcmUoJyR7bW9kdWxlTmFtZX0nKS4gVHJ5JHtcbiAgICBzaW1pbGFyQXBpTmFtZSA/IGAgdXNpbmcgJHtzaW1pbGFyQXBpTmFtZX0gb3JgIDogJydcbiAgfSBidW5kbGluZyB0aGUgbW9kdWxlIGludG8geW91ciBjb2RlIHdpdGggYSBidWlsZCB0b29sIGxpa2Ugd2VicGFja2A7XG59XG5cbi8vICNlbmRyZWdpb25cblxuLy8gI3JlZ2lvbiBTZXJpYWxpemF0aW9uIGFuZCBkZXNlcmlhbGl6YXRpb24gZnVuY3Rpb25zXG5cbi8qKiBTZXBhcmF0b3IgYmV0d2VlbiBwYXJ0cyBvZiBhIHNlcmlhbGl6ZWQgcmVxdWVzdCAqL1xuY29uc3QgUkVRVUVTVF9UWVBFX1NFUEFSQVRPUiA9ICc6JztcblxuLyoqIEluZm9ybWF0aW9uIGFib3V0IGEgcmVxdWVzdCB0aGF0IHRlbGxzIHVzIHdoYXQgdG8gZG8gd2l0aCBpdCAqL1xuZXhwb3J0IHR5cGUgUmVxdWVzdFR5cGUgPSB7XG4gIC8qKiBUaGUgZ2VuZXJhbCBjYXRlZ29yeSBvZiByZXF1ZXN0ICovXG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIC8qKiBTcGVjaWZpYyBpZGVudGlmaWVyIGZvciB0aGlzIHR5cGUgb2YgcmVxdWVzdCAqL1xuICBkaXJlY3RpdmU6IHN0cmluZztcbn07XG5cbi8qKlxuICogU3RyaW5nIHZlcnNpb24gb2YgYSByZXF1ZXN0IHR5cGUgdGhhdCB0ZWxscyB1cyB3aGF0IHRvIGRvIHdpdGggYSByZXF1ZXN0LlxuICpcbiAqIENvbnNpc3RzIG9mIHR3byBzdHJpbmdzIGNvbmNhdGVuYXRlZCBieSBhIGNvbG9uXG4gKi9cbmV4cG9ydCB0eXBlIFNlcmlhbGl6ZWRSZXF1ZXN0VHlwZSA9IGAke3N0cmluZ30ke3R5cGVvZiBSRVFVRVNUX1RZUEVfU0VQQVJBVE9SfSR7c3RyaW5nfWA7XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVxdWVzdCBtZXNzYWdlIHJlcXVlc3RUeXBlIHN0cmluZyBmcm9tIGEgY2F0ZWdvcnkgYW5kIGEgZGlyZWN0aXZlXG4gKlxuICogQHBhcmFtIGNhdGVnb3J5IFRoZSBnZW5lcmFsIGNhdGVnb3J5IG9mIHJlcXVlc3RcbiAqIEBwYXJhbSBkaXJlY3RpdmUgU3BlY2lmaWMgaWRlbnRpZmllciBmb3IgdGhpcyB0eXBlIG9mIHJlcXVlc3RcbiAqIEByZXR1cm5zIEZ1bGwgcmVxdWVzdFR5cGUgZm9yIHVzZSBpbiBuZXR3b3JrIGNhbGxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVSZXF1ZXN0VHlwZShjYXRlZ29yeTogc3RyaW5nLCBkaXJlY3RpdmU6IHN0cmluZyk6IFNlcmlhbGl6ZWRSZXF1ZXN0VHlwZSB7XG4gIGlmICghY2F0ZWdvcnkpIHRocm93IG5ldyBFcnJvcignc2VyaWFsaXplUmVxdWVzdFR5cGU6IFwiY2F0ZWdvcnlcIiBpcyBub3QgZGVmaW5lZCBvciBlbXB0eS4nKTtcbiAgaWYgKCFkaXJlY3RpdmUpIHRocm93IG5ldyBFcnJvcignc2VyaWFsaXplUmVxdWVzdFR5cGU6IFwiZGlyZWN0aXZlXCIgaXMgbm90IGRlZmluZWQgb3IgZW1wdHkuJyk7XG5cbiAgcmV0dXJuIGAke2NhdGVnb3J5fSR7UkVRVUVTVF9UWVBFX1NFUEFSQVRPUn0ke2RpcmVjdGl2ZX1gO1xufVxuXG4vKiogU3BsaXQgYSByZXF1ZXN0IG1lc3NhZ2UgcmVxdWVzdFR5cGUgc3RyaW5nIGludG8gaXRzIHBhcnRzICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemVSZXF1ZXN0VHlwZShyZXF1ZXN0VHlwZTogU2VyaWFsaXplZFJlcXVlc3RUeXBlKTogUmVxdWVzdFR5cGUge1xuICBpZiAoIXJlcXVlc3RUeXBlKSB0aHJvdyBuZXcgRXJyb3IoJ2Rlc2VyaWFsaXplUmVxdWVzdFR5cGU6IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgY29uc3QgY29sb25JbmRleCA9IGluZGV4T2YocmVxdWVzdFR5cGUsIFJFUVVFU1RfVFlQRV9TRVBBUkFUT1IpO1xuICBpZiAoY29sb25JbmRleCA8PSAwIHx8IGNvbG9uSW5kZXggPj0gc3RyaW5nTGVuZ3RoKHJlcXVlc3RUeXBlKSAtIDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGRlc2VyaWFsaXplUmVxdWVzdFR5cGU6IE11c3QgaGF2ZSB0d28gcGFydHMgZGl2aWRlZCBieSBhICR7UkVRVUVTVF9UWVBFX1NFUEFSQVRPUn0gKCR7cmVxdWVzdFR5cGV9KWAsXG4gICAgKTtcbiAgY29uc3QgY2F0ZWdvcnkgPSBzdWJzdHJpbmcocmVxdWVzdFR5cGUsIDAsIGNvbG9uSW5kZXgpO1xuICBjb25zdCBkaXJlY3RpdmUgPSBzdWJzdHJpbmcocmVxdWVzdFR5cGUsIGNvbG9uSW5kZXggKyAxKTtcbiAgcmV0dXJuIHsgY2F0ZWdvcnksIGRpcmVjdGl2ZSB9O1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8qKlxuICogQWxsb3cgYW4gb2JqZWN0IHRvIGJpbmQgYWxsIGl0cyBjbGFzcy1kZWZpbmVkIGZ1bmN0aW9ucyB0byBpdHNlbGYgdG8gZW5zdXJlIGFsbCByZWZlcmVuY2VzIHRvXG4gKiBcInRoaXNcIiBpbiBpdHMgZnVuY3Rpb25zIHJlZmVyIHRvIHRoZSBvYmplY3QgcmF0aGVyIHRoYW4gdGhlIGNhbGxlciBvZiB0aGUgZnVuY3Rpb24uIEZvciBleGFtcGxlLFxuICogaWYgYSBmdW5jdGlvbiBvbiB0aGUgY2xhc3MgaXMgcHJvdmlkZWQgdG8gYSBjYWxsYmFjaywgaWYgXCJ0aGlzXCIgaXNuJ3QgYm91bmQgdG8gdGhlIG9iamVjdCB0aGVuXG4gKiBcInRoaXNcIiB3aWxsIHJlZmVyIHRvIHRoZSBlbnRpdHkgcnVubmluZyB0aGUgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kQ2xhc3NNZXRob2RzPFQgZXh0ZW5kcyBvYmplY3Q+KHRoaXM6IFQpOiB2b2lkIHtcbiAgY29uc3QgbWV0aG9kcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gIG1ldGhvZHMuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgLy8gQWxsb3cgaW5kZXhpbmcgdG8gd29yayBmb3IgdGhpcyBvYmplY3RcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb25cbiAgICBjb25zdCB0aGlzQXNBbnkgPSB0aGlzIGFzIGFueTtcbiAgICBpZiAodHlwZW9mIHRoaXNBc0FueVttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzQXNBbnlbbWV0aG9kXSA9IHRoaXNBc0FueVttZXRob2RdLmJpbmQodGhpcyk7XG4gICAgfVxuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSB3cml0ZUZpbGVcbm1vZHVsZS5leHBvcnRzLnN5bmMgPSB3cml0ZUZpbGVTeW5jXG5tb2R1bGUuZXhwb3J0cy5fZ2V0VG1wbmFtZSA9IGdldFRtcG5hbWUgLy8gZm9yIHRlc3Rpbmdcbm1vZHVsZS5leHBvcnRzLl9jbGVhbnVwT25FeGl0ID0gY2xlYW51cE9uRXhpdFxuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IE11cm11ckhhc2gzID0gcmVxdWlyZSgnaW11cm11cmhhc2gnKVxuY29uc3QgeyBvbkV4aXQgfSA9IHJlcXVpcmUoJ3NpZ25hbC1leGl0JylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IGFjdGl2ZUZpbGVzID0ge31cblxuLy8gaWYgd2UgcnVuIGluc2lkZSBvZiBhIHdvcmtlcl90aHJlYWQsIGBwcm9jZXNzLnBpZGAgaXMgbm90IHVuaXF1ZVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHRocmVhZElkID0gKGZ1bmN0aW9uIGdldElkICgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB3b3JrZXJUaHJlYWRzID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKVxuXG4gICAgLy8vIGlmIHdlIGFyZSBpbiBtYWluIHRocmVhZCwgdGhpcyBpcyBzZXQgdG8gYDBgXG4gICAgcmV0dXJuIHdvcmtlclRocmVhZHMudGhyZWFkSWRcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHdvcmtlcl90aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlLCBmYWxsYmFjayB0byAwXG4gICAgcmV0dXJuIDBcbiAgfVxufSkoKVxuXG5sZXQgaW52b2NhdGlvbnMgPSAwXG5mdW5jdGlvbiBnZXRUbXBuYW1lIChmaWxlbmFtZSkge1xuICByZXR1cm4gZmlsZW5hbWUgKyAnLicgK1xuICAgIE11cm11ckhhc2gzKF9fZmlsZW5hbWUpXG4gICAgICAuaGFzaChTdHJpbmcocHJvY2Vzcy5waWQpKVxuICAgICAgLmhhc2goU3RyaW5nKHRocmVhZElkKSlcbiAgICAgIC5oYXNoKFN0cmluZygrK2ludm9jYXRpb25zKSlcbiAgICAgIC5yZXN1bHQoKVxufVxuXG5mdW5jdGlvbiBjbGVhbnVwT25FeGl0ICh0bXBmaWxlKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnVubGlua1N5bmModHlwZW9mIHRtcGZpbGUgPT09ICdmdW5jdGlvbicgPyB0bXBmaWxlKCkgOiB0bXBmaWxlKVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gaWdub3JlIGVycm9yc1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVBY3RpdmVGaWxlIChhYnNvbHV0ZU5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIC8vIG1ha2UgYSBxdWV1ZSBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3RcbiAgICBpZiAoIWFjdGl2ZUZpbGVzW2Fic29sdXRlTmFtZV0pIHtcbiAgICAgIGFjdGl2ZUZpbGVzW2Fic29sdXRlTmFtZV0gPSBbXVxuICAgIH1cblxuICAgIGFjdGl2ZUZpbGVzW2Fic29sdXRlTmFtZV0ucHVzaChyZXNvbHZlKSAvLyBhZGQgdGhpcyBqb2IgdG8gdGhlIHF1ZXVlXG4gICAgaWYgKGFjdGl2ZUZpbGVzW2Fic29sdXRlTmFtZV0ubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXNvbHZlKClcbiAgICB9IC8vIGtpY2sgb2ZmIHRoZSBmaXJzdCBvbmVcbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdyYWNlZnVsLWZzL2Jsb2IvbWFzdGVyL3BvbHlmaWxscy5qcyNMMzE1LUwzNDJcbmZ1bmN0aW9uIGlzQ2hvd25FcnJPayAoZXJyKSB7XG4gIGlmIChlcnIuY29kZSA9PT0gJ0VOT1NZUycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3Qgbm9ucm9vdCA9ICFwcm9jZXNzLmdldHVpZCB8fCBwcm9jZXNzLmdldHVpZCgpICE9PSAwXG4gIGlmIChub25yb290KSB7XG4gICAgaWYgKGVyci5jb2RlID09PSAnRUlOVkFMJyB8fCBlcnIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVGaWxlQXN5bmMgKGZpbGVuYW1lLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IGVuY29kaW5nOiBvcHRpb25zIH1cbiAgfVxuXG4gIGxldCBmZFxuICBsZXQgdG1wZmlsZVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtLSBUaGUgY2xvc3VyZSBvbmx5IGdldHMgY2FsbGVkIHdoZW4gb25FeGl0IHRyaWdnZXJzICovXG4gIGNvbnN0IHJlbW92ZU9uRXhpdEhhbmRsZXIgPSBvbkV4aXQoY2xlYW51cE9uRXhpdCgoKSA9PiB0bXBmaWxlKSlcbiAgY29uc3QgYWJzb2x1dGVOYW1lID0gcGF0aC5yZXNvbHZlKGZpbGVuYW1lKVxuXG4gIHRyeSB7XG4gICAgYXdhaXQgc2VyaWFsaXplQWN0aXZlRmlsZShhYnNvbHV0ZU5hbWUpXG4gICAgY29uc3QgdHJ1ZW5hbWUgPSBhd2FpdCBwcm9taXNpZnkoZnMucmVhbHBhdGgpKGZpbGVuYW1lKS5jYXRjaCgoKSA9PiBmaWxlbmFtZSlcbiAgICB0bXBmaWxlID0gZ2V0VG1wbmFtZSh0cnVlbmFtZSlcblxuICAgIGlmICghb3B0aW9ucy5tb2RlIHx8ICFvcHRpb25zLmNob3duKSB7XG4gICAgICAvLyBFaXRoZXIgbW9kZSBvciBjaG93biBpcyBub3QgZXhwbGljaXRseSBzZXRcbiAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gY29weSBpdCBmcm9tIG9yaWdpbmFsIGZpbGVcbiAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgcHJvbWlzaWZ5KGZzLnN0YXQpKHRydWVuYW1lKS5jYXRjaCgoKSA9PiB7fSlcbiAgICAgIGlmIChzdGF0cykge1xuICAgICAgICBpZiAob3B0aW9ucy5tb2RlID09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zLm1vZGUgPSBzdGF0cy5tb2RlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5jaG93biA9PSBudWxsICYmIHByb2Nlc3MuZ2V0dWlkKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaG93biA9IHsgdWlkOiBzdGF0cy51aWQsIGdpZDogc3RhdHMuZ2lkIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZkID0gYXdhaXQgcHJvbWlzaWZ5KGZzLm9wZW4pKHRtcGZpbGUsICd3Jywgb3B0aW9ucy5tb2RlKVxuICAgIGlmIChvcHRpb25zLnRtcGZpbGVDcmVhdGVkKSB7XG4gICAgICBhd2FpdCBvcHRpb25zLnRtcGZpbGVDcmVhdGVkKHRtcGZpbGUpXG4gICAgfVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgIGF3YWl0IHByb21pc2lmeShmcy53cml0ZSkoZmQsIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwKVxuICAgIH0gZWxzZSBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICBhd2FpdCBwcm9taXNpZnkoZnMud3JpdGUpKGZkLCBTdHJpbmcoZGF0YSksIDAsIFN0cmluZyhvcHRpb25zLmVuY29kaW5nIHx8ICd1dGY4JykpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZnN5bmMgIT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCBwcm9taXNpZnkoZnMuZnN5bmMpKGZkKVxuICAgIH1cblxuICAgIGF3YWl0IHByb21pc2lmeShmcy5jbG9zZSkoZmQpXG4gICAgZmQgPSBudWxsXG5cbiAgICBpZiAob3B0aW9ucy5jaG93bikge1xuICAgICAgYXdhaXQgcHJvbWlzaWZ5KGZzLmNob3duKSh0bXBmaWxlLCBvcHRpb25zLmNob3duLnVpZCwgb3B0aW9ucy5jaG93bi5naWQpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmICghaXNDaG93bkVyck9rKGVycikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5tb2RlKSB7XG4gICAgICBhd2FpdCBwcm9taXNpZnkoZnMuY2htb2QpKHRtcGZpbGUsIG9wdGlvbnMubW9kZSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKCFpc0Nob3duRXJyT2soZXJyKSkge1xuICAgICAgICAgIHRocm93IGVyclxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGF3YWl0IHByb21pc2lmeShmcy5yZW5hbWUpKHRtcGZpbGUsIHRydWVuYW1lKVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChmZCkge1xuICAgICAgYXdhaXQgcHJvbWlzaWZ5KGZzLmNsb3NlKShmZCkuY2F0Y2goXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICgpID0+IHt9XG4gICAgICApXG4gICAgfVxuICAgIHJlbW92ZU9uRXhpdEhhbmRsZXIoKVxuICAgIGF3YWl0IHByb21pc2lmeShmcy51bmxpbmspKHRtcGZpbGUpLmNhdGNoKCgpID0+IHt9KVxuICAgIGFjdGl2ZUZpbGVzW2Fic29sdXRlTmFtZV0uc2hpZnQoKSAvLyByZW1vdmUgdGhlIGVsZW1lbnQgYWRkZWQgYnkgc2VyaWFsaXplU2FtZUZpbGVcbiAgICBpZiAoYWN0aXZlRmlsZXNbYWJzb2x1dGVOYW1lXS5sZW5ndGggPiAwKSB7XG4gICAgICBhY3RpdmVGaWxlc1thYnNvbHV0ZU5hbWVdWzBdKCkgLy8gc3RhcnQgbmV4dCBqb2IgaWYgb25lIGlzIHBlbmRpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIGFjdGl2ZUZpbGVzW2Fic29sdXRlTmFtZV1cbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVGaWxlIChmaWxlbmFtZSwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IHdyaXRlRmlsZUFzeW5jKGZpbGVuYW1lLCBkYXRhLCBvcHRpb25zKVxuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gd3JpdGVGaWxlU3luYyAoZmlsZW5hbWUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IGVuY29kaW5nOiBvcHRpb25zIH1cbiAgfSBlbHNlIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG4gIHRyeSB7XG4gICAgZmlsZW5hbWUgPSBmcy5yZWFscGF0aFN5bmMoZmlsZW5hbWUpXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgLy8gaXQncyBvaywgaXQnbGwgaGFwcGVuIG9uIGEgbm90IHlldCBleGlzdGluZyBmaWxlXG4gIH1cbiAgY29uc3QgdG1wZmlsZSA9IGdldFRtcG5hbWUoZmlsZW5hbWUpXG5cbiAgaWYgKCFvcHRpb25zLm1vZGUgfHwgIW9wdGlvbnMuY2hvd24pIHtcbiAgICAvLyBFaXRoZXIgbW9kZSBvciBjaG93biBpcyBub3QgZXhwbGljaXRseSBzZXRcbiAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGNvcHkgaXQgZnJvbSBvcmlnaW5hbCBmaWxlXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZW5hbWUpXG4gICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucylcbiAgICAgIGlmICghb3B0aW9ucy5tb2RlKSB7XG4gICAgICAgIG9wdGlvbnMubW9kZSA9IHN0YXRzLm1vZGVcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy5jaG93biAmJiBwcm9jZXNzLmdldHVpZCkge1xuICAgICAgICBvcHRpb25zLmNob3duID0geyB1aWQ6IHN0YXRzLnVpZCwgZ2lkOiBzdGF0cy5naWQgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAvLyBpZ25vcmUgc3RhdCBlcnJvcnNcbiAgICB9XG4gIH1cblxuICBsZXQgZmRcbiAgY29uc3QgY2xlYW51cCA9IGNsZWFudXBPbkV4aXQodG1wZmlsZSlcbiAgY29uc3QgcmVtb3ZlT25FeGl0SGFuZGxlciA9IG9uRXhpdChjbGVhbnVwKVxuXG4gIGxldCB0aHJldyA9IHRydWVcbiAgdHJ5IHtcbiAgICBmZCA9IGZzLm9wZW5TeW5jKHRtcGZpbGUsICd3Jywgb3B0aW9ucy5tb2RlIHx8IDBvNjY2KVxuICAgIGlmIChvcHRpb25zLnRtcGZpbGVDcmVhdGVkKSB7XG4gICAgICBvcHRpb25zLnRtcGZpbGVDcmVhdGVkKHRtcGZpbGUpXG4gICAgfVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgIGZzLndyaXRlU3luYyhmZCwgZGF0YSwgMCwgZGF0YS5sZW5ndGgsIDApXG4gICAgfSBlbHNlIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgIGZzLndyaXRlU3luYyhmZCwgU3RyaW5nKGRhdGEpLCAwLCBTdHJpbmcob3B0aW9ucy5lbmNvZGluZyB8fCAndXRmOCcpKVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mc3luYyAhPT0gZmFsc2UpIHtcbiAgICAgIGZzLmZzeW5jU3luYyhmZClcbiAgICB9XG5cbiAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgZmQgPSBudWxsXG5cbiAgICBpZiAob3B0aW9ucy5jaG93bikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2hvd25TeW5jKHRtcGZpbGUsIG9wdGlvbnMuY2hvd24udWlkLCBvcHRpb25zLmNob3duLmdpZClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWlzQ2hvd25FcnJPayhlcnIpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5tb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy5jaG1vZFN5bmModG1wZmlsZSwgb3B0aW9ucy5tb2RlKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghaXNDaG93bkVyck9rKGVycikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZzLnJlbmFtZVN5bmModG1wZmlsZSwgZmlsZW5hbWUpXG4gICAgdGhyZXcgPSBmYWxzZVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChmZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgLy8gaWdub3JlIGNsb3NlIGVycm9ycyBhdCB0aGlzIHN0YWdlLCBlcnJvciBtYXkgaGF2ZSBjbG9zZWQgZmQgYWxyZWFkeS5cbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlT25FeGl0SGFuZGxlcigpXG4gICAgaWYgKHRocmV3KSB7XG4gICAgICBjbGVhbnVwKClcbiAgICB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImFzc2VydFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJidWZmZXJcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb25zdGFudHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY3J5cHRvXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZWN0cm9uXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImV2ZW50c1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmcy9wcm9taXNlc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5ldFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJvc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXRoXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN0cmVhbVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0bHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHR5XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dGlsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInZtXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInpsaWJcIik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVubG9hZCA9IGV4cG9ydHMubG9hZCA9IGV4cG9ydHMub25FeGl0ID0gZXhwb3J0cy5zaWduYWxzID0gdm9pZCAwO1xuLy8gTm90ZTogc2luY2UgbnljIHVzZXMgdGhpcyBtb2R1bGUgdG8gb3V0cHV0IGNvdmVyYWdlLCBhbnkgbGluZXNcbi8vIHRoYXQgYXJlIGluIHRoZSBkaXJlY3Qgc3luYyBmbG93IG9mIG55YydzIG91dHB1dENvdmVyYWdlIGFyZVxuLy8gaWdub3JlZCwgc2luY2Ugd2UgY2FuIG5ldmVyIGdldCBjb3ZlcmFnZSBmb3IgdGhlbS5cbi8vIGdyYWIgYSByZWZlcmVuY2UgdG8gbm9kZSdzIHJlYWwgcHJvY2VzcyBvYmplY3QgcmlnaHQgYXdheVxuY29uc3Qgc2lnbmFsc19qc18xID0gcmVxdWlyZShcIi4vc2lnbmFscy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNpZ25hbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25hbHNfanNfMS5zaWduYWxzOyB9IH0pO1xuY29uc3QgcHJvY2Vzc09rID0gKHByb2Nlc3MpID0+ICEhcHJvY2VzcyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnJlYWxseUV4aXQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5saXN0ZW5lcnMgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5raWxsID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHByb2Nlc3MucGlkID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLm9uID09PSAnZnVuY3Rpb24nO1xuY29uc3Qga0V4aXRFbWl0dGVyID0gU3ltYm9sLmZvcignc2lnbmFsLWV4aXQgZW1pdHRlcicpO1xuY29uc3QgZ2xvYmFsID0gZ2xvYmFsVGhpcztcbmNvbnN0IE9iamVjdERlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LmJpbmQoT2JqZWN0KTtcbi8vIHRlZW55IHNwZWNpYWwgcHVycG9zZSBlZVxuY2xhc3MgRW1pdHRlciB7XG4gICAgZW1pdHRlZCA9IHtcbiAgICAgICAgYWZ0ZXJFeGl0OiBmYWxzZSxcbiAgICAgICAgZXhpdDogZmFsc2UsXG4gICAgfTtcbiAgICBsaXN0ZW5lcnMgPSB7XG4gICAgICAgIGFmdGVyRXhpdDogW10sXG4gICAgICAgIGV4aXQ6IFtdLFxuICAgIH07XG4gICAgY291bnQgPSAwO1xuICAgIGlkID0gTWF0aC5yYW5kb20oKTtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKGdsb2JhbFtrRXhpdEVtaXR0ZXJdKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsW2tFeGl0RW1pdHRlcl07XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHkoZ2xvYmFsLCBrRXhpdEVtaXR0ZXIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb24oZXYsIGZuKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2V2XS5wdXNoKGZuKTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXYsIGZuKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLmxpc3RlbmVyc1tldl07XG4gICAgICAgIGNvbnN0IGkgPSBsaXN0LmluZGV4T2YoZm4pO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKGkgPT09IDAgJiYgbGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXQoZXYsIGNvZGUsIHNpZ25hbCkge1xuICAgICAgICBpZiAodGhpcy5lbWl0dGVkW2V2XSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdHRlZFtldl0gPSB0cnVlO1xuICAgICAgICBsZXQgcmV0ID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgZm4gb2YgdGhpcy5saXN0ZW5lcnNbZXZdKSB7XG4gICAgICAgICAgICByZXQgPSBmbihjb2RlLCBzaWduYWwpID09PSB0cnVlIHx8IHJldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXYgPT09ICdleGl0Jykge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5lbWl0KCdhZnRlckV4aXQnLCBjb2RlLCBzaWduYWwpIHx8IHJldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmNsYXNzIFNpZ25hbEV4aXRCYXNlIHtcbn1cbmNvbnN0IHNpZ25hbEV4aXRXcmFwID0gKGhhbmRsZXIpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbkV4aXQoY2IsIG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLm9uRXhpdChjYiwgb3B0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvYWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlci5sb2FkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVubG9hZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLnVubG9hZCgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuY2xhc3MgU2lnbmFsRXhpdEZhbGxiYWNrIGV4dGVuZHMgU2lnbmFsRXhpdEJhc2Uge1xuICAgIG9uRXhpdCgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcbiAgICB9XG4gICAgbG9hZCgpIHsgfVxuICAgIHVubG9hZCgpIHsgfVxufVxuY2xhc3MgU2lnbmFsRXhpdCBleHRlbmRzIFNpZ25hbEV4aXRCYXNlIHtcbiAgICAvLyBcIlNJR0hVUFwiIHRocm93cyBhbiBgRU5PU1lTYCBlcnJvciBvbiBXaW5kb3dzLFxuICAgIC8vIHNvIHVzZSBhIHN1cHBvcnRlZCBzaWduYWwgaW5zdGVhZFxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICNodXBTaWcgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gJ1NJR0lOVCcgOiAnU0lHSFVQJztcbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICNlbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAjcHJvY2VzcztcbiAgICAjb3JpZ2luYWxQcm9jZXNzRW1pdDtcbiAgICAjb3JpZ2luYWxQcm9jZXNzUmVhbGx5RXhpdDtcbiAgICAjc2lnTGlzdGVuZXJzID0ge307XG4gICAgI2xvYWRlZCA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKHByb2Nlc3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jcHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgICAgIC8vIHsgPHNpZ25hbD46IDxsaXN0ZW5lciBmbj4sIC4uLiB9XG4gICAgICAgIHRoaXMuI3NpZ0xpc3RlbmVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHNpZyBvZiBzaWduYWxzX2pzXzEuc2lnbmFscykge1xuICAgICAgICAgICAgdGhpcy4jc2lnTGlzdGVuZXJzW3NpZ10gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGxpc3RlbmVycywgYW4gZXhpdCBpcyBjb21pbmchXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlc3Qgd2F5OiByZW1vdmUgdXMgYW5kIHRoZW4gcmUtc2VuZCB0aGUgc2lnbmFsLlxuICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhhdCB0aGlzIHdpbGwga2lsbCB0aGUgcHJvY2Vzcywgc28gd2UgY2FuXG4gICAgICAgICAgICAgICAgLy8gc2FmZWx5IGVtaXQgbm93LlxuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuI3Byb2Nlc3MubGlzdGVuZXJzKHNpZyk7XG4gICAgICAgICAgICAgICAgbGV0IHsgY291bnQgfSA9IHRoaXMuI2VtaXR0ZXI7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIHRoZSBmYWN0IHRoYXQgc2lnbmFsLWV4aXQgdjMgYW5kIHNpZ25hbFxuICAgICAgICAgICAgICAgIC8vIGV4aXQgdjQgYXJlIG5vdCBhd2FyZSBvZiBlYWNoIG90aGVyLCBhbmQgZWFjaCB3aWxsIGF0dGVtcHQgdG8gbGV0XG4gICAgICAgICAgICAgICAgLy8gdGhlIG90aGVyIGhhbmRsZSBpdCwgc28gbmVpdGhlciBvZiB0aGVtIGRvLiBUbyBjb3JyZWN0IHRoaXMsIHdlXG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IGlmIHdlJ3JlIHRoZSBvbmx5IGhhbmRsZXIgKmV4Y2VwdCogZm9yIHByZXZpb3VzIHZlcnNpb25zXG4gICAgICAgICAgICAgICAgLy8gb2Ygc2lnbmFsLWV4aXQsIGFuZCBpbmNyZW1lbnQgYnkgdGhlIGNvdW50IG9mIGxpc3RlbmVycyBpdCBoYXNcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGVkLlxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwcm9jZXNzO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcC5fX3NpZ25hbF9leGl0X2VtaXR0ZXJfXyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHAuX19zaWduYWxfZXhpdF9lbWl0dGVyX18uY291bnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IHAuX19zaWduYWxfZXhpdF9lbWl0dGVyX18uY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMuI2VtaXR0ZXIuZW1pdCgnZXhpdCcsIG51bGwsIHNpZyk7XG4gICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gc2lnID09PSAnU0lHSFVQJyA/IHRoaXMuI2h1cFNpZyA6IHNpZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmtpbGwocHJvY2Vzcy5waWQsIHMpO1xuICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jb3JpZ2luYWxQcm9jZXNzUmVhbGx5RXhpdCA9IHByb2Nlc3MucmVhbGx5RXhpdDtcbiAgICAgICAgdGhpcy4jb3JpZ2luYWxQcm9jZXNzRW1pdCA9IHByb2Nlc3MuZW1pdDtcbiAgICB9XG4gICAgb25FeGl0KGNiLCBvcHRzKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXByb2Nlc3NPayh0aGlzLiNwcm9jZXNzKSkge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAodGhpcy4jbG9hZGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXYgPSBvcHRzPy5hbHdheXNMYXN0ID8gJ2FmdGVyRXhpdCcgOiAnZXhpdCc7XG4gICAgICAgIHRoaXMuI2VtaXR0ZXIub24oZXYsIGNiKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2VtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXYsIGNiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNlbWl0dGVyLmxpc3RlbmVyc1snZXhpdCddLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI2VtaXR0ZXIubGlzdGVuZXJzWydhZnRlckV4aXQnXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVubG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBsb2FkKCkge1xuICAgICAgICBpZiAodGhpcy4jbG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgbnVtYmVyIG9mIG9uU2lnbmFsRXhpdCdzIHRoYXQgYXJlIGluIHBsYXkuXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHNvIHRoYXQgd2UgY2FuIGNvdW50IHRoZSBjb3JyZWN0IG51bWJlciBvZlxuICAgICAgICAvLyBsaXN0ZW5lcnMgb24gc2lnbmFscywgYW5kIGRvbid0IHdhaXQgZm9yIHRoZSBvdGhlciBvbmUgdG9cbiAgICAgICAgLy8gaGFuZGxlIGl0IGluc3RlYWQgb2YgdXMuXG4gICAgICAgIHRoaXMuI2VtaXR0ZXIuY291bnQgKz0gMTtcbiAgICAgICAgZm9yIChjb25zdCBzaWcgb2Ygc2lnbmFsc19qc18xLnNpZ25hbHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm4gPSB0aGlzLiNzaWdMaXN0ZW5lcnNbc2lnXTtcbiAgICAgICAgICAgICAgICBpZiAoZm4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3Byb2Nlc3Mub24oc2lnLCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvY2Vzcy5lbWl0ID0gKGV2LCAuLi5hKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcHJvY2Vzc0VtaXQoZXYsIC4uLmEpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNwcm9jZXNzLnJlYWxseUV4aXQgPSAoY29kZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2Nlc3NSZWFsbHlFeGl0KGNvZGUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1bmxvYWQoKSB7XG4gICAgICAgIGlmICghdGhpcy4jbG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHNpZ25hbHNfanNfMS5zaWduYWxzLmZvckVhY2goc2lnID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gdGhpcy4jc2lnTGlzdGVuZXJzW3NpZ107XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpc3RlbmVyIG5vdCBkZWZpbmVkIGZvciBzaWduYWw6ICcgKyBzaWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcihzaWcsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNwcm9jZXNzLmVtaXQgPSB0aGlzLiNvcmlnaW5hbFByb2Nlc3NFbWl0O1xuICAgICAgICB0aGlzLiNwcm9jZXNzLnJlYWxseUV4aXQgPSB0aGlzLiNvcmlnaW5hbFByb2Nlc3NSZWFsbHlFeGl0O1xuICAgICAgICB0aGlzLiNlbWl0dGVyLmNvdW50IC09IDE7XG4gICAgfVxuICAgICNwcm9jZXNzUmVhbGx5RXhpdChjb2RlKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXByb2Nlc3NPayh0aGlzLiNwcm9jZXNzKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvY2Vzcy5leGl0Q29kZSA9IGNvZGUgfHwgMDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy4jZW1pdHRlci5lbWl0KCdleGl0JywgdGhpcy4jcHJvY2Vzcy5leGl0Q29kZSwgbnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzLiNvcmlnaW5hbFByb2Nlc3NSZWFsbHlFeGl0LmNhbGwodGhpcy4jcHJvY2VzcywgdGhpcy4jcHJvY2Vzcy5leGl0Q29kZSk7XG4gICAgfVxuICAgICNwcm9jZXNzRW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBvZyA9IHRoaXMuI29yaWdpbmFsUHJvY2Vzc0VtaXQ7XG4gICAgICAgIGlmIChldiA9PT0gJ2V4aXQnICYmIHByb2Nlc3NPayh0aGlzLiNwcm9jZXNzKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuI3Byb2Nlc3MuZXhpdENvZGUgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBjb25zdCByZXQgPSBvZy5jYWxsKHRoaXMuI3Byb2Nlc3MsIGV2LCAuLi5hcmdzKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgdGhpcy4jZW1pdHRlci5lbWl0KCdleGl0JywgdGhpcy4jcHJvY2Vzcy5leGl0Q29kZSwgbnVsbCk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvZy5jYWxsKHRoaXMuI3Byb2Nlc3MsIGV2LCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IHByb2Nlc3MgPSBnbG9iYWxUaGlzLnByb2Nlc3M7XG4vLyB3cmFwIHNvIHRoYXQgd2UgY2FsbCB0aGUgbWV0aG9kIG9uIHRoZSBhY3R1YWwgaGFuZGxlciwgd2l0aG91dFxuLy8gZXhwb3J0aW5nIGl0IGRpcmVjdGx5LlxuX2EgPSBzaWduYWxFeGl0V3JhcChwcm9jZXNzT2socHJvY2VzcykgPyBuZXcgU2lnbmFsRXhpdChwcm9jZXNzKSA6IG5ldyBTaWduYWxFeGl0RmFsbGJhY2soKSksIFxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgcHJvY2VzcyBpcyBleGl0aW5nLCB3aGV0aGVyIHZpYSBzaWduYWwsIGV4cGxpY2l0XG4gKiBleGl0LCBvciBydW5uaW5nIG91dCBvZiBzdHVmZiB0byBkby5cbiAqXG4gKiBJZiB0aGUgZ2xvYmFsIHByb2Nlc3Mgb2JqZWN0IGlzIG5vdCBzdWl0YWJsZSBmb3IgaW5zdHJ1bWVudGF0aW9uLFxuICogdGhlbiB0aGlzIHdpbGwgYmUgYSBuby1vcC5cbiAqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byB1bmxvYWQgc2lnbmFsLWV4aXQuXG4gKi9cbmV4cG9ydHMub25FeGl0ID0gX2Eub25FeGl0LCBcbi8qKlxuICogTG9hZCB0aGUgbGlzdGVuZXJzLiAgTGlrZWx5IHlvdSBuZXZlciBuZWVkIHRvIGNhbGwgdGhpcywgdW5sZXNzXG4gKiBkb2luZyBhIHJhdGhlciBkZWVwIGludGVncmF0aW9uIHdpdGggc2lnbmFsLWV4aXQgZnVuY3Rpb25hbGl0eS5cbiAqIE1vc3RseSBleHBvc2VkIGZvciB0aGUgYmVuZWZpdCBvZiB0ZXN0aW5nLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnRzLmxvYWQgPSBfYS5sb2FkLCBcbi8qKlxuICogVW5sb2FkIHRoZSBsaXN0ZW5lcnMuICBMaWtlbHkgeW91IG5ldmVyIG5lZWQgdG8gY2FsbCB0aGlzLCB1bmxlc3NcbiAqIGRvaW5nIGEgcmF0aGVyIGRlZXAgaW50ZWdyYXRpb24gd2l0aCBzaWduYWwtZXhpdCBmdW5jdGlvbmFsaXR5LlxuICogTW9zdGx5IGV4cG9zZWQgZm9yIHRoZSBiZW5lZml0IG9mIHRlc3RpbmcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydHMudW5sb2FkID0gX2EudW5sb2FkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNpZ25hbHMgPSB2b2lkIDA7XG4vKipcbiAqIFRoaXMgaXMgbm90IHRoZSBzZXQgb2YgYWxsIHBvc3NpYmxlIHNpZ25hbHMuXG4gKlxuICogSXQgSVMsIGhvd2V2ZXIsIHRoZSBzZXQgb2YgYWxsIHNpZ25hbHMgdGhhdCB0cmlnZ2VyXG4gKiBhbiBleGl0IG9uIGVpdGhlciBMaW51eCBvciBCU0Qgc3lzdGVtcy4gIExpbnV4IGlzIGFcbiAqIHN1cGVyc2V0IG9mIHRoZSBzaWduYWwgbmFtZXMgc3VwcG9ydGVkIG9uIEJTRCwgYW5kXG4gKiB0aGUgdW5rbm93biBzaWduYWxzIGp1c3QgZmFpbCB0byByZWdpc3Rlciwgc28gd2UgY2FuXG4gKiBjYXRjaCB0aGF0IGVhc2lseSBlbm91Z2guXG4gKlxuICogV2luZG93cyBzaWduYWxzIGFyZSBhIGRpZmZlcmVudCBzZXQsIHNpbmNlIHRoZXJlIGFyZVxuICogc2lnbmFscyB0aGF0IHRlcm1pbmF0ZSBXaW5kb3dzIHByb2Nlc3NlcywgYnV0IGRvbid0XG4gKiB0ZXJtaW5hdGUgKG9yIGRvbid0IGV2ZW4gZXhpc3QpIG9uIFBvc2l4IHN5c3RlbXMuXG4gKlxuICogRG9uJ3QgYm90aGVyIHdpdGggU0lHS0lMTC4gIEl0J3MgdW5jYXRjaGFibGUsIHdoaWNoXG4gKiBtZWFucyB0aGF0IHdlIGNhbid0IGZpcmUgYW55IGNhbGxiYWNrcyBhbnl3YXkuXG4gKlxuICogSWYgYSB1c2VyIGRvZXMgaGFwcGVuIHRvIHJlZ2lzdGVyIGEgaGFuZGxlciBvbiBhIG5vbi1cbiAqIGZhdGFsIHNpZ25hbCBsaWtlIFNJR1dJTkNIIG9yIHNvbWV0aGluZywgYW5kIHRoZW5cbiAqIGV4aXQsIGl0J2xsIGVuZCB1cCBmaXJpbmcgYHByb2Nlc3MuZW1pdCgnZXhpdCcpYCwgc29cbiAqIHRoZSBoYW5kbGVyIHdpbGwgYmUgZmlyZWQgYW55d2F5LlxuICpcbiAqIFNJR0JVUywgU0lHRlBFLCBTSUdTRUdWIGFuZCBTSUdJTEwsIHdoZW4gbm90IHJhaXNlZFxuICogYXJ0aWZpY2lhbGx5LCBpbmhlcmVudGx5IGxlYXZlIHRoZSBwcm9jZXNzIGluIGFcbiAqIHN0YXRlIGZyb20gd2hpY2ggaXQgaXMgbm90IHNhZmUgdG8gdHJ5IGFuZCBlbnRlciBKU1xuICogbGlzdGVuZXJzLlxuICovXG5leHBvcnRzLnNpZ25hbHMgPSBbXTtcbmV4cG9ydHMuc2lnbmFscy5wdXNoKCdTSUdIVVAnLCAnU0lHSU5UJywgJ1NJR1RFUk0nKTtcbmlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgZXhwb3J0cy5zaWduYWxzLnB1c2goJ1NJR0FMUk0nLCAnU0lHQUJSVCcsICdTSUdWVEFMUk0nLCAnU0lHWENQVScsICdTSUdYRlNaJywgJ1NJR1VTUjInLCAnU0lHVFJBUCcsICdTSUdTWVMnLCAnU0lHUVVJVCcsICdTSUdJT1QnXG4gICAgLy8gc2hvdWxkIGRldGVjdCBwcm9maWxlciBhbmQgZW5hYmxlL2Rpc2FibGUgYWNjb3JkaW5nbHkuXG4gICAgLy8gc2VlICMyMVxuICAgIC8vICdTSUdQUk9GJ1xuICAgICk7XG59XG5pZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jykge1xuICAgIGV4cG9ydHMuc2lnbmFscy5wdXNoKCdTSUdJTycsICdTSUdQT0xMJywgJ1NJR1BXUicsICdTSUdTVEtGTFQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hbHMuanMubWFwIiwiY29uc3QgRV9USU1FT1VUID0gbmV3IEVycm9yKCd0aW1lb3V0IHdoaWxlIHdhaXRpbmcgZm9yIG11dGV4IHRvIGJlY29tZSBhdmFpbGFibGUnKTtcbmNvbnN0IEVfQUxSRUFEWV9MT0NLRUQgPSBuZXcgRXJyb3IoJ211dGV4IGFscmVhZHkgbG9ja2VkJyk7XG5jb25zdCBFX0NBTkNFTEVEID0gbmV3IEVycm9yKCdyZXF1ZXN0IGZvciBsb2NrIGNhbmNlbGVkJyk7XG5cbnZhciBfX2F3YWl0ZXIkMiA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuY2xhc3MgU2VtYXBob3JlIHtcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9jYW5jZWxFcnJvciA9IEVfQ0FOQ0VMRUQpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgIHRoaXMuX2NhbmNlbEVycm9yID0gX2NhbmNlbEVycm9yO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLl93ZWlnaHRlZFdhaXRlcnMgPSBbXTtcbiAgICB9XG4gICAgYWNxdWlyZSh3ZWlnaHQgPSAxLCBwcmlvcml0eSA9IDApIHtcbiAgICAgICAgaWYgKHdlaWdodCA8PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSB7IHJlc29sdmUsIHJlamVjdCwgd2VpZ2h0LCBwcmlvcml0eSB9O1xuICAgICAgICAgICAgY29uc3QgaSA9IGZpbmRJbmRleEZyb21FbmQodGhpcy5fcXVldWUsIChvdGhlcikgPT4gcHJpb3JpdHkgPD0gb3RoZXIucHJpb3JpdHkpO1xuICAgICAgICAgICAgaWYgKGkgPT09IC0xICYmIHdlaWdodCA8PSB0aGlzLl92YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWRzIGltbWVkaWF0ZSBkaXNwYXRjaCwgc2tpcCB0aGUgcXVldWVcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEl0ZW0odGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcnVuRXhjbHVzaXZlKGNhbGxiYWNrXzEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKGNhbGxiYWNrLCB3ZWlnaHQgPSAxLCBwcmlvcml0eSA9IDApIHtcbiAgICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgcmVsZWFzZV0gPSB5aWVsZCB0aGlzLmFjcXVpcmUod2VpZ2h0LCBwcmlvcml0eSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3YWl0Rm9yVW5sb2NrKHdlaWdodCA9IDEsIHByaW9yaXR5ID0gMCkge1xuICAgICAgICBpZiAod2VpZ2h0IDw9IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICBpZiAodGhpcy5fY291bGRMb2NrSW1tZWRpYXRlbHkod2VpZ2h0LCBwcmlvcml0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0gPSBbXTtcbiAgICAgICAgICAgICAgICBpbnNlcnRTb3J0ZWQodGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdLCB7IHJlc29sdmUsIHByaW9yaXR5IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNMb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZSA8PSAwO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFF1ZXVlKCk7XG4gICAgfVxuICAgIHJlbGVhc2Uod2VpZ2h0ID0gMSkge1xuICAgICAgICBpZiAod2VpZ2h0IDw9IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICB0aGlzLl92YWx1ZSArPSB3ZWlnaHQ7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUXVldWUoKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLl9xdWV1ZS5mb3JFYWNoKChlbnRyeSkgPT4gZW50cnkucmVqZWN0KHRoaXMuX2NhbmNlbEVycm9yKSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgfVxuICAgIF9kaXNwYXRjaFF1ZXVlKCkge1xuICAgICAgICB0aGlzLl9kcmFpblVubG9ja1dhaXRlcnMoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDAgJiYgdGhpcy5fcXVldWVbMF0ud2VpZ2h0IDw9IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEl0ZW0odGhpcy5fcXVldWUuc2hpZnQoKSk7XG4gICAgICAgICAgICB0aGlzLl9kcmFpblVubG9ja1dhaXRlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZGlzcGF0Y2hJdGVtKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICB0aGlzLl92YWx1ZSAtPSBpdGVtLndlaWdodDtcbiAgICAgICAgaXRlbS5yZXNvbHZlKFtwcmV2aW91c1ZhbHVlLCB0aGlzLl9uZXdSZWxlYXNlcihpdGVtLndlaWdodCldKTtcbiAgICB9XG4gICAgX25ld1JlbGVhc2VyKHdlaWdodCkge1xuICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2Uod2VpZ2h0KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2RyYWluVW5sb2NrV2FpdGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgd2VpZ2h0ID0gdGhpcy5fdmFsdWU7IHdlaWdodCA+IDA7IHdlaWdodC0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FpdGVycyA9IHRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXdhaXRlcnMpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHdhaXRlcnMuZm9yRWFjaCgod2FpdGVyKSA9PiB3YWl0ZXIucmVzb2x2ZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlZFByaW9yaXR5ID0gdGhpcy5fcXVldWVbMF0ucHJpb3JpdHk7XG4gICAgICAgICAgICBmb3IgKGxldCB3ZWlnaHQgPSB0aGlzLl92YWx1ZTsgd2VpZ2h0ID4gMDsgd2VpZ2h0LS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YWl0ZXJzID0gdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICghd2FpdGVycylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IHdhaXRlcnMuZmluZEluZGV4KCh3YWl0ZXIpID0+IHdhaXRlci5wcmlvcml0eSA8PSBxdWV1ZWRQcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgKGkgPT09IC0xID8gd2FpdGVycyA6IHdhaXRlcnMuc3BsaWNlKDAsIGkpKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgod2FpdGVyID0+IHdhaXRlci5yZXNvbHZlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfY291bGRMb2NrSW1tZWRpYXRlbHkod2VpZ2h0LCBwcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9xdWV1ZVswXS5wcmlvcml0eSA8IHByaW9yaXR5KSAmJlxuICAgICAgICAgICAgd2VpZ2h0IDw9IHRoaXMuX3ZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc2VydFNvcnRlZChhLCB2KSB7XG4gICAgY29uc3QgaSA9IGZpbmRJbmRleEZyb21FbmQoYSwgKG90aGVyKSA9PiB2LnByaW9yaXR5IDw9IG90aGVyLnByaW9yaXR5KTtcbiAgICBhLnNwbGljZShpICsgMSwgMCwgdik7XG59XG5mdW5jdGlvbiBmaW5kSW5kZXhGcm9tRW5kKGEsIHByZWRpY2F0ZSkge1xuICAgIGZvciAobGV0IGkgPSBhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYVtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxudmFyIF9fYXdhaXRlciQxID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5jbGFzcyBNdXRleCB7XG4gICAgY29uc3RydWN0b3IoY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fc2VtYXBob3JlID0gbmV3IFNlbWFwaG9yZSgxLCBjYW5jZWxFcnJvcik7XG4gICAgfVxuICAgIGFjcXVpcmUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24qIChwcmlvcml0eSA9IDApIHtcbiAgICAgICAgICAgIGNvbnN0IFssIHJlbGVhc2VyXSA9IHlpZWxkIHRoaXMuX3NlbWFwaG9yZS5hY3F1aXJlKDEsIHByaW9yaXR5KTtcbiAgICAgICAgICAgIHJldHVybiByZWxlYXNlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJ1bkV4Y2x1c2l2ZShjYWxsYmFjaywgcHJpb3JpdHkgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUucnVuRXhjbHVzaXZlKCgpID0+IGNhbGxiYWNrKCksIDEsIHByaW9yaXR5KTtcbiAgICB9XG4gICAgaXNMb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUuaXNMb2NrZWQoKTtcbiAgICB9XG4gICAgd2FpdEZvclVubG9jayhwcmlvcml0eSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS53YWl0Rm9yVW5sb2NrKDEsIHByaW9yaXR5KTtcbiAgICB9XG4gICAgcmVsZWFzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbWFwaG9yZS5pc0xvY2tlZCgpKVxuICAgICAgICAgICAgdGhpcy5fc2VtYXBob3JlLnJlbGVhc2UoKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLmNhbmNlbCgpO1xuICAgIH1cbn1cblxudmFyIF9fYXdhaXRlciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gd2l0aFRpbWVvdXQoc3luYywgdGltZW91dCwgdGltZW91dEVycm9yID0gRV9USU1FT1VUKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWNxdWlyZTogKHdlaWdodE9yUHJpb3JpdHksIHByaW9yaXR5KSA9PiB7XG4gICAgICAgICAgICBsZXQgd2VpZ2h0O1xuICAgICAgICAgICAgaWYgKGlzU2VtYXBob3JlKHN5bmMpKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0T3JQcmlvcml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBwcmlvcml0eSA9IHdlaWdodE9yUHJpb3JpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2VpZ2h0ICE9PSB1bmRlZmluZWQgJiYgd2VpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlzVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aW1lb3V0RXJyb3IpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tldCA9IHlpZWxkIChpc1NlbWFwaG9yZShzeW5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzeW5jLmFjcXVpcmUod2VpZ2h0LCBwcmlvcml0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3luYy5hY3F1aXJlKHByaW9yaXR5KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGVhc2UgPSBBcnJheS5pc0FycmF5KHRpY2tldCkgPyB0aWNrZXRbMV0gOiB0aWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGlja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bkV4Y2x1c2l2ZShjYWxsYmFjaywgd2VpZ2h0LCBwcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVsZWFzZSA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWNrZXQgPSB5aWVsZCB0aGlzLmFjcXVpcmUod2VpZ2h0LCBwcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRpY2tldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UgPSB0aWNrZXRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2sodGlja2V0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UgPSB0aWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWxlYXNlKHdlaWdodCkge1xuICAgICAgICAgICAgc3luYy5yZWxlYXNlKHdlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW5jLmNhbmNlbCgpO1xuICAgICAgICB9LFxuICAgICAgICB3YWl0Rm9yVW5sb2NrOiAod2VpZ2h0T3JQcmlvcml0eSwgcHJpb3JpdHkpID0+IHtcbiAgICAgICAgICAgIGxldCB3ZWlnaHQ7XG4gICAgICAgICAgICBpZiAoaXNTZW1hcGhvcmUoc3luYykpIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHRPclByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gd2VpZ2h0T3JQcmlvcml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3ZWlnaHQgIT09IHVuZGVmaW5lZCAmJiB3ZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHt3ZWlnaHR9OiBtdXN0IGJlIHBvc2l0aXZlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KHRpbWVvdXRFcnJvciksIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIChpc1NlbWFwaG9yZShzeW5jKVxuICAgICAgICAgICAgICAgICAgICA/IHN5bmMud2FpdEZvclVubG9jayh3ZWlnaHQsIHByaW9yaXR5KVxuICAgICAgICAgICAgICAgICAgICA6IHN5bmMud2FpdEZvclVubG9jayhwcmlvcml0eSkpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzTG9ja2VkOiAoKSA9PiBzeW5jLmlzTG9ja2VkKCksXG4gICAgICAgIGdldFZhbHVlOiAoKSA9PiBzeW5jLmdldFZhbHVlKCksXG4gICAgICAgIHNldFZhbHVlOiAodmFsdWUpID0+IHN5bmMuc2V0VmFsdWUodmFsdWUpLFxuICAgIH07XG59XG5mdW5jdGlvbiBpc1NlbWFwaG9yZShzeW5jKSB7XG4gICAgcmV0dXJuIHN5bmMuZ2V0VmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saXNuZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiB0cnlBY3F1aXJlKHN5bmMsIGFscmVhZHlBY3F1aXJlZEVycm9yID0gRV9BTFJFQURZX0xPQ0tFRCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIHdpdGhUaW1lb3V0KHN5bmMsIDAsIGFscmVhZHlBY3F1aXJlZEVycm9yKTtcbn1cblxuZXhwb3J0IHsgRV9BTFJFQURZX0xPQ0tFRCwgRV9DQU5DRUxFRCwgRV9USU1FT1VULCBNdXRleCwgU2VtYXBob3JlLCB0cnlBY3F1aXJlLCB3aXRoVGltZW91dCB9O1xuIiwiaW1wb3J0IHZtIGZyb20gJ3ZtJztcblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7SUhvb2tzfVxuICovXG5jbGFzcyBIb29rcyB7XG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgSG9va0NhbGxiYWNrXG4gICAqIEB0aGlzIHsqfEpzZXB9IHRoaXNcbiAgICogQHBhcmFtIHtKc2VwfSBlbnZcbiAgICogQHJldHVybnM6IHZvaWRcbiAgICovXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBjYWxsYmFjayB0byB0aGUgbGlzdCBvZiBjYWxsYmFja3MgZm9yIHRoZSBnaXZlbiBob29rLlxuICAgKlxuICAgKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGhvb2sgaXQgaXMgcmVnaXN0ZXJlZCBmb3IgaXMgcnVuLlxuICAgKlxuICAgKiBPbmUgY2FsbGJhY2sgZnVuY3Rpb24gY2FuIGJlIHJlZ2lzdGVyZWQgdG8gbXVsdGlwbGUgaG9va3MgYW5kIHRoZSBzYW1lIGhvb2sgbXVsdGlwbGUgdGltZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9vaywgb3IgYW4gb2JqZWN0IG9mIGNhbGxiYWNrcyBrZXllZCBieSBuYW1lXG4gICAqIEBwYXJhbSB7SG9va0NhbGxiYWNrfGJvb2xlYW59IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBnaXZlbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAqIEBwYXJhbSB7P2Jvb2xlYW59IFtmaXJzdD1mYWxzZV0gV2lsbCBhZGQgdGhlIGhvb2sgdG8gdGhlIHRvcCBvZiB0aGUgbGlzdCAoZGVmYXVsdHMgdG8gdGhlIGJvdHRvbSlcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkKG5hbWUsIGNhbGxiYWNrLCBmaXJzdCkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdICE9ICdzdHJpbmcnKSB7XG4gICAgICAvLyBNdWx0aXBsZSBob29rIGNhbGxiYWNrcywga2V5ZWQgYnkgbmFtZVxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgdGhpcy5hZGQobmFtZSwgYXJndW1lbnRzWzBdW25hbWVdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoQXJyYXkuaXNBcnJheShuYW1lKSA/IG5hbWUgOiBbbmFtZV0pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpc1tuYW1lXSA9IHRoaXNbbmFtZV0gfHwgW107XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIHRoaXNbbmFtZV1bZmlyc3QgPyAndW5zaGlmdCcgOiAncHVzaCddKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSBob29rIGludm9raW5nIGFsbCByZWdpc3RlcmVkIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAqXG4gICAqIENhbGxiYWNrcyB3aWxsIGJlIGludm9rZWQgc3luY2hyb25vdXNseSBhbmQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9vay5cbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBlbnYgVGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvZiB0aGUgaG9vayBwYXNzZWQgdG8gYWxsIGNhbGxiYWNrcyByZWdpc3RlcmVkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBydW4obmFtZSwgZW52KSB7XG4gICAgdGhpc1tuYW1lXSA9IHRoaXNbbmFtZV0gfHwgW107XG4gICAgdGhpc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChlbnYgJiYgZW52LmNvbnRleHQgPyBlbnYuY29udGV4dCA6IGVudiwgZW52KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtJUGx1Z2luc31cbiAqL1xuY2xhc3MgUGx1Z2lucyB7XG4gIGNvbnN0cnVjdG9yKGpzZXApIHtcbiAgICB0aGlzLmpzZXAgPSBqc2VwO1xuICAgIHRoaXMucmVnaXN0ZXJlZCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBjYWxsYmFjayBQbHVnaW5TZXR1cFxuICAgKiBAdGhpcyB7SnNlcH0ganNlcFxuICAgKiBAcmV0dXJuczogdm9pZFxuICAgKi9cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIHBsdWdpbihzKSB0byB0aGUgcmVnaXN0cnlcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBsdWdpbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBsdWdpbnMubmFtZSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luXG4gICAqIEBwYXJhbSB7UGx1Z2luU2V0dXB9IHBsdWdpbnMuaW5pdCBUaGUgaW5pdCBmdW5jdGlvblxuICAgKiBAcHVibGljXG4gICAqL1xuICByZWdpc3RlciguLi5wbHVnaW5zKSB7XG4gICAgcGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbiAhPT0gJ29iamVjdCcgfHwgIXBsdWdpbi5uYW1lIHx8ICFwbHVnaW4uaW5pdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNFUCBwbHVnaW4gZm9ybWF0Jyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWdpc3RlcmVkW3BsdWdpbi5uYW1lXSkge1xuICAgICAgICAvLyBhbHJlYWR5IHJlZ2lzdGVyZWQuIElnbm9yZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGx1Z2luLmluaXQodGhpcy5qc2VwKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZFtwbHVnaW4ubmFtZV0gPSBwbHVnaW47XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gICAgIEphdmFTY3JpcHQgRXhwcmVzc2lvbiBQYXJzZXIgKEpTRVApIDEuNC4wXG5cbmNsYXNzIEpzZXAge1xuICAvKipcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgdmVyc2lvbigpIHtcbiAgICAvLyBUbyBiZSBmaWxsZWQgaW4gYnkgdGhlIHRlbXBsYXRlXG4gICAgcmV0dXJuICcxLjQuMCc7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0phdmFTY3JpcHQgRXhwcmVzc2lvbiBQYXJzZXIgKEpTRVApIHYnICsgSnNlcC52ZXJzaW9uO1xuICB9XG4gIC8vID09PT09PT09PT09PT09PT09PT09IENPTkZJRyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvKipcbiAgICogQG1ldGhvZCBhZGRVbmFyeU9wXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcF9uYW1lIFRoZSBuYW1lIG9mIHRoZSB1bmFyeSBvcCB0byBhZGRcbiAgICogQHJldHVybnMge0pzZXB9XG4gICAqL1xuICBzdGF0aWMgYWRkVW5hcnlPcChvcF9uYW1lKSB7XG4gICAgSnNlcC5tYXhfdW5vcF9sZW4gPSBNYXRoLm1heChvcF9uYW1lLmxlbmd0aCwgSnNlcC5tYXhfdW5vcF9sZW4pO1xuICAgIEpzZXAudW5hcnlfb3BzW29wX25hbWVdID0gMTtcbiAgICByZXR1cm4gSnNlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGpzZXAuYWRkQmluYXJ5T3BcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wX25hbWUgVGhlIG5hbWUgb2YgdGhlIGJpbmFyeSBvcCB0byBhZGRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByZWNlZGVuY2UgVGhlIHByZWNlZGVuY2Ugb2YgdGhlIGJpbmFyeSBvcCAoY2FuIGJlIGEgZmxvYXQpLiBIaWdoZXIgbnVtYmVyID0gaGlnaGVyIHByZWNlZGVuY2VcbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNSaWdodEFzc29jaWF0aXZlPWZhbHNlXSB3aGV0aGVyIG9wZXJhdG9yIGlzIHJpZ2h0LWFzc29jaWF0aXZlXG4gICAqIEByZXR1cm5zIHtKc2VwfVxuICAgKi9cbiAgc3RhdGljIGFkZEJpbmFyeU9wKG9wX25hbWUsIHByZWNlZGVuY2UsIGlzUmlnaHRBc3NvY2lhdGl2ZSkge1xuICAgIEpzZXAubWF4X2Jpbm9wX2xlbiA9IE1hdGgubWF4KG9wX25hbWUubGVuZ3RoLCBKc2VwLm1heF9iaW5vcF9sZW4pO1xuICAgIEpzZXAuYmluYXJ5X29wc1tvcF9uYW1lXSA9IHByZWNlZGVuY2U7XG4gICAgaWYgKGlzUmlnaHRBc3NvY2lhdGl2ZSkge1xuICAgICAgSnNlcC5yaWdodF9hc3NvY2lhdGl2ZS5hZGQob3BfbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEpzZXAucmlnaHRfYXNzb2NpYXRpdmUuZGVsZXRlKG9wX25hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gSnNlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFkZElkZW50aWZpZXJDaGFyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBhZGRpdGlvbmFsIGNoYXJhY3RlciB0byB0cmVhdCBhcyBhIHZhbGlkIHBhcnQgb2YgYW4gaWRlbnRpZmllclxuICAgKiBAcmV0dXJucyB7SnNlcH1cbiAgICovXG4gIHN0YXRpYyBhZGRJZGVudGlmaWVyQ2hhcihjaGFyKSB7XG4gICAgSnNlcC5hZGRpdGlvbmFsX2lkZW50aWZpZXJfY2hhcnMuYWRkKGNoYXIpO1xuICAgIHJldHVybiBKc2VwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYWRkTGl0ZXJhbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGl0ZXJhbF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBsaXRlcmFsIHRvIGFkZFxuICAgKiBAcGFyYW0geyp9IGxpdGVyYWxfdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBsaXRlcmFsXG4gICAqIEByZXR1cm5zIHtKc2VwfVxuICAgKi9cbiAgc3RhdGljIGFkZExpdGVyYWwobGl0ZXJhbF9uYW1lLCBsaXRlcmFsX3ZhbHVlKSB7XG4gICAgSnNlcC5saXRlcmFsc1tsaXRlcmFsX25hbWVdID0gbGl0ZXJhbF92YWx1ZTtcbiAgICByZXR1cm4gSnNlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlbW92ZVVuYXJ5T3BcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wX25hbWUgVGhlIG5hbWUgb2YgdGhlIHVuYXJ5IG9wIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJucyB7SnNlcH1cbiAgICovXG4gIHN0YXRpYyByZW1vdmVVbmFyeU9wKG9wX25hbWUpIHtcbiAgICBkZWxldGUgSnNlcC51bmFyeV9vcHNbb3BfbmFtZV07XG4gICAgaWYgKG9wX25hbWUubGVuZ3RoID09PSBKc2VwLm1heF91bm9wX2xlbikge1xuICAgICAgSnNlcC5tYXhfdW5vcF9sZW4gPSBKc2VwLmdldE1heEtleUxlbihKc2VwLnVuYXJ5X29wcyk7XG4gICAgfVxuICAgIHJldHVybiBKc2VwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVtb3ZlQWxsVW5hcnlPcHNcbiAgICogQHJldHVybnMge0pzZXB9XG4gICAqL1xuICBzdGF0aWMgcmVtb3ZlQWxsVW5hcnlPcHMoKSB7XG4gICAgSnNlcC51bmFyeV9vcHMgPSB7fTtcbiAgICBKc2VwLm1heF91bm9wX2xlbiA9IDA7XG4gICAgcmV0dXJuIEpzZXA7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZW1vdmVJZGVudGlmaWVyQ2hhclxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgYWRkaXRpb25hbCBjaGFyYWN0ZXIgdG8gc3RvcCB0cmVhdGluZyBhcyBhIHZhbGlkIHBhcnQgb2YgYW4gaWRlbnRpZmllclxuICAgKiBAcmV0dXJucyB7SnNlcH1cbiAgICovXG4gIHN0YXRpYyByZW1vdmVJZGVudGlmaWVyQ2hhcihjaGFyKSB7XG4gICAgSnNlcC5hZGRpdGlvbmFsX2lkZW50aWZpZXJfY2hhcnMuZGVsZXRlKGNoYXIpO1xuICAgIHJldHVybiBKc2VwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVtb3ZlQmluYXJ5T3BcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wX25hbWUgVGhlIG5hbWUgb2YgdGhlIGJpbmFyeSBvcCB0byByZW1vdmVcbiAgICogQHJldHVybnMge0pzZXB9XG4gICAqL1xuICBzdGF0aWMgcmVtb3ZlQmluYXJ5T3Aob3BfbmFtZSkge1xuICAgIGRlbGV0ZSBKc2VwLmJpbmFyeV9vcHNbb3BfbmFtZV07XG4gICAgaWYgKG9wX25hbWUubGVuZ3RoID09PSBKc2VwLm1heF9iaW5vcF9sZW4pIHtcbiAgICAgIEpzZXAubWF4X2Jpbm9wX2xlbiA9IEpzZXAuZ2V0TWF4S2V5TGVuKEpzZXAuYmluYXJ5X29wcyk7XG4gICAgfVxuICAgIEpzZXAucmlnaHRfYXNzb2NpYXRpdmUuZGVsZXRlKG9wX25hbWUpO1xuICAgIHJldHVybiBKc2VwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVtb3ZlQWxsQmluYXJ5T3BzXG4gICAqIEByZXR1cm5zIHtKc2VwfVxuICAgKi9cbiAgc3RhdGljIHJlbW92ZUFsbEJpbmFyeU9wcygpIHtcbiAgICBKc2VwLmJpbmFyeV9vcHMgPSB7fTtcbiAgICBKc2VwLm1heF9iaW5vcF9sZW4gPSAwO1xuICAgIHJldHVybiBKc2VwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVtb3ZlTGl0ZXJhbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGl0ZXJhbF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBsaXRlcmFsIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJucyB7SnNlcH1cbiAgICovXG4gIHN0YXRpYyByZW1vdmVMaXRlcmFsKGxpdGVyYWxfbmFtZSkge1xuICAgIGRlbGV0ZSBKc2VwLmxpdGVyYWxzW2xpdGVyYWxfbmFtZV07XG4gICAgcmV0dXJuIEpzZXA7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZW1vdmVBbGxMaXRlcmFsc1xuICAgKiBAcmV0dXJucyB7SnNlcH1cbiAgICovXG4gIHN0YXRpYyByZW1vdmVBbGxMaXRlcmFscygpIHtcbiAgICBKc2VwLmxpdGVyYWxzID0ge307XG4gICAgcmV0dXJuIEpzZXA7XG4gIH1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gRU5EIENPTkZJRyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgY2hhcigpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLmNoYXJBdCh0aGlzLmluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwci5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwciBhIHN0cmluZyB3aXRoIHRoZSBwYXNzZWQgaW4gZXhwcmVzc1xuICAgKiBAcmV0dXJucyBKc2VwXG4gICAqL1xuICBjb25zdHJ1Y3RvcihleHByKSB7XG4gICAgLy8gYGluZGV4YCBzdG9yZXMgdGhlIGNoYXJhY3RlciBudW1iZXIgd2UgYXJlIGN1cnJlbnRseSBhdFxuICAgIC8vIEFsbCBvZiB0aGUgZ29iYmxlcyBiZWxvdyB3aWxsIG1vZGlmeSBgaW5kZXhgIGFzIHdlIG1vdmUgYWxvbmdcbiAgICB0aGlzLmV4cHIgPSBleHByO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIHN0YXRpYyB0b3AtbGV2ZWwgcGFyc2VyXG4gICAqIEByZXR1cm5zIHtqc2VwLkV4cHJlc3Npb259XG4gICAqL1xuICBzdGF0aWMgcGFyc2UoZXhwcikge1xuICAgIHJldHVybiBuZXcgSnNlcChleHByKS5wYXJzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9uZ2VzdCBrZXkgbGVuZ3RoIG9mIGFueSBvYmplY3RcbiAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldE1heEtleUxlbihvYmopIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgLi4uT2JqZWN0LmtleXMob2JqKS5tYXAoayA9PiBrLmxlbmd0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIGBjaGAgaXMgYSBjaGFyYWN0ZXIgY29kZSBpbiB0aGUgbmV4dCB0aHJlZSBmdW5jdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNoXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDQ4ICYmIGNoIDw9IDU3OyAvLyAwLi4uOVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZWNlZGVuY2Ugb2YgYSBiaW5hcnkgb3BlcmF0b3Igb3IgYDBgIGlmIGl0IGlzbid0IGEgYmluYXJ5IG9wZXJhdG9yLiBDYW4gYmUgZmxvYXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcF92YWxcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBiaW5hcnlQcmVjZWRlbmNlKG9wX3ZhbCkge1xuICAgIHJldHVybiBKc2VwLmJpbmFyeV9vcHNbb3BfdmFsXSB8fCAwO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2tzIGZvciBzdGFydCBvZiBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0lkZW50aWZpZXJTdGFydChjaCkge1xuICAgIHJldHVybiBjaCA+PSA2NSAmJiBjaCA8PSA5MCB8fFxuICAgIC8vIEEuLi5aXG4gICAgY2ggPj0gOTcgJiYgY2ggPD0gMTIyIHx8XG4gICAgLy8gYS4uLnpcbiAgICBjaCA+PSAxMjggJiYgIUpzZXAuYmluYXJ5X29wc1tTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKV0gfHxcbiAgICAvLyBhbnkgbm9uLUFTQ0lJIHRoYXQgaXMgbm90IGFuIG9wZXJhdG9yXG4gICAgSnNlcC5hZGRpdGlvbmFsX2lkZW50aWZpZXJfY2hhcnMuaGFzKFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKTsgLy8gYWRkaXRpb25hbCBjaGFyYWN0ZXJzXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNoXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgICByZXR1cm4gSnNlcC5pc0lkZW50aWZpZXJTdGFydChjaCkgfHwgSnNlcC5pc0RlY2ltYWxEaWdpdChjaCk7XG4gIH1cblxuICAvKipcbiAgICogdGhyb3cgZXJyb3IgYXQgaW5kZXggb2YgdGhlIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICogQHRocm93c1xuICAgKi9cbiAgdGhyb3dFcnJvcihtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSArICcgYXQgY2hhcmFjdGVyICcgKyB0aGlzLmluZGV4KTtcbiAgICBlcnJvci5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgZXJyb3IuZGVzY3JpcHRpb24gPSBtZXNzYWdlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBhIGdpdmVuIGhvb2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtqc2VwLkV4cHJlc3Npb258ZmFsc2V9IFtub2RlXVxuICAgKiBAcmV0dXJucyB7P2pzZXAuRXhwcmVzc2lvbn1cbiAgICovXG4gIHJ1bkhvb2sobmFtZSwgbm9kZSkge1xuICAgIGlmIChKc2VwLmhvb2tzW25hbWVdKSB7XG4gICAgICBjb25zdCBlbnYgPSB7XG4gICAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAgIG5vZGVcbiAgICAgIH07XG4gICAgICBKc2VwLmhvb2tzLnJ1bihuYW1lLCBlbnYpO1xuICAgICAgcmV0dXJuIGVudi5ub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIGEgZ2l2ZW4gaG9vayB1bnRpbCBvbmUgcmV0dXJucyBhIG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybnMgez9qc2VwLkV4cHJlc3Npb259XG4gICAqL1xuICBzZWFyY2hIb29rKG5hbWUpIHtcbiAgICBpZiAoSnNlcC5ob29rc1tuYW1lXSkge1xuICAgICAgY29uc3QgZW52ID0ge1xuICAgICAgICBjb250ZXh0OiB0aGlzXG4gICAgICB9O1xuICAgICAgSnNlcC5ob29rc1tuYW1lXS5maW5kKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjay5jYWxsKGVudi5jb250ZXh0LCBlbnYpO1xuICAgICAgICByZXR1cm4gZW52Lm5vZGU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbnYubm9kZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVzaCBgaW5kZXhgIHVwIHRvIHRoZSBuZXh0IG5vbi1zcGFjZSBjaGFyYWN0ZXJcbiAgICovXG4gIGdvYmJsZVNwYWNlcygpIHtcbiAgICBsZXQgY2ggPSB0aGlzLmNvZGU7XG4gICAgLy8gV2hpdGVzcGFjZVxuICAgIHdoaWxlIChjaCA9PT0gSnNlcC5TUEFDRV9DT0RFIHx8IGNoID09PSBKc2VwLlRBQl9DT0RFIHx8IGNoID09PSBKc2VwLkxGX0NPREUgfHwgY2ggPT09IEpzZXAuQ1JfQ09ERSkge1xuICAgICAgY2ggPSB0aGlzLmV4cHIuY2hhckNvZGVBdCgrK3RoaXMuaW5kZXgpO1xuICAgIH1cbiAgICB0aGlzLnJ1bkhvb2soJ2dvYmJsZS1zcGFjZXMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb3AtbGV2ZWwgbWV0aG9kIHRvIHBhcnNlIGFsbCBleHByZXNzaW9ucyBhbmQgcmV0dXJucyBjb21wb3VuZCBvciBzaW5nbGUgbm9kZVxuICAgKiBAcmV0dXJucyB7anNlcC5FeHByZXNzaW9ufVxuICAgKi9cbiAgcGFyc2UoKSB7XG4gICAgdGhpcy5ydW5Ib29rKCdiZWZvcmUtYWxsJyk7XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLmdvYmJsZUV4cHJlc3Npb25zKCk7XG5cbiAgICAvLyBJZiB0aGVyZSdzIG9ubHkgb25lIGV4cHJlc3Npb24ganVzdCB0cnkgcmV0dXJuaW5nIHRoZSBleHByZXNzaW9uXG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzLmxlbmd0aCA9PT0gMSA/IG5vZGVzWzBdIDoge1xuICAgICAgdHlwZTogSnNlcC5DT01QT1VORCxcbiAgICAgIGJvZHk6IG5vZGVzXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5ydW5Ib29rKCdhZnRlci1hbGwnLCBub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0b3AtbGV2ZWwgcGFyc2VyIChidXQgY2FuIGJlIHJldXNlZCB3aXRoaW4gYXMgd2VsbClcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt1bnRpbElDb2RlXVxuICAgKiBAcmV0dXJucyB7anNlcC5FeHByZXNzaW9uW119XG4gICAqL1xuICBnb2JibGVFeHByZXNzaW9ucyh1bnRpbElDb2RlKSB7XG4gICAgbGV0IG5vZGVzID0gW10sXG4gICAgICBjaF9pLFxuICAgICAgbm9kZTtcbiAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMuZXhwci5sZW5ndGgpIHtcbiAgICAgIGNoX2kgPSB0aGlzLmNvZGU7XG5cbiAgICAgIC8vIEV4cHJlc3Npb25zIGNhbiBiZSBzZXBhcmF0ZWQgYnkgc2VtaWNvbG9ucywgY29tbWFzLCBvciBqdXN0IGluZmVycmVkIHdpdGhvdXQgYW55XG4gICAgICAvLyBzZXBhcmF0b3JzXG4gICAgICBpZiAoY2hfaSA9PT0gSnNlcC5TRU1DT0xfQ09ERSB8fCBjaF9pID09PSBKc2VwLkNPTU1BX0NPREUpIHtcbiAgICAgICAgdGhpcy5pbmRleCsrOyAvLyBpZ25vcmUgc2VwYXJhdG9yc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHJ5IHRvIGdvYmJsZSBlYWNoIGV4cHJlc3Npb24gaW5kaXZpZHVhbGx5XG4gICAgICAgIGlmIChub2RlID0gdGhpcy5nb2JibGVFeHByZXNzaW9uKCkpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIC8vIElmIHdlIHdlcmVuJ3QgYWJsZSB0byBmaW5kIGEgYmluYXJ5IGV4cHJlc3Npb24gYW5kIGFyZSBvdXQgb2Ygcm9vbSwgdGhlblxuICAgICAgICAgIC8vIHRoZSBleHByZXNzaW9uIHBhc3NlZCBpbiBwcm9iYWJseSBoYXMgdG9vIG11Y2hcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmluZGV4IDwgdGhpcy5leHByLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChjaF9pID09PSB1bnRpbElDb2RlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50aHJvd0Vycm9yKCdVbmV4cGVjdGVkIFwiJyArIHRoaXMuY2hhciArICdcIicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWFpbiBwYXJzaW5nIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJucyB7P2pzZXAuRXhwcmVzc2lvbn1cbiAgICovXG4gIGdvYmJsZUV4cHJlc3Npb24oKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc2VhcmNoSG9vaygnZ29iYmxlLWV4cHJlc3Npb24nKSB8fCB0aGlzLmdvYmJsZUJpbmFyeUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmdvYmJsZVNwYWNlcygpO1xuICAgIHJldHVybiB0aGlzLnJ1bkhvb2soJ2FmdGVyLWV4cHJlc3Npb24nLCBub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIHRoZSBvcGVyYXRpb24gcG9ydGlvbiBvZiB0aGUgc3RyaW5nIChlLmcuIGArYCwgYD09PWApXG4gICAqIFN0YXJ0IGJ5IHRha2luZyB0aGUgbG9uZ2VzdCBwb3NzaWJsZSBiaW5hcnkgb3BlcmF0aW9ucyAoMyBjaGFyYWN0ZXJzOiBgPT09YCwgYCE9PWAsIGA+Pj5gKVxuICAgKiBhbmQgbW92ZSBkb3duIGZyb20gMyB0byAyIHRvIDEgY2hhcmFjdGVyIHVudGlsIGEgbWF0Y2hpbmcgYmluYXJ5IG9wZXJhdGlvbiBpcyBmb3VuZFxuICAgKiB0aGVuLCByZXR1cm4gdGhhdCBiaW5hcnkgb3BlcmF0aW9uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8Ym9vbGVhbn1cbiAgICovXG4gIGdvYmJsZUJpbmFyeU9wKCkge1xuICAgIHRoaXMuZ29iYmxlU3BhY2VzKCk7XG4gICAgbGV0IHRvX2NoZWNrID0gdGhpcy5leHByLnN1YnN0cih0aGlzLmluZGV4LCBKc2VwLm1heF9iaW5vcF9sZW4pO1xuICAgIGxldCB0Y19sZW4gPSB0b19jaGVjay5sZW5ndGg7XG4gICAgd2hpbGUgKHRjX2xlbiA+IDApIHtcbiAgICAgIC8vIERvbid0IGFjY2VwdCBhIGJpbmFyeSBvcCB3aGVuIGl0IGlzIGFuIGlkZW50aWZpZXIuXG4gICAgICAvLyBCaW5hcnkgb3BzIHRoYXQgc3RhcnQgd2l0aCBhIGlkZW50aWZpZXItdmFsaWQgY2hhcmFjdGVyIG11c3QgYmUgZm9sbG93ZWRcbiAgICAgIC8vIGJ5IGEgbm9uIGlkZW50aWZpZXItcGFydCB2YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChKc2VwLmJpbmFyeV9vcHMuaGFzT3duUHJvcGVydHkodG9fY2hlY2spICYmICghSnNlcC5pc0lkZW50aWZpZXJTdGFydCh0aGlzLmNvZGUpIHx8IHRoaXMuaW5kZXggKyB0b19jaGVjay5sZW5ndGggPCB0aGlzLmV4cHIubGVuZ3RoICYmICFKc2VwLmlzSWRlbnRpZmllclBhcnQodGhpcy5leHByLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIHRvX2NoZWNrLmxlbmd0aCkpKSkge1xuICAgICAgICB0aGlzLmluZGV4ICs9IHRjX2xlbjtcbiAgICAgICAgcmV0dXJuIHRvX2NoZWNrO1xuICAgICAgfVxuICAgICAgdG9fY2hlY2sgPSB0b19jaGVjay5zdWJzdHIoMCwgLS10Y19sZW4pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgZ29iYmxpbmcgYW4gaW5kaXZpZHVhbCBleHByZXNzaW9uLFxuICAgKiBlLmcuIGAxYCwgYDErMmAsIGBhKyhiKjIpLU1hdGguc3FydCgyKWBcbiAgICogQHJldHVybnMgez9qc2VwLkJpbmFyeUV4cHJlc3Npb259XG4gICAqL1xuICBnb2JibGVCaW5hcnlFeHByZXNzaW9uKCkge1xuICAgIGxldCBub2RlLCBiaW9wLCBwcmVjLCBzdGFjaywgYmlvcF9pbmZvLCBsZWZ0LCByaWdodCwgaSwgY3VyX2Jpb3A7XG5cbiAgICAvLyBGaXJzdCwgdHJ5IHRvIGdldCB0aGUgbGVmdG1vc3QgdGhpbmdcbiAgICAvLyBUaGVuLCBjaGVjayB0byBzZWUgaWYgdGhlcmUncyBhIGJpbmFyeSBvcGVyYXRvciBvcGVyYXRpbmcgb24gdGhhdCBsZWZ0bW9zdCB0aGluZ1xuICAgIC8vIERvbid0IGdvYmJsZUJpbmFyeU9wIHdpdGhvdXQgYSBsZWZ0LWhhbmQtc2lkZVxuICAgIGxlZnQgPSB0aGlzLmdvYmJsZVRva2VuKCk7XG4gICAgaWYgKCFsZWZ0KSB7XG4gICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG4gICAgYmlvcCA9IHRoaXMuZ29iYmxlQmluYXJ5T3AoKTtcblxuICAgIC8vIElmIHRoZXJlIHdhc24ndCBhIGJpbmFyeSBvcGVyYXRvciwganVzdCByZXR1cm4gdGhlIGxlZnRtb3N0IG5vZGVcbiAgICBpZiAoIWJpb3ApIHtcbiAgICAgIHJldHVybiBsZWZ0O1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBzdGFydCBhIHN0YWNrIHRvIHByb3Blcmx5IHBsYWNlIHRoZSBiaW5hcnkgb3BlcmF0aW9ucyBpbiB0aGVpclxuICAgIC8vIHByZWNlZGVuY2Ugc3RydWN0dXJlXG4gICAgYmlvcF9pbmZvID0ge1xuICAgICAgdmFsdWU6IGJpb3AsXG4gICAgICBwcmVjOiBKc2VwLmJpbmFyeVByZWNlZGVuY2UoYmlvcCksXG4gICAgICByaWdodF9hOiBKc2VwLnJpZ2h0X2Fzc29jaWF0aXZlLmhhcyhiaW9wKVxuICAgIH07XG4gICAgcmlnaHQgPSB0aGlzLmdvYmJsZVRva2VuKCk7XG4gICAgaWYgKCFyaWdodCkge1xuICAgICAgdGhpcy50aHJvd0Vycm9yKFwiRXhwZWN0ZWQgZXhwcmVzc2lvbiBhZnRlciBcIiArIGJpb3ApO1xuICAgIH1cbiAgICBzdGFjayA9IFtsZWZ0LCBiaW9wX2luZm8sIHJpZ2h0XTtcblxuICAgIC8vIFByb3Blcmx5IGRlYWwgd2l0aCBwcmVjZWRlbmNlIHVzaW5nIFtyZWN1cnNpdmUgZGVzY2VudF0oaHR0cDovL3d3dy5lbmdyLm11bi5jYS9+dGhlby9NaXNjL2V4cF9wYXJzaW5nLmh0bSlcbiAgICB3aGlsZSAoYmlvcCA9IHRoaXMuZ29iYmxlQmluYXJ5T3AoKSkge1xuICAgICAgcHJlYyA9IEpzZXAuYmluYXJ5UHJlY2VkZW5jZShiaW9wKTtcbiAgICAgIGlmIChwcmVjID09PSAwKSB7XG4gICAgICAgIHRoaXMuaW5kZXggLT0gYmlvcC5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYmlvcF9pbmZvID0ge1xuICAgICAgICB2YWx1ZTogYmlvcCxcbiAgICAgICAgcHJlYyxcbiAgICAgICAgcmlnaHRfYTogSnNlcC5yaWdodF9hc3NvY2lhdGl2ZS5oYXMoYmlvcClcbiAgICAgIH07XG4gICAgICBjdXJfYmlvcCA9IGJpb3A7XG5cbiAgICAgIC8vIFJlZHVjZTogbWFrZSBhIGJpbmFyeSBleHByZXNzaW9uIGZyb20gdGhlIHRocmVlIHRvcG1vc3QgZW50cmllcy5cbiAgICAgIGNvbnN0IGNvbXBhcmVQcmV2ID0gcHJldiA9PiBiaW9wX2luZm8ucmlnaHRfYSAmJiBwcmV2LnJpZ2h0X2EgPyBwcmVjID4gcHJldi5wcmVjIDogcHJlYyA8PSBwcmV2LnByZWM7XG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMiAmJiBjb21wYXJlUHJldihzdGFja1tzdGFjay5sZW5ndGggLSAyXSkpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgYmlvcCA9IHN0YWNrLnBvcCgpLnZhbHVlO1xuICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgdHlwZTogSnNlcC5CSU5BUllfRVhQLFxuICAgICAgICAgIG9wZXJhdG9yOiBiaW9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgcmlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgc3RhY2sucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSB0aGlzLmdvYmJsZVRva2VuKCk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiRXhwZWN0ZWQgZXhwcmVzc2lvbiBhZnRlciBcIiArIGN1cl9iaW9wKTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnB1c2goYmlvcF9pbmZvLCBub2RlKTtcbiAgICB9XG4gICAgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgbm9kZSA9IHN0YWNrW2ldO1xuICAgIHdoaWxlIChpID4gMSkge1xuICAgICAgbm9kZSA9IHtcbiAgICAgICAgdHlwZTogSnNlcC5CSU5BUllfRVhQLFxuICAgICAgICBvcGVyYXRvcjogc3RhY2tbaSAtIDFdLnZhbHVlLFxuICAgICAgICBsZWZ0OiBzdGFja1tpIC0gMl0sXG4gICAgICAgIHJpZ2h0OiBub2RlXG4gICAgICB9O1xuICAgICAgaSAtPSAyO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbmRpdmlkdWFsIHBhcnQgb2YgYSBiaW5hcnkgZXhwcmVzc2lvbjpcbiAgICogZS5nLiBgZm9vLmJhcihiYXopYCwgYDFgLCBgXCJhYmNcImAsIGAoYSAlIDIpYCAoYmVjYXVzZSBpdCdzIGluIHBhcmVudGhlc2lzKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxqc2VwLkV4cHJlc3Npb259XG4gICAqL1xuICBnb2JibGVUb2tlbigpIHtcbiAgICBsZXQgY2gsIHRvX2NoZWNrLCB0Y19sZW4sIG5vZGU7XG4gICAgdGhpcy5nb2JibGVTcGFjZXMoKTtcbiAgICBub2RlID0gdGhpcy5zZWFyY2hIb29rKCdnb2JibGUtdG9rZW4nKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMucnVuSG9vaygnYWZ0ZXItdG9rZW4nLCBub2RlKTtcbiAgICB9XG4gICAgY2ggPSB0aGlzLmNvZGU7XG4gICAgaWYgKEpzZXAuaXNEZWNpbWFsRGlnaXQoY2gpIHx8IGNoID09PSBKc2VwLlBFUklPRF9DT0RFKSB7XG4gICAgICAvLyBDaGFyIGNvZGUgNDYgaXMgYSBkb3QgYC5gIHdoaWNoIGNhbiBzdGFydCBvZmYgYSBudW1lcmljIGxpdGVyYWxcbiAgICAgIHJldHVybiB0aGlzLmdvYmJsZU51bWVyaWNMaXRlcmFsKCk7XG4gICAgfVxuICAgIGlmIChjaCA9PT0gSnNlcC5TUVVPVEVfQ09ERSB8fCBjaCA9PT0gSnNlcC5EUVVPVEVfQ09ERSkge1xuICAgICAgLy8gU2luZ2xlIG9yIGRvdWJsZSBxdW90ZXNcbiAgICAgIG5vZGUgPSB0aGlzLmdvYmJsZVN0cmluZ0xpdGVyYWwoKTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSBKc2VwLk9CUkFDS19DT0RFKSB7XG4gICAgICBub2RlID0gdGhpcy5nb2JibGVBcnJheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b19jaGVjayA9IHRoaXMuZXhwci5zdWJzdHIodGhpcy5pbmRleCwgSnNlcC5tYXhfdW5vcF9sZW4pO1xuICAgICAgdGNfbGVuID0gdG9fY2hlY2subGVuZ3RoO1xuICAgICAgd2hpbGUgKHRjX2xlbiA+IDApIHtcbiAgICAgICAgLy8gRG9uJ3QgYWNjZXB0IGFuIHVuYXJ5IG9wIHdoZW4gaXQgaXMgYW4gaWRlbnRpZmllci5cbiAgICAgICAgLy8gVW5hcnkgb3BzIHRoYXQgc3RhcnQgd2l0aCBhIGlkZW50aWZpZXItdmFsaWQgY2hhcmFjdGVyIG11c3QgYmUgZm9sbG93ZWRcbiAgICAgICAgLy8gYnkgYSBub24gaWRlbnRpZmllci1wYXJ0IHZhbGlkIGNoYXJhY3RlclxuICAgICAgICBpZiAoSnNlcC51bmFyeV9vcHMuaGFzT3duUHJvcGVydHkodG9fY2hlY2spICYmICghSnNlcC5pc0lkZW50aWZpZXJTdGFydCh0aGlzLmNvZGUpIHx8IHRoaXMuaW5kZXggKyB0b19jaGVjay5sZW5ndGggPCB0aGlzLmV4cHIubGVuZ3RoICYmICFKc2VwLmlzSWRlbnRpZmllclBhcnQodGhpcy5leHByLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIHRvX2NoZWNrLmxlbmd0aCkpKSkge1xuICAgICAgICAgIHRoaXMuaW5kZXggKz0gdGNfbGVuO1xuICAgICAgICAgIGNvbnN0IGFyZ3VtZW50ID0gdGhpcy5nb2JibGVUb2tlbigpO1xuICAgICAgICAgIGlmICghYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcignbWlzc2luZyB1bmFyeU9wIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLnJ1bkhvb2soJ2FmdGVyLXRva2VuJywge1xuICAgICAgICAgICAgdHlwZTogSnNlcC5VTkFSWV9FWFAsXG4gICAgICAgICAgICBvcGVyYXRvcjogdG9fY2hlY2ssXG4gICAgICAgICAgICBhcmd1bWVudCxcbiAgICAgICAgICAgIHByZWZpeDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRvX2NoZWNrID0gdG9fY2hlY2suc3Vic3RyKDAsIC0tdGNfbGVuKTtcbiAgICAgIH1cbiAgICAgIGlmIChKc2VwLmlzSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgICBub2RlID0gdGhpcy5nb2JibGVJZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChKc2VwLmxpdGVyYWxzLmhhc093blByb3BlcnR5KG5vZGUubmFtZSkpIHtcbiAgICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgdHlwZTogSnNlcC5MSVRFUkFMLFxuICAgICAgICAgICAgdmFsdWU6IEpzZXAubGl0ZXJhbHNbbm9kZS5uYW1lXSxcbiAgICAgICAgICAgIHJhdzogbm9kZS5uYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLm5hbWUgPT09IEpzZXAudGhpc19zdHIpIHtcbiAgICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgdHlwZTogSnNlcC5USElTX0VYUFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IEpzZXAuT1BBUkVOX0NPREUpIHtcbiAgICAgICAgLy8gb3BlbiBwYXJlbnRoZXNpc1xuICAgICAgICBub2RlID0gdGhpcy5nb2JibGVHcm91cCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bkhvb2soJ2FmdGVyLXRva2VuJywgZmFsc2UpO1xuICAgIH1cbiAgICBub2RlID0gdGhpcy5nb2JibGVUb2tlblByb3BlcnR5KG5vZGUpO1xuICAgIHJldHVybiB0aGlzLnJ1bkhvb2soJ2FmdGVyLXRva2VuJywgbm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogR29iYmxlIHByb3BlcnRpZXMgb2Ygb2YgaWRlbnRpZmllcnMvc3RyaW5ncy9hcnJheXMvZ3JvdXBzLlxuICAgKiBlLmcuIGBmb29gLCBgYmFyLmJhemAsIGBmb29bJ2JhciddLmJhemBcbiAgICogSXQgYWxzbyBnb2JibGVzIGZ1bmN0aW9uIGNhbGxzOlxuICAgKiBlLmcuIGBNYXRoLmFjb3Mob2JqLmFuZ2xlKWBcbiAgICogQHBhcmFtIHtqc2VwLkV4cHJlc3Npb259IG5vZGVcbiAgICogQHJldHVybnMge2pzZXAuRXhwcmVzc2lvbn1cbiAgICovXG4gIGdvYmJsZVRva2VuUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMuZ29iYmxlU3BhY2VzKCk7XG4gICAgbGV0IGNoID0gdGhpcy5jb2RlO1xuICAgIHdoaWxlIChjaCA9PT0gSnNlcC5QRVJJT0RfQ09ERSB8fCBjaCA9PT0gSnNlcC5PQlJBQ0tfQ09ERSB8fCBjaCA9PT0gSnNlcC5PUEFSRU5fQ09ERSB8fCBjaCA9PT0gSnNlcC5RVU1BUktfQ09ERSkge1xuICAgICAgbGV0IG9wdGlvbmFsO1xuICAgICAgaWYgKGNoID09PSBKc2VwLlFVTUFSS19DT0RFKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cHIuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkgIT09IEpzZXAuUEVSSU9EX0NPREUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25hbCA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5kZXggKz0gMjtcbiAgICAgICAgdGhpcy5nb2JibGVTcGFjZXMoKTtcbiAgICAgICAgY2ggPSB0aGlzLmNvZGU7XG4gICAgICB9XG4gICAgICB0aGlzLmluZGV4Kys7XG4gICAgICBpZiAoY2ggPT09IEpzZXAuT0JSQUNLX0NPREUpIHtcbiAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICB0eXBlOiBKc2VwLk1FTUJFUl9FWFAsXG4gICAgICAgICAgY29tcHV0ZWQ6IHRydWUsXG4gICAgICAgICAgb2JqZWN0OiBub2RlLFxuICAgICAgICAgIHByb3BlcnR5OiB0aGlzLmdvYmJsZUV4cHJlc3Npb24oKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIW5vZGUucHJvcGVydHkpIHtcbiAgICAgICAgICB0aGlzLnRocm93RXJyb3IoJ1VuZXhwZWN0ZWQgXCInICsgdGhpcy5jaGFyICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nb2JibGVTcGFjZXMoKTtcbiAgICAgICAgY2ggPSB0aGlzLmNvZGU7XG4gICAgICAgIGlmIChjaCAhPT0gSnNlcC5DQlJBQ0tfQ09ERSkge1xuICAgICAgICAgIHRoaXMudGhyb3dFcnJvcignVW5jbG9zZWQgWycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IEpzZXAuT1BBUkVOX0NPREUpIHtcbiAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIGlzIGJlaW5nIG1hZGU7IGdvYmJsZSBhbGwgdGhlIGFyZ3VtZW50c1xuICAgICAgICBub2RlID0ge1xuICAgICAgICAgIHR5cGU6IEpzZXAuQ0FMTF9FWFAsXG4gICAgICAgICAgJ2FyZ3VtZW50cyc6IHRoaXMuZ29iYmxlQXJndW1lbnRzKEpzZXAuQ1BBUkVOX0NPREUpLFxuICAgICAgICAgIGNhbGxlZTogbm9kZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gSnNlcC5QRVJJT0RfQ09ERSB8fCBvcHRpb25hbCkge1xuICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICB0aGlzLmluZGV4LS07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nb2JibGVTcGFjZXMoKTtcbiAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICB0eXBlOiBKc2VwLk1FTUJFUl9FWFAsXG4gICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgIG9iamVjdDogbm9kZSxcbiAgICAgICAgICBwcm9wZXJ0eTogdGhpcy5nb2JibGVJZGVudGlmaWVyKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIH0gLy8gZWxzZSBsZWF2ZSB1bmRlZmluZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBlc3ByaW1hXG5cbiAgICAgIHRoaXMuZ29iYmxlU3BhY2VzKCk7XG4gICAgICBjaCA9IHRoaXMuY29kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugc2ltcGxlIG51bWVyaWMgbGl0ZXJhbHM6IGAxMmAsIGAzLjRgLCBgLjVgLiBEbyB0aGlzIGJ5IHVzaW5nIGEgc3RyaW5nIHRvXG4gICAqIGtlZXAgdHJhY2sgb2YgZXZlcnl0aGluZyBpbiB0aGUgbnVtZXJpYyBsaXRlcmFsIGFuZCB0aGVuIGNhbGxpbmcgYHBhcnNlRmxvYXRgIG9uIHRoYXQgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtqc2VwLkxpdGVyYWx9XG4gICAqL1xuICBnb2JibGVOdW1lcmljTGl0ZXJhbCgpIHtcbiAgICBsZXQgbnVtYmVyID0gJycsXG4gICAgICBjaCxcbiAgICAgIGNoQ29kZTtcbiAgICB3aGlsZSAoSnNlcC5pc0RlY2ltYWxEaWdpdCh0aGlzLmNvZGUpKSB7XG4gICAgICBudW1iZXIgKz0gdGhpcy5leHByLmNoYXJBdCh0aGlzLmluZGV4KyspO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb2RlID09PSBKc2VwLlBFUklPRF9DT0RFKSB7XG4gICAgICAvLyBjYW4gc3RhcnQgd2l0aCBhIGRlY2ltYWwgbWFya2VyXG4gICAgICBudW1iZXIgKz0gdGhpcy5leHByLmNoYXJBdCh0aGlzLmluZGV4KyspO1xuICAgICAgd2hpbGUgKEpzZXAuaXNEZWNpbWFsRGlnaXQodGhpcy5jb2RlKSkge1xuICAgICAgICBudW1iZXIgKz0gdGhpcy5leHByLmNoYXJBdCh0aGlzLmluZGV4KyspO1xuICAgICAgfVxuICAgIH1cbiAgICBjaCA9IHRoaXMuY2hhcjtcbiAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAvLyBleHBvbmVudCBtYXJrZXJcbiAgICAgIG51bWJlciArPSB0aGlzLmV4cHIuY2hhckF0KHRoaXMuaW5kZXgrKyk7XG4gICAgICBjaCA9IHRoaXMuY2hhcjtcbiAgICAgIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHtcbiAgICAgICAgLy8gZXhwb25lbnQgc2lnblxuICAgICAgICBudW1iZXIgKz0gdGhpcy5leHByLmNoYXJBdCh0aGlzLmluZGV4KyspO1xuICAgICAgfVxuICAgICAgd2hpbGUgKEpzZXAuaXNEZWNpbWFsRGlnaXQodGhpcy5jb2RlKSkge1xuICAgICAgICAvLyBleHBvbmVudCBpdHNlbGZcbiAgICAgICAgbnVtYmVyICs9IHRoaXMuZXhwci5jaGFyQXQodGhpcy5pbmRleCsrKTtcbiAgICAgIH1cbiAgICAgIGlmICghSnNlcC5pc0RlY2ltYWxEaWdpdCh0aGlzLmV4cHIuY2hhckNvZGVBdCh0aGlzLmluZGV4IC0gMSkpKSB7XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcignRXhwZWN0ZWQgZXhwb25lbnQgKCcgKyBudW1iZXIgKyB0aGlzLmNoYXIgKyAnKScpO1xuICAgICAgfVxuICAgIH1cbiAgICBjaENvZGUgPSB0aGlzLmNvZGU7XG5cbiAgICAvLyBDaGVjayB0byBtYWtlIHN1cmUgdGhpcyBpc24ndCBhIHZhcmlhYmxlIG5hbWUgdGhhdCBzdGFydCB3aXRoIGEgbnVtYmVyICgxMjNhYmMpXG4gICAgaWYgKEpzZXAuaXNJZGVudGlmaWVyU3RhcnQoY2hDb2RlKSkge1xuICAgICAgdGhpcy50aHJvd0Vycm9yKCdWYXJpYWJsZSBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCBhIG51bWJlciAoJyArIG51bWJlciArIHRoaXMuY2hhciArICcpJyk7XG4gICAgfSBlbHNlIGlmIChjaENvZGUgPT09IEpzZXAuUEVSSU9EX0NPREUgfHwgbnVtYmVyLmxlbmd0aCA9PT0gMSAmJiBudW1iZXIuY2hhckNvZGVBdCgwKSA9PT0gSnNlcC5QRVJJT0RfQ09ERSkge1xuICAgICAgdGhpcy50aHJvd0Vycm9yKCdVbmV4cGVjdGVkIHBlcmlvZCcpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogSnNlcC5MSVRFUkFMLFxuICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKSxcbiAgICAgIHJhdzogbnVtYmVyXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBzdHJpbmcgbGl0ZXJhbCwgc3RhcmluZyB3aXRoIHNpbmdsZSBvciBkb3VibGUgcXVvdGVzIHdpdGggYmFzaWMgc3VwcG9ydCBmb3IgZXNjYXBlIGNvZGVzXG4gICAqIGUuZy4gYFwiaGVsbG8gd29ybGRcImAsIGAndGhpcyBpc1xcbkpTRVAnYFxuICAgKiBAcmV0dXJucyB7anNlcC5MaXRlcmFsfVxuICAgKi9cbiAgZ29iYmxlU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgY29uc3QgcXVvdGUgPSB0aGlzLmV4cHIuY2hhckF0KHRoaXMuaW5kZXgrKyk7XG4gICAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy5leHByLmxlbmd0aCkge1xuICAgICAgbGV0IGNoID0gdGhpcy5leHByLmNoYXJBdCh0aGlzLmluZGV4KyspO1xuICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAvLyBDaGVjayBmb3IgYWxsIG9mIHRoZSBjb21tb24gZXNjYXBlIGNvZGVzXG4gICAgICAgIGNoID0gdGhpcy5leHByLmNoYXJBdCh0aGlzLmluZGV4KyspO1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcYic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxmJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gY2g7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY2xvc2VkKSB7XG4gICAgICB0aGlzLnRocm93RXJyb3IoJ1VuY2xvc2VkIHF1b3RlIGFmdGVyIFwiJyArIHN0ciArICdcIicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogSnNlcC5MSVRFUkFMLFxuICAgICAgdmFsdWU6IHN0cixcbiAgICAgIHJhdzogdGhpcy5leHByLnN1YnN0cmluZyhzdGFydEluZGV4LCB0aGlzLmluZGV4KVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR29iYmxlcyBvbmx5IGlkZW50aWZpZXJzXG4gICAqIGUuZy46IGBmb29gLCBgX3ZhbHVlYCwgYCR4MWBcbiAgICogQWxzbywgdGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhhdCBpZGVudGlmaWVyIGlzIGEgbGl0ZXJhbDpcbiAgICogKGUuZy4gYHRydWVgLCBgZmFsc2VgLCBgbnVsbGApIG9yIGB0aGlzYFxuICAgKiBAcmV0dXJucyB7anNlcC5JZGVudGlmaWVyfVxuICAgKi9cbiAgZ29iYmxlSWRlbnRpZmllcigpIHtcbiAgICBsZXQgY2ggPSB0aGlzLmNvZGUsXG4gICAgICBzdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgaWYgKEpzZXAuaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICB0aGlzLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGhyb3dFcnJvcignVW5leHBlY3RlZCAnICsgdGhpcy5jaGFyKTtcbiAgICB9XG4gICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmV4cHIubGVuZ3RoKSB7XG4gICAgICBjaCA9IHRoaXMuY29kZTtcbiAgICAgIGlmIChKc2VwLmlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogSnNlcC5JREVOVElGSUVSLFxuICAgICAgbmFtZTogdGhpcy5leHByLnNsaWNlKHN0YXJ0LCB0aGlzLmluZGV4KVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR29iYmxlcyBhIGxpc3Qgb2YgYXJndW1lbnRzIHdpdGhpbiB0aGUgY29udGV4dCBvZiBhIGZ1bmN0aW9uIGNhbGxcbiAgICogb3IgYXJyYXkgbGl0ZXJhbC4gVGhpcyBmdW5jdGlvbiBhbHNvIGFzc3VtZXMgdGhhdCB0aGUgb3BlbmluZyBjaGFyYWN0ZXJcbiAgICogYChgIG9yIGBbYCBoYXMgYWxyZWFkeSBiZWVuIGdvYmJsZWQsIGFuZCBnb2JibGVzIGV4cHJlc3Npb25zIGFuZCBjb21tYXNcbiAgICogdW50aWwgdGhlIHRlcm1pbmF0b3IgY2hhcmFjdGVyIGApYCBvciBgXWAgaXMgZW5jb3VudGVyZWQuXG4gICAqIGUuZy4gYGZvbyhiYXIsIGJheilgLCBgbXlfZnVuYygpYCwgb3IgYFtiYXIsIGJhel1gXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXJtaW5hdGlvblxuICAgKiBAcmV0dXJucyB7anNlcC5FeHByZXNzaW9uW119XG4gICAqL1xuICBnb2JibGVBcmd1bWVudHModGVybWluYXRpb24pIHtcbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICAgIGxldCBzZXBhcmF0b3JfY291bnQgPSAwO1xuICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy5leHByLmxlbmd0aCkge1xuICAgICAgdGhpcy5nb2JibGVTcGFjZXMoKTtcbiAgICAgIGxldCBjaF9pID0gdGhpcy5jb2RlO1xuICAgICAgaWYgKGNoX2kgPT09IHRlcm1pbmF0aW9uKSB7XG4gICAgICAgIC8vIGRvbmUgcGFyc2luZ1xuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIGlmICh0ZXJtaW5hdGlvbiA9PT0gSnNlcC5DUEFSRU5fQ09ERSAmJiBzZXBhcmF0b3JfY291bnQgJiYgc2VwYXJhdG9yX2NvdW50ID49IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy50aHJvd0Vycm9yKCdVbmV4cGVjdGVkIHRva2VuICcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHRlcm1pbmF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNoX2kgPT09IEpzZXAuQ09NTUFfQ09ERSkge1xuICAgICAgICAvLyBiZXR3ZWVuIGV4cHJlc3Npb25zXG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgc2VwYXJhdG9yX2NvdW50Kys7XG4gICAgICAgIGlmIChzZXBhcmF0b3JfY291bnQgIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gbWlzc2luZyBhcmd1bWVudFxuICAgICAgICAgIGlmICh0ZXJtaW5hdGlvbiA9PT0gSnNlcC5DUEFSRU5fQ09ERSkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKCdVbmV4cGVjdGVkIHRva2VuICwnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRlcm1pbmF0aW9uID09PSBKc2VwLkNCUkFDS19DT0RFKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBhcmcgPSBhcmdzLmxlbmd0aDsgYXJnIDwgc2VwYXJhdG9yX2NvdW50OyBhcmcrKykge1xuICAgICAgICAgICAgICBhcmdzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoICE9PSBzZXBhcmF0b3JfY291bnQgJiYgc2VwYXJhdG9yX2NvdW50ICE9PSAwKSB7XG4gICAgICAgIC8vIE5PVEU6IGAmJiBzZXBhcmF0b3JfY291bnQgIT09IDBgIGFsbG93cyBmb3IgZWl0aGVyIGFsbCBjb21tYXMsIG9yIGFsbCBzcGFjZXMgYXMgYXJndW1lbnRzXG4gICAgICAgIHRoaXMudGhyb3dFcnJvcignRXhwZWN0ZWQgY29tbWEnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdvYmJsZUV4cHJlc3Npb24oKTtcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUudHlwZSA9PT0gSnNlcC5DT01QT1VORCkge1xuICAgICAgICAgIHRoaXMudGhyb3dFcnJvcignRXhwZWN0ZWQgY29tbWEnKTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY2xvc2VkKSB7XG4gICAgICB0aGlzLnRocm93RXJyb3IoJ0V4cGVjdGVkICcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHRlcm1pbmF0aW9uKSk7XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIGEgZ3JvdXAgb2YgdGhpbmdzIHdpdGhpbiBwYXJlbnRoZXNlcyBgKClgXG4gICAqIHRoYXQgaGF2ZSBubyBpZGVudGlmaWVyIGluIGZyb250IChzbyBub3QgYSBmdW5jdGlvbiBjYWxsKVxuICAgKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBpdCBuZWVkcyB0byBnb2JibGUgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXNcbiAgICogYW5kIHRoZW4gdHJpZXMgdG8gZ29iYmxlIGV2ZXJ5dGhpbmcgd2l0aGluIHRoYXQgcGFyZW50aGVzaXMsIGFzc3VtaW5nXG4gICAqIHRoYXQgdGhlIG5leHQgdGhpbmcgaXQgc2hvdWxkIHNlZSBpcyB0aGUgY2xvc2UgcGFyZW50aGVzaXMuIElmIG5vdCxcbiAgICogdGhlbiB0aGUgZXhwcmVzc2lvbiBwcm9iYWJseSBkb2Vzbid0IGhhdmUgYSBgKWBcbiAgICogQHJldHVybnMge2Jvb2xlYW58anNlcC5FeHByZXNzaW9ufVxuICAgKi9cbiAgZ29iYmxlR3JvdXAoKSB7XG4gICAgdGhpcy5pbmRleCsrO1xuICAgIGxldCBub2RlcyA9IHRoaXMuZ29iYmxlRXhwcmVzc2lvbnMoSnNlcC5DUEFSRU5fQ09ERSk7XG4gICAgaWYgKHRoaXMuY29kZSA9PT0gSnNlcC5DUEFSRU5fQ09ERSkge1xuICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgICB9IGVsc2UgaWYgKCFub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBKc2VwLlNFUVVFTkNFX0VYUCxcbiAgICAgICAgICBleHByZXNzaW9uczogbm9kZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50aHJvd0Vycm9yKCdVbmNsb3NlZCAoJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIEFycmF5IGxpdGVyYWxzIGBbMSwgMiwgM11gXG4gICAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGl0IG5lZWRzIHRvIGdvYmJsZSB0aGUgb3BlbmluZyBicmFja2V0XG4gICAqIGFuZCB0aGVuIHRyaWVzIHRvIGdvYmJsZSB0aGUgZXhwcmVzc2lvbnMgYXMgYXJndW1lbnRzLlxuICAgKiBAcmV0dXJucyB7anNlcC5BcnJheUV4cHJlc3Npb259XG4gICAqL1xuICBnb2JibGVBcnJheSgpIHtcbiAgICB0aGlzLmluZGV4Kys7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IEpzZXAuQVJSQVlfRVhQLFxuICAgICAgZWxlbWVudHM6IHRoaXMuZ29iYmxlQXJndW1lbnRzKEpzZXAuQ0JSQUNLX0NPREUpXG4gICAgfTtcbiAgfVxufVxuXG4vLyBTdGF0aWMgZmllbGRzOlxuY29uc3QgaG9va3MgPSBuZXcgSG9va3MoKTtcbk9iamVjdC5hc3NpZ24oSnNlcCwge1xuICBob29rcyxcbiAgcGx1Z2luczogbmV3IFBsdWdpbnMoSnNlcCksXG4gIC8vIE5vZGUgVHlwZXNcbiAgLy8gLS0tLS0tLS0tLVxuICAvLyBUaGlzIGlzIHRoZSBmdWxsIHNldCBvZiB0eXBlcyB0aGF0IGFueSBKU0VQIG5vZGUgY2FuIGJlLlxuICAvLyBTdG9yZSB0aGVtIGhlcmUgdG8gc2F2ZSBzcGFjZSB3aGVuIG1pbmlmaWVkXG4gIENPTVBPVU5EOiAnQ29tcG91bmQnLFxuICBTRVFVRU5DRV9FWFA6ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICBJREVOVElGSUVSOiAnSWRlbnRpZmllcicsXG4gIE1FTUJFUl9FWFA6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgTElURVJBTDogJ0xpdGVyYWwnLFxuICBUSElTX0VYUDogJ1RoaXNFeHByZXNzaW9uJyxcbiAgQ0FMTF9FWFA6ICdDYWxsRXhwcmVzc2lvbicsXG4gIFVOQVJZX0VYUDogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gIEJJTkFSWV9FWFA6ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgQVJSQVlfRVhQOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgVEFCX0NPREU6IDksXG4gIExGX0NPREU6IDEwLFxuICBDUl9DT0RFOiAxMyxcbiAgU1BBQ0VfQ09ERTogMzIsXG4gIFBFUklPRF9DT0RFOiA0NixcbiAgLy8gJy4nXG4gIENPTU1BX0NPREU6IDQ0LFxuICAvLyAnLCdcbiAgU1FVT1RFX0NPREU6IDM5LFxuICAvLyBzaW5nbGUgcXVvdGVcbiAgRFFVT1RFX0NPREU6IDM0LFxuICAvLyBkb3VibGUgcXVvdGVzXG4gIE9QQVJFTl9DT0RFOiA0MCxcbiAgLy8gKFxuICBDUEFSRU5fQ09ERTogNDEsXG4gIC8vIClcbiAgT0JSQUNLX0NPREU6IDkxLFxuICAvLyBbXG4gIENCUkFDS19DT0RFOiA5MyxcbiAgLy8gXVxuICBRVU1BUktfQ09ERTogNjMsXG4gIC8vID9cbiAgU0VNQ09MX0NPREU6IDU5LFxuICAvLyA7XG4gIENPTE9OX0NPREU6IDU4LFxuICAvLyA6XG5cbiAgLy8gT3BlcmF0aW9uc1xuICAvLyAtLS0tLS0tLS0tXG4gIC8vIFVzZSBhIHF1aWNrbHktYWNjZXNzaWJsZSBtYXAgdG8gc3RvcmUgYWxsIG9mIHRoZSB1bmFyeSBvcGVyYXRvcnNcbiAgLy8gVmFsdWVzIGFyZSBzZXQgdG8gYDFgIChpdCByZWFsbHkgZG9lc24ndCBtYXR0ZXIpXG4gIHVuYXJ5X29wczoge1xuICAgICctJzogMSxcbiAgICAnISc6IDEsXG4gICAgJ34nOiAxLFxuICAgICcrJzogMVxuICB9LFxuICAvLyBBbHNvIHVzZSBhIG1hcCBmb3IgdGhlIGJpbmFyeSBvcGVyYXRpb25zIGJ1dCBzZXQgdGhlaXIgdmFsdWVzIHRvIHRoZWlyXG4gIC8vIGJpbmFyeSBwcmVjZWRlbmNlIGZvciBxdWljayByZWZlcmVuY2UgKGhpZ2hlciBudW1iZXIgPSBoaWdoZXIgcHJlY2VkZW5jZSlcbiAgLy8gc2VlIFtPcmRlciBvZiBvcGVyYXRpb25zXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvT3BlcmF0b3JfUHJlY2VkZW5jZSlcbiAgYmluYXJ5X29wczoge1xuICAgICd8fCc6IDEsXG4gICAgJz8/JzogMSxcbiAgICAnJiYnOiAyLFxuICAgICd8JzogMyxcbiAgICAnXic6IDQsXG4gICAgJyYnOiA1LFxuICAgICc9PSc6IDYsXG4gICAgJyE9JzogNixcbiAgICAnPT09JzogNixcbiAgICAnIT09JzogNixcbiAgICAnPCc6IDcsXG4gICAgJz4nOiA3LFxuICAgICc8PSc6IDcsXG4gICAgJz49JzogNyxcbiAgICAnPDwnOiA4LFxuICAgICc+Pic6IDgsXG4gICAgJz4+Pic6IDgsXG4gICAgJysnOiA5LFxuICAgICctJzogOSxcbiAgICAnKic6IDEwLFxuICAgICcvJzogMTAsXG4gICAgJyUnOiAxMCxcbiAgICAnKionOiAxMVxuICB9LFxuICAvLyBzZXRzIHNwZWNpZmljIGJpbmFyeV9vcHMgYXMgcmlnaHQtYXNzb2NpYXRpdmVcbiAgcmlnaHRfYXNzb2NpYXRpdmU6IG5ldyBTZXQoWycqKiddKSxcbiAgLy8gQWRkaXRpb25hbCB2YWxpZCBpZGVudGlmaWVyIGNoYXJzLCBhcGFydCBmcm9tIGEteiwgQS1aIGFuZCAwLTkgKGV4Y2VwdCBvbiB0aGUgc3RhcnRpbmcgY2hhcilcbiAgYWRkaXRpb25hbF9pZGVudGlmaWVyX2NoYXJzOiBuZXcgU2V0KFsnJCcsICdfJ10pLFxuICAvLyBMaXRlcmFsc1xuICAvLyAtLS0tLS0tLS0tXG4gIC8vIFN0b3JlIHRoZSB2YWx1ZXMgdG8gcmV0dXJuIGZvciB0aGUgdmFyaW91cyBsaXRlcmFscyB3ZSBtYXkgZW5jb3VudGVyXG4gIGxpdGVyYWxzOiB7XG4gICAgJ3RydWUnOiB0cnVlLFxuICAgICdmYWxzZSc6IGZhbHNlLFxuICAgICdudWxsJzogbnVsbFxuICB9LFxuICAvLyBFeGNlcHQgZm9yIGB0aGlzYCwgd2hpY2ggaXMgc3BlY2lhbC4gVGhpcyBjb3VsZCBiZSBjaGFuZ2VkIHRvIHNvbWV0aGluZyBsaWtlIGAnc2VsZidgIGFzIHdlbGxcbiAgdGhpc19zdHI6ICd0aGlzJ1xufSk7XG5Kc2VwLm1heF91bm9wX2xlbiA9IEpzZXAuZ2V0TWF4S2V5TGVuKEpzZXAudW5hcnlfb3BzKTtcbkpzZXAubWF4X2Jpbm9wX2xlbiA9IEpzZXAuZ2V0TWF4S2V5TGVuKEpzZXAuYmluYXJ5X29wcyk7XG5cbi8vIEJhY2t3YXJkIENvbXBhdGliaWxpdHk6XG5jb25zdCBqc2VwID0gZXhwciA9PiBuZXcgSnNlcChleHByKS5wYXJzZSgpO1xuY29uc3Qgc3RkQ2xhc3NQcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNsYXNzIFRlc3Qge30pO1xuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoSnNlcCkuZmlsdGVyKHByb3AgPT4gIXN0ZENsYXNzUHJvcHMuaW5jbHVkZXMocHJvcCkgJiYganNlcFtwcm9wXSA9PT0gdW5kZWZpbmVkKS5mb3JFYWNoKG0gPT4ge1xuICBqc2VwW21dID0gSnNlcFttXTtcbn0pO1xuanNlcC5Kc2VwID0gSnNlcDsgLy8gYWxsb3dzIGZvciBjb25zdCB7IEpzZXAgfSA9IHJlcXVpcmUoJ2pzZXAnKTtcblxuY29uc3QgQ09ORElUSU9OQUxfRVhQID0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic7XG52YXIgdGVybmFyeSA9IHtcbiAgbmFtZTogJ3Rlcm5hcnknLFxuICBpbml0KGpzZXApIHtcbiAgICAvLyBUZXJuYXJ5IGV4cHJlc3Npb246IHRlc3QgPyBjb25zZXF1ZW50IDogYWx0ZXJuYXRlXG4gICAganNlcC5ob29rcy5hZGQoJ2FmdGVyLWV4cHJlc3Npb24nLCBmdW5jdGlvbiBnb2JibGVUZXJuYXJ5KGVudikge1xuICAgICAgaWYgKGVudi5ub2RlICYmIHRoaXMuY29kZSA9PT0ganNlcC5RVU1BUktfQ09ERSkge1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIGNvbnN0IHRlc3QgPSBlbnYubm9kZTtcbiAgICAgICAgY29uc3QgY29uc2VxdWVudCA9IHRoaXMuZ29iYmxlRXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAoIWNvbnNlcXVlbnQpIHtcbiAgICAgICAgICB0aGlzLnRocm93RXJyb3IoJ0V4cGVjdGVkIGV4cHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdvYmJsZVNwYWNlcygpO1xuICAgICAgICBpZiAodGhpcy5jb2RlID09PSBqc2VwLkNPTE9OX0NPREUpIHtcbiAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgY29uc3QgYWx0ZXJuYXRlID0gdGhpcy5nb2JibGVFeHByZXNzaW9uKCk7XG4gICAgICAgICAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcignRXhwZWN0ZWQgZXhwcmVzc2lvbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbnYubm9kZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IENPTkRJVElPTkFMX0VYUCxcbiAgICAgICAgICAgIHRlc3QsXG4gICAgICAgICAgICBjb25zZXF1ZW50LFxuICAgICAgICAgICAgYWx0ZXJuYXRlXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGNoZWNrIGZvciBvcGVyYXRvcnMgb2YgaGlnaGVyIHByaW9yaXR5IHRoYW4gdGVybmFyeSAoaS5lLiBhc3NpZ25tZW50KVxuICAgICAgICAgIC8vIGpzZXAgc2V0cyB8fCBhdCAxLCBhbmQgYXNzaWdubWVudCBhdCAwLjksIGFuZCBjb25kaXRpb25hbCBzaG91bGQgYmUgYmV0d2VlbiB0aGVtXG4gICAgICAgICAgaWYgKHRlc3Qub3BlcmF0b3IgJiYganNlcC5iaW5hcnlfb3BzW3Rlc3Qub3BlcmF0b3JdIDw9IDAuOSkge1xuICAgICAgICAgICAgbGV0IG5ld1Rlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgd2hpbGUgKG5ld1Rlc3QucmlnaHQub3BlcmF0b3IgJiYganNlcC5iaW5hcnlfb3BzW25ld1Rlc3QucmlnaHQub3BlcmF0b3JdIDw9IDAuOSkge1xuICAgICAgICAgICAgICBuZXdUZXN0ID0gbmV3VGVzdC5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudi5ub2RlLnRlc3QgPSBuZXdUZXN0LnJpZ2h0O1xuICAgICAgICAgICAgbmV3VGVzdC5yaWdodCA9IGVudi5ub2RlO1xuICAgICAgICAgICAgZW52Lm5vZGUgPSB0ZXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRocm93RXJyb3IoJ0V4cGVjdGVkIDonKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBBZGQgZGVmYXVsdCBwbHVnaW5zOlxuXG5qc2VwLnBsdWdpbnMucmVnaXN0ZXIodGVybmFyeSk7XG5cbmNvbnN0IEZTTEFTSF9DT0RFID0gNDc7IC8vICcvJ1xuY29uc3QgQlNMQVNIX0NPREUgPSA5MjsgLy8gJ1xcXFwnXG5cbnZhciBpbmRleCA9IHtcbiAgbmFtZTogJ3JlZ2V4JyxcbiAgaW5pdChqc2VwKSB7XG4gICAgLy8gUmVnZXggbGl0ZXJhbDogL2FiYzEyMy9pZ1xuICAgIGpzZXAuaG9va3MuYWRkKCdnb2JibGUtdG9rZW4nLCBmdW5jdGlvbiBnb2JibGVSZWdleExpdGVyYWwoZW52KSB7XG4gICAgICBpZiAodGhpcy5jb2RlID09PSBGU0xBU0hfQ09ERSkge1xuICAgICAgICBjb25zdCBwYXR0ZXJuSW5kZXggPSArK3RoaXMuaW5kZXg7XG4gICAgICAgIGxldCBpbkNoYXJTZXQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmV4cHIubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29kZSA9PT0gRlNMQVNIX0NPREUgJiYgIWluQ2hhclNldCkge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuZXhwci5zbGljZShwYXR0ZXJuSW5kZXgsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgbGV0IGZsYWdzID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAoKyt0aGlzLmluZGV4IDwgdGhpcy5leHByLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICAgICAgICBpZiAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMiAvLyBhLi4uelxuICAgICAgICAgICAgICB8fCBjb2RlID49IDY1ICYmIGNvZGUgPD0gOTAgLy8gQS4uLlpcbiAgICAgICAgICAgICAgfHwgY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgLy8gMC05XG4gICAgICAgICAgICAgICAgZmxhZ3MgKz0gdGhpcy5jaGFyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudi5ub2RlID0ge1xuICAgICAgICAgICAgICB0eXBlOiBqc2VwLkxJVEVSQUwsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICByYXc6IHRoaXMuZXhwci5zbGljZShwYXR0ZXJuSW5kZXggLSAxLCB0aGlzLmluZGV4KVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gYWxsb3cgLiBbXSBhbmQgKCkgYWZ0ZXIgcmVnZXg6IC9yZWdleC8udGVzdChhKVxuICAgICAgICAgICAgZW52Lm5vZGUgPSB0aGlzLmdvYmJsZVRva2VuUHJvcGVydHkoZW52Lm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIGVudi5ub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5jb2RlID09PSBqc2VwLk9CUkFDS19DT0RFKSB7XG4gICAgICAgICAgICBpbkNoYXJTZXQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5DaGFyU2V0ICYmIHRoaXMuY29kZSA9PT0ganNlcC5DQlJBQ0tfQ09ERSkge1xuICAgICAgICAgICAgaW5DaGFyU2V0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaW5kZXggKz0gdGhpcy5jb2RlID09PSBCU0xBU0hfQ09ERSA/IDIgOiAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcignVW5jbG9zZWQgUmVnZXgnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuY29uc3QgUExVU19DT0RFID0gNDM7IC8vICtcbmNvbnN0IE1JTlVTX0NPREUgPSA0NTsgLy8gLVxuXG5jb25zdCBwbHVnaW4gPSB7XG4gIG5hbWU6ICdhc3NpZ25tZW50JyxcbiAgYXNzaWdubWVudE9wZXJhdG9yczogbmV3IFNldChbJz0nLCAnKj0nLCAnKio9JywgJy89JywgJyU9JywgJys9JywgJy09JywgJzw8PScsICc+Pj0nLCAnPj4+PScsICcmPScsICdePScsICd8PScsICd8fD0nLCAnJiY9JywgJz8/PSddKSxcbiAgdXBkYXRlT3BlcmF0b3JzOiBbUExVU19DT0RFLCBNSU5VU19DT0RFXSxcbiAgYXNzaWdubWVudFByZWNlZGVuY2U6IDAuOSxcbiAgaW5pdChqc2VwKSB7XG4gICAgY29uc3QgdXBkYXRlTm9kZVR5cGVzID0gW2pzZXAuSURFTlRJRklFUiwganNlcC5NRU1CRVJfRVhQXTtcbiAgICBwbHVnaW4uYXNzaWdubWVudE9wZXJhdG9ycy5mb3JFYWNoKG9wID0+IGpzZXAuYWRkQmluYXJ5T3Aob3AsIHBsdWdpbi5hc3NpZ25tZW50UHJlY2VkZW5jZSwgdHJ1ZSkpO1xuICAgIGpzZXAuaG9va3MuYWRkKCdnb2JibGUtdG9rZW4nLCBmdW5jdGlvbiBnb2JibGVVcGRhdGVQcmVmaXgoZW52KSB7XG4gICAgICBjb25zdCBjb2RlID0gdGhpcy5jb2RlO1xuICAgICAgaWYgKHBsdWdpbi51cGRhdGVPcGVyYXRvcnMuc29tZShjID0+IGMgPT09IGNvZGUgJiYgYyA9PT0gdGhpcy5leHByLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpKSkge1xuICAgICAgICB0aGlzLmluZGV4ICs9IDI7XG4gICAgICAgIGVudi5ub2RlID0ge1xuICAgICAgICAgIHR5cGU6ICdVcGRhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgICBvcGVyYXRvcjogY29kZSA9PT0gUExVU19DT0RFID8gJysrJyA6ICctLScsXG4gICAgICAgICAgYXJndW1lbnQ6IHRoaXMuZ29iYmxlVG9rZW5Qcm9wZXJ0eSh0aGlzLmdvYmJsZUlkZW50aWZpZXIoKSksXG4gICAgICAgICAgcHJlZml4OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmICghZW52Lm5vZGUuYXJndW1lbnQgfHwgIXVwZGF0ZU5vZGVUeXBlcy5pbmNsdWRlcyhlbnYubm9kZS5hcmd1bWVudC50eXBlKSkge1xuICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihgVW5leHBlY3RlZCAke2Vudi5ub2RlLm9wZXJhdG9yfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAganNlcC5ob29rcy5hZGQoJ2FmdGVyLXRva2VuJywgZnVuY3Rpb24gZ29iYmxlVXBkYXRlUG9zdGZpeChlbnYpIHtcbiAgICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICBpZiAocGx1Z2luLnVwZGF0ZU9wZXJhdG9ycy5zb21lKGMgPT4gYyA9PT0gY29kZSAmJiBjID09PSB0aGlzLmV4cHIuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkpKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVOb2RlVHlwZXMuaW5jbHVkZXMoZW52Lm5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihgVW5leHBlY3RlZCAke2Vudi5ub2RlLm9wZXJhdG9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XG4gICAgICAgICAgZW52Lm5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiAnVXBkYXRlRXhwcmVzc2lvbicsXG4gICAgICAgICAgICBvcGVyYXRvcjogY29kZSA9PT0gUExVU19DT0RFID8gJysrJyA6ICctLScsXG4gICAgICAgICAgICBhcmd1bWVudDogZW52Lm5vZGUsXG4gICAgICAgICAgICBwcmVmaXg6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGpzZXAuaG9va3MuYWRkKCdhZnRlci1leHByZXNzaW9uJywgZnVuY3Rpb24gZ29iYmxlQXNzaWdubWVudChlbnYpIHtcbiAgICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgICAvLyBOb3RlOiBCaW5hcmllcyBjYW4gYmUgY2hhaW5lZCBpbiBhIHNpbmdsZSBleHByZXNzaW9uIHRvIHJlc3BlY3RcbiAgICAgICAgLy8gb3BlcmF0b3IgcHJlY2VkZW5jZSAoaS5lLiBhID0gYiA9IDEgKyAyICsgMylcbiAgICAgICAgLy8gVXBkYXRlIGFsbCBiaW5hcnkgYXNzaWdubWVudCBub2RlcyBpbiB0aGUgdHJlZVxuICAgICAgICB1cGRhdGVCaW5hcmllc1RvQXNzaWdubWVudHMoZW52Lm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUJpbmFyaWVzVG9Bc3NpZ25tZW50cyhub2RlKSB7XG4gICAgICBpZiAocGx1Z2luLmFzc2lnbm1lbnRPcGVyYXRvcnMuaGFzKG5vZGUub3BlcmF0b3IpKSB7XG4gICAgICAgIG5vZGUudHlwZSA9ICdBc3NpZ25tZW50RXhwcmVzc2lvbic7XG4gICAgICAgIHVwZGF0ZUJpbmFyaWVzVG9Bc3NpZ25tZW50cyhub2RlLmxlZnQpO1xuICAgICAgICB1cGRhdGVCaW5hcmllc1RvQXNzaWdubWVudHMobm9kZS5yaWdodCk7XG4gICAgICB9IGVsc2UgaWYgKCFub2RlLm9wZXJhdG9yKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMobm9kZSkuZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHVwZGF0ZUJpbmFyaWVzVG9Bc3NpZ25tZW50cyh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlIC0tIENvbnZlbmllbnQgKi9cblxuLy8gcmVnaXN0ZXIgcGx1Z2luc1xuanNlcC5wbHVnaW5zLnJlZ2lzdGVyKGluZGV4LCBwbHVnaW4pO1xuanNlcC5hZGRVbmFyeU9wKCd0eXBlb2YnKTtcbmpzZXAuYWRkTGl0ZXJhbCgnbnVsbCcsIG51bGwpO1xuanNlcC5hZGRMaXRlcmFsKCd1bmRlZmluZWQnLCB1bmRlZmluZWQpO1xuY29uc3QgQkxPQ0tFRF9QUk9UT19QUk9QRVJUSUVTID0gbmV3IFNldChbJ2NvbnN0cnVjdG9yJywgJ19fcHJvdG9fXycsICdfX2RlZmluZUdldHRlcl9fJywgJ19fZGVmaW5lU2V0dGVyX18nXSk7XG5jb25zdCBTYWZlRXZhbCA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7anNlcC5FeHByZXNzaW9ufSBhc3RcbiAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBzdWJzXG4gICAqL1xuICBldmFsQXN0KGFzdCwgc3Vicykge1xuICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnTG9naWNhbEV4cHJlc3Npb24nOlxuICAgICAgICByZXR1cm4gU2FmZUV2YWwuZXZhbEJpbmFyeUV4cHJlc3Npb24oYXN0LCBzdWJzKTtcbiAgICAgIGNhc2UgJ0NvbXBvdW5kJzpcbiAgICAgICAgcmV0dXJuIFNhZmVFdmFsLmV2YWxDb21wb3VuZChhc3QsIHN1YnMpO1xuICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgcmV0dXJuIFNhZmVFdmFsLmV2YWxDb25kaXRpb25hbEV4cHJlc3Npb24oYXN0LCBzdWJzKTtcbiAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxuICAgICAgICByZXR1cm4gU2FmZUV2YWwuZXZhbElkZW50aWZpZXIoYXN0LCBzdWJzKTtcbiAgICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgICByZXR1cm4gU2FmZUV2YWwuZXZhbExpdGVyYWwoYXN0LCBzdWJzKTtcbiAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICByZXR1cm4gU2FmZUV2YWwuZXZhbE1lbWJlckV4cHJlc3Npb24oYXN0LCBzdWJzKTtcbiAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiBTYWZlRXZhbC5ldmFsVW5hcnlFeHByZXNzaW9uKGFzdCwgc3Vicyk7XG4gICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICByZXR1cm4gU2FmZUV2YWwuZXZhbEFycmF5RXhwcmVzc2lvbihhc3QsIHN1YnMpO1xuICAgICAgY2FzZSAnQ2FsbEV4cHJlc3Npb24nOlxuICAgICAgICByZXR1cm4gU2FmZUV2YWwuZXZhbENhbGxFeHByZXNzaW9uKGFzdCwgc3Vicyk7XG4gICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiBTYWZlRXZhbC5ldmFsQXNzaWdubWVudEV4cHJlc3Npb24oYXN0LCBzdWJzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cbiAgfSxcbiAgZXZhbEJpbmFyeUV4cHJlc3Npb24oYXN0LCBzdWJzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgJ3x8JzogKGEsIGIpID0+IGEgfHwgYigpLFxuICAgICAgJyYmJzogKGEsIGIpID0+IGEgJiYgYigpLFxuICAgICAgJ3wnOiAoYSwgYikgPT4gYSB8IGIoKSxcbiAgICAgICdeJzogKGEsIGIpID0+IGEgXiBiKCksXG4gICAgICAnJic6IChhLCBiKSA9PiBhICYgYigpLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcSAtLSBBUElcbiAgICAgICc9PSc6IChhLCBiKSA9PiBhID09IGIoKSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXEgLS0gQVBJXG4gICAgICAnIT0nOiAoYSwgYikgPT4gYSAhPSBiKCksXG4gICAgICAnPT09JzogKGEsIGIpID0+IGEgPT09IGIoKSxcbiAgICAgICchPT0nOiAoYSwgYikgPT4gYSAhPT0gYigpLFxuICAgICAgJzwnOiAoYSwgYikgPT4gYSA8IGIoKSxcbiAgICAgICc+JzogKGEsIGIpID0+IGEgPiBiKCksXG4gICAgICAnPD0nOiAoYSwgYikgPT4gYSA8PSBiKCksXG4gICAgICAnPj0nOiAoYSwgYikgPT4gYSA+PSBiKCksXG4gICAgICAnPDwnOiAoYSwgYikgPT4gYSA8PCBiKCksXG4gICAgICAnPj4nOiAoYSwgYikgPT4gYSA+PiBiKCksXG4gICAgICAnPj4+JzogKGEsIGIpID0+IGEgPj4+IGIoKSxcbiAgICAgICcrJzogKGEsIGIpID0+IGEgKyBiKCksXG4gICAgICAnLSc6IChhLCBiKSA9PiBhIC0gYigpLFxuICAgICAgJyonOiAoYSwgYikgPT4gYSAqIGIoKSxcbiAgICAgICcvJzogKGEsIGIpID0+IGEgLyBiKCksXG4gICAgICAnJSc6IChhLCBiKSA9PiBhICUgYigpXG4gICAgfVthc3Qub3BlcmF0b3JdKFNhZmVFdmFsLmV2YWxBc3QoYXN0LmxlZnQsIHN1YnMpLCAoKSA9PiBTYWZlRXZhbC5ldmFsQXN0KGFzdC5yaWdodCwgc3VicykpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIGV2YWxDb21wb3VuZChhc3QsIHN1YnMpIHtcbiAgICBsZXQgbGFzdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXN0LmJvZHlbaV0udHlwZSA9PT0gJ0lkZW50aWZpZXInICYmIFsndmFyJywgJ2xldCcsICdjb25zdCddLmluY2x1ZGVzKGFzdC5ib2R5W2ldLm5hbWUpICYmIGFzdC5ib2R5W2kgKyAxXSAmJiBhc3QuYm9keVtpICsgMV0udHlwZSA9PT0gJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJykge1xuICAgICAgICAvLyB2YXIgeD0yOyBpcyBkZXRlY3RlZCBhc1xuICAgICAgICAvLyBbe0lkZW50aWZpZXIgdmFyfSwge0Fzc2lnbm1lbnRFeHByZXNzaW9uIHg9Mn1dXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAc3R5bGlzdGljL21heC1sZW4gLS0gTG9uZ1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29uYXJqcy91cGRhdGVkLWxvb3AtY291bnRlciAtLSBDb252ZW5pZW50XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4cHIgPSBhc3QuYm9keVtpXTtcbiAgICAgIGxhc3QgPSBTYWZlRXZhbC5ldmFsQXN0KGV4cHIsIHN1YnMpO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdDtcbiAgfSxcbiAgZXZhbENvbmRpdGlvbmFsRXhwcmVzc2lvbihhc3QsIHN1YnMpIHtcbiAgICBpZiAoU2FmZUV2YWwuZXZhbEFzdChhc3QudGVzdCwgc3VicykpIHtcbiAgICAgIHJldHVybiBTYWZlRXZhbC5ldmFsQXN0KGFzdC5jb25zZXF1ZW50LCBzdWJzKTtcbiAgICB9XG4gICAgcmV0dXJuIFNhZmVFdmFsLmV2YWxBc3QoYXN0LmFsdGVybmF0ZSwgc3Vicyk7XG4gIH0sXG4gIGV2YWxJZGVudGlmaWVyKGFzdCwgc3Vicykge1xuICAgIGlmIChPYmplY3QuaGFzT3duKHN1YnMsIGFzdC5uYW1lKSkge1xuICAgICAgcmV0dXJuIHN1YnNbYXN0Lm5hbWVdO1xuICAgIH1cbiAgICB0aHJvdyBSZWZlcmVuY2VFcnJvcihgJHthc3QubmFtZX0gaXMgbm90IGRlZmluZWRgKTtcbiAgfSxcbiAgZXZhbExpdGVyYWwoYXN0KSB7XG4gICAgcmV0dXJuIGFzdC52YWx1ZTtcbiAgfSxcbiAgZXZhbE1lbWJlckV4cHJlc3Npb24oYXN0LCBzdWJzKSB7XG4gICAgY29uc3QgcHJvcCA9IFN0cmluZyhcbiAgICAvLyBOT1RFOiBgU3RyaW5nKHZhbHVlKWAgdGhyb3dzIGVycm9yIHdoZW5cbiAgICAvLyB2YWx1ZSBoYXMgb3ZlcndyaXR0ZW4gdGhlIHRvU3RyaW5nIG1ldGhvZCB0byByZXR1cm4gbm9uLXN0cmluZ1xuICAgIC8vIGkuZS4gYHZhbHVlID0ge3RvU3RyaW5nOiAoKSA9PiBbXX1gXG4gICAgYXN0LmNvbXB1dGVkID8gU2FmZUV2YWwuZXZhbEFzdChhc3QucHJvcGVydHkpIC8vIGBvYmplY3RbcHJvcGVydHldYFxuICAgIDogYXN0LnByb3BlcnR5Lm5hbWUgLy8gYG9iamVjdC5wcm9wZXJ0eWAgcHJvcGVydHkgaXMgSWRlbnRpZmllclxuICAgICk7XG4gICAgY29uc3Qgb2JqID0gU2FmZUV2YWwuZXZhbEFzdChhc3Qub2JqZWN0LCBzdWJzKTtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoYENhbm5vdCByZWFkIHByb3BlcnRpZXMgb2YgJHtvYmp9IChyZWFkaW5nICcke3Byb3B9JylgKTtcbiAgICB9XG4gICAgaWYgKCFPYmplY3QuaGFzT3duKG9iaiwgcHJvcCkgJiYgQkxPQ0tFRF9QUk9UT19QUk9QRVJUSUVTLmhhcyhwcm9wKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKGBDYW5ub3QgcmVhZCBwcm9wZXJ0aWVzIG9mICR7b2JqfSAocmVhZGluZyAnJHtwcm9wfScpYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG9ialtwcm9wXTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHJlc3VsdC5iaW5kKG9iaik7IC8vIGFycm93IGZ1bmN0aW9ucyBhcmVuJ3QgYWZmZWN0ZWQgYnkgYmluZC5cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgZXZhbFVuYXJ5RXhwcmVzc2lvbihhc3QsIHN1YnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAnLSc6IGEgPT4gLVNhZmVFdmFsLmV2YWxBc3QoYSwgc3VicyksXG4gICAgICAnISc6IGEgPT4gIVNhZmVFdmFsLmV2YWxBc3QoYSwgc3VicyksXG4gICAgICAnfic6IGEgPT4gflNhZmVFdmFsLmV2YWxBc3QoYSwgc3VicyksXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW1wbGljaXQtY29lcmNpb24gLS0gQVBJXG4gICAgICAnKyc6IGEgPT4gK1NhZmVFdmFsLmV2YWxBc3QoYSwgc3VicyksXG4gICAgICB0eXBlb2Y6IGEgPT4gdHlwZW9mIFNhZmVFdmFsLmV2YWxBc3QoYSwgc3VicylcbiAgICB9W2FzdC5vcGVyYXRvcl0oYXN0LmFyZ3VtZW50KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBldmFsQXJyYXlFeHByZXNzaW9uKGFzdCwgc3Vicykge1xuICAgIHJldHVybiBhc3QuZWxlbWVudHMubWFwKGVsID0+IFNhZmVFdmFsLmV2YWxBc3QoZWwsIHN1YnMpKTtcbiAgfSxcbiAgZXZhbENhbGxFeHByZXNzaW9uKGFzdCwgc3Vicykge1xuICAgIGNvbnN0IGFyZ3MgPSBhc3QuYXJndW1lbnRzLm1hcChhcmcgPT4gU2FmZUV2YWwuZXZhbEFzdChhcmcsIHN1YnMpKTtcbiAgICBjb25zdCBmdW5jID0gU2FmZUV2YWwuZXZhbEFzdChhc3QuY2FsbGVlLCBzdWJzKTtcbiAgICAvLyBpZiAoZnVuYyA9PT0gRnVuY3Rpb24pIHtcbiAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjb25zdHJ1Y3RvciBpcyBkaXNhYmxlZCcpO1xuICAgIC8vIH1cbiAgICByZXR1cm4gZnVuYyguLi5hcmdzKTtcbiAgfSxcbiAgZXZhbEFzc2lnbm1lbnRFeHByZXNzaW9uKGFzdCwgc3Vicykge1xuICAgIGlmIChhc3QubGVmdC50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHRocm93IFN5bnRheEVycm9yKCdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGFzc2lnbm1lbnQnKTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBhc3QubGVmdC5uYW1lO1xuICAgIGNvbnN0IHZhbHVlID0gU2FmZUV2YWwuZXZhbEFzdChhc3QucmlnaHQsIHN1YnMpO1xuICAgIHN1YnNbaWRdID0gdmFsdWU7XG4gICAgcmV0dXJuIHN1YnNbaWRdO1xuICB9XG59O1xuXG4vKipcbiAqIEEgcmVwbGFjZW1lbnQgZm9yIE5vZGVKUycgVk0uU2NyaXB0IHdoaWNoIGlzIGFsc28ge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQ1NQIHwgQ29udGVudCBTZWN1cml0eSBQb2xpY3l9IGZyaWVuZGx5LlxuICovXG5jbGFzcyBTYWZlU2NyaXB0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHByIEV4cHJlc3Npb24gdG8gZXZhbHVhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGV4cHIpIHtcbiAgICB0aGlzLmNvZGUgPSBleHByO1xuICAgIHRoaXMuYXN0ID0ganNlcCh0aGlzLmNvZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IE9iamVjdCB3aG9zZSBpdGVtcyB3aWxsIGJlIGFkZGVkXG4gICAqICAgdG8gZXZhbHVhdGlvblxuICAgKiBAcmV0dXJucyB7RXZhbHVhdGVkUmVzdWx0fSBSZXN1bHQgb2YgZXZhbHVhdGVkIGNvZGVcbiAgICovXG4gIHJ1bkluTmV3Q29udGV4dChjb250ZXh0KSB7XG4gICAgLy8gYE9iamVjdC5jcmVhdGUobnVsbClgIGNyZWF0ZXMgYSBwcm90b3R5cGVsZXNzIG9iamVjdFxuICAgIGNvbnN0IGtleU1hcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgY29udGV4dCk7XG4gICAgcmV0dXJuIFNhZmVFdmFsLmV2YWxBc3QodGhpcy5hc3QsIGtleU1hcCk7XG4gIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlIC0tIENvbnZlbmllbnQgZm9yIGVzY2FwaW5nICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7bnVsbHxib29sZWFufG51bWJlcnxzdHJpbmd8b2JqZWN0fEdlbmVyaWNBcnJheX0gSlNPTk9iamVjdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2FueX0gQW55SXRlbVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2FueX0gQW55UmVzdWx0XG4gKi9cblxuLyoqXG4gKiBDb3BpZXMgYXJyYXkgYW5kIHRoZW4gcHVzaGVzIGl0ZW0gaW50byBpdC5cbiAqIEBwYXJhbSB7R2VuZXJpY0FycmF5fSBhcnIgQXJyYXkgdG8gY29weSBhbmQgaW50byB3aGljaCB0byBwdXNoXG4gKiBAcGFyYW0ge0FueUl0ZW19IGl0ZW0gQXJyYXkgaXRlbSB0byBhZGQgKHRvIGVuZClcbiAqIEByZXR1cm5zIHtHZW5lcmljQXJyYXl9IENvcHkgb2YgdGhlIG9yaWdpbmFsIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHB1c2goYXJyLCBpdGVtKSB7XG4gIGFyciA9IGFyci5zbGljZSgpO1xuICBhcnIucHVzaChpdGVtKTtcbiAgcmV0dXJuIGFycjtcbn1cbi8qKlxuICogQ29waWVzIGFycmF5IGFuZCB0aGVuIHVuc2hpZnRzIGl0ZW0gaW50byBpdC5cbiAqIEBwYXJhbSB7QW55SXRlbX0gaXRlbSBBcnJheSBpdGVtIHRvIGFkZCAodG8gYmVnaW5uaW5nKVxuICogQHBhcmFtIHtHZW5lcmljQXJyYXl9IGFyciBBcnJheSB0byBjb3B5IGFuZCBpbnRvIHdoaWNoIHRvIHVuc2hpZnRcbiAqIEByZXR1cm5zIHtHZW5lcmljQXJyYXl9IENvcHkgb2YgdGhlIG9yaWdpbmFsIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVuc2hpZnQoaXRlbSwgYXJyKSB7XG4gIGFyciA9IGFyci5zbGljZSgpO1xuICBhcnIudW5zaGlmdChpdGVtKTtcbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBDYXVnaHQgd2hlbiBKU09OUGF0aCBpcyB1c2VkIHdpdGhvdXQgYG5ld2AgYnV0IHJldGhyb3duIGlmIHdpdGggYG5ld2BcbiAqIEBleHRlbmRzIEVycm9yXG4gKi9cbmNsYXNzIE5ld0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtBbnlSZXN1bHR9IHZhbHVlIFRoZSBldmFsdWF0ZWQgc2NhbGFyIHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKCdKU09OUGF0aCBzaG91bGQgbm90IGJlIGNhbGxlZCB3aXRoIFwibmV3XCIgKGl0IHByZXZlbnRzIHJldHVybiAnICsgJ29mICh1bndyYXBwZWQpIHNjYWxhciB2YWx1ZXMpJyk7XG4gICAgdGhpcy5hdm9pZE5ldyA9IHRydWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubmFtZSA9ICdOZXdFcnJvcic7XG4gIH1cbn1cblxuLyoqXG4qIEB0eXBlZGVmIHtvYmplY3R9IFJldHVybk9iamVjdFxuKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aFxuKiBAcHJvcGVydHkge0pTT05PYmplY3R9IHZhbHVlXG4qIEBwcm9wZXJ0eSB7b2JqZWN0fEdlbmVyaWNBcnJheX0gcGFyZW50XG4qIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXJlbnRQcm9wZXJ0eVxuKi9cblxuLyoqXG4qIEBjYWxsYmFjayBKU09OUGF0aENhbGxiYWNrXG4qIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcHJlZmVycmVkT3V0cHV0XG4qIEBwYXJhbSB7XCJ2YWx1ZVwifFwicHJvcGVydHlcIn0gdHlwZVxuKiBAcGFyYW0ge1JldHVybk9iamVjdH0gZnVsbFJldE9ialxuKiBAcmV0dXJucyB7dm9pZH1cbiovXG5cbi8qKlxuKiBAY2FsbGJhY2sgT3RoZXJUeXBlQ2FsbGJhY2tcbiogQHBhcmFtIHtKU09OT2JqZWN0fSB2YWxcbiogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiogQHBhcmFtIHtvYmplY3R8R2VuZXJpY0FycmF5fSBwYXJlbnRcbiogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFByb3BOYW1lXG4qIEByZXR1cm5zIHtib29sZWFufVxuKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7YW55fSBDb250ZXh0SXRlbVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2FueX0gRXZhbHVhdGVkUmVzdWx0XG4gKi9cblxuLyoqXG4qIEBjYWxsYmFjayBFdmFsQ2FsbGJhY2tcbiogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiogQHBhcmFtIHtDb250ZXh0SXRlbX0gY29udGV4dFxuKiBAcmV0dXJucyB7RXZhbHVhdGVkUmVzdWx0fVxuKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7dHlwZW9mIFNhZmVTY3JpcHR9IEV2YWxDbGFzc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gSlNPTlBhdGhPcHRpb25zXG4gKiBAcHJvcGVydHkge0pTT059IGpzb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoXG4gKiBAcHJvcGVydHkge1widmFsdWVcInxcInBhdGhcInxcInBvaW50ZXJcInxcInBhcmVudFwifFwicGFyZW50UHJvcGVydHlcInxcbiAqICAgXCJhbGxcIn0gW3Jlc3VsdFR5cGU9XCJ2YWx1ZVwiXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbZmxhdHRlbj1mYWxzZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXA9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbc2FuZGJveD17fV1cbiAqIEBwcm9wZXJ0eSB7RXZhbENhbGxiYWNrfEV2YWxDbGFzc3wnc2FmZSd8J25hdGl2ZSd8XG4gKiAgIGJvb2xlYW59IFtldmFsID0gJ3NhZmUnXVxuICogQHByb3BlcnR5IHtvYmplY3R8R2VuZXJpY0FycmF5fG51bGx9IFtwYXJlbnQ9bnVsbF1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtwYXJlbnRQcm9wZXJ0eT1udWxsXVxuICogQHByb3BlcnR5IHtKU09OUGF0aENhbGxiYWNrfSBbY2FsbGJhY2tdXG4gKiBAcHJvcGVydHkge090aGVyVHlwZUNhbGxiYWNrfSBbb3RoZXJUeXBlQ2FsbGJhY2tdIERlZmF1bHRzIHRvXG4gKiAgIGZ1bmN0aW9uIHdoaWNoIHRocm93cyBvbiBlbmNvdW50ZXJpbmcgYEBvdGhlcmBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F1dG9zdGFydD10cnVlXVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8SlNPTlBhdGhPcHRpb25zfSBvcHRzIElmIGEgc3RyaW5nLCB3aWxsIGJlIHRyZWF0ZWQgYXMgYGV4cHJgXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4cHJdIEpTT04gcGF0aCB0byBldmFsdWF0ZVxuICogQHBhcmFtIHtKU09OfSBbb2JqXSBKU09OIG9iamVjdCB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gKiBAcGFyYW0ge0pTT05QYXRoQ2FsbGJhY2t9IFtjYWxsYmFja10gUGFzc2VkIDMgYXJndW1lbnRzOiAxKSBkZXNpcmVkIHBheWxvYWRcbiAqICAgICBwZXIgYHJlc3VsdFR5cGVgLCAyKSBgXCJ2YWx1ZVwifFwicHJvcGVydHlcImAsIDMpIEZ1bGwgcmV0dXJuZWQgb2JqZWN0IHdpdGhcbiAqICAgICBhbGwgcGF5bG9hZHNcbiAqIEBwYXJhbSB7T3RoZXJUeXBlQ2FsbGJhY2t9IFtvdGhlclR5cGVDYWxsYmFja10gSWYgYEBvdGhlcigpYCBpcyBhdCB0aGUgZW5kXG4gKiAgIG9mIG9uZSdzIHF1ZXJ5LCB0aGlzIHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgaXRlbSwgaXRzXG4gKiAgIHBhdGgsIGl0cyBwYXJlbnQsIGFuZCBpdHMgcGFyZW50J3MgcHJvcGVydHkgbmFtZSwgYW5kIGl0IHNob3VsZCByZXR1cm5cbiAqICAgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3VwcGxpZWQgdmFsdWUgYmVsb25ncyB0byB0aGUgXCJvdGhlclwiXG4gKiAgIHR5cGUgb3Igbm90IChvciBpdCBtYXkgaGFuZGxlIHRyYW5zZm9ybWF0aW9ucyBhbmQgcmV0dXJuIGBmYWxzZWApLlxuICogQHJldHVybnMge0pTT05QYXRofVxuICogQGNsYXNzXG4gKi9cbmZ1bmN0aW9uIEpTT05QYXRoKG9wdHMsIGV4cHIsIG9iaiwgY2FsbGJhY2ssIG90aGVyVHlwZUNhbGxiYWNrKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCAtLSBBbGxvdyBmb3IgcHNldWRvLWNsYXNzXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBKU09OUGF0aCkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBKU09OUGF0aChvcHRzLCBleHByLCBvYmosIGNhbGxiYWNrLCBvdGhlclR5cGVDYWxsYmFjayk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFlLmF2b2lkTmV3KSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgIG90aGVyVHlwZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgY2FsbGJhY2sgPSBvYmo7XG4gICAgb2JqID0gZXhwcjtcbiAgICBleHByID0gb3B0cztcbiAgICBvcHRzID0gbnVsbDtcbiAgfVxuICBjb25zdCBvcHRPYmogPSBvcHRzICYmIHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JztcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMuanNvbiA9IG9wdHMuanNvbiB8fCBvYmo7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aCB8fCBleHByO1xuICB0aGlzLnJlc3VsdFR5cGUgPSBvcHRzLnJlc3VsdFR5cGUgfHwgJ3ZhbHVlJztcbiAgdGhpcy5mbGF0dGVuID0gb3B0cy5mbGF0dGVuIHx8IGZhbHNlO1xuICB0aGlzLndyYXAgPSBPYmplY3QuaGFzT3duKG9wdHMsICd3cmFwJykgPyBvcHRzLndyYXAgOiB0cnVlO1xuICB0aGlzLnNhbmRib3ggPSBvcHRzLnNhbmRib3ggfHwge307XG4gIHRoaXMuZXZhbCA9IG9wdHMuZXZhbCA9PT0gdW5kZWZpbmVkID8gJ3NhZmUnIDogb3B0cy5ldmFsO1xuICB0aGlzLmlnbm9yZUV2YWxFcnJvcnMgPSB0eXBlb2Ygb3B0cy5pZ25vcmVFdmFsRXJyb3JzID09PSAndW5kZWZpbmVkJyA/IGZhbHNlIDogb3B0cy5pZ25vcmVFdmFsRXJyb3JzO1xuICB0aGlzLnBhcmVudCA9IG9wdHMucGFyZW50IHx8IG51bGw7XG4gIHRoaXMucGFyZW50UHJvcGVydHkgPSBvcHRzLnBhcmVudFByb3BlcnR5IHx8IG51bGw7XG4gIHRoaXMuY2FsbGJhY2sgPSBvcHRzLmNhbGxiYWNrIHx8IGNhbGxiYWNrIHx8IG51bGw7XG4gIHRoaXMub3RoZXJUeXBlQ2FsbGJhY2sgPSBvcHRzLm90aGVyVHlwZUNhbGxiYWNrIHx8IG90aGVyVHlwZUNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBzdXBwbHkgYW4gb3RoZXJUeXBlQ2FsbGJhY2sgY2FsbGJhY2sgb3B0aW9uICcgKyAnd2l0aCB0aGUgQG90aGVyKCkgb3BlcmF0b3IuJyk7XG4gIH07XG4gIGlmIChvcHRzLmF1dG9zdGFydCAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgcGF0aDogb3B0T2JqID8gb3B0cy5wYXRoIDogZXhwclxuICAgIH07XG4gICAgaWYgKCFvcHRPYmopIHtcbiAgICAgIGFyZ3MuanNvbiA9IG9iajtcbiAgICB9IGVsc2UgaWYgKCdqc29uJyBpbiBvcHRzKSB7XG4gICAgICBhcmdzLmpzb24gPSBvcHRzLmpzb247XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHRoaXMuZXZhbHVhdGUoYXJncyk7XG4gICAgaWYgKCFyZXQgfHwgdHlwZW9mIHJldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBOZXdFcnJvcihyZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG5cbi8vIFBVQkxJQyBNRVRIT0RTXG5KU09OUGF0aC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoZXhwciwganNvbiwgY2FsbGJhY2ssIG90aGVyVHlwZUNhbGxiYWNrKSB7XG4gIGxldCBjdXJyUGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgY3VyclBhcmVudFByb3BlcnR5ID0gdGhpcy5wYXJlbnRQcm9wZXJ0eTtcbiAgbGV0IHtcbiAgICBmbGF0dGVuLFxuICAgIHdyYXBcbiAgfSA9IHRoaXM7XG4gIHRoaXMuY3VyclJlc3VsdFR5cGUgPSB0aGlzLnJlc3VsdFR5cGU7XG4gIHRoaXMuY3VyckV2YWwgPSB0aGlzLmV2YWw7XG4gIHRoaXMuY3VyclNhbmRib3ggPSB0aGlzLnNhbmRib3g7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgdGhpcy5jYWxsYmFjaztcbiAgdGhpcy5jdXJyT3RoZXJUeXBlQ2FsbGJhY2sgPSBvdGhlclR5cGVDYWxsYmFjayB8fCB0aGlzLm90aGVyVHlwZUNhbGxiYWNrO1xuICBqc29uID0ganNvbiB8fCB0aGlzLmpzb247XG4gIGV4cHIgPSBleHByIHx8IHRoaXMucGF0aDtcbiAgaWYgKGV4cHIgJiYgdHlwZW9mIGV4cHIgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGV4cHIpKSB7XG4gICAgaWYgKCFleHByLnBhdGggJiYgZXhwci5wYXRoICE9PSAnJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3Qgc3VwcGx5IGEgXCJwYXRoXCIgcHJvcGVydHkgd2hlbiBwcm92aWRpbmcgYW4gb2JqZWN0ICcgKyAnYXJndW1lbnQgdG8gSlNPTlBhdGguZXZhbHVhdGUoKS4nKTtcbiAgICB9XG4gICAgaWYgKCFPYmplY3QuaGFzT3duKGV4cHIsICdqc29uJykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhIFwianNvblwiIHByb3BlcnR5IHdoZW4gcHJvdmlkaW5nIGFuIG9iamVjdCAnICsgJ2FyZ3VtZW50IHRvIEpTT05QYXRoLmV2YWx1YXRlKCkuJyk7XG4gICAgfVxuICAgICh7XG4gICAgICBqc29uXG4gICAgfSA9IGV4cHIpO1xuICAgIGZsYXR0ZW4gPSBPYmplY3QuaGFzT3duKGV4cHIsICdmbGF0dGVuJykgPyBleHByLmZsYXR0ZW4gOiBmbGF0dGVuO1xuICAgIHRoaXMuY3VyclJlc3VsdFR5cGUgPSBPYmplY3QuaGFzT3duKGV4cHIsICdyZXN1bHRUeXBlJykgPyBleHByLnJlc3VsdFR5cGUgOiB0aGlzLmN1cnJSZXN1bHRUeXBlO1xuICAgIHRoaXMuY3VyclNhbmRib3ggPSBPYmplY3QuaGFzT3duKGV4cHIsICdzYW5kYm94JykgPyBleHByLnNhbmRib3ggOiB0aGlzLmN1cnJTYW5kYm94O1xuICAgIHdyYXAgPSBPYmplY3QuaGFzT3duKGV4cHIsICd3cmFwJykgPyBleHByLndyYXAgOiB3cmFwO1xuICAgIHRoaXMuY3VyckV2YWwgPSBPYmplY3QuaGFzT3duKGV4cHIsICdldmFsJykgPyBleHByLmV2YWwgOiB0aGlzLmN1cnJFdmFsO1xuICAgIGNhbGxiYWNrID0gT2JqZWN0Lmhhc093bihleHByLCAnY2FsbGJhY2snKSA/IGV4cHIuY2FsbGJhY2sgOiBjYWxsYmFjaztcbiAgICB0aGlzLmN1cnJPdGhlclR5cGVDYWxsYmFjayA9IE9iamVjdC5oYXNPd24oZXhwciwgJ290aGVyVHlwZUNhbGxiYWNrJykgPyBleHByLm90aGVyVHlwZUNhbGxiYWNrIDogdGhpcy5jdXJyT3RoZXJUeXBlQ2FsbGJhY2s7XG4gICAgY3VyclBhcmVudCA9IE9iamVjdC5oYXNPd24oZXhwciwgJ3BhcmVudCcpID8gZXhwci5wYXJlbnQgOiBjdXJyUGFyZW50O1xuICAgIGN1cnJQYXJlbnRQcm9wZXJ0eSA9IE9iamVjdC5oYXNPd24oZXhwciwgJ3BhcmVudFByb3BlcnR5JykgPyBleHByLnBhcmVudFByb3BlcnR5IDogY3VyclBhcmVudFByb3BlcnR5O1xuICAgIGV4cHIgPSBleHByLnBhdGg7XG4gIH1cbiAgY3VyclBhcmVudCA9IGN1cnJQYXJlbnQgfHwgbnVsbDtcbiAgY3VyclBhcmVudFByb3BlcnR5ID0gY3VyclBhcmVudFByb3BlcnR5IHx8IG51bGw7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cHIpKSB7XG4gICAgZXhwciA9IEpTT05QYXRoLnRvUGF0aFN0cmluZyhleHByKTtcbiAgfVxuICBpZiAoIWV4cHIgJiYgZXhwciAhPT0gJycgfHwgIWpzb24pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGV4cHJMaXN0ID0gSlNPTlBhdGgudG9QYXRoQXJyYXkoZXhwcik7XG4gIGlmIChleHByTGlzdFswXSA9PT0gJyQnICYmIGV4cHJMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICBleHByTGlzdC5zaGlmdCgpO1xuICB9XG4gIHRoaXMuX2hhc1BhcmVudFNlbGVjdG9yID0gbnVsbDtcbiAgY29uc3QgcmVzdWx0ID0gdGhpcy5fdHJhY2UoZXhwckxpc3QsIGpzb24sIFsnJCddLCBjdXJyUGFyZW50LCBjdXJyUGFyZW50UHJvcGVydHksIGNhbGxiYWNrKS5maWx0ZXIoZnVuY3Rpb24gKGVhKSB7XG4gICAgcmV0dXJuIGVhICYmICFlYS5pc1BhcmVudFNlbGVjdG9yO1xuICB9KTtcbiAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHdyYXAgPyBbXSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIXdyYXAgJiYgcmVzdWx0Lmxlbmd0aCA9PT0gMSAmJiAhcmVzdWx0WzBdLmhhc0FyckV4cHIpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UHJlZmVycmVkT3V0cHV0KHJlc3VsdFswXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5yZWR1Y2UoKHJzbHQsIGVhKSA9PiB7XG4gICAgY29uc3QgdmFsT3JQYXRoID0gdGhpcy5fZ2V0UHJlZmVycmVkT3V0cHV0KGVhKTtcbiAgICBpZiAoZmxhdHRlbiAmJiBBcnJheS5pc0FycmF5KHZhbE9yUGF0aCkpIHtcbiAgICAgIHJzbHQgPSByc2x0LmNvbmNhdCh2YWxPclBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByc2x0LnB1c2godmFsT3JQYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJzbHQ7XG4gIH0sIFtdKTtcbn07XG5cbi8vIFBSSVZBVEUgTUVUSE9EU1xuXG5KU09OUGF0aC5wcm90b3R5cGUuX2dldFByZWZlcnJlZE91dHB1dCA9IGZ1bmN0aW9uIChlYSkge1xuICBjb25zdCByZXN1bHRUeXBlID0gdGhpcy5jdXJyUmVzdWx0VHlwZTtcbiAgc3dpdGNoIChyZXN1bHRUeXBlKSB7XG4gICAgY2FzZSAnYWxsJzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IEFycmF5LmlzQXJyYXkoZWEucGF0aCkgPyBlYS5wYXRoIDogSlNPTlBhdGgudG9QYXRoQXJyYXkoZWEucGF0aCk7XG4gICAgICAgIGVhLnBvaW50ZXIgPSBKU09OUGF0aC50b1BvaW50ZXIocGF0aCk7XG4gICAgICAgIGVhLnBhdGggPSB0eXBlb2YgZWEucGF0aCA9PT0gJ3N0cmluZycgPyBlYS5wYXRoIDogSlNPTlBhdGgudG9QYXRoU3RyaW5nKGVhLnBhdGgpO1xuICAgICAgICByZXR1cm4gZWE7XG4gICAgICB9XG4gICAgY2FzZSAndmFsdWUnOlxuICAgIGNhc2UgJ3BhcmVudCc6XG4gICAgY2FzZSAncGFyZW50UHJvcGVydHknOlxuICAgICAgcmV0dXJuIGVhW3Jlc3VsdFR5cGVdO1xuICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgcmV0dXJuIEpTT05QYXRoLnRvUGF0aFN0cmluZyhlYVtyZXN1bHRUeXBlXSk7XG4gICAgY2FzZSAncG9pbnRlcic6XG4gICAgICByZXR1cm4gSlNPTlBhdGgudG9Qb2ludGVyKGVhLnBhdGgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIHJlc3VsdCB0eXBlJyk7XG4gIH1cbn07XG5KU09OUGF0aC5wcm90b3R5cGUuX2hhbmRsZUNhbGxiYWNrID0gZnVuY3Rpb24gKGZ1bGxSZXRPYmosIGNhbGxiYWNrLCB0eXBlKSB7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIGNvbnN0IHByZWZlcnJlZE91dHB1dCA9IHRoaXMuX2dldFByZWZlcnJlZE91dHB1dChmdWxsUmV0T2JqKTtcbiAgICBmdWxsUmV0T2JqLnBhdGggPSB0eXBlb2YgZnVsbFJldE9iai5wYXRoID09PSAnc3RyaW5nJyA/IGZ1bGxSZXRPYmoucGF0aCA6IEpTT05QYXRoLnRvUGF0aFN0cmluZyhmdWxsUmV0T2JqLnBhdGgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuL2NhbGxiYWNrLXJldHVybiAtLSBObyBuZWVkIHRvIHJldHVyblxuICAgIGNhbGxiYWNrKHByZWZlcnJlZE91dHB1dCwgdHlwZSwgZnVsbFJldE9iaik7XG4gIH1cbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByXG4gKiBAcGFyYW0ge0pTT05PYmplY3R9IHZhbFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fEdlbmVyaWNBcnJheX0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50UHJvcE5hbWVcbiAqIEBwYXJhbSB7SlNPTlBhdGhDYWxsYmFja30gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzQXJyRXhwclxuICogQHBhcmFtIHtib29sZWFufSBsaXRlcmFsUHJpb3JpdHlcbiAqIEByZXR1cm5zIHtSZXR1cm5PYmplY3R8UmV0dXJuT2JqZWN0W119XG4gKi9cbkpTT05QYXRoLnByb3RvdHlwZS5fdHJhY2UgPSBmdW5jdGlvbiAoZXhwciwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgaGFzQXJyRXhwciwgbGl0ZXJhbFByaW9yaXR5KSB7XG4gIC8vIE5vIGV4cHIgdG8gZm9sbG93PyByZXR1cm4gcGF0aCBhbmQgdmFsdWUgYXMgdGhlIHJlc3VsdCBvZlxuICAvLyAgdGhpcyB0cmFjZSBicmFuY2hcbiAgbGV0IHJldE9iajtcbiAgaWYgKCFleHByLmxlbmd0aCkge1xuICAgIHJldE9iaiA9IHtcbiAgICAgIHBhdGgsXG4gICAgICB2YWx1ZTogdmFsLFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50UHJvcGVydHk6IHBhcmVudFByb3BOYW1lLFxuICAgICAgaGFzQXJyRXhwclxuICAgIH07XG4gICAgdGhpcy5faGFuZGxlQ2FsbGJhY2socmV0T2JqLCBjYWxsYmFjaywgJ3ZhbHVlJyk7XG4gICAgcmV0dXJuIHJldE9iajtcbiAgfVxuICBjb25zdCBsb2MgPSBleHByWzBdLFxuICAgIHggPSBleHByLnNsaWNlKDEpO1xuXG4gIC8vIFdlIG5lZWQgdG8gZ2F0aGVyIHRoZSByZXR1cm4gdmFsdWUgb2YgcmVjdXJzaXZlIHRyYWNlIGNhbGxzIGluIG9yZGVyIHRvXG4gIC8vIGRvIHRoZSBwYXJlbnQgc2VsIGNvbXB1dGF0aW9uLlxuICBjb25zdCByZXQgPSBbXTtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7UmV0dXJuT2JqZWN0fFJldHVybk9iamVjdFtdfSBlbGVtc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIGFkZFJldChlbGVtcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1zKSkge1xuICAgICAgLy8gVGhpcyB3YXMgY2F1c2luZyBleGNlc3NpdmUgc3RhY2sgc2l6ZSBpbiBOb2RlICh3aXRoIG9yXG4gICAgICAvLyAgd2l0aG91dCBCYWJlbCkgYWdhaW5zdCBvdXIgcGVyZm9ybWFuY2UgdGVzdDpcbiAgICAgIC8vICBgcmV0LnB1c2goLi4uZWxlbXMpO2BcbiAgICAgIGVsZW1zLmZvckVhY2godCA9PiB7XG4gICAgICAgIHJldC5wdXNoKHQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wdXNoKGVsZW1zKTtcbiAgICB9XG4gIH1cbiAgaWYgKCh0eXBlb2YgbG9jICE9PSAnc3RyaW5nJyB8fCBsaXRlcmFsUHJpb3JpdHkpICYmIHZhbCAmJiBPYmplY3QuaGFzT3duKHZhbCwgbG9jKSkge1xuICAgIC8vIHNpbXBsZSBjYXNlLS1kaXJlY3RseSBmb2xsb3cgcHJvcGVydHlcbiAgICBhZGRSZXQodGhpcy5fdHJhY2UoeCwgdmFsW2xvY10sIHB1c2gocGF0aCwgbG9jKSwgdmFsLCBsb2MsIGNhbGxiYWNrLCBoYXNBcnJFeHByKSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLXN3aXRjaCAtLSBQYXJ0IG9mIGxhcmdlciBgaWZgXG4gIH0gZWxzZSBpZiAobG9jID09PSAnKicpIHtcbiAgICAvLyBhbGwgY2hpbGQgcHJvcGVydGllc1xuICAgIHRoaXMuX3dhbGsodmFsLCBtID0+IHtcbiAgICAgIGFkZFJldCh0aGlzLl90cmFjZSh4LCB2YWxbbV0sIHB1c2gocGF0aCwgbSksIHZhbCwgbSwgY2FsbGJhY2ssIHRydWUsIHRydWUpKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChsb2MgPT09ICcuLicpIHtcbiAgICAvLyBhbGwgZGVzY2VuZGVudCBwYXJlbnQgcHJvcGVydGllc1xuICAgIC8vIENoZWNrIHJlbWFpbmluZyBleHByZXNzaW9uIHdpdGggdmFsJ3MgaW1tZWRpYXRlIGNoaWxkcmVuXG4gICAgYWRkUmV0KHRoaXMuX3RyYWNlKHgsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIGhhc0FyckV4cHIpKTtcbiAgICB0aGlzLl93YWxrKHZhbCwgbSA9PiB7XG4gICAgICAvLyBXZSBkb24ndCBqb2luIG0gYW5kIHggaGVyZSBiZWNhdXNlIHdlIG9ubHkgd2FudCBwYXJlbnRzLFxuICAgICAgLy8gICBub3Qgc2NhbGFyIHZhbHVlc1xuICAgICAgaWYgKHR5cGVvZiB2YWxbbV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIEtlZXAgZ29pbmcgd2l0aCByZWN1cnNpdmUgZGVzY2VudCBvbiB2YWwnc1xuICAgICAgICAvLyAgIG9iamVjdCBjaGlsZHJlblxuICAgICAgICBhZGRSZXQodGhpcy5fdHJhY2UoZXhwci5zbGljZSgpLCB2YWxbbV0sIHB1c2gocGF0aCwgbSksIHZhbCwgbSwgY2FsbGJhY2ssIHRydWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBUaGUgcGFyZW50IHNlbCBjb21wdXRhdGlvbiBpcyBoYW5kbGVkIGluIHRoZSBmcmFtZSBhYm92ZSB1c2luZyB0aGVcbiAgICAvLyBhbmNlc3RvciBvYmplY3Qgb2YgdmFsXG4gIH0gZWxzZSBpZiAobG9jID09PSAnXicpIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBhIGZpbmFsIGVuZHBvaW50LCBzbyB3ZSBkbyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBoZXJlXG4gICAgdGhpcy5faGFzUGFyZW50U2VsZWN0b3IgPSB0cnVlO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLnNsaWNlKDAsIC0xKSxcbiAgICAgIGV4cHI6IHgsXG4gICAgICBpc1BhcmVudFNlbGVjdG9yOiB0cnVlXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsb2MgPT09ICd+Jykge1xuICAgIC8vIHByb3BlcnR5IG5hbWVcbiAgICByZXRPYmogPSB7XG4gICAgICBwYXRoOiBwdXNoKHBhdGgsIGxvYyksXG4gICAgICB2YWx1ZTogcGFyZW50UHJvcE5hbWUsXG4gICAgICBwYXJlbnQsXG4gICAgICBwYXJlbnRQcm9wZXJ0eTogbnVsbFxuICAgIH07XG4gICAgdGhpcy5faGFuZGxlQ2FsbGJhY2socmV0T2JqLCBjYWxsYmFjaywgJ3Byb3BlcnR5Jyk7XG4gICAgcmV0dXJuIHJldE9iajtcbiAgfSBlbHNlIGlmIChsb2MgPT09ICckJykge1xuICAgIC8vIHJvb3Qgb25seVxuICAgIGFkZFJldCh0aGlzLl90cmFjZSh4LCB2YWwsIHBhdGgsIG51bGwsIG51bGwsIGNhbGxiYWNrLCBoYXNBcnJFeHByKSk7XG4gIH0gZWxzZSBpZiAoL14oLT9cXGQqKTooLT9cXGQqKTo/KFxcZCopJC91LnRlc3QobG9jKSkge1xuICAgIC8vIFtzdGFydDplbmQ6c3RlcF0gIFB5dGhvbiBzbGljZSBzeW50YXhcbiAgICBhZGRSZXQodGhpcy5fc2xpY2UobG9jLCB4LCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrKSk7XG4gIH0gZWxzZSBpZiAobG9jLmluZGV4T2YoJz8oJykgPT09IDApIHtcbiAgICAvLyBbPyhleHByKV0gKGZpbHRlcmluZylcbiAgICBpZiAodGhpcy5jdXJyRXZhbCA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXZhbCBbPyhleHByKV0gcHJldmVudGVkIGluIEpTT05QYXRoIGV4cHJlc3Npb24uJyk7XG4gICAgfVxuICAgIGNvbnN0IHNhZmVMb2MgPSBsb2MucmVwbGFjZSgvXlxcP1xcKCguKj8pXFwpJC91LCAnJDEnKTtcbiAgICAvLyBjaGVjayBmb3IgYSBuZXN0ZWQgZmlsdGVyIGV4cHJlc3Npb25cbiAgICBjb25zdCBuZXN0ZWQgPSAvQC4/KFteP10qKVtbJ10oXFw/P1xcKC4qP1xcKSkoPyEuXFwpXFxdKVtcXF0nXS9ndS5leGVjKHNhZmVMb2MpO1xuICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgIC8vIGZpbmQgaWYgdGhlcmUgYXJlIG1hdGNoZXMgaW4gdGhlIG5lc3RlZCBleHByZXNzaW9uXG4gICAgICAvLyBhZGQgdGhlbSB0byB0aGUgcmVzdWx0IHNldCBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbWF0Y2hcbiAgICAgIHRoaXMuX3dhbGsodmFsLCBtID0+IHtcbiAgICAgICAgY29uc3QgbnBhdGggPSBbbmVzdGVkWzJdXTtcbiAgICAgICAgY29uc3QgbnZhbHVlID0gbmVzdGVkWzFdID8gdmFsW21dW25lc3RlZFsxXV0gOiB2YWxbbV07XG4gICAgICAgIGNvbnN0IGZpbHRlclJlc3VsdHMgPSB0aGlzLl90cmFjZShucGF0aCwgbnZhbHVlLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIGlmIChmaWx0ZXJSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhZGRSZXQodGhpcy5fdHJhY2UoeCwgdmFsW21dLCBwdXNoKHBhdGgsIG0pLCB2YWwsIG0sIGNhbGxiYWNrLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93YWxrKHZhbCwgbSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9ldmFsKHNhZmVMb2MsIHZhbFttXSwgbSwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSkpIHtcbiAgICAgICAgICBhZGRSZXQodGhpcy5fdHJhY2UoeCwgdmFsW21dLCBwdXNoKHBhdGgsIG0pLCB2YWwsIG0sIGNhbGxiYWNrLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsb2NbMF0gPT09ICcoJykge1xuICAgIC8vIFsoZXhwcildIChkeW5hbWljIHByb3BlcnR5L2luZGV4KVxuICAgIGlmICh0aGlzLmN1cnJFdmFsID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmFsIFsoZXhwcildIHByZXZlbnRlZCBpbiBKU09OUGF0aCBleHByZXNzaW9uLicpO1xuICAgIH1cbiAgICAvLyBBcyB0aGlzIHdpbGwgcmVzb2x2ZSB0byBhIHByb3BlcnR5IG5hbWUgKGJ1dCB3ZSBkb24ndCBrbm93IGl0XG4gICAgLy8gIHlldCksIHByb3BlcnR5IGFuZCBwYXJlbnQgaW5mb3JtYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlXG4gICAgLy8gIHBhcmVudCBvZiB0aGUgcHJvcGVydHkgdG8gd2hpY2ggdGhpcyBleHByZXNzaW9uIHdpbGwgcmVzb2x2ZVxuICAgIGFkZFJldCh0aGlzLl90cmFjZSh1bnNoaWZ0KHRoaXMuX2V2YWwobG9jLCB2YWwsIHBhdGguYXQoLTEpLCBwYXRoLnNsaWNlKDAsIC0xKSwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSksIHgpLCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCBoYXNBcnJFeHByKSk7XG4gIH0gZWxzZSBpZiAobG9jWzBdID09PSAnQCcpIHtcbiAgICAvLyB2YWx1ZSB0eXBlOiBAYm9vbGVhbigpLCBldGMuXG4gICAgbGV0IGFkZFR5cGUgPSBmYWxzZTtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSBsb2Muc2xpY2UoMSwgLTIpO1xuICAgIHN3aXRjaCAodmFsdWVUeXBlKSB7XG4gICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBpZiAoIXZhbCB8fCAhWydvYmplY3QnLCAnZnVuY3Rpb24nXS5pbmNsdWRlcyh0eXBlb2YgdmFsKSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IHZhbHVlVHlwZSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmFsKSAmJiAhKHZhbCAlIDEpKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbCkpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ25vbkZpbml0ZSc6XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhTnVtYmVyLmlzRmluaXRlKHZhbCkpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gdmFsdWVUeXBlKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ290aGVyJzpcbiAgICAgICAgYWRkVHlwZSA9IHRoaXMuY3Vyck90aGVyVHlwZUNhbGxiYWNrKHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gdmFsdWUgdHlwZSAnICsgdmFsdWVUeXBlKTtcbiAgICB9XG4gICAgaWYgKGFkZFR5cGUpIHtcbiAgICAgIHJldE9iaiA9IHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBwYXJlbnRQcm9wZXJ0eTogcGFyZW50UHJvcE5hbWVcbiAgICAgIH07XG4gICAgICB0aGlzLl9oYW5kbGVDYWxsYmFjayhyZXRPYmosIGNhbGxiYWNrLCAndmFsdWUnKTtcbiAgICAgIHJldHVybiByZXRPYmo7XG4gICAgfVxuICAgIC8vIGAtZXNjYXBlZCBwcm9wZXJ0eVxuICB9IGVsc2UgaWYgKGxvY1swXSA9PT0gJ2AnICYmIHZhbCAmJiBPYmplY3QuaGFzT3duKHZhbCwgbG9jLnNsaWNlKDEpKSkge1xuICAgIGNvbnN0IGxvY1Byb3AgPSBsb2Muc2xpY2UoMSk7XG4gICAgYWRkUmV0KHRoaXMuX3RyYWNlKHgsIHZhbFtsb2NQcm9wXSwgcHVzaChwYXRoLCBsb2NQcm9wKSwgdmFsLCBsb2NQcm9wLCBjYWxsYmFjaywgaGFzQXJyRXhwciwgdHJ1ZSkpO1xuICB9IGVsc2UgaWYgKGxvYy5pbmNsdWRlcygnLCcpKSB7XG4gICAgLy8gW25hbWUxLG5hbWUyLC4uLl1cbiAgICBjb25zdCBwYXJ0cyA9IGxvYy5zcGxpdCgnLCcpO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgYWRkUmV0KHRoaXMuX3RyYWNlKHVuc2hpZnQocGFydCwgeCksIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIHRydWUpKTtcbiAgICB9XG4gICAgLy8gc2ltcGxlIGNhc2UtLWRpcmVjdGx5IGZvbGxvdyBwcm9wZXJ0eVxuICB9IGVsc2UgaWYgKCFsaXRlcmFsUHJpb3JpdHkgJiYgdmFsICYmIE9iamVjdC5oYXNPd24odmFsLCBsb2MpKSB7XG4gICAgYWRkUmV0KHRoaXMuX3RyYWNlKHgsIHZhbFtsb2NdLCBwdXNoKHBhdGgsIGxvYyksIHZhbCwgbG9jLCBjYWxsYmFjaywgaGFzQXJyRXhwciwgdHJ1ZSkpO1xuICB9XG5cbiAgLy8gV2UgY2hlY2sgdGhlIHJlc3VsdGluZyB2YWx1ZXMgZm9yIHBhcmVudCBzZWxlY3Rpb25zLiBGb3IgcGFyZW50XG4gIC8vIHNlbGVjdGlvbnMgd2UgZGlzY2FyZCB0aGUgdmFsdWUgb2JqZWN0IGFuZCBjb250aW51ZSB0aGUgdHJhY2Ugd2l0aCB0aGVcbiAgLy8gY3VycmVudCB2YWwgb2JqZWN0XG4gIGlmICh0aGlzLl9oYXNQYXJlbnRTZWxlY3Rvcikge1xuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgcmV0Lmxlbmd0aDsgdCsrKSB7XG4gICAgICBjb25zdCByZXR0ID0gcmV0W3RdO1xuICAgICAgaWYgKHJldHQgJiYgcmV0dC5pc1BhcmVudFNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IHRoaXMuX3RyYWNlKHJldHQuZXhwciwgdmFsLCByZXR0LnBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCBoYXNBcnJFeHByKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG1wKSkge1xuICAgICAgICAgIHJldFt0XSA9IHRtcFswXTtcbiAgICAgICAgICBjb25zdCB0bCA9IHRtcC5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgdHQgPSAxOyB0dCA8IHRsOyB0dCsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHN0eWxpc3RpYy9tYXgtbGVuIC0tIExvbmdcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb25hcmpzL3VwZGF0ZWQtbG9vcC1jb3VudGVyIC0tIENvbnZlbmllbnRcbiAgICAgICAgICAgIHQrKztcbiAgICAgICAgICAgIHJldC5zcGxpY2UodCwgMCwgdG1wW3R0XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldFt0XSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbkpTT05QYXRoLnByb3RvdHlwZS5fd2FsayA9IGZ1bmN0aW9uICh2YWwsIGYpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGNvbnN0IG4gPSB2YWwubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBmKGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICBPYmplY3Qua2V5cyh2YWwpLmZvckVhY2gobSA9PiB7XG4gICAgICBmKG0pO1xuICAgIH0pO1xuICB9XG59O1xuSlNPTlBhdGgucHJvdG90eXBlLl9zbGljZSA9IGZ1bmN0aW9uIChsb2MsIGV4cHIsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGxlbiA9IHZhbC5sZW5ndGgsXG4gICAgcGFydHMgPSBsb2Muc3BsaXQoJzonKSxcbiAgICBzdGVwID0gcGFydHNbMl0gJiYgTnVtYmVyLnBhcnNlSW50KHBhcnRzWzJdKSB8fCAxO1xuICBsZXQgc3RhcnQgPSBwYXJ0c1swXSAmJiBOdW1iZXIucGFyc2VJbnQocGFydHNbMF0pIHx8IDAsXG4gICAgZW5kID0gcGFydHNbMV0gJiYgTnVtYmVyLnBhcnNlSW50KHBhcnRzWzFdKSB8fCBsZW47XG4gIHN0YXJ0ID0gc3RhcnQgPCAwID8gTWF0aC5tYXgoMCwgc3RhcnQgKyBsZW4pIDogTWF0aC5taW4obGVuLCBzdGFydCk7XG4gIGVuZCA9IGVuZCA8IDAgPyBNYXRoLm1heCgwLCBlbmQgKyBsZW4pIDogTWF0aC5taW4obGVuLCBlbmQpO1xuICBjb25zdCByZXQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IHN0ZXApIHtcbiAgICBjb25zdCB0bXAgPSB0aGlzLl90cmFjZSh1bnNoaWZ0KGksIGV4cHIpLCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAvLyBTaG91bGQgb25seSBiZSBwb3NzaWJsZSB0byBiZSBhbiBhcnJheSBoZXJlIHNpbmNlIGZpcnN0IHBhcnQgb2ZcbiAgICAvLyAgIGBgdW5zaGlmdChpLCBleHByKWAgcGFzc2VkIGluIGFib3ZlIHdvdWxkIG5vdCBiZSBlbXB0eSwgbm9yIGB+YCxcbiAgICAvLyAgICAgbm9yIGJlZ2luIHdpdGggYEBgIChhcyBjb3VsZCByZXR1cm4gb2JqZWN0cylcbiAgICAvLyBUaGlzIHdhcyBjYXVzaW5nIGV4Y2Vzc2l2ZSBzdGFjayBzaXplIGluIE5vZGUgKHdpdGggb3JcbiAgICAvLyAgd2l0aG91dCBCYWJlbCkgYWdhaW5zdCBvdXIgcGVyZm9ybWFuY2UgdGVzdDogYHJldC5wdXNoKC4uLnRtcCk7YFxuICAgIHRtcC5mb3JFYWNoKHQgPT4ge1xuICAgICAgcmV0LnB1c2godCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5KU09OUGF0aC5wcm90b3R5cGUuX2V2YWwgPSBmdW5jdGlvbiAoY29kZSwgX3YsIF92bmFtZSwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSkge1xuICB0aGlzLmN1cnJTYW5kYm94Ll8kX3BhcmVudFByb3BlcnR5ID0gcGFyZW50UHJvcE5hbWU7XG4gIHRoaXMuY3VyclNhbmRib3guXyRfcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmN1cnJTYW5kYm94Ll8kX3Byb3BlcnR5ID0gX3ZuYW1lO1xuICB0aGlzLmN1cnJTYW5kYm94Ll8kX3Jvb3QgPSB0aGlzLmpzb247XG4gIHRoaXMuY3VyclNhbmRib3guXyRfdiA9IF92O1xuICBjb25zdCBjb250YWluc1BhdGggPSBjb2RlLmluY2x1ZGVzKCdAcGF0aCcpO1xuICBpZiAoY29udGFpbnNQYXRoKSB7XG4gICAgdGhpcy5jdXJyU2FuZGJveC5fJF9wYXRoID0gSlNPTlBhdGgudG9QYXRoU3RyaW5nKHBhdGguY29uY2F0KFtfdm5hbWVdKSk7XG4gIH1cbiAgY29uc3Qgc2NyaXB0Q2FjaGVLZXkgPSB0aGlzLmN1cnJFdmFsICsgJ1NjcmlwdDonICsgY29kZTtcbiAgaWYgKCFKU09OUGF0aC5jYWNoZVtzY3JpcHRDYWNoZUtleV0pIHtcbiAgICBsZXQgc2NyaXB0ID0gY29kZS5yZXBsYWNlQWxsKCdAcGFyZW50UHJvcGVydHknLCAnXyRfcGFyZW50UHJvcGVydHknKS5yZXBsYWNlQWxsKCdAcGFyZW50JywgJ18kX3BhcmVudCcpLnJlcGxhY2VBbGwoJ0Bwcm9wZXJ0eScsICdfJF9wcm9wZXJ0eScpLnJlcGxhY2VBbGwoJ0Byb290JywgJ18kX3Jvb3QnKS5yZXBsYWNlQWxsKC9AKFsuXFxzKVtdKS9ndSwgJ18kX3YkMScpO1xuICAgIGlmIChjb250YWluc1BhdGgpIHtcbiAgICAgIHNjcmlwdCA9IHNjcmlwdC5yZXBsYWNlQWxsKCdAcGF0aCcsICdfJF9wYXRoJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJFdmFsID09PSAnc2FmZScgfHwgdGhpcy5jdXJyRXZhbCA9PT0gdHJ1ZSB8fCB0aGlzLmN1cnJFdmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIEpTT05QYXRoLmNhY2hlW3NjcmlwdENhY2hlS2V5XSA9IG5ldyB0aGlzLnNhZmVWbS5TY3JpcHQoc2NyaXB0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VyckV2YWwgPT09ICduYXRpdmUnKSB7XG4gICAgICBKU09OUGF0aC5jYWNoZVtzY3JpcHRDYWNoZUtleV0gPSBuZXcgdGhpcy52bS5TY3JpcHQoc2NyaXB0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmN1cnJFdmFsID09PSAnZnVuY3Rpb24nICYmIHRoaXMuY3VyckV2YWwucHJvdG90eXBlICYmIE9iamVjdC5oYXNPd24odGhpcy5jdXJyRXZhbC5wcm90b3R5cGUsICdydW5Jbk5ld0NvbnRleHQnKSkge1xuICAgICAgY29uc3QgQ3VyckV2YWwgPSB0aGlzLmN1cnJFdmFsO1xuICAgICAgSlNPTlBhdGguY2FjaGVbc2NyaXB0Q2FjaGVLZXldID0gbmV3IEN1cnJFdmFsKHNjcmlwdCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jdXJyRXZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgSlNPTlBhdGguY2FjaGVbc2NyaXB0Q2FjaGVLZXldID0ge1xuICAgICAgICBydW5Jbk5ld0NvbnRleHQ6IGNvbnRleHQgPT4gdGhpcy5jdXJyRXZhbChzY3JpcHQsIGNvbnRleHQpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIFwiZXZhbFwiIHByb3BlcnR5IFwiJHt0aGlzLmN1cnJFdmFsfVwiYCk7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT05QYXRoLmNhY2hlW3NjcmlwdENhY2hlS2V5XS5ydW5Jbk5ld0NvbnRleHQodGhpcy5jdXJyU2FuZGJveCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy5pZ25vcmVFdmFsRXJyb3JzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignanNvblBhdGg6ICcgKyBlLm1lc3NhZ2UgKyAnOiAnICsgY29kZSk7XG4gIH1cbn07XG5cbi8vIFBVQkxJQyBDTEFTUyBQUk9QRVJUSUVTIEFORCBNRVRIT0RTXG5cbi8vIENvdWxkIHN0b3JlIHRoZSBjYWNoZSBvYmplY3QgaXRzZWxmXG5KU09OUGF0aC5jYWNoZSA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhBcnIgQXJyYXkgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHBhdGggc3RyaW5nXG4gKi9cbkpTT05QYXRoLnRvUGF0aFN0cmluZyA9IGZ1bmN0aW9uIChwYXRoQXJyKSB7XG4gIGNvbnN0IHggPSBwYXRoQXJyLFxuICAgIG4gPSB4Lmxlbmd0aDtcbiAgbGV0IHAgPSAnJCc7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKCEvXih+fFxcXnxALio/XFwoXFwpKSQvdS50ZXN0KHhbaV0pKSB7XG4gICAgICBwICs9IC9eWzAtOSpdKyQvdS50ZXN0KHhbaV0pID8gJ1snICsgeFtpXSArICddJyA6IFwiWydcIiArIHhbaV0gKyBcIiddXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9pbnRlciBKU09OIFBhdGhcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEpTT04gUG9pbnRlclxuICovXG5KU09OUGF0aC50b1BvaW50ZXIgPSBmdW5jdGlvbiAocG9pbnRlcikge1xuICBjb25zdCB4ID0gcG9pbnRlcixcbiAgICBuID0geC5sZW5ndGg7XG4gIGxldCBwID0gJyc7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKCEvXih+fFxcXnxALio/XFwoXFwpKSQvdS50ZXN0KHhbaV0pKSB7XG4gICAgICBwICs9ICcvJyArIHhbaV0udG9TdHJpbmcoKS5yZXBsYWNlQWxsKCd+JywgJ34wJykucmVwbGFjZUFsbCgnLycsICd+MScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV4cHIgRXhwcmVzc2lvbiB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cbkpTT05QYXRoLnRvUGF0aEFycmF5ID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgY29uc3Qge1xuICAgIGNhY2hlXG4gIH0gPSBKU09OUGF0aDtcbiAgaWYgKGNhY2hlW2V4cHJdKSB7XG4gICAgcmV0dXJuIGNhY2hlW2V4cHJdLmNvbmNhdCgpO1xuICB9XG4gIGNvbnN0IHN1YnggPSBbXTtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IGV4cHJcbiAgLy8gUHJvcGVydGllc1xuICAucmVwbGFjZUFsbCgvQCg/Om51bGx8Ym9vbGVhbnxudW1iZXJ8c3RyaW5nfGludGVnZXJ8dW5kZWZpbmVkfG5vbkZpbml0ZXxzY2FsYXJ8YXJyYXl8b2JqZWN0fGZ1bmN0aW9ufG90aGVyKVxcKFxcKS9ndSwgJzskJjsnKVxuICAvLyBQYXJlbnRoZXRpY2FsIGV2YWx1YXRpb25zIChmaWx0ZXJpbmcgYW5kIG90aGVyd2lzZSksIGRpcmVjdGx5XG4gIC8vICAgd2l0aGluIGJyYWNrZXRzIG9yIHNpbmdsZSBxdW90ZXNcbiAgLnJlcGxhY2VBbGwoL1tbJ10oXFw/P1xcKC4qP1xcKSlbXFxdJ10oPyEuXFxdKS9ndSwgZnVuY3Rpb24gKCQwLCAkMSkge1xuICAgIHJldHVybiAnWyMnICsgKHN1YngucHVzaCgkMSkgLSAxKSArICddJztcbiAgfSlcbiAgLy8gRXNjYXBlIHBlcmlvZHMgYW5kIHRpbGRlcyB3aXRoaW4gcHJvcGVydGllc1xuICAucmVwbGFjZUFsbCgvXFxbWydcIl0oW14nXFxdXSopWydcIl1cXF0vZ3UsIGZ1bmN0aW9uICgkMCwgcHJvcCkge1xuICAgIHJldHVybiBcIlsnXCIgKyBwcm9wLnJlcGxhY2VBbGwoJy4nLCAnJUAlJykucmVwbGFjZUFsbCgnficsICclJUBAJSUnKSArIFwiJ11cIjtcbiAgfSlcbiAgLy8gUHJvcGVydGllcyBvcGVyYXRvclxuICAucmVwbGFjZUFsbCgnficsICc7fjsnKVxuICAvLyBTcGxpdCBieSBwcm9wZXJ0eSBib3VuZGFyaWVzXG4gIC5yZXBsYWNlQWxsKC9bJ1wiXT9cXC5bJ1wiXT8oPyFbXltdKlxcXSl8XFxbWydcIl0/L2d1LCAnOycpXG4gIC8vIFJlaW5zZXJ0IHBlcmlvZHMgd2l0aGluIHByb3BlcnRpZXNcbiAgLnJlcGxhY2VBbGwoJyVAJScsICcuJylcbiAgLy8gUmVpbnNlcnQgdGlsZGVzIHdpdGhpbiBwcm9wZXJ0aWVzXG4gIC5yZXBsYWNlQWxsKCclJUBAJSUnLCAnficpXG4gIC8vIFBhcmVudFxuICAucmVwbGFjZUFsbCgvKD86Oyk/KFxcXispKD86Oyk/L2d1LCBmdW5jdGlvbiAoJDAsIHVwcykge1xuICAgIHJldHVybiAnOycgKyB1cHMuc3BsaXQoJycpLmpvaW4oJzsnKSArICc7JztcbiAgfSlcbiAgLy8gRGVzY2VuZGVudHNcbiAgLnJlcGxhY2VBbGwoLzs7O3w7Oy9ndSwgJzsuLjsnKVxuICAvLyBSZW1vdmUgdHJhaWxpbmdcbiAgLnJlcGxhY2VBbGwoLzskfCc/XFxdfCckL2d1LCAnJyk7XG4gIGNvbnN0IGV4cHJMaXN0ID0gbm9ybWFsaXplZC5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAoZXhwKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleHAubWF0Y2goLyMoXFxkKykvdSk7XG4gICAgcmV0dXJuICFtYXRjaCB8fCAhbWF0Y2hbMV0gPyBleHAgOiBzdWJ4W21hdGNoWzFdXTtcbiAgfSk7XG4gIGNhY2hlW2V4cHJdID0gZXhwckxpc3Q7XG4gIHJldHVybiBjYWNoZVtleHByXS5jb25jYXQoKTtcbn07XG5KU09OUGF0aC5wcm90b3R5cGUuc2FmZVZtID0ge1xuICBTY3JpcHQ6IFNhZmVTY3JpcHRcbn07XG5cbkpTT05QYXRoLnByb3RvdHlwZS52bSA9IHZtO1xuXG5leHBvcnQgeyBKU09OUGF0aCB9O1xuIiwidmFyIEpyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIFhyID0gKHQsIGUsIG4pID0+IGUgaW4gdCA/IEpyKHQsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IG4gfSkgOiB0W2VdID0gbjtcbnZhciBXID0gKHQsIGUsIG4pID0+IFhyKHQsIHR5cGVvZiBlICE9IFwic3ltYm9sXCIgPyBlICsgXCJcIiA6IGUsIG4pO1xuaW1wb3J0IHsgTXV0ZXggYXMgWXIgfSBmcm9tIFwiYXN5bmMtbXV0ZXhcIjtcbmltcG9ydCB7IEpTT05QYXRoIGFzIFd0IH0gZnJvbSBcImpzb25wYXRoLXBsdXNcIjtcbmNsYXNzIFB1IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB2YXJpYWJsZU5hbWUgTmFtZSB0byB1c2Ugd2hlbiBsb2dnaW5nIGFib3V0IHRoaXMgdmFyaWFibGVcbiAgICogQHBhcmFtIHJlamVjdElmTm90U2V0dGxlZFdpdGhpbk1TIE1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSB2ZXJpZnlpbmcgaWYgdGhlIHByb21pc2Ugd2FzXG4gICAqICAgc2V0dGxlZCAocmVzb2x2ZWQgb3IgcmVqZWN0ZWQpOyB3aWxsIHJlamVjdCBpZiBpdCBoYXMgbm90IHNldHRsZWQgYnkgdGhhdCB0aW1lLiBVc2UgLTEgaWYgeW91XG4gICAqICAgZG8gbm90IHdhbnQgYSB0aW1lb3V0IGF0IGFsbC4gRGVmYXVsdHMgdG8gMTAwMDAgbXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIG4gPSAxZTQpIHtcbiAgICBXKHRoaXMsIFwidmFyaWFibGVOYW1lXCIpO1xuICAgIFcodGhpcywgXCJwcm9taXNlVG9WYWx1ZVwiKTtcbiAgICBXKHRoaXMsIFwicmVzb2x2ZXJcIik7XG4gICAgVyh0aGlzLCBcInJlamVjdGVyXCIpO1xuICAgIHRoaXMudmFyaWFibGVOYW1lID0gZSwgdGhpcy5wcm9taXNlVG9WYWx1ZSA9IG5ldyBQcm9taXNlKChpLCBvKSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmVyID0gaSwgdGhpcy5yZWplY3RlciA9IG87XG4gICAgfSksIG4gPiAwICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5yZWplY3RlciAmJiAodGhpcy5yZWplY3RlcihgVGltZW91dCByZWFjaGVkIHdoZW4gd2FpdGluZyBmb3IgJHt0aGlzLnZhcmlhYmxlTmFtZX0gdG8gc2V0dGxlYCksIHRoaXMuY29tcGxldGUoKSk7XG4gICAgfSwgbiksIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhpcyB2YXJpYWJsZSdzIHByb21pc2UgdG8gYSB2YWx1ZS4gVGhpcyBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSBwcm9taXNlIGV2ZW4gYWZ0ZXIgdGhlXG4gICAqIHZhbHVlIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIHRvIGJlIHNldFxuICAgKi9cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZVRvVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEEgc2ltcGxlIHdheSB0byBzZWUgaWYgdGhpcyB2YXJpYWJsZSdzIHByb21pc2Ugd2FzIHJlc29sdmVkIG9yIHJlamVjdGVkIGFscmVhZHlcbiAgICpcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgdmFyaWFibGUgd2FzIGFscmVhZHkgcmVzb2x2ZWQgb3IgcmVqZWN0ZWRcbiAgICovXG4gIGdldCBoYXNTZXR0bGVkKCkge1xuICAgIHJldHVybiBPYmplY3QuaXNGcm96ZW4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmUgdGhpcyB2YXJpYWJsZSdzIHByb21pc2UgdG8gdGhlIGdpdmVuIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGlzIHZhcmlhYmxlJ3MgcHJvbWlzZSB3aWxsIHJlc29sdmUgdG8gdGhpcyB2YWx1ZVxuICAgKiBAcGFyYW0gdGhyb3dJZkFscmVhZHlTZXR0bGVkIERldGVybWluZXMgd2hldGhlciB0byB0aHJvdyBpZiB0aGUgdmFyaWFibGUgd2FzIGFscmVhZHkgcmVzb2x2ZWRcbiAgICogICBvciByZWplY3RlZC4gRGVmYXVsdHMgdG8gYGZhbHNlYFxuICAgKi9cbiAgcmVzb2x2ZVRvVmFsdWUoZSwgbiA9ICExKSB7XG4gICAgaWYgKHRoaXMucmVzb2x2ZXIpXG4gICAgICBjb25zb2xlLmRlYnVnKGAke3RoaXMudmFyaWFibGVOYW1lfSBpcyBiZWluZyByZXNvbHZlZCBub3dgKSwgdGhpcy5yZXNvbHZlcihlKSwgdGhpcy5jb21wbGV0ZSgpO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKG4pIHRocm93IEVycm9yKGAke3RoaXMudmFyaWFibGVOYW1lfSB3YXMgYWxyZWFkeSBzZXR0bGVkYCk7XG4gICAgICBjb25zb2xlLmRlYnVnKGBJZ25vcmluZyBzdWJzZXF1ZW50IHJlc29sdXRpb24gb2YgJHt0aGlzLnZhcmlhYmxlTmFtZX1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlamVjdCB0aGlzIHZhcmlhYmxlJ3MgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIHdpdGggdGhlIGdpdmVuIHJlYXNvblxuICAgKlxuICAgKiBAcGFyYW0gcmVhc29uIFRoaXMgdmFyaWFibGUncyBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGlzIHJlYXNvblxuICAgKiBAcGFyYW0gdGhyb3dJZkFscmVhZHlTZXR0bGVkIERldGVybWluZXMgd2hldGhlciB0byB0aHJvdyBpZiB0aGUgdmFyaWFibGUgd2FzIGFscmVhZHkgcmVzb2x2ZWRcbiAgICogICBvciByZWplY3RlZC4gRGVmYXVsdHMgdG8gYGZhbHNlYFxuICAgKi9cbiAgcmVqZWN0V2l0aFJlYXNvbihlLCBuID0gITEpIHtcbiAgICBpZiAodGhpcy5yZWplY3RlcilcbiAgICAgIGNvbnNvbGUuZGVidWcoYCR7dGhpcy52YXJpYWJsZU5hbWV9IGlzIGJlaW5nIHJlamVjdGVkIG5vd2ApLCB0aGlzLnJlamVjdGVyKGUpLCB0aGlzLmNvbXBsZXRlKCk7XG4gICAgZWxzZSB7XG4gICAgICBpZiAobikgdGhyb3cgRXJyb3IoYCR7dGhpcy52YXJpYWJsZU5hbWV9IHdhcyBhbHJlYWR5IHNldHRsZWRgKTtcbiAgICAgIGNvbnNvbGUuZGVidWcoYElnbm9yaW5nIHN1YnNlcXVlbnQgcmVqZWN0aW9uIG9mICR7dGhpcy52YXJpYWJsZU5hbWV9YCk7XG4gICAgfVxuICB9XG4gIC8qKiBQcmV2ZW50IGFueSBmdXJ0aGVyIHVwZGF0ZXMgdG8gdGhpcyB2YXJpYWJsZSAqL1xuICBjb21wbGV0ZSgpIHtcbiAgICB0aGlzLnJlc29sdmVyID0gdm9pZCAwLCB0aGlzLnJlamVjdGVyID0gdm9pZCAwLCBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG59XG5jbGFzcyBMdSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4pIHtcbiAgICBXKHRoaXMsIFwiY29sbGF0b3JcIik7XG4gICAgdGhpcy5jb2xsYXRvciA9IG5ldyBJbnRsLkNvbGxhdG9yKGUsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gc3RyaW5ncyBhY2NvcmRpbmcgdG8gdGhlIHNvcnQgb3JkZXIgb2YgdGhpcyBDb2xsYXRvciBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHN0cmluZzEgU3RyaW5nIHRvIGNvbXBhcmVcbiAgICogQHBhcmFtIHN0cmluZzIgU3RyaW5nIHRvIGNvbXBhcmVcbiAgICogQHJldHVybnMgQSBudW1iZXIgaW5kaWNhdGluZyBob3cgc3RyaW5nMSBhbmQgc3RyaW5nMiBjb21wYXJlIHRvIGVhY2ggb3RoZXIgYWNjb3JkaW5nIHRvIHRoZVxuICAgKiAgIHNvcnQgb3JkZXIgb2YgdGhpcyBDb2xsYXRvciBvYmplY3QuIE5lZ2F0aXZlIHZhbHVlIGlmIHN0cmluZzEgY29tZXMgYmVmb3JlIHN0cmluZzIuIFBvc2l0aXZlXG4gICAqICAgdmFsdWUgaWYgc3RyaW5nMSBjb21lcyBhZnRlciBzdHJpbmcyLiAwIGlmIHRoZXkgYXJlIGNvbnNpZGVyZWQgZXF1YWwuXG4gICAqL1xuICBjb21wYXJlKGUsIG4pIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsYXRvci5jb21wYXJlKGUsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgcmVmbGVjdGluZyB0aGUgbG9jYWxlIGFuZCBjb2xsYXRpb24gb3B0aW9ucyBjb21wdXRlZFxuICAgKiBkdXJpbmcgaW5pdGlhbGl6YXRpb24gb2YgdGhpcyBjb2xsYXRvciBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIFJlc29sdmVkQ29sbGF0b3JPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgcmVzb2x2ZWRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxhdG9yLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG59XG5jbGFzcyBXciB7XG4gIGNvbnN0cnVjdG9yKGUsIG4pIHtcbiAgICBXKHRoaXMsIFwiZGF0ZVRpbWVGb3JtYXR0ZXJcIik7XG4gICAgdGhpcy5kYXRlVGltZUZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGUsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBGb3JtYXRzIGEgZGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZSBhbmQgZm9ybWF0dGluZyBvcHRpb24gZm9yIHRoaXMgRGF0ZVRpbWVGb3JtYXQgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGZvcm1hdFxuICAgKiBAcmV0dXJucyBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBkYXRlIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZSBhbmQgZm9ybWF0dGluZ1xuICAgKiAgIG9wdGlvbnMgb2YgdGhpcyBEYXRlVGltZUZvcm1hdCBvYmplY3RcbiAgICovXG4gIGZvcm1hdChlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZVRpbWVGb3JtYXR0ZXIuZm9ybWF0KGUpO1xuICB9XG4gIC8qKlxuICAgKiBGb3JtYXRzIGEgZGF0ZSByYW5nZSBpbiB0aGUgbW9zdCBjb25jaXNlIHdheSBiYXNlZCBvbiB0aGUgbG9jYWxlcyBhbmQgb3B0aW9ucyBwcm92aWRlZCB3aGVuXG4gICAqIGluc3RhbnRpYXRpbmcgdGhpcyBEYXRlVGltZUZvcm1hdCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0RGF0ZSBEYXRlIG9iamVjdCByZXByZXNlbnRpbmcgc3RhcnQgb2YgdGhlIGRhdGUgcmFuZ2VcbiAgICogQHBhcmFtIGVuZERhdGUgRGF0ZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBlbmQgb2YgdGhlIGRhdGUgcmFuZ2VcbiAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gZGF0ZSByYW5nZSBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUgYW5kXG4gICAqICAgZm9ybWF0dGluZyBvcHRpb25zIG9mIHRoaXMgRGF0ZVRpbWVGb3JtYXQgb2JqZWN0XG4gICAqL1xuICBmb3JtYXRSYW5nZShlLCBuKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZVRpbWVGb3JtYXR0ZXIuZm9ybWF0UmFuZ2UoZSwgbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbG9jYWxlLXNwZWNpZmljIHRva2VucyByZXByZXNlbnRpbmcgZWFjaCBwYXJ0IG9mIHRoZSBmb3JtYXR0ZWQgZGF0ZSByYW5nZVxuICAgKiBwcm9kdWNlZCBieSB0aGlzIERhdGVUaW1lRm9ybWF0IG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnREYXRlIERhdGUgb2JqZWN0IHJlcHJlc2VudGluZyBzdGFydCBvZiB0aGUgZGF0ZSByYW5nZVxuICAgKiBAcGFyYW0gZW5kRGF0ZSBEYXRlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgZGF0ZSByYW5nZVxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBEYXRlVGltZVJhbmdlRm9ybWF0UGFydCBvYmplY3RzXG4gICAqL1xuICBmb3JtYXRSYW5nZVRvUGFydHMoZSwgbikge1xuICAgIHJldHVybiB0aGlzLmRhdGVUaW1lRm9ybWF0dGVyLmZvcm1hdFJhbmdlVG9QYXJ0cyhlLCBuKTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIGxvY2FsZS1hd2FyZSBmb3JtYXR0aW5nIG9mIHN0cmluZ3MgcHJvZHVjZWQgYnkgdGhpcyBEYXRlVGltZUZvcm1hdCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gZm9ybWF0XG4gICAqIEByZXR1cm5zIEFycmF5IG9mIERhdGVUaW1lRm9ybWF0UGFydCBvYmplY3RzXG4gICAqL1xuICBmb3JtYXRUb1BhcnRzKGUpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlVGltZUZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgcmVmbGVjdGluZyB0aGUgbG9jYWxlIGFuZCBkYXRlIGFuZCB0aW1lIGZvcm1hdHRpbmcgb3B0aW9uc1xuICAgKiBjb21wdXRlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24gb2YgdGhpcyBEYXRlVGltZUZvcm1hdCBvYmplY3RcbiAgICpcbiAgICogQHJldHVybnMgUmVzb2x2ZWREYXRlVGltZUZvcm1hdE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICByZXNvbHZlZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZVRpbWVGb3JtYXR0ZXIucmVzb2x2ZWRPcHRpb25zKCk7XG4gIH1cbn1cbmNsYXNzIEtyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyBhIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoaXMgZXZlbnQgaXMgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBydW4gd2l0aCB0aGUgZXZlbnQgd2hlbiBpdCBpcyBlbWl0dGVkXG4gICAgICogQHJldHVybnMgVW5zdWJzY3JpYmVyIGZ1bmN0aW9uIHRvIHJ1biB0byBzdG9wIGNhbGxpbmcgdGhlIHBhc3NlZC1pbiBmdW5jdGlvbiB3aGVuIHRoZSBldmVudCBpc1xuICAgICAqICAgZW1pdHRlZFxuICAgICAqIEBhbGlhcyBldmVudFxuICAgICAqL1xuICAgIFcodGhpcywgXCJzdWJzY3JpYmVcIiwgdGhpcy5ldmVudCk7XG4gICAgLyoqIEFsbCBjYWxsYmFjayBmdW5jdGlvbnMgdGhhdCB3aWxsIHJ1biB3aGVuIHRoaXMgZXZlbnQgaXMgZW1pdHRlZC4gTGF6eSBsb2FkZWQgKi9cbiAgICBXKHRoaXMsIFwic3Vic2NyaXB0aW9uc1wiKTtcbiAgICAvKiogRXZlbnQgZm9yIGxpc3RlbmVycyB0byBzdWJzY3JpYmUgdG8uIExhenkgbG9hZGVkICovXG4gICAgVyh0aGlzLCBcImxhenlFdmVudFwiKTtcbiAgICAvKiogV2hldGhlciB0aGlzIGVtaXR0ZXIgaGFzIGJlZW4gZGlzcG9zZWQgKi9cbiAgICBXKHRoaXMsIFwiaXNEaXNwb3NlZFwiLCAhMSk7XG4gICAgLyoqIERpc3Bvc2VzIG9mIHRoaXMgZXZlbnQsIHByZXBhcmluZyBpdCB0byByZWxlYXNlIGZyb20gbWVtb3J5ICovXG4gICAgVyh0aGlzLCBcImRpc3Bvc2VcIiwgKCkgPT4gdGhpcy5kaXNwb3NlRm4oKSk7XG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgc3Vic2NyaXB0aW9ucyBmb3IgdGhlIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgZGF0YSB0byBwcm92aWRlIHRvIHN1YnNjcmliZWQgY2FsbGJhY2tzXG4gICAgICovXG4gICAgVyh0aGlzLCBcImVtaXRcIiwgKGUpID0+IHtcbiAgICAgIHRoaXMuZW1pdEZuKGUpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFdmVudCBmb3IgbGlzdGVuZXJzIHRvIHN1YnNjcmliZSB0by4gU3Vic2NyaWJlcyBhIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoaXMgZXZlbnQgaXMgZW1pdHRlZC5cbiAgICogVXNlIGxpa2UgYGNvbnN0IHVuc3Vic2NyaWJlciA9IGV2ZW50KGNhbGxiYWNrKWBcbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIHJ1biB3aXRoIHRoZSBldmVudCB3aGVuIGl0IGlzIGVtaXR0ZWRcbiAgICogQHJldHVybnMgVW5zdWJzY3JpYmVyIGZ1bmN0aW9uIHRvIHJ1biB0byBzdG9wIGNhbGxpbmcgdGhlIHBhc3NlZC1pbiBmdW5jdGlvbiB3aGVuIHRoZSBldmVudCBpc1xuICAgKiAgIGVtaXR0ZWRcbiAgICovXG4gIGdldCBldmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpLCB0aGlzLmxhenlFdmVudCB8fCAodGhpcy5sYXp5RXZlbnQgPSAoZSkgPT4ge1xuICAgICAgaWYgKCFlIHx8IHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaGFuZGxlciBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24hXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9ucyB8fCAodGhpcy5zdWJzY3JpcHRpb25zID0gW10pLCB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChlKSwgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaXB0aW9ucykgcmV0dXJuICExO1xuICAgICAgICBjb25zdCBuID0gdGhpcy5zdWJzY3JpcHRpb25zLmluZGV4T2YoZSk7XG4gICAgICAgIHJldHVybiBuIDwgMCA/ICExIDogKHRoaXMuc3Vic2NyaXB0aW9ucy5zcGxpY2UobiwgMSksICEwKTtcbiAgICAgIH07XG4gICAgfSksIHRoaXMubGF6eUV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHJ1bnMgdGhlIHN1YnNjcmlwdGlvbnMgZm9yIHRoZSBldmVudC4gQWRkZWQgaGVyZSBzbyBjaGlsZHJlbiBjYW4gb3ZlcnJpZGUgZW1pdFxuICAgKiBhbmQgc3RpbGwgY2FsbCB0aGUgYmFzZSBmdW5jdGlvbmFsaXR5LiBTZWUgTmV0d29ya0V2ZW50RW1pdHRlci5lbWl0IGZvciBleGFtcGxlXG4gICAqL1xuICBlbWl0Rm4oZSkge1xuICAgIHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKSwgWy4uLnRoaXMuc3Vic2NyaXB0aW9ucyA/PyBbXV0uZm9yRWFjaCgoaSkgPT4gaShlKSk7XG4gIH1cbiAgLyoqIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGlzIGVtaXR0ZXIgaXMgbm90IGRpc3Bvc2VkLiBUaHJvdyBpZiBpdCBpcyAqL1xuICBhc3NlcnROb3REaXNwb3NlZCgpIHtcbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB0aHJvdyBuZXcgRXJyb3IoXCJFbWl0dGVyIGlzIGRpc3Bvc2VkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNwb3NlcyBvZiB0aGlzIGV2ZW50LCBwcmVwYXJpbmcgaXQgdG8gcmVsZWFzZSBmcm9tIG1lbW9yeS4gQWRkZWQgaGVyZSBzbyBjaGlsZHJlbiBjYW5cbiAgICogb3ZlcnJpZGUgZW1pdCBhbmQgc3RpbGwgY2FsbCB0aGUgYmFzZSBmdW5jdGlvbmFsaXR5LlxuICAgKi9cbiAgZGlzcG9zZUZuKCkge1xuICAgIHJldHVybiB0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCksIHRoaXMuaXNEaXNwb3NlZCA9ICEwLCB0aGlzLnN1YnNjcmlwdGlvbnMgPSB2b2lkIDAsIHRoaXMubGF6eUV2ZW50ID0gdm9pZCAwLCBQcm9taXNlLnJlc29sdmUoITApO1xuICB9XG59XG5mdW5jdGlvbiBGdSgpIHtcbiAgcmV0dXJuIFwiMDAtMC00LTEtMDAwXCIucmVwbGFjZShcbiAgICAvW14tXS9nLFxuICAgICh0KSA9PiAoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRzKDIzNjMpIHRoaXMgd29ya3MgZmluZVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICgoTWF0aC5yYW5kb20oKSArIH5+dCkgKiA2NTUzNiA+PiB0KS50b1N0cmluZygxNikucGFkU3RhcnQoNCwgXCIwXCIpXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gTWUodCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiB8fCB0IGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZnVuY3Rpb24gd3QodCkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0KSk7XG59XG5mdW5jdGlvbiBrdSh0LCBlID0gMzAwKSB7XG4gIGlmIChNZSh0KSkgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gZGVib3VuY2UgYSBzdHJpbmchIENvdWxkIGJlIFhTU1wiKTtcbiAgbGV0IG47XG4gIHJldHVybiAoLi4uaSkgPT4ge1xuICAgIGNsZWFyVGltZW91dChuKSwgbiA9IHNldFRpbWVvdXQoKCkgPT4gdCguLi5pKSwgZSk7XG4gIH07XG59XG5mdW5jdGlvbiBxdSh0LCBlLCBuKSB7XG4gIGNvbnN0IGkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gdC5mb3JFYWNoKChvKSA9PiB7XG4gICAgY29uc3QgYSA9IGUobyksIGggPSBpLmdldChhKSwgcCA9IG4gPyBuKG8sIGEpIDogbztcbiAgICBoID8gaC5wdXNoKHApIDogaS5zZXQoYSwgW3BdKTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiBRcih0KSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIC8vIFdlJ3JlIHBvdGVudGlhbGx5IGRlYWxpbmcgd2l0aCBvYmplY3RzIHdlIGRpZG4ndCBjcmVhdGUsIHNvIHRoZXkgbWlnaHQgY29udGFpbiBgbnVsbGBcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW51bGwvbm8tbnVsbFxuICB0ICE9PSBudWxsICYmIFwibWVzc2FnZVwiIGluIHQgJiYgLy8gVHlwZSBhc3NlcnQgYGVycm9yYCB0byBjaGVjayBpdCdzIGBtZXNzYWdlYC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gIHR5cGVvZiB0Lm1lc3NhZ2UgPT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIFpyKHQpIHtcbiAgaWYgKFFyKHQpKSByZXR1cm4gdDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHQpKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihTdHJpbmcodCkpO1xuICB9XG59XG5mdW5jdGlvbiBPcih0KSB7XG4gIHJldHVybiBacih0KS5tZXNzYWdlO1xufVxuZnVuY3Rpb24gZW4odCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKGUpID0+IHNldFRpbWVvdXQoZSwgdCkpO1xufVxuZnVuY3Rpb24gVXUodCwgZSkge1xuICBjb25zdCBuID0gZW4oZSkudGhlbigoKSA9PiB7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5hbnkoW24sIHQoKV0pO1xufVxuZnVuY3Rpb24ganUodCwgZSA9IFwib2JqXCIpIHtcbiAgY29uc3QgbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpLmZvckVhY2goKG8pID0+IHtcbiAgICB0cnkge1xuICAgICAgdHlwZW9mIHRbb10gPT0gXCJmdW5jdGlvblwiICYmIG4uYWRkKG8pO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfSk7XG4gIGxldCBpID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICBmb3IgKDsgaSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaSk7IClcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0eXBlb2YgdFtvXSA9PSBcImZ1bmN0aW9uXCIgJiYgbi5hZGQobyk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9KSwgaSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiAkdSh0LCBlID0ge30pIHtcbiAgcmV0dXJuIG5ldyBQcm94eShlLCB7XG4gICAgZ2V0KG4sIGkpIHtcbiAgICAgIHJldHVybiBpIGluIG4gPyBuW2ldIDogYXN5bmMgKC4uLm8pID0+IChhd2FpdCB0KCkpW2ldKC4uLm8pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBWdSh0KSB7XG4gIGNvbnN0IGUgPSBcIkJ1ZyBpbiBQYXJhdGV4dCBjYXVzZWQgYXR0ZW1wdGVkIGFjY2VzcyB0byBJbnRlcm5ldC4gUmVxdWVzdCBoYXMgYmVlbiBibG9ja2VkLlwiO1xuICByZXR1cm4gTWUodCkgPyB0LmluY2x1ZGVzKGUpIDogT3IodCkuaW5jbHVkZXMoZSk7XG59XG5mdW5jdGlvbiBHdSh0KSB7XG4gIGNvbnN0IGUgPSBcIjQwMSBVbmF1dGhvcml6ZWQgZXJyb3Igd2hpbGUgZ2V0dGluZyBzaGFyZWQgcHJvamVjdHMuXCIsIG4gPSBcIlVzZXIgcmVnaXN0cmF0aW9uIGlzIG5vdCB2YWxpZC4gQ2Fubm90IHJldHJpZXZlIHJlc291cmNlcyBmcm9tIERCTC5cIiwgaSA9IE1lKHQpID8gdCA6IE9yKHQpO1xuICByZXR1cm4gaS5pbmNsdWRlcyhlKSB8fCBpLmluY2x1ZGVzKG4pO1xufVxuY2xhc3MgdG4ge1xuICAvKipcbiAgICogQ3JlYXRlIGEgRG9jdW1lbnRDb21iaW5lciBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gYmFzZURvY3VtZW50IFRoaXMgaXMgdGhlIGZpcnN0IGRvY3VtZW50IHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gY29tcG9zaW5nIHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB1c2VkIGJ5IHRoaXMgb2JqZWN0IHdoZW4gY29tYmluaW5nIGRvY3VtZW50c1xuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIFcodGhpcywgXCJiYXNlRG9jdW1lbnRcIik7XG4gICAgVyh0aGlzLCBcImNvbnRyaWJ1dGlvbnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgVyh0aGlzLCBcImxhdGVzdE91dHB1dFwiKTtcbiAgICBXKHRoaXMsIFwib3B0aW9uc1wiKTtcbiAgICBXKHRoaXMsIFwib25EaWRSZWJ1aWxkRW1pdHRlclwiLCBuZXcgS3IoKSk7XG4gICAgLyoqIEV2ZW50IHRoYXQgZW1pdHMgdG8gYW5ub3VuY2UgdGhhdCB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gcmVidWlsdCBhbmQgdGhlIG91dHB1dCBoYXMgYmVlbiB1cGRhdGVkICovXG4gICAgLy8gTmVlZCBgb25EaWRSZWJ1aWxkRW1pdHRlcmAgdG8gYmUgaW5zdGFudGlhdGVkIGJlZm9yZSB0aGlzIGxpbmVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgIFcodGhpcywgXCJvbkRpZFJlYnVpbGRcIiwgdGhpcy5vbkRpZFJlYnVpbGRFbWl0dGVyLnN1YnNjcmliZSk7XG4gICAgdGhpcy5iYXNlRG9jdW1lbnQgPSBlLCB0aGlzLm9wdGlvbnMgPSBuLCB0aGlzLnVwZGF0ZUJhc2VEb2N1bWVudChlKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBzdGFydGluZyBkb2N1bWVudCBmb3IgY29tcG9zaXRpb24gcHJvY2Vzc1xuICAgKlxuICAgKiBAcGFyYW0gYmFzZURvY3VtZW50IEJhc2UgSlNPTiBkb2N1bWVudC9KUyBvYmplY3QgdGhhdCBhbGwgb3RoZXIgZG9jdW1lbnRzIGFyZSBhZGRlZCB0b1xuICAgKiBAcmV0dXJucyBSZWNhbGN1bGF0ZWQgb3V0cHV0IGRvY3VtZW50IGdpdmVuIHRoZSBuZXcgc3RhcnRpbmcgc3RhdGUgYW5kIGV4aXN0aW5nIG90aGVyIGRvY3VtZW50c1xuICAgKi9cbiAgdXBkYXRlQmFzZURvY3VtZW50KGUpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUJhc2VEb2N1bWVudChlKSwgdGhpcy5iYXNlRG9jdW1lbnQgPSB0aGlzLm9wdGlvbnMuY29weURvY3VtZW50cyA/IHd0KGUpIDogZSwgdGhpcy5iYXNlRG9jdW1lbnQgPSB0aGlzLnRyYW5zZm9ybUJhc2VEb2N1bWVudEFmdGVyVmFsaWRhdGlvbih0aGlzLmJhc2VEb2N1bWVudCksIHRoaXMucmVidWlsZCgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgb3IgdXBkYXRlIG9uZSBvZiB0aGUgY29udHJpYnV0aW9uIGRvY3VtZW50cyBmb3IgdGhlIGNvbXBvc2l0aW9uIHByb2Nlc3NcbiAgICpcbiAgICogTm90ZTogdGhlIG9yZGVyIGluIHdoaWNoIGNvbnRyaWJ1dGlvbiBkb2N1bWVudHMgYXJlIGFkZGVkIGNhbiBiZSBjb25zaWRlcmVkIGluZGV0ZXJtaW5hdGUgYXMgaXRcbiAgICogZGVwZW5kcyBvbiB0aGUgb3JkZXIgaW4gd2hpY2ggYE1hcC5mb3JFYWNoYCBpdGVyYXRlcyBvdmVyIHRoZSBjb250cmlidXRpb25zLiBIb3dldmVyLCB0aGUgb3JkZXJcbiAgICogbWF0dGVycyB3aGVuIG1lcmdpbmcgdHdvIGFycmF5cyBpbnRvIG9uZS4gQWxzbywgd2hlbiBgb3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVQcm9wZXJ0aWVzYCBpcyBpc1xuICAgKiBgdHJ1ZWAsIHRoZSBvcmRlciBhbHNvIG1hdHRlcnMgd2hlbiBhZGRpbmcgdGhlIHNhbWUgcHJvcGVydHkgdG8gYW4gb2JqZWN0IHRoYXQgaXMgYWxyZWFkeVxuICAgKiBwcm92aWRlZCBwcmV2aW91c2x5LiBQbGVhc2UgbGV0IHVzIGtub3cgaWYgeW91IGhhdmUgdHJvdWJsZSBiZWNhdXNlIG9mIGluZGV0ZXJtaW5hdGVcbiAgICogY29udHJpYnV0aW9uIG9yZGVyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gZG9jdW1lbnROYW1lIE5hbWUgb2YgdGhlIGNvbnRyaWJ1dGVkIGRvY3VtZW50IHRvIGNvbWJpbmVcbiAgICogQHBhcmFtIGRvY3VtZW50IENvbnRlbnQgb2YgdGhlIGNvbnRyaWJ1dGVkIGRvY3VtZW50IHRvIGNvbWJpbmVcbiAgICogQHJldHVybnMgUmVjYWxjdWxhdGVkIG91dHB1dCBkb2N1bWVudCBnaXZlbiB0aGUgbmV3IG9yIHVwZGF0ZWQgY29udHJpYnV0aW9uIGFuZCBleGlzdGluZyBvdGhlclxuICAgKiAgIGRvY3VtZW50c1xuICAgKi9cbiAgYWRkT3JVcGRhdGVDb250cmlidXRpb24oZSwgbikge1xuICAgIHRoaXMudmFsaWRhdGVDb250cmlidXRpb24oZSwgbik7XG4gICAgY29uc3QgaSA9IHRoaXMuY29udHJpYnV0aW9ucy5nZXQoZSk7XG4gICAgbGV0IG8gPSB0aGlzLm9wdGlvbnMuY29weURvY3VtZW50cyAmJiBuID8gd3QobikgOiBuO1xuICAgIG8gPSB0aGlzLnRyYW5zZm9ybUNvbnRyaWJ1dGlvbkFmdGVyVmFsaWRhdGlvbihlLCBvKSwgdGhpcy5jb250cmlidXRpb25zLnNldChlLCBvKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMucmVidWlsZCgpO1xuICAgIH0gY2F0Y2ggKGEpIHtcbiAgICAgIHRocm93IGkgPyB0aGlzLmNvbnRyaWJ1dGlvbnMuc2V0KGUsIGkpIDogdGhpcy5jb250cmlidXRpb25zLmRlbGV0ZShlKSwgbmV3IEVycm9yKGBFcnJvciB3aGVuIHNldHRpbmcgdGhlIGRvY3VtZW50IG5hbWVkICR7ZX06ICR7YX1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBvbmUgb2YgdGhlIGNvbnRyaWJ1dGlvbiBkb2N1bWVudHMgZm9yIHRoZSBjb21wb3NpdGlvbiBwcm9jZXNzXG4gICAqXG4gICAqIEBwYXJhbSBkb2N1bWVudE5hbWUgTmFtZSBvZiB0aGUgY29udHJpYnV0ZWQgZG9jdW1lbnQgdG8gZGVsZXRlXG4gICAqIEByZXR1cm5zIFJlY2FsY3VsYXRlZCBvdXRwdXQgZG9jdW1lbnQgZ2l2ZW4gdGhlIHJlbWFpbmluZyBvdGhlciBkb2N1bWVudHNcbiAgICovXG4gIGRlbGV0ZUNvbnRyaWJ1dGlvbihlKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuY29udHJpYnV0aW9ucy5nZXQoZSk7XG4gICAgaWYgKCFuKSB0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICB0aGlzLmNvbnRyaWJ1dGlvbnMuZGVsZXRlKGUpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWJ1aWxkKCk7XG4gICAgfSBjYXRjaCAoaSkge1xuICAgICAgdGhyb3cgdGhpcy5jb250cmlidXRpb25zLnNldChlLCBuKSwgbmV3IEVycm9yKGBFcnJvciB3aGVuIGRlbGV0aW5nIHRoZSBkb2N1bWVudCBuYW1lZCAke2V9OiAke2l9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYWxsIHByZXNlbnQgY29udHJpYnV0aW9uIGRvY3VtZW50cyBmb3IgdGhlIGNvbXBvc2l0aW9uIHByb2Nlc3MgYW5kIHJldHVybiB0byB0aGUgYmFzZVxuICAgKiBkb2N1bWVudFxuICAgKlxuICAgKiBAcmV0dXJucyBSZWNhbGN1bGF0ZWQgb3V0cHV0IGRvY3VtZW50IGNvbnNpc3Rpbmcgb25seSBvZiB0aGUgYmFzZSBkb2N1bWVudFxuICAgKi9cbiAgZGVsZXRlQWxsQ29udHJpYnV0aW9ucygpIHtcbiAgICBpZiAodGhpcy5jb250cmlidXRpb25zLnNpemUgPD0gMCkgcmV0dXJuIHRoaXMubGF0ZXN0T3V0cHV0O1xuICAgIGNvbnN0IGUgPSBbLi4udGhpcy5jb250cmlidXRpb25zLmVudHJpZXMoKV07XG4gICAgZS5mb3JFYWNoKChbbl0pID0+IHRoaXMuY29udHJpYnV0aW9ucy5kZWxldGUobikpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWJ1aWxkKCk7XG4gICAgfSBjYXRjaCAobikge1xuICAgICAgdGhyb3cgZS5mb3JFYWNoKFxuICAgICAgICAoW2ksIG9dKSA9PiB0aGlzLmNvbnRyaWJ1dGlvbnMuc2V0KGksIG8pXG4gICAgICApLCBuZXcgRXJyb3IoYEVycm9yIHdoZW4gZGVsZXRpbmcgYWxsIGNvbnRyaWJ1dGlvbnM6ICR7bn1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJ1biB0aGUgZG9jdW1lbnQgY29tcG9zaXRpb24gcHJvY2VzcyBnaXZlbiB0aGUgc3RhcnRpbmcgZG9jdW1lbnQgYW5kIGFsbCBjb250cmlidXRpb25zLiBUaHJvd3NcbiAgICogaWYgdGhlIG91dHB1dCBkb2N1bWVudCBmYWlscyB0byB2YWxpZGF0ZSBwcm9wZXJseS5cbiAgICpcbiAgICogQHJldHVybnMgUmVjYWxjdWxhdGVkIG91dHB1dCBkb2N1bWVudCBnaXZlbiB0aGUgc3RhcnRpbmcgYW5kIGNvbnRyaWJ1dGVkIGRvY3VtZW50c1xuICAgKi9cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAodGhpcy5jb250cmlidXRpb25zLnNpemUgPT09IDApIHtcbiAgICAgIGxldCBuID0gd3QodGhpcy5iYXNlRG9jdW1lbnQpO1xuICAgICAgcmV0dXJuIG4gPSB0aGlzLnRyYW5zZm9ybUZpbmFsT3V0cHV0QmVmb3JlVmFsaWRhdGlvbihuKSwgdGhpcy52YWxpZGF0ZU91dHB1dChuKSwgdGhpcy5sYXRlc3RPdXRwdXQgPSBuLCB0aGlzLm9uRGlkUmVidWlsZEVtaXR0ZXIuZW1pdCh2b2lkIDApLCB0aGlzLmxhdGVzdE91dHB1dDtcbiAgICB9XG4gICAgbGV0IGUgPSB0aGlzLmJhc2VEb2N1bWVudDtcbiAgICByZXR1cm4gdGhpcy5jb250cmlidXRpb25zLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGUgPSBybihcbiAgICAgICAgZSxcbiAgICAgICAgbixcbiAgICAgICAgdGhpcy5vcHRpb25zLmlnbm9yZUR1cGxpY2F0ZVByb3BlcnRpZXNcbiAgICAgICksIHRoaXMudmFsaWRhdGVPdXRwdXQoZSk7XG4gICAgfSksIGUgPSB0aGlzLnRyYW5zZm9ybUZpbmFsT3V0cHV0QmVmb3JlVmFsaWRhdGlvbihlKSwgdGhpcy52YWxpZGF0ZU91dHB1dChlKSwgdGhpcy5sYXRlc3RPdXRwdXQgPSBlLCB0aGlzLm9uRGlkUmVidWlsZEVtaXR0ZXIuZW1pdCh2b2lkIDApLCB0aGlzLmxhdGVzdE91dHB1dDtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBzdGFydGluZyBkb2N1bWVudCB0aGF0IGlzIGdpdmVuIHRvIHRoZSBjb21iaW5lci4gVGhpcyB0cmFuc2Zvcm1hdGlvbiBvY2N1cnMgYWZ0ZXJcbiAgICogdmFsaWRhdGluZyB0aGUgYmFzZSBkb2N1bWVudCBhbmQgYmVmb3JlIGNvbWJpbmluZyBhbnkgY29udHJpYnV0aW9ucy5cbiAgICpcbiAgICogV0FSTklORzogSWYgeW91IGRvIG5vdCBjcmVhdGUgdGhlIGNvbWJpbmVyIHdpdGggb3B0aW9uIGBjb3B5RG9jdW1lbnRzOiB0cnVlYCBvciBjbG9uZSBpbnNpZGVcbiAgICogdGhpcyBtZXRob2QsIHRoaXMgbWV0aG9kIHdpbGwgZGlyZWN0bHkgbW9kaWZ5IHRoZSBgYmFzZURvY3VtZW50YCBwYXNzZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSBiYXNlRG9jdW1lbnQgSW5pdGlhbCBpbnB1dCBkb2N1bWVudC4gQWxyZWFkeSB2YWxpZGF0ZWQgdmlhIGB2YWxpZGF0ZUJhc2VEb2N1bWVudGBcbiAgICogQHJldHVybnMgVHJhbnNmb3JtZWQgYmFzZSBkb2N1bWVudFxuICAgKi9cbiAgLy8gV2UganVzdCBkb24ndCBuZWVkIGB0aGlzYCBoZXJlLiBUaGlzIGlzIGJhc2ljYWxseSBhIG5vLW9wIGZ1bmN0aW9uIHRoYXQgaXMgYXZhaWxhYmxlIHRvIGNoaWxkXG4gIC8vIGNsYXNzZXMgdG8gb3ZlcnJpZGVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIHRyYW5zZm9ybUJhc2VEb2N1bWVudEFmdGVyVmFsaWRhdGlvbihlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgY29udHJpYnV0ZWQgZG9jdW1lbnQgYXNzb2NpYXRlZCB3aXRoIGBkb2N1bWVudE5hbWVgLiBUaGlzIHRyYW5zZm9ybWF0aW9uIG9jY3Vyc1xuICAgKiBhZnRlciB2YWxpZGF0aW5nIHRoZSBjb250cmlidXRlZCBkb2N1bWVudCBhbmQgYmVmb3JlIGNvbWJpbmluZyB3aXRoIG90aGVyIGRvY3VtZW50cy5cbiAgICpcbiAgICogV0FSTklORzogSWYgeW91IGRvIG5vdCBjcmVhdGUgdGhlIGNvbWJpbmVyIHdpdGggb3B0aW9uIGBjb3B5RG9jdW1lbnRzOiB0cnVlYCBvciBjbG9uZSBpbnNpZGVcbiAgICogdGhpcyBtZXRob2QsIHRoaXMgbWV0aG9kIHdpbGwgZGlyZWN0bHkgbW9kaWZ5IHRoZSBjb250cmlidXRlZCBgZG9jdW1lbnRgIHBhc3NlZCBpbi5cbiAgICpcbiAgICogQHBhcmFtIGRvY3VtZW50TmFtZSBOYW1lIG9mIHRoZSBjb250cmlidXRlZCBkb2N1bWVudCB0byBjb21iaW5lXG4gICAqIEBwYXJhbSBkb2N1bWVudCBDb250ZW50IG9mIHRoZSBjb250cmlidXRlZCBkb2N1bWVudCB0byBjb21iaW5lLiBBbHJlYWR5IHZhbGlkYXRlZCB2aWFcbiAgICogICBgdmFsaWRhdGVDb250cmlidXRpb25gXG4gICAqIEByZXR1cm5zIFRyYW5zZm9ybWVkIGNvbnRyaWJ1dGVkIGRvY3VtZW50XG4gICAqL1xuICAvLyBXZSBqdXN0IGRvbid0IG5lZWQgYHRoaXNgIGhlcmUuIFRoaXMgaXMgYmFzaWNhbGx5IGEgbm8tb3AgZnVuY3Rpb24gdGhhdCBpcyBhdmFpbGFibGUgdG8gY2hpbGRcbiAgLy8gY2xhc3NlcyB0byBvdmVycmlkZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgdHJhbnNmb3JtQ29udHJpYnV0aW9uQWZ0ZXJWYWxpZGF0aW9uKGUsIG4pIHtcbiAgICByZXR1cm4gbjtcbiAgfVxuICAvKipcbiAgICogVGhyb3cgYW4gZXJyb3IgaWYgdGhlIHByb3ZpZGVkIGRvY3VtZW50IGlzIG5vdCBhIHZhbGlkIHN0YXJ0aW5nIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gYmFzZURvY3VtZW50IEJhc2UgSlNPTiBkb2N1bWVudC9KUyBvYmplY3QgdGhhdCBhbGwgb3RoZXIgZG9jdW1lbnRzIGFyZSBhZGRlZCB0b1xuICAgKi9cbiAgLy8gbm8tb3AgaW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBjaGlsZCBjbGFzc2VzLiBDYW4ndCBiZSBzdGF0aWNcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciB0cyg2MTMzKSBwYXJhbWV0ZXIgZG9lc24ndCBuZWVkIHRvIGJlIHVzZWQgYnV0IHN0aWxsIG5lZWRzIHRoZSByaWdodCBuYW1lXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2xhc3MtbWV0aG9kcy11c2UtdGhpcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHZhbGlkYXRlQmFzZURvY3VtZW50KGUpIHtcbiAgfVxuICAvKipcbiAgICogVGhyb3cgYW4gZXJyb3IgaWYgdGhlIHByb3ZpZGVkIGRvY3VtZW50IGlzIG5vdCBhIHZhbGlkIGNvbnRyaWJ1dGlvbiBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIGRvY3VtZW50TmFtZSBOYW1lIG9mIHRoZSBjb250cmlidXRlZCBkb2N1bWVudCB0byBjb21iaW5lXG4gICAqIEBwYXJhbSBkb2N1bWVudCBDb250ZW50IG9mIHRoZSBjb250cmlidXRlZCBkb2N1bWVudCB0byBjb21iaW5lXG4gICAqL1xuICAvLyBuby1vcCBpbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5IGNoaWxkIGNsYXNzZXMuIENhbid0IGJlIHN0YXRpY1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIHRzKDYxMzMpIHBhcmFtZXRlciBkb2Vzbid0IG5lZWQgdG8gYmUgdXNlZCBidXQgc3RpbGwgbmVlZHMgdGhlIHJpZ2h0IG5hbWVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jbGFzcy1tZXRob2RzLXVzZS10aGlzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgdmFsaWRhdGVDb250cmlidXRpb24oZSwgbikge1xuICB9XG4gIC8qKlxuICAgKiBUaHJvdyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgb3V0cHV0IGlzIG5vdCB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIG91dHB1dCBPdXRwdXQgZG9jdW1lbnQgdGhhdCBjb3VsZCBwb3RlbnRpYWxseSBiZSByZXR1cm5lZCB0byBjYWxsZXJzXG4gICAqL1xuICAvLyBuby1vcCBpbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5IGNoaWxkIGNsYXNzZXMuIENhbid0IGJlIHN0YXRpY1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIHRzKDYxMzMpIHBhcmFtZXRlciBkb2Vzbid0IG5lZWQgdG8gYmUgdXNlZCBidXQgc3RpbGwgbmVlZHMgdGhlIHJpZ2h0IG5hbWVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jbGFzcy1tZXRob2RzLXVzZS10aGlzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgdmFsaWRhdGVPdXRwdXQoZSkge1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIGRvY3VtZW50IHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHRoZSBiYXNlIGRvY3VtZW50IGFuZCBhbGwgY29udHJpYnV0aW9uXG4gICAqIGRvY3VtZW50cy4gVGhpcyBpcyB0aGUgbGFzdCBzdGVwIHRoYXQgd2lsbCBiZSBydW4gcHJpb3IgdG8gdmFsaWRhdGlvbiB2aWEgYHZhbGlkYXRlT3V0cHV0YFxuICAgKiBiZWZvcmUgYHRoaXMubGF0ZXN0T3V0cHV0YCBpcyB1cGRhdGVkIHRvIHRoZSBuZXcgb3V0cHV0LlxuICAgKlxuICAgKiBAcGFyYW0gZmluYWxPdXRwdXQgRmluYWwgb3V0cHV0IGRvY3VtZW50IHRoYXQgY291bGQgcG90ZW50aWFsbHkgYmUgcmV0dXJuZWQgdG8gY2FsbGVycy4gXCJGaW5hbFwiXG4gICAqICAgbWVhbnMgbm8gZnVydGhlciBjb250cmlidXRpb24gZG9jdW1lbnRzIHdpbGwgYmUgbWVyZ2VkLlxuICAgKi9cbiAgLy8gbm8tb3AgaW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBjaGlsZCBjbGFzc2VzLiBDYW4ndCBiZSBzdGF0aWNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIHRyYW5zZm9ybUZpbmFsT3V0cHV0QmVmb3JlVmFsaWRhdGlvbihlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cbmZ1bmN0aW9uIEt0KC4uLnQpIHtcbiAgbGV0IGUgPSAhMDtcbiAgcmV0dXJuIHQuZm9yRWFjaCgobikgPT4ge1xuICAgICghbiB8fCB0eXBlb2YgbiAhPSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkobikpICYmIChlID0gITEpO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIFF0KC4uLnQpIHtcbiAgbGV0IGUgPSAhMDtcbiAgcmV0dXJuIHQuZm9yRWFjaCgobikgPT4ge1xuICAgICghbiB8fCB0eXBlb2YgbiAhPSBcIm9iamVjdFwiIHx8ICFBcnJheS5pc0FycmF5KG4pKSAmJiAoZSA9ICExKTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBybih0LCBlLCBuKSB7XG4gIGNvbnN0IGkgPSB3dCh0KTtcbiAgcmV0dXJuIGUgPyBJcihpLCB3dChlKSwgbikgOiBpO1xufVxuZnVuY3Rpb24gSXIodCwgZSwgbikge1xuICBpZiAoIWUpIHJldHVybiB0O1xuICBpZiAoS3QodCwgZSkpIHtcbiAgICBjb25zdCBpID0gdCwgbyA9IGU7XG4gICAgT2JqZWN0LmtleXMobykuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgaWYgKE9iamVjdC5oYXNPd24oaSwgYSkpIHtcbiAgICAgICAgaWYgKEt0KGlbYV0sIG9bYV0pKVxuICAgICAgICAgIGlbYV0gPSBJcihcbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlc2UgYXJlIG9iamVjdHMgZnJvbSB0aGUgYGlmYCBjaGVja1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdHlwZS1hc3NlcnRpb24vbm8tdHlwZS1hc3NlcnRpb24gKi9cbiAgICAgICAgICAgIGlbYV0sXG4gICAgICAgICAgICBvW2FdLFxuICAgICAgICAgICAgblxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby10eXBlLWFzc2VydGlvbi9uby10eXBlLWFzc2VydGlvbiAqL1xuICAgICAgICAgICk7XG4gICAgICAgIGVsc2UgaWYgKFF0KGlbYV0sIG9bYV0pKVxuICAgICAgICAgIGlbYV0gPSBpW2FdLmNvbmNhdChcbiAgICAgICAgICAgIG9bYV1cbiAgICAgICAgICApO1xuICAgICAgICBlbHNlIGlmICghbilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBtZXJnZSBvYmplY3RzOiBrZXkgXCIke2F9XCIgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHRhcmdldCBvYmplY3RgKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBpW2FdID0gb1thXTtcbiAgICB9KTtcbiAgfSBlbHNlIFF0KHQsIGUpICYmIHQucHVzaCguLi5lKTtcbiAgcmV0dXJuIHQ7XG59XG5jbGFzcyB6dSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEluc3RhbmNlVGltZUNvdW50ZXIgY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlclNpemUgLSBNYXhpbXVtIG51bWJlciBvZiBpbnN0YW5jZXMgdG8gdHJhY2tcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICAvKiogVGhlIHJpbmcgYnVmZmVyIHRvIHN0b3JlIHRpbWVzICovXG4gICAgVyh0aGlzLCBcInJpbmdCdWZmZXJcIik7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSByaW5nIGJ1ZmZlciAqL1xuICAgIFcodGhpcywgXCJidWZmZXJTaXplXCIpO1xuICAgIC8qKiBUaGUgbmV4dCBsb2NhdGlvbiB3aGVyZSBhIHRpbWUgd2lsbCBiZSB3cml0dGVuICovXG4gICAgVyh0aGlzLCBcIndyaXRlckluZGV4XCIpO1xuICAgIC8qKiBUaGUgbG9jYXRpb24gd2hlcmUgdGhlIGZpcnN0IHRpbWUgaW4gdGhlIGJ1ZmZlciB3aWxsIGJlIHJlYWQgKi9cbiAgICBXKHRoaXMsIFwicmVhZGVySW5kZXhcIik7XG4gICAgLyoqIFRoZSBtb3N0IHJlY2VudCBkaWZmZXJlbmNlIGluIHRpbWUgYmV0d2VlbiB0aGUgbmV3ZXN0IGFuZCBvbGRlc3QgZXZlbnRzICovXG4gICAgVyh0aGlzLCBcImxhc3RUaW1lRGlmZmVyZW5jZVwiKTtcbiAgICAvKiogSG93IG1hbnkgaW5zdGFuY2VzIGluIHRvdGFsIGhhdmUgYmVlbiByZWNvcmRlZCAqL1xuICAgIFcodGhpcywgXCJ0b3RhbEluc3RhbmNlQ291bnRcIik7XG4gICAgdGhpcy5idWZmZXJTaXplID0gZSwgdGhpcy5yaW5nQnVmZmVyID0gbmV3IEFycmF5KGUpLmZpbGwoMCksIHRoaXMud3JpdGVySW5kZXggPSAwLCB0aGlzLnJlYWRlckluZGV4ID0gMCwgdGhpcy5sYXN0VGltZURpZmZlcmVuY2UgPSAwLCB0aGlzLnRvdGFsSW5zdGFuY2VDb3VudCA9IDA7XG4gIH1cbiAgLyoqIEdldCB0aGUgdG90YWwgbnVtYmVyIG9mIGluc3RhbmNlcyB0aGF0IGhhdmUgYmVlbiByZWNvcmRlZCAqL1xuICBnZXQgdG90YWxJbnN0YW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxJbnN0YW5jZUNvdW50O1xuICB9XG4gIC8qKiBBZGQgYSBuZXcgdGltZSBtZWFzdXJlbWVudCBmb3IgYW4gaW5zdGFuY2Ugb2YgYW4gZXZlbnQgKi9cbiAgcmVjb3JkSW5zdGFuY2UoKSB7XG4gICAgdGhpcy50b3RhbEluc3RhbmNlQ291bnQgKz0gMTtcbiAgICBjb25zdCBlID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5sYXN0VGltZURpZmZlcmVuY2UgPSBlIC0gdGhpcy5yaW5nQnVmZmVyW3RoaXMucmVhZGVySW5kZXhdLCB0aGlzLnJpbmdCdWZmZXJbdGhpcy53cml0ZXJJbmRleF0gPSBlLCB0aGlzLndyaXRlckluZGV4ICs9IDEsIHRoaXMud3JpdGVySW5kZXggPj0gdGhpcy5idWZmZXJTaXplICYmICh0aGlzLndyaXRlckluZGV4ICU9IHRoaXMuYnVmZmVyU2l6ZSksIHRoaXMud3JpdGVySW5kZXggPT09IHRoaXMucmVhZGVySW5kZXggJiYgKHRoaXMucmVhZGVySW5kZXggKz0gMSwgdGhpcy5yZWFkZXJJbmRleCA+PSB0aGlzLmJ1ZmZlclNpemUgJiYgKHRoaXMucmVhZGVySW5kZXggJT0gdGhpcy5idWZmZXJTaXplKSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgTiBldmVudHMgaXMgbGVzcyB0aGFuIHRoZSBwcm92aWRlZCB0aHJlc2hvbGRcbiAgICpcbiAgICogQHBhcmFtIG1pblJvbGxpbmdUaW1lTXMgLSBNaW5pbXVtIHRpbWUgdGhhdCBtdXN0IGhhdmUgcGFzc2VkIHdoZW4gdGhlIGxhc3QgTiBldmVudHMgb2NjdXJyZWRcbiAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSB0aHJlc2hvbGQgaXMgdmlvbGF0ZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgaGFzVmlvbGF0ZWRUaHJlc2hvbGQoZSkge1xuICAgIHJldHVybiB0aGlzLnRvdGFsSW5zdGFuY2VDb3VudCA+PSB0aGlzLmJ1ZmZlclNpemUgJiYgdGhpcy5sYXN0VGltZURpZmZlcmVuY2UgPCBlO1xuICB9XG59XG5jbGFzcyBubiBleHRlbmRzIFlyIHtcbn1cbmNsYXNzIEh1IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgVyh0aGlzLCBcIm11dGV4ZXNCeUlEXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICB9XG4gIGdldChlKSB7XG4gICAgbGV0IG4gPSB0aGlzLm11dGV4ZXNCeUlELmdldChlKTtcbiAgICByZXR1cm4gbiB8fCAobiA9IG5ldyBubigpLCB0aGlzLm11dGV4ZXNCeUlELnNldChlLCBuKSwgbik7XG4gIH1cbn1cbmNsYXNzIEp1IGV4dGVuZHMgdG4ge1xuICAvLyBNYWtpbmcgdGhlIHByb3RlY3RlZCBiYXNlIGNvbnN0cnVjdG9yIHB1YmxpY1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZWxlc3MtY29uc3RydWN0b3JcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHN1cGVyKGUsIG4pO1xuICB9XG4gIGdldCBvdXRwdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZXN0T3V0cHV0O1xuICB9XG59XG5jbGFzcyB1biB7XG4gIGNvbnN0cnVjdG9yKGUsIG4pIHtcbiAgICBXKHRoaXMsIFwibnVtYmVyRm9ybWF0dGVyXCIpO1xuICAgIHRoaXMubnVtYmVyRm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGUsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBGb3JtYXRzIGEgbnVtYmVyIGFjY29yZGluZyB0byB0aGUgbG9jYWxlIGFuZCBmb3JtYXR0aW5nIG9wdGlvbnMgb2YgdGhpcyBOdW1iZXJGb3JtYXQgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBOdW1iZXIgb3IgQmlnSW50IHRvIGZvcm1hdFxuICAgKiBAcmV0dXJucyBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBudW1iZXIgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgbG9jYWxlIGFuZCBmb3JtYXR0aW5nXG4gICAqICAgb3B0aW9ucyBvZiB0aGlzIE51bWJlckZvcm1hdCBvYmplY3RcbiAgICovXG4gIGZvcm1hdChlKSB7XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyRm9ybWF0dGVyLmZvcm1hdChlKTtcbiAgfVxuICAvKipcbiAgICogRm9ybWF0cyBhIHJhbmdlIG9mIG51bWJlcnMgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUgYW5kIGZvcm1hdHRpbmcgb3B0aW9ucyBvZiB0aGlzIE51bWJlckZvcm1hdFxuICAgKiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0UmFuZ2UgTnVtYmVyIG9yIGJpZ2ludCByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZVxuICAgKiBAcGFyYW0gZW5kUmFuZ2UgTnVtYmVyIG9yIGJpZ2ludCByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgcmFuZ2VcbiAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgbnVtYmVycyBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUgYW5kXG4gICAqICAgZm9ybWF0dGluZyBvcHRpb25zIG9mIHRoaXMgTnVtYmVyRm9ybWF0IG9iamVjdFxuICAgKi9cbiAgZm9ybWF0UmFuZ2UoZSwgbikge1xuICAgIHJldHVybiB0aGlzLm51bWJlckZvcm1hdHRlci5mb3JtYXRSYW5nZShlLCBuKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGxvY2FsZS1zcGVjaWZpYyB0b2tlbnMgZnJvbSB3aGljaCBpdCBpcyBwb3NzaWJsZSB0b1xuICAgKiBidWlsZCBjdXN0b20gc3RyaW5ncyB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBsb2NhbGUtc3BlY2lmaWMgcGFydHMuXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFJhbmdlIE51bWJlciBvciBiaWdpbnQgcmVwcmVzZW50aW5nIHN0YXJ0IG9mIHRoZSByYW5nZVxuICAgKiBAcGFyYW0gZW5kUmFuZ2UgTnVtYmVyIG9yIGJpZ2ludCByZXByZXNlbnRpbmcgZW5kIG9mIHRoZSByYW5nZVxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBOdW1iZXJSYW5nZUZvcm1hdFBhcnQgb2JqZWN0cyBjb250YWluaW5nIHRoZSBmb3JtYXR0ZWQgcmFuZ2Ugb2YgbnVtYmVycyBpblxuICAgKiAgIHBhcnRzXG4gICAqL1xuICBmb3JtYXRSYW5nZVRvUGFydHMoZSwgbikge1xuICAgIHJldHVybiB0aGlzLm51bWJlckZvcm1hdHRlci5mb3JtYXRSYW5nZVRvUGFydHMoZSwgbik7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93cyBsb2NhbGUtYXdhcmUgZm9ybWF0dGluZyBvZiBzdHJpbmdzIHByb2R1Y2VkIGJ5IHRoaXMgTnVtYmVyRm9ybWF0IG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgTnVtYmVyIG9yIGJpZ2ludCB0byBmb3JtYXRcbiAgICogQHJldHVybnMgQXJyYXkgb2YgTnVtYmVyRm9ybWF0UGFydCBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGZvcm1hdHRlZCBudW1iZXIgaW4gcGFydHNcbiAgICovXG4gIGZvcm1hdFRvUGFydHMoZSkge1xuICAgIHJldHVybiB0aGlzLm51bWJlckZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgcmVmbGVjdGluZyB0aGUgbG9jYWxlIGFuZCBudW1iZXIgZm9ybWF0dGluZyBvcHRpb25zXG4gICAqIGNvbXB1dGVkIGR1cmluZyBpbml0aWFsaXphdGlvbiBvZiB0aGlzIE51bWJlckZvcm1hdCBvYmplY3RcbiAgICpcbiAgICogQHJldHVybnMgUmVzb2x2ZWROdW1iZXJGb3JtYXRPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgcmVzb2x2ZWRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm51bWJlckZvcm1hdHRlci5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfVxufVxuY29uc3Qgb24gPSBQcm9taXNlLnJlc29sdmUoKTtcbmNsYXNzIFh1IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUHJvbWlzZUNoYWluaW5nTWFwXG4gICAqXG4gICAqIEBwYXJhbSBsb2dnZXIgT2JqZWN0IHdpdGggYSBgd2FybmAgbWV0aG9kIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHByb21pc2UgcmVqZWN0cy4gVGhpc1xuICAgKiAgIGRlZmF1bHRzIHRvIGBjb25zb2xlYC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUgPSBjb25zb2xlKSB7XG4gICAgVyh0aGlzLCBcIm1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBXKHRoaXMsIFwibG9nZ2VyXCIpO1xuICAgIHRoaXMubG9nZ2VyID0gZTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHByb21pc2UgZnVuY3Rpb24gdG8gdGhlIG1hcCBmb3IgYSBnaXZlbiBrZXkuIElmIGEgcHJvbWlzZSBpcyBhbHJlYWR5IHJ1bm5pbmcgZm9yIHRoZVxuICAgKiBrZXksIHRoZSBuZXcgcHJvbWlzZSB3aWxsIGJlIGNoYWluZWQgdG8gdGhlIGV4aXN0aW5nIG9uZS4gT25jZSBhbGwgcHJvbWlzZXMgZm9yIGEga2V5IGhhdmVcbiAgICogc2V0dGxlZCwgdGhlIG1hcCB3aWxsIGJlIGNsZWFyZWQgZm9yIHRoYXQga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFVuaXF1ZSBrZXkgdG8gaWRlbnRpZnkgYSBkaXN0aW5jdCBwcm9taXNlIGNoYWluXG4gICAqIEBwYXJhbSBwcm9taXNlRnVuY3Rpb24gRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZSB0byBhZGQgdG8gdGhlIGNoYWluXG4gICAqL1xuICBhZGRQcm9taXNlRnVuY3Rpb24oZSwgbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLm1hcC5nZXQoZSk7XG4gICAgdGhpcy5tYXAuc2V0KGUsIGkgPyBpLnRoZW4obikgOiBuKCkpLCB0aGlzLmNsZWFudXBQcm9taXNlQ2hhaW4oZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcHJvbWlzZSBjaGFpbiBmb3IgdGhlIGdpdmVuIGtleS4gVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvciB0ZXN0aW5nLiBOb3JtYWxseVxuICAgKiB5b3Ugc2hvdWxkIGp1c3QgY2FsbCB7QGxpbmsgYWRkUHJvbWlzZUZ1bmN0aW9ufSBhbmQgbGV0IHRoZSBtYXAgaGFuZGxlIHRoZSByZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFVuaXF1ZSBrZXkgdG8gaWRlbnRpZnkgYSBkaXN0aW5jdCBwcm9taXNlIGNoYWluXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHByb21pc2UgY2hhaW4gZm9yIHRoZSBrZXlcbiAgICovXG4gIGdldChlKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmdldChlKTtcbiAgfVxuICAvKipcbiAgICogQ29uZmlndXJlcyBhIHByb21pc2UgY2hhaW4gdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgZm9yIHRoZSBnaXZlbiBrZXkgYWZ0ZXIgYWxsIHRoZSBwcm9taXNlc1xuICAgKiBoYXZlIHNldHRsZWRcbiAgICpcbiAgICogQHBhcmFtIGtleSBVbmlxdWUga2V5IHRvIGlkZW50aWZ5IGEgZGlzdGluY3QgcHJvbWlzZSBjaGFpblxuICAgKi9cbiAgY2xlYW51cFByb21pc2VDaGFpbihlKSB7XG4gICAgY29uc3QgbiA9IHRoaXMubWFwLmdldChlKTtcbiAgICBpZiAoIW4pIHJldHVybjtcbiAgICBjb25zdCBpID0geyBwcm9taXNlOiBvbiB9LCBvID0gbi5jYXRjaCgoYSkgPT4gdGhpcy5sb2dnZXIud2FybihgRXJyb3IgaW4gcHJvbWlzZSBmb3IgJHtlfTogJHthLm1lc3NhZ2V9YCkpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5tYXAuZ2V0KGUpID09PSBpLnByb21pc2UgJiYgdGhpcy5tYXAuZGVsZXRlKGUpO1xuICAgIH0pO1xuICAgIGkucHJvbWlzZSA9IG8sIHRoaXMubWFwLnNldChlLCBvKTtcbiAgfVxufVxuY2xhc3MgWXUge1xuICBjb25zdHJ1Y3RvcihlID0gXCJBbm9ueW1vdXNcIikge1xuICAgIFcodGhpcywgXCJ1bnN1YnNjcmliZXJzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIHRoaXMubmFtZSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCB1bnN1YnNjcmliZXJzIHRvIHRoZSBsaXN0LiBOb3RlIHRoYXQgZHVwbGljYXRlcyBhcmUgbm90IGFkZGVkIHR3aWNlLlxuICAgKlxuICAgKiBAcGFyYW0gdW5zdWJzY3JpYmVycyAtIE9iamVjdHMgdGhhdCB3ZXJlIHJldHVybmVkIGZyb20gYSByZWdpc3RyYXRpb24gcHJvY2Vzcy5cbiAgICovXG4gIGFkZCguLi5lKSB7XG4gICAgZS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBcImRpc3Bvc2VcIiBpbiBuID8gdGhpcy51bnN1YnNjcmliZXJzLmFkZChuLmRpc3Bvc2UuYmluZChuKSkgOiB0aGlzLnVuc3Vic2NyaWJlcnMuYWRkKG4pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSdW4gYWxsIHVuc3Vic2NyaWJlcnMgYWRkZWQgdG8gdGhpcyBsaXN0IGFuZCB0aGVuIGNsZWFyIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYWxsIHVuc3Vic2NyaWJlcnMgc3VjY2VlZGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIGFzeW5jIHJ1bkFsbFVuc3Vic2NyaWJlcnMoKSB7XG4gICAgY29uc3QgZSA9IFsuLi50aGlzLnVuc3Vic2NyaWJlcnNdLm1hcCgoaSkgPT4gaSgpKSwgbiA9IGF3YWl0IFByb21pc2UuYWxsKGUpO1xuICAgIHJldHVybiB0aGlzLnVuc3Vic2NyaWJlcnMuY2xlYXIoKSwgbi5ldmVyeSgoaSwgbykgPT4gKGkgfHwgY29uc29sZS5lcnJvcihgVW5zdWJzY3JpYmVyQXN5bmNMaXN0ICR7dGhpcy5uYW1lfTogVW5zdWJzY3JpYmVyIGF0IGluZGV4ICR7b30gZmFpbGVkIWApLCBpKSk7XG4gIH1cbn1cbmNvbnN0IEl0ID0gMTtcbmZ1bmN0aW9uIFd1KHQpIHtcbiAgaWYgKCF0KSByZXR1cm4geyBtZXNzYWdlOiBcIlwiLCBwbGF0Zm9ybUVycm9yVmVyc2lvbjogSXQgfTtcbiAgaWYgKE1lKHQpKSByZXR1cm4geyBtZXNzYWdlOiB0LCBwbGF0Zm9ybUVycm9yVmVyc2lvbjogSXQgfTtcbiAgaWYgKHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgXCJtZXNzYWdlXCIgaW4gdCAmJiB0eXBlb2YgdC5tZXNzYWdlID09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgbWVzc2FnZTogdC5tZXNzYWdlLFxuICAgICAgcGxhdGZvcm1FcnJvclZlcnNpb246IEl0XG4gICAgfTtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJtZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogITAgfSksIFwic3RhY2tcIiBpbiBlICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInN0YWNrXCIsIHsgZW51bWVyYWJsZTogITAgfSksIFwiY2F1c2VcIiBpbiBlICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImNhdXNlXCIsIHsgZW51bWVyYWJsZTogITAgfSksIGU7XG4gIH1cbiAgcmV0dXJuIHsgY2F1c2U6IHQsIG1lc3NhZ2U6IFwiXCIsIHBsYXRmb3JtRXJyb3JWZXJzaW9uOiBJdCB9O1xufVxuZnVuY3Rpb24gS3UodCkge1xuICByZXR1cm4gISF0ICYmIHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgXCJwbGF0Zm9ybUVycm9yVmVyc2lvblwiIGluIHQ7XG59XG52YXIgYW4gPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNuID0gKHQsIGUsIG4pID0+IGUgaW4gdCA/IGFuKHQsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IG4gfSkgOiB0W2VdID0gbiwgeiA9ICh0LCBlLCBuKSA9PiBzbih0LCB0eXBlb2YgZSAhPSBcInN5bWJvbFwiID8gZSArIFwiXCIgOiBlLCBuKTtcbmNvbnN0IGl0ID0gW1xuICBcIkdFTlwiLFxuICBcIkVYT1wiLFxuICBcIkxFVlwiLFxuICBcIk5VTVwiLFxuICBcIkRFVVwiLFxuICBcIkpPU1wiLFxuICBcIkpER1wiLFxuICBcIlJVVFwiLFxuICBcIjFTQVwiLFxuICBcIjJTQVwiLFxuICAvLyAxMFxuICBcIjFLSVwiLFxuICBcIjJLSVwiLFxuICBcIjFDSFwiLFxuICBcIjJDSFwiLFxuICBcIkVaUlwiLFxuICBcIk5FSFwiLFxuICBcIkVTVFwiLFxuICBcIkpPQlwiLFxuICBcIlBTQVwiLFxuICBcIlBST1wiLFxuICAvLyAyMFxuICBcIkVDQ1wiLFxuICBcIlNOR1wiLFxuICBcIklTQVwiLFxuICBcIkpFUlwiLFxuICBcIkxBTVwiLFxuICBcIkVaS1wiLFxuICBcIkRBTlwiLFxuICBcIkhPU1wiLFxuICBcIkpPTFwiLFxuICBcIkFNT1wiLFxuICAvLyAzMFxuICBcIk9CQVwiLFxuICBcIkpPTlwiLFxuICBcIk1JQ1wiLFxuICBcIk5BTVwiLFxuICBcIkhBQlwiLFxuICBcIlpFUFwiLFxuICBcIkhBR1wiLFxuICBcIlpFQ1wiLFxuICBcIk1BTFwiLFxuICBcIk1BVFwiLFxuICAvLyA0MFxuICBcIk1SS1wiLFxuICBcIkxVS1wiLFxuICBcIkpITlwiLFxuICBcIkFDVFwiLFxuICBcIlJPTVwiLFxuICBcIjFDT1wiLFxuICBcIjJDT1wiLFxuICBcIkdBTFwiLFxuICBcIkVQSFwiLFxuICBcIlBIUFwiLFxuICAvLyA1MFxuICBcIkNPTFwiLFxuICBcIjFUSFwiLFxuICBcIjJUSFwiLFxuICBcIjFUSVwiLFxuICBcIjJUSVwiLFxuICBcIlRJVFwiLFxuICBcIlBITVwiLFxuICBcIkhFQlwiLFxuICBcIkpBU1wiLFxuICBcIjFQRVwiLFxuICAvLyA2MFxuICBcIjJQRVwiLFxuICBcIjFKTlwiLFxuICBcIjJKTlwiLFxuICBcIjNKTlwiLFxuICBcIkpVRFwiLFxuICBcIlJFVlwiLFxuICBcIlRPQlwiLFxuICBcIkpEVFwiLFxuICBcIkVTR1wiLFxuICBcIldJU1wiLFxuICAvLyA3MFxuICBcIlNJUlwiLFxuICBcIkJBUlwiLFxuICBcIkxKRVwiLFxuICBcIlMzWVwiLFxuICBcIlNVU1wiLFxuICBcIkJFTFwiLFxuICBcIjFNQVwiLFxuICBcIjJNQVwiLFxuICBcIjNNQVwiLFxuICBcIjRNQVwiLFxuICAvLyA4MFxuICBcIjFFU1wiLFxuICBcIjJFU1wiLFxuICBcIk1BTlwiLFxuICBcIlBTMlwiLFxuICBcIk9EQVwiLFxuICBcIlBTU1wiLFxuICBcIkpTQVwiLFxuICAvLyBhY3R1YWwgdmFyaWFudCB0ZXh0IGZvciBKT1MsIG5vdyBpbiBMWEEgdGV4dFxuICBcIkpEQlwiLFxuICAvLyBhY3R1YWwgdmFyaWFudCB0ZXh0IGZvciBKREcsIG5vdyBpbiBMWEEgdGV4dFxuICBcIlRCU1wiLFxuICAvLyBhY3R1YWwgdmFyaWFudCB0ZXh0IGZvciBUT0IsIG5vdyBpbiBMWEEgdGV4dFxuICBcIlNTVFwiLFxuICAvLyBhY3R1YWwgdmFyaWFudCB0ZXh0IGZvciBTVVMsIG5vdyBpbiBMWEEgdGV4dCAvLyA5MFxuICBcIkROVFwiLFxuICAvLyBhY3R1YWwgdmFyaWFudCB0ZXh0IGZvciBEQU4sIG5vdyBpbiBMWEEgdGV4dFxuICBcIkJMVFwiLFxuICAvLyBhY3R1YWwgdmFyaWFudCB0ZXh0IGZvciBCRUwsIG5vdyBpbiBMWEEgdGV4dFxuICBcIlhYQVwiLFxuICBcIlhYQlwiLFxuICBcIlhYQ1wiLFxuICBcIlhYRFwiLFxuICBcIlhYRVwiLFxuICBcIlhYRlwiLFxuICBcIlhYR1wiLFxuICBcIkZSVFwiLFxuICAvLyAxMDBcbiAgXCJCQUtcIixcbiAgXCJPVEhcIixcbiAgXCIzRVNcIixcbiAgLy8gVXNlZCBwcmV2aW91c2x5IGJ1dCByZWFsbHkgc2hvdWxkIGJlIDJFU1xuICBcIkVaQVwiLFxuICAvLyBVc2VkIHRvIGJlIGNhbGxlZCA0RVMsIGJ1dCBub3QgYWN0dWFsbHkgaW4gYW55IGtub3duIHByb2plY3RcbiAgXCI1RVpcIixcbiAgLy8gVXNlZCB0byBiZSBjYWxsZWQgNUVTLCBidXQgbm90IGFjdHVhbGx5IGluIGFueSBrbm93biBwcm9qZWN0XG4gIFwiNkVaXCIsXG4gIC8vIFVzZWQgdG8gYmUgY2FsbGVkIDZFUywgYnV0IG5vdCBhY3R1YWxseSBpbiBhbnkga25vd24gcHJvamVjdFxuICBcIklOVFwiLFxuICBcIkNOQ1wiLFxuICBcIkdMT1wiLFxuICBcIlREWFwiLFxuICAvLyAxMTBcbiAgXCJORFhcIixcbiAgXCJEQUdcIixcbiAgXCJQUzNcIixcbiAgXCIyQkFcIixcbiAgXCJMQkFcIixcbiAgXCJKVUJcIixcbiAgXCJFTk9cIixcbiAgXCIxTVFcIixcbiAgXCIyTVFcIixcbiAgXCIzTVFcIixcbiAgLy8gMTIwXG4gIFwiUkVQXCIsXG4gIFwiNEJBXCIsXG4gIFwiTEFPXCJcbl0sICR0ID0gW1xuICBcIlhYQVwiLFxuICBcIlhYQlwiLFxuICBcIlhYQ1wiLFxuICBcIlhYRFwiLFxuICBcIlhYRVwiLFxuICBcIlhYRlwiLFxuICBcIlhYR1wiLFxuICBcIkZSVFwiLFxuICBcIkJBS1wiLFxuICBcIk9USFwiLFxuICBcIklOVFwiLFxuICBcIkNOQ1wiLFxuICBcIkdMT1wiLFxuICBcIlREWFwiLFxuICBcIk5EWFwiXG5dLCB4ciA9IFtcbiAgXCJHZW5lc2lzXCIsXG4gIFwiRXhvZHVzXCIsXG4gIFwiTGV2aXRpY3VzXCIsXG4gIFwiTnVtYmVyc1wiLFxuICBcIkRldXRlcm9ub215XCIsXG4gIFwiSm9zaHVhXCIsXG4gIFwiSnVkZ2VzXCIsXG4gIFwiUnV0aFwiLFxuICBcIjEgU2FtdWVsXCIsXG4gIFwiMiBTYW11ZWxcIixcbiAgXCIxIEtpbmdzXCIsXG4gIFwiMiBLaW5nc1wiLFxuICBcIjEgQ2hyb25pY2xlc1wiLFxuICBcIjIgQ2hyb25pY2xlc1wiLFxuICBcIkV6cmFcIixcbiAgXCJOZWhlbWlhaFwiLFxuICBcIkVzdGhlciAoSGVicmV3KVwiLFxuICBcIkpvYlwiLFxuICBcIlBzYWxtc1wiLFxuICBcIlByb3ZlcmJzXCIsXG4gIFwiRWNjbGVzaWFzdGVzXCIsXG4gIFwiU29uZyBvZiBTb25nc1wiLFxuICBcIklzYWlhaFwiLFxuICBcIkplcmVtaWFoXCIsXG4gIFwiTGFtZW50YXRpb25zXCIsXG4gIFwiRXpla2llbFwiLFxuICBcIkRhbmllbCAoSGVicmV3KVwiLFxuICBcIkhvc2VhXCIsXG4gIFwiSm9lbFwiLFxuICBcIkFtb3NcIixcbiAgXCJPYmFkaWFoXCIsXG4gIFwiSm9uYWhcIixcbiAgXCJNaWNhaFwiLFxuICBcIk5haHVtXCIsXG4gIFwiSGFiYWtrdWtcIixcbiAgXCJaZXBoYW5pYWhcIixcbiAgXCJIYWdnYWlcIixcbiAgXCJaZWNoYXJpYWhcIixcbiAgXCJNYWxhY2hpXCIsXG4gIFwiTWF0dGhld1wiLFxuICBcIk1hcmtcIixcbiAgXCJMdWtlXCIsXG4gIFwiSm9oblwiLFxuICBcIkFjdHNcIixcbiAgXCJSb21hbnNcIixcbiAgXCIxIENvcmludGhpYW5zXCIsXG4gIFwiMiBDb3JpbnRoaWFuc1wiLFxuICBcIkdhbGF0aWFuc1wiLFxuICBcIkVwaGVzaWFuc1wiLFxuICBcIlBoaWxpcHBpYW5zXCIsXG4gIFwiQ29sb3NzaWFuc1wiLFxuICBcIjEgVGhlc3NhbG9uaWFuc1wiLFxuICBcIjIgVGhlc3NhbG9uaWFuc1wiLFxuICBcIjEgVGltb3RoeVwiLFxuICBcIjIgVGltb3RoeVwiLFxuICBcIlRpdHVzXCIsXG4gIFwiUGhpbGVtb25cIixcbiAgXCJIZWJyZXdzXCIsXG4gIFwiSmFtZXNcIixcbiAgXCIxIFBldGVyXCIsXG4gIFwiMiBQZXRlclwiLFxuICBcIjEgSm9oblwiLFxuICBcIjIgSm9oblwiLFxuICBcIjMgSm9oblwiLFxuICBcIkp1ZGVcIixcbiAgXCJSZXZlbGF0aW9uXCIsXG4gIFwiVG9iaXRcIixcbiAgXCJKdWRpdGhcIixcbiAgXCJFc3RoZXIgR3JlZWtcIixcbiAgXCJXaXNkb20gb2YgU29sb21vblwiLFxuICBcIlNpcmFjaCAoRWNjbGVzaWFzdGljdXMpXCIsXG4gIFwiQmFydWNoXCIsXG4gIFwiTGV0dGVyIG9mIEplcmVtaWFoXCIsXG4gIFwiU29uZyBvZiAzIFlvdW5nIE1lblwiLFxuICBcIlN1c2FubmFcIixcbiAgXCJCZWwgYW5kIHRoZSBEcmFnb25cIixcbiAgXCIxIE1hY2NhYmVlc1wiLFxuICBcIjIgTWFjY2FiZWVzXCIsXG4gIFwiMyBNYWNjYWJlZXNcIixcbiAgXCI0IE1hY2NhYmVlc1wiLFxuICBcIjEgRXNkcmFzIChHcmVlaylcIixcbiAgXCIyIEVzZHJhcyAoTGF0aW4pXCIsXG4gIFwiUHJheWVyIG9mIE1hbmFzc2VoXCIsXG4gIFwiUHNhbG0gMTUxXCIsXG4gIFwiT2Rlc1wiLFxuICBcIlBzYWxtcyBvZiBTb2xvbW9uXCIsXG4gIC8vIFdBUk5JTkcsIGlmIHlvdSBjaGFuZ2UgdGhlIHNwZWxsaW5nIG9mIHRoZSAqb2Jzb2xldGUqIHRhZyBiZSBzdXJlIHRvIHVwZGF0ZVxuICAvLyBJc09ic29sZXRlIHJvdXRpbmVcbiAgXCJKb3NodWEgQS4gKm9ic29sZXRlKlwiLFxuICBcIkp1ZGdlcyBCLiAqb2Jzb2xldGUqXCIsXG4gIFwiVG9iaXQgUy4gKm9ic29sZXRlKlwiLFxuICBcIlN1c2FubmEgVGguICpvYnNvbGV0ZSpcIixcbiAgXCJEYW5pZWwgVGguICpvYnNvbGV0ZSpcIixcbiAgXCJCZWwgVGguICpvYnNvbGV0ZSpcIixcbiAgXCJFeHRyYSBBXCIsXG4gIFwiRXh0cmEgQlwiLFxuICBcIkV4dHJhIENcIixcbiAgXCJFeHRyYSBEXCIsXG4gIFwiRXh0cmEgRVwiLFxuICBcIkV4dHJhIEZcIixcbiAgXCJFeHRyYSBHXCIsXG4gIFwiRnJvbnQgTWF0dGVyXCIsXG4gIFwiQmFjayBNYXR0ZXJcIixcbiAgXCJPdGhlciBNYXR0ZXJcIixcbiAgXCIzIEV6cmEgKm9ic29sZXRlKlwiLFxuICBcIkFwb2NhbHlwc2Ugb2YgRXpyYVwiLFxuICBcIjUgRXpyYSAoTGF0aW4gUHJvbG9ndWUpXCIsXG4gIFwiNiBFenJhIChMYXRpbiBFcGlsb2d1ZSlcIixcbiAgXCJJbnRyb2R1Y3Rpb25cIixcbiAgXCJDb25jb3JkYW5jZSBcIixcbiAgXCJHbG9zc2FyeSBcIixcbiAgXCJUb3BpY2FsIEluZGV4XCIsXG4gIFwiTmFtZXMgSW5kZXhcIixcbiAgXCJEYW5pZWwgR3JlZWtcIixcbiAgXCJQc2FsbXMgMTUyLTE1NVwiLFxuICBcIjIgQmFydWNoIChBcG9jYWx5cHNlKVwiLFxuICBcIkxldHRlciBvZiBCYXJ1Y2hcIixcbiAgXCJKdWJpbGVlc1wiLFxuICBcIkVub2NoXCIsXG4gIFwiMSBNZXFhYnlhblwiLFxuICBcIjIgTWVxYWJ5YW5cIixcbiAgXCIzIE1lcWFieWFuXCIsXG4gIFwiUmVwcm9vZiAoUHJvdmVyYnMgMjUtMzEpXCIsXG4gIFwiNCBCYXJ1Y2ggKFJlc3Qgb2YgQmFydWNoKVwiLFxuICBcIkxhb2RpY2VhbnNcIlxuXSwgWnQgPSBEbigpO1xuZnVuY3Rpb24gZ3QodCwgZSA9ICEwKSB7XG4gIHJldHVybiBlICYmICh0ID0gdC50b1VwcGVyQ2FzZSgpKSwgdCBpbiBadCA/IFp0W3RdIDogMDtcbn1cbmZ1bmN0aW9uIFZ0KHQpIHtcbiAgcmV0dXJuIGd0KHQpID4gMDtcbn1cbmZ1bmN0aW9uIGNuKHQpIHtcbiAgY29uc3QgZSA9IHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBndCh0KSA6IHQ7XG4gIHJldHVybiBlID49IDQwICYmIGUgPD0gNjY7XG59XG5mdW5jdGlvbiBsbih0KSB7XG4gIHJldHVybiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IGd0KHQpIDogdCkgPD0gMzk7XG59XG5mdW5jdGlvbiBNcih0KSB7XG4gIHJldHVybiB0IDw9IDY2O1xufVxuZnVuY3Rpb24gZm4odCkge1xuICBjb25zdCBlID0gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IGd0KHQpIDogdDtcbiAgcmV0dXJuIF9yKGUpICYmICFNcihlKTtcbn1cbmZ1bmN0aW9uKiBwbigpIHtcbiAgZm9yIChsZXQgdCA9IDE7IHQgPD0gaXQubGVuZ3RoOyB0KyspIHlpZWxkIHQ7XG59XG5jb25zdCBobiA9IDEsIEJyID0gaXQubGVuZ3RoO1xuZnVuY3Rpb24gZG4oKSB7XG4gIHJldHVybiBbXCJYWEFcIiwgXCJYWEJcIiwgXCJYWENcIiwgXCJYWERcIiwgXCJYWEVcIiwgXCJYWEZcIiwgXCJYWEdcIl07XG59XG5mdW5jdGlvbiBHdCh0LCBlID0gXCIqKipcIikge1xuICBjb25zdCBuID0gdCAtIDE7XG4gIHJldHVybiBuIDwgMCB8fCBuID49IGl0Lmxlbmd0aCA/IGUgOiBpdFtuXTtcbn1cbmZ1bmN0aW9uIFJyKHQpIHtcbiAgcmV0dXJuIHQgPD0gMCB8fCB0ID4gQnIgPyBcIioqKioqKlwiIDogeHJbdCAtIDFdO1xufVxuZnVuY3Rpb24gbW4odCkge1xuICByZXR1cm4gUnIoZ3QodCkpO1xufVxuZnVuY3Rpb24gX3IodCkge1xuICBjb25zdCBlID0gdHlwZW9mIHQgPT0gXCJudW1iZXJcIiA/IEd0KHQpIDogdDtcbiAgcmV0dXJuIFZ0KGUpICYmICEkdC5pbmNsdWRlcyhlKTtcbn1cbmZ1bmN0aW9uIEVuKHQpIHtcbiAgY29uc3QgZSA9IHR5cGVvZiB0ID09IFwibnVtYmVyXCIgPyBHdCh0KSA6IHQ7XG4gIHJldHVybiBWdChlKSAmJiAkdC5pbmNsdWRlcyhlKTtcbn1cbmZ1bmN0aW9uIGduKHQpIHtcbiAgcmV0dXJuIHhyW3QgLSAxXS5pbmNsdWRlcyhcIipvYnNvbGV0ZSpcIik7XG59XG5mdW5jdGlvbiBEbigpIHtcbiAgY29uc3QgdCA9IHt9O1xuICBmb3IgKGxldCBlID0gMDsgZSA8IGl0Lmxlbmd0aDsgZSsrKVxuICAgIHRbaXRbZV1dID0gZSArIDE7XG4gIHJldHVybiB0O1xufVxuY29uc3QgYmUgPSB7XG4gIGFsbEJvb2tJZHM6IGl0LFxuICBub25DYW5vbmljYWxJZHM6ICR0LFxuICBib29rSWRUb051bWJlcjogZ3QsXG4gIGlzQm9va0lkVmFsaWQ6IFZ0LFxuICBpc0Jvb2tOVDogY24sXG4gIGlzQm9va09UOiBsbixcbiAgaXNCb29rT1ROVDogTXIsXG4gIGlzQm9va0RDOiBmbixcbiAgYWxsQm9va051bWJlcnM6IHBuLFxuICBmaXJzdEJvb2s6IGhuLFxuICBsYXN0Qm9vazogQnIsXG4gIGV4dHJhQm9va3M6IGRuLFxuICBib29rTnVtYmVyVG9JZDogR3QsXG4gIGJvb2tOdW1iZXJUb0VuZ2xpc2hOYW1lOiBScixcbiAgYm9va0lkVG9FbmdsaXNoTmFtZTogbW4sXG4gIGlzQ2Fub25pY2FsOiBfcixcbiAgaXNFeHRyYU1hdGVyaWFsOiBFbixcbiAgaXNPYnNvbGV0ZTogZ25cbn07XG52YXIgTGUgPSAvKiBAX19QVVJFX18gKi8gKCh0KSA9PiAodFt0LlVua25vd24gPSAwXSA9IFwiVW5rbm93blwiLCB0W3QuT3JpZ2luYWwgPSAxXSA9IFwiT3JpZ2luYWxcIiwgdFt0LlNlcHR1YWdpbnQgPSAyXSA9IFwiU2VwdHVhZ2ludFwiLCB0W3QuVnVsZ2F0ZSA9IDNdID0gXCJWdWxnYXRlXCIsIHRbdC5FbmdsaXNoID0gNF0gPSBcIkVuZ2xpc2hcIiwgdFt0LlJ1c3NpYW5Qcm90ZXN0YW50ID0gNV0gPSBcIlJ1c3NpYW5Qcm90ZXN0YW50XCIsIHRbdC5SdXNzaWFuT3J0aG9kb3ggPSA2XSA9IFwiUnVzc2lhbk9ydGhvZG94XCIsIHQpKShMZSB8fCB7fSk7XG5jb25zdCBUZSA9IGNsYXNzIHtcbiAgLy8gcHJpdmF0ZSB2ZXJzSW5mbzogVmVyc2lmaWNhdGlvbjtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGlmICh6KHRoaXMsIFwibmFtZVwiKSwgeih0aGlzLCBcImZ1bGxQYXRoXCIpLCB6KHRoaXMsIFwiaXNQcmVzZW50XCIpLCB6KHRoaXMsIFwiaGFzVmVyc2VTZWdtZW50c1wiKSwgeih0aGlzLCBcImlzQ3VzdG9taXplZFwiKSwgeih0aGlzLCBcImJhc2VWZXJzaWZpY2F0aW9uXCIpLCB6KHRoaXMsIFwic2NyaXB0dXJlQm9va3NcIiksIHoodGhpcywgXCJfdHlwZVwiKSwgZSA9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgdW5kZWZpbmVkXCIpO1xuICAgIHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyAodGhpcy5uYW1lID0gZSwgdGhpcy5fdHlwZSA9IExlW2VdKSA6ICh0aGlzLl90eXBlID0gZSwgdGhpcy5uYW1lID0gTGVbZV0pO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlO1xuICB9XG4gIGVxdWFscyhlKSB7XG4gICAgcmV0dXJuICFlLnR5cGUgfHwgIXRoaXMudHlwZSA/ICExIDogZS50eXBlID09PSB0aGlzLnR5cGU7XG4gIH1cbn07XG56KFRlLCBcIk9yaWdpbmFsXCIsIG5ldyBUZShMZS5PcmlnaW5hbCkpLCB6KFRlLCBcIlNlcHR1YWdpbnRcIiwgbmV3IFRlKExlLlNlcHR1YWdpbnQpKSwgeihUZSwgXCJWdWxnYXRlXCIsIG5ldyBUZShMZS5WdWxnYXRlKSksIHooVGUsIFwiRW5nbGlzaFwiLCBuZXcgVGUoTGUuRW5nbGlzaCkpLCB6KFRlLCBcIlJ1c3NpYW5Qcm90ZXN0YW50XCIsIG5ldyBUZShMZS5SdXNzaWFuUHJvdGVzdGFudCkpLCB6KFRlLCBcIlJ1c3NpYW5PcnRob2RveFwiLCBuZXcgVGUoTGUuUnVzc2lhbk9ydGhvZG94KSk7XG5sZXQgbnQgPSBUZTtcbmZ1bmN0aW9uIGVyKHQsIGUpIHtcbiAgY29uc3QgbiA9IGVbMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgZS5sZW5ndGg7IGkrKylcbiAgICB0ID0gdC5zcGxpdChlW2ldKS5qb2luKG4pO1xuICByZXR1cm4gdC5zcGxpdChuKTtcbn1cbnZhciBQciA9IC8qIEBfX1BVUkVfXyAqLyAoKHQpID0+ICh0W3QuVmFsaWQgPSAwXSA9IFwiVmFsaWRcIiwgdFt0LlVua25vd25WZXJzaWZpY2F0aW9uID0gMV0gPSBcIlVua25vd25WZXJzaWZpY2F0aW9uXCIsIHRbdC5PdXRPZlJhbmdlID0gMl0gPSBcIk91dE9mUmFuZ2VcIiwgdFt0LlZlcnNlT3V0T2ZPcmRlciA9IDNdID0gXCJWZXJzZU91dE9mT3JkZXJcIiwgdFt0LlZlcnNlUmVwZWF0ZWQgPSA0XSA9IFwiVmVyc2VSZXBlYXRlZFwiLCB0KSkoUHIgfHwge30pO1xuY29uc3QgRGUgPSBjbGFzcyBZIHtcbiAgY29uc3RydWN0b3IoZSwgbiwgaSwgbykge1xuICAgIGlmICh6KHRoaXMsIFwiZmlyc3RDaGFwdGVyXCIpLCB6KHRoaXMsIFwibGFzdENoYXB0ZXJcIiksIHoodGhpcywgXCJsYXN0VmVyc2VcIiksIHoodGhpcywgXCJoYXNTZWdtZW50c0RlZmluZWRcIiksIHoodGhpcywgXCJ0ZXh0XCIpLCB6KHRoaXMsIFwiQkJCQ0NDVlZWU1wiKSwgeih0aGlzLCBcImxvbmdIYXNoQ29kZVwiKSwgeih0aGlzLCBcInZlcnNpZmljYXRpb25cIiksIHoodGhpcywgXCJydGxNYXJrXCIsIFwi4oCPXCIpLCB6KHRoaXMsIFwiX2Jvb2tOdW1cIiwgMCksIHoodGhpcywgXCJfY2hhcHRlck51bVwiLCAwKSwgeih0aGlzLCBcIl92ZXJzZU51bVwiLCAwKSwgeih0aGlzLCBcIl92ZXJzZVwiKSwgaSA9PSBudWxsICYmIG8gPT0gbnVsbClcbiAgICAgIGlmIChlICE9IG51bGwgJiYgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBhID0gZSwgaCA9IG4gIT0gbnVsbCAmJiBuIGluc3RhbmNlb2YgbnQgPyBuIDogdm9pZCAwO1xuICAgICAgICB0aGlzLnNldEVtcHR5KGgpLCB0aGlzLnBhcnNlKGEpO1xuICAgICAgfSBlbHNlIGlmIChlICE9IG51bGwgJiYgdHlwZW9mIGUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICBjb25zdCBhID0gbiAhPSBudWxsICYmIG4gaW5zdGFuY2VvZiBudCA/IG4gOiB2b2lkIDA7XG4gICAgICAgIHRoaXMuc2V0RW1wdHkoYSksIHRoaXMuX3ZlcnNlTnVtID0gZSAlIFkuY2hhcHRlckRpZ2l0U2hpZnRlciwgdGhpcy5fY2hhcHRlck51bSA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgZSAlIFkuYm9va0RpZ2l0U2hpZnRlciAvIFkuY2hhcHRlckRpZ2l0U2hpZnRlclxuICAgICAgICApLCB0aGlzLl9ib29rTnVtID0gTWF0aC5mbG9vcihlIC8gWS5ib29rRGlnaXRTaGlmdGVyKTtcbiAgICAgIH0gZWxzZSBpZiAobiA9PSBudWxsKVxuICAgICAgICBpZiAoZSAhPSBudWxsICYmIGUgaW5zdGFuY2VvZiBZKSB7XG4gICAgICAgICAgY29uc3QgYSA9IGU7XG4gICAgICAgICAgdGhpcy5fYm9va051bSA9IGEuYm9va051bSwgdGhpcy5fY2hhcHRlck51bSA9IGEuY2hhcHRlck51bSwgdGhpcy5fdmVyc2VOdW0gPSBhLnZlcnNlTnVtLCB0aGlzLl92ZXJzZSA9IGEudmVyc2UsIHRoaXMudmVyc2lmaWNhdGlvbiA9IGEudmVyc2lmaWNhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgYSA9IGUgaW5zdGFuY2VvZiBudCA/IGUgOiBZLmRlZmF1bHRWZXJzaWZpY2F0aW9uO1xuICAgICAgICAgIHRoaXMuc2V0RW1wdHkoYSk7XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2VSZWYgY29uc3RydWN0b3Igbm90IHN1cHBvcnRlZC5cIik7XG4gICAgZWxzZSBpZiAoZSAhPSBudWxsICYmIG4gIT0gbnVsbCAmJiBpICE9IG51bGwpXG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBpID09IFwic3RyaW5nXCIpXG4gICAgICAgIHRoaXMuc2V0RW1wdHkobyksIHRoaXMudXBkYXRlSW50ZXJuYWwoZSwgbiwgaSk7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZSA9PSBcIm51bWJlclwiICYmIHR5cGVvZiBuID09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGkgPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhpcy5fYm9va051bSA9IGUsIHRoaXMuX2NoYXB0ZXJOdW0gPSBuLCB0aGlzLl92ZXJzZU51bSA9IGksIHRoaXMudmVyc2lmaWNhdGlvbiA9IG8gPz8gWS5kZWZhdWx0VmVyc2lmaWNhdGlvbjtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2VSZWYgY29uc3RydWN0b3Igbm90IHN1cHBvcnRlZC5cIik7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2VSZWYgY29uc3RydWN0b3Igbm90IHN1cHBvcnRlZC5cIik7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIHZlcnNlIHN0cmluZyBpcyBpbiBhIHZhbGlkIGZvcm1hdCAoZG9lcyBub3QgY29uc2lkZXIgdmVyc2lmaWNhdGlvbikuXG4gICAqL1xuICBzdGF0aWMgaXNWZXJzZVBhcnNlYWJsZShlKSB7XG4gICAgcmV0dXJuIGUubGVuZ3RoID4gMCAmJiBcIjAxMjM0NTY3ODlcIi5pbmNsdWRlcyhlWzBdKSAmJiAhZS5lbmRzV2l0aCh0aGlzLnZlcnNlUmFuZ2VTZXBhcmF0b3IpICYmICFlLmVuZHNXaXRoKHRoaXMudmVyc2VTZXF1ZW5jZUluZGljYXRvcik7XG4gIH1cbiAgLyoqXG4gICAqIFRyaWVzIHRvIHBhcnNlIHRoZSBzcGVjaWZpZWQgc3RyaW5nIGludG8gYSB2ZXJzZSByZWZlcmVuY2UuXG4gICAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nIHRvIGF0dGVtcHQgdG8gcGFyc2UuXG4gICAqIEByZXR1cm5zIHN1Y2Nlc3M6IGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIHN0cmluZyB3YXMgc3VjY2Vzc2Z1bGx5IHBhcnNlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEByZXR1cm5zIHZlcnNlUmVmOiBUaGUgcmVzdWx0IG9mIHRoZSBwYXJzZSBpZiBzdWNjZXNzZnVsLCBvciBlbXB0eSBWZXJzZVJlZiBpZiBpdCBmYWlsZWRcbiAgICovXG4gIHN0YXRpYyB0cnlQYXJzZShlKSB7XG4gICAgbGV0IG47XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuID0gbmV3IFkoZSksIHsgc3VjY2VzczogITAsIHZlcnNlUmVmOiBuIH07XG4gICAgfSBjYXRjaCAoaSkge1xuICAgICAgaWYgKGkgaW5zdGFuY2VvZiBDdClcbiAgICAgICAgcmV0dXJuIG4gPSBuZXcgWSgpLCB7IHN1Y2Nlc3M6ICExLCB2ZXJzZVJlZjogbiB9O1xuICAgICAgdGhyb3cgaTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJlZmVyZW5jZSBhcyBhIGNvbXBhcmFibGUgaW50ZWdlciB3aGVyZSB0aGUgYm9vaywgY2hhcHRlciwgYW5kIHZlcnNlIGVhY2ggb2NjdXB5IDNcbiAgICogZGlnaXRzLlxuICAgKiBAcGFyYW0gYm9va051bSAtIEJvb2sgbnVtYmVyICh0aGlzIGlzIDEtYmFzZWQsIG5vdCBhbiBpbmRleCkuXG4gICAqIEBwYXJhbSBjaGFwdGVyTnVtIC0gQ2hhcHRlciBudW1iZXIuXG4gICAqIEBwYXJhbSB2ZXJzZU51bSAtIFZlcnNlIG51bWJlci5cbiAgICogQHJldHVybnMgVGhlIHJlZmVyZW5jZSBhcyBhIGNvbXBhcmFibGUgaW50ZWdlciB3aGVyZSB0aGUgYm9vaywgY2hhcHRlciwgYW5kIHZlcnNlIGVhY2ggb2NjdXB5IDNcbiAgICogZGlnaXRzLlxuICAgKi9cbiAgc3RhdGljIGdldEJCQkNDQ1ZWVihlLCBuLCBpKSB7XG4gICAgcmV0dXJuIGUgJSBZLmJjdk1heFZhbHVlICogWS5ib29rRGlnaXRTaGlmdGVyICsgKG4gPj0gMCA/IG4gJSBZLmJjdk1heFZhbHVlICogWS5jaGFwdGVyRGlnaXRTaGlmdGVyIDogMCkgKyAoaSA+PSAwID8gaSAlIFkuYmN2TWF4VmFsdWUgOiAwKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIGEgc2VyaWFsaXplZCBWZXJzZVJlZi5cbiAgICogQHBhcmFtIHNlcmlhbGl6ZWRWZXJzZVJlZiAtIFNlcmlhbGl6ZWQgVmVyc2VSZWYgdG8gY3JlYXRlIGZyb20uXG4gICAqIEByZXR1cm5zIHRoZSBkZXNlcmlhbGl6ZWQgVmVyc2VSZWYuXG4gICAqL1xuICBzdGF0aWMgZnJvbUpTT04oZSkge1xuICAgIGNvbnN0IHsgYm9vazogbiwgY2hhcHRlck51bTogaSwgdmVyc2VOdW06IG8sIHZlcnNlOiBhLCB2ZXJzaWZpY2F0aW9uU3RyOiBoIH0gPSBlLCBwID0gYSB8fCBvLnRvU3RyaW5nKCk7XG4gICAgbGV0IGY7XG4gICAgcmV0dXJuIGggJiYgKGYgPSBuZXcgbnQoaCkpLCBuID8gbmV3IFkobiwgaS50b1N0cmluZygpLCBwLCBmKSA6IG5ldyBZKCk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHZlcnNlIHN0cmluZyBhbmQgZ2V0cyB0aGUgbGVhZGluZyBudW1lcmljIHBvcnRpb24gYXMgYSBudW1iZXIuXG4gICAqIEBwYXJhbSB2ZXJzZVN0ciAtIHZlcnNlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBlbnRpcmUgc3RyaW5nIGNvdWxkIGJlIHBhcnNlZCBhcyBhIHNpbmdsZSwgc2ltcGxlIHZlcnNlIG51bWJlciAoMS05OTkpO1xuICAgKiAgICBmYWxzZSBpZiB0aGUgdmVyc2Ugc3RyaW5nIHJlcHJlc2VudGVkIGEgdmVyc2UgYnJpZGdlLCBjb250YWluZWQgc2VnbWVudCBsZXR0ZXJzLCBvciB3YXMgaW52YWxpZFxuICAgKi9cbiAgc3RhdGljIHRyeUdldFZlcnNlTnVtKGUpIHtcbiAgICBsZXQgbjtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gbiA9IC0xLCB7IHN1Y2Nlc3M6ICEwLCB2TnVtOiBuIH07XG4gICAgbiA9IDA7XG4gICAgbGV0IGk7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBlLmxlbmd0aDsgbysrKSB7XG4gICAgICBpZiAoaSA9IGVbb10sIGkgPCBcIjBcIiB8fCBpID4gXCI5XCIpXG4gICAgICAgIHJldHVybiBvID09PSAwICYmIChuID0gLTEpLCB7IHN1Y2Nlc3M6ICExLCB2TnVtOiBuIH07XG4gICAgICBpZiAobiA9IG4gKiAxMCArICtpIC0gMCwgbiA+IFkuYmN2TWF4VmFsdWUpXG4gICAgICAgIHJldHVybiBuID0gLTEsIHsgc3VjY2VzczogITEsIHZOdW06IG4gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogITAsIHZOdW06IG4gfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSBpZiBhIFZlcnNlUmVmIGhhc24ndCBiZWVuIHNldCAtIGFsbCB2YWx1ZXMgYXJlIHRoZSBkZWZhdWx0LlxuICAgKi9cbiAgZ2V0IGlzRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib29rTnVtID09PSAwICYmIHRoaXMuY2hhcHRlck51bSA9PT0gMCAmJiB0aGlzLnZlcnNlTnVtID09PSAwICYmIHRoaXMudmVyc2lmaWNhdGlvbiA9PSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgdGhlIHZlcnNlIGNvbnRhaW5zIG11bHRpcGxlIHZlcnNlcy5cbiAgICovXG4gIGdldCBoYXNNdWx0aXBsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVyc2UgIT0gbnVsbCAmJiAodGhpcy5fdmVyc2UuaW5jbHVkZXMoWS52ZXJzZVJhbmdlU2VwYXJhdG9yKSB8fCB0aGlzLl92ZXJzZS5pbmNsdWRlcyhZLnZlcnNlU2VxdWVuY2VJbmRpY2F0b3IpKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBib29rIG9mIHRoZSByZWZlcmVuY2UuIEJvb2sgaXMgdGhlIDMtbGV0dGVyIGFiYnJldmlhdGlvbiBpbiBjYXBpdGFsIGxldHRlcnMsXG4gICAqIGUuZy4gYCdNQVQnYC5cbiAgICovXG4gIGdldCBib29rKCkge1xuICAgIHJldHVybiBiZS5ib29rTnVtYmVyVG9JZCh0aGlzLmJvb2tOdW0sIFwiXCIpO1xuICB9XG4gIHNldCBib29rKGUpIHtcbiAgICB0aGlzLmJvb2tOdW0gPSBiZS5ib29rSWRUb051bWJlcihlKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBjaGFwdGVyIG9mIHRoZSByZWZlcmVuY2UsLiBlLmcuIGAnMydgLlxuICAgKi9cbiAgZ2V0IGNoYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEZWZhdWx0IHx8IHRoaXMuX2NoYXB0ZXJOdW0gPCAwID8gXCJcIiA6IHRoaXMuX2NoYXB0ZXJOdW0udG9TdHJpbmcoKTtcbiAgfVxuICBzZXQgY2hhcHRlcihlKSB7XG4gICAgY29uc3QgbiA9ICtlO1xuICAgIHRoaXMuX2NoYXB0ZXJOdW0gPSBOdW1iZXIuaXNJbnRlZ2VyKG4pID8gbiA6IC0xO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIHZlcnNlIG9mIHRoZSByZWZlcmVuY2UsIGluY2x1ZGluZyByYW5nZSwgc2VnbWVudHMsIGFuZCBzZXF1ZW5jZXMsIGUuZy4gYCc0J2AsXG4gICAqIG9yIGAnNGItNWEsIDcnYC5cbiAgICovXG4gIGdldCB2ZXJzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVyc2UgIT0gbnVsbCA/IHRoaXMuX3ZlcnNlIDogdGhpcy5pc0RlZmF1bHQgfHwgdGhpcy5fdmVyc2VOdW0gPCAwID8gXCJcIiA6IHRoaXMuX3ZlcnNlTnVtLnRvU3RyaW5nKCk7XG4gIH1cbiAgc2V0IHZlcnNlKGUpIHtcbiAgICBjb25zdCB7IHN1Y2Nlc3M6IG4sIHZOdW06IGkgfSA9IFkudHJ5R2V0VmVyc2VOdW0oZSk7XG4gICAgdGhpcy5fdmVyc2UgPSBuID8gdm9pZCAwIDogZS5yZXBsYWNlKHRoaXMucnRsTWFyaywgXCJcIiksIHRoaXMuX3ZlcnNlTnVtID0gaSwgISh0aGlzLl92ZXJzZU51bSA+PSAwKSAmJiAoeyB2TnVtOiB0aGlzLl92ZXJzZU51bSB9ID0gWS50cnlHZXRWZXJzZU51bSh0aGlzLl92ZXJzZSkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IEJvb2sgYmFzZWQgb24gYm9vayBudW1iZXIsIGUuZy4gYDQyYC5cbiAgICovXG4gIGdldCBib29rTnVtKCkge1xuICAgIHJldHVybiB0aGlzLl9ib29rTnVtO1xuICB9XG4gIHNldCBib29rTnVtKGUpIHtcbiAgICBpZiAoZSA8PSAwIHx8IGUgPiBiZS5sYXN0Qm9vaylcbiAgICAgIHRocm93IG5ldyBDdChcbiAgICAgICAgXCJCb29rTnVtIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8gYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBsYXN0IGJvb2tcIlxuICAgICAgKTtcbiAgICB0aGlzLl9ib29rTnVtID0gZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBjaGFwdGVyIG51bWJlciwgZS5nLiBgM2AuIGAtMWAgaWYgbm90IHZhbGlkLlxuICAgKi9cbiAgZ2V0IGNoYXB0ZXJOdW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXB0ZXJOdW07XG4gIH1cbiAgc2V0IGNoYXB0ZXJOdW0oZSkge1xuICAgIHRoaXMuY2hhcHRlck51bSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB2ZXJzZSBzdGFydCBudW1iZXIsIGUuZy4gYDRgLiBgLTFgIGlmIG5vdCB2YWxpZC5cbiAgICovXG4gIGdldCB2ZXJzZU51bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVyc2VOdW07XG4gIH1cbiAgc2V0IHZlcnNlTnVtKGUpIHtcbiAgICB0aGlzLl92ZXJzZU51bSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZlcnNpZmljYXRpb24gKHNob3VsZCBPTkxZIGJlIHVzZWQgZm9yIHNlcmlhbGl6YXRpb24vZGVzZXJpYWxpemF0aW9uKS5cbiAgICpcbiAgICogQHJlbWFya3MgVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2hlbiBTY3JWZXJzIHdhcyBhbiBlbnVtZXJhdGlvbi5cbiAgICovXG4gIGdldCB2ZXJzaWZpY2F0aW9uU3RyKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiAoZSA9IHRoaXMudmVyc2lmaWNhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IGUubmFtZTtcbiAgfVxuICBzZXQgdmVyc2lmaWNhdGlvblN0cihlKSB7XG4gICAgdGhpcy52ZXJzaWZpY2F0aW9uID0gdGhpcy52ZXJzaWZpY2F0aW9uICE9IG51bGwgPyBuZXcgbnQoZSkgOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIHJlZmVyZW5jZSBpcyB2YWxpZC5cbiAgICovXG4gIGdldCB2YWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFN0YXR1cyA9PT0gMDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB2YWxpZCBzdGF0dXMgZm9yIHRoaXMgcmVmZXJlbmNlLlxuICAgKi9cbiAgZ2V0IHZhbGlkU3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlVmVyc2UoWS52ZXJzZVJhbmdlU2VwYXJhdG9ycywgWS52ZXJzZVNlcXVlbmNlSW5kaWNhdG9ycyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJlZmVyZW5jZSBhcyBhIGNvbXBhcmFibGUgaW50ZWdlciB3aGVyZSB0aGUgYm9vayxcbiAgICogY2hhcHRlciwgYW5kIHZlcnNlIGVhY2ggb2NjdXB5IHRocmVlIGRpZ2l0cyBhbmQgdGhlIHZlcnNlIGlzIDAuXG4gICAqL1xuICBnZXQgQkJCQ0NDKCkge1xuICAgIHJldHVybiBZLmdldEJCQkNDQ1ZWVih0aGlzLl9ib29rTnVtLCB0aGlzLl9jaGFwdGVyTnVtLCAwKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcmVmZXJlbmNlIGFzIGEgY29tcGFyYWJsZSBpbnRlZ2VyIHdoZXJlIHRoZSBib29rLFxuICAgKiBjaGFwdGVyLCBhbmQgdmVyc2UgZWFjaCBvY2N1cHkgdGhyZWUgZGlnaXRzLiBJZiB2ZXJzZSBpcyBub3QgbnVsbFxuICAgKiAoaS5lLiwgdGhpcyByZWZlcmVuY2UgcmVwcmVzZW50cyBhIGNvbXBsZXggcmVmZXJlbmNlIHdpdGggdmVyc2VcbiAgICogc2VnbWVudHMgb3IgYnJpZGdlKSB0aGlzIGNhbm5vdCBiZSB1c2VkIGZvciBhbiBleGFjdCBjb21wYXJpc29uLlxuICAgKi9cbiAgZ2V0IEJCQkNDQ1ZWVigpIHtcbiAgICByZXR1cm4gWS5nZXRCQkJDQ0NWVlYodGhpcy5fYm9va051bSwgdGhpcy5fY2hhcHRlck51bSwgdGhpcy5fdmVyc2VOdW0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgdGhlIHZlcnNlIGlzIGRlZmluZWQgYXMgYW4gZXhjbHVkZWQgdmVyc2UgaW4gdGhlIHZlcnNpZmljYXRpb24uXG4gICAqIERvZXMgbm90IGhhbmRsZSB2ZXJzZSByYW5nZXMuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NsYXNzLWxpdGVyYWwtcHJvcGVydHktc3R5bGVcbiAgZ2V0IGlzRXhjbHVkZWQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIHJlZmVyZW5jZSBpbiB0aGUgc3BlY2lmaWVkIHN0cmluZy5cbiAgICogT3B0aW9uYWxseSB2ZXJzaWZpY2F0aW9uIGNhbiBmb2xsb3cgcmVmZXJlbmNlIGFzIGluIEdFTiAzOjExLzRcbiAgICogVGhyb3cgYW4gZXhjZXB0aW9uIGlmXG4gICAqIC0gaW52YWxpZCBib29rIG5hbWVcbiAgICogLSBjaGFwdGVyIG51bWJlciBpcyBtaXNzaW5nIG9yIG5vdCBhIG51bWJlclxuICAgKiAtIHZlcnNlIG51bWJlciBpcyBtaXNzaW5nIG9yIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBudW1iZXJcbiAgICogLSB2ZXJzaWZpY2F0aW9uIGlzIGludmFsaWRcbiAgICogQHBhcmFtIHZlcnNlU3RyIC0gc3RyaW5nIHRvIHBhcnNlIGUuZy4gJ01BVCAzOjExJ1xuICAgKi9cbiAgcGFyc2UoZSkge1xuICAgIGlmIChlID0gZS5yZXBsYWNlKHRoaXMucnRsTWFyaywgXCJcIiksIGUuaW5jbHVkZXMoXCIvXCIpKSB7XG4gICAgICBjb25zdCBhID0gZS5zcGxpdChcIi9cIik7XG4gICAgICBpZiAoZSA9IGFbMF0sIGEubGVuZ3RoID4gMSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBoID0gK2FbMV0udHJpbSgpO1xuICAgICAgICAgIHRoaXMudmVyc2lmaWNhdGlvbiA9IG5ldyBudChMZVtoXSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRocm93IG5ldyBDdChcIkludmFsaWQgcmVmZXJlbmNlIDogXCIgKyBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuID0gZS50cmltKCkuc3BsaXQoXCIgXCIpO1xuICAgIGlmIChuLmxlbmd0aCAhPT0gMilcbiAgICAgIHRocm93IG5ldyBDdChcIkludmFsaWQgcmVmZXJlbmNlIDogXCIgKyBlKTtcbiAgICBjb25zdCBpID0gblsxXS5zcGxpdChcIjpcIiksIG8gPSAraVswXTtcbiAgICBpZiAoaS5sZW5ndGggIT09IDIgfHwgYmUuYm9va0lkVG9OdW1iZXIoblswXSkgPT09IDAgfHwgIU51bWJlci5pc0ludGVnZXIobykgfHwgbyA8IDAgfHwgIVkuaXNWZXJzZVBhcnNlYWJsZShpWzFdKSlcbiAgICAgIHRocm93IG5ldyBDdChcIkludmFsaWQgcmVmZXJlbmNlIDogXCIgKyBlKTtcbiAgICB0aGlzLnVwZGF0ZUludGVybmFsKG5bMF0sIGlbMF0sIGlbMV0pO1xuICB9XG4gIC8qKlxuICAgKiBTaW1wbGlmaWVzIHRoaXMgdmVyc2UgcmVmIHNvIHRoYXQgaXQgaGFzIG5vIGJyaWRnaW5nIG9mIHZlcnNlcyBvclxuICAgKiB2ZXJzZSBzZWdtZW50cyBsaWtlIGAnMWEnYC5cbiAgICovXG4gIHNpbXBsaWZ5KCkge1xuICAgIHRoaXMuX3ZlcnNlID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIGNsb25lIG9mIHRoZSByZWZlcmVuY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBjbG9uZWQgVmVyc2VSZWYuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFkodGhpcyk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuYm9vaztcbiAgICByZXR1cm4gZSA9PT0gXCJcIiA/IFwiXCIgOiBgJHtlfSAke3RoaXMuY2hhcHRlcn06JHt0aGlzLnZlcnNlfWA7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIGxldCBlID0gdGhpcy52ZXJzZTtcbiAgICAoZSA9PT0gXCJcIiB8fCBlID09PSB0aGlzLnZlcnNlTnVtLnRvU3RyaW5nKCkpICYmIChlID0gdm9pZCAwKTtcbiAgICBjb25zdCBuID0ge1xuICAgICAgYm9vazogdGhpcy5ib29rLFxuICAgICAgY2hhcHRlck51bTogdGhpcy5jaGFwdGVyTnVtLFxuICAgICAgdmVyc2VOdW06IHRoaXMudmVyc2VOdW0sXG4gICAgICB2ZXJzZTogZSxcbiAgICAgIHZlcnNpZmljYXRpb25TdHI6IHRoaXMudmVyc2lmaWNhdGlvblN0clxuICAgIH07XG4gICAgcmV0dXJuIGUgfHwgZGVsZXRlIG4udmVyc2UsIG47XG4gIH1cbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoaXMgYFZlcnNlUmVmYCB3aXRoIHN1cHBsaWVkIG9uZS5cbiAgICogQHBhcmFtIHZlcnNlUmVmIC0gb2JqZWN0IHRvIGNvbXBhcmUgdGhpcyBvbmUgdG8uXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGBWZXJzZVJlZmAgaXMgZXF1YWwgdG8gdGhlIHN1cHBsaWVkIG9uZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBlcXVhbHMoZSkge1xuICAgIHJldHVybiBlIGluc3RhbmNlb2YgWSA/IGUuX2Jvb2tOdW0gPT09IHRoaXMuX2Jvb2tOdW0gJiYgZS5fY2hhcHRlck51bSA9PT0gdGhpcy5fY2hhcHRlck51bSAmJiBlLl92ZXJzZU51bSA9PT0gdGhpcy5fdmVyc2VOdW0gJiYgZS52ZXJzZSA9PT0gdGhpcy52ZXJzZSAmJiAoZS52ZXJzaWZpY2F0aW9uID09IG51bGwgJiYgdGhpcy52ZXJzaWZpY2F0aW9uID09IG51bGwgfHwgZS52ZXJzaWZpY2F0aW9uICE9IG51bGwgJiYgdGhpcy52ZXJzaWZpY2F0aW9uICE9IG51bGwgJiYgZS52ZXJzaWZpY2F0aW9uLmVxdWFscyh0aGlzLnZlcnNpZmljYXRpb24pKSA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBFbnVtZXJhdGUgYWxsIGluZGl2aWR1YWwgdmVyc2VzIGNvbnRhaW5lZCBpbiBhIFZlcnNlUmVmLlxuICAgKiBWZXJzZSByYW5nZXMgYXJlIGluZGljYXRlZCBieSBcIi1cIiBhbmQgY29uc2VjdXRpdmUgdmVyc2VzIGJ5IFwiLFwicy5cbiAgICogRXhhbXBsZXM6XG4gICAqIEdFTiAxOjIgcmV0dXJucyBHRU4gMToyXG4gICAqIEdFTiAxOjFhLTNiLDUgcmV0dXJucyBHRU4gMToxYSwgR0VOIDE6MiwgR0VOIDE6M2IsIEdFTiAxOjVcbiAgICogR0VOIDE6MmEtMmMgcmV0dXJucyAvLyEgPz8/Pz8/XG4gICAqXG4gICAqIEBwYXJhbSBzcGVjaWZpZWRWZXJzZXNPbmx5IC0gaWYgc2V0IHRvIDxjPnRydWU8L2M+IHJldHVybiBvbmx5IHZlcnNlcyB0aGF0IGFyZVxuICAgKiBleHBsaWNpdGx5IHNwZWNpZmllZCBvbmx5LCBub3QgdmVyc2VzIHdpdGhpbiBhIHJhbmdlLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKiBAcGFyYW0gdmVyc2VSYW5nZVNlcGFyYXRvcnMgLSBWZXJzZSByYW5nZSBzZXBhcmF0b3JzLlxuICAgKiBEZWZhdWx0cyB0byBgVmVyc2VSZWYudmVyc2VSYW5nZVNlcGFyYXRvcnNgLlxuICAgKiBAcGFyYW0gdmVyc2VTZXF1ZW5jZVNlcGFyYXRvcnMgLSBWZXJzZSBzZXF1ZW5jZSBzZXBhcmF0b3JzLlxuICAgKiBEZWZhdWx0cyB0byBgVmVyc2VSZWYudmVyc2VTZXF1ZW5jZUluZGljYXRvcnNgLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgc2luZ2xlIHZlcnNlIHJlZmVyZW5jZXMgaW4gdGhpcyBWZXJzZVJlZi5cbiAgICovXG4gIGFsbFZlcnNlcyhlID0gITEsIG4gPSBZLnZlcnNlUmFuZ2VTZXBhcmF0b3JzLCBpID0gWS52ZXJzZVNlcXVlbmNlSW5kaWNhdG9ycykge1xuICAgIGlmICh0aGlzLl92ZXJzZSA9PSBudWxsIHx8IHRoaXMuY2hhcHRlck51bSA8PSAwKVxuICAgICAgcmV0dXJuIFt0aGlzLmNsb25lKCldO1xuICAgIGNvbnN0IG8gPSBbXSwgYSA9IGVyKHRoaXMuX3ZlcnNlLCBpKTtcbiAgICBmb3IgKGNvbnN0IGggb2YgYS5tYXAoKHApID0+IGVyKHAsIG4pKSkge1xuICAgICAgY29uc3QgcCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHAudmVyc2UgPSBoWzBdO1xuICAgICAgY29uc3QgZiA9IHAudmVyc2VOdW07XG4gICAgICBpZiAoby5wdXNoKHApLCBoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKG0udmVyc2UgPSBoWzFdLCAhZSlcbiAgICAgICAgICBmb3IgKGxldCBFID0gZiArIDE7IEUgPCBtLnZlcnNlTnVtOyBFKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBuZXcgWShcbiAgICAgICAgICAgICAgdGhpcy5fYm9va051bSxcbiAgICAgICAgICAgICAgdGhpcy5fY2hhcHRlck51bSxcbiAgICAgICAgICAgICAgRSxcbiAgICAgICAgICAgICAgdGhpcy52ZXJzaWZpY2F0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5pc0V4Y2x1ZGVkIHx8IG8ucHVzaChsKTtcbiAgICAgICAgICB9XG4gICAgICAgIG8ucHVzaChtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhIHZlcnNlIG51bWJlciB1c2luZyB0aGUgc3VwcGxpZWQgc2VwYXJhdG9ycyByYXRoZXIgdGhhbiB0aGUgZGVmYXVsdHMuXG4gICAqL1xuICB2YWxpZGF0ZVZlcnNlKGUsIG4pIHtcbiAgICBpZiAoIXRoaXMudmVyc2UpXG4gICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFZhbGlkO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG8gb2YgdGhpcy5hbGxWZXJzZXMoITAsIGUsIG4pKSB7XG4gICAgICBjb25zdCBhID0gby5pbnRlcm5hbFZhbGlkO1xuICAgICAgaWYgKGEgIT09IDApXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgY29uc3QgaCA9IG8uQkJCQ0NDVlZWO1xuICAgICAgaWYgKGkgPiBoKVxuICAgICAgICByZXR1cm4gMztcbiAgICAgIGlmIChpID09PSBoKVxuICAgICAgICByZXR1cm4gNDtcbiAgICAgIGkgPSBoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIGEgc2luZ2xlIHZlcnNlIHJlZmVyZW5jZSBpcyB2YWxpZC5cbiAgICovXG4gIGdldCBpbnRlcm5hbFZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnNpZmljYXRpb24gPT0gbnVsbCA/IDEgOiB0aGlzLl9ib29rTnVtIDw9IDAgfHwgdGhpcy5fYm9va051bSA+IGJlLmxhc3RCb29rID8gMiA6IChiZS5pc0Nhbm9uaWNhbCh0aGlzLl9ib29rTnVtKSwgMCk7XG4gIH1cbiAgc2V0RW1wdHkoZSA9IFkuZGVmYXVsdFZlcnNpZmljYXRpb24pIHtcbiAgICB0aGlzLl9ib29rTnVtID0gMCwgdGhpcy5fY2hhcHRlck51bSA9IC0xLCB0aGlzLl92ZXJzZSA9IHZvaWQgMCwgdGhpcy52ZXJzaWZpY2F0aW9uID0gZTtcbiAgfVxuICB1cGRhdGVJbnRlcm5hbChlLCBuLCBpKSB7XG4gICAgdGhpcy5ib29rTnVtID0gYmUuYm9va0lkVG9OdW1iZXIoZSksIHRoaXMuY2hhcHRlciA9IG4sIHRoaXMudmVyc2UgPSBpO1xuICB9XG59O1xueihEZSwgXCJkZWZhdWx0VmVyc2lmaWNhdGlvblwiLCBudC5FbmdsaXNoKSwgeihEZSwgXCJ2ZXJzZVJhbmdlU2VwYXJhdG9yXCIsIFwiLVwiKSwgeihEZSwgXCJ2ZXJzZVNlcXVlbmNlSW5kaWNhdG9yXCIsIFwiLFwiKSwgeihEZSwgXCJ2ZXJzZVJhbmdlU2VwYXJhdG9yc1wiLCBbRGUudmVyc2VSYW5nZVNlcGFyYXRvcl0pLCB6KERlLCBcInZlcnNlU2VxdWVuY2VJbmRpY2F0b3JzXCIsIFtEZS52ZXJzZVNlcXVlbmNlSW5kaWNhdG9yXSksIHooRGUsIFwiY2hhcHRlckRpZ2l0U2hpZnRlclwiLCAxZTMpLCB6KERlLCBcImJvb2tEaWdpdFNoaWZ0ZXJcIiwgRGUuY2hhcHRlckRpZ2l0U2hpZnRlciAqIERlLmNoYXB0ZXJEaWdpdFNoaWZ0ZXIpLCB6KERlLCBcImJjdk1heFZhbHVlXCIsIERlLmNoYXB0ZXJEaWdpdFNoaWZ0ZXIgLSAxKSwgLyoqXG4qIFRoZSB2YWxpZCBzdGF0dXMgb2YgdGhlIFZlcnNlUmVmLlxuKi9cbnooRGUsIFwiVmFsaWRTdGF0dXNUeXBlXCIsIFByKTtcbmxldCBMciA9IERlO1xuY2xhc3MgQ3QgZXh0ZW5kcyBFcnJvciB7XG59XG52YXIgSCA9IHt9LCBzZSA9IHt9LCB0cjtcbmZ1bmN0aW9uIER0KCkge1xuICBpZiAodHIpIHJldHVybiBzZTtcbiAgdHIgPSAxO1xuICBmdW5jdGlvbiB0KFIsIGssICQpIHtcbiAgICBpZiAoJCA9PT0gdm9pZCAwICYmICgkID0gQXJyYXkucHJvdG90eXBlKSwgUiAmJiB0eXBlb2YgJC5maW5kID09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiAkLmZpbmQuY2FsbChSLCBrKTtcbiAgICBmb3IgKHZhciBuZSA9IDA7IG5lIDwgUi5sZW5ndGg7IG5lKyspXG4gICAgICBpZiAobihSLCBuZSkpIHtcbiAgICAgICAgdmFyIGxlID0gUltuZV07XG4gICAgICAgIGlmIChrLmNhbGwodm9pZCAwLCBsZSwgbmUsIFIpKVxuICAgICAgICAgIHJldHVybiBsZTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBlKFIsIGspIHtcbiAgICByZXR1cm4gayA9PT0gdm9pZCAwICYmIChrID0gT2JqZWN0KSwgayAmJiB0eXBlb2Ygay5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID09IFwiZnVuY3Rpb25cIiAmJiAoUiA9IGsuY3JlYXRlKG51bGwsIGsuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhSKSkpLCBrICYmIHR5cGVvZiBrLmZyZWV6ZSA9PSBcImZ1bmN0aW9uXCIgPyBrLmZyZWV6ZShSKSA6IFI7XG4gIH1cbiAgZnVuY3Rpb24gbihSLCBrKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChSLCBrKTtcbiAgfVxuICBmdW5jdGlvbiBpKFIsIGspIHtcbiAgICBpZiAoUiA9PT0gbnVsbCB8fCB0eXBlb2YgUiAhPSBcIm9iamVjdFwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRhcmdldCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgIGZvciAodmFyICQgaW4gaylcbiAgICAgIG4oaywgJCkgJiYgKFJbJF0gPSBrWyRdKTtcbiAgICByZXR1cm4gUjtcbiAgfVxuICB2YXIgbyA9IGUoe1xuICAgIGFsbG93ZnVsbHNjcmVlbjogITAsXG4gICAgYXN5bmM6ICEwLFxuICAgIGF1dG9mb2N1czogITAsXG4gICAgYXV0b3BsYXk6ICEwLFxuICAgIGNoZWNrZWQ6ICEwLFxuICAgIGNvbnRyb2xzOiAhMCxcbiAgICBkZWZhdWx0OiAhMCxcbiAgICBkZWZlcjogITAsXG4gICAgZGlzYWJsZWQ6ICEwLFxuICAgIGZvcm1ub3ZhbGlkYXRlOiAhMCxcbiAgICBoaWRkZW46ICEwLFxuICAgIGlzbWFwOiAhMCxcbiAgICBpdGVtc2NvcGU6ICEwLFxuICAgIGxvb3A6ICEwLFxuICAgIG11bHRpcGxlOiAhMCxcbiAgICBtdXRlZDogITAsXG4gICAgbm9tb2R1bGU6ICEwLFxuICAgIG5vdmFsaWRhdGU6ICEwLFxuICAgIG9wZW46ICEwLFxuICAgIHBsYXlzaW5saW5lOiAhMCxcbiAgICByZWFkb25seTogITAsXG4gICAgcmVxdWlyZWQ6ICEwLFxuICAgIHJldmVyc2VkOiAhMCxcbiAgICBzZWxlY3RlZDogITBcbiAgfSk7XG4gIGZ1bmN0aW9uIGEoUikge1xuICAgIHJldHVybiBuKG8sIFIudG9Mb3dlckNhc2UoKSk7XG4gIH1cbiAgdmFyIGggPSBlKHtcbiAgICBhcmVhOiAhMCxcbiAgICBiYXNlOiAhMCxcbiAgICBicjogITAsXG4gICAgY29sOiAhMCxcbiAgICBlbWJlZDogITAsXG4gICAgaHI6ICEwLFxuICAgIGltZzogITAsXG4gICAgaW5wdXQ6ICEwLFxuICAgIGxpbms6ICEwLFxuICAgIG1ldGE6ICEwLFxuICAgIHBhcmFtOiAhMCxcbiAgICBzb3VyY2U6ICEwLFxuICAgIHRyYWNrOiAhMCxcbiAgICB3YnI6ICEwXG4gIH0pO1xuICBmdW5jdGlvbiBwKFIpIHtcbiAgICByZXR1cm4gbihoLCBSLnRvTG93ZXJDYXNlKCkpO1xuICB9XG4gIHZhciBmID0gZSh7XG4gICAgc2NyaXB0OiAhMSxcbiAgICBzdHlsZTogITEsXG4gICAgdGV4dGFyZWE6ICEwLFxuICAgIHRpdGxlOiAhMFxuICB9KTtcbiAgZnVuY3Rpb24gbShSKSB7XG4gICAgdmFyIGsgPSBSLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG4oZiwgaykgJiYgIWZba107XG4gIH1cbiAgZnVuY3Rpb24gRShSKSB7XG4gICAgdmFyIGsgPSBSLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG4oZiwgaykgJiYgZltrXTtcbiAgfVxuICBmdW5jdGlvbiBsKFIpIHtcbiAgICByZXR1cm4gUiA9PT0gTy5IVE1MO1xuICB9XG4gIGZ1bmN0aW9uIHYoUikge1xuICAgIHJldHVybiBsKFIpIHx8IFIgPT09IE8uWE1MX1hIVE1MX0FQUExJQ0FUSU9OO1xuICB9XG4gIHZhciBPID0gZSh7XG4gICAgLyoqXG4gICAgICogYHRleHQvaHRtbGAsIHRoZSBvbmx5IG1pbWUgdHlwZSB0aGF0IHRyaWdnZXJzIHRyZWF0aW5nIGFuIFhNTCBkb2N1bWVudCBhcyBIVE1MLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9tZWRpYS10eXBlcy90ZXh0L2h0bWwgSUFOQSBNaW1lVHlwZSByZWdpc3RyYXRpb25cbiAgICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hUTUwgV2lraXBlZGlhXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRE9NUGFyc2VyL3BhcnNlRnJvbVN0cmluZyBNRE5cbiAgICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2R5bmFtaWMtbWFya3VwLWluc2VydGlvbi5odG1sI2RvbS1kb21wYXJzZXItcGFyc2Vmcm9tc3RyaW5nXG4gICAgICogICAgICBXSEFUV0cgSFRNTCBTcGVjXG4gICAgICovXG4gICAgSFRNTDogXCJ0ZXh0L2h0bWxcIixcbiAgICAvKipcbiAgICAgKiBgYXBwbGljYXRpb24veG1sYCwgdGhlIHN0YW5kYXJkIG1pbWUgdHlwZSBmb3IgWE1MIGRvY3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbWVkaWEtdHlwZXMvYXBwbGljYXRpb24veG1sIElBTkEgTWltZVR5cGVcbiAgICAgKiAgICAgIHJlZ2lzdHJhdGlvblxuICAgICAqIEBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzczMDMjc2VjdGlvbi05LjEgUkZDIDczMDNcbiAgICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1hNTF9hbmRfTUlNRSBXaWtpcGVkaWFcbiAgICAgKi9cbiAgICBYTUxfQVBQTElDQVRJT046IFwiYXBwbGljYXRpb24veG1sXCIsXG4gICAgLyoqXG4gICAgICogYHRleHQveG1sYCwgYW4gYWxpYXMgZm9yIGBhcHBsaWNhdGlvbi94bWxgLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzMwMyNzZWN0aW9uLTkuMiBSRkMgNzMwM1xuICAgICAqIEBzZWUgaHR0cHM6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbWVkaWEtdHlwZXMvdGV4dC94bWwgSUFOQSBNaW1lVHlwZSByZWdpc3RyYXRpb25cbiAgICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1hNTF9hbmRfTUlNRSBXaWtpcGVkaWFcbiAgICAgKi9cbiAgICBYTUxfVEVYVDogXCJ0ZXh0L3htbFwiLFxuICAgIC8qKlxuICAgICAqIGBhcHBsaWNhdGlvbi94aHRtbCt4bWxgLCBpbmRpY2F0ZXMgYW4gWE1MIGRvY3VtZW50IHRoYXQgaGFzIHRoZSBkZWZhdWx0IEhUTUwgbmFtZXNwYWNlLFxuICAgICAqIGJ1dCBpcyBwYXJzZWQgYXMgYW4gWE1MIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9tZWRpYS10eXBlcy9hcHBsaWNhdGlvbi94aHRtbCt4bWwgSUFOQSBNaW1lVHlwZVxuICAgICAqICAgICAgcmVnaXN0cmF0aW9uXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1jcmVhdGVkb2N1bWVudCBXSEFUV0cgRE9NIFNwZWNcbiAgICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1hIVE1MIFdpa2lwZWRpYVxuICAgICAqL1xuICAgIFhNTF9YSFRNTF9BUFBMSUNBVElPTjogXCJhcHBsaWNhdGlvbi94aHRtbCt4bWxcIixcbiAgICAvKipcbiAgICAgKiBgaW1hZ2Uvc3ZnK3htbGAsXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL21lZGlhLXR5cGVzL2ltYWdlL3N2Zyt4bWwgSUFOQSBNaW1lVHlwZSByZWdpc3RyYXRpb25cbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS8gVzNDIFNWRyAxLjFcbiAgICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxhYmxlX1ZlY3Rvcl9HcmFwaGljcyBXaWtpcGVkaWFcbiAgICAgKi9cbiAgICBYTUxfU1ZHX0lNQUdFOiBcImltYWdlL3N2Zyt4bWxcIlxuICB9KSwgYiA9IE9iamVjdC5rZXlzKE8pLm1hcChmdW5jdGlvbihSKSB7XG4gICAgcmV0dXJuIE9bUl07XG4gIH0pO1xuICBmdW5jdGlvbiBDKFIpIHtcbiAgICByZXR1cm4gYi5pbmRleE9mKFIpID4gLTE7XG4gIH1cbiAgdmFyIGogPSBlKHtcbiAgICAvKipcbiAgICAgKiBUaGUgWEhUTUwgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXG4gICAgICovXG4gICAgSFRNTDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsXG4gICAgLyoqXG4gICAgICogVGhlIFNWRyBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXG4gICAgICovXG4gICAgU1ZHOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgLyoqXG4gICAgICogVGhlIGB4bWw6YCBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVxuICAgICAqL1xuICAgIFhNTDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgICAvKipcbiAgICAgKiBUaGUgYHhtbG5zOmAgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvMjAwMC94bWxucy9cbiAgICAgKi9cbiAgICBYTUxOUzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG4gIH0pO1xuICByZXR1cm4gc2UuYXNzaWduID0gaSwgc2UuZmluZCA9IHQsIHNlLmZyZWV6ZSA9IGUsIHNlLkhUTUxfQk9PTEVBTl9BVFRSSUJVVEVTID0gbywgc2UuSFRNTF9SQVdfVEVYVF9FTEVNRU5UUyA9IGYsIHNlLkhUTUxfVk9JRF9FTEVNRU5UUyA9IGgsIHNlLmhhc0RlZmF1bHRIVE1MTmFtZXNwYWNlID0gdiwgc2UuaGFzT3duID0gbiwgc2UuaXNIVE1MQm9vbGVhbkF0dHJpYnV0ZSA9IGEsIHNlLmlzSFRNTFJhd1RleHRFbGVtZW50ID0gbSwgc2UuaXNIVE1MRXNjYXBhYmxlUmF3VGV4dEVsZW1lbnQgPSBFLCBzZS5pc0hUTUxNaW1lVHlwZSA9IGwsIHNlLmlzSFRNTFZvaWRFbGVtZW50ID0gcCwgc2UuaXNWYWxpZE1pbWVUeXBlID0gQywgc2UuTUlNRV9UWVBFID0gTywgc2UuTkFNRVNQQUNFID0gaiwgc2U7XG59XG52YXIgZHQgPSB7fSwgcnI7XG5mdW5jdGlvbiBfdCgpIHtcbiAgaWYgKHJyKSByZXR1cm4gZHQ7XG4gIHJyID0gMTtcbiAgdmFyIHQgPSBEdCgpO1xuICBmdW5jdGlvbiBlKHYsIE8pIHtcbiAgICB2LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdiB9LFxuICAgICAgbmFtZTogeyB2YWx1ZTogdi5uYW1lLCBlbnVtZXJhYmxlOiAhMCwgd3JpdGFibGU6IE8gfVxuICAgIH0pO1xuICB9XG4gIHZhciBuID0gdC5mcmVlemUoe1xuICAgIC8qKlxuICAgICAqIHRoZSBkZWZhdWx0IHZhbHVlIGFzIGRlZmluZWQgYnkgdGhlIHNwZWNcbiAgICAgKi9cbiAgICBFcnJvcjogXCJFcnJvclwiLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogVXNlIFJhbmdlRXJyb3IgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBJbmRleFNpemVFcnJvcjogXCJJbmRleFNpemVFcnJvclwiLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogSnVzdCB0byBtYXRjaCB0aGUgcmVsYXRlZCBzdGF0aWMgY29kZSwgbm90IHBhcnQgb2YgdGhlIHNwZWMuXG4gICAgICovXG4gICAgRG9tc3RyaW5nU2l6ZUVycm9yOiBcIkRvbXN0cmluZ1NpemVFcnJvclwiLFxuICAgIEhpZXJhcmNoeVJlcXVlc3RFcnJvcjogXCJIaWVyYXJjaHlSZXF1ZXN0RXJyb3JcIixcbiAgICBXcm9uZ0RvY3VtZW50RXJyb3I6IFwiV3JvbmdEb2N1bWVudEVycm9yXCIsXG4gICAgSW52YWxpZENoYXJhY3RlckVycm9yOiBcIkludmFsaWRDaGFyYWN0ZXJFcnJvclwiLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogSnVzdCB0byBtYXRjaCB0aGUgcmVsYXRlZCBzdGF0aWMgY29kZSwgbm90IHBhcnQgb2YgdGhlIHNwZWMuXG4gICAgICovXG4gICAgTm9EYXRhQWxsb3dlZEVycm9yOiBcIk5vRGF0YUFsbG93ZWRFcnJvclwiLFxuICAgIE5vTW9kaWZpY2F0aW9uQWxsb3dlZEVycm9yOiBcIk5vTW9kaWZpY2F0aW9uQWxsb3dlZEVycm9yXCIsXG4gICAgTm90Rm91bmRFcnJvcjogXCJOb3RGb3VuZEVycm9yXCIsXG4gICAgTm90U3VwcG9ydGVkRXJyb3I6IFwiTm90U3VwcG9ydGVkRXJyb3JcIixcbiAgICBJblVzZUF0dHJpYnV0ZUVycm9yOiBcIkluVXNlQXR0cmlidXRlRXJyb3JcIixcbiAgICBJbnZhbGlkU3RhdGVFcnJvcjogXCJJbnZhbGlkU3RhdGVFcnJvclwiLFxuICAgIFN5bnRheEVycm9yOiBcIlN5bnRheEVycm9yXCIsXG4gICAgSW52YWxpZE1vZGlmaWNhdGlvbkVycm9yOiBcIkludmFsaWRNb2RpZmljYXRpb25FcnJvclwiLFxuICAgIE5hbWVzcGFjZUVycm9yOiBcIk5hbWVzcGFjZUVycm9yXCIsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBVc2UgVHlwZUVycm9yIGZvciBpbnZhbGlkIGFyZ3VtZW50cyxcbiAgICAgKiBcIk5vdFN1cHBvcnRlZEVycm9yXCIgRE9NRXhjZXB0aW9uIGZvciB1bnN1cHBvcnRlZCBvcGVyYXRpb25zLFxuICAgICAqIGFuZCBcIk5vdEFsbG93ZWRFcnJvclwiIERPTUV4Y2VwdGlvbiBmb3IgZGVuaWVkIHJlcXVlc3RzIGluc3RlYWQuXG4gICAgICovXG4gICAgSW52YWxpZEFjY2Vzc0Vycm9yOiBcIkludmFsaWRBY2Nlc3NFcnJvclwiLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogSnVzdCB0byBtYXRjaCB0aGUgcmVsYXRlZCBzdGF0aWMgY29kZSwgbm90IHBhcnQgb2YgdGhlIHNwZWMuXG4gICAgICovXG4gICAgVmFsaWRhdGlvbkVycm9yOiBcIlZhbGlkYXRpb25FcnJvclwiLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogVXNlIFR5cGVFcnJvciBpbnN0ZWFkLlxuICAgICAqL1xuICAgIFR5cGVNaXNtYXRjaEVycm9yOiBcIlR5cGVNaXNtYXRjaEVycm9yXCIsXG4gICAgU2VjdXJpdHlFcnJvcjogXCJTZWN1cml0eUVycm9yXCIsXG4gICAgTmV0d29ya0Vycm9yOiBcIk5ldHdvcmtFcnJvclwiLFxuICAgIEFib3J0RXJyb3I6IFwiQWJvcnRFcnJvclwiLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogSnVzdCB0byBtYXRjaCB0aGUgcmVsYXRlZCBzdGF0aWMgY29kZSwgbm90IHBhcnQgb2YgdGhlIHNwZWMuXG4gICAgICovXG4gICAgVVJMTWlzbWF0Y2hFcnJvcjogXCJVUkxNaXNtYXRjaEVycm9yXCIsXG4gICAgUXVvdGFFeGNlZWRlZEVycm9yOiBcIlF1b3RhRXhjZWVkZWRFcnJvclwiLFxuICAgIFRpbWVvdXRFcnJvcjogXCJUaW1lb3V0RXJyb3JcIixcbiAgICBJbnZhbGlkTm9kZVR5cGVFcnJvcjogXCJJbnZhbGlkTm9kZVR5cGVFcnJvclwiLFxuICAgIERhdGFDbG9uZUVycm9yOiBcIkRhdGFDbG9uZUVycm9yXCIsXG4gICAgRW5jb2RpbmdFcnJvcjogXCJFbmNvZGluZ0Vycm9yXCIsXG4gICAgTm90UmVhZGFibGVFcnJvcjogXCJOb3RSZWFkYWJsZUVycm9yXCIsXG4gICAgVW5rbm93bkVycm9yOiBcIlVua25vd25FcnJvclwiLFxuICAgIENvbnN0cmFpbnRFcnJvcjogXCJDb25zdHJhaW50RXJyb3JcIixcbiAgICBEYXRhRXJyb3I6IFwiRGF0YUVycm9yXCIsXG4gICAgVHJhbnNhY3Rpb25JbmFjdGl2ZUVycm9yOiBcIlRyYW5zYWN0aW9uSW5hY3RpdmVFcnJvclwiLFxuICAgIFJlYWRPbmx5RXJyb3I6IFwiUmVhZE9ubHlFcnJvclwiLFxuICAgIFZlcnNpb25FcnJvcjogXCJWZXJzaW9uRXJyb3JcIixcbiAgICBPcGVyYXRpb25FcnJvcjogXCJPcGVyYXRpb25FcnJvclwiLFxuICAgIE5vdEFsbG93ZWRFcnJvcjogXCJOb3RBbGxvd2VkRXJyb3JcIixcbiAgICBPcHRPdXRFcnJvcjogXCJPcHRPdXRFcnJvclwiXG4gIH0pLCBpID0gT2JqZWN0LmtleXMobik7XG4gIGZ1bmN0aW9uIG8odikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PSBcIm51bWJlclwiICYmIHYgPj0gMSAmJiB2IDw9IDI1O1xuICB9XG4gIGZ1bmN0aW9uIGEodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PSBcInN0cmluZ1wiICYmIHYuc3Vic3RyaW5nKHYubGVuZ3RoIC0gbi5FcnJvci5sZW5ndGgpID09PSBuLkVycm9yO1xuICB9XG4gIGZ1bmN0aW9uIGgodiwgTykge1xuICAgIG8odikgPyAodGhpcy5uYW1lID0gaVt2XSwgdGhpcy5tZXNzYWdlID0gTyB8fCBcIlwiKSA6ICh0aGlzLm1lc3NhZ2UgPSB2LCB0aGlzLm5hbWUgPSBhKE8pID8gTyA6IG4uRXJyb3IpLCBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBoKTtcbiAgfVxuICBlKGgsICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaC5wcm90b3R5cGUsIHtcbiAgICBjb2RlOiB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gaS5pbmRleE9mKHRoaXMubmFtZSk7XG4gICAgICAgIHJldHVybiBvKHYpID8gdiA6IDA7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgcCA9IHtcbiAgICBJTkRFWF9TSVpFX0VSUjogMSxcbiAgICBET01TVFJJTkdfU0laRV9FUlI6IDIsXG4gICAgSElFUkFSQ0hZX1JFUVVFU1RfRVJSOiAzLFxuICAgIFdST05HX0RPQ1VNRU5UX0VSUjogNCxcbiAgICBJTlZBTElEX0NIQVJBQ1RFUl9FUlI6IDUsXG4gICAgTk9fREFUQV9BTExPV0VEX0VSUjogNixcbiAgICBOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlI6IDcsXG4gICAgTk9UX0ZPVU5EX0VSUjogOCxcbiAgICBOT1RfU1VQUE9SVEVEX0VSUjogOSxcbiAgICBJTlVTRV9BVFRSSUJVVEVfRVJSOiAxMCxcbiAgICBJTlZBTElEX1NUQVRFX0VSUjogMTEsXG4gICAgU1lOVEFYX0VSUjogMTIsXG4gICAgSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSOiAxMyxcbiAgICBOQU1FU1BBQ0VfRVJSOiAxNCxcbiAgICBJTlZBTElEX0FDQ0VTU19FUlI6IDE1LFxuICAgIFZBTElEQVRJT05fRVJSOiAxNixcbiAgICBUWVBFX01JU01BVENIX0VSUjogMTcsXG4gICAgU0VDVVJJVFlfRVJSOiAxOCxcbiAgICBORVRXT1JLX0VSUjogMTksXG4gICAgQUJPUlRfRVJSOiAyMCxcbiAgICBVUkxfTUlTTUFUQ0hfRVJSOiAyMSxcbiAgICBRVU9UQV9FWENFRURFRF9FUlI6IDIyLFxuICAgIFRJTUVPVVRfRVJSOiAyMyxcbiAgICBJTlZBTElEX05PREVfVFlQRV9FUlI6IDI0LFxuICAgIERBVEFfQ0xPTkVfRVJSOiAyNVxuICB9LCBmID0gT2JqZWN0LmVudHJpZXMocCksIG0gPSAwOyBtIDwgZi5sZW5ndGg7IG0rKykge1xuICAgIHZhciBFID0gZlttXVswXTtcbiAgICBoW0VdID0gZlttXVsxXTtcbiAgfVxuICBmdW5jdGlvbiBsKHYsIE8pIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSB2LCB0aGlzLmxvY2F0b3IgPSBPLCBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBsKTtcbiAgfVxuICByZXR1cm4gZShsKSwgZHQuRE9NRXhjZXB0aW9uID0gaCwgZHQuRE9NRXhjZXB0aW9uTmFtZSA9IG4sIGR0LkV4Y2VwdGlvbkNvZGUgPSBwLCBkdC5QYXJzZUVycm9yID0gbCwgZHQ7XG59XG52YXIgcmUgPSB7fSwgVSA9IHt9LCBucjtcbmZ1bmN0aW9uIEZyKCkge1xuICBpZiAobnIpIHJldHVybiBVO1xuICBuciA9IDE7XG4gIGZ1bmN0aW9uIHQodWUpIHtcbiAgICB0cnkge1xuICAgICAgdHlwZW9mIHVlICE9IFwiZnVuY3Rpb25cIiAmJiAodWUgPSBSZWdFeHApO1xuICAgICAgdmFyIGhlID0gbmV3IHVlKFwi8J2MhlwiLCBcInVcIikuZXhlYyhcIvCdjIZcIik7XG4gICAgICByZXR1cm4gISFoZSAmJiBoZVswXS5sZW5ndGggPT09IDI7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICB2YXIgZSA9IHQoKTtcbiAgZnVuY3Rpb24gbih1ZSkge1xuICAgIGlmICh1ZS5zb3VyY2VbMF0gIT09IFwiW1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKHVlICsgXCIgY2FuIG5vdCBiZSB1c2VkIHdpdGggY2hhcnNcIik7XG4gICAgcmV0dXJuIHVlLnNvdXJjZS5zbGljZSgxLCB1ZS5zb3VyY2UubGFzdEluZGV4T2YoXCJdXCIpKTtcbiAgfVxuICBmdW5jdGlvbiBpKHVlLCBoZSkge1xuICAgIGlmICh1ZS5zb3VyY2VbMF0gIT09IFwiW1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiL1wiICsgdWUuc291cmNlICsgXCIvIGNhbiBub3QgYmUgdXNlZCB3aXRoIGNoYXJzX3dpdGhvdXRcIik7XG4gICAgaWYgKCFoZSB8fCB0eXBlb2YgaGUgIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShoZSkgKyBcIiBpcyBub3QgYSB2YWxpZCBzZWFyY2hcIik7XG4gICAgaWYgKHVlLnNvdXJjZS5pbmRleE9mKGhlKSA9PT0gLTEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGhlICsgJ1wiIGlzIG5vdCBpcyAvJyArIHVlLnNvdXJjZSArIFwiL1wiKTtcbiAgICBpZiAoaGUgPT09IFwiLVwiICYmIHVlLnNvdXJjZS5pbmRleE9mKGhlKSAhPT0gMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgaGUgKyAnXCIgaXMgbm90IGF0IHRoZSBmaXJzdCBwb3N0aW9uIG9mIC8nICsgdWUuc291cmNlICsgXCIvXCIpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHVlLnNvdXJjZS5yZXBsYWNlKGhlLCBcIlwiKSwgZSA/IFwidVwiIDogXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gbyh1ZSkge1xuICAgIHZhciBoZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXG4gICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLm1hcChmdW5jdGlvbihrZSkge1xuICAgICAgICB2YXIgcWUgPSB0eXBlb2Yga2UgPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgaWYgKHFlICYmIGhlID09PSB2b2lkIDAgJiYga2UgPT09IFwifFwiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVzZSByZWdnIGluc3RlYWQgb2YgcmVnIHRvIHdyYXAgZXhwcmVzc2lvbnMgd2l0aCBgfGAhXCIpO1xuICAgICAgICByZXR1cm4gcWUgPyBrZSA6IGtlLnNvdXJjZTtcbiAgICAgIH0pLmpvaW4oXCJcIiksXG4gICAgICBlID8gXCJtdVwiIDogXCJtXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGEodWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHBhcmFtZXRlcnMgcHJvdmlkZWRcIik7XG4gICAgcmV0dXJuIG8uYXBwbHkoYSwgW1wiKD86XCJdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLCBbXCIpXCJdKSk7XG4gIH1cbiAgdmFyIGggPSBcIu+/vVwiLCBwID0gL1stXFx4MDlcXHgwQVxceDBEXFx4MjAtXFx4MkNcXHgyRS1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZEXS87XG4gIGUgJiYgKHAgPSBvKFwiW1wiLCBuKHApLCBcIlxcXFx1ezEwMDAwfS1cXFxcdXsxMEZGRkZ9XCIsIFwiXVwiKSk7XG4gIHZhciBmID0gL1tcXHgyMFxceDA5XFx4MERcXHgwQV0vLCBtID0gbihmKSwgRSA9IG8oZiwgXCIrXCIpLCBsID0gbyhmLCBcIipcIiksIHYgPSAvWzpfYS16QS1aXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyRkZcXHUwMzcwLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdLztcbiAgZSAmJiAodiA9IG8oXCJbXCIsIG4odiksIFwiXFxcXHV7MTAwMDB9LVxcXFx1ezEwRkZGRn1cIiwgXCJdXCIpKTtcbiAgdmFyIE8gPSBuKHYpLCBiID0gbyhcIltcIiwgTywgbigvWy0uMC05XFx4QjddLyksIG4oL1tcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDBdLyksIFwiXVwiKSwgQyA9IG8odiwgYiwgXCIqXCIpLCBqID0gbyhiLCBcIitcIiksIFIgPSBvKFwiJlwiLCBDLCBcIjtcIiksIGsgPSBhKC8mI1swLTldKzt8JiN4WzAtOWEtZkEtRl0rOy8pLCAkID0gYShSLCBcInxcIiwgayksIG5lID0gbyhcIiVcIiwgQywgXCI7XCIpLCBsZSA9IGEoXG4gICAgbygnXCInLCBhKC9bXiUmXCJdLywgXCJ8XCIsIG5lLCBcInxcIiwgJCksIFwiKlwiLCAnXCInKSxcbiAgICBcInxcIixcbiAgICBvKFwiJ1wiLCBhKC9bXiUmJ10vLCBcInxcIiwgbmUsIFwifFwiLCAkKSwgXCIqXCIsIFwiJ1wiKVxuICApLCBnID0gYSgnXCInLCBhKC9bXjwmXCJdLywgXCJ8XCIsICQpLCBcIipcIiwgJ1wiJywgXCJ8XCIsIFwiJ1wiLCBhKC9bXjwmJ10vLCBcInxcIiwgJCksIFwiKlwiLCBcIidcIiksIHggPSBpKHYsIFwiOlwiKSwgRiA9IGkoYiwgXCI6XCIpLCBHID0gbyh4LCBGLCBcIipcIiksIEsgPSBvKEcsIGEoXCI6XCIsIEcpLCBcIj9cIiksIGVlID0gbyhcIl5cIiwgSywgXCIkXCIpLCBJZSA9IG8oXCIoXCIsIEssIFwiKVwiKSwgdGUgPSBhKC9cIlteXCJdKlwifCdbXiddKicvKSwgQmUgPSBvKC9ePFxcPy8sIFwiKFwiLCBDLCBcIilcIiwgYShFLCBcIihcIiwgcCwgXCIqPylcIiksIFwiP1wiLCAvXFw/Pi8pLCBkID0gL1tcXHgyMFxceDBEXFx4MEFhLXpBLVowLTktJygpKywuLzo9PzshKiNAJF8lXS8sIE4gPSBhKCdcIicsIGQsICcqXCInLCBcInxcIiwgXCInXCIsIGkoZCwgXCInXCIpLCBcIionXCIpLCB3ID0gXCI8IS0tXCIsIHkgPSBcIi0tPlwiLCBNID0gbyh3LCBhKGkocCwgXCItXCIpLCBcInxcIiwgbyhcIi1cIiwgaShwLCBcIi1cIikpKSwgXCIqXCIsIHkpLCBBID0gXCIjUENEQVRBXCIsIEIgPSBhKFxuICAgIG8oL1xcKC8sIGwsIEEsIGEobCwgL1xcfC8sIGwsIEspLCBcIipcIiwgbCwgL1xcKVxcKi8pLFxuICAgIFwifFwiLFxuICAgIG8oL1xcKC8sIGwsIEEsIGwsIC9cXCkvKVxuICApLCBKID0gL1s/KitdPy8sIF8gPSBvKFxuICAgIC9cXChbXj5dK1xcKS8sXG4gICAgSlxuICAgIC8qcmVnZyhjaG9pY2UsICd8Jywgc2VxKSwgX2NoaWxkcmVuX3F1YW50aXR5Ki9cbiAgKSwgVCA9IGEoXCJFTVBUWVwiLCBcInxcIiwgXCJBTllcIiwgXCJ8XCIsIEIsIFwifFwiLCBfKSwgSSA9IFwiPCFFTEVNRU5UXCIsIEwgPSBvKEksIEUsIGEoSywgXCJ8XCIsIG5lKSwgRSwgYShULCBcInxcIiwgbmUpLCBsLCBcIj5cIiksIFYgPSBvKFwiTk9UQVRJT05cIiwgRSwgL1xcKC8sIGwsIEMsIGEobCwgL1xcfC8sIGwsIEMpLCBcIipcIiwgbCwgL1xcKS8pLCBmZSA9IG8oL1xcKC8sIGwsIGosIGEobCwgL1xcfC8sIGwsIGopLCBcIipcIiwgbCwgL1xcKS8pLCB3ZSA9IGEoViwgXCJ8XCIsIGZlKSwgdmUgPSBhKC9DREFUQXxJRHxJRFJFRnxJRFJFRlN8RU5USVRZfEVOVElUSUVTfE5NVE9LRU58Tk1UT0tFTlMvLCBcInxcIiwgd2UpLCBpZSA9IGEoLyNSRVFVSVJFRHwjSU1QTElFRC8sIFwifFwiLCBhKGEoXCIjRklYRURcIiwgRSksIFwiP1wiLCBnKSksIFAgPSBhKEUsIEMsIEUsIHZlLCBFLCBpZSksICRlID0gXCI8IUFUVExJU1RcIiwgUmUgPSBvKCRlLCBFLCBDLCBQLCBcIipcIiwgbCwgXCI+XCIpLCBwZSA9IFwiYWJvdXQ6bGVnYWN5LWNvbXBhdFwiLCBWZSA9IGEoJ1wiJyArIHBlICsgJ1wiJywgXCJ8XCIsIFwiJ1wiICsgcGUgKyBcIidcIiksIF9lID0gXCJTWVNURU1cIiwgU2UgPSBcIlBVQkxJQ1wiLCBGZSA9IGEoYShfZSwgRSwgdGUpLCBcInxcIiwgYShTZSwgRSwgTiwgRSwgdGUpKSwgSGUgPSBvKFxuICAgIFwiXlwiLFxuICAgIGEoXG4gICAgICBhKF9lLCBFLCBcIig/PFN5c3RlbUxpdGVyYWxPbmx5PlwiLCB0ZSwgXCIpXCIpLFxuICAgICAgXCJ8XCIsXG4gICAgICBhKFNlLCBFLCBcIig/PFB1YmlkTGl0ZXJhbD5cIiwgTiwgXCIpXCIsIEUsIFwiKD88U3lzdGVtTGl0ZXJhbD5cIiwgdGUsIFwiKVwiKVxuICAgIClcbiAgKSwgSmUgPSBhKEUsIFwiTkRBVEFcIiwgRSwgQyksIENlID0gYShsZSwgXCJ8XCIsIGEoRmUsIEplLCBcIj9cIikpLCBRID0gXCI8IUVOVElUWVwiLCBHZSA9IG8oUSwgRSwgQywgRSwgQ2UsIGwsIFwiPlwiKSwgb2UgPSBhKGxlLCBcInxcIiwgRmUpLCBYZSA9IG8oUSwgRSwgXCIlXCIsIEUsIEMsIEUsIG9lLCBsLCBcIj5cIiksIHZ0ID0gYShHZSwgXCJ8XCIsIFhlKSwgWWUgPSBvKFNlLCBFLCBOKSwgV2UgPSBvKFwiPCFOT1RBVElPTlwiLCBFLCBDLCBFLCBhKEZlLCBcInxcIiwgWWUpLCBsLCBcIj5cIiksIHEgPSBvKGwsIFwiPVwiLCBsKSwgWiA9IC8xWy5dXFxkKy8sIEFlID0gbyhFLCBcInZlcnNpb25cIiwgcSwgYShcIidcIiwgWiwgXCInXCIsIFwifFwiLCAnXCInLCBaLCAnXCInKSksIE5lID0gL1tBLVphLXpdWy1BLVphLXowLTkuX10qLywgS2UgPSBhKEUsIFwiZW5jb2RpbmdcIiwgcSwgYSgnXCInLCBOZSwgJ1wiJywgXCJ8XCIsIFwiJ1wiLCBOZSwgXCInXCIpKSwgc3QgPSBhKEUsIFwic3RhbmRhbG9uZVwiLCBxLCBhKFwiJ1wiLCBhKFwieWVzXCIsIFwifFwiLCBcIm5vXCIpLCBcIidcIiwgXCJ8XCIsICdcIicsIGEoXCJ5ZXNcIiwgXCJ8XCIsIFwibm9cIiksICdcIicpKSwgY3QgPSBvKC9ePFxcP3htbC8sIEFlLCBLZSwgXCI/XCIsIHN0LCBcIj9cIiwgbCwgL1xcPz4vKSwgbHQgPSBcIjwhRE9DVFlQRVwiLCBBdCA9IFwiPCFbQ0RBVEFbXCIsIE50ID0gXCJdXT5cIiwgZnQgPSAvPCFcXFtDREFUQVxcWy8sIFFlID0gL1xcXVxcXT4vLCBwdCA9IG8ocCwgXCIqP1wiLCBRZSksIE90ID0gbyhmdCwgcHQpO1xuICByZXR1cm4gVS5jaGFycyA9IG4sIFUuY2hhcnNfd2l0aG91dCA9IGksIFUuZGV0ZWN0VW5pY29kZVN1cHBvcnQgPSB0LCBVLnJlZyA9IG8sIFUucmVnZyA9IGEsIFUuQUJPVVRfTEVHQUNZX0NPTVBBVCA9IHBlLCBVLkFCT1VUX0xFR0FDWV9DT01QQVRfU3lzdGVtTGl0ZXJhbCA9IFZlLCBVLkF0dGxpc3REZWNsID0gUmUsIFUuQ0RBVEFfU1RBUlQgPSBBdCwgVS5DREFUQV9FTkQgPSBOdCwgVS5DRFNlY3QgPSBPdCwgVS5DaGFyID0gcCwgVS5Db21tZW50ID0gTSwgVS5DT01NRU5UX1NUQVJUID0gdywgVS5DT01NRU5UX0VORCA9IHksIFUuRE9DVFlQRV9ERUNMX1NUQVJUID0gbHQsIFUuZWxlbWVudGRlY2wgPSBMLCBVLkVudGl0eURlY2wgPSB2dCwgVS5FbnRpdHlWYWx1ZSA9IGxlLCBVLkV4dGVybmFsSUQgPSBGZSwgVS5FeHRlcm5hbElEX21hdGNoID0gSGUsIFUuTmFtZSA9IEMsIFUuTm90YXRpb25EZWNsID0gV2UsIFUuUmVmZXJlbmNlID0gJCwgVS5QRVJlZmVyZW5jZSA9IG5lLCBVLlBJID0gQmUsIFUuUFVCTElDID0gU2UsIFUuUHViaWRMaXRlcmFsID0gTiwgVS5RTmFtZSA9IEssIFUuUU5hbWVfZXhhY3QgPSBlZSwgVS5RTmFtZV9ncm91cCA9IEllLCBVLlMgPSBFLCBVLlNDaGFyX3MgPSBtLCBVLlNfT1BUID0gbCwgVS5TWVNURU0gPSBfZSwgVS5TeXN0ZW1MaXRlcmFsID0gdGUsIFUuVU5JQ09ERV9SRVBMQUNFTUVOVF9DSEFSQUNURVIgPSBoLCBVLlVOSUNPREVfU1VQUE9SVCA9IGUsIFUuWE1MRGVjbCA9IGN0LCBVO1xufVxudmFyIHVyO1xuZnVuY3Rpb24ga3IoKSB7XG4gIGlmICh1cikgcmV0dXJuIHJlO1xuICB1ciA9IDE7XG4gIHZhciB0ID0gRHQoKSwgZSA9IHQuZmluZCwgbiA9IHQuaGFzRGVmYXVsdEhUTUxOYW1lc3BhY2UsIGkgPSB0Lmhhc093biwgbyA9IHQuaXNIVE1MTWltZVR5cGUsIGEgPSB0LmlzSFRNTFJhd1RleHRFbGVtZW50LCBoID0gdC5pc0hUTUxWb2lkRWxlbWVudCwgcCA9IHQuTUlNRV9UWVBFLCBmID0gdC5OQU1FU1BBQ0UsIG0gPSBTeW1ib2woKSwgRSA9IF90KCksIGwgPSBFLkRPTUV4Y2VwdGlvbiwgdiA9IEUuRE9NRXhjZXB0aW9uTmFtZSwgTyA9IEZyKCk7XG4gIGZ1bmN0aW9uIGIocikge1xuICAgIGlmIChyICE9PSBtKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgY29uc3RydWN0b3JcIik7XG4gIH1cbiAgZnVuY3Rpb24gQyhyKSB7XG4gICAgcmV0dXJuIHIgIT09IFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gaihyKSB7XG4gICAgcmV0dXJuIHIgPyByLnNwbGl0KC9bXFx0XFxuXFxmXFxyIF0rLykuZmlsdGVyKEMpIDogW107XG4gIH1cbiAgZnVuY3Rpb24gUihyLCB1KSB7XG4gICAgcmV0dXJuIGkociwgdSkgfHwgKHJbdV0gPSAhMCksIHI7XG4gIH1cbiAgZnVuY3Rpb24gayhyKSB7XG4gICAgaWYgKCFyKSByZXR1cm4gW107XG4gICAgdmFyIHUgPSBqKHIpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh1LnJlZHVjZShSLCB7fSkpO1xuICB9XG4gIGZ1bmN0aW9uICQocikge1xuICAgIHJldHVybiBmdW5jdGlvbih1KSB7XG4gICAgICByZXR1cm4gciAmJiByLmluZGV4T2YodSkgIT09IC0xO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbmUocikge1xuICAgIGlmICghTy5RTmFtZV9leGFjdC50ZXN0KHIpKVxuICAgICAgdGhyb3cgbmV3IGwobC5JTlZBTElEX0NIQVJBQ1RFUl9FUlIsICdpbnZhbGlkIGNoYXJhY3RlciBpbiBxdWFsaWZpZWQgbmFtZSBcIicgKyByICsgJ1wiJyk7XG4gIH1cbiAgZnVuY3Rpb24gbGUociwgdSkge1xuICAgIG5lKHUpLCByID0gciB8fCBudWxsO1xuICAgIHZhciBzID0gbnVsbCwgYyA9IHU7XG4gICAgaWYgKHUuaW5kZXhPZihcIjpcIikgPj0gMCkge1xuICAgICAgdmFyIEQgPSB1LnNwbGl0KFwiOlwiKTtcbiAgICAgIHMgPSBEWzBdLCBjID0gRFsxXTtcbiAgICB9XG4gICAgaWYgKHMgIT09IG51bGwgJiYgciA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBsKGwuTkFNRVNQQUNFX0VSUiwgXCJwcmVmaXggaXMgbm9uLW51bGwgYW5kIG5hbWVzcGFjZSBpcyBudWxsXCIpO1xuICAgIGlmIChzID09PSBcInhtbFwiICYmIHIgIT09IHQuTkFNRVNQQUNFLlhNTClcbiAgICAgIHRocm93IG5ldyBsKGwuTkFNRVNQQUNFX0VSUiwgJ3ByZWZpeCBpcyBcInhtbFwiIGFuZCBuYW1lc3BhY2UgaXMgbm90IHRoZSBYTUwgbmFtZXNwYWNlJyk7XG4gICAgaWYgKChzID09PSBcInhtbG5zXCIgfHwgdSA9PT0gXCJ4bWxuc1wiKSAmJiByICE9PSB0Lk5BTUVTUEFDRS5YTUxOUylcbiAgICAgIHRocm93IG5ldyBsKFxuICAgICAgICBsLk5BTUVTUEFDRV9FUlIsXG4gICAgICAgICdlaXRoZXIgcXVhbGlmaWVkTmFtZSBvciBwcmVmaXggaXMgXCJ4bWxuc1wiIGFuZCBuYW1lc3BhY2UgaXMgbm90IHRoZSBYTUxOUyBuYW1lc3BhY2UnXG4gICAgICApO1xuICAgIGlmIChyID09PSB0Lk5BTUVTUEFDRS5YTUxOUyAmJiBzICE9PSBcInhtbG5zXCIgJiYgdSAhPT0gXCJ4bWxuc1wiKVxuICAgICAgdGhyb3cgbmV3IGwoXG4gICAgICAgIGwuTkFNRVNQQUNFX0VSUixcbiAgICAgICAgJ25hbWVzcGFjZSBpcyB0aGUgWE1MTlMgbmFtZXNwYWNlIGFuZCBuZWl0aGVyIHF1YWxpZmllZE5hbWUgbm9yIHByZWZpeCBpcyBcInhtbG5zXCInXG4gICAgICApO1xuICAgIHJldHVybiBbciwgcywgY107XG4gIH1cbiAgZnVuY3Rpb24gZyhyLCB1KSB7XG4gICAgZm9yICh2YXIgcyBpbiByKVxuICAgICAgaShyLCBzKSAmJiAodVtzXSA9IHJbc10pO1xuICB9XG4gIGZ1bmN0aW9uIHgociwgdSkge1xuICAgIHZhciBzID0gci5wcm90b3R5cGU7XG4gICAgaWYgKCEocyBpbnN0YW5jZW9mIHUpKSB7XG4gICAgICBsZXQgYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIGMucHJvdG90eXBlID0gdS5wcm90b3R5cGUsIGMgPSBuZXcgYygpLCBnKHMsIGMpLCByLnByb3RvdHlwZSA9IHMgPSBjO1xuICAgIH1cbiAgICBzLmNvbnN0cnVjdG9yICE9IHIgJiYgKHR5cGVvZiByICE9IFwiZnVuY3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFwidW5rbm93biBDbGFzczpcIiArIHIpLCBzLmNvbnN0cnVjdG9yID0gcik7XG4gIH1cbiAgdmFyIEYgPSB7fSwgRyA9IEYuRUxFTUVOVF9OT0RFID0gMSwgSyA9IEYuQVRUUklCVVRFX05PREUgPSAyLCBlZSA9IEYuVEVYVF9OT0RFID0gMywgSWUgPSBGLkNEQVRBX1NFQ1RJT05fTk9ERSA9IDQsIHRlID0gRi5FTlRJVFlfUkVGRVJFTkNFX05PREUgPSA1LCBCZSA9IEYuRU5USVRZX05PREUgPSA2LCBkID0gRi5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREUgPSA3LCBOID0gRi5DT01NRU5UX05PREUgPSA4LCB3ID0gRi5ET0NVTUVOVF9OT0RFID0gOSwgeSA9IEYuRE9DVU1FTlRfVFlQRV9OT0RFID0gMTAsIE0gPSBGLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMSwgQSA9IEYuTk9UQVRJT05fTk9ERSA9IDEyLCBCID0gdC5mcmVlemUoe1xuICAgIERPQ1VNRU5UX1BPU0lUSU9OX0RJU0NPTk5FQ1RFRDogMSxcbiAgICBET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkc6IDIsXG4gICAgRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HOiA0LFxuICAgIERPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TOiA4LFxuICAgIERPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWTogMTYsXG4gICAgRE9DVU1FTlRfUE9TSVRJT05fSU1QTEVNRU5UQVRJT05fU1BFQ0lGSUM6IDMyXG4gIH0pO1xuICBmdW5jdGlvbiBKKHIsIHUpIHtcbiAgICBpZiAodS5sZW5ndGggPCByLmxlbmd0aCkgcmV0dXJuIEoodSwgcik7XG4gICAgdmFyIHMgPSBudWxsO1xuICAgIGZvciAodmFyIGMgaW4gcikge1xuICAgICAgaWYgKHJbY10gIT09IHVbY10pIHJldHVybiBzO1xuICAgICAgcyA9IHJbY107XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG4gIGZ1bmN0aW9uIF8ocikge1xuICAgIHJldHVybiByLmd1aWQgfHwgKHIuZ3VpZCA9IE1hdGgucmFuZG9tKCkpLCByLmd1aWQ7XG4gIH1cbiAgZnVuY3Rpb24gVCgpIHtcbiAgfVxuICBULnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBsaXN0LiBUaGUgcmFuZ2Ugb2YgdmFsaWQgY2hpbGQgbm9kZSBpbmRpY2VzIGlzIDAgdG8gbGVuZ3RoLTFcbiAgICAgKiBpbmNsdXNpdmUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aDogMCxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtIGF0IGBpbmRleGAuIElmIGluZGV4IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIG5vZGVzIGluXG4gICAgICogdGhlIGxpc3QsIHRoaXMgcmV0dXJucyBudWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogVW5zaWduZWQgbG9uZyBJbmRleCBpbnRvIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAgICAgKiBUaGUgbm9kZSBhdCBwb3NpdGlvbiBgaW5kZXhgIGluIHRoZSBOb2RlTGlzdCxcbiAgICAgKiBvciBudWxsIGlmIHRoYXQgaXMgbm90IGEgdmFsaWQgaW5kZXguXG4gICAgICovXG4gICAgaXRlbTogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHIgPj0gMCAmJiByIDwgdGhpcy5sZW5ndGggPyB0aGlzW3JdIDogbnVsbDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE5vZGVMaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHt1bmtub3dufSBub2RlRmlsdGVyXG4gICAgICogX19BIGZpbHRlciBmdW5jdGlvbj8gTm90IGltcGxlbWVudGVkIGFjY29yZGluZyB0byB0aGUgc3BlYz9fXy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBOb2RlTGlzdC5cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24ocikge1xuICAgICAgZm9yICh2YXIgdSA9IFtdLCBzID0gMDsgcyA8IHRoaXMubGVuZ3RoOyBzKyspXG4gICAgICAgIHFlKHRoaXNbc10sIHUsIHIpO1xuICAgICAgcmV0dXJuIHUuam9pbihcIlwiKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgdGhlIE5vZGVMaXN0IGJhc2VkIG9uIGEgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihOb2RlKTogYm9vbGVhbn0gcHJlZGljYXRlXG4gICAgICogLSBBIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBmaWx0ZXIgdGhlIE5vZGVMaXN0LlxuICAgICAqIEByZXR1cm5zIHtOb2RlW119XG4gICAgICogQW4gYXJyYXkgb2Ygbm9kZXMgdGhhdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwodGhpcywgcik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIG5vZGUgY2FuIGJlIGZvdW5kIGluIHRoZSBOb2RlTGlzdCwgb3IgLTEgaWYgaXQgaXNcbiAgICAgKiBub3QgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gaXRlbVxuICAgICAqIC0gVGhlIE5vZGUgaXRlbSB0byBsb2NhdGUgaW4gdGhlIE5vZGVMaXN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogVGhlIGZpcnN0IGluZGV4IG9mIHRoZSBub2RlIGluIHRoZSBOb2RlTGlzdDsgLTEgaWYgbm90IGZvdW5kLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5kZXhPZjogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgcik7XG4gICAgfVxuICB9LCBULnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSB0aGlzLCB1ID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1IDwgci5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IHJbdSsrXSxcbiAgICAgICAgICBkb25lOiAhMVxuICAgICAgICB9IDoge1xuICAgICAgICAgIGRvbmU6ICEwXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmV0dXJuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiAhMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9uIEkociwgdSkge1xuICAgIHRoaXMuX25vZGUgPSByLCB0aGlzLl9yZWZyZXNoID0gdSwgTCh0aGlzKTtcbiAgfVxuICBmdW5jdGlvbiBMKHIpIHtcbiAgICB2YXIgdSA9IHIuX25vZGUuX2luYyB8fCByLl9ub2RlLm93bmVyRG9jdW1lbnQuX2luYztcbiAgICBpZiAoci5faW5jICE9PSB1KSB7XG4gICAgICB2YXIgcyA9IHIuX3JlZnJlc2goci5fbm9kZSk7XG4gICAgICBpZiAoWHQociwgXCJsZW5ndGhcIiwgcy5sZW5ndGgpLCAhci4kJGxlbmd0aCB8fCBzLmxlbmd0aCA8IHIuJCRsZW5ndGgpXG4gICAgICAgIGZvciAodmFyIGMgPSBzLmxlbmd0aDsgYyBpbiByOyBjKyspXG4gICAgICAgICAgaShyLCBjKSAmJiBkZWxldGUgcltjXTtcbiAgICAgIGcocywgciksIHIuX2luYyA9IHU7XG4gICAgfVxuICB9XG4gIEkucHJvdG90eXBlLml0ZW0gPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIEwodGhpcyksIHRoaXNbcl0gfHwgbnVsbDtcbiAgfSwgeChJLCBUKTtcbiAgZnVuY3Rpb24gVigpIHtcbiAgfVxuICBmdW5jdGlvbiBmZShyLCB1KSB7XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCByLmxlbmd0aDsgKSB7XG4gICAgICBpZiAocltzXSA9PT0gdSlcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICBzKys7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHdlKHIsIHUsIHMsIGMpIHtcbiAgICBpZiAoYyA/IHVbZmUodSwgYyldID0gcyA6ICh1W3UubGVuZ3RoXSA9IHMsIHUubGVuZ3RoKyspLCByKSB7XG4gICAgICBzLm93bmVyRWxlbWVudCA9IHI7XG4gICAgICB2YXIgRCA9IHIub3duZXJEb2N1bWVudDtcbiAgICAgIEQgJiYgKGMgJiYgX2UoRCwgciwgYyksIFZlKEQsIHIsIHMpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdmUociwgdSwgcykge1xuICAgIHZhciBjID0gZmUodSwgcyk7XG4gICAgaWYgKGMgPj0gMCkge1xuICAgICAgZm9yICh2YXIgRCA9IHUubGVuZ3RoIC0gMTsgYyA8PSBEOyApXG4gICAgICAgIHVbY10gPSB1WysrY107XG4gICAgICBpZiAodS5sZW5ndGggPSBELCByKSB7XG4gICAgICAgIHZhciBTID0gci5vd25lckRvY3VtZW50O1xuICAgICAgICBTICYmIF9lKFMsIHIsIHMpLCBzLm93bmVyRWxlbWVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFYucHJvdG90eXBlID0ge1xuICAgIGxlbmd0aDogMCxcbiAgICBpdGVtOiBULnByb3RvdHlwZS5pdGVtLFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBhdHRyaWJ1dGUgYnkgbmFtZS4gTm90ZTogTmFtZSBpcyBpbiBsb3dlciBjYXNlIGluIGNhc2Ugb2YgSFRNTCBuYW1lc3BhY2UgYW5kXG4gICAgICogZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAgICogVGhlIGxvY2FsIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgKiBAcmV0dXJucyB7QXR0ciB8IG51bGx9XG4gICAgICogVGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiBsb2NhbCBuYW1lLCBvciBudWxsIGlmIG5vIHN1Y2ggYXR0cmlidXRlIGV4aXN0cy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1lbGVtZW50LWF0dHJpYnV0ZXMtZ2V0LWJ5LW5hbWVcbiAgICAgKi9cbiAgICBnZXROYW1lZEl0ZW06IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHRoaXMuX293bmVyRWxlbWVudCAmJiB0aGlzLl9vd25lckVsZW1lbnQuX2lzSW5IVE1MRG9jdW1lbnRBbmROYW1lc3BhY2UoKSAmJiAociA9IHIudG9Mb3dlckNhc2UoKSk7XG4gICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IHRoaXMubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzW3VdO1xuICAgICAgICBpZiAocy5ub2RlTmFtZSA9PT0gcilcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgdSsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXQgYW4gYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdHRyfSBhdHRyXG4gICAgICogVGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge0F0dHIgfCBudWxsfVxuICAgICAqIFRoZSBvbGQgYXR0cmlidXRlIHdpdGggdGhlIHNhbWUgbG9jYWwgbmFtZSBhbmQgbmFtZXNwYWNlIFVSSSBhcyB0aGUgbmV3IG9uZSwgb3IgbnVsbCBpZiBub1xuICAgICAqIHN1Y2ggYXR0cmlidXRlIGV4aXN0cy5cbiAgICAgKiBAdGhyb3dzIHtET01FeGNlcHRpb259XG4gICAgICogV2l0aCBjb2RlOlxuICAgICAqIC0ge0BsaW5rIElOVVNFX0FUVFJJQlVURV9FUlJ9IC0gSWYgdGhlIGF0dHJpYnV0ZSBpcyBhbHJlYWR5IGFuIGF0dHJpYnV0ZSBvZiBhbm90aGVyXG4gICAgICogZWxlbWVudC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1lbGVtZW50LWF0dHJpYnV0ZXMtc2V0XG4gICAgICovXG4gICAgc2V0TmFtZWRJdGVtOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgdSA9IHIub3duZXJFbGVtZW50O1xuICAgICAgaWYgKHUgJiYgdSAhPT0gdGhpcy5fb3duZXJFbGVtZW50KVxuICAgICAgICB0aHJvdyBuZXcgbChsLklOVVNFX0FUVFJJQlVURV9FUlIpO1xuICAgICAgdmFyIHMgPSB0aGlzLmdldE5hbWVkSXRlbU5TKHIubmFtZXNwYWNlVVJJLCByLmxvY2FsTmFtZSk7XG4gICAgICByZXR1cm4gcyA9PT0gciA/IHIgOiAod2UodGhpcy5fb3duZXJFbGVtZW50LCB0aGlzLCByLCBzKSwgcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXQgYW4gYXR0cmlidXRlLCByZXBsYWNpbmcgYW4gZXhpc3RpbmcgYXR0cmlidXRlIHdpdGggdGhlIHNhbWUgbG9jYWwgbmFtZSBhbmQgbmFtZXNwYWNlXG4gICAgICogVVJJIGlmIG9uZSBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F0dHJ9IGF0dHJcbiAgICAgKiBUaGUgYXR0cmlidXRlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7QXR0ciB8IG51bGx9XG4gICAgICogVGhlIG9sZCBhdHRyaWJ1dGUgd2l0aCB0aGUgc2FtZSBsb2NhbCBuYW1lIGFuZCBuYW1lc3BhY2UgVVJJIGFzIHRoZSBuZXcgb25lLCBvciBudWxsIGlmIG5vXG4gICAgICogc3VjaCBhdHRyaWJ1dGUgZXhpc3RzLlxuICAgICAqIEB0aHJvd3Mge0RPTUV4Y2VwdGlvbn1cbiAgICAgKiBUaHJvd3MgYSBET01FeGNlcHRpb24gd2l0aCB0aGUgbmFtZSBcIkluVXNlQXR0cmlidXRlRXJyb3JcIiBpZiB0aGUgYXR0cmlidXRlIGlzIGFscmVhZHkgYW5cbiAgICAgKiBhdHRyaWJ1dGUgb2YgYW5vdGhlciBlbGVtZW50LlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWVsZW1lbnQtYXR0cmlidXRlcy1zZXRcbiAgICAgKi9cbiAgICBzZXROYW1lZEl0ZW1OUzogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0TmFtZWRJdGVtKHIpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgc3BlY2lmaWVkIGJ5IHRoZSBsb2NhbCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgICAqIFRoZSBsb2NhbCBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJucyB7QXR0cn1cbiAgICAgKiBUaGUgYXR0cmlidXRlIG5vZGUgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAdGhyb3dzIHtET01FeGNlcHRpb259XG4gICAgICogV2l0aCBjb2RlOlxuICAgICAqIC0ge0BsaW5rIERPTUV4Y2VwdGlvbi5OT1RfRk9VTkRfRVJSfSBpZiBubyBhdHRyaWJ1dGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBmb3VuZC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLW5hbWVkbm9kZW1hcC1yZW1vdmVuYW1lZGl0ZW1cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1lbGVtZW50LWF0dHJpYnV0ZXMtcmVtb3ZlLWJ5LW5hbWVcbiAgICAgKi9cbiAgICByZW1vdmVOYW1lZEl0ZW06IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciB1ID0gdGhpcy5nZXROYW1lZEl0ZW0ocik7XG4gICAgICBpZiAoIXUpXG4gICAgICAgIHRocm93IG5ldyBsKGwuTk9UX0ZPVU5EX0VSUiwgcik7XG4gICAgICByZXR1cm4gdmUodGhpcy5fb3duZXJFbGVtZW50LCB0aGlzLCB1KSwgdTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIHNwZWNpZmllZCBieSB0aGUgbmFtZXNwYWNlIGFuZCBsb2NhbCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBuYW1lc3BhY2VVUklcbiAgICAgKiBUaGUgbmFtZXNwYWNlIFVSSSBvZiB0aGUgYXR0cmlidXRlIHRvIGJlIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgICAqIFRoZSBsb2NhbCBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJucyB7QXR0cn1cbiAgICAgKiBUaGUgYXR0cmlidXRlIG5vZGUgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAdGhyb3dzIHtET01FeGNlcHRpb259XG4gICAgICogV2l0aCBjb2RlOlxuICAgICAqIC0ge0BsaW5rIERPTUV4Y2VwdGlvbi5OT1RfRk9VTkRfRVJSfSBpZiBubyBhdHRyaWJ1dGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZXNwYWNlIFVSSSBhbmQgbG9jYWxcbiAgICAgKiBuYW1lIGlzIGZvdW5kLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tbmFtZWRub2RlbWFwLXJlbW92ZW5hbWVkaXRlbW5zXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZWxlbWVudC1hdHRyaWJ1dGVzLXJlbW92ZS1ieS1uYW1lc3BhY2VcbiAgICAgKi9cbiAgICByZW1vdmVOYW1lZEl0ZW1OUzogZnVuY3Rpb24ociwgdSkge1xuICAgICAgdmFyIHMgPSB0aGlzLmdldE5hbWVkSXRlbU5TKHIsIHUpO1xuICAgICAgaWYgKCFzKVxuICAgICAgICB0aHJvdyBuZXcgbChsLk5PVF9GT1VORF9FUlIsIHIgPyByICsgXCIgOiBcIiArIHUgOiB1KTtcbiAgICAgIHJldHVybiB2ZSh0aGlzLl9vd25lckVsZW1lbnQsIHRoaXMsIHMpLCBzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIGF0dHJpYnV0ZSBieSBuYW1lc3BhY2UgYW5kIGxvY2FsIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IG5hbWVzcGFjZVVSSVxuICAgICAqIFRoZSBuYW1lc3BhY2UgVVJJIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgICAqIFRoZSBsb2NhbCBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICogQHJldHVybnMge0F0dHIgfCBudWxsfVxuICAgICAqIFRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZXNwYWNlIFVSSSBhbmQgbG9jYWwgbmFtZSwgb3IgbnVsbCBpZiBubyBzdWNoIGF0dHJpYnV0ZVxuICAgICAqIGV4aXN0cy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1lbGVtZW50LWF0dHJpYnV0ZXMtZ2V0LWJ5LW5hbWVzcGFjZVxuICAgICAqL1xuICAgIGdldE5hbWVkSXRlbU5TOiBmdW5jdGlvbihyLCB1KSB7XG4gICAgICByIHx8IChyID0gbnVsbCk7XG4gICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHRoaXMubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzW3NdO1xuICAgICAgICBpZiAoYy5sb2NhbE5hbWUgPT09IHUgJiYgYy5uYW1lc3BhY2VVUkkgPT09IHIpXG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIHMrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwgVi5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gdGhpcywgdSA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdSA8IHIubGVuZ3RoID8ge1xuICAgICAgICAgIHZhbHVlOiByW3UrK10sXG4gICAgICAgICAgZG9uZTogITFcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiAhMFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJldHVybjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogITBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBmdW5jdGlvbiBpZSgpIHtcbiAgfVxuICBpZS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGUgRE9NIGltcGxlbWVudGF0aW9uIGltcGxlbWVudHMgYSBzcGVjaWZpYyBmZWF0dXJlIGFuZCB2ZXJzaW9uLCBhcyBzcGVjaWZpZWQgaW5cbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUNvcmUvY29yZS5odG1sI0RPTUZlYXR1cmVzIERPTSBGZWF0dXJlc30uXG4gICAgICpcbiAgICAgKiBUaGUgRE9NSW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgpIG1ldGhvZCByZXR1cm5zIGEgQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgYSBnaXZlblxuICAgICAqIGZlYXR1cmUgaXMgc3VwcG9ydGVkLiBUaGUgZGlmZmVyZW50IGltcGxlbWVudGF0aW9ucyBmYWlybHkgZGl2ZXJnZWQgaW4gd2hhdCBraW5kIG9mXG4gICAgICogZmVhdHVyZXMgd2VyZSByZXBvcnRlZC4gVGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHRoZSBzcGVjIHNldHRsZWQgdG8gZm9yY2UgdGhpcyBtZXRob2QgdG9cbiAgICAgKiBhbHdheXMgcmV0dXJuIHRydWUsIHdoZXJlIHRoZSBmdW5jdGlvbmFsaXR5IHdhcyBhY2N1cmF0ZSBhbmQgaW4gdXNlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBJdCBpcyBkZXByZWNhdGVkIGFuZCBtb2Rlcm4gYnJvd3NlcnMgcmV0dXJuIHRydWUgaW4gYWxsIGNhc2VzLlxuICAgICAqIEBmdW5jdGlvbiBET01JbXBsZW1lbnRhdGlvbiNoYXNGZWF0dXJlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmVcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZmVhdHVyZSB0byB0ZXN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmVyc2lvbl1cbiAgICAgKiBUaGlzIGlzIHRoZSB2ZXJzaW9uIG51bWJlciBvZiB0aGUgZmVhdHVyZSB0byB0ZXN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEFsd2F5cyByZXR1cm5zIHRydWUuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRE9NSW1wbGVtZW50YXRpb24vaGFzRmVhdHVyZSBNRE5cbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9SRUMtRE9NLUxldmVsLTEvbGV2ZWwtb25lLWNvcmUuaHRtbCNJRC01Q0VEOTRENyBET00gTGV2ZWwgMSBDb3JlXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlIERPTSBMaXZpbmcgU3RhbmRhcmRcbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL2NvcmUuaHRtbCNJRC01Q0VEOTRENyBET00gTGV2ZWwgMyBDb3JlXG4gICAgICovXG4gICAgaGFzRmVhdHVyZTogZnVuY3Rpb24ociwgdSkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERPTSBEb2N1bWVudCBvYmplY3Qgb2YgdGhlIHNwZWNpZmllZCB0eXBlIHdpdGggaXRzIGRvY3VtZW50IGVsZW1lbnQuIE5vdGUgdGhhdFxuICAgICAqIGJhc2VkIG9uIHRoZSB7QGxpbmsgRG9jdW1lbnRUeXBlfVxuICAgICAqIGdpdmVuIHRvIGNyZWF0ZSB0aGUgZG9jdW1lbnQsIHRoZSBpbXBsZW1lbnRhdGlvbiBtYXkgaW5zdGFudGlhdGUgc3BlY2lhbGl6ZWRcbiAgICAgKiB7QGxpbmsgRG9jdW1lbnR9IG9iamVjdHMgdGhhdCBzdXBwb3J0IGFkZGl0aW9uYWwgZmVhdHVyZXMgdGhhbiB0aGUgXCJDb3JlXCIsIHN1Y2ggYXMgXCJIVE1MXCJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUNvcmUvcmVmZXJlbmNlcy5odG1sI0RPTTJIVE1MIERPTSBMZXZlbCAyIEhUTUx9LlxuICAgICAqIE9uIHRoZSBvdGhlciBoYW5kLCBzZXR0aW5nIHRoZSB7QGxpbmsgRG9jdW1lbnRUeXBlfSBhZnRlciB0aGUgZG9jdW1lbnQgd2FzIGNyZWF0ZWQgbWFrZXNcbiAgICAgKiB0aGlzIHZlcnkgdW5saWtlbHkgdG8gaGFwcGVuLiBBbHRlcm5hdGl2ZWx5LCBzcGVjaWFsaXplZCB7QGxpbmsgRG9jdW1lbnR9IGNyZWF0aW9uIG1ldGhvZHMsXG4gICAgICogc3VjaCBhcyBjcmVhdGVIVE1MRG9jdW1lbnRcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUNvcmUvcmVmZXJlbmNlcy5odG1sI0RPTTJIVE1MIERPTSBMZXZlbCAyIEhUTUx9LFxuICAgICAqIGNhbiBiZSB1c2VkIHRvIG9idGFpbiBzcGVjaWZpYyB0eXBlcyBvZiB7QGxpbmsgRG9jdW1lbnR9IG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBfX0l0IGJlaGF2ZXMgc2xpZ2h0bHkgZGlmZmVyZW50IGZyb20gdGhlIGRlc2NyaXB0aW9uIGluIHRoZSBsaXZpbmcgc3RhbmRhcmRfXzpcbiAgICAgKiAtIFRoZXJlIGlzIG5vIGludGVyZmFjZS9jbGFzcyBgWE1MRG9jdW1lbnRgLCBpdCByZXR1cm5zIGEgYERvY3VtZW50YFxuICAgICAqIGluc3RhbmNlICh3aXRoIGl0J3MgYHR5cGVgIHNldCB0byBgJ3htbCdgKS5cbiAgICAgKiAtIGBlbmNvZGluZ2AsIGBtb2RlYCwgYG9yaWdpbmAsIGB1cmxgIGZpZWxkcyBhcmUgY3VycmVudGx5IG5vdCBkZWNsYXJlZC5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBET01JbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gbmFtZXNwYWNlVVJJXG4gICAgICogVGhlXG4gICAgICoge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL2dsb3NzYXJ5Lmh0bWwjZHQtbmFtZXNwYWNlVVJJIG5hbWVzcGFjZSBVUkl9XG4gICAgICogb2YgdGhlIGRvY3VtZW50IGVsZW1lbnQgdG8gY3JlYXRlIG9yIG51bGwuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBxdWFsaWZpZWROYW1lXG4gICAgICogVGhlXG4gICAgICoge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL2dsb3NzYXJ5Lmh0bWwjZHQtcXVhbGlmaWVkbmFtZSBxdWFsaWZpZWQgbmFtZX1cbiAgICAgKiBvZiB0aGUgZG9jdW1lbnQgZWxlbWVudCB0byBiZSBjcmVhdGVkIG9yIG51bGwuXG4gICAgICogQHBhcmFtIHtEb2N1bWVudFR5cGUgfCBudWxsfSBbZG9jdHlwZT1udWxsXVxuICAgICAqIFRoZSB0eXBlIG9mIGRvY3VtZW50IHRvIGJlIGNyZWF0ZWQgb3IgbnVsbC4gV2hlbiBkb2N0eXBlIGlzIG5vdCBudWxsLCBpdHNcbiAgICAgKiB7QGxpbmsgTm9kZSNvd25lckRvY3VtZW50fSBhdHRyaWJ1dGUgaXMgc2V0IHRvIHRoZSBkb2N1bWVudCBiZWluZyBjcmVhdGVkLiBEZWZhdWx0IGlzXG4gICAgICogYG51bGxgXG4gICAgICogQHJldHVybnMge0RvY3VtZW50fVxuICAgICAqIEEgbmV3IHtAbGluayBEb2N1bWVudH0gb2JqZWN0IHdpdGggaXRzIGRvY3VtZW50IGVsZW1lbnQuIElmIHRoZSBOYW1lc3BhY2VVUkksXG4gICAgICogcXVhbGlmaWVkTmFtZSwgYW5kIGRvY3R5cGUgYXJlIG51bGwsIHRoZSByZXR1cm5lZCB7QGxpbmsgRG9jdW1lbnR9IGlzIGVtcHR5IHdpdGggbm9cbiAgICAgKiBkb2N1bWVudCBlbGVtZW50LlxuICAgICAqIEB0aHJvd3Mge0RPTUV4Y2VwdGlvbn1cbiAgICAgKiBXaXRoIGNvZGU6XG4gICAgICpcbiAgICAgKiAtIGBJTlZBTElEX0NIQVJBQ1RFUl9FUlJgOiBSYWlzZWQgaWYgdGhlIHNwZWNpZmllZCBxdWFsaWZpZWQgbmFtZSBpcyBub3QgYW4gWE1MIG5hbWVcbiAgICAgKiBhY2NvcmRpbmcgdG8ge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL3JlZmVyZW5jZXMuaHRtbCNYTUwgWE1MIDEuMH0uXG4gICAgICogLSBgTkFNRVNQQUNFX0VSUmA6IFJhaXNlZCBpZiB0aGUgcXVhbGlmaWVkTmFtZSBpcyBtYWxmb3JtZWQsIGlmIHRoZSBxdWFsaWZpZWROYW1lIGhhcyBhXG4gICAgICogcHJlZml4IGFuZCB0aGUgbmFtZXNwYWNlVVJJIGlzIG51bGwsIG9yIGlmIHRoZSBxdWFsaWZpZWROYW1lIGlzIG51bGwgYW5kIHRoZSBuYW1lc3BhY2VVUklcbiAgICAgKiBpcyBkaWZmZXJlbnQgZnJvbSBudWxsLCBvciBpZiB0aGUgcXVhbGlmaWVkTmFtZSBoYXMgYSBwcmVmaXggdGhhdCBpcyBcInhtbFwiIGFuZCB0aGVcbiAgICAgKiBuYW1lc3BhY2VVUkkgaXMgZGlmZmVyZW50IGZyb20gXCJ7QGxpbmsgaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlfVwiXG4gICAgICoge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL3JlZmVyZW5jZXMuaHRtbCNOYW1lc3BhY2VzIFhNTCBOYW1lc3BhY2VzfSxcbiAgICAgKiBvciBpZiB0aGUgRE9NIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHN1cHBvcnQgdGhlIFwiWE1MXCIgZmVhdHVyZSBidXQgYSBub24tbnVsbCBuYW1lc3BhY2VcbiAgICAgKiBVUkkgd2FzIHByb3ZpZGVkLCBzaW5jZSBuYW1lc3BhY2VzIHdlcmUgZGVmaW5lZCBieSBYTUwuXG4gICAgICogLSBgV1JPTkdfRE9DVU1FTlRfRVJSYDogUmFpc2VkIGlmIGRvY3R5cGUgaGFzIGFscmVhZHkgYmVlbiB1c2VkIHdpdGggYSBkaWZmZXJlbnQgZG9jdW1lbnRcbiAgICAgKiBvciB3YXMgY3JlYXRlZCBmcm9tIGEgZGlmZmVyZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAqIC0gYE5PVF9TVVBQT1JURURfRVJSYDogTWF5IGJlIHJhaXNlZCBpZiB0aGUgaW1wbGVtZW50YXRpb24gZG9lcyBub3Qgc3VwcG9ydCB0aGUgZmVhdHVyZVxuICAgICAqIFwiWE1MXCIgYW5kIHRoZSBsYW5ndWFnZSBleHBvc2VkIHRocm91Z2ggdGhlIERvY3VtZW50IGRvZXMgbm90IHN1cHBvcnQgWE1MIE5hbWVzcGFjZXMgKHN1Y2hcbiAgICAgKiBhcyB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUNvcmUvcmVmZXJlbmNlcy5odG1sI0hUTUw0MCBIVE1MIDQuMDF9KS5cbiAgICAgKiBAc2luY2UgRE9NIExldmVsIDIuXG4gICAgICogQHNlZSB7QGxpbmsgI2NyZWF0ZUhUTUxEb2N1bWVudH1cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ET01JbXBsZW1lbnRhdGlvbi9jcmVhdGVEb2N1bWVudCBNRE5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWNyZWF0ZWRvY3VtZW50IERPTSBMaXZpbmcgU3RhbmRhcmRcbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL2NvcmUuaHRtbCNMZXZlbC0yLUNvcmUtRE9NLWNyZWF0ZURvY3VtZW50IERPTVxuICAgICAqICAgICAgTGV2ZWwgMyBDb3JlXG4gICAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItQ29yZS9jb3JlLmh0bWwjTGV2ZWwtMi1Db3JlLURPTS1jcmVhdGVEb2N1bWVudCBET01cbiAgICAgKiAgICAgIExldmVsIDIgQ29yZSAoaW5pdGlhbClcbiAgICAgKi9cbiAgICBjcmVhdGVEb2N1bWVudDogZnVuY3Rpb24ociwgdSwgcykge1xuICAgICAgdmFyIGMgPSBwLlhNTF9BUFBMSUNBVElPTjtcbiAgICAgIHIgPT09IGYuSFRNTCA/IGMgPSBwLlhNTF9YSFRNTF9BUFBMSUNBVElPTiA6IHIgPT09IGYuU1ZHICYmIChjID0gcC5YTUxfU1ZHX0lNQUdFKTtcbiAgICAgIHZhciBEID0gbmV3IHBlKG0sIHsgY29udGVudFR5cGU6IGMgfSk7XG4gICAgICBpZiAoRC5pbXBsZW1lbnRhdGlvbiA9IHRoaXMsIEQuY2hpbGROb2RlcyA9IG5ldyBUKCksIEQuZG9jdHlwZSA9IHMgfHwgbnVsbCwgcyAmJiBELmFwcGVuZENoaWxkKHMpLCB1KSB7XG4gICAgICAgIHZhciBTID0gRC5jcmVhdGVFbGVtZW50TlMociwgdSk7XG4gICAgICAgIEQuYXBwZW5kQ2hpbGQoUyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gRDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZW1wdHkgRG9jdW1lbnRUeXBlIG5vZGUuIEVudGl0eSBkZWNsYXJhdGlvbnMgYW5kIG5vdGF0aW9ucyBhcmUgbm90IG1hZGVcbiAgICAgKiBhdmFpbGFibGUuIEVudGl0eSByZWZlcmVuY2UgZXhwYW5zaW9ucyBhbmQgZGVmYXVsdCBhdHRyaWJ1dGUgYWRkaXRpb25zIGRvIG5vdCBvY2N1ci5cbiAgICAgKlxuICAgICAqICoqVGhpcyBiZWhhdmlvciBpcyBzbGlnaHRseSBkaWZmZXJlbnQgZnJvbSB0aGUgb25lIGluIHRoZSBzcGVjcyoqOlxuICAgICAqIC0gYGVuY29kaW5nYCwgYG1vZGVgLCBgb3JpZ2luYCwgYHVybGAgZmllbGRzIGFyZSBjdXJyZW50bHkgbm90IGRlY2xhcmVkLlxuICAgICAqIC0gYHB1YmxpY0lkYCBhbmQgYHN5c3RlbUlkYCBjb250YWluIHRoZSByYXcgZGF0YSBpbmNsdWRpbmcgYW55IHBvc3NpYmxlIHF1b3RlcyxcbiAgICAgKiAgIHNvIHRoZXkgY2FuIGFsd2F5cyBiZSBzZXJpYWxpemVkIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICogLSBgaW50ZXJuYWxTdWJzZXRgIGNvbnRhaW5zIHRoZSByYXcgc3RyaW5nIGJldHdlZW4gYFtgIGFuZCBgXWAgaWYgcHJlc2VudCxcbiAgICAgKiAgIGJ1dCBpcyBub3QgcGFyc2VkIG9yIHZhbGlkYXRlZCBpbiBhbnkgZm9ybS5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBET01JbXBsZW1lbnRhdGlvbiNjcmVhdGVEb2N1bWVudFR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVhbGlmaWVkTmFtZVxuICAgICAqIFRoZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUNvcmUvZ2xvc3NhcnkuaHRtbCNkdC1xdWFsaWZpZWRuYW1lIHF1YWxpZmllZFxuICAgICAqIG5hbWV9IG9mIHRoZSBkb2N1bWVudCB0eXBlIHRvIGJlIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNJZF1cbiAgICAgKiBUaGUgZXh0ZXJuYWwgc3Vic2V0IHB1YmxpYyBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3lzdGVtSWRdXG4gICAgICogVGhlIGV4dGVybmFsIHN1YnNldCBzeXN0ZW0gaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2ludGVybmFsU3Vic2V0XVxuICAgICAqIHRoZSBpbnRlcm5hbCBzdWJzZXQgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIGl0IGlzIG5vdCBwcmVzZW50XG4gICAgICogQHJldHVybnMge0RvY3VtZW50VHlwZX1cbiAgICAgKiBBIG5ldyB7QGxpbmsgRG9jdW1lbnRUeXBlfSBub2RlIHdpdGgge0BsaW5rIE5vZGUjb3duZXJEb2N1bWVudH0gc2V0IHRvIG51bGwuXG4gICAgICogQHRocm93cyB7RE9NRXhjZXB0aW9ufVxuICAgICAqIFdpdGggY29kZTpcbiAgICAgKlxuICAgICAqIC0gYElOVkFMSURfQ0hBUkFDVEVSX0VSUmA6IFJhaXNlZCBpZiB0aGUgc3BlY2lmaWVkIHF1YWxpZmllZCBuYW1lIGlzIG5vdCBhbiBYTUwgbmFtZVxuICAgICAqIGFjY29yZGluZyB0byB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUNvcmUvcmVmZXJlbmNlcy5odG1sI1hNTCBYTUwgMS4wfS5cbiAgICAgKiAtIGBOQU1FU1BBQ0VfRVJSYDogUmFpc2VkIGlmIHRoZSBxdWFsaWZpZWROYW1lIGlzIG1hbGZvcm1lZC5cbiAgICAgKiAtIGBOT1RfU1VQUE9SVEVEX0VSUmA6IE1heSBiZSByYWlzZWQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHN1cHBvcnQgdGhlIGZlYXR1cmVcbiAgICAgKiBcIlhNTFwiIGFuZCB0aGUgbGFuZ3VhZ2UgZXhwb3NlZCB0aHJvdWdoIHRoZSBEb2N1bWVudCBkb2VzIG5vdCBzdXBwb3J0IFhNTCBOYW1lc3BhY2VzIChzdWNoXG4gICAgICogYXMge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL3JlZmVyZW5jZXMuaHRtbCNIVE1MNDAgSFRNTCA0LjAxfSkuXG4gICAgICogQHNpbmNlIERPTSBMZXZlbCAyLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RPTUltcGxlbWVudGF0aW9uL2NyZWF0ZURvY3VtZW50VHlwZVxuICAgICAqICAgICAgTUROXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1jcmVhdGVkb2N1bWVudHR5cGUgRE9NIExpdmluZ1xuICAgICAqICAgICAgU3RhbmRhcmRcbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL2NvcmUuaHRtbCNMZXZlbC0zLUNvcmUtRE9NLWNyZWF0ZURvY1R5cGUgRE9NXG4gICAgICogICAgICBMZXZlbCAzIENvcmVcbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1Db3JlL2NvcmUuaHRtbCNMZXZlbC0yLUNvcmUtRE9NLWNyZWF0ZURvY1R5cGUgRE9NXG4gICAgICogICAgICBMZXZlbCAyIENvcmVcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS94bWxkb20veG1sZG9tL2Jsb2IvbWFzdGVyL0NIQU5HRUxPRy5tZCMwNTBcbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1Db3JlLyNjb3JlLUlELUNvcmUtRG9jVHlwZS1pbnRlcm5hbFN1YnNldFxuICAgICAqIEBwcmV0dGllcmlnbm9yZVxuICAgICAqL1xuICAgIGNyZWF0ZURvY3VtZW50VHlwZTogZnVuY3Rpb24ociwgdSwgcywgYykge1xuICAgICAgbmUocik7XG4gICAgICB2YXIgRCA9IG5ldyBsdChtKTtcbiAgICAgIHJldHVybiBELm5hbWUgPSByLCBELm5vZGVOYW1lID0gciwgRC5wdWJsaWNJZCA9IHUgfHwgXCJcIiwgRC5zeXN0ZW1JZCA9IHMgfHwgXCJcIiwgRC5pbnRlcm5hbFN1YnNldCA9IGMgfHwgXCJcIiwgRC5jaGlsZE5vZGVzID0gbmV3IFQoKSwgRDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gSFRNTCBkb2N1bWVudCwgdGhhdCBtaWdodCBhbHJlYWR5IGhhdmUgYSBiYXNpYyBET00gc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogX19JdCBiZWhhdmVzIHNsaWdodGx5IGRpZmZlcmVudCBmcm9tIHRoZSBkZXNjcmlwdGlvbiBpbiB0aGUgbGl2aW5nIHN0YW5kYXJkX186XG4gICAgICogLSBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYGZhbHNlYCBubyBpbml0aWFsIG5vZGVzIGFyZSBhZGRlZCAoc3RlcHMgMy03IGluIHRoZSBzcGVjcyBhcmVcbiAgICAgKiBvbWl0dGVkKVxuICAgICAqIC0gYGVuY29kaW5nYCwgYG1vZGVgLCBgb3JpZ2luYCwgYHVybGAgZmllbGRzIGFyZSBjdXJyZW50bHkgbm90IGRlY2xhcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBmYWxzZX0gW3RpdGxlXVxuICAgICAqIEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHRpdGxlIHRvIGdpdmUgdGhlIG5ldyBIVE1MIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtEb2N1bWVudH1cbiAgICAgKiBUaGUgSFRNTCBkb2N1bWVudC5cbiAgICAgKiBAc2luY2UgV0hBVFdHIExpdmluZyBTdGFuZGFyZC5cbiAgICAgKiBAc2VlIHtAbGluayAjY3JlYXRlRG9jdW1lbnR9XG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1jcmVhdGVodG1sZG9jdW1lbnRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jaHRtbC1kb2N1bWVudFxuICAgICAqL1xuICAgIGNyZWF0ZUhUTUxEb2N1bWVudDogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIHUgPSBuZXcgcGUobSwgeyBjb250ZW50VHlwZTogcC5IVE1MIH0pO1xuICAgICAgaWYgKHUuaW1wbGVtZW50YXRpb24gPSB0aGlzLCB1LmNoaWxkTm9kZXMgPSBuZXcgVCgpLCByICE9PSAhMSkge1xuICAgICAgICB1LmRvY3R5cGUgPSB0aGlzLmNyZWF0ZURvY3VtZW50VHlwZShcImh0bWxcIiksIHUuZG9jdHlwZS5vd25lckRvY3VtZW50ID0gdSwgdS5hcHBlbmRDaGlsZCh1LmRvY3R5cGUpO1xuICAgICAgICB2YXIgcyA9IHUuY3JlYXRlRWxlbWVudChcImh0bWxcIik7XG4gICAgICAgIHUuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgIHZhciBjID0gdS5jcmVhdGVFbGVtZW50KFwiaGVhZFwiKTtcbiAgICAgICAgaWYgKHMuYXBwZW5kQ2hpbGQoYyksIHR5cGVvZiByID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YXIgRCA9IHUuY3JlYXRlRWxlbWVudChcInRpdGxlXCIpO1xuICAgICAgICAgIEQuYXBwZW5kQ2hpbGQodS5jcmVhdGVUZXh0Tm9kZShyKSksIGMuYXBwZW5kQ2hpbGQoRCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5hcHBlbmRDaGlsZCh1LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1O1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gUChyKSB7XG4gICAgYihyKTtcbiAgfVxuICBQLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZmlyc3QgY2hpbGQgb2YgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHR5cGUge05vZGUgfCBudWxsfVxuICAgICAqL1xuICAgIGZpcnN0Q2hpbGQ6IG51bGwsXG4gICAgLyoqXG4gICAgICogVGhlIGxhc3QgY2hpbGQgb2YgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHR5cGUge05vZGUgfCBudWxsfVxuICAgICAqL1xuICAgIGxhc3RDaGlsZDogbnVsbCxcbiAgICAvKipcbiAgICAgKiBUaGUgcHJldmlvdXMgc2libGluZyBvZiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Tm9kZSB8IG51bGx9XG4gICAgICovXG4gICAgcHJldmlvdXNTaWJsaW5nOiBudWxsLFxuICAgIC8qKlxuICAgICAqIFRoZSBuZXh0IHNpYmxpbmcgb2YgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHR5cGUge05vZGUgfCBudWxsfVxuICAgICAqL1xuICAgIG5leHRTaWJsaW5nOiBudWxsLFxuICAgIC8qKlxuICAgICAqIFRoZSBwYXJlbnQgbm9kZSBvZiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Tm9kZSB8IG51bGx9XG4gICAgICovXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICAvKipcbiAgICAgKiBUaGUgcGFyZW50IGVsZW1lbnQgb2YgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHR5cGUge0VsZW1lbnQgfCBudWxsfVxuICAgICAqL1xuICAgIGdldCBwYXJlbnRFbGVtZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUubm9kZVR5cGUgPT09IHRoaXMuRUxFTUVOVF9OT0RFID8gdGhpcy5wYXJlbnROb2RlIDogbnVsbDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBjaGlsZCBub2RlcyBvZiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Tm9kZUxpc3R9XG4gICAgICovXG4gICAgY2hpbGROb2RlczogbnVsbCxcbiAgICAvKipcbiAgICAgKiBUaGUgZG9jdW1lbnQgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RG9jdW1lbnQgfCBudWxsfVxuICAgICAqL1xuICAgIG93bmVyRG9jdW1lbnQ6IG51bGwsXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIG5vZGVWYWx1ZTogbnVsbCxcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZXNwYWNlIFVSSSBvZiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH1cbiAgICAgKi9cbiAgICBuYW1lc3BhY2VVUkk6IG51bGwsXG4gICAgLyoqXG4gICAgICogVGhlIHByZWZpeCBvZiB0aGUgbmFtZXNwYWNlIGZvciB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH1cbiAgICAgKi9cbiAgICBwcmVmaXg6IG51bGwsXG4gICAgLyoqXG4gICAgICogVGhlIGxvY2FsIHBhcnQgb2YgdGhlIHF1YWxpZmllZCBuYW1lIG9mIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIGxvY2FsTmFtZTogbnVsbCxcbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZVVSSSBpcyBjdXJyZW50bHkgYWx3YXlzIGBhYm91dDpibGFua2AsXG4gICAgICogc2luY2UgdGhhdCdzIHdoYXQgaGFwcGVucyB3aGVuIHlvdSBjcmVhdGUgYSBkb2N1bWVudCBmcm9tIHNjcmF0Y2guXG4gICAgICpcbiAgICAgKiBAdHlwZSB7J2Fib3V0OmJsYW5rJ31cbiAgICAgKi9cbiAgICBiYXNlVVJJOiBcImFib3V0OmJsYW5rXCIsXG4gICAgLyoqXG4gICAgICogSXMgdHJ1ZSBpZiB0aGlzIG5vZGUgaXMgcGFydCBvZiBhIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzQ29ubmVjdGVkKCkge1xuICAgICAgdmFyIHIgPSB0aGlzLmdldFJvb3ROb2RlKCk7XG4gICAgICByZXR1cm4gciAmJiByLm5vZGVUeXBlID09PSByLkRPQ1VNRU5UX05PREU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBgb3RoZXJgIGlzIGFuIGluY2x1c2l2ZSBkZXNjZW5kYW50IG9mIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZSB8IG51bGwgfCB1bmRlZmluZWR9IG90aGVyXG4gICAgICogVGhlIG5vZGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogVHJ1ZSBpZiBgb3RoZXJgIGlzIGFuIGluY2x1c2l2ZSBkZXNjZW5kYW50IG9mIHRoaXMgbm9kZTsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tbm9kZS1jb250YWluc1xuICAgICAqL1xuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihyKSB7XG4gICAgICBpZiAoIXIpIHJldHVybiAhMTtcbiAgICAgIHZhciB1ID0gcjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IHUpIHJldHVybiAhMDtcbiAgICAgICAgdSA9IHIucGFyZW50Tm9kZTtcbiAgICAgIH0gd2hpbGUgKHUpO1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYgR2V0Um9vdE5vZGVPcHRpb25zXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY29tcG9zZWQ9ZmFsc2VdXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIHRoZSByb290IG5vZGUgb2YgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogKipUaGlzIGJlaGF2aW9yIGlzIHNsaWdodGx5IGRpZmZlcmVudCBmcm9tIHRoZSBpbiB0aGUgc3BlY3MqKjpcbiAgICAgKiAtIGlnbm9yZXMgYG9wdGlvbnMuY29tcG9zZWRgLCBzaW5jZSBgU2hhZG93Um9vdGBzIGFyZSB1bnN1cHBvcnRlZCwgYWx3YXlzIHJldHVybnMgcm9vdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7R2V0Um9vdE5vZGVPcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJucyB7Tm9kZX1cbiAgICAgKiBSb290IG5vZGUuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ub2RlLWdldHJvb3Rub2RlXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtc2hhZG93LWluY2x1ZGluZy1yb290XG4gICAgICovXG4gICAgZ2V0Um9vdE5vZGU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciB1ID0gdGhpcztcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCF1LnBhcmVudE5vZGUpXG4gICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgIHUgPSB1LnBhcmVudE5vZGU7XG4gICAgICB9IHdoaWxlICh1KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIGlzIGVxdWFsIHRvIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gW290aGVyTm9kZV1cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ub2RlLWVxdWFsc1xuICAgICAqL1xuICAgIGlzRXF1YWxOb2RlOiBmdW5jdGlvbihyKSB7XG4gICAgICBpZiAoIXIgfHwgdGhpcy5ub2RlVHlwZSAhPT0gci5ub2RlVHlwZSkgcmV0dXJuICExO1xuICAgICAgc3dpdGNoICh0aGlzLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgdGhpcy5ET0NVTUVOVF9UWVBFX05PREU6XG4gICAgICAgICAgaWYgKHRoaXMubmFtZSAhPT0gci5uYW1lIHx8IHRoaXMucHVibGljSWQgIT09IHIucHVibGljSWQgfHwgdGhpcy5zeXN0ZW1JZCAhPT0gci5zeXN0ZW1JZCkgcmV0dXJuICExO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRoaXMuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgIGlmICh0aGlzLm5hbWVzcGFjZVVSSSAhPT0gci5uYW1lc3BhY2VVUkkgfHwgdGhpcy5wcmVmaXggIT09IHIucHJlZml4IHx8IHRoaXMubG9jYWxOYW1lICE9PSByLmxvY2FsTmFtZSB8fCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoICE9PSByLmF0dHJpYnV0ZXMubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5hdHRyaWJ1dGVzLml0ZW0odSk7XG4gICAgICAgICAgICBpZiAoIXMuaXNFcXVhbE5vZGUoci5nZXRBdHRyaWJ1dGVOb2RlTlMocy5uYW1lc3BhY2VVUkksIHMubG9jYWxOYW1lKSkpXG4gICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdGhpcy5BVFRSSUJVVEVfTk9ERTpcbiAgICAgICAgICBpZiAodGhpcy5uYW1lc3BhY2VVUkkgIT09IHIubmFtZXNwYWNlVVJJIHx8IHRoaXMubG9jYWxOYW1lICE9PSByLmxvY2FsTmFtZSB8fCB0aGlzLnZhbHVlICE9PSByLnZhbHVlKSByZXR1cm4gITE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdGhpcy5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU6XG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0ICE9PSByLnRhcmdldCB8fCB0aGlzLmRhdGEgIT09IHIuZGF0YSlcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0aGlzLlRFWFRfTk9ERTpcbiAgICAgICAgY2FzZSB0aGlzLkNPTU1FTlRfTk9ERTpcbiAgICAgICAgICBpZiAodGhpcy5kYXRhICE9PSByLmRhdGEpIHJldHVybiAhMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNoaWxkTm9kZXMubGVuZ3RoICE9PSByLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7IHUrKylcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkTm9kZXNbdV0uaXNFcXVhbE5vZGUoci5jaGlsZE5vZGVzW3VdKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIG5vZGUgaXMgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBbb3RoZXJOb2RlXVxuICAgICAqL1xuICAgIGlzU2FtZU5vZGU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiB0aGlzID09PSByO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIG5vZGUgYmVmb3JlIGEgcmVmZXJlbmNlIG5vZGUgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5ld0NoaWxkXG4gICAgICogVGhlIG5ldyBjaGlsZCBub2RlIHRvIGJlIGluc2VydGVkLlxuICAgICAqIEBwYXJhbSB7Tm9kZSB8IG51bGx9IHJlZkNoaWxkXG4gICAgICogVGhlIHJlZmVyZW5jZSBub2RlIGJlZm9yZSB3aGljaCBuZXdDaGlsZCB3aWxsIGJlIGluc2VydGVkLlxuICAgICAqIEByZXR1cm5zIHtOb2RlfVxuICAgICAqIFRoZSBuZXcgY2hpbGQgbm9kZSBzdWNjZXNzZnVsbHkgaW5zZXJ0ZWQuXG4gICAgICogQHRocm93cyB7RE9NRXhjZXB0aW9ufVxuICAgICAqIFRocm93cyBhIERPTUV4Y2VwdGlvbiBpZiBpbnNlcnRpbmcgdGhlIG5vZGUgd291bGQgcmVzdWx0IGluIGEgRE9NIHRyZWUgdGhhdCBpcyBub3RcbiAgICAgKiB3ZWxsLWZvcm1lZCwgb3IgaWYgYGNoaWxkYCBpcyBwcm92aWRlZCBidXQgaXMgbm90IGEgY2hpbGQgb2YgYHBhcmVudGAuXG4gICAgICogU2VlIHtAbGluayBfaW5zZXJ0QmVmb3JlfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBzaW5jZSBNb2RpZmllZCBpbiBET00gTDJcbiAgICAgKi9cbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKHIsIHUpIHtcbiAgICAgIHJldHVybiBxKHRoaXMsIHIsIHUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW4gb2xkIGNoaWxkIG5vZGUgd2l0aCBhIG5ldyBjaGlsZCBub2RlIHdpdGhpbiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5ld0NoaWxkXG4gICAgICogVGhlIG5ldyBub2RlIHRoYXQgaXMgdG8gcmVwbGFjZSB0aGUgb2xkIG5vZGUuXG4gICAgICogSWYgaXQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIERPTSwgaXQgaXMgcmVtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge05vZGV9IG9sZENoaWxkXG4gICAgICogVGhlIGV4aXN0aW5nIGNoaWxkIG5vZGUgdG8gYmUgcmVwbGFjZWQuXG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICogUmV0dXJucyB0aGUgcmVwbGFjZWQgY2hpbGQgbm9kZS5cbiAgICAgKiBAdGhyb3dzIHtET01FeGNlcHRpb259XG4gICAgICogVGhyb3dzIGEgRE9NRXhjZXB0aW9uIGlmIHJlcGxhY2luZyB0aGUgbm9kZSB3b3VsZCByZXN1bHQgaW4gYSBET00gdHJlZSB0aGF0IGlzIG5vdFxuICAgICAqIHdlbGwtZm9ybWVkLCBvciBpZiBgb2xkQ2hpbGRgIGlzIG5vdCBhIGNoaWxkIG9mIGB0aGlzYC5cbiAgICAgKiBUaGlzIGNhbiBhbHNvIG9jY3VyIGlmIHRoZSBwcmUtcmVwbGFjZW1lbnQgdmFsaWRpdHkgYXNzZXJ0aW9uIGZhaWxzLlxuICAgICAqIFNlZSB7QGxpbmsgX2luc2VydEJlZm9yZX0sIHtAbGluayBOb2RlLnJlbW92ZUNoaWxkfSwgYW5kXG4gICAgICoge0BsaW5rIGFzc2VydFByZVJlcGxhY2VtZW50VmFsaWRpdHlJbkRvY3VtZW50fSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW5vZGUtcmVwbGFjZVxuICAgICAqL1xuICAgIHJlcGxhY2VDaGlsZDogZnVuY3Rpb24ociwgdSkge1xuICAgICAgcSh0aGlzLCByLCB1LCBXZSksIHUgJiYgdGhpcy5yZW1vdmVDaGlsZCh1KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gZXhpc3RpbmcgY2hpbGQgbm9kZSBmcm9tIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gb2xkQ2hpbGRcbiAgICAgKiBUaGUgY2hpbGQgbm9kZSB0byBiZSByZW1vdmVkLlxuICAgICAqIEByZXR1cm5zIHtOb2RlfVxuICAgICAqIFJldHVybnMgdGhlIHJlbW92ZWQgY2hpbGQgbm9kZS5cbiAgICAgKiBAdGhyb3dzIHtET01FeGNlcHRpb259XG4gICAgICogVGhyb3dzIGEgRE9NRXhjZXB0aW9uIGlmIGBvbGRDaGlsZGAgaXMgbm90IGEgY2hpbGQgb2YgYHRoaXNgLlxuICAgICAqIFNlZSB7QGxpbmsgX3JlbW92ZUNoaWxkfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gRmUodGhpcywgcik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgY2hpbGQgbm9kZSB0byB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5ld0NoaWxkXG4gICAgICogVGhlIGNoaWxkIG5vZGUgdG8gYmUgYXBwZW5kZWQgdG8gdGhpcyBub2RlLlxuICAgICAqIElmIGl0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBET00sIGl0IGlzIHJlbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICogUmV0dXJucyB0aGUgYXBwZW5kZWQgY2hpbGQgbm9kZS5cbiAgICAgKiBAdGhyb3dzIHtET01FeGNlcHRpb259XG4gICAgICogVGhyb3dzIGEgRE9NRXhjZXB0aW9uIGlmIGFwcGVuZGluZyB0aGUgbm9kZSB3b3VsZCByZXN1bHQgaW4gYSBET00gdHJlZSB0aGF0IGlzIG5vdFxuICAgICAqIHdlbGwtZm9ybWVkLCBvciBpZiBgbmV3Q2hpbGRgIGlzIG5vdCBhIHZhbGlkIE5vZGUuXG4gICAgICogU2VlIHtAbGluayBpbnNlcnRCZWZvcmV9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICovXG4gICAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShyLCBudWxsKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGlzIG5vZGUgaGFzIGFueSBjaGlsZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIG5vZGUgaGFzIGFueSBjaGlsZCBub2RlcywgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBoYXNDaGlsZE5vZGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpcnN0Q2hpbGQgIT0gbnVsbDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBjYWxsaW5nIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlZXBcbiAgICAgKiBJZiB0cnVlLCB0aGUgY29udGVudHMgb2YgdGhlIG5vZGUgYXJlIHJlY3Vyc2l2ZWx5IGNvcGllZC5cbiAgICAgKiBJZiBmYWxzZSwgb25seSB0aGUgbm9kZSBpdHNlbGYgKGFuZCBpdHMgYXR0cmlidXRlcywgaWYgaXQgaXMgYW4gZWxlbWVudCkgYXJlIGNvcGllZC5cbiAgICAgKiBAcmV0dXJucyB7Tm9kZX1cbiAgICAgKiBSZXR1cm5zIHRoZSBuZXdseSBjcmVhdGVkIGNvcHkgb2YgdGhlIG5vZGUuXG4gICAgICogQHRocm93cyB7RE9NRXhjZXB0aW9ufVxuICAgICAqIE1heSB0aHJvdyBhIERPTUV4Y2VwdGlvbiBpZiBvcGVyYXRpb25zIHdpdGhpbiB7QGxpbmsgRWxlbWVudCNzZXRBdHRyaWJ1dGVOb2RlfSBvclxuICAgICAqIHtAbGluayBOb2RlI2FwcGVuZENoaWxkfSAod2hpY2ggYXJlIHBvdGVudGlhbGx5IGludm9rZWQgaW4gdGhpcyBtZXRob2QpIGRvIG5vdCBtZWV0IHRoZWlyXG4gICAgICogc3BlY2lmaWMgY29uc3RyYWludHMuXG4gICAgICogQHNlZSB7QGxpbmsgY2xvbmVOb2RlfVxuICAgICAqL1xuICAgIGNsb25lTm9kZTogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIEx0KHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLCB0aGlzLCByKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFB1dHMgdGhlIHNwZWNpZmllZCBub2RlIGFuZCBhbGwgb2YgaXRzIHN1YnRyZWUgaW50byBhIFwibm9ybWFsaXplZFwiIGZvcm0uIEluIGEgbm9ybWFsaXplZFxuICAgICAqIHN1YnRyZWUsIG5vIHRleHQgbm9kZXMgaW4gdGhlIHN1YnRyZWUgYXJlIGVtcHR5IGFuZCB0aGVyZSBhcmUgbm8gYWRqYWNlbnQgdGV4dCBub2Rlcy5cbiAgICAgKlxuICAgICAqIFNwZWNpZmljYWxseSwgdGhpcyBtZXRob2QgbWVyZ2VzIGFueSBhZGphY2VudCB0ZXh0IG5vZGVzIChpLmUuLCBub2RlcyBmb3Igd2hpY2ggYG5vZGVUeXBlYFxuICAgICAqIGlzIGBURVhUX05PREVgKSBpbnRvIGEgc2luZ2xlIG5vZGUgd2l0aCB0aGUgY29tYmluZWQgZGF0YS4gSXQgYWxzbyByZW1vdmVzIGFueSBlbXB0eSB0ZXh0XG4gICAgICogbm9kZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBvcGVyYXRlcyByZWN1cnNpdmVseSwgc28gaXQgYWxzbyBub3JtYWxpemVzIGFueSBhbmQgYWxsIGRlc2NlbmRlbnQgbm9kZXMgd2l0aGluXG4gICAgICogdGhlIHN1YnRyZWUuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtET01FeGNlcHRpb259XG4gICAgICogTWF5IHRocm93IGEgRE9NRXhjZXB0aW9uIGlmIG9wZXJhdGlvbnMgd2l0aGluIHJlbW92ZUNoaWxkIG9yIGFwcGVuZERhdGEgKHdoaWNoIGFyZVxuICAgICAqIHBvdGVudGlhbGx5IGludm9rZWQgaW4gdGhpcyBtZXRob2QpIGRvIG5vdCBtZWV0IHRoZWlyIHNwZWNpZmljIGNvbnN0cmFpbnRzLlxuICAgICAqIEBzaW5jZSBNb2RpZmllZCBpbiBET00gTGV2ZWwgMlxuICAgICAqIEBzZWUge0BsaW5rIE5vZGUucmVtb3ZlQ2hpbGR9XG4gICAgICogQHNlZSB7QGxpbmsgQ2hhcmFjdGVyRGF0YS5hcHBlbmREYXRhfVxuICAgICAqL1xuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciByID0gdGhpcy5maXJzdENoaWxkOyByOyApIHtcbiAgICAgICAgdmFyIHUgPSByLm5leHRTaWJsaW5nO1xuICAgICAgICB1ICYmIHUubm9kZVR5cGUgPT0gZWUgJiYgci5ub2RlVHlwZSA9PSBlZSA/ICh0aGlzLnJlbW92ZUNoaWxkKHUpLCByLmFwcGVuZERhdGEodS5kYXRhKSkgOiAoci5ub3JtYWxpemUoKSwgciA9IHUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIERPTSBpbXBsZW1lbnRhdGlvbiBpbXBsZW1lbnRzIGEgc3BlY2lmaWMgZmVhdHVyZSBhbmQgaXRzIHZlcnNpb24uXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIFNpbmNlIGBET01JbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlYCBpcyBkZXByZWNhdGVkIGFuZCBhbHdheXMgcmV0dXJucyB0cnVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlXG4gICAgICogVGhlIHBhY2thZ2UgbmFtZSBvZiB0aGUgZmVhdHVyZSB0byB0ZXN0LiBUaGlzIGlzIHRoZSBzYW1lIG5hbWUgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZVxuICAgICAqIG1ldGhvZCBgaGFzRmVhdHVyZWAgb24gYERPTUltcGxlbWVudGF0aW9uYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICAgICAqIFRoaXMgaXMgdGhlIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBwYWNrYWdlIG5hbWUgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBSZXR1cm5zIHRydWUgaW4gYWxsIGNhc2VzIGluIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBzaW5jZSBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyXG4gICAgICogQHNlZSB7QGxpbmsgRE9NSW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZX1cbiAgICAgKi9cbiAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24ociwgdSkge1xuICAgICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKHIsIHUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogTG9vayB1cCB0aGUgcHJlZml4IGFzc29jaWF0ZWQgdG8gdGhlIGdpdmVuIG5hbWVzcGFjZSBVUkksIHN0YXJ0aW5nIGZyb20gdGhpcyBub2RlLlxuICAgICAqICoqVGhlIGRlZmF1bHQgbmFtZXNwYWNlIGRlY2xhcmF0aW9ucyBhcmUgaWdub3JlZCBieSB0aGlzIG1ldGhvZC4qKlxuICAgICAqIFNlZSBOYW1lc3BhY2UgUHJlZml4IExvb2t1cCBmb3IgZGV0YWlscyBvbiB0aGUgYWxnb3JpdGhtIHVzZWQgYnkgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKlRoaXMgYmVoYXZpb3IgaXMgZGlmZmVyZW50IGZyb20gdGhlIGluIHRoZSBzcGVjcyoqOlxuICAgICAqIC0gbm8gbm9kZSB0eXBlIHNwZWNpZmljIGhhbmRsaW5nXG4gICAgICogLSB1c2VzIHRoZSBpbnRlcm5hbCBhdHRyaWJ1dGUgX25zTWFwIGZvciByZXNvbHZpbmcgbmFtZXNwYWNlcyB0aGF0IGlzIHVwZGF0ZWQgd2hlbiBjaGFuZ2luZyBhdHRyaWJ1dGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IG5hbWVzcGFjZVVSSVxuICAgICAqIFRoZSBuYW1lc3BhY2UgVVJJIGZvciB3aGljaCB0byBmaW5kIHRoZSBhc3NvY2lhdGVkIHByZWZpeC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cbiAgICAgKiBUaGUgYXNzb2NpYXRlZCBwcmVmaXgsIGlmIGZvdW5kOyBvdGhlcndpc2UsIG51bGwuXG4gICAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yZS9jb3JlLmh0bWwjTm9kZTMtbG9va3VwTmFtZXNwYWNlUHJlZml4XG4gICAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yZS9uYW1lc3BhY2VzLWFsZ29yaXRobXMuaHRtbCNsb29rdXBOYW1lc3BhY2VQcmVmaXhBbGdvXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ub2RlLWxvb2t1cHByZWZpeFxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3htbGRvbS94bWxkb20vaXNzdWVzLzMyMlxuICAgICAqIEBwcmV0dGllcmlnbm9yZVxuICAgICAqL1xuICAgIGxvb2t1cFByZWZpeDogZnVuY3Rpb24ocikge1xuICAgICAgZm9yICh2YXIgdSA9IHRoaXM7IHU7ICkge1xuICAgICAgICB2YXIgcyA9IHUuX25zTWFwO1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgIGZvciAodmFyIGMgaW4gcylcbiAgICAgICAgICAgIGlmIChpKHMsIGMpICYmIHNbY10gPT09IHIpXG4gICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9XG4gICAgICAgIHUgPSB1Lm5vZGVUeXBlID09IEsgPyB1Lm93bmVyRG9jdW1lbnQgOiB1LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBsb29rIHVwIHRoZSBuYW1lc3BhY2UgVVJJIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcHJlZml4LFxuICAgICAqIHN0YXJ0aW5nIGZyb20gdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogKipUaGlzIGJlaGF2aW9yIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBpbiB0aGUgc3BlY3MqKjpcbiAgICAgKiAtIG5vIG5vZGUgdHlwZSBzcGVjaWZpYyBoYW5kbGluZ1xuICAgICAqIC0gdXNlcyB0aGUgaW50ZXJuYWwgYXR0cmlidXRlIF9uc01hcCBmb3IgcmVzb2x2aW5nIG5hbWVzcGFjZXMgdGhhdCBpcyB1cGRhdGVkIHdoZW4gY2hhbmdpbmcgYXR0cmlidXRlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBwcmVmaXhcbiAgICAgKiBUaGUgcHJlZml4IGZvciB3aGljaCB0byBmaW5kIHRoZSBhc3NvY2lhdGVkIG5hbWVzcGFjZSBVUkkuXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XG4gICAgICogVGhlIGFzc29jaWF0ZWQgbmFtZXNwYWNlIFVSSSwgaWYgZm91bmQ7IG90aGVyd2lzZSwgbnVsbC5cbiAgICAgKiBAc2luY2UgRE9NIExldmVsIDNcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLW5vZGUtbG9va3VwbmFtZXNwYWNldXJpXG4gICAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yZS9jb3JlLmh0bWwjTm9kZTMtbG9va3VwTmFtZXNwYWNlVVJJXG4gICAgICogQHByZXR0aWVyaWdub3JlXG4gICAgICovXG4gICAgbG9va3VwTmFtZXNwYWNlVVJJOiBmdW5jdGlvbihyKSB7XG4gICAgICBmb3IgKHZhciB1ID0gdGhpczsgdTsgKSB7XG4gICAgICAgIHZhciBzID0gdS5fbnNNYXA7XG4gICAgICAgIGlmIChzICYmIGkocywgcikpXG4gICAgICAgICAgcmV0dXJuIHNbcl07XG4gICAgICAgIHUgPSB1Lm5vZGVUeXBlID09IEsgPyB1Lm93bmVyRG9jdW1lbnQgOiB1LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gbmFtZXNwYWNlIFVSSSBpcyB0aGUgZGVmYXVsdCBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBUaGUgZnVuY3Rpb24gd29ya3MgYnkgbG9va2luZyB1cCB0aGUgcHJlZml4IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gbmFtZXNwYWNlIFVSSS4gSWYgbm9cbiAgICAgKiBwcmVmaXggaXMgZm91bmQgKGkuZS4sIHRoZSBuYW1lc3BhY2UgVVJJIGlzIG5vdCByZWdpc3RlcmVkIGluIHRoZSBuYW1lc3BhY2UgbWFwIG9mIHRoaXNcbiAgICAgKiBub2RlIG9yIGFueSBvZiBpdHMgYW5jZXN0b3JzKSwgaXQgcmV0dXJucyBgdHJ1ZWAsIGltcGx5aW5nIHRoZSBuYW1lc3BhY2UgVVJJIGlzIGNvbnNpZGVyZWRcbiAgICAgKiB0aGUgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqICoqVGhpcyBiZWhhdmlvciBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgaW4gdGhlIHNwZWNzKio6XG4gICAgICogLSBubyBub2RlIHR5cGUgc3BlY2lmaWMgaGFuZGxpbmdcbiAgICAgKiAtIHVzZXMgdGhlIGludGVybmFsIGF0dHJpYnV0ZSBfbnNNYXAgZm9yIHJlc29sdmluZyBuYW1lc3BhY2VzIHRoYXQgaXMgdXBkYXRlZCB3aGVuIGNoYW5naW5nIGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gbmFtZXNwYWNlVVJJXG4gICAgICogVGhlIG5hbWVzcGFjZSBVUkkgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG5hbWVzcGFjZSBVUkkgaXMgdGhlIGRlZmF1bHQgbmFtZXNwYWNlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHNpbmNlIERPTSBMZXZlbCAzXG4gICAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yZS9jb3JlLmh0bWwjTm9kZTMtaXNEZWZhdWx0TmFtZXNwYWNlXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ub2RlLWlzZGVmYXVsdG5hbWVzcGFjZVxuICAgICAqIEBwcmV0dGllcmlnbm9yZVxuICAgICAqL1xuICAgIGlzRGVmYXVsdE5hbWVzcGFjZTogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIHUgPSB0aGlzLmxvb2t1cFByZWZpeChyKTtcbiAgICAgIHJldHVybiB1ID09IG51bGw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0aGUgcmVmZXJlbmNlIG5vZGUgd2l0aCBhIG5vZGUgd2l0aCByZWdhcmQgdG8gdGhlaXIgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50IGFuZFxuICAgICAqIGFjY29yZGluZyB0byB0aGUgZG9jdW1lbnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG90aGVyXG4gICAgICogVGhlIG5vZGUgdG8gY29tcGFyZSB0aGUgcmVmZXJlbmNlIG5vZGUgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBSZXR1cm5zIGhvdyB0aGUgbm9kZSBpcyBwb3NpdGlvbmVkIHJlbGF0aXZlbHkgdG8gdGhlIHJlZmVyZW5jZSBub2RlIGFjY29yZGluZyB0byB0aGVcbiAgICAgKiBiaXRtYXNrLiAwIGlmIHJlZmVyZW5jZSBub2RlIGFuZCBnaXZlbiBub2RlIGFyZSB0aGUgc2FtZS5cbiAgICAgKiBAc2luY2UgRE9NIExldmVsIDNcbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA0L1JFQy1ET00tTGV2ZWwtMy1Db3JlLTIwMDQwNDA3L2NvcmUuaHRtbCNOb2RlMy1jb21wYXJlXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ub2RlLWNvbXBhcmVkb2N1bWVudHBvc2l0aW9uXG4gICAgICovXG4gICAgY29tcGFyZURvY3VtZW50UG9zaXRpb246IGZ1bmN0aW9uKHIpIHtcbiAgICAgIGlmICh0aGlzID09PSByKSByZXR1cm4gMDtcbiAgICAgIHZhciB1ID0gciwgcyA9IHRoaXMsIGMgPSBudWxsLCBEID0gbnVsbDtcbiAgICAgIGlmICh1IGluc3RhbmNlb2YgQWUgJiYgKGMgPSB1LCB1ID0gYy5vd25lckVsZW1lbnQpLCBzIGluc3RhbmNlb2YgQWUgJiYgKEQgPSBzLCBzID0gRC5vd25lckVsZW1lbnQsIGMgJiYgdSAmJiBzID09PSB1KSlcbiAgICAgICAgZm9yICh2YXIgUyA9IDAsIFg7IFggPSBzLmF0dHJpYnV0ZXNbU107IFMrKykge1xuICAgICAgICAgIGlmIChYID09PSBjKVxuICAgICAgICAgICAgcmV0dXJuIEIuRE9DVU1FTlRfUE9TSVRJT05fSU1QTEVNRU5UQVRJT05fU1BFQ0lGSUMgKyBCLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORztcbiAgICAgICAgICBpZiAoWCA9PT0gRClcbiAgICAgICAgICAgIHJldHVybiBCLkRPQ1VNRU5UX1BPU0lUSU9OX0lNUExFTUVOVEFUSU9OX1NQRUNJRklDICsgQi5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gICAgICAgIH1cbiAgICAgIGlmICghdSB8fCAhcyB8fCBzLm93bmVyRG9jdW1lbnQgIT09IHUub3duZXJEb2N1bWVudClcbiAgICAgICAgcmV0dXJuIEIuRE9DVU1FTlRfUE9TSVRJT05fRElTQ09OTkVDVEVEICsgQi5ET0NVTUVOVF9QT1NJVElPTl9JTVBMRU1FTlRBVElPTl9TUEVDSUZJQyArIChfKHMub3duZXJEb2N1bWVudCkgPiBfKHUub3duZXJEb2N1bWVudCkgPyBCLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyA6IEIuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HKTtcbiAgICAgIGlmIChEICYmIHUgPT09IHMpXG4gICAgICAgIHJldHVybiBCLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TICsgQi5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkc7XG4gICAgICBpZiAoYyAmJiB1ID09PSBzKVxuICAgICAgICByZXR1cm4gQi5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkgKyBCLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgICAgIGZvciAodmFyIGFlID0gW10sIGRlID0gdS5wYXJlbnROb2RlOyBkZTsgKSB7XG4gICAgICAgIGlmICghRCAmJiBkZSA9PT0gcylcbiAgICAgICAgICByZXR1cm4gQi5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkgKyBCLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgICAgICAgYWUucHVzaChkZSksIGRlID0gZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIGFlLnJldmVyc2UoKTtcbiAgICAgIGZvciAodmFyIHllID0gW10sIGdlID0gcy5wYXJlbnROb2RlOyBnZTsgKSB7XG4gICAgICAgIGlmICghYyAmJiBnZSA9PT0gdSlcbiAgICAgICAgICByZXR1cm4gQi5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUyArIEIuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HO1xuICAgICAgICB5ZS5wdXNoKGdlKSwgZ2UgPSBnZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgeWUucmV2ZXJzZSgpO1xuICAgICAgdmFyIFplID0gSihhZSwgeWUpO1xuICAgICAgZm9yICh2YXIgVWUgaW4gWmUuY2hpbGROb2Rlcykge1xuICAgICAgICB2YXIgT2UgPSBaZS5jaGlsZE5vZGVzW1VlXTtcbiAgICAgICAgaWYgKE9lID09PSBzKSByZXR1cm4gQi5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gICAgICAgIGlmIChPZSA9PT0gdSkgcmV0dXJuIEIuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HO1xuICAgICAgICBpZiAoeWUuaW5kZXhPZihPZSkgPj0gMCkgcmV0dXJuIEIuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICAgICAgICBpZiAoYWUuaW5kZXhPZihPZSkgPj0gMCkgcmV0dXJuIEIuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiAkZShyKSB7XG4gICAgcmV0dXJuIHIgPT0gXCI8XCIgJiYgXCImbHQ7XCIgfHwgciA9PSBcIj5cIiAmJiBcIiZndDtcIiB8fCByID09IFwiJlwiICYmIFwiJmFtcDtcIiB8fCByID09ICdcIicgJiYgXCImcXVvdDtcIiB8fCBcIiYjXCIgKyByLmNoYXJDb2RlQXQoKSArIFwiO1wiO1xuICB9XG4gIGcoRiwgUCksIGcoRiwgUC5wcm90b3R5cGUpLCBnKEIsIFApLCBnKEIsIFAucHJvdG90eXBlKTtcbiAgZnVuY3Rpb24gUmUociwgdSkge1xuICAgIGlmICh1KHIpKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGlmIChyID0gci5maXJzdENoaWxkKVxuICAgICAgZG9cbiAgICAgICAgaWYgKFJlKHIsIHUpKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIHdoaWxlIChyID0gci5uZXh0U2libGluZyk7XG4gIH1cbiAgZnVuY3Rpb24gcGUociwgdSkge1xuICAgIGIocik7XG4gICAgdmFyIHMgPSB1IHx8IHt9O1xuICAgIHRoaXMub3duZXJEb2N1bWVudCA9IHRoaXMsIHRoaXMuY29udGVudFR5cGUgPSBzLmNvbnRlbnRUeXBlIHx8IHAuWE1MX0FQUExJQ0FUSU9OLCB0aGlzLnR5cGUgPSBvKHRoaXMuY29udGVudFR5cGUpID8gXCJodG1sXCIgOiBcInhtbFwiO1xuICB9XG4gIGZ1bmN0aW9uIFZlKHIsIHUsIHMpIHtcbiAgICByICYmIHIuX2luYysrO1xuICAgIHZhciBjID0gcy5uYW1lc3BhY2VVUkk7XG4gICAgYyA9PT0gZi5YTUxOUyAmJiAodS5fbnNNYXBbcy5wcmVmaXggPyBzLmxvY2FsTmFtZSA6IFwiXCJdID0gcy52YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gX2UociwgdSwgcywgYykge1xuICAgIHIgJiYgci5faW5jKys7XG4gICAgdmFyIEQgPSBzLm5hbWVzcGFjZVVSSTtcbiAgICBEID09PSBmLlhNTE5TICYmIGRlbGV0ZSB1Ll9uc01hcFtzLnByZWZpeCA/IHMubG9jYWxOYW1lIDogXCJcIl07XG4gIH1cbiAgZnVuY3Rpb24gU2UociwgdSwgcykge1xuICAgIGlmIChyICYmIHIuX2luYykge1xuICAgICAgci5faW5jKys7XG4gICAgICB2YXIgYyA9IHUuY2hpbGROb2RlcztcbiAgICAgIGlmIChzICYmICFzLm5leHRTaWJsaW5nKVxuICAgICAgICBjW2MubGVuZ3RoKytdID0gcztcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBEID0gdS5maXJzdENoaWxkLCBTID0gMDsgRDsgKVxuICAgICAgICAgIGNbUysrXSA9IEQsIEQgPSBELm5leHRTaWJsaW5nO1xuICAgICAgICBjLmxlbmd0aCA9IFMsIGRlbGV0ZSBjW2MubGVuZ3RoXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gRmUociwgdSkge1xuICAgIGlmIChyICE9PSB1LnBhcmVudE5vZGUpXG4gICAgICB0aHJvdyBuZXcgbChsLk5PVF9GT1VORF9FUlIsIFwiY2hpbGQncyBwYXJlbnQgaXMgbm90IHBhcmVudFwiKTtcbiAgICB2YXIgcyA9IHUucHJldmlvdXNTaWJsaW5nLCBjID0gdS5uZXh0U2libGluZztcbiAgICByZXR1cm4gcyA/IHMubmV4dFNpYmxpbmcgPSBjIDogci5maXJzdENoaWxkID0gYywgYyA/IGMucHJldmlvdXNTaWJsaW5nID0gcyA6IHIubGFzdENoaWxkID0gcywgU2Uoci5vd25lckRvY3VtZW50LCByKSwgdS5wYXJlbnROb2RlID0gbnVsbCwgdS5wcmV2aW91c1NpYmxpbmcgPSBudWxsLCB1Lm5leHRTaWJsaW5nID0gbnVsbCwgdTtcbiAgfVxuICBmdW5jdGlvbiBIZShyKSB7XG4gICAgcmV0dXJuIHIgJiYgKHIubm9kZVR5cGUgPT09IFAuRE9DVU1FTlRfTk9ERSB8fCByLm5vZGVUeXBlID09PSBQLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfHwgci5ub2RlVHlwZSA9PT0gUC5FTEVNRU5UX05PREUpO1xuICB9XG4gIGZ1bmN0aW9uIEplKHIpIHtcbiAgICByZXR1cm4gciAmJiAoci5ub2RlVHlwZSA9PT0gUC5DREFUQV9TRUNUSU9OX05PREUgfHwgci5ub2RlVHlwZSA9PT0gUC5DT01NRU5UX05PREUgfHwgci5ub2RlVHlwZSA9PT0gUC5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IHIubm9kZVR5cGUgPT09IFAuRE9DVU1FTlRfVFlQRV9OT0RFIHx8IHIubm9kZVR5cGUgPT09IFAuRUxFTUVOVF9OT0RFIHx8IHIubm9kZVR5cGUgPT09IFAuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFIHx8IHIubm9kZVR5cGUgPT09IFAuVEVYVF9OT0RFKTtcbiAgfVxuICBmdW5jdGlvbiBDZShyKSB7XG4gICAgcmV0dXJuIHIgJiYgci5ub2RlVHlwZSA9PT0gUC5ET0NVTUVOVF9UWVBFX05PREU7XG4gIH1cbiAgZnVuY3Rpb24gUShyKSB7XG4gICAgcmV0dXJuIHIgJiYgci5ub2RlVHlwZSA9PT0gUC5FTEVNRU5UX05PREU7XG4gIH1cbiAgZnVuY3Rpb24gR2Uocikge1xuICAgIHJldHVybiByICYmIHIubm9kZVR5cGUgPT09IFAuVEVYVF9OT0RFO1xuICB9XG4gIGZ1bmN0aW9uIG9lKHIsIHUpIHtcbiAgICB2YXIgcyA9IHIuY2hpbGROb2RlcyB8fCBbXTtcbiAgICBpZiAoZShzLCBRKSB8fCBDZSh1KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICB2YXIgYyA9IGUocywgQ2UpO1xuICAgIHJldHVybiAhKHUgJiYgYyAmJiBzLmluZGV4T2YoYykgPiBzLmluZGV4T2YodSkpO1xuICB9XG4gIGZ1bmN0aW9uIFhlKHIsIHUpIHtcbiAgICB2YXIgcyA9IHIuY2hpbGROb2RlcyB8fCBbXTtcbiAgICBmdW5jdGlvbiBjKFMpIHtcbiAgICAgIHJldHVybiBRKFMpICYmIFMgIT09IHU7XG4gICAgfVxuICAgIGlmIChlKHMsIGMpKVxuICAgICAgcmV0dXJuICExO1xuICAgIHZhciBEID0gZShzLCBDZSk7XG4gICAgcmV0dXJuICEodSAmJiBEICYmIHMuaW5kZXhPZihEKSA+IHMuaW5kZXhPZih1KSk7XG4gIH1cbiAgZnVuY3Rpb24gdnQociwgdSwgcykge1xuICAgIGlmICghSGUocikpXG4gICAgICB0aHJvdyBuZXcgbChsLkhJRVJBUkNIWV9SRVFVRVNUX0VSUiwgXCJVbmV4cGVjdGVkIHBhcmVudCBub2RlIHR5cGUgXCIgKyByLm5vZGVUeXBlKTtcbiAgICBpZiAocyAmJiBzLnBhcmVudE5vZGUgIT09IHIpXG4gICAgICB0aHJvdyBuZXcgbChsLk5PVF9GT1VORF9FUlIsIFwiY2hpbGQgbm90IGluIHBhcmVudFwiKTtcbiAgICBpZiAoXG4gICAgICAvLyA0LiBJZiBgbm9kZWAgaXMgbm90IGEgRG9jdW1lbnRGcmFnbWVudCwgRG9jdW1lbnRUeXBlLCBFbGVtZW50LCBvciBDaGFyYWN0ZXJEYXRhIG5vZGUsIHRoZW4gdGhyb3cgYSBcIkhpZXJhcmNoeVJlcXVlc3RFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICAgICFKZSh1KSB8fCAvLyA1LiBJZiBlaXRoZXIgYG5vZGVgIGlzIGEgVGV4dCBub2RlIGFuZCBgcGFyZW50YCBpcyBhIGRvY3VtZW50LFxuICAgICAgLy8gdGhlIHNheCBwYXJzZXIgY3VycmVudGx5IGFkZHMgdG9wIGxldmVsIHRleHQgbm9kZXMsIHRoaXMgd2lsbCBiZSBmaXhlZCBpbiAwLjkuMFxuICAgICAgLy8gfHwgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKVxuICAgICAgLy8gb3IgYG5vZGVgIGlzIGEgZG9jdHlwZSBhbmQgYHBhcmVudGAgaXMgbm90IGEgZG9jdW1lbnQsIHRoZW4gdGhyb3cgYSBcIkhpZXJhcmNoeVJlcXVlc3RFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICAgIENlKHUpICYmIHIubm9kZVR5cGUgIT09IFAuRE9DVU1FTlRfTk9ERVxuICAgIClcbiAgICAgIHRocm93IG5ldyBsKFxuICAgICAgICBsLkhJRVJBUkNIWV9SRVFVRVNUX0VSUixcbiAgICAgICAgXCJVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIiArIHUubm9kZVR5cGUgKyBcIiBmb3IgcGFyZW50IG5vZGUgdHlwZSBcIiArIHIubm9kZVR5cGVcbiAgICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gWWUociwgdSwgcykge1xuICAgIHZhciBjID0gci5jaGlsZE5vZGVzIHx8IFtdLCBEID0gdS5jaGlsZE5vZGVzIHx8IFtdO1xuICAgIGlmICh1Lm5vZGVUeXBlID09PSBQLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgIHZhciBTID0gRC5maWx0ZXIoUSk7XG4gICAgICBpZiAoUy5sZW5ndGggPiAxIHx8IGUoRCwgR2UpKVxuICAgICAgICB0aHJvdyBuZXcgbChsLkhJRVJBUkNIWV9SRVFVRVNUX0VSUiwgXCJNb3JlIHRoYW4gb25lIGVsZW1lbnQgb3IgdGV4dCBpbiBmcmFnbWVudFwiKTtcbiAgICAgIGlmIChTLmxlbmd0aCA9PT0gMSAmJiAhb2UociwgcykpXG4gICAgICAgIHRocm93IG5ldyBsKGwuSElFUkFSQ0hZX1JFUVVFU1RfRVJSLCBcIkVsZW1lbnQgaW4gZnJhZ21lbnQgY2FuIG5vdCBiZSBpbnNlcnRlZCBiZWZvcmUgZG9jdHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKFEodSkgJiYgIW9lKHIsIHMpKVxuICAgICAgdGhyb3cgbmV3IGwobC5ISUVSQVJDSFlfUkVRVUVTVF9FUlIsIFwiT25seSBvbmUgZWxlbWVudCBjYW4gYmUgYWRkZWQgYW5kIG9ubHkgYWZ0ZXIgZG9jdHlwZVwiKTtcbiAgICBpZiAoQ2UodSkpIHtcbiAgICAgIGlmIChlKGMsIENlKSlcbiAgICAgICAgdGhyb3cgbmV3IGwobC5ISUVSQVJDSFlfUkVRVUVTVF9FUlIsIFwiT25seSBvbmUgZG9jdHlwZSBpcyBhbGxvd2VkXCIpO1xuICAgICAgdmFyIFggPSBlKGMsIFEpO1xuICAgICAgaWYgKHMgJiYgYy5pbmRleE9mKFgpIDwgYy5pbmRleE9mKHMpKVxuICAgICAgICB0aHJvdyBuZXcgbChsLkhJRVJBUkNIWV9SRVFVRVNUX0VSUiwgXCJEb2N0eXBlIGNhbiBvbmx5IGJlIGluc2VydGVkIGJlZm9yZSBhbiBlbGVtZW50XCIpO1xuICAgICAgaWYgKCFzICYmIFgpXG4gICAgICAgIHRocm93IG5ldyBsKGwuSElFUkFSQ0hZX1JFUVVFU1RfRVJSLCBcIkRvY3R5cGUgY2FuIG5vdCBiZSBhcHBlbmRlZCBzaW5jZSBlbGVtZW50IGlzIHByZXNlbnRcIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFdlKHIsIHUsIHMpIHtcbiAgICB2YXIgYyA9IHIuY2hpbGROb2RlcyB8fCBbXSwgRCA9IHUuY2hpbGROb2RlcyB8fCBbXTtcbiAgICBpZiAodS5ub2RlVHlwZSA9PT0gUC5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgUyA9IEQuZmlsdGVyKFEpO1xuICAgICAgaWYgKFMubGVuZ3RoID4gMSB8fCBlKEQsIEdlKSlcbiAgICAgICAgdGhyb3cgbmV3IGwobC5ISUVSQVJDSFlfUkVRVUVTVF9FUlIsIFwiTW9yZSB0aGFuIG9uZSBlbGVtZW50IG9yIHRleHQgaW4gZnJhZ21lbnRcIik7XG4gICAgICBpZiAoUy5sZW5ndGggPT09IDEgJiYgIVhlKHIsIHMpKVxuICAgICAgICB0aHJvdyBuZXcgbChsLkhJRVJBUkNIWV9SRVFVRVNUX0VSUiwgXCJFbGVtZW50IGluIGZyYWdtZW50IGNhbiBub3QgYmUgaW5zZXJ0ZWQgYmVmb3JlIGRvY3R5cGVcIik7XG4gICAgfVxuICAgIGlmIChRKHUpICYmICFYZShyLCBzKSlcbiAgICAgIHRocm93IG5ldyBsKGwuSElFUkFSQ0hZX1JFUVVFU1RfRVJSLCBcIk9ubHkgb25lIGVsZW1lbnQgY2FuIGJlIGFkZGVkIGFuZCBvbmx5IGFmdGVyIGRvY3R5cGVcIik7XG4gICAgaWYgKENlKHUpKSB7XG4gICAgICBpZiAoZShjLCBmdW5jdGlvbihkZSkge1xuICAgICAgICByZXR1cm4gQ2UoZGUpICYmIGRlICE9PSBzO1xuICAgICAgfSkpXG4gICAgICAgIHRocm93IG5ldyBsKGwuSElFUkFSQ0hZX1JFUVVFU1RfRVJSLCBcIk9ubHkgb25lIGRvY3R5cGUgaXMgYWxsb3dlZFwiKTtcbiAgICAgIHZhciBYID0gZShjLCBRKTtcbiAgICAgIGlmIChzICYmIGMuaW5kZXhPZihYKSA8IGMuaW5kZXhPZihzKSlcbiAgICAgICAgdGhyb3cgbmV3IGwobC5ISUVSQVJDSFlfUkVRVUVTVF9FUlIsIFwiRG9jdHlwZSBjYW4gb25seSBiZSBpbnNlcnRlZCBiZWZvcmUgYW4gZWxlbWVudFwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcShyLCB1LCBzLCBjKSB7XG4gICAgdnQociwgdSwgcyksIHIubm9kZVR5cGUgPT09IFAuRE9DVU1FTlRfTk9ERSAmJiAoYyB8fCBZZSkociwgdSwgcyk7XG4gICAgdmFyIEQgPSB1LnBhcmVudE5vZGU7XG4gICAgaWYgKEQgJiYgRC5yZW1vdmVDaGlsZCh1KSwgdS5ub2RlVHlwZSA9PT0gTSkge1xuICAgICAgdmFyIFMgPSB1LmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAoUyA9PSBudWxsKVxuICAgICAgICByZXR1cm4gdTtcbiAgICAgIHZhciBYID0gdS5sYXN0Q2hpbGQ7XG4gICAgfSBlbHNlXG4gICAgICBTID0gWCA9IHU7XG4gICAgdmFyIGFlID0gcyA/IHMucHJldmlvdXNTaWJsaW5nIDogci5sYXN0Q2hpbGQ7XG4gICAgUy5wcmV2aW91c1NpYmxpbmcgPSBhZSwgWC5uZXh0U2libGluZyA9IHMsIGFlID8gYWUubmV4dFNpYmxpbmcgPSBTIDogci5maXJzdENoaWxkID0gUywgcyA9PSBudWxsID8gci5sYXN0Q2hpbGQgPSBYIDogcy5wcmV2aW91c1NpYmxpbmcgPSBYO1xuICAgIGRvXG4gICAgICBTLnBhcmVudE5vZGUgPSByO1xuICAgIHdoaWxlIChTICE9PSBYICYmIChTID0gUy5uZXh0U2libGluZykpO1xuICAgIHJldHVybiBTZShyLm93bmVyRG9jdW1lbnQgfHwgciwgciwgdSksIHUubm9kZVR5cGUgPT0gTSAmJiAodS5maXJzdENoaWxkID0gdS5sYXN0Q2hpbGQgPSBudWxsKSwgdTtcbiAgfVxuICBwZS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIHRoYXQgY3JlYXRlZCB0aGlzIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHR5cGUgRE9NSW1wbGVtZW50YXRpb25cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBpbXBsZW1lbnRhdGlvbjogbnVsbCxcbiAgICBub2RlTmFtZTogXCIjZG9jdW1lbnRcIixcbiAgICBub2RlVHlwZTogdyxcbiAgICAvKipcbiAgICAgKiBUaGUgRG9jdW1lbnRUeXBlIG5vZGUgb2YgdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHR5cGUgRG9jdW1lbnRUeXBlXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZG9jdHlwZTogbnVsbCxcbiAgICBkb2N1bWVudEVsZW1lbnQ6IG51bGwsXG4gICAgX2luYzogMSxcbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKHIsIHUpIHtcbiAgICAgIGlmIChyLm5vZGVUeXBlID09PSBNKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSByLmZpcnN0Q2hpbGQ7IHM7ICkge1xuICAgICAgICAgIHZhciBjID0gcy5uZXh0U2libGluZztcbiAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShzLCB1KSwgcyA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcSh0aGlzLCByLCB1KSwgci5vd25lckRvY3VtZW50ID0gdGhpcywgdGhpcy5kb2N1bWVudEVsZW1lbnQgPT09IG51bGwgJiYgci5ub2RlVHlwZSA9PT0gRyAmJiAodGhpcy5kb2N1bWVudEVsZW1lbnQgPSByKSwgcjtcbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgdSA9IEZlKHRoaXMsIHIpO1xuICAgICAgcmV0dXJuIHUgPT09IHRoaXMuZG9jdW1lbnRFbGVtZW50ICYmICh0aGlzLmRvY3VtZW50RWxlbWVudCA9IG51bGwpLCB1O1xuICAgIH0sXG4gICAgcmVwbGFjZUNoaWxkOiBmdW5jdGlvbihyLCB1KSB7XG4gICAgICBxKHRoaXMsIHIsIHUsIFdlKSwgci5vd25lckRvY3VtZW50ID0gdGhpcywgdSAmJiB0aGlzLnJlbW92ZUNoaWxkKHUpLCBRKHIpICYmICh0aGlzLmRvY3VtZW50RWxlbWVudCA9IHIpO1xuICAgIH0sXG4gICAgLy8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMjpcbiAgICBpbXBvcnROb2RlOiBmdW5jdGlvbihyLCB1KSB7XG4gICAgICByZXR1cm4gSnQodGhpcywgciwgdSk7XG4gICAgfSxcbiAgICAvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuICAgIGdldEVsZW1lbnRCeUlkOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgdSA9IG51bGw7XG4gICAgICByZXR1cm4gUmUodGhpcy5kb2N1bWVudEVsZW1lbnQsIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHMubm9kZVR5cGUgPT0gRyAmJiBzLmdldEF0dHJpYnV0ZShcImlkXCIpID09IHIpXG4gICAgICAgICAgcmV0dXJuIHUgPSBzLCAhMDtcbiAgICAgIH0pLCB1O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgRWxlbWVudGAgdGhhdCBpcyBvd25lZCBieSB0aGlzIGBEb2N1bWVudGAuXG4gICAgICogSW4gSFRNTCBEb2N1bWVudHMgYGxvY2FsTmFtZWAgaXMgdGhlIGxvd2VyIGNhc2VkIGB0YWdOYW1lYCxcbiAgICAgKiBvdGhlcndpc2Ugbm8gdHJhbnNmb3JtYXRpb24gaXMgYmVpbmcgYXBwbGllZC5cbiAgICAgKiBXaGVuIGBjb250ZW50VHlwZWAgaW1wbGllcyB0aGUgSFRNTCBuYW1lc3BhY2UsIGl0IHdpbGwgYmUgc2V0IGFzIGBuYW1lc3BhY2VVUklgLlxuICAgICAqXG4gICAgICogX19UaGlzIGltcGxlbWVudGF0aW9uIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWNhdGlvbjpfXyAtIFRoZSBwcm92aWRlZCBuYW1lIGlzIG5vdCBjaGVja2VkXG4gICAgICogYWdhaW5zdCB0aGUgYE5hbWVgIHByb2R1Y3Rpb24sXG4gICAgICogc28gbm8gcmVsYXRlZCBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgKiAtIFRoZXJlIGlzIG5vIGludGVyZmFjZSBgSFRNTEVsZW1lbnRgLCBpdCBpcyBhbHdheXMgYW4gYEVsZW1lbnRgLlxuICAgICAqIC0gVGhlcmUgaXMgbm8gc3VwcG9ydCBmb3IgYSBzZWNvbmQgYXJndW1lbnQgdG8gaW5kaWNhdGUgdXNpbmcgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWVcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9jcmVhdGVFbGVtZW50XG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb2N1bWVudC1jcmVhdGVlbGVtZW50XG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtY3JlYXRlLWVsZW1lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgdSA9IG5ldyBaKG0pO1xuICAgICAgdS5vd25lckRvY3VtZW50ID0gdGhpcywgdGhpcy50eXBlID09PSBcImh0bWxcIiAmJiAociA9IHIudG9Mb3dlckNhc2UoKSksIG4odGhpcy5jb250ZW50VHlwZSkgJiYgKHUubmFtZXNwYWNlVVJJID0gZi5IVE1MKSwgdS5ub2RlTmFtZSA9IHIsIHUudGFnTmFtZSA9IHIsIHUubG9jYWxOYW1lID0gciwgdS5jaGlsZE5vZGVzID0gbmV3IFQoKTtcbiAgICAgIHZhciBzID0gdS5hdHRyaWJ1dGVzID0gbmV3IFYoKTtcbiAgICAgIHJldHVybiBzLl9vd25lckVsZW1lbnQgPSB1LCB1O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0RvY3VtZW50RnJhZ21lbnR9XG4gICAgICovXG4gICAgY3JlYXRlRG9jdW1lbnRGcmFnbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciA9IG5ldyBRZShtKTtcbiAgICAgIHJldHVybiByLm93bmVyRG9jdW1lbnQgPSB0aGlzLCByLmNoaWxkTm9kZXMgPSBuZXcgVCgpLCByO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7VGV4dH1cbiAgICAgKi9cbiAgICBjcmVhdGVUZXh0Tm9kZTogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIHUgPSBuZXcgS2UobSk7XG4gICAgICByZXR1cm4gdS5vd25lckRvY3VtZW50ID0gdGhpcywgdS5jaGlsZE5vZGVzID0gbmV3IFQoKSwgdS5hcHBlbmREYXRhKHIpLCB1O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7Q29tbWVudH1cbiAgICAgKi9cbiAgICBjcmVhdGVDb21tZW50OiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgdSA9IG5ldyBzdChtKTtcbiAgICAgIHJldHVybiB1Lm93bmVyRG9jdW1lbnQgPSB0aGlzLCB1LmNoaWxkTm9kZXMgPSBuZXcgVCgpLCB1LmFwcGVuZERhdGEociksIHU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICAgICAqIEByZXR1cm5zIHtDREFUQVNlY3Rpb259XG4gICAgICovXG4gICAgY3JlYXRlQ0RBVEFTZWN0aW9uOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgdSA9IG5ldyBjdChtKTtcbiAgICAgIHJldHVybiB1Lm93bmVyRG9jdW1lbnQgPSB0aGlzLCB1LmNoaWxkTm9kZXMgPSBuZXcgVCgpLCB1LmFwcGVuZERhdGEociksIHU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7UHJvY2Vzc2luZ0luc3RydWN0aW9ufVxuICAgICAqL1xuICAgIGNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbjogZnVuY3Rpb24ociwgdSkge1xuICAgICAgdmFyIHMgPSBuZXcgcHQobSk7XG4gICAgICByZXR1cm4gcy5vd25lckRvY3VtZW50ID0gdGhpcywgcy5jaGlsZE5vZGVzID0gbmV3IFQoKSwgcy5ub2RlTmFtZSA9IHMudGFyZ2V0ID0gciwgcy5ub2RlVmFsdWUgPSBzLmRhdGEgPSB1LCBzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBgQXR0cmAgbm9kZSB0aGF0IGlzIG93bmVkIGJ5IHRoaXMgZG9jdW1lbnQuXG4gICAgICogSW4gSFRNTCBEb2N1bWVudHMgYGxvY2FsTmFtZWAgaXMgdGhlIGxvd2VyIGNhc2VkIGBuYW1lYCxcbiAgICAgKiBvdGhlcndpc2Ugbm8gdHJhbnNmb3JtYXRpb24gaXMgYmVpbmcgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIF9fVGhpcyBpbXBsZW1lbnRhdGlvbiBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmljYXRpb246X18gLSBUaGUgcHJvdmlkZWQgbmFtZSBpcyBub3QgY2hlY2tlZFxuICAgICAqIGFnYWluc3QgdGhlIGBOYW1lYCBwcm9kdWN0aW9uLFxuICAgICAqIHNvIG5vIHJlbGF0ZWQgZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtBdHRyfVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2NyZWF0ZUF0dHJpYnV0ZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9jdW1lbnQtY3JlYXRlYXR0cmlidXRlXG4gICAgICovXG4gICAgY3JlYXRlQXR0cmlidXRlOiBmdW5jdGlvbihyKSB7XG4gICAgICBpZiAoIU8uUU5hbWVfZXhhY3QudGVzdChyKSlcbiAgICAgICAgdGhyb3cgbmV3IGwobC5JTlZBTElEX0NIQVJBQ1RFUl9FUlIsICdpbnZhbGlkIGNoYXJhY3RlciBpbiBuYW1lIFwiJyArIHIgKyAnXCInKTtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwiaHRtbFwiICYmIChyID0gci50b0xvd2VyQ2FzZSgpKSwgdGhpcy5fY3JlYXRlQXR0cmlidXRlKHIpO1xuICAgIH0sXG4gICAgX2NyZWF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIHUgPSBuZXcgQWUobSk7XG4gICAgICByZXR1cm4gdS5vd25lckRvY3VtZW50ID0gdGhpcywgdS5jaGlsZE5vZGVzID0gbmV3IFQoKSwgdS5uYW1lID0gciwgdS5ub2RlTmFtZSA9IHIsIHUubG9jYWxOYW1lID0gciwgdS5zcGVjaWZpZWQgPSAhMCwgdTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gRW50aXR5UmVmZXJlbmNlIG9iamVjdC5cbiAgICAgKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBmaWxsIHRoZSBgY2hpbGROb2Rlc2Agd2l0aCB0aG9zZSBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIGBFbnRpdHlgXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEluIERPTSBMZXZlbCA0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGVudGl0eSB0byByZWZlcmVuY2UuIE5vIG5hbWVzcGFjZSB3ZWxsLWZvcm1lZG5lc3MgY2hlY2tzIGFyZSBwZXJmb3JtZWQuXG4gICAgICogQHJldHVybnMge0VudGl0eVJlZmVyZW5jZX1cbiAgICAgKiBAdGhyb3dzIHtET01FeGNlcHRpb259XG4gICAgICogV2l0aCBjb2RlIGBJTlZBTElEX0NIQVJBQ1RFUl9FUlJgIHdoZW4gYG5hbWVgIGlzIG5vdCB2YWxpZC5cbiAgICAgKiBAdGhyb3dzIHtET01FeGNlcHRpb259XG4gICAgICogd2l0aCBjb2RlIGBOT1RfU1VQUE9SVEVEX0VSUmAgd2hlbiB0aGUgZG9jdW1lbnQgaXMgb2YgdHlwZSBgaHRtbGBcbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL2NvcmUuaHRtbCNJRC0zOTJCNzVBRVxuICAgICAqL1xuICAgIGNyZWF0ZUVudGl0eVJlZmVyZW5jZTogZnVuY3Rpb24ocikge1xuICAgICAgaWYgKCFPLk5hbWUudGVzdChyKSlcbiAgICAgICAgdGhyb3cgbmV3IGwobC5JTlZBTElEX0NIQVJBQ1RFUl9FUlIsICdub3QgYSB2YWxpZCB4bWwgbmFtZSBcIicgKyByICsgJ1wiJyk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSBcImh0bWxcIilcbiAgICAgICAgdGhyb3cgbmV3IGwoXCJkb2N1bWVudCBpcyBhbiBodG1sIGRvY3VtZW50XCIsIHYuTm90U3VwcG9ydGVkRXJyb3IpO1xuICAgICAgdmFyIHUgPSBuZXcgZnQobSk7XG4gICAgICByZXR1cm4gdS5vd25lckRvY3VtZW50ID0gdGhpcywgdS5jaGlsZE5vZGVzID0gbmV3IFQoKSwgdS5ub2RlTmFtZSA9IHIsIHU7XG4gICAgfSxcbiAgICAvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2VVUklcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVhbGlmaWVkTmFtZVxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAqL1xuICAgIGNyZWF0ZUVsZW1lbnROUzogZnVuY3Rpb24ociwgdSkge1xuICAgICAgdmFyIHMgPSBsZShyLCB1KSwgYyA9IG5ldyBaKG0pLCBEID0gYy5hdHRyaWJ1dGVzID0gbmV3IFYoKTtcbiAgICAgIHJldHVybiBjLmNoaWxkTm9kZXMgPSBuZXcgVCgpLCBjLm93bmVyRG9jdW1lbnQgPSB0aGlzLCBjLm5vZGVOYW1lID0gdSwgYy50YWdOYW1lID0gdSwgYy5uYW1lc3BhY2VVUkkgPSBzWzBdLCBjLnByZWZpeCA9IHNbMV0sIGMubG9jYWxOYW1lID0gc1syXSwgRC5fb3duZXJFbGVtZW50ID0gYywgYztcbiAgICB9LFxuICAgIC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZVVSSVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBxdWFsaWZpZWROYW1lXG4gICAgICogQHJldHVybnMge0F0dHJ9XG4gICAgICovXG4gICAgY3JlYXRlQXR0cmlidXRlTlM6IGZ1bmN0aW9uKHIsIHUpIHtcbiAgICAgIHZhciBzID0gbGUociwgdSksIGMgPSBuZXcgQWUobSk7XG4gICAgICByZXR1cm4gYy5vd25lckRvY3VtZW50ID0gdGhpcywgYy5jaGlsZE5vZGVzID0gbmV3IFQoKSwgYy5ub2RlTmFtZSA9IHUsIGMubmFtZSA9IHUsIGMuc3BlY2lmaWVkID0gITAsIGMubmFtZXNwYWNlVVJJID0gc1swXSwgYy5wcmVmaXggPSBzWzFdLCBjLmxvY2FsTmFtZSA9IHNbMl0sIGM7XG4gICAgfVxuICB9LCB4KHBlLCBQKTtcbiAgZnVuY3Rpb24gWihyKSB7XG4gICAgYihyKSwgdGhpcy5fbnNNYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBaLnByb3RvdHlwZSA9IHtcbiAgICBub2RlVHlwZTogRyxcbiAgICAvKipcbiAgICAgKiBUaGUgYXR0cmlidXRlcyBvZiB0aGlzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TmFtZWROb2RlTWFwIHwgbnVsbH1cbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVzOiBudWxsLFxuICAgIGdldFF1YWxpZmllZE5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZml4ID8gdGhpcy5wcmVmaXggKyBcIjpcIiArIHRoaXMubG9jYWxOYW1lIDogdGhpcy5sb2NhbE5hbWU7XG4gICAgfSxcbiAgICBfaXNJbkhUTUxEb2N1bWVudEFuZE5hbWVzcGFjZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LnR5cGUgPT09IFwiaHRtbFwiICYmIHRoaXMubmFtZXNwYWNlVVJJID09PSBmLkhUTUw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRhdG9uIG9mIExldmVsMiBDb3JlIGZ1bmN0aW9uIGhhc0F0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBUcnVlIGlmIGF0dHJpYnV0ZSBsaXN0IGlzIG5vdCBlbXB0eS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1Db3JlLyNjb3JlLUlELU5vZGVIYXNBdHRyc1xuICAgICAqL1xuICAgIGhhc0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEhKHRoaXMuYXR0cmlidXRlcyAmJiB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoKTtcbiAgICB9LFxuICAgIGhhc0F0dHJpYnV0ZTogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuICEhdGhpcy5nZXRBdHRyaWJ1dGVOb2RlKHIpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBlbGVtZW504oCZcyBmaXJzdCBhdHRyaWJ1dGUgd2hvc2UgcXVhbGlmaWVkIG5hbWUgaXMgYG5hbWVgLCBhbmQgYG51bGxgXG4gICAgICogaWYgdGhlcmUgaXMgbm8gc3VjaCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIGdldEF0dHJpYnV0ZTogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIHUgPSB0aGlzLmdldEF0dHJpYnV0ZU5vZGUocik7XG4gICAgICByZXR1cm4gdSA/IHUudmFsdWUgOiBudWxsO1xuICAgIH0sXG4gICAgZ2V0QXR0cmlidXRlTm9kZTogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzSW5IVE1MRG9jdW1lbnRBbmROYW1lc3BhY2UoKSAmJiAociA9IHIudG9Mb3dlckNhc2UoKSksIHRoaXMuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0ocik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBlbGVtZW504oCZcyBmaXJzdCBhdHRyaWJ1dGUgd2hvc2UgcXVhbGlmaWVkIG5hbWUgaXMgcXVhbGlmaWVkTmFtZSB0byB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc2V0QXR0cmlidXRlOiBmdW5jdGlvbihyLCB1KSB7XG4gICAgICB0aGlzLl9pc0luSFRNTERvY3VtZW50QW5kTmFtZXNwYWNlKCkgJiYgKHIgPSByLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgdmFyIHMgPSB0aGlzLmdldEF0dHJpYnV0ZU5vZGUocik7XG4gICAgICBzID8gcy52YWx1ZSA9IHMubm9kZVZhbHVlID0gXCJcIiArIHUgOiAocyA9IHRoaXMub3duZXJEb2N1bWVudC5fY3JlYXRlQXR0cmlidXRlKHIpLCBzLnZhbHVlID0gcy5ub2RlVmFsdWUgPSBcIlwiICsgdSwgdGhpcy5zZXRBdHRyaWJ1dGVOb2RlKHMpKTtcbiAgICB9LFxuICAgIHJlbW92ZUF0dHJpYnV0ZTogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIHUgPSB0aGlzLmdldEF0dHJpYnV0ZU5vZGUocik7XG4gICAgICB1ICYmIHRoaXMucmVtb3ZlQXR0cmlidXRlTm9kZSh1KTtcbiAgICB9LFxuICAgIHNldEF0dHJpYnV0ZU5vZGU6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuc2V0TmFtZWRJdGVtKHIpO1xuICAgIH0sXG4gICAgc2V0QXR0cmlidXRlTm9kZU5TOiBmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnNldE5hbWVkSXRlbU5TKHIpO1xuICAgIH0sXG4gICAgcmVtb3ZlQXR0cmlidXRlTm9kZTogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5yZW1vdmVOYW1lZEl0ZW0oci5ub2RlTmFtZSk7XG4gICAgfSxcbiAgICAvL2dldCByZWFsIGF0dHJpYnV0ZSBuYW1lLGFuZCByZW1vdmUgaXQgYnkgcmVtb3ZlQXR0cmlidXRlTm9kZVxuICAgIHJlbW92ZUF0dHJpYnV0ZU5TOiBmdW5jdGlvbihyLCB1KSB7XG4gICAgICB2YXIgcyA9IHRoaXMuZ2V0QXR0cmlidXRlTm9kZU5TKHIsIHUpO1xuICAgICAgcyAmJiB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5vZGUocyk7XG4gICAgfSxcbiAgICBoYXNBdHRyaWJ1dGVOUzogZnVuY3Rpb24ociwgdSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlTm9kZU5TKHIsIHUpICE9IG51bGw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGVsZW1lbnTigJlzIGF0dHJpYnV0ZSB3aG9zZSBuYW1lc3BhY2UgaXMgYG5hbWVzcGFjZVVSSWAgYW5kIGxvY2FsIG5hbWUgaXNcbiAgICAgKiBgbG9jYWxOYW1lYCxcbiAgICAgKiBvciBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gc3VjaCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlVVJJXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIGdldEF0dHJpYnV0ZU5TOiBmdW5jdGlvbihyLCB1KSB7XG4gICAgICB2YXIgcyA9IHRoaXMuZ2V0QXR0cmlidXRlTm9kZU5TKHIsIHUpO1xuICAgICAgcmV0dXJuIHMgPyBzLnZhbHVlIDogbnVsbDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIGVsZW1lbnTigJlzIGF0dHJpYnV0ZSB3aG9zZSBuYW1lc3BhY2UgaXMgYG5hbWVzcGFjZVVSSWAgYW5kIGxvY2FsIG5hbWUgaXNcbiAgICAgKiBgbG9jYWxOYW1lYCB0byB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2VVUklcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVhbGlmaWVkTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZWxlbWVudC1zZXRhdHRyaWJ1dGVuc1xuICAgICAqL1xuICAgIHNldEF0dHJpYnV0ZU5TOiBmdW5jdGlvbihyLCB1LCBzKSB7XG4gICAgICB2YXIgYyA9IGxlKHIsIHUpLCBEID0gY1syXSwgUyA9IHRoaXMuZ2V0QXR0cmlidXRlTm9kZU5TKHIsIEQpO1xuICAgICAgUyA/IFMudmFsdWUgPSBTLm5vZGVWYWx1ZSA9IFwiXCIgKyBzIDogKFMgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlTlMociwgdSksIFMudmFsdWUgPSBTLm5vZGVWYWx1ZSA9IFwiXCIgKyBzLCB0aGlzLnNldEF0dHJpYnV0ZU5vZGUoUykpO1xuICAgIH0sXG4gICAgZ2V0QXR0cmlidXRlTm9kZU5TOiBmdW5jdGlvbihyLCB1KSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbU5TKHIsIHUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIExpdmVOb2RlTGlzdCBvZiBhbGwgY2hpbGQgZWxlbWVudHMgd2hpY2ggaGF2ZSAqKmFsbCoqIG9mIHRoZSBnaXZlbiBjbGFzcyBuYW1lKHMpLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhbiBlbXB0eSBsaXN0IGlmIGBjbGFzc05hbWVzYCBpcyBhbiBlbXB0eSBzdHJpbmcgb3Igb25seSBjb250YWlucyBIVE1MIHdoaXRlIHNwYWNlXG4gICAgICogY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIFdhcm5pbmc6IFRoaXMgcmV0dXJucyBhIGxpdmUgTGl2ZU5vZGVMaXN0LlxuICAgICAqIENoYW5nZXMgaW4gdGhlIERPTSB3aWxsIHJlZmxlY3QgaW4gdGhlIGFycmF5IGFzIHRoZSBjaGFuZ2VzIG9jY3VyLlxuICAgICAqIElmIGFuIGVsZW1lbnQgc2VsZWN0ZWQgYnkgdGhpcyBhcnJheSBubyBsb25nZXIgcXVhbGlmaWVzIGZvciB0aGUgc2VsZWN0b3IsXG4gICAgICogaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHJlbW92ZWQuIEJlIGF3YXJlIG9mIHRoaXMgZm9yIGl0ZXJhdGlvbiBwdXJwb3Nlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVzXG4gICAgICogSXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjbGFzcyBuYW1lKHMpIHRvIG1hdGNoOyBtdWx0aXBsZSBjbGFzcyBuYW1lcyBhcmUgc2VwYXJhdGVkIGJ5XG4gICAgICogKEFTQ0lJLSl3aGl0ZXNwYWNlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0RWxlbWVudHNCeUNsYXNzTmFtZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2dldEVsZW1lbnRzQnlDbGFzc05hbWVcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1nZXRlbGVtZW50c2J5Y2xhc3NuYW1lXG4gICAgICovXG4gICAgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZTogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIHUgPSBrKHIpO1xuICAgICAgcmV0dXJuIG5ldyBJKHRoaXMsIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIGMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHUubGVuZ3RoID4gMCAmJiBSZShzLCBmdW5jdGlvbihEKSB7XG4gICAgICAgICAgaWYgKEQgIT09IHMgJiYgRC5ub2RlVHlwZSA9PT0gRykge1xuICAgICAgICAgICAgdmFyIFMgPSBELmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgICAgICAgICAgaWYgKFMpIHtcbiAgICAgICAgICAgICAgdmFyIFggPSByID09PSBTO1xuICAgICAgICAgICAgICBpZiAoIVgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWUgPSBrKFMpO1xuICAgICAgICAgICAgICAgIFggPSB1LmV2ZXJ5KCQoYWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBYICYmIGMucHVzaChEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBjO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgTGl2ZU5vZGVMaXN0IG9mIGVsZW1lbnRzIHdpdGggdGhlIGdpdmVuIHF1YWxpZmllZE5hbWUuXG4gICAgICogU2VhcmNoaW5nIGZvciBhbGwgZGVzY2VuZGFudHMgY2FuIGJlIGRvbmUgYnkgcGFzc2luZyBgKmAgYXMgYHF1YWxpZmllZE5hbWVgLlxuICAgICAqXG4gICAgICogQWxsIGRlc2NlbmRhbnRzIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBhcmUgc2VhcmNoZWQsIGJ1dCBub3QgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqIFRoZSByZXR1cm5lZCBsaXN0IGlzIGxpdmUsIHdoaWNoIG1lYW5zIGl0IHVwZGF0ZXMgaXRzZWxmIHdpdGggdGhlIERPTSB0cmVlIGF1dG9tYXRpY2FsbHkuXG4gICAgICogVGhlcmVmb3JlLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKWBcbiAgICAgKiB3aXRoIHRoZSBzYW1lIGVsZW1lbnQgYW5kIGFyZ3VtZW50cyByZXBlYXRlZGx5IGlmIHRoZSBET00gY2hhbmdlcyBpbiBiZXR3ZWVuIGNhbGxzLlxuICAgICAqXG4gICAgICogV2hlbiBjYWxsZWQgb24gYW4gSFRNTCBlbGVtZW50IGluIGFuIEhUTUwgZG9jdW1lbnQsXG4gICAgICogYGdldEVsZW1lbnRzQnlUYWdOYW1lYCBsb3dlci1jYXNlcyB0aGUgYXJndW1lbnQgYmVmb3JlIHNlYXJjaGluZyBmb3IgaXQuXG4gICAgICogVGhpcyBpcyB1bmRlc2lyYWJsZSB3aGVuIHRyeWluZyB0byBtYXRjaCBjYW1lbC1jYXNlZCBTVkcgZWxlbWVudHMgKHN1Y2ggYXNcbiAgICAgKiBgPGxpbmVhckdyYWRpZW50PmApIGluIGFuIEhUTUwgZG9jdW1lbnQuXG4gICAgICogSW5zdGVhZCwgdXNlIGBFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lTlMoKWAsXG4gICAgICogd2hpY2ggcHJlc2VydmVzIHRoZSBjYXBpdGFsaXphdGlvbiBvZiB0aGUgdGFnIG5hbWUuXG4gICAgICpcbiAgICAgKiBgRWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZWAgaXMgc2ltaWxhciB0byBgRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKWAsXG4gICAgICogZXhjZXB0IHRoYXQgaXQgb25seSBzZWFyY2hlcyBmb3IgZWxlbWVudHMgdGhhdCBhcmUgZGVzY2VuZGFudHMgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHF1YWxpZmllZE5hbWVcbiAgICAgKiBAcmV0dXJucyB7TGl2ZU5vZGVMaXN0fVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0RWxlbWVudHNCeVRhZ05hbWVcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1nZXRlbGVtZW50c2J5dGFnbmFtZVxuICAgICAqL1xuICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgdSA9ICh0aGlzLm5vZGVUeXBlID09PSB3ID8gdGhpcyA6IHRoaXMub3duZXJEb2N1bWVudCkudHlwZSA9PT0gXCJodG1sXCIsIHMgPSByLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gbmV3IEkodGhpcywgZnVuY3Rpb24oYykge1xuICAgICAgICB2YXIgRCA9IFtdO1xuICAgICAgICByZXR1cm4gUmUoYywgZnVuY3Rpb24oUykge1xuICAgICAgICAgIGlmICghKFMgPT09IGMgfHwgUy5ub2RlVHlwZSAhPT0gRykpXG4gICAgICAgICAgICBpZiAociA9PT0gXCIqXCIpXG4gICAgICAgICAgICAgIEQucHVzaChTKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgWCA9IFMuZ2V0UXVhbGlmaWVkTmFtZSgpLCBhZSA9IHUgJiYgUy5uYW1lc3BhY2VVUkkgPT09IGYuSFRNTCA/IHMgOiByO1xuICAgICAgICAgICAgICBYID09PSBhZSAmJiBELnB1c2goUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBEO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRFbGVtZW50c0J5VGFnTmFtZU5TOiBmdW5jdGlvbihyLCB1KSB7XG4gICAgICByZXR1cm4gbmV3IEkodGhpcywgZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgYyA9IFtdO1xuICAgICAgICByZXR1cm4gUmUocywgZnVuY3Rpb24oRCkge1xuICAgICAgICAgIEQgIT09IHMgJiYgRC5ub2RlVHlwZSA9PT0gRyAmJiAociA9PT0gXCIqXCIgfHwgRC5uYW1lc3BhY2VVUkkgPT09IHIpICYmICh1ID09PSBcIipcIiB8fCBELmxvY2FsTmFtZSA9PSB1KSAmJiBjLnB1c2goRCk7XG4gICAgICAgIH0pLCBjO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBwZS5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IFoucHJvdG90eXBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUsIHBlLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IFoucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lLCBwZS5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUyA9IFoucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lTlMsIHgoWiwgUCk7XG4gIGZ1bmN0aW9uIEFlKHIpIHtcbiAgICBiKHIpLCB0aGlzLm5hbWVzcGFjZVVSSSA9IG51bGwsIHRoaXMucHJlZml4ID0gbnVsbCwgdGhpcy5vd25lckVsZW1lbnQgPSBudWxsO1xuICB9XG4gIEFlLnByb3RvdHlwZS5ub2RlVHlwZSA9IEssIHgoQWUsIFApO1xuICBmdW5jdGlvbiBOZShyKSB7XG4gICAgYihyKTtcbiAgfVxuICBOZS5wcm90b3R5cGUgPSB7XG4gICAgZGF0YTogXCJcIixcbiAgICBzdWJzdHJpbmdEYXRhOiBmdW5jdGlvbihyLCB1KSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLnN1YnN0cmluZyhyLCByICsgdSk7XG4gICAgfSxcbiAgICBhcHBlbmREYXRhOiBmdW5jdGlvbihyKSB7XG4gICAgICByID0gdGhpcy5kYXRhICsgciwgdGhpcy5ub2RlVmFsdWUgPSB0aGlzLmRhdGEgPSByLCB0aGlzLmxlbmd0aCA9IHIubGVuZ3RoO1xuICAgIH0sXG4gICAgaW5zZXJ0RGF0YTogZnVuY3Rpb24ociwgdSkge1xuICAgICAgdGhpcy5yZXBsYWNlRGF0YShyLCAwLCB1KTtcbiAgICB9LFxuICAgIGRlbGV0ZURhdGE6IGZ1bmN0aW9uKHIsIHUpIHtcbiAgICAgIHRoaXMucmVwbGFjZURhdGEociwgdSwgXCJcIik7XG4gICAgfSxcbiAgICByZXBsYWNlRGF0YTogZnVuY3Rpb24ociwgdSwgcykge1xuICAgICAgdmFyIGMgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKDAsIHIpLCBEID0gdGhpcy5kYXRhLnN1YnN0cmluZyhyICsgdSk7XG4gICAgICBzID0gYyArIHMgKyBELCB0aGlzLm5vZGVWYWx1ZSA9IHRoaXMuZGF0YSA9IHMsIHRoaXMubGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgfVxuICB9LCB4KE5lLCBQKTtcbiAgZnVuY3Rpb24gS2Uocikge1xuICAgIGIocik7XG4gIH1cbiAgS2UucHJvdG90eXBlID0ge1xuICAgIG5vZGVOYW1lOiBcIiN0ZXh0XCIsXG4gICAgbm9kZVR5cGU6IGVlLFxuICAgIHNwbGl0VGV4dDogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIHUgPSB0aGlzLmRhdGEsIHMgPSB1LnN1YnN0cmluZyhyKTtcbiAgICAgIHUgPSB1LnN1YnN0cmluZygwLCByKSwgdGhpcy5kYXRhID0gdGhpcy5ub2RlVmFsdWUgPSB1LCB0aGlzLmxlbmd0aCA9IHUubGVuZ3RoO1xuICAgICAgdmFyIGMgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocyk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYywgdGhpcy5uZXh0U2libGluZyksIGM7XG4gICAgfVxuICB9LCB4KEtlLCBOZSk7XG4gIGZ1bmN0aW9uIHN0KHIpIHtcbiAgICBiKHIpO1xuICB9XG4gIHN0LnByb3RvdHlwZSA9IHtcbiAgICBub2RlTmFtZTogXCIjY29tbWVudFwiLFxuICAgIG5vZGVUeXBlOiBOXG4gIH0sIHgoc3QsIE5lKTtcbiAgZnVuY3Rpb24gY3Qocikge1xuICAgIGIocik7XG4gIH1cbiAgY3QucHJvdG90eXBlID0ge1xuICAgIG5vZGVOYW1lOiBcIiNjZGF0YS1zZWN0aW9uXCIsXG4gICAgbm9kZVR5cGU6IEllXG4gIH0sIHgoY3QsIEtlKTtcbiAgZnVuY3Rpb24gbHQocikge1xuICAgIGIocik7XG4gIH1cbiAgbHQucHJvdG90eXBlLm5vZGVUeXBlID0geSwgeChsdCwgUCk7XG4gIGZ1bmN0aW9uIEF0KHIpIHtcbiAgICBiKHIpO1xuICB9XG4gIEF0LnByb3RvdHlwZS5ub2RlVHlwZSA9IEEsIHgoQXQsIFApO1xuICBmdW5jdGlvbiBOdChyKSB7XG4gICAgYihyKTtcbiAgfVxuICBOdC5wcm90b3R5cGUubm9kZVR5cGUgPSBCZSwgeChOdCwgUCk7XG4gIGZ1bmN0aW9uIGZ0KHIpIHtcbiAgICBiKHIpO1xuICB9XG4gIGZ0LnByb3RvdHlwZS5ub2RlVHlwZSA9IHRlLCB4KGZ0LCBQKTtcbiAgZnVuY3Rpb24gUWUocikge1xuICAgIGIocik7XG4gIH1cbiAgUWUucHJvdG90eXBlLm5vZGVOYW1lID0gXCIjZG9jdW1lbnQtZnJhZ21lbnRcIiwgUWUucHJvdG90eXBlLm5vZGVUeXBlID0gTSwgeChRZSwgUCk7XG4gIGZ1bmN0aW9uIHB0KHIpIHtcbiAgICBiKHIpO1xuICB9XG4gIHB0LnByb3RvdHlwZS5ub2RlVHlwZSA9IGQsIHgocHQsIE5lKTtcbiAgZnVuY3Rpb24gT3QoKSB7XG4gIH1cbiAgT3QucHJvdG90eXBlLnNlcmlhbGl6ZVRvU3RyaW5nID0gZnVuY3Rpb24ociwgdSkge1xuICAgIHJldHVybiB1ZS5jYWxsKHIsIHUpO1xuICB9LCBQLnByb3RvdHlwZS50b1N0cmluZyA9IHVlO1xuICBmdW5jdGlvbiB1ZShyKSB7XG4gICAgdmFyIHUgPSBbXSwgcyA9IHRoaXMubm9kZVR5cGUgPT09IHcgJiYgdGhpcy5kb2N1bWVudEVsZW1lbnQgfHwgdGhpcywgYyA9IHMucHJlZml4LCBEID0gcy5uYW1lc3BhY2VVUkk7XG4gICAgaWYgKEQgJiYgYyA9PSBudWxsKSB7XG4gICAgICB2YXIgYyA9IHMubG9va3VwUHJlZml4KEQpO1xuICAgICAgaWYgKGMgPT0gbnVsbClcbiAgICAgICAgdmFyIFMgPSBbXG4gICAgICAgICAgeyBuYW1lc3BhY2U6IEQsIHByZWZpeDogbnVsbCB9XG4gICAgICAgICAgLy97bmFtZXNwYWNlOnVyaSxwcmVmaXg6Jyd9XG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBxZSh0aGlzLCB1LCByLCBTKSwgdS5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGhlKHIsIHUsIHMpIHtcbiAgICB2YXIgYyA9IHIucHJlZml4IHx8IFwiXCIsIEQgPSByLm5hbWVzcGFjZVVSSTtcbiAgICBpZiAoIUQgfHwgYyA9PT0gXCJ4bWxcIiAmJiBEID09PSBmLlhNTCB8fCBEID09PSBmLlhNTE5TKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAodmFyIFMgPSBzLmxlbmd0aDsgUy0tOyApIHtcbiAgICAgIHZhciBYID0gc1tTXTtcbiAgICAgIGlmIChYLnByZWZpeCA9PT0gYylcbiAgICAgICAgcmV0dXJuIFgubmFtZXNwYWNlICE9PSBEO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbiAgZnVuY3Rpb24ga2UociwgdSwgcykge1xuICAgIHIucHVzaChcIiBcIiwgdSwgJz1cIicsIHMucmVwbGFjZSgvWzw+JlwiXFx0XFxuXFxyXS9nLCAkZSksICdcIicpO1xuICB9XG4gIGZ1bmN0aW9uIHFlKHIsIHUsIHMsIGMpIHtcbiAgICBjIHx8IChjID0gW10pO1xuICAgIHZhciBEID0gci5ub2RlVHlwZSA9PT0gdyA/IHIgOiByLm93bmVyRG9jdW1lbnQsIFMgPSBELnR5cGUgPT09IFwiaHRtbFwiO1xuICAgIGlmIChzKVxuICAgICAgaWYgKHIgPSBzKHIpLCByKSB7XG4gICAgICAgIGlmICh0eXBlb2YgciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdS5wdXNoKHIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgICBzd2l0Y2ggKHIubm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgRzpcbiAgICAgICAgdmFyIFggPSByLmF0dHJpYnV0ZXMsIGFlID0gWC5sZW5ndGgsIG1lID0gci5maXJzdENoaWxkLCBkZSA9IHIudGFnTmFtZSwgeWUgPSBkZTtcbiAgICAgICAgaWYgKCFTICYmICFyLnByZWZpeCAmJiByLm5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgIGZvciAodmFyIGdlLCBaZSA9IDA7IFplIDwgWC5sZW5ndGg7IFplKyspXG4gICAgICAgICAgICBpZiAoWC5pdGVtKFplKS5uYW1lID09PSBcInhtbG5zXCIpIHtcbiAgICAgICAgICAgICAgZ2UgPSBYLml0ZW0oWmUpLnZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWdlKVxuICAgICAgICAgICAgZm9yICh2YXIgVWUgPSBjLmxlbmd0aCAtIDE7IFVlID49IDA7IFVlLS0pIHtcbiAgICAgICAgICAgICAgdmFyIE9lID0gY1tVZV07XG4gICAgICAgICAgICAgIGlmIChPZS5wcmVmaXggPT09IFwiXCIgJiYgT2UubmFtZXNwYWNlID09PSByLm5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgICAgIGdlID0gT2UubmFtZXNwYWNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdlICE9PSByLm5hbWVzcGFjZVVSSSlcbiAgICAgICAgICAgIGZvciAodmFyIFVlID0gYy5sZW5ndGggLSAxOyBVZSA+PSAwOyBVZS0tKSB7XG4gICAgICAgICAgICAgIHZhciBPZSA9IGNbVWVdO1xuICAgICAgICAgICAgICBpZiAoT2UubmFtZXNwYWNlID09PSByLm5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgICAgIE9lLnByZWZpeCAmJiAoeWUgPSBPZS5wcmVmaXggKyBcIjpcIiArIGRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHUucHVzaChcIjxcIiwgeWUpO1xuICAgICAgICBmb3IgKHZhciBldCA9IDA7IGV0IDwgYWU7IGV0KyspIHtcbiAgICAgICAgICB2YXIgUGUgPSBYLml0ZW0oZXQpO1xuICAgICAgICAgIFBlLnByZWZpeCA9PSBcInhtbG5zXCIgPyBjLnB1c2goe1xuICAgICAgICAgICAgcHJlZml4OiBQZS5sb2NhbE5hbWUsXG4gICAgICAgICAgICBuYW1lc3BhY2U6IFBlLnZhbHVlXG4gICAgICAgICAgfSkgOiBQZS5ub2RlTmFtZSA9PSBcInhtbG5zXCIgJiYgYy5wdXNoKHsgcHJlZml4OiBcIlwiLCBuYW1lc3BhY2U6IFBlLnZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGV0ID0gMDsgZXQgPCBhZTsgZXQrKykge1xuICAgICAgICAgIHZhciBQZSA9IFguaXRlbShldCk7XG4gICAgICAgICAgaWYgKGhlKFBlLCBTLCBjKSkge1xuICAgICAgICAgICAgdmFyIHR0ID0gUGUucHJlZml4IHx8IFwiXCIsIGJ0ID0gUGUubmFtZXNwYWNlVVJJO1xuICAgICAgICAgICAga2UodSwgdHQgPyBcInhtbG5zOlwiICsgdHQgOiBcInhtbG5zXCIsIGJ0KSwgYy5wdXNoKHsgcHJlZml4OiB0dCwgbmFtZXNwYWNlOiBidCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcWUoUGUsIHUsIHMsIGMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZSA9PT0geWUgJiYgaGUociwgUywgYykpIHtcbiAgICAgICAgICB2YXIgdHQgPSByLnByZWZpeCB8fCBcIlwiLCBidCA9IHIubmFtZXNwYWNlVVJJO1xuICAgICAgICAgIGtlKHUsIHR0ID8gXCJ4bWxuczpcIiArIHR0IDogXCJ4bWxuc1wiLCBidCksIGMucHVzaCh7IHByZWZpeDogdHQsIG5hbWVzcGFjZTogYnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEZ0ID0gIW1lO1xuICAgICAgICBpZiAoRnQgJiYgKFMgfHwgci5uYW1lc3BhY2VVUkkgPT09IGYuSFRNTCkgJiYgKEZ0ID0gaChkZSkpLCBGdClcbiAgICAgICAgICB1LnB1c2goXCIvPlwiKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHUucHVzaChcIj5cIiksIFMgJiYgYShkZSkpXG4gICAgICAgICAgICBmb3IgKDsgbWU7IClcbiAgICAgICAgICAgICAgbWUuZGF0YSA/IHUucHVzaChtZS5kYXRhKSA6IHFlKG1lLCB1LCBzLCBjLnNsaWNlKCkpLCBtZSA9IG1lLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAoOyBtZTsgKVxuICAgICAgICAgICAgICBxZShtZSwgdSwgcywgYy5zbGljZSgpKSwgbWUgPSBtZS5uZXh0U2libGluZztcbiAgICAgICAgICB1LnB1c2goXCI8L1wiLCB5ZSwgXCI+XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgdzpcbiAgICAgIGNhc2UgTTpcbiAgICAgICAgZm9yICh2YXIgbWUgPSByLmZpcnN0Q2hpbGQ7IG1lOyApXG4gICAgICAgICAgcWUobWUsIHUsIHMsIGMuc2xpY2UoKSksIG1lID0gbWUubmV4dFNpYmxpbmc7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgSzpcbiAgICAgICAgcmV0dXJuIGtlKHUsIHIubmFtZSwgci52YWx1ZSk7XG4gICAgICBjYXNlIGVlOlxuICAgICAgICByZXR1cm4gdS5wdXNoKHIuZGF0YS5yZXBsYWNlKC9bPCY+XS9nLCAkZSkpO1xuICAgICAgY2FzZSBJZTpcbiAgICAgICAgcmV0dXJuIHUucHVzaChPLkNEQVRBX1NUQVJULCByLmRhdGEsIE8uQ0RBVEFfRU5EKTtcbiAgICAgIGNhc2UgTjpcbiAgICAgICAgcmV0dXJuIHUucHVzaChPLkNPTU1FTlRfU1RBUlQsIHIuZGF0YSwgTy5DT01NRU5UX0VORCk7XG4gICAgICBjYXNlIHk6XG4gICAgICAgIHZhciBZdCA9IHIucHVibGljSWQsIGh0ID0gci5zeXN0ZW1JZDtcbiAgICAgICAgdS5wdXNoKE8uRE9DVFlQRV9ERUNMX1NUQVJULCBcIiBcIiwgci5uYW1lKSwgWXQgPyAodS5wdXNoKFwiIFwiLCBPLlBVQkxJQywgXCIgXCIsIFl0KSwgaHQgJiYgaHQgIT09IFwiLlwiICYmIHUucHVzaChcIiBcIiwgaHQpKSA6IGh0ICYmIGh0ICE9PSBcIi5cIiAmJiB1LnB1c2goXCIgXCIsIE8uU1lTVEVNLCBcIiBcIiwgaHQpLCByLmludGVybmFsU3Vic2V0ICYmIHUucHVzaChcIiBbXCIsIHIuaW50ZXJuYWxTdWJzZXQsIFwiXVwiKSwgdS5wdXNoKFwiPlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBkOlxuICAgICAgICByZXR1cm4gdS5wdXNoKFwiPD9cIiwgci50YXJnZXQsIFwiIFwiLCByLmRhdGEsIFwiPz5cIik7XG4gICAgICBjYXNlIHRlOlxuICAgICAgICByZXR1cm4gdS5wdXNoKFwiJlwiLCByLm5vZGVOYW1lLCBcIjtcIik7XG4gICAgICAvL2Nhc2UgRU5USVRZX05PREU6XG4gICAgICAvL2Nhc2UgTk9UQVRJT05fTk9ERTpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHUucHVzaChcIj8/XCIsIHIubm9kZU5hbWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBKdChyLCB1LCBzKSB7XG4gICAgdmFyIGM7XG4gICAgc3dpdGNoICh1Lm5vZGVUeXBlKSB7XG4gICAgICBjYXNlIEc6XG4gICAgICAgIGMgPSB1LmNsb25lTm9kZSghMSksIGMub3duZXJEb2N1bWVudCA9IHI7XG4gICAgICAvL3ZhciBhdHRycyA9IG5vZGUyLmF0dHJpYnV0ZXM7XG4gICAgICAvL3ZhciBsZW4gPSBhdHRycy5sZW5ndGg7XG4gICAgICAvL2Zvcih2YXIgaT0wO2k8bGVuO2krKyl7XG4gICAgICAvL25vZGUyLnNldEF0dHJpYnV0ZU5vZGVOUyhpbXBvcnROb2RlKGRvYyxhdHRycy5pdGVtKGkpLGRlZXApKTtcbiAgICAgIC8vfVxuICAgICAgY2FzZSBNOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSzpcbiAgICAgICAgcyA9ICEwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGMgfHwgKGMgPSB1LmNsb25lTm9kZSghMSkpLCBjLm93bmVyRG9jdW1lbnQgPSByLCBjLnBhcmVudE5vZGUgPSBudWxsLCBzKVxuICAgICAgZm9yICh2YXIgRCA9IHUuZmlyc3RDaGlsZDsgRDsgKVxuICAgICAgICBjLmFwcGVuZENoaWxkKEp0KHIsIEQsIHMpKSwgRCA9IEQubmV4dFNpYmxpbmc7XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgZnVuY3Rpb24gTHQociwgdSwgcykge1xuICAgIHZhciBjID0gbmV3IHUuY29uc3RydWN0b3IobSk7XG4gICAgZm9yICh2YXIgRCBpbiB1KVxuICAgICAgaWYgKGkodSwgRCkpIHtcbiAgICAgICAgdmFyIFMgPSB1W0RdO1xuICAgICAgICB0eXBlb2YgUyAhPSBcIm9iamVjdFwiICYmIFMgIT0gY1tEXSAmJiAoY1tEXSA9IFMpO1xuICAgICAgfVxuICAgIHN3aXRjaCAodS5jaGlsZE5vZGVzICYmIChjLmNoaWxkTm9kZXMgPSBuZXcgVCgpKSwgYy5vd25lckRvY3VtZW50ID0gciwgYy5ub2RlVHlwZSkge1xuICAgICAgY2FzZSBHOlxuICAgICAgICB2YXIgWCA9IHUuYXR0cmlidXRlcywgYWUgPSBjLmF0dHJpYnV0ZXMgPSBuZXcgVigpLCBkZSA9IFgubGVuZ3RoO1xuICAgICAgICBhZS5fb3duZXJFbGVtZW50ID0gYztcbiAgICAgICAgZm9yICh2YXIgeWUgPSAwOyB5ZSA8IGRlOyB5ZSsrKVxuICAgICAgICAgIGMuc2V0QXR0cmlidXRlTm9kZShMdChyLCBYLml0ZW0oeWUpLCAhMCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSzpcbiAgICAgICAgcyA9ICEwO1xuICAgIH1cbiAgICBpZiAocylcbiAgICAgIGZvciAodmFyIGdlID0gdS5maXJzdENoaWxkOyBnZTsgKVxuICAgICAgICBjLmFwcGVuZENoaWxkKEx0KHIsIGdlLCBzKSksIGdlID0gZ2UubmV4dFNpYmxpbmc7XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgZnVuY3Rpb24gWHQociwgdSwgcykge1xuICAgIHJbdV0gPSBzO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgbGV0IHIgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHN3aXRjaCAodS5ub2RlVHlwZSkge1xuICAgICAgICAgIGNhc2UgRzpcbiAgICAgICAgICBjYXNlIE06XG4gICAgICAgICAgICB2YXIgcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh1ID0gdS5maXJzdENoaWxkOyB1OyApXG4gICAgICAgICAgICAgIHUubm9kZVR5cGUgIT09IDcgJiYgdS5ub2RlVHlwZSAhPT0gOCAmJiBzLnB1c2gocih1KSksIHUgPSB1Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHUubm9kZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEkucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIEwodGhpcyksIHRoaXMuJCRsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoUC5wcm90b3R5cGUsIFwidGV4dENvbnRlbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiByKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRzpcbiAgICAgICAgICAgIGNhc2UgTTpcbiAgICAgICAgICAgICAgZm9yICg7IHRoaXMuZmlyc3RDaGlsZDsgKVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgKHUgfHwgU3RyaW5nKHUpKSAmJiB0aGlzLmFwcGVuZENoaWxkKHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh1KSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhpcy5kYXRhID0gdSwgdGhpcy52YWx1ZSA9IHUsIHRoaXMubm9kZVZhbHVlID0gdTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLCBYdCA9IGZ1bmN0aW9uKHUsIHMsIGMpIHtcbiAgICAgICAgdVtcIiQkXCIgKyBzXSA9IGM7XG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIHJlLl91cGRhdGVMaXZlTGlzdCA9IEwsIHJlLkF0dHIgPSBBZSwgcmUuQ0RBVEFTZWN0aW9uID0gY3QsIHJlLkNoYXJhY3RlckRhdGEgPSBOZSwgcmUuQ29tbWVudCA9IHN0LCByZS5Eb2N1bWVudCA9IHBlLCByZS5Eb2N1bWVudEZyYWdtZW50ID0gUWUsIHJlLkRvY3VtZW50VHlwZSA9IGx0LCByZS5ET01JbXBsZW1lbnRhdGlvbiA9IGllLCByZS5FbGVtZW50ID0gWiwgcmUuRW50aXR5ID0gTnQsIHJlLkVudGl0eVJlZmVyZW5jZSA9IGZ0LCByZS5MaXZlTm9kZUxpc3QgPSBJLCByZS5OYW1lZE5vZGVNYXAgPSBWLCByZS5Ob2RlID0gUCwgcmUuTm9kZUxpc3QgPSBULCByZS5Ob3RhdGlvbiA9IEF0LCByZS5UZXh0ID0gS2UsIHJlLlByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHB0LCByZS5YTUxTZXJpYWxpemVyID0gT3QsIHJlO1xufVxudmFyIHJ0ID0ge30sIGt0ID0ge30sIGlyO1xuZnVuY3Rpb24gdm4oKSB7XG4gIHJldHVybiBpciB8fCAoaXIgPSAxLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSBEdCgpLmZyZWV6ZTtcbiAgICB0LlhNTF9FTlRJVElFUyA9IGUoe1xuICAgICAgYW1wOiBcIiZcIixcbiAgICAgIGFwb3M6IFwiJ1wiLFxuICAgICAgZ3Q6IFwiPlwiLFxuICAgICAgbHQ6IFwiPFwiLFxuICAgICAgcXVvdDogJ1wiJ1xuICAgIH0pLCB0LkhUTUxfRU5USVRJRVMgPSBlKHtcbiAgICAgIEFhY3V0ZTogXCLDgVwiLFxuICAgICAgYWFjdXRlOiBcIsOhXCIsXG4gICAgICBBYnJldmU6IFwixIJcIixcbiAgICAgIGFicmV2ZTogXCLEg1wiLFxuICAgICAgYWM6IFwi4oi+XCIsXG4gICAgICBhY2Q6IFwi4oi/XCIsXG4gICAgICBhY0U6IFwi4oi+zLNcIixcbiAgICAgIEFjaXJjOiBcIsOCXCIsXG4gICAgICBhY2lyYzogXCLDolwiLFxuICAgICAgYWN1dGU6IFwiwrRcIixcbiAgICAgIEFjeTogXCLQkFwiLFxuICAgICAgYWN5OiBcItCwXCIsXG4gICAgICBBRWxpZzogXCLDhlwiLFxuICAgICAgYWVsaWc6IFwiw6ZcIixcbiAgICAgIGFmOiBcIuKBoVwiLFxuICAgICAgQWZyOiBcIvCdlIRcIixcbiAgICAgIGFmcjogXCLwnZSeXCIsXG4gICAgICBBZ3JhdmU6IFwiw4BcIixcbiAgICAgIGFncmF2ZTogXCLDoFwiLFxuICAgICAgYWxlZnN5bTogXCLihLVcIixcbiAgICAgIGFsZXBoOiBcIuKEtVwiLFxuICAgICAgQWxwaGE6IFwizpFcIixcbiAgICAgIGFscGhhOiBcIs6xXCIsXG4gICAgICBBbWFjcjogXCLEgFwiLFxuICAgICAgYW1hY3I6IFwixIFcIixcbiAgICAgIGFtYWxnOiBcIuKov1wiLFxuICAgICAgQU1QOiBcIiZcIixcbiAgICAgIGFtcDogXCImXCIsXG4gICAgICBBbmQ6IFwi4qmTXCIsXG4gICAgICBhbmQ6IFwi4oinXCIsXG4gICAgICBhbmRhbmQ6IFwi4qmVXCIsXG4gICAgICBhbmRkOiBcIuKpnFwiLFxuICAgICAgYW5kc2xvcGU6IFwi4qmYXCIsXG4gICAgICBhbmR2OiBcIuKpmlwiLFxuICAgICAgYW5nOiBcIuKIoFwiLFxuICAgICAgYW5nZTogXCLipqRcIixcbiAgICAgIGFuZ2xlOiBcIuKIoFwiLFxuICAgICAgYW5nbXNkOiBcIuKIoVwiLFxuICAgICAgYW5nbXNkYWE6IFwi4qaoXCIsXG4gICAgICBhbmdtc2RhYjogXCLipqlcIixcbiAgICAgIGFuZ21zZGFjOiBcIuKmqlwiLFxuICAgICAgYW5nbXNkYWQ6IFwi4qarXCIsXG4gICAgICBhbmdtc2RhZTogXCLipqxcIixcbiAgICAgIGFuZ21zZGFmOiBcIuKmrVwiLFxuICAgICAgYW5nbXNkYWc6IFwi4qauXCIsXG4gICAgICBhbmdtc2RhaDogXCLipq9cIixcbiAgICAgIGFuZ3J0OiBcIuKIn1wiLFxuICAgICAgYW5ncnR2YjogXCLiir5cIixcbiAgICAgIGFuZ3J0dmJkOiBcIuKmnVwiLFxuICAgICAgYW5nc3BoOiBcIuKIolwiLFxuICAgICAgYW5nc3Q6IFwiw4VcIixcbiAgICAgIGFuZ3phcnI6IFwi4o28XCIsXG4gICAgICBBb2dvbjogXCLEhFwiLFxuICAgICAgYW9nb246IFwixIVcIixcbiAgICAgIEFvcGY6IFwi8J2UuFwiLFxuICAgICAgYW9wZjogXCLwnZWSXCIsXG4gICAgICBhcDogXCLiiYhcIixcbiAgICAgIGFwYWNpcjogXCLiqa9cIixcbiAgICAgIGFwRTogXCLiqbBcIixcbiAgICAgIGFwZTogXCLiiYpcIixcbiAgICAgIGFwaWQ6IFwi4omLXCIsXG4gICAgICBhcG9zOiBcIidcIixcbiAgICAgIEFwcGx5RnVuY3Rpb246IFwi4oGhXCIsXG4gICAgICBhcHByb3g6IFwi4omIXCIsXG4gICAgICBhcHByb3hlcTogXCLiiYpcIixcbiAgICAgIEFyaW5nOiBcIsOFXCIsXG4gICAgICBhcmluZzogXCLDpVwiLFxuICAgICAgQXNjcjogXCLwnZKcXCIsXG4gICAgICBhc2NyOiBcIvCdkrZcIixcbiAgICAgIEFzc2lnbjogXCLiiZRcIixcbiAgICAgIGFzdDogXCIqXCIsXG4gICAgICBhc3ltcDogXCLiiYhcIixcbiAgICAgIGFzeW1wZXE6IFwi4omNXCIsXG4gICAgICBBdGlsZGU6IFwiw4NcIixcbiAgICAgIGF0aWxkZTogXCLDo1wiLFxuICAgICAgQXVtbDogXCLDhFwiLFxuICAgICAgYXVtbDogXCLDpFwiLFxuICAgICAgYXdjb25pbnQ6IFwi4oizXCIsXG4gICAgICBhd2ludDogXCLiqJFcIixcbiAgICAgIGJhY2tjb25nOiBcIuKJjFwiLFxuICAgICAgYmFja2Vwc2lsb246IFwiz7ZcIixcbiAgICAgIGJhY2twcmltZTogXCLigLVcIixcbiAgICAgIGJhY2tzaW06IFwi4oi9XCIsXG4gICAgICBiYWNrc2ltZXE6IFwi4ouNXCIsXG4gICAgICBCYWNrc2xhc2g6IFwi4oiWXCIsXG4gICAgICBCYXJ2OiBcIuKrp1wiLFxuICAgICAgYmFydmVlOiBcIuKKvVwiLFxuICAgICAgQmFyd2VkOiBcIuKMhlwiLFxuICAgICAgYmFyd2VkOiBcIuKMhVwiLFxuICAgICAgYmFyd2VkZ2U6IFwi4oyFXCIsXG4gICAgICBiYnJrOiBcIuKOtVwiLFxuICAgICAgYmJya3Ricms6IFwi4o62XCIsXG4gICAgICBiY29uZzogXCLiiYxcIixcbiAgICAgIEJjeTogXCLQkVwiLFxuICAgICAgYmN5OiBcItCxXCIsXG4gICAgICBiZHF1bzogXCLigJ5cIixcbiAgICAgIGJlY2F1czogXCLiiLVcIixcbiAgICAgIEJlY2F1c2U6IFwi4oi1XCIsXG4gICAgICBiZWNhdXNlOiBcIuKItVwiLFxuICAgICAgYmVtcHR5djogXCLiprBcIixcbiAgICAgIGJlcHNpOiBcIs+2XCIsXG4gICAgICBiZXJub3U6IFwi4oSsXCIsXG4gICAgICBCZXJub3VsbGlzOiBcIuKErFwiLFxuICAgICAgQmV0YTogXCLOklwiLFxuICAgICAgYmV0YTogXCLOslwiLFxuICAgICAgYmV0aDogXCLihLZcIixcbiAgICAgIGJldHdlZW46IFwi4omsXCIsXG4gICAgICBCZnI6IFwi8J2UhVwiLFxuICAgICAgYmZyOiBcIvCdlJ9cIixcbiAgICAgIGJpZ2NhcDogXCLii4JcIixcbiAgICAgIGJpZ2NpcmM6IFwi4pevXCIsXG4gICAgICBiaWdjdXA6IFwi4ouDXCIsXG4gICAgICBiaWdvZG90OiBcIuKogFwiLFxuICAgICAgYmlnb3BsdXM6IFwi4qiBXCIsXG4gICAgICBiaWdvdGltZXM6IFwi4qiCXCIsXG4gICAgICBiaWdzcWN1cDogXCLiqIZcIixcbiAgICAgIGJpZ3N0YXI6IFwi4piFXCIsXG4gICAgICBiaWd0cmlhbmdsZWRvd246IFwi4pa9XCIsXG4gICAgICBiaWd0cmlhbmdsZXVwOiBcIuKWs1wiLFxuICAgICAgYmlndXBsdXM6IFwi4qiEXCIsXG4gICAgICBiaWd2ZWU6IFwi4ouBXCIsXG4gICAgICBiaWd3ZWRnZTogXCLii4BcIixcbiAgICAgIGJrYXJvdzogXCLipI1cIixcbiAgICAgIGJsYWNrbG96ZW5nZTogXCLip6tcIixcbiAgICAgIGJsYWNrc3F1YXJlOiBcIuKWqlwiLFxuICAgICAgYmxhY2t0cmlhbmdsZTogXCLilrRcIixcbiAgICAgIGJsYWNrdHJpYW5nbGVkb3duOiBcIuKWvlwiLFxuICAgICAgYmxhY2t0cmlhbmdsZWxlZnQ6IFwi4peCXCIsXG4gICAgICBibGFja3RyaWFuZ2xlcmlnaHQ6IFwi4pa4XCIsXG4gICAgICBibGFuazogXCLikKNcIixcbiAgICAgIGJsazEyOiBcIuKWklwiLFxuICAgICAgYmxrMTQ6IFwi4paRXCIsXG4gICAgICBibGszNDogXCLilpNcIixcbiAgICAgIGJsb2NrOiBcIuKWiFwiLFxuICAgICAgYm5lOiBcIj3ig6VcIixcbiAgICAgIGJuZXF1aXY6IFwi4omh4oOlXCIsXG4gICAgICBiTm90OiBcIuKrrVwiLFxuICAgICAgYm5vdDogXCLijJBcIixcbiAgICAgIEJvcGY6IFwi8J2UuVwiLFxuICAgICAgYm9wZjogXCLwnZWTXCIsXG4gICAgICBib3Q6IFwi4oqlXCIsXG4gICAgICBib3R0b206IFwi4oqlXCIsXG4gICAgICBib3d0aWU6IFwi4ouIXCIsXG4gICAgICBib3hib3g6IFwi4qeJXCIsXG4gICAgICBib3hETDogXCLilZdcIixcbiAgICAgIGJveERsOiBcIuKVllwiLFxuICAgICAgYm94ZEw6IFwi4pWVXCIsXG4gICAgICBib3hkbDogXCLilJBcIixcbiAgICAgIGJveERSOiBcIuKVlFwiLFxuICAgICAgYm94RHI6IFwi4pWTXCIsXG4gICAgICBib3hkUjogXCLilZJcIixcbiAgICAgIGJveGRyOiBcIuKUjFwiLFxuICAgICAgYm94SDogXCLilZBcIixcbiAgICAgIGJveGg6IFwi4pSAXCIsXG4gICAgICBib3hIRDogXCLilaZcIixcbiAgICAgIGJveEhkOiBcIuKVpFwiLFxuICAgICAgYm94aEQ6IFwi4pWlXCIsXG4gICAgICBib3hoZDogXCLilKxcIixcbiAgICAgIGJveEhVOiBcIuKVqVwiLFxuICAgICAgYm94SHU6IFwi4pWnXCIsXG4gICAgICBib3hoVTogXCLilahcIixcbiAgICAgIGJveGh1OiBcIuKUtFwiLFxuICAgICAgYm94bWludXM6IFwi4oqfXCIsXG4gICAgICBib3hwbHVzOiBcIuKKnlwiLFxuICAgICAgYm94dGltZXM6IFwi4oqgXCIsXG4gICAgICBib3hVTDogXCLilZ1cIixcbiAgICAgIGJveFVsOiBcIuKVnFwiLFxuICAgICAgYm94dUw6IFwi4pWbXCIsXG4gICAgICBib3h1bDogXCLilJhcIixcbiAgICAgIGJveFVSOiBcIuKVmlwiLFxuICAgICAgYm94VXI6IFwi4pWZXCIsXG4gICAgICBib3h1UjogXCLilZhcIixcbiAgICAgIGJveHVyOiBcIuKUlFwiLFxuICAgICAgYm94VjogXCLilZFcIixcbiAgICAgIGJveHY6IFwi4pSCXCIsXG4gICAgICBib3hWSDogXCLilaxcIixcbiAgICAgIGJveFZoOiBcIuKVq1wiLFxuICAgICAgYm94dkg6IFwi4pWqXCIsXG4gICAgICBib3h2aDogXCLilLxcIixcbiAgICAgIGJveFZMOiBcIuKVo1wiLFxuICAgICAgYm94Vmw6IFwi4pWiXCIsXG4gICAgICBib3h2TDogXCLilaFcIixcbiAgICAgIGJveHZsOiBcIuKUpFwiLFxuICAgICAgYm94VlI6IFwi4pWgXCIsXG4gICAgICBib3hWcjogXCLilZ9cIixcbiAgICAgIGJveHZSOiBcIuKVnlwiLFxuICAgICAgYm94dnI6IFwi4pScXCIsXG4gICAgICBicHJpbWU6IFwi4oC1XCIsXG4gICAgICBCcmV2ZTogXCLLmFwiLFxuICAgICAgYnJldmU6IFwiy5hcIixcbiAgICAgIGJydmJhcjogXCLCplwiLFxuICAgICAgQnNjcjogXCLihKxcIixcbiAgICAgIGJzY3I6IFwi8J2St1wiLFxuICAgICAgYnNlbWk6IFwi4oGPXCIsXG4gICAgICBic2ltOiBcIuKIvVwiLFxuICAgICAgYnNpbWU6IFwi4ouNXCIsXG4gICAgICBic29sOiBcIlxcXFxcIixcbiAgICAgIGJzb2xiOiBcIuKnhVwiLFxuICAgICAgYnNvbGhzdWI6IFwi4p+IXCIsXG4gICAgICBidWxsOiBcIuKAolwiLFxuICAgICAgYnVsbGV0OiBcIuKAolwiLFxuICAgICAgYnVtcDogXCLiiY5cIixcbiAgICAgIGJ1bXBFOiBcIuKqrlwiLFxuICAgICAgYnVtcGU6IFwi4omPXCIsXG4gICAgICBCdW1wZXE6IFwi4omOXCIsXG4gICAgICBidW1wZXE6IFwi4omPXCIsXG4gICAgICBDYWN1dGU6IFwixIZcIixcbiAgICAgIGNhY3V0ZTogXCLEh1wiLFxuICAgICAgQ2FwOiBcIuKLklwiLFxuICAgICAgY2FwOiBcIuKIqVwiLFxuICAgICAgY2FwYW5kOiBcIuKphFwiLFxuICAgICAgY2FwYnJjdXA6IFwi4qmJXCIsXG4gICAgICBjYXBjYXA6IFwi4qmLXCIsXG4gICAgICBjYXBjdXA6IFwi4qmHXCIsXG4gICAgICBjYXBkb3Q6IFwi4qmAXCIsXG4gICAgICBDYXBpdGFsRGlmZmVyZW50aWFsRDogXCLihYVcIixcbiAgICAgIGNhcHM6IFwi4oip77iAXCIsXG4gICAgICBjYXJldDogXCLigYFcIixcbiAgICAgIGNhcm9uOiBcIsuHXCIsXG4gICAgICBDYXlsZXlzOiBcIuKErVwiLFxuICAgICAgY2NhcHM6IFwi4qmNXCIsXG4gICAgICBDY2Fyb246IFwixIxcIixcbiAgICAgIGNjYXJvbjogXCLEjVwiLFxuICAgICAgQ2NlZGlsOiBcIsOHXCIsXG4gICAgICBjY2VkaWw6IFwiw6dcIixcbiAgICAgIENjaXJjOiBcIsSIXCIsXG4gICAgICBjY2lyYzogXCLEiVwiLFxuICAgICAgQ2NvbmludDogXCLiiLBcIixcbiAgICAgIGNjdXBzOiBcIuKpjFwiLFxuICAgICAgY2N1cHNzbTogXCLiqZBcIixcbiAgICAgIENkb3Q6IFwixIpcIixcbiAgICAgIGNkb3Q6IFwixItcIixcbiAgICAgIGNlZGlsOiBcIsK4XCIsXG4gICAgICBDZWRpbGxhOiBcIsK4XCIsXG4gICAgICBjZW1wdHl2OiBcIuKmslwiLFxuICAgICAgY2VudDogXCLColwiLFxuICAgICAgQ2VudGVyRG90OiBcIsK3XCIsXG4gICAgICBjZW50ZXJkb3Q6IFwiwrdcIixcbiAgICAgIENmcjogXCLihK1cIixcbiAgICAgIGNmcjogXCLwnZSgXCIsXG4gICAgICBDSGN5OiBcItCnXCIsXG4gICAgICBjaGN5OiBcItGHXCIsXG4gICAgICBjaGVjazogXCLinJNcIixcbiAgICAgIGNoZWNrbWFyazogXCLinJNcIixcbiAgICAgIENoaTogXCLOp1wiLFxuICAgICAgY2hpOiBcIs+HXCIsXG4gICAgICBjaXI6IFwi4peLXCIsXG4gICAgICBjaXJjOiBcIsuGXCIsXG4gICAgICBjaXJjZXE6IFwi4omXXCIsXG4gICAgICBjaXJjbGVhcnJvd2xlZnQ6IFwi4oa6XCIsXG4gICAgICBjaXJjbGVhcnJvd3JpZ2h0OiBcIuKGu1wiLFxuICAgICAgY2lyY2xlZGFzdDogXCLiiptcIixcbiAgICAgIGNpcmNsZWRjaXJjOiBcIuKKmlwiLFxuICAgICAgY2lyY2xlZGRhc2g6IFwi4oqdXCIsXG4gICAgICBDaXJjbGVEb3Q6IFwi4oqZXCIsXG4gICAgICBjaXJjbGVkUjogXCLCrlwiLFxuICAgICAgY2lyY2xlZFM6IFwi4pOIXCIsXG4gICAgICBDaXJjbGVNaW51czogXCLiipZcIixcbiAgICAgIENpcmNsZVBsdXM6IFwi4oqVXCIsXG4gICAgICBDaXJjbGVUaW1lczogXCLiipdcIixcbiAgICAgIGNpckU6IFwi4qeDXCIsXG4gICAgICBjaXJlOiBcIuKJl1wiLFxuICAgICAgY2lyZm5pbnQ6IFwi4qiQXCIsXG4gICAgICBjaXJtaWQ6IFwi4quvXCIsXG4gICAgICBjaXJzY2lyOiBcIuKnglwiLFxuICAgICAgQ2xvY2t3aXNlQ29udG91ckludGVncmFsOiBcIuKIslwiLFxuICAgICAgQ2xvc2VDdXJseURvdWJsZVF1b3RlOiBcIuKAnVwiLFxuICAgICAgQ2xvc2VDdXJseVF1b3RlOiBcIuKAmVwiLFxuICAgICAgY2x1YnM6IFwi4pmjXCIsXG4gICAgICBjbHVic3VpdDogXCLimaNcIixcbiAgICAgIENvbG9uOiBcIuKIt1wiLFxuICAgICAgY29sb246IFwiOlwiLFxuICAgICAgQ29sb25lOiBcIuKptFwiLFxuICAgICAgY29sb25lOiBcIuKJlFwiLFxuICAgICAgY29sb25lcTogXCLiiZRcIixcbiAgICAgIGNvbW1hOiBcIixcIixcbiAgICAgIGNvbW1hdDogXCJAXCIsXG4gICAgICBjb21wOiBcIuKIgVwiLFxuICAgICAgY29tcGZuOiBcIuKImFwiLFxuICAgICAgY29tcGxlbWVudDogXCLiiIFcIixcbiAgICAgIGNvbXBsZXhlczogXCLihIJcIixcbiAgICAgIGNvbmc6IFwi4omFXCIsXG4gICAgICBjb25nZG90OiBcIuKprVwiLFxuICAgICAgQ29uZ3J1ZW50OiBcIuKJoVwiLFxuICAgICAgQ29uaW50OiBcIuKIr1wiLFxuICAgICAgY29uaW50OiBcIuKIrlwiLFxuICAgICAgQ29udG91ckludGVncmFsOiBcIuKIrlwiLFxuICAgICAgQ29wZjogXCLihIJcIixcbiAgICAgIGNvcGY6IFwi8J2VlFwiLFxuICAgICAgY29wcm9kOiBcIuKIkFwiLFxuICAgICAgQ29wcm9kdWN0OiBcIuKIkFwiLFxuICAgICAgQ09QWTogXCLCqVwiLFxuICAgICAgY29weTogXCLCqVwiLFxuICAgICAgY29weXNyOiBcIuKEl1wiLFxuICAgICAgQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDogXCLiiLNcIixcbiAgICAgIGNyYXJyOiBcIuKGtVwiLFxuICAgICAgQ3Jvc3M6IFwi4qivXCIsXG4gICAgICBjcm9zczogXCLinJdcIixcbiAgICAgIENzY3I6IFwi8J2SnlwiLFxuICAgICAgY3NjcjogXCLwnZK4XCIsXG4gICAgICBjc3ViOiBcIuKrj1wiLFxuICAgICAgY3N1YmU6IFwi4quRXCIsXG4gICAgICBjc3VwOiBcIuKrkFwiLFxuICAgICAgY3N1cGU6IFwi4quSXCIsXG4gICAgICBjdGRvdDogXCLii69cIixcbiAgICAgIGN1ZGFycmw6IFwi4qS4XCIsXG4gICAgICBjdWRhcnJyOiBcIuKktVwiLFxuICAgICAgY3VlcHI6IFwi4oueXCIsXG4gICAgICBjdWVzYzogXCLii59cIixcbiAgICAgIGN1bGFycjogXCLihrZcIixcbiAgICAgIGN1bGFycnA6IFwi4qS9XCIsXG4gICAgICBDdXA6IFwi4ouTXCIsXG4gICAgICBjdXA6IFwi4oiqXCIsXG4gICAgICBjdXBicmNhcDogXCLiqYhcIixcbiAgICAgIEN1cENhcDogXCLiiY1cIixcbiAgICAgIGN1cGNhcDogXCLiqYZcIixcbiAgICAgIGN1cGN1cDogXCLiqYpcIixcbiAgICAgIGN1cGRvdDogXCLiio1cIixcbiAgICAgIGN1cG9yOiBcIuKphVwiLFxuICAgICAgY3VwczogXCLiiKrvuIBcIixcbiAgICAgIGN1cmFycjogXCLihrdcIixcbiAgICAgIGN1cmFycm06IFwi4qS8XCIsXG4gICAgICBjdXJseWVxcHJlYzogXCLii55cIixcbiAgICAgIGN1cmx5ZXFzdWNjOiBcIuKLn1wiLFxuICAgICAgY3VybHl2ZWU6IFwi4ouOXCIsXG4gICAgICBjdXJseXdlZGdlOiBcIuKLj1wiLFxuICAgICAgY3VycmVuOiBcIsKkXCIsXG4gICAgICBjdXJ2ZWFycm93bGVmdDogXCLihrZcIixcbiAgICAgIGN1cnZlYXJyb3dyaWdodDogXCLihrdcIixcbiAgICAgIGN1dmVlOiBcIuKLjlwiLFxuICAgICAgY3V3ZWQ6IFwi4ouPXCIsXG4gICAgICBjd2NvbmludDogXCLiiLJcIixcbiAgICAgIGN3aW50OiBcIuKIsVwiLFxuICAgICAgY3lsY3R5OiBcIuKMrVwiLFxuICAgICAgRGFnZ2VyOiBcIuKAoVwiLFxuICAgICAgZGFnZ2VyOiBcIuKAoFwiLFxuICAgICAgZGFsZXRoOiBcIuKEuFwiLFxuICAgICAgRGFycjogXCLihqFcIixcbiAgICAgIGRBcnI6IFwi4oeTXCIsXG4gICAgICBkYXJyOiBcIuKGk1wiLFxuICAgICAgZGFzaDogXCLigJBcIixcbiAgICAgIERhc2h2OiBcIuKrpFwiLFxuICAgICAgZGFzaHY6IFwi4oqjXCIsXG4gICAgICBkYmthcm93OiBcIuKkj1wiLFxuICAgICAgZGJsYWM6IFwiy51cIixcbiAgICAgIERjYXJvbjogXCLEjlwiLFxuICAgICAgZGNhcm9uOiBcIsSPXCIsXG4gICAgICBEY3k6IFwi0JRcIixcbiAgICAgIGRjeTogXCLQtFwiLFxuICAgICAgREQ6IFwi4oWFXCIsXG4gICAgICBkZDogXCLihYZcIixcbiAgICAgIGRkYWdnZXI6IFwi4oChXCIsXG4gICAgICBkZGFycjogXCLih4pcIixcbiAgICAgIEREb3RyYWhkOiBcIuKkkVwiLFxuICAgICAgZGRvdHNlcTogXCLiqbdcIixcbiAgICAgIGRlZzogXCLCsFwiLFxuICAgICAgRGVsOiBcIuKIh1wiLFxuICAgICAgRGVsdGE6IFwizpRcIixcbiAgICAgIGRlbHRhOiBcIs60XCIsXG4gICAgICBkZW1wdHl2OiBcIuKmsVwiLFxuICAgICAgZGZpc2h0OiBcIuKlv1wiLFxuICAgICAgRGZyOiBcIvCdlIdcIixcbiAgICAgIGRmcjogXCLwnZShXCIsXG4gICAgICBkSGFyOiBcIuKlpVwiLFxuICAgICAgZGhhcmw6IFwi4oeDXCIsXG4gICAgICBkaGFycjogXCLih4JcIixcbiAgICAgIERpYWNyaXRpY2FsQWN1dGU6IFwiwrRcIixcbiAgICAgIERpYWNyaXRpY2FsRG90OiBcIsuZXCIsXG4gICAgICBEaWFjcml0aWNhbERvdWJsZUFjdXRlOiBcIsudXCIsXG4gICAgICBEaWFjcml0aWNhbEdyYXZlOiBcImBcIixcbiAgICAgIERpYWNyaXRpY2FsVGlsZGU6IFwiy5xcIixcbiAgICAgIGRpYW06IFwi4ouEXCIsXG4gICAgICBEaWFtb25kOiBcIuKLhFwiLFxuICAgICAgZGlhbW9uZDogXCLii4RcIixcbiAgICAgIGRpYW1vbmRzdWl0OiBcIuKZplwiLFxuICAgICAgZGlhbXM6IFwi4pmmXCIsXG4gICAgICBkaWU6IFwiwqhcIixcbiAgICAgIERpZmZlcmVudGlhbEQ6IFwi4oWGXCIsXG4gICAgICBkaWdhbW1hOiBcIs+dXCIsXG4gICAgICBkaXNpbjogXCLii7JcIixcbiAgICAgIGRpdjogXCLDt1wiLFxuICAgICAgZGl2aWRlOiBcIsO3XCIsXG4gICAgICBkaXZpZGVvbnRpbWVzOiBcIuKLh1wiLFxuICAgICAgZGl2b254OiBcIuKLh1wiLFxuICAgICAgREpjeTogXCLQglwiLFxuICAgICAgZGpjeTogXCLRklwiLFxuICAgICAgZGxjb3JuOiBcIuKMnlwiLFxuICAgICAgZGxjcm9wOiBcIuKMjVwiLFxuICAgICAgZG9sbGFyOiBcIiRcIixcbiAgICAgIERvcGY6IFwi8J2Uu1wiLFxuICAgICAgZG9wZjogXCLwnZWVXCIsXG4gICAgICBEb3Q6IFwiwqhcIixcbiAgICAgIGRvdDogXCLLmVwiLFxuICAgICAgRG90RG90OiBcIuKDnFwiLFxuICAgICAgZG90ZXE6IFwi4omQXCIsXG4gICAgICBkb3RlcWRvdDogXCLiiZFcIixcbiAgICAgIERvdEVxdWFsOiBcIuKJkFwiLFxuICAgICAgZG90bWludXM6IFwi4oi4XCIsXG4gICAgICBkb3RwbHVzOiBcIuKIlFwiLFxuICAgICAgZG90c3F1YXJlOiBcIuKKoVwiLFxuICAgICAgZG91YmxlYmFyd2VkZ2U6IFwi4oyGXCIsXG4gICAgICBEb3VibGVDb250b3VySW50ZWdyYWw6IFwi4oivXCIsXG4gICAgICBEb3VibGVEb3Q6IFwiwqhcIixcbiAgICAgIERvdWJsZURvd25BcnJvdzogXCLih5NcIixcbiAgICAgIERvdWJsZUxlZnRBcnJvdzogXCLih5BcIixcbiAgICAgIERvdWJsZUxlZnRSaWdodEFycm93OiBcIuKHlFwiLFxuICAgICAgRG91YmxlTGVmdFRlZTogXCLiq6RcIixcbiAgICAgIERvdWJsZUxvbmdMZWZ0QXJyb3c6IFwi4p+4XCIsXG4gICAgICBEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3c6IFwi4p+6XCIsXG4gICAgICBEb3VibGVMb25nUmlnaHRBcnJvdzogXCLin7lcIixcbiAgICAgIERvdWJsZVJpZ2h0QXJyb3c6IFwi4oeSXCIsXG4gICAgICBEb3VibGVSaWdodFRlZTogXCLiiqhcIixcbiAgICAgIERvdWJsZVVwQXJyb3c6IFwi4oeRXCIsXG4gICAgICBEb3VibGVVcERvd25BcnJvdzogXCLih5VcIixcbiAgICAgIERvdWJsZVZlcnRpY2FsQmFyOiBcIuKIpVwiLFxuICAgICAgRG93bkFycm93OiBcIuKGk1wiLFxuICAgICAgRG93bmFycm93OiBcIuKHk1wiLFxuICAgICAgZG93bmFycm93OiBcIuKGk1wiLFxuICAgICAgRG93bkFycm93QmFyOiBcIuKkk1wiLFxuICAgICAgRG93bkFycm93VXBBcnJvdzogXCLih7VcIixcbiAgICAgIERvd25CcmV2ZTogXCLMkVwiLFxuICAgICAgZG93bmRvd25hcnJvd3M6IFwi4oeKXCIsXG4gICAgICBkb3duaGFycG9vbmxlZnQ6IFwi4oeDXCIsXG4gICAgICBkb3duaGFycG9vbnJpZ2h0OiBcIuKHglwiLFxuICAgICAgRG93bkxlZnRSaWdodFZlY3RvcjogXCLipZBcIixcbiAgICAgIERvd25MZWZ0VGVlVmVjdG9yOiBcIuKlnlwiLFxuICAgICAgRG93bkxlZnRWZWN0b3I6IFwi4oa9XCIsXG4gICAgICBEb3duTGVmdFZlY3RvckJhcjogXCLipZZcIixcbiAgICAgIERvd25SaWdodFRlZVZlY3RvcjogXCLipZ9cIixcbiAgICAgIERvd25SaWdodFZlY3RvcjogXCLih4FcIixcbiAgICAgIERvd25SaWdodFZlY3RvckJhcjogXCLipZdcIixcbiAgICAgIERvd25UZWU6IFwi4oqkXCIsXG4gICAgICBEb3duVGVlQXJyb3c6IFwi4oanXCIsXG4gICAgICBkcmJrYXJvdzogXCLipJBcIixcbiAgICAgIGRyY29ybjogXCLijJ9cIixcbiAgICAgIGRyY3JvcDogXCLijIxcIixcbiAgICAgIERzY3I6IFwi8J2Sn1wiLFxuICAgICAgZHNjcjogXCLwnZK5XCIsXG4gICAgICBEU2N5OiBcItCFXCIsXG4gICAgICBkc2N5OiBcItGVXCIsXG4gICAgICBkc29sOiBcIuKntlwiLFxuICAgICAgRHN0cm9rOiBcIsSQXCIsXG4gICAgICBkc3Ryb2s6IFwixJFcIixcbiAgICAgIGR0ZG90OiBcIuKLsVwiLFxuICAgICAgZHRyaTogXCLilr9cIixcbiAgICAgIGR0cmlmOiBcIuKWvlwiLFxuICAgICAgZHVhcnI6IFwi4oe1XCIsXG4gICAgICBkdWhhcjogXCLipa9cIixcbiAgICAgIGR3YW5nbGU6IFwi4qamXCIsXG4gICAgICBEWmN5OiBcItCPXCIsXG4gICAgICBkemN5OiBcItGfXCIsXG4gICAgICBkemlncmFycjogXCLin79cIixcbiAgICAgIEVhY3V0ZTogXCLDiVwiLFxuICAgICAgZWFjdXRlOiBcIsOpXCIsXG4gICAgICBlYXN0ZXI6IFwi4qmuXCIsXG4gICAgICBFY2Fyb246IFwixJpcIixcbiAgICAgIGVjYXJvbjogXCLEm1wiLFxuICAgICAgZWNpcjogXCLiiZZcIixcbiAgICAgIEVjaXJjOiBcIsOKXCIsXG4gICAgICBlY2lyYzogXCLDqlwiLFxuICAgICAgZWNvbG9uOiBcIuKJlVwiLFxuICAgICAgRWN5OiBcItCtXCIsXG4gICAgICBlY3k6IFwi0Y1cIixcbiAgICAgIGVERG90OiBcIuKpt1wiLFxuICAgICAgRWRvdDogXCLEllwiLFxuICAgICAgZURvdDogXCLiiZFcIixcbiAgICAgIGVkb3Q6IFwixJdcIixcbiAgICAgIGVlOiBcIuKFh1wiLFxuICAgICAgZWZEb3Q6IFwi4omSXCIsXG4gICAgICBFZnI6IFwi8J2UiFwiLFxuICAgICAgZWZyOiBcIvCdlKJcIixcbiAgICAgIGVnOiBcIuKqmlwiLFxuICAgICAgRWdyYXZlOiBcIsOIXCIsXG4gICAgICBlZ3JhdmU6IFwiw6hcIixcbiAgICAgIGVnczogXCLiqpZcIixcbiAgICAgIGVnc2RvdDogXCLiqphcIixcbiAgICAgIGVsOiBcIuKqmVwiLFxuICAgICAgRWxlbWVudDogXCLiiIhcIixcbiAgICAgIGVsaW50ZXJzOiBcIuKPp1wiLFxuICAgICAgZWxsOiBcIuKEk1wiLFxuICAgICAgZWxzOiBcIuKqlVwiLFxuICAgICAgZWxzZG90OiBcIuKql1wiLFxuICAgICAgRW1hY3I6IFwixJJcIixcbiAgICAgIGVtYWNyOiBcIsSTXCIsXG4gICAgICBlbXB0eTogXCLiiIVcIixcbiAgICAgIGVtcHR5c2V0OiBcIuKIhVwiLFxuICAgICAgRW1wdHlTbWFsbFNxdWFyZTogXCLil7tcIixcbiAgICAgIGVtcHR5djogXCLiiIVcIixcbiAgICAgIEVtcHR5VmVyeVNtYWxsU3F1YXJlOiBcIuKWq1wiLFxuICAgICAgZW1zcDogXCLigINcIixcbiAgICAgIGVtc3AxMzogXCLigIRcIixcbiAgICAgIGVtc3AxNDogXCLigIVcIixcbiAgICAgIEVORzogXCLFilwiLFxuICAgICAgZW5nOiBcIsWLXCIsXG4gICAgICBlbnNwOiBcIuKAglwiLFxuICAgICAgRW9nb246IFwixJhcIixcbiAgICAgIGVvZ29uOiBcIsSZXCIsXG4gICAgICBFb3BmOiBcIvCdlLxcIixcbiAgICAgIGVvcGY6IFwi8J2VllwiLFxuICAgICAgZXBhcjogXCLii5VcIixcbiAgICAgIGVwYXJzbDogXCLip6NcIixcbiAgICAgIGVwbHVzOiBcIuKpsVwiLFxuICAgICAgZXBzaTogXCLOtVwiLFxuICAgICAgRXBzaWxvbjogXCLOlVwiLFxuICAgICAgZXBzaWxvbjogXCLOtVwiLFxuICAgICAgZXBzaXY6IFwiz7VcIixcbiAgICAgIGVxY2lyYzogXCLiiZZcIixcbiAgICAgIGVxY29sb246IFwi4omVXCIsXG4gICAgICBlcXNpbTogXCLiiYJcIixcbiAgICAgIGVxc2xhbnRndHI6IFwi4qqWXCIsXG4gICAgICBlcXNsYW50bGVzczogXCLiqpVcIixcbiAgICAgIEVxdWFsOiBcIuKptVwiLFxuICAgICAgZXF1YWxzOiBcIj1cIixcbiAgICAgIEVxdWFsVGlsZGU6IFwi4omCXCIsXG4gICAgICBlcXVlc3Q6IFwi4omfXCIsXG4gICAgICBFcXVpbGlicml1bTogXCLih4xcIixcbiAgICAgIGVxdWl2OiBcIuKJoVwiLFxuICAgICAgZXF1aXZERDogXCLiqbhcIixcbiAgICAgIGVxdnBhcnNsOiBcIuKnpVwiLFxuICAgICAgZXJhcnI6IFwi4qWxXCIsXG4gICAgICBlckRvdDogXCLiiZNcIixcbiAgICAgIEVzY3I6IFwi4oSwXCIsXG4gICAgICBlc2NyOiBcIuKEr1wiLFxuICAgICAgZXNkb3Q6IFwi4omQXCIsXG4gICAgICBFc2ltOiBcIuKps1wiLFxuICAgICAgZXNpbTogXCLiiYJcIixcbiAgICAgIEV0YTogXCLOl1wiLFxuICAgICAgZXRhOiBcIs63XCIsXG4gICAgICBFVEg6IFwiw5BcIixcbiAgICAgIGV0aDogXCLDsFwiLFxuICAgICAgRXVtbDogXCLDi1wiLFxuICAgICAgZXVtbDogXCLDq1wiLFxuICAgICAgZXVybzogXCLigqxcIixcbiAgICAgIGV4Y2w6IFwiIVwiLFxuICAgICAgZXhpc3Q6IFwi4oiDXCIsXG4gICAgICBFeGlzdHM6IFwi4oiDXCIsXG4gICAgICBleHBlY3RhdGlvbjogXCLihLBcIixcbiAgICAgIEV4cG9uZW50aWFsRTogXCLihYdcIixcbiAgICAgIGV4cG9uZW50aWFsZTogXCLihYdcIixcbiAgICAgIGZhbGxpbmdkb3RzZXE6IFwi4omSXCIsXG4gICAgICBGY3k6IFwi0KRcIixcbiAgICAgIGZjeTogXCLRhFwiLFxuICAgICAgZmVtYWxlOiBcIuKZgFwiLFxuICAgICAgZmZpbGlnOiBcIu+sg1wiLFxuICAgICAgZmZsaWc6IFwi76yAXCIsXG4gICAgICBmZmxsaWc6IFwi76yEXCIsXG4gICAgICBGZnI6IFwi8J2UiVwiLFxuICAgICAgZmZyOiBcIvCdlKNcIixcbiAgICAgIGZpbGlnOiBcIu+sgVwiLFxuICAgICAgRmlsbGVkU21hbGxTcXVhcmU6IFwi4pe8XCIsXG4gICAgICBGaWxsZWRWZXJ5U21hbGxTcXVhcmU6IFwi4paqXCIsXG4gICAgICBmamxpZzogXCJmalwiLFxuICAgICAgZmxhdDogXCLima1cIixcbiAgICAgIGZsbGlnOiBcIu+sglwiLFxuICAgICAgZmx0bnM6IFwi4paxXCIsXG4gICAgICBmbm9mOiBcIsaSXCIsXG4gICAgICBGb3BmOiBcIvCdlL1cIixcbiAgICAgIGZvcGY6IFwi8J2Vl1wiLFxuICAgICAgRm9yQWxsOiBcIuKIgFwiLFxuICAgICAgZm9yYWxsOiBcIuKIgFwiLFxuICAgICAgZm9yazogXCLii5RcIixcbiAgICAgIGZvcmt2OiBcIuKrmVwiLFxuICAgICAgRm91cmllcnRyZjogXCLihLFcIixcbiAgICAgIGZwYXJ0aW50OiBcIuKojVwiLFxuICAgICAgZnJhYzEyOiBcIsK9XCIsXG4gICAgICBmcmFjMTM6IFwi4oWTXCIsXG4gICAgICBmcmFjMTQ6IFwiwrxcIixcbiAgICAgIGZyYWMxNTogXCLihZVcIixcbiAgICAgIGZyYWMxNjogXCLihZlcIixcbiAgICAgIGZyYWMxODogXCLihZtcIixcbiAgICAgIGZyYWMyMzogXCLihZRcIixcbiAgICAgIGZyYWMyNTogXCLihZZcIixcbiAgICAgIGZyYWMzNDogXCLCvlwiLFxuICAgICAgZnJhYzM1OiBcIuKFl1wiLFxuICAgICAgZnJhYzM4OiBcIuKFnFwiLFxuICAgICAgZnJhYzQ1OiBcIuKFmFwiLFxuICAgICAgZnJhYzU2OiBcIuKFmlwiLFxuICAgICAgZnJhYzU4OiBcIuKFnVwiLFxuICAgICAgZnJhYzc4OiBcIuKFnlwiLFxuICAgICAgZnJhc2w6IFwi4oGEXCIsXG4gICAgICBmcm93bjogXCLijKJcIixcbiAgICAgIEZzY3I6IFwi4oSxXCIsXG4gICAgICBmc2NyOiBcIvCdkrtcIixcbiAgICAgIGdhY3V0ZTogXCLHtVwiLFxuICAgICAgR2FtbWE6IFwizpNcIixcbiAgICAgIGdhbW1hOiBcIs6zXCIsXG4gICAgICBHYW1tYWQ6IFwiz5xcIixcbiAgICAgIGdhbW1hZDogXCLPnVwiLFxuICAgICAgZ2FwOiBcIuKqhlwiLFxuICAgICAgR2JyZXZlOiBcIsSeXCIsXG4gICAgICBnYnJldmU6IFwixJ9cIixcbiAgICAgIEdjZWRpbDogXCLEolwiLFxuICAgICAgR2NpcmM6IFwixJxcIixcbiAgICAgIGdjaXJjOiBcIsSdXCIsXG4gICAgICBHY3k6IFwi0JNcIixcbiAgICAgIGdjeTogXCLQs1wiLFxuICAgICAgR2RvdDogXCLEoFwiLFxuICAgICAgZ2RvdDogXCLEoVwiLFxuICAgICAgZ0U6IFwi4omnXCIsXG4gICAgICBnZTogXCLiiaVcIixcbiAgICAgIGdFbDogXCLiqoxcIixcbiAgICAgIGdlbDogXCLii5tcIixcbiAgICAgIGdlcTogXCLiiaVcIixcbiAgICAgIGdlcXE6IFwi4omnXCIsXG4gICAgICBnZXFzbGFudDogXCLiqb5cIixcbiAgICAgIGdlczogXCLiqb5cIixcbiAgICAgIGdlc2NjOiBcIuKqqVwiLFxuICAgICAgZ2VzZG90OiBcIuKqgFwiLFxuICAgICAgZ2VzZG90bzogXCLiqoJcIixcbiAgICAgIGdlc2RvdG9sOiBcIuKqhFwiLFxuICAgICAgZ2VzbDogXCLii5vvuIBcIixcbiAgICAgIGdlc2xlczogXCLiqpRcIixcbiAgICAgIEdmcjogXCLwnZSKXCIsXG4gICAgICBnZnI6IFwi8J2UpFwiLFxuICAgICAgR2c6IFwi4ouZXCIsXG4gICAgICBnZzogXCLiiatcIixcbiAgICAgIGdnZzogXCLii5lcIixcbiAgICAgIGdpbWVsOiBcIuKEt1wiLFxuICAgICAgR0pjeTogXCLQg1wiLFxuICAgICAgZ2pjeTogXCLRk1wiLFxuICAgICAgZ2w6IFwi4om3XCIsXG4gICAgICBnbGE6IFwi4qqlXCIsXG4gICAgICBnbEU6IFwi4qqSXCIsXG4gICAgICBnbGo6IFwi4qqkXCIsXG4gICAgICBnbmFwOiBcIuKqilwiLFxuICAgICAgZ25hcHByb3g6IFwi4qqKXCIsXG4gICAgICBnbkU6IFwi4ompXCIsXG4gICAgICBnbmU6IFwi4qqIXCIsXG4gICAgICBnbmVxOiBcIuKqiFwiLFxuICAgICAgZ25lcXE6IFwi4ompXCIsXG4gICAgICBnbnNpbTogXCLii6dcIixcbiAgICAgIEdvcGY6IFwi8J2UvlwiLFxuICAgICAgZ29wZjogXCLwnZWYXCIsXG4gICAgICBncmF2ZTogXCJgXCIsXG4gICAgICBHcmVhdGVyRXF1YWw6IFwi4omlXCIsXG4gICAgICBHcmVhdGVyRXF1YWxMZXNzOiBcIuKLm1wiLFxuICAgICAgR3JlYXRlckZ1bGxFcXVhbDogXCLiiadcIixcbiAgICAgIEdyZWF0ZXJHcmVhdGVyOiBcIuKqolwiLFxuICAgICAgR3JlYXRlckxlc3M6IFwi4om3XCIsXG4gICAgICBHcmVhdGVyU2xhbnRFcXVhbDogXCLiqb5cIixcbiAgICAgIEdyZWF0ZXJUaWxkZTogXCLiibNcIixcbiAgICAgIEdzY3I6IFwi8J2SolwiLFxuICAgICAgZ3NjcjogXCLihIpcIixcbiAgICAgIGdzaW06IFwi4omzXCIsXG4gICAgICBnc2ltZTogXCLiqo5cIixcbiAgICAgIGdzaW1sOiBcIuKqkFwiLFxuICAgICAgR3Q6IFwi4omrXCIsXG4gICAgICBHVDogXCI+XCIsXG4gICAgICBndDogXCI+XCIsXG4gICAgICBndGNjOiBcIuKqp1wiLFxuICAgICAgZ3RjaXI6IFwi4qm6XCIsXG4gICAgICBndGRvdDogXCLii5dcIixcbiAgICAgIGd0bFBhcjogXCLippVcIixcbiAgICAgIGd0cXVlc3Q6IFwi4qm8XCIsXG4gICAgICBndHJhcHByb3g6IFwi4qqGXCIsXG4gICAgICBndHJhcnI6IFwi4qW4XCIsXG4gICAgICBndHJkb3Q6IFwi4ouXXCIsXG4gICAgICBndHJlcWxlc3M6IFwi4oubXCIsXG4gICAgICBndHJlcXFsZXNzOiBcIuKqjFwiLFxuICAgICAgZ3RybGVzczogXCLiibdcIixcbiAgICAgIGd0cnNpbTogXCLiibNcIixcbiAgICAgIGd2ZXJ0bmVxcTogXCLiianvuIBcIixcbiAgICAgIGd2bkU6IFwi4omp77iAXCIsXG4gICAgICBIYWNlazogXCLLh1wiLFxuICAgICAgaGFpcnNwOiBcIuKAilwiLFxuICAgICAgaGFsZjogXCLCvVwiLFxuICAgICAgaGFtaWx0OiBcIuKEi1wiLFxuICAgICAgSEFSRGN5OiBcItCqXCIsXG4gICAgICBoYXJkY3k6IFwi0YpcIixcbiAgICAgIGhBcnI6IFwi4oeUXCIsXG4gICAgICBoYXJyOiBcIuKGlFwiLFxuICAgICAgaGFycmNpcjogXCLipYhcIixcbiAgICAgIGhhcnJ3OiBcIuKGrVwiLFxuICAgICAgSGF0OiBcIl5cIixcbiAgICAgIGhiYXI6IFwi4oSPXCIsXG4gICAgICBIY2lyYzogXCLEpFwiLFxuICAgICAgaGNpcmM6IFwixKVcIixcbiAgICAgIGhlYXJ0czogXCLimaVcIixcbiAgICAgIGhlYXJ0c3VpdDogXCLimaVcIixcbiAgICAgIGhlbGxpcDogXCLigKZcIixcbiAgICAgIGhlcmNvbjogXCLiirlcIixcbiAgICAgIEhmcjogXCLihIxcIixcbiAgICAgIGhmcjogXCLwnZSlXCIsXG4gICAgICBIaWxiZXJ0U3BhY2U6IFwi4oSLXCIsXG4gICAgICBoa3NlYXJvdzogXCLipKVcIixcbiAgICAgIGhrc3dhcm93OiBcIuKkplwiLFxuICAgICAgaG9hcnI6IFwi4oe/XCIsXG4gICAgICBob210aHQ6IFwi4oi7XCIsXG4gICAgICBob29rbGVmdGFycm93OiBcIuKGqVwiLFxuICAgICAgaG9va3JpZ2h0YXJyb3c6IFwi4oaqXCIsXG4gICAgICBIb3BmOiBcIuKEjVwiLFxuICAgICAgaG9wZjogXCLwnZWZXCIsXG4gICAgICBob3JiYXI6IFwi4oCVXCIsXG4gICAgICBIb3Jpem9udGFsTGluZTogXCLilIBcIixcbiAgICAgIEhzY3I6IFwi4oSLXCIsXG4gICAgICBoc2NyOiBcIvCdkr1cIixcbiAgICAgIGhzbGFzaDogXCLihI9cIixcbiAgICAgIEhzdHJvazogXCLEplwiLFxuICAgICAgaHN0cm9rOiBcIsSnXCIsXG4gICAgICBIdW1wRG93bkh1bXA6IFwi4omOXCIsXG4gICAgICBIdW1wRXF1YWw6IFwi4omPXCIsXG4gICAgICBoeWJ1bGw6IFwi4oGDXCIsXG4gICAgICBoeXBoZW46IFwi4oCQXCIsXG4gICAgICBJYWN1dGU6IFwiw41cIixcbiAgICAgIGlhY3V0ZTogXCLDrVwiLFxuICAgICAgaWM6IFwi4oGjXCIsXG4gICAgICBJY2lyYzogXCLDjlwiLFxuICAgICAgaWNpcmM6IFwiw65cIixcbiAgICAgIEljeTogXCLQmFwiLFxuICAgICAgaWN5OiBcItC4XCIsXG4gICAgICBJZG90OiBcIsSwXCIsXG4gICAgICBJRWN5OiBcItCVXCIsXG4gICAgICBpZWN5OiBcItC1XCIsXG4gICAgICBpZXhjbDogXCLCoVwiLFxuICAgICAgaWZmOiBcIuKHlFwiLFxuICAgICAgSWZyOiBcIuKEkVwiLFxuICAgICAgaWZyOiBcIvCdlKZcIixcbiAgICAgIElncmF2ZTogXCLDjFwiLFxuICAgICAgaWdyYXZlOiBcIsOsXCIsXG4gICAgICBpaTogXCLihYhcIixcbiAgICAgIGlpaWludDogXCLiqIxcIixcbiAgICAgIGlpaW50OiBcIuKIrVwiLFxuICAgICAgaWluZmluOiBcIuKnnFwiLFxuICAgICAgaWlvdGE6IFwi4oSpXCIsXG4gICAgICBJSmxpZzogXCLEslwiLFxuICAgICAgaWpsaWc6IFwixLNcIixcbiAgICAgIEltOiBcIuKEkVwiLFxuICAgICAgSW1hY3I6IFwixKpcIixcbiAgICAgIGltYWNyOiBcIsSrXCIsXG4gICAgICBpbWFnZTogXCLihJFcIixcbiAgICAgIEltYWdpbmFyeUk6IFwi4oWIXCIsXG4gICAgICBpbWFnbGluZTogXCLihJBcIixcbiAgICAgIGltYWdwYXJ0OiBcIuKEkVwiLFxuICAgICAgaW1hdGg6IFwixLFcIixcbiAgICAgIGltb2Y6IFwi4oq3XCIsXG4gICAgICBpbXBlZDogXCLGtVwiLFxuICAgICAgSW1wbGllczogXCLih5JcIixcbiAgICAgIGluOiBcIuKIiFwiLFxuICAgICAgaW5jYXJlOiBcIuKEhVwiLFxuICAgICAgaW5maW46IFwi4oieXCIsXG4gICAgICBpbmZpbnRpZTogXCLip51cIixcbiAgICAgIGlub2RvdDogXCLEsVwiLFxuICAgICAgSW50OiBcIuKIrFwiLFxuICAgICAgaW50OiBcIuKIq1wiLFxuICAgICAgaW50Y2FsOiBcIuKKulwiLFxuICAgICAgaW50ZWdlcnM6IFwi4oSkXCIsXG4gICAgICBJbnRlZ3JhbDogXCLiiKtcIixcbiAgICAgIGludGVyY2FsOiBcIuKKulwiLFxuICAgICAgSW50ZXJzZWN0aW9uOiBcIuKLglwiLFxuICAgICAgaW50bGFyaGs6IFwi4qiXXCIsXG4gICAgICBpbnRwcm9kOiBcIuKovFwiLFxuICAgICAgSW52aXNpYmxlQ29tbWE6IFwi4oGjXCIsXG4gICAgICBJbnZpc2libGVUaW1lczogXCLigaJcIixcbiAgICAgIElPY3k6IFwi0IFcIixcbiAgICAgIGlvY3k6IFwi0ZFcIixcbiAgICAgIElvZ29uOiBcIsSuXCIsXG4gICAgICBpb2dvbjogXCLEr1wiLFxuICAgICAgSW9wZjogXCLwnZWAXCIsXG4gICAgICBpb3BmOiBcIvCdlZpcIixcbiAgICAgIElvdGE6IFwizplcIixcbiAgICAgIGlvdGE6IFwizrlcIixcbiAgICAgIGlwcm9kOiBcIuKovFwiLFxuICAgICAgaXF1ZXN0OiBcIsK/XCIsXG4gICAgICBJc2NyOiBcIuKEkFwiLFxuICAgICAgaXNjcjogXCLwnZK+XCIsXG4gICAgICBpc2luOiBcIuKIiFwiLFxuICAgICAgaXNpbmRvdDogXCLii7VcIixcbiAgICAgIGlzaW5FOiBcIuKLuVwiLFxuICAgICAgaXNpbnM6IFwi4ou0XCIsXG4gICAgICBpc2luc3Y6IFwi4ouzXCIsXG4gICAgICBpc2ludjogXCLiiIhcIixcbiAgICAgIGl0OiBcIuKBolwiLFxuICAgICAgSXRpbGRlOiBcIsSoXCIsXG4gICAgICBpdGlsZGU6IFwixKlcIixcbiAgICAgIEl1a2N5OiBcItCGXCIsXG4gICAgICBpdWtjeTogXCLRllwiLFxuICAgICAgSXVtbDogXCLDj1wiLFxuICAgICAgaXVtbDogXCLDr1wiLFxuICAgICAgSmNpcmM6IFwixLRcIixcbiAgICAgIGpjaXJjOiBcIsS1XCIsXG4gICAgICBKY3k6IFwi0JlcIixcbiAgICAgIGpjeTogXCLQuVwiLFxuICAgICAgSmZyOiBcIvCdlI1cIixcbiAgICAgIGpmcjogXCLwnZSnXCIsXG4gICAgICBqbWF0aDogXCLIt1wiLFxuICAgICAgSm9wZjogXCLwnZWBXCIsXG4gICAgICBqb3BmOiBcIvCdlZtcIixcbiAgICAgIEpzY3I6IFwi8J2SpVwiLFxuICAgICAganNjcjogXCLwnZK/XCIsXG4gICAgICBKc2VyY3k6IFwi0IhcIixcbiAgICAgIGpzZXJjeTogXCLRmFwiLFxuICAgICAgSnVrY3k6IFwi0IRcIixcbiAgICAgIGp1a2N5OiBcItGUXCIsXG4gICAgICBLYXBwYTogXCLOmlwiLFxuICAgICAga2FwcGE6IFwizrpcIixcbiAgICAgIGthcHBhdjogXCLPsFwiLFxuICAgICAgS2NlZGlsOiBcIsS2XCIsXG4gICAgICBrY2VkaWw6IFwixLdcIixcbiAgICAgIEtjeTogXCLQmlwiLFxuICAgICAga2N5OiBcItC6XCIsXG4gICAgICBLZnI6IFwi8J2UjlwiLFxuICAgICAga2ZyOiBcIvCdlKhcIixcbiAgICAgIGtncmVlbjogXCLEuFwiLFxuICAgICAgS0hjeTogXCLQpVwiLFxuICAgICAga2hjeTogXCLRhVwiLFxuICAgICAgS0pjeTogXCLQjFwiLFxuICAgICAga2pjeTogXCLRnFwiLFxuICAgICAgS29wZjogXCLwnZWCXCIsXG4gICAgICBrb3BmOiBcIvCdlZxcIixcbiAgICAgIEtzY3I6IFwi8J2SplwiLFxuICAgICAga3NjcjogXCLwnZOAXCIsXG4gICAgICBsQWFycjogXCLih5pcIixcbiAgICAgIExhY3V0ZTogXCLEuVwiLFxuICAgICAgbGFjdXRlOiBcIsS6XCIsXG4gICAgICBsYWVtcHR5djogXCLiprRcIixcbiAgICAgIGxhZ3JhbjogXCLihJJcIixcbiAgICAgIExhbWJkYTogXCLOm1wiLFxuICAgICAgbGFtYmRhOiBcIs67XCIsXG4gICAgICBMYW5nOiBcIuKfqlwiLFxuICAgICAgbGFuZzogXCLin6hcIixcbiAgICAgIGxhbmdkOiBcIuKmkVwiLFxuICAgICAgbGFuZ2xlOiBcIuKfqFwiLFxuICAgICAgbGFwOiBcIuKqhVwiLFxuICAgICAgTGFwbGFjZXRyZjogXCLihJJcIixcbiAgICAgIGxhcXVvOiBcIsKrXCIsXG4gICAgICBMYXJyOiBcIuKGnlwiLFxuICAgICAgbEFycjogXCLih5BcIixcbiAgICAgIGxhcnI6IFwi4oaQXCIsXG4gICAgICBsYXJyYjogXCLih6RcIixcbiAgICAgIGxhcnJiZnM6IFwi4qSfXCIsXG4gICAgICBsYXJyZnM6IFwi4qSdXCIsXG4gICAgICBsYXJyaGs6IFwi4oapXCIsXG4gICAgICBsYXJybHA6IFwi4oarXCIsXG4gICAgICBsYXJycGw6IFwi4qS5XCIsXG4gICAgICBsYXJyc2ltOiBcIuKls1wiLFxuICAgICAgbGFycnRsOiBcIuKGolwiLFxuICAgICAgbGF0OiBcIuKqq1wiLFxuICAgICAgbEF0YWlsOiBcIuKkm1wiLFxuICAgICAgbGF0YWlsOiBcIuKkmVwiLFxuICAgICAgbGF0ZTogXCLiqq1cIixcbiAgICAgIGxhdGVzOiBcIuKqre+4gFwiLFxuICAgICAgbEJhcnI6IFwi4qSOXCIsXG4gICAgICBsYmFycjogXCLipIxcIixcbiAgICAgIGxiYnJrOiBcIuKdslwiLFxuICAgICAgbGJyYWNlOiBcIntcIixcbiAgICAgIGxicmFjazogXCJbXCIsXG4gICAgICBsYnJrZTogXCLipotcIixcbiAgICAgIGxicmtzbGQ6IFwi4qaPXCIsXG4gICAgICBsYnJrc2x1OiBcIuKmjVwiLFxuICAgICAgTGNhcm9uOiBcIsS9XCIsXG4gICAgICBsY2Fyb246IFwixL5cIixcbiAgICAgIExjZWRpbDogXCLEu1wiLFxuICAgICAgbGNlZGlsOiBcIsS8XCIsXG4gICAgICBsY2VpbDogXCLijIhcIixcbiAgICAgIGxjdWI6IFwie1wiLFxuICAgICAgTGN5OiBcItCbXCIsXG4gICAgICBsY3k6IFwi0LtcIixcbiAgICAgIGxkY2E6IFwi4qS2XCIsXG4gICAgICBsZHF1bzogXCLigJxcIixcbiAgICAgIGxkcXVvcjogXCLigJ5cIixcbiAgICAgIGxkcmRoYXI6IFwi4qWnXCIsXG4gICAgICBsZHJ1c2hhcjogXCLipYtcIixcbiAgICAgIGxkc2g6IFwi4oayXCIsXG4gICAgICBsRTogXCLiiaZcIixcbiAgICAgIGxlOiBcIuKJpFwiLFxuICAgICAgTGVmdEFuZ2xlQnJhY2tldDogXCLin6hcIixcbiAgICAgIExlZnRBcnJvdzogXCLihpBcIixcbiAgICAgIExlZnRhcnJvdzogXCLih5BcIixcbiAgICAgIGxlZnRhcnJvdzogXCLihpBcIixcbiAgICAgIExlZnRBcnJvd0JhcjogXCLih6RcIixcbiAgICAgIExlZnRBcnJvd1JpZ2h0QXJyb3c6IFwi4oeGXCIsXG4gICAgICBsZWZ0YXJyb3d0YWlsOiBcIuKGolwiLFxuICAgICAgTGVmdENlaWxpbmc6IFwi4oyIXCIsXG4gICAgICBMZWZ0RG91YmxlQnJhY2tldDogXCLin6ZcIixcbiAgICAgIExlZnREb3duVGVlVmVjdG9yOiBcIuKloVwiLFxuICAgICAgTGVmdERvd25WZWN0b3I6IFwi4oeDXCIsXG4gICAgICBMZWZ0RG93blZlY3RvckJhcjogXCLipZlcIixcbiAgICAgIExlZnRGbG9vcjogXCLijIpcIixcbiAgICAgIGxlZnRoYXJwb29uZG93bjogXCLihr1cIixcbiAgICAgIGxlZnRoYXJwb29udXA6IFwi4oa8XCIsXG4gICAgICBsZWZ0bGVmdGFycm93czogXCLih4dcIixcbiAgICAgIExlZnRSaWdodEFycm93OiBcIuKGlFwiLFxuICAgICAgTGVmdHJpZ2h0YXJyb3c6IFwi4oeUXCIsXG4gICAgICBsZWZ0cmlnaHRhcnJvdzogXCLihpRcIixcbiAgICAgIGxlZnRyaWdodGFycm93czogXCLih4ZcIixcbiAgICAgIGxlZnRyaWdodGhhcnBvb25zOiBcIuKHi1wiLFxuICAgICAgbGVmdHJpZ2h0c3F1aWdhcnJvdzogXCLihq1cIixcbiAgICAgIExlZnRSaWdodFZlY3RvcjogXCLipY5cIixcbiAgICAgIExlZnRUZWU6IFwi4oqjXCIsXG4gICAgICBMZWZ0VGVlQXJyb3c6IFwi4oakXCIsXG4gICAgICBMZWZ0VGVlVmVjdG9yOiBcIuKlmlwiLFxuICAgICAgbGVmdHRocmVldGltZXM6IFwi4ouLXCIsXG4gICAgICBMZWZ0VHJpYW5nbGU6IFwi4oqyXCIsXG4gICAgICBMZWZ0VHJpYW5nbGVCYXI6IFwi4qePXCIsXG4gICAgICBMZWZ0VHJpYW5nbGVFcXVhbDogXCLiirRcIixcbiAgICAgIExlZnRVcERvd25WZWN0b3I6IFwi4qWRXCIsXG4gICAgICBMZWZ0VXBUZWVWZWN0b3I6IFwi4qWgXCIsXG4gICAgICBMZWZ0VXBWZWN0b3I6IFwi4oa/XCIsXG4gICAgICBMZWZ0VXBWZWN0b3JCYXI6IFwi4qWYXCIsXG4gICAgICBMZWZ0VmVjdG9yOiBcIuKGvFwiLFxuICAgICAgTGVmdFZlY3RvckJhcjogXCLipZJcIixcbiAgICAgIGxFZzogXCLiqotcIixcbiAgICAgIGxlZzogXCLii5pcIixcbiAgICAgIGxlcTogXCLiiaRcIixcbiAgICAgIGxlcXE6IFwi4ommXCIsXG4gICAgICBsZXFzbGFudDogXCLiqb1cIixcbiAgICAgIGxlczogXCLiqb1cIixcbiAgICAgIGxlc2NjOiBcIuKqqFwiLFxuICAgICAgbGVzZG90OiBcIuKpv1wiLFxuICAgICAgbGVzZG90bzogXCLiqoFcIixcbiAgICAgIGxlc2RvdG9yOiBcIuKqg1wiLFxuICAgICAgbGVzZzogXCLii5rvuIBcIixcbiAgICAgIGxlc2dlczogXCLiqpNcIixcbiAgICAgIGxlc3NhcHByb3g6IFwi4qqFXCIsXG4gICAgICBsZXNzZG90OiBcIuKLllwiLFxuICAgICAgbGVzc2VxZ3RyOiBcIuKLmlwiLFxuICAgICAgbGVzc2VxcWd0cjogXCLiqotcIixcbiAgICAgIExlc3NFcXVhbEdyZWF0ZXI6IFwi4ouaXCIsXG4gICAgICBMZXNzRnVsbEVxdWFsOiBcIuKJplwiLFxuICAgICAgTGVzc0dyZWF0ZXI6IFwi4om2XCIsXG4gICAgICBsZXNzZ3RyOiBcIuKJtlwiLFxuICAgICAgTGVzc0xlc3M6IFwi4qqhXCIsXG4gICAgICBsZXNzc2ltOiBcIuKJslwiLFxuICAgICAgTGVzc1NsYW50RXF1YWw6IFwi4qm9XCIsXG4gICAgICBMZXNzVGlsZGU6IFwi4omyXCIsXG4gICAgICBsZmlzaHQ6IFwi4qW8XCIsXG4gICAgICBsZmxvb3I6IFwi4oyKXCIsXG4gICAgICBMZnI6IFwi8J2Uj1wiLFxuICAgICAgbGZyOiBcIvCdlKlcIixcbiAgICAgIGxnOiBcIuKJtlwiLFxuICAgICAgbGdFOiBcIuKqkVwiLFxuICAgICAgbEhhcjogXCLipaJcIixcbiAgICAgIGxoYXJkOiBcIuKGvVwiLFxuICAgICAgbGhhcnU6IFwi4oa8XCIsXG4gICAgICBsaGFydWw6IFwi4qWqXCIsXG4gICAgICBsaGJsazogXCLiloRcIixcbiAgICAgIExKY3k6IFwi0IlcIixcbiAgICAgIGxqY3k6IFwi0ZlcIixcbiAgICAgIExsOiBcIuKLmFwiLFxuICAgICAgbGw6IFwi4omqXCIsXG4gICAgICBsbGFycjogXCLih4dcIixcbiAgICAgIGxsY29ybmVyOiBcIuKMnlwiLFxuICAgICAgTGxlZnRhcnJvdzogXCLih5pcIixcbiAgICAgIGxsaGFyZDogXCLipatcIixcbiAgICAgIGxsdHJpOiBcIuKXulwiLFxuICAgICAgTG1pZG90OiBcIsS/XCIsXG4gICAgICBsbWlkb3Q6IFwixYBcIixcbiAgICAgIGxtb3VzdDogXCLijrBcIixcbiAgICAgIGxtb3VzdGFjaGU6IFwi4o6wXCIsXG4gICAgICBsbmFwOiBcIuKqiVwiLFxuICAgICAgbG5hcHByb3g6IFwi4qqJXCIsXG4gICAgICBsbkU6IFwi4omoXCIsXG4gICAgICBsbmU6IFwi4qqHXCIsXG4gICAgICBsbmVxOiBcIuKqh1wiLFxuICAgICAgbG5lcXE6IFwi4omoXCIsXG4gICAgICBsbnNpbTogXCLii6ZcIixcbiAgICAgIGxvYW5nOiBcIuKfrFwiLFxuICAgICAgbG9hcnI6IFwi4oe9XCIsXG4gICAgICBsb2JyazogXCLin6ZcIixcbiAgICAgIExvbmdMZWZ0QXJyb3c6IFwi4p+1XCIsXG4gICAgICBMb25nbGVmdGFycm93OiBcIuKfuFwiLFxuICAgICAgbG9uZ2xlZnRhcnJvdzogXCLin7VcIixcbiAgICAgIExvbmdMZWZ0UmlnaHRBcnJvdzogXCLin7dcIixcbiAgICAgIExvbmdsZWZ0cmlnaHRhcnJvdzogXCLin7pcIixcbiAgICAgIGxvbmdsZWZ0cmlnaHRhcnJvdzogXCLin7dcIixcbiAgICAgIGxvbmdtYXBzdG86IFwi4p+8XCIsXG4gICAgICBMb25nUmlnaHRBcnJvdzogXCLin7ZcIixcbiAgICAgIExvbmdyaWdodGFycm93OiBcIuKfuVwiLFxuICAgICAgbG9uZ3JpZ2h0YXJyb3c6IFwi4p+2XCIsXG4gICAgICBsb29wYXJyb3dsZWZ0OiBcIuKGq1wiLFxuICAgICAgbG9vcGFycm93cmlnaHQ6IFwi4oasXCIsXG4gICAgICBsb3BhcjogXCLipoVcIixcbiAgICAgIExvcGY6IFwi8J2Vg1wiLFxuICAgICAgbG9wZjogXCLwnZWdXCIsXG4gICAgICBsb3BsdXM6IFwi4qitXCIsXG4gICAgICBsb3RpbWVzOiBcIuKotFwiLFxuICAgICAgbG93YXN0OiBcIuKIl1wiLFxuICAgICAgbG93YmFyOiBcIl9cIixcbiAgICAgIExvd2VyTGVmdEFycm93OiBcIuKGmVwiLFxuICAgICAgTG93ZXJSaWdodEFycm93OiBcIuKGmFwiLFxuICAgICAgbG96OiBcIuKXilwiLFxuICAgICAgbG96ZW5nZTogXCLil4pcIixcbiAgICAgIGxvemY6IFwi4qerXCIsXG4gICAgICBscGFyOiBcIihcIixcbiAgICAgIGxwYXJsdDogXCLippNcIixcbiAgICAgIGxyYXJyOiBcIuKHhlwiLFxuICAgICAgbHJjb3JuZXI6IFwi4oyfXCIsXG4gICAgICBscmhhcjogXCLih4tcIixcbiAgICAgIGxyaGFyZDogXCLipa1cIixcbiAgICAgIGxybTogXCLigI5cIixcbiAgICAgIGxydHJpOiBcIuKKv1wiLFxuICAgICAgbHNhcXVvOiBcIuKAuVwiLFxuICAgICAgTHNjcjogXCLihJJcIixcbiAgICAgIGxzY3I6IFwi8J2TgVwiLFxuICAgICAgTHNoOiBcIuKGsFwiLFxuICAgICAgbHNoOiBcIuKGsFwiLFxuICAgICAgbHNpbTogXCLiibJcIixcbiAgICAgIGxzaW1lOiBcIuKqjVwiLFxuICAgICAgbHNpbWc6IFwi4qqPXCIsXG4gICAgICBsc3FiOiBcIltcIixcbiAgICAgIGxzcXVvOiBcIuKAmFwiLFxuICAgICAgbHNxdW9yOiBcIuKAmlwiLFxuICAgICAgTHN0cm9rOiBcIsWBXCIsXG4gICAgICBsc3Ryb2s6IFwixYJcIixcbiAgICAgIEx0OiBcIuKJqlwiLFxuICAgICAgTFQ6IFwiPFwiLFxuICAgICAgbHQ6IFwiPFwiLFxuICAgICAgbHRjYzogXCLiqqZcIixcbiAgICAgIGx0Y2lyOiBcIuKpuVwiLFxuICAgICAgbHRkb3Q6IFwi4ouWXCIsXG4gICAgICBsdGhyZWU6IFwi4ouLXCIsXG4gICAgICBsdGltZXM6IFwi4ouJXCIsXG4gICAgICBsdGxhcnI6IFwi4qW2XCIsXG4gICAgICBsdHF1ZXN0OiBcIuKpu1wiLFxuICAgICAgbHRyaTogXCLil4NcIixcbiAgICAgIGx0cmllOiBcIuKKtFwiLFxuICAgICAgbHRyaWY6IFwi4peCXCIsXG4gICAgICBsdHJQYXI6IFwi4qaWXCIsXG4gICAgICBsdXJkc2hhcjogXCLipYpcIixcbiAgICAgIGx1cnVoYXI6IFwi4qWmXCIsXG4gICAgICBsdmVydG5lcXE6IFwi4omo77iAXCIsXG4gICAgICBsdm5FOiBcIuKJqO+4gFwiLFxuICAgICAgbWFjcjogXCLCr1wiLFxuICAgICAgbWFsZTogXCLimYJcIixcbiAgICAgIG1hbHQ6IFwi4pygXCIsXG4gICAgICBtYWx0ZXNlOiBcIuKcoFwiLFxuICAgICAgTWFwOiBcIuKkhVwiLFxuICAgICAgbWFwOiBcIuKGplwiLFxuICAgICAgbWFwc3RvOiBcIuKGplwiLFxuICAgICAgbWFwc3RvZG93bjogXCLihqdcIixcbiAgICAgIG1hcHN0b2xlZnQ6IFwi4oakXCIsXG4gICAgICBtYXBzdG91cDogXCLihqVcIixcbiAgICAgIG1hcmtlcjogXCLilq5cIixcbiAgICAgIG1jb21tYTogXCLiqKlcIixcbiAgICAgIE1jeTogXCLQnFwiLFxuICAgICAgbWN5OiBcItC8XCIsXG4gICAgICBtZGFzaDogXCLigJRcIixcbiAgICAgIG1ERG90OiBcIuKIulwiLFxuICAgICAgbWVhc3VyZWRhbmdsZTogXCLiiKFcIixcbiAgICAgIE1lZGl1bVNwYWNlOiBcIuKBn1wiLFxuICAgICAgTWVsbGludHJmOiBcIuKEs1wiLFxuICAgICAgTWZyOiBcIvCdlJBcIixcbiAgICAgIG1mcjogXCLwnZSqXCIsXG4gICAgICBtaG86IFwi4oSnXCIsXG4gICAgICBtaWNybzogXCLCtVwiLFxuICAgICAgbWlkOiBcIuKIo1wiLFxuICAgICAgbWlkYXN0OiBcIipcIixcbiAgICAgIG1pZGNpcjogXCLiq7BcIixcbiAgICAgIG1pZGRvdDogXCLCt1wiLFxuICAgICAgbWludXM6IFwi4oiSXCIsXG4gICAgICBtaW51c2I6IFwi4oqfXCIsXG4gICAgICBtaW51c2Q6IFwi4oi4XCIsXG4gICAgICBtaW51c2R1OiBcIuKoqlwiLFxuICAgICAgTWludXNQbHVzOiBcIuKIk1wiLFxuICAgICAgbWxjcDogXCLiq5tcIixcbiAgICAgIG1sZHI6IFwi4oCmXCIsXG4gICAgICBtbnBsdXM6IFwi4oiTXCIsXG4gICAgICBtb2RlbHM6IFwi4oqnXCIsXG4gICAgICBNb3BmOiBcIvCdlYRcIixcbiAgICAgIG1vcGY6IFwi8J2VnlwiLFxuICAgICAgbXA6IFwi4oiTXCIsXG4gICAgICBNc2NyOiBcIuKEs1wiLFxuICAgICAgbXNjcjogXCLwnZOCXCIsXG4gICAgICBtc3Rwb3M6IFwi4oi+XCIsXG4gICAgICBNdTogXCLOnFwiLFxuICAgICAgbXU6IFwizrxcIixcbiAgICAgIG11bHRpbWFwOiBcIuKKuFwiLFxuICAgICAgbXVtYXA6IFwi4oq4XCIsXG4gICAgICBuYWJsYTogXCLiiIdcIixcbiAgICAgIE5hY3V0ZTogXCLFg1wiLFxuICAgICAgbmFjdXRlOiBcIsWEXCIsXG4gICAgICBuYW5nOiBcIuKIoOKDklwiLFxuICAgICAgbmFwOiBcIuKJiVwiLFxuICAgICAgbmFwRTogXCLiqbDMuFwiLFxuICAgICAgbmFwaWQ6IFwi4omLzLhcIixcbiAgICAgIG5hcG9zOiBcIsWJXCIsXG4gICAgICBuYXBwcm94OiBcIuKJiVwiLFxuICAgICAgbmF0dXI6IFwi4pmuXCIsXG4gICAgICBuYXR1cmFsOiBcIuKZrlwiLFxuICAgICAgbmF0dXJhbHM6IFwi4oSVXCIsXG4gICAgICBuYnNwOiBcIsKgXCIsXG4gICAgICBuYnVtcDogXCLiiY7MuFwiLFxuICAgICAgbmJ1bXBlOiBcIuKJj8y4XCIsXG4gICAgICBuY2FwOiBcIuKpg1wiLFxuICAgICAgTmNhcm9uOiBcIsWHXCIsXG4gICAgICBuY2Fyb246IFwixYhcIixcbiAgICAgIE5jZWRpbDogXCLFhVwiLFxuICAgICAgbmNlZGlsOiBcIsWGXCIsXG4gICAgICBuY29uZzogXCLiiYdcIixcbiAgICAgIG5jb25nZG90OiBcIuKprcy4XCIsXG4gICAgICBuY3VwOiBcIuKpglwiLFxuICAgICAgTmN5OiBcItCdXCIsXG4gICAgICBuY3k6IFwi0L1cIixcbiAgICAgIG5kYXNoOiBcIuKAk1wiLFxuICAgICAgbmU6IFwi4omgXCIsXG4gICAgICBuZWFyaGs6IFwi4qSkXCIsXG4gICAgICBuZUFycjogXCLih5dcIixcbiAgICAgIG5lYXJyOiBcIuKGl1wiLFxuICAgICAgbmVhcnJvdzogXCLihpdcIixcbiAgICAgIG5lZG90OiBcIuKJkMy4XCIsXG4gICAgICBOZWdhdGl2ZU1lZGl1bVNwYWNlOiBcIuKAi1wiLFxuICAgICAgTmVnYXRpdmVUaGlja1NwYWNlOiBcIuKAi1wiLFxuICAgICAgTmVnYXRpdmVUaGluU3BhY2U6IFwi4oCLXCIsXG4gICAgICBOZWdhdGl2ZVZlcnlUaGluU3BhY2U6IFwi4oCLXCIsXG4gICAgICBuZXF1aXY6IFwi4omiXCIsXG4gICAgICBuZXNlYXI6IFwi4qSoXCIsXG4gICAgICBuZXNpbTogXCLiiYLMuFwiLFxuICAgICAgTmVzdGVkR3JlYXRlckdyZWF0ZXI6IFwi4omrXCIsXG4gICAgICBOZXN0ZWRMZXNzTGVzczogXCLiiapcIixcbiAgICAgIE5ld0xpbmU6IGBcbmAsXG4gICAgICBuZXhpc3Q6IFwi4oiEXCIsXG4gICAgICBuZXhpc3RzOiBcIuKIhFwiLFxuICAgICAgTmZyOiBcIvCdlJFcIixcbiAgICAgIG5mcjogXCLwnZSrXCIsXG4gICAgICBuZ0U6IFwi4omnzLhcIixcbiAgICAgIG5nZTogXCLiibFcIixcbiAgICAgIG5nZXE6IFwi4omxXCIsXG4gICAgICBuZ2VxcTogXCLiiafMuFwiLFxuICAgICAgbmdlcXNsYW50OiBcIuKpvsy4XCIsXG4gICAgICBuZ2VzOiBcIuKpvsy4XCIsXG4gICAgICBuR2c6IFwi4ouZzLhcIixcbiAgICAgIG5nc2ltOiBcIuKJtVwiLFxuICAgICAgbkd0OiBcIuKJq+KDklwiLFxuICAgICAgbmd0OiBcIuKJr1wiLFxuICAgICAgbmd0cjogXCLiia9cIixcbiAgICAgIG5HdHY6IFwi4omrzLhcIixcbiAgICAgIG5oQXJyOiBcIuKHjlwiLFxuICAgICAgbmhhcnI6IFwi4oauXCIsXG4gICAgICBuaHBhcjogXCLiq7JcIixcbiAgICAgIG5pOiBcIuKIi1wiLFxuICAgICAgbmlzOiBcIuKLvFwiLFxuICAgICAgbmlzZDogXCLii7pcIixcbiAgICAgIG5pdjogXCLiiItcIixcbiAgICAgIE5KY3k6IFwi0IpcIixcbiAgICAgIG5qY3k6IFwi0ZpcIixcbiAgICAgIG5sQXJyOiBcIuKHjVwiLFxuICAgICAgbmxhcnI6IFwi4oaaXCIsXG4gICAgICBubGRyOiBcIuKApVwiLFxuICAgICAgbmxFOiBcIuKJpsy4XCIsXG4gICAgICBubGU6IFwi4omwXCIsXG4gICAgICBuTGVmdGFycm93OiBcIuKHjVwiLFxuICAgICAgbmxlZnRhcnJvdzogXCLihppcIixcbiAgICAgIG5MZWZ0cmlnaHRhcnJvdzogXCLih45cIixcbiAgICAgIG5sZWZ0cmlnaHRhcnJvdzogXCLihq5cIixcbiAgICAgIG5sZXE6IFwi4omwXCIsXG4gICAgICBubGVxcTogXCLiiabMuFwiLFxuICAgICAgbmxlcXNsYW50OiBcIuKpvcy4XCIsXG4gICAgICBubGVzOiBcIuKpvcy4XCIsXG4gICAgICBubGVzczogXCLiia5cIixcbiAgICAgIG5MbDogXCLii5jMuFwiLFxuICAgICAgbmxzaW06IFwi4om0XCIsXG4gICAgICBuTHQ6IFwi4omq4oOSXCIsXG4gICAgICBubHQ6IFwi4omuXCIsXG4gICAgICBubHRyaTogXCLii6pcIixcbiAgICAgIG5sdHJpZTogXCLii6xcIixcbiAgICAgIG5MdHY6IFwi4omqzLhcIixcbiAgICAgIG5taWQ6IFwi4oikXCIsXG4gICAgICBOb0JyZWFrOiBcIuKBoFwiLFxuICAgICAgTm9uQnJlYWtpbmdTcGFjZTogXCLCoFwiLFxuICAgICAgTm9wZjogXCLihJVcIixcbiAgICAgIG5vcGY6IFwi8J2Vn1wiLFxuICAgICAgTm90OiBcIuKrrFwiLFxuICAgICAgbm90OiBcIsKsXCIsXG4gICAgICBOb3RDb25ncnVlbnQ6IFwi4omiXCIsXG4gICAgICBOb3RDdXBDYXA6IFwi4omtXCIsXG4gICAgICBOb3REb3VibGVWZXJ0aWNhbEJhcjogXCLiiKZcIixcbiAgICAgIE5vdEVsZW1lbnQ6IFwi4oiJXCIsXG4gICAgICBOb3RFcXVhbDogXCLiiaBcIixcbiAgICAgIE5vdEVxdWFsVGlsZGU6IFwi4omCzLhcIixcbiAgICAgIE5vdEV4aXN0czogXCLiiIRcIixcbiAgICAgIE5vdEdyZWF0ZXI6IFwi4omvXCIsXG4gICAgICBOb3RHcmVhdGVyRXF1YWw6IFwi4omxXCIsXG4gICAgICBOb3RHcmVhdGVyRnVsbEVxdWFsOiBcIuKJp8y4XCIsXG4gICAgICBOb3RHcmVhdGVyR3JlYXRlcjogXCLiiavMuFwiLFxuICAgICAgTm90R3JlYXRlckxlc3M6IFwi4om5XCIsXG4gICAgICBOb3RHcmVhdGVyU2xhbnRFcXVhbDogXCLiqb7MuFwiLFxuICAgICAgTm90R3JlYXRlclRpbGRlOiBcIuKJtVwiLFxuICAgICAgTm90SHVtcERvd25IdW1wOiBcIuKJjsy4XCIsXG4gICAgICBOb3RIdW1wRXF1YWw6IFwi4omPzLhcIixcbiAgICAgIG5vdGluOiBcIuKIiVwiLFxuICAgICAgbm90aW5kb3Q6IFwi4ou1zLhcIixcbiAgICAgIG5vdGluRTogXCLii7nMuFwiLFxuICAgICAgbm90aW52YTogXCLiiIlcIixcbiAgICAgIG5vdGludmI6IFwi4ou3XCIsXG4gICAgICBub3RpbnZjOiBcIuKLtlwiLFxuICAgICAgTm90TGVmdFRyaWFuZ2xlOiBcIuKLqlwiLFxuICAgICAgTm90TGVmdFRyaWFuZ2xlQmFyOiBcIuKnj8y4XCIsXG4gICAgICBOb3RMZWZ0VHJpYW5nbGVFcXVhbDogXCLii6xcIixcbiAgICAgIE5vdExlc3M6IFwi4omuXCIsXG4gICAgICBOb3RMZXNzRXF1YWw6IFwi4omwXCIsXG4gICAgICBOb3RMZXNzR3JlYXRlcjogXCLiibhcIixcbiAgICAgIE5vdExlc3NMZXNzOiBcIuKJqsy4XCIsXG4gICAgICBOb3RMZXNzU2xhbnRFcXVhbDogXCLiqb3MuFwiLFxuICAgICAgTm90TGVzc1RpbGRlOiBcIuKJtFwiLFxuICAgICAgTm90TmVzdGVkR3JlYXRlckdyZWF0ZXI6IFwi4qqizLhcIixcbiAgICAgIE5vdE5lc3RlZExlc3NMZXNzOiBcIuKqocy4XCIsXG4gICAgICBub3RuaTogXCLiiIxcIixcbiAgICAgIG5vdG5pdmE6IFwi4oiMXCIsXG4gICAgICBub3RuaXZiOiBcIuKLvlwiLFxuICAgICAgbm90bml2YzogXCLii71cIixcbiAgICAgIE5vdFByZWNlZGVzOiBcIuKKgFwiLFxuICAgICAgTm90UHJlY2VkZXNFcXVhbDogXCLiqq/MuFwiLFxuICAgICAgTm90UHJlY2VkZXNTbGFudEVxdWFsOiBcIuKLoFwiLFxuICAgICAgTm90UmV2ZXJzZUVsZW1lbnQ6IFwi4oiMXCIsXG4gICAgICBOb3RSaWdodFRyaWFuZ2xlOiBcIuKLq1wiLFxuICAgICAgTm90UmlnaHRUcmlhbmdsZUJhcjogXCLip5DMuFwiLFxuICAgICAgTm90UmlnaHRUcmlhbmdsZUVxdWFsOiBcIuKLrVwiLFxuICAgICAgTm90U3F1YXJlU3Vic2V0OiBcIuKKj8y4XCIsXG4gICAgICBOb3RTcXVhcmVTdWJzZXRFcXVhbDogXCLii6JcIixcbiAgICAgIE5vdFNxdWFyZVN1cGVyc2V0OiBcIuKKkMy4XCIsXG4gICAgICBOb3RTcXVhcmVTdXBlcnNldEVxdWFsOiBcIuKLo1wiLFxuICAgICAgTm90U3Vic2V0OiBcIuKKguKDklwiLFxuICAgICAgTm90U3Vic2V0RXF1YWw6IFwi4oqIXCIsXG4gICAgICBOb3RTdWNjZWVkczogXCLiioFcIixcbiAgICAgIE5vdFN1Y2NlZWRzRXF1YWw6IFwi4qqwzLhcIixcbiAgICAgIE5vdFN1Y2NlZWRzU2xhbnRFcXVhbDogXCLii6FcIixcbiAgICAgIE5vdFN1Y2NlZWRzVGlsZGU6IFwi4om/zLhcIixcbiAgICAgIE5vdFN1cGVyc2V0OiBcIuKKg+KDklwiLFxuICAgICAgTm90U3VwZXJzZXRFcXVhbDogXCLiiolcIixcbiAgICAgIE5vdFRpbGRlOiBcIuKJgVwiLFxuICAgICAgTm90VGlsZGVFcXVhbDogXCLiiYRcIixcbiAgICAgIE5vdFRpbGRlRnVsbEVxdWFsOiBcIuKJh1wiLFxuICAgICAgTm90VGlsZGVUaWxkZTogXCLiiYlcIixcbiAgICAgIE5vdFZlcnRpY2FsQmFyOiBcIuKIpFwiLFxuICAgICAgbnBhcjogXCLiiKZcIixcbiAgICAgIG5wYXJhbGxlbDogXCLiiKZcIixcbiAgICAgIG5wYXJzbDogXCLiq73ig6VcIixcbiAgICAgIG5wYXJ0OiBcIuKIgsy4XCIsXG4gICAgICBucG9saW50OiBcIuKolFwiLFxuICAgICAgbnByOiBcIuKKgFwiLFxuICAgICAgbnByY3VlOiBcIuKLoFwiLFxuICAgICAgbnByZTogXCLiqq/MuFwiLFxuICAgICAgbnByZWM6IFwi4oqAXCIsXG4gICAgICBucHJlY2VxOiBcIuKqr8y4XCIsXG4gICAgICBuckFycjogXCLih49cIixcbiAgICAgIG5yYXJyOiBcIuKGm1wiLFxuICAgICAgbnJhcnJjOiBcIuKks8y4XCIsXG4gICAgICBucmFycnc6IFwi4oadzLhcIixcbiAgICAgIG5SaWdodGFycm93OiBcIuKHj1wiLFxuICAgICAgbnJpZ2h0YXJyb3c6IFwi4oabXCIsXG4gICAgICBucnRyaTogXCLii6tcIixcbiAgICAgIG5ydHJpZTogXCLii61cIixcbiAgICAgIG5zYzogXCLiioFcIixcbiAgICAgIG5zY2N1ZTogXCLii6FcIixcbiAgICAgIG5zY2U6IFwi4qqwzLhcIixcbiAgICAgIE5zY3I6IFwi8J2SqVwiLFxuICAgICAgbnNjcjogXCLwnZODXCIsXG4gICAgICBuc2hvcnRtaWQ6IFwi4oikXCIsXG4gICAgICBuc2hvcnRwYXJhbGxlbDogXCLiiKZcIixcbiAgICAgIG5zaW06IFwi4omBXCIsXG4gICAgICBuc2ltZTogXCLiiYRcIixcbiAgICAgIG5zaW1lcTogXCLiiYRcIixcbiAgICAgIG5zbWlkOiBcIuKIpFwiLFxuICAgICAgbnNwYXI6IFwi4oimXCIsXG4gICAgICBuc3FzdWJlOiBcIuKLolwiLFxuICAgICAgbnNxc3VwZTogXCLii6NcIixcbiAgICAgIG5zdWI6IFwi4oqEXCIsXG4gICAgICBuc3ViRTogXCLiq4XMuFwiLFxuICAgICAgbnN1YmU6IFwi4oqIXCIsXG4gICAgICBuc3Vic2V0OiBcIuKKguKDklwiLFxuICAgICAgbnN1YnNldGVxOiBcIuKKiFwiLFxuICAgICAgbnN1YnNldGVxcTogXCLiq4XMuFwiLFxuICAgICAgbnN1Y2M6IFwi4oqBXCIsXG4gICAgICBuc3VjY2VxOiBcIuKqsMy4XCIsXG4gICAgICBuc3VwOiBcIuKKhVwiLFxuICAgICAgbnN1cEU6IFwi4quGzLhcIixcbiAgICAgIG5zdXBlOiBcIuKKiVwiLFxuICAgICAgbnN1cHNldDogXCLiioPig5JcIixcbiAgICAgIG5zdXBzZXRlcTogXCLiiolcIixcbiAgICAgIG5zdXBzZXRlcXE6IFwi4quGzLhcIixcbiAgICAgIG50Z2w6IFwi4om5XCIsXG4gICAgICBOdGlsZGU6IFwiw5FcIixcbiAgICAgIG50aWxkZTogXCLDsVwiLFxuICAgICAgbnRsZzogXCLiibhcIixcbiAgICAgIG50cmlhbmdsZWxlZnQ6IFwi4ouqXCIsXG4gICAgICBudHJpYW5nbGVsZWZ0ZXE6IFwi4ousXCIsXG4gICAgICBudHJpYW5nbGVyaWdodDogXCLii6tcIixcbiAgICAgIG50cmlhbmdsZXJpZ2h0ZXE6IFwi4outXCIsXG4gICAgICBOdTogXCLOnVwiLFxuICAgICAgbnU6IFwizr1cIixcbiAgICAgIG51bTogXCIjXCIsXG4gICAgICBudW1lcm86IFwi4oSWXCIsXG4gICAgICBudW1zcDogXCLigIdcIixcbiAgICAgIG52YXA6IFwi4omN4oOSXCIsXG4gICAgICBuVkRhc2g6IFwi4oqvXCIsXG4gICAgICBuVmRhc2g6IFwi4oquXCIsXG4gICAgICBudkRhc2g6IFwi4oqtXCIsXG4gICAgICBudmRhc2g6IFwi4oqsXCIsXG4gICAgICBudmdlOiBcIuKJpeKDklwiLFxuICAgICAgbnZndDogXCI+4oOSXCIsXG4gICAgICBudkhhcnI6IFwi4qSEXCIsXG4gICAgICBudmluZmluOiBcIuKnnlwiLFxuICAgICAgbnZsQXJyOiBcIuKkglwiLFxuICAgICAgbnZsZTogXCLiiaTig5JcIixcbiAgICAgIG52bHQ6IFwiPOKDklwiLFxuICAgICAgbnZsdHJpZTogXCLiirTig5JcIixcbiAgICAgIG52ckFycjogXCLipINcIixcbiAgICAgIG52cnRyaWU6IFwi4oq14oOSXCIsXG4gICAgICBudnNpbTogXCLiiLzig5JcIixcbiAgICAgIG53YXJoazogXCLipKNcIixcbiAgICAgIG53QXJyOiBcIuKHllwiLFxuICAgICAgbndhcnI6IFwi4oaWXCIsXG4gICAgICBud2Fycm93OiBcIuKGllwiLFxuICAgICAgbnduZWFyOiBcIuKkp1wiLFxuICAgICAgT2FjdXRlOiBcIsOTXCIsXG4gICAgICBvYWN1dGU6IFwiw7NcIixcbiAgICAgIG9hc3Q6IFwi4oqbXCIsXG4gICAgICBvY2lyOiBcIuKKmlwiLFxuICAgICAgT2NpcmM6IFwiw5RcIixcbiAgICAgIG9jaXJjOiBcIsO0XCIsXG4gICAgICBPY3k6IFwi0J5cIixcbiAgICAgIG9jeTogXCLQvlwiLFxuICAgICAgb2Rhc2g6IFwi4oqdXCIsXG4gICAgICBPZGJsYWM6IFwixZBcIixcbiAgICAgIG9kYmxhYzogXCLFkVwiLFxuICAgICAgb2RpdjogXCLiqLhcIixcbiAgICAgIG9kb3Q6IFwi4oqZXCIsXG4gICAgICBvZHNvbGQ6IFwi4qa8XCIsXG4gICAgICBPRWxpZzogXCLFklwiLFxuICAgICAgb2VsaWc6IFwixZNcIixcbiAgICAgIG9mY2lyOiBcIuKmv1wiLFxuICAgICAgT2ZyOiBcIvCdlJJcIixcbiAgICAgIG9mcjogXCLwnZSsXCIsXG4gICAgICBvZ29uOiBcIsubXCIsXG4gICAgICBPZ3JhdmU6IFwiw5JcIixcbiAgICAgIG9ncmF2ZTogXCLDslwiLFxuICAgICAgb2d0OiBcIuKngVwiLFxuICAgICAgb2hiYXI6IFwi4qa1XCIsXG4gICAgICBvaG06IFwizqlcIixcbiAgICAgIG9pbnQ6IFwi4oiuXCIsXG4gICAgICBvbGFycjogXCLihrpcIixcbiAgICAgIG9sY2lyOiBcIuKmvlwiLFxuICAgICAgb2xjcm9zczogXCLiprtcIixcbiAgICAgIG9saW5lOiBcIuKAvlwiLFxuICAgICAgb2x0OiBcIuKngFwiLFxuICAgICAgT21hY3I6IFwixYxcIixcbiAgICAgIG9tYWNyOiBcIsWNXCIsXG4gICAgICBPbWVnYTogXCLOqVwiLFxuICAgICAgb21lZ2E6IFwiz4lcIixcbiAgICAgIE9taWNyb246IFwizp9cIixcbiAgICAgIG9taWNyb246IFwizr9cIixcbiAgICAgIG9taWQ6IFwi4qa2XCIsXG4gICAgICBvbWludXM6IFwi4oqWXCIsXG4gICAgICBPb3BmOiBcIvCdlYZcIixcbiAgICAgIG9vcGY6IFwi8J2VoFwiLFxuICAgICAgb3BhcjogXCLiprdcIixcbiAgICAgIE9wZW5DdXJseURvdWJsZVF1b3RlOiBcIuKAnFwiLFxuICAgICAgT3BlbkN1cmx5UXVvdGU6IFwi4oCYXCIsXG4gICAgICBvcGVycDogXCLiprlcIixcbiAgICAgIG9wbHVzOiBcIuKKlVwiLFxuICAgICAgT3I6IFwi4qmUXCIsXG4gICAgICBvcjogXCLiiKhcIixcbiAgICAgIG9yYXJyOiBcIuKGu1wiLFxuICAgICAgb3JkOiBcIuKpnVwiLFxuICAgICAgb3JkZXI6IFwi4oS0XCIsXG4gICAgICBvcmRlcm9mOiBcIuKEtFwiLFxuICAgICAgb3JkZjogXCLCqlwiLFxuICAgICAgb3JkbTogXCLCulwiLFxuICAgICAgb3JpZ29mOiBcIuKKtlwiLFxuICAgICAgb3JvcjogXCLiqZZcIixcbiAgICAgIG9yc2xvcGU6IFwi4qmXXCIsXG4gICAgICBvcnY6IFwi4qmbXCIsXG4gICAgICBvUzogXCLik4hcIixcbiAgICAgIE9zY3I6IFwi8J2SqlwiLFxuICAgICAgb3NjcjogXCLihLRcIixcbiAgICAgIE9zbGFzaDogXCLDmFwiLFxuICAgICAgb3NsYXNoOiBcIsO4XCIsXG4gICAgICBvc29sOiBcIuKKmFwiLFxuICAgICAgT3RpbGRlOiBcIsOVXCIsXG4gICAgICBvdGlsZGU6IFwiw7VcIixcbiAgICAgIE90aW1lczogXCLiqLdcIixcbiAgICAgIG90aW1lczogXCLiipdcIixcbiAgICAgIG90aW1lc2FzOiBcIuKotlwiLFxuICAgICAgT3VtbDogXCLDllwiLFxuICAgICAgb3VtbDogXCLDtlwiLFxuICAgICAgb3ZiYXI6IFwi4oy9XCIsXG4gICAgICBPdmVyQmFyOiBcIuKAvlwiLFxuICAgICAgT3ZlckJyYWNlOiBcIuKPnlwiLFxuICAgICAgT3ZlckJyYWNrZXQ6IFwi4o60XCIsXG4gICAgICBPdmVyUGFyZW50aGVzaXM6IFwi4o+cXCIsXG4gICAgICBwYXI6IFwi4oilXCIsXG4gICAgICBwYXJhOiBcIsK2XCIsXG4gICAgICBwYXJhbGxlbDogXCLiiKVcIixcbiAgICAgIHBhcnNpbTogXCLiq7NcIixcbiAgICAgIHBhcnNsOiBcIuKrvVwiLFxuICAgICAgcGFydDogXCLiiIJcIixcbiAgICAgIFBhcnRpYWxEOiBcIuKIglwiLFxuICAgICAgUGN5OiBcItCfXCIsXG4gICAgICBwY3k6IFwi0L9cIixcbiAgICAgIHBlcmNudDogXCIlXCIsXG4gICAgICBwZXJpb2Q6IFwiLlwiLFxuICAgICAgcGVybWlsOiBcIuKAsFwiLFxuICAgICAgcGVycDogXCLiiqVcIixcbiAgICAgIHBlcnRlbms6IFwi4oCxXCIsXG4gICAgICBQZnI6IFwi8J2Uk1wiLFxuICAgICAgcGZyOiBcIvCdlK1cIixcbiAgICAgIFBoaTogXCLOplwiLFxuICAgICAgcGhpOiBcIs+GXCIsXG4gICAgICBwaGl2OiBcIs+VXCIsXG4gICAgICBwaG1tYXQ6IFwi4oSzXCIsXG4gICAgICBwaG9uZTogXCLimI5cIixcbiAgICAgIFBpOiBcIs6gXCIsXG4gICAgICBwaTogXCLPgFwiLFxuICAgICAgcGl0Y2hmb3JrOiBcIuKLlFwiLFxuICAgICAgcGl2OiBcIs+WXCIsXG4gICAgICBwbGFuY2s6IFwi4oSPXCIsXG4gICAgICBwbGFuY2toOiBcIuKEjlwiLFxuICAgICAgcGxhbmt2OiBcIuKEj1wiLFxuICAgICAgcGx1czogXCIrXCIsXG4gICAgICBwbHVzYWNpcjogXCLiqKNcIixcbiAgICAgIHBsdXNiOiBcIuKKnlwiLFxuICAgICAgcGx1c2NpcjogXCLiqKJcIixcbiAgICAgIHBsdXNkbzogXCLiiJRcIixcbiAgICAgIHBsdXNkdTogXCLiqKVcIixcbiAgICAgIHBsdXNlOiBcIuKpslwiLFxuICAgICAgUGx1c01pbnVzOiBcIsKxXCIsXG4gICAgICBwbHVzbW46IFwiwrFcIixcbiAgICAgIHBsdXNzaW06IFwi4qimXCIsXG4gICAgICBwbHVzdHdvOiBcIuKop1wiLFxuICAgICAgcG06IFwiwrFcIixcbiAgICAgIFBvaW5jYXJlcGxhbmU6IFwi4oSMXCIsXG4gICAgICBwb2ludGludDogXCLiqJVcIixcbiAgICAgIFBvcGY6IFwi4oSZXCIsXG4gICAgICBwb3BmOiBcIvCdlaFcIixcbiAgICAgIHBvdW5kOiBcIsKjXCIsXG4gICAgICBQcjogXCLiqrtcIixcbiAgICAgIHByOiBcIuKJulwiLFxuICAgICAgcHJhcDogXCLiqrdcIixcbiAgICAgIHByY3VlOiBcIuKJvFwiLFxuICAgICAgcHJFOiBcIuKqs1wiLFxuICAgICAgcHJlOiBcIuKqr1wiLFxuICAgICAgcHJlYzogXCLiibpcIixcbiAgICAgIHByZWNhcHByb3g6IFwi4qq3XCIsXG4gICAgICBwcmVjY3VybHllcTogXCLiibxcIixcbiAgICAgIFByZWNlZGVzOiBcIuKJulwiLFxuICAgICAgUHJlY2VkZXNFcXVhbDogXCLiqq9cIixcbiAgICAgIFByZWNlZGVzU2xhbnRFcXVhbDogXCLiibxcIixcbiAgICAgIFByZWNlZGVzVGlsZGU6IFwi4om+XCIsXG4gICAgICBwcmVjZXE6IFwi4qqvXCIsXG4gICAgICBwcmVjbmFwcHJveDogXCLiqrlcIixcbiAgICAgIHByZWNuZXFxOiBcIuKqtVwiLFxuICAgICAgcHJlY25zaW06IFwi4ouoXCIsXG4gICAgICBwcmVjc2ltOiBcIuKJvlwiLFxuICAgICAgUHJpbWU6IFwi4oCzXCIsXG4gICAgICBwcmltZTogXCLigLJcIixcbiAgICAgIHByaW1lczogXCLihJlcIixcbiAgICAgIHBybmFwOiBcIuKquVwiLFxuICAgICAgcHJuRTogXCLiqrVcIixcbiAgICAgIHBybnNpbTogXCLii6hcIixcbiAgICAgIHByb2Q6IFwi4oiPXCIsXG4gICAgICBQcm9kdWN0OiBcIuKIj1wiLFxuICAgICAgcHJvZmFsYXI6IFwi4oyuXCIsXG4gICAgICBwcm9mbGluZTogXCLijJJcIixcbiAgICAgIHByb2ZzdXJmOiBcIuKMk1wiLFxuICAgICAgcHJvcDogXCLiiJ1cIixcbiAgICAgIFByb3BvcnRpb246IFwi4oi3XCIsXG4gICAgICBQcm9wb3J0aW9uYWw6IFwi4oidXCIsXG4gICAgICBwcm9wdG86IFwi4oidXCIsXG4gICAgICBwcnNpbTogXCLiib5cIixcbiAgICAgIHBydXJlbDogXCLiirBcIixcbiAgICAgIFBzY3I6IFwi8J2Sq1wiLFxuICAgICAgcHNjcjogXCLwnZOFXCIsXG4gICAgICBQc2k6IFwizqhcIixcbiAgICAgIHBzaTogXCLPiFwiLFxuICAgICAgcHVuY3NwOiBcIuKAiFwiLFxuICAgICAgUWZyOiBcIvCdlJRcIixcbiAgICAgIHFmcjogXCLwnZSuXCIsXG4gICAgICBxaW50OiBcIuKojFwiLFxuICAgICAgUW9wZjogXCLihJpcIixcbiAgICAgIHFvcGY6IFwi8J2VolwiLFxuICAgICAgcXByaW1lOiBcIuKBl1wiLFxuICAgICAgUXNjcjogXCLwnZKsXCIsXG4gICAgICBxc2NyOiBcIvCdk4ZcIixcbiAgICAgIHF1YXRlcm5pb25zOiBcIuKEjVwiLFxuICAgICAgcXVhdGludDogXCLiqJZcIixcbiAgICAgIHF1ZXN0OiBcIj9cIixcbiAgICAgIHF1ZXN0ZXE6IFwi4omfXCIsXG4gICAgICBRVU9UOiAnXCInLFxuICAgICAgcXVvdDogJ1wiJyxcbiAgICAgIHJBYXJyOiBcIuKHm1wiLFxuICAgICAgcmFjZTogXCLiiL3MsVwiLFxuICAgICAgUmFjdXRlOiBcIsWUXCIsXG4gICAgICByYWN1dGU6IFwixZVcIixcbiAgICAgIHJhZGljOiBcIuKImlwiLFxuICAgICAgcmFlbXB0eXY6IFwi4qazXCIsXG4gICAgICBSYW5nOiBcIuKfq1wiLFxuICAgICAgcmFuZzogXCLin6lcIixcbiAgICAgIHJhbmdkOiBcIuKmklwiLFxuICAgICAgcmFuZ2U6IFwi4qalXCIsXG4gICAgICByYW5nbGU6IFwi4p+pXCIsXG4gICAgICByYXF1bzogXCLCu1wiLFxuICAgICAgUmFycjogXCLihqBcIixcbiAgICAgIHJBcnI6IFwi4oeSXCIsXG4gICAgICByYXJyOiBcIuKGklwiLFxuICAgICAgcmFycmFwOiBcIuKltVwiLFxuICAgICAgcmFycmI6IFwi4oelXCIsXG4gICAgICByYXJyYmZzOiBcIuKkoFwiLFxuICAgICAgcmFycmM6IFwi4qSzXCIsXG4gICAgICByYXJyZnM6IFwi4qSeXCIsXG4gICAgICByYXJyaGs6IFwi4oaqXCIsXG4gICAgICByYXJybHA6IFwi4oasXCIsXG4gICAgICByYXJycGw6IFwi4qWFXCIsXG4gICAgICByYXJyc2ltOiBcIuKltFwiLFxuICAgICAgUmFycnRsOiBcIuKkllwiLFxuICAgICAgcmFycnRsOiBcIuKGo1wiLFxuICAgICAgcmFycnc6IFwi4oadXCIsXG4gICAgICByQXRhaWw6IFwi4qScXCIsXG4gICAgICByYXRhaWw6IFwi4qSaXCIsXG4gICAgICByYXRpbzogXCLiiLZcIixcbiAgICAgIHJhdGlvbmFsczogXCLihJpcIixcbiAgICAgIFJCYXJyOiBcIuKkkFwiLFxuICAgICAgckJhcnI6IFwi4qSPXCIsXG4gICAgICByYmFycjogXCLipI1cIixcbiAgICAgIHJiYnJrOiBcIuKds1wiLFxuICAgICAgcmJyYWNlOiBcIn1cIixcbiAgICAgIHJicmFjazogXCJdXCIsXG4gICAgICByYnJrZTogXCLipoxcIixcbiAgICAgIHJicmtzbGQ6IFwi4qaOXCIsXG4gICAgICByYnJrc2x1OiBcIuKmkFwiLFxuICAgICAgUmNhcm9uOiBcIsWYXCIsXG4gICAgICByY2Fyb246IFwixZlcIixcbiAgICAgIFJjZWRpbDogXCLFllwiLFxuICAgICAgcmNlZGlsOiBcIsWXXCIsXG4gICAgICByY2VpbDogXCLijIlcIixcbiAgICAgIHJjdWI6IFwifVwiLFxuICAgICAgUmN5OiBcItCgXCIsXG4gICAgICByY3k6IFwi0YBcIixcbiAgICAgIHJkY2E6IFwi4qS3XCIsXG4gICAgICByZGxkaGFyOiBcIuKlqVwiLFxuICAgICAgcmRxdW86IFwi4oCdXCIsXG4gICAgICByZHF1b3I6IFwi4oCdXCIsXG4gICAgICByZHNoOiBcIuKGs1wiLFxuICAgICAgUmU6IFwi4oScXCIsXG4gICAgICByZWFsOiBcIuKEnFwiLFxuICAgICAgcmVhbGluZTogXCLihJtcIixcbiAgICAgIHJlYWxwYXJ0OiBcIuKEnFwiLFxuICAgICAgcmVhbHM6IFwi4oSdXCIsXG4gICAgICByZWN0OiBcIuKWrVwiLFxuICAgICAgUkVHOiBcIsKuXCIsXG4gICAgICByZWc6IFwiwq5cIixcbiAgICAgIFJldmVyc2VFbGVtZW50OiBcIuKIi1wiLFxuICAgICAgUmV2ZXJzZUVxdWlsaWJyaXVtOiBcIuKHi1wiLFxuICAgICAgUmV2ZXJzZVVwRXF1aWxpYnJpdW06IFwi4qWvXCIsXG4gICAgICByZmlzaHQ6IFwi4qW9XCIsXG4gICAgICByZmxvb3I6IFwi4oyLXCIsXG4gICAgICBSZnI6IFwi4oScXCIsXG4gICAgICByZnI6IFwi8J2Ur1wiLFxuICAgICAgckhhcjogXCLipaRcIixcbiAgICAgIHJoYXJkOiBcIuKHgVwiLFxuICAgICAgcmhhcnU6IFwi4oeAXCIsXG4gICAgICByaGFydWw6IFwi4qWsXCIsXG4gICAgICBSaG86IFwizqFcIixcbiAgICAgIHJobzogXCLPgVwiLFxuICAgICAgcmhvdjogXCLPsVwiLFxuICAgICAgUmlnaHRBbmdsZUJyYWNrZXQ6IFwi4p+pXCIsXG4gICAgICBSaWdodEFycm93OiBcIuKGklwiLFxuICAgICAgUmlnaHRhcnJvdzogXCLih5JcIixcbiAgICAgIHJpZ2h0YXJyb3c6IFwi4oaSXCIsXG4gICAgICBSaWdodEFycm93QmFyOiBcIuKHpVwiLFxuICAgICAgUmlnaHRBcnJvd0xlZnRBcnJvdzogXCLih4RcIixcbiAgICAgIHJpZ2h0YXJyb3d0YWlsOiBcIuKGo1wiLFxuICAgICAgUmlnaHRDZWlsaW5nOiBcIuKMiVwiLFxuICAgICAgUmlnaHREb3VibGVCcmFja2V0OiBcIuKfp1wiLFxuICAgICAgUmlnaHREb3duVGVlVmVjdG9yOiBcIuKlnVwiLFxuICAgICAgUmlnaHREb3duVmVjdG9yOiBcIuKHglwiLFxuICAgICAgUmlnaHREb3duVmVjdG9yQmFyOiBcIuKllVwiLFxuICAgICAgUmlnaHRGbG9vcjogXCLijItcIixcbiAgICAgIHJpZ2h0aGFycG9vbmRvd246IFwi4oeBXCIsXG4gICAgICByaWdodGhhcnBvb251cDogXCLih4BcIixcbiAgICAgIHJpZ2h0bGVmdGFycm93czogXCLih4RcIixcbiAgICAgIHJpZ2h0bGVmdGhhcnBvb25zOiBcIuKHjFwiLFxuICAgICAgcmlnaHRyaWdodGFycm93czogXCLih4lcIixcbiAgICAgIHJpZ2h0c3F1aWdhcnJvdzogXCLihp1cIixcbiAgICAgIFJpZ2h0VGVlOiBcIuKKolwiLFxuICAgICAgUmlnaHRUZWVBcnJvdzogXCLihqZcIixcbiAgICAgIFJpZ2h0VGVlVmVjdG9yOiBcIuKlm1wiLFxuICAgICAgcmlnaHR0aHJlZXRpbWVzOiBcIuKLjFwiLFxuICAgICAgUmlnaHRUcmlhbmdsZTogXCLiirNcIixcbiAgICAgIFJpZ2h0VHJpYW5nbGVCYXI6IFwi4qeQXCIsXG4gICAgICBSaWdodFRyaWFuZ2xlRXF1YWw6IFwi4oq1XCIsXG4gICAgICBSaWdodFVwRG93blZlY3RvcjogXCLipY9cIixcbiAgICAgIFJpZ2h0VXBUZWVWZWN0b3I6IFwi4qWcXCIsXG4gICAgICBSaWdodFVwVmVjdG9yOiBcIuKGvlwiLFxuICAgICAgUmlnaHRVcFZlY3RvckJhcjogXCLipZRcIixcbiAgICAgIFJpZ2h0VmVjdG9yOiBcIuKHgFwiLFxuICAgICAgUmlnaHRWZWN0b3JCYXI6IFwi4qWTXCIsXG4gICAgICByaW5nOiBcIsuaXCIsXG4gICAgICByaXNpbmdkb3RzZXE6IFwi4omTXCIsXG4gICAgICBybGFycjogXCLih4RcIixcbiAgICAgIHJsaGFyOiBcIuKHjFwiLFxuICAgICAgcmxtOiBcIuKAj1wiLFxuICAgICAgcm1vdXN0OiBcIuKOsVwiLFxuICAgICAgcm1vdXN0YWNoZTogXCLijrFcIixcbiAgICAgIHJubWlkOiBcIuKrrlwiLFxuICAgICAgcm9hbmc6IFwi4p+tXCIsXG4gICAgICByb2FycjogXCLih75cIixcbiAgICAgIHJvYnJrOiBcIuKfp1wiLFxuICAgICAgcm9wYXI6IFwi4qaGXCIsXG4gICAgICBSb3BmOiBcIuKEnVwiLFxuICAgICAgcm9wZjogXCLwnZWjXCIsXG4gICAgICByb3BsdXM6IFwi4qiuXCIsXG4gICAgICByb3RpbWVzOiBcIuKotVwiLFxuICAgICAgUm91bmRJbXBsaWVzOiBcIuKlsFwiLFxuICAgICAgcnBhcjogXCIpXCIsXG4gICAgICBycGFyZ3Q6IFwi4qaUXCIsXG4gICAgICBycHBvbGludDogXCLiqJJcIixcbiAgICAgIHJyYXJyOiBcIuKHiVwiLFxuICAgICAgUnJpZ2h0YXJyb3c6IFwi4oebXCIsXG4gICAgICByc2FxdW86IFwi4oC6XCIsXG4gICAgICBSc2NyOiBcIuKEm1wiLFxuICAgICAgcnNjcjogXCLwnZOHXCIsXG4gICAgICBSc2g6IFwi4oaxXCIsXG4gICAgICByc2g6IFwi4oaxXCIsXG4gICAgICByc3FiOiBcIl1cIixcbiAgICAgIHJzcXVvOiBcIuKAmVwiLFxuICAgICAgcnNxdW9yOiBcIuKAmVwiLFxuICAgICAgcnRocmVlOiBcIuKLjFwiLFxuICAgICAgcnRpbWVzOiBcIuKLilwiLFxuICAgICAgcnRyaTogXCLilrlcIixcbiAgICAgIHJ0cmllOiBcIuKKtVwiLFxuICAgICAgcnRyaWY6IFwi4pa4XCIsXG4gICAgICBydHJpbHRyaTogXCLip45cIixcbiAgICAgIFJ1bGVEZWxheWVkOiBcIuKntFwiLFxuICAgICAgcnVsdWhhcjogXCLipahcIixcbiAgICAgIHJ4OiBcIuKEnlwiLFxuICAgICAgU2FjdXRlOiBcIsWaXCIsXG4gICAgICBzYWN1dGU6IFwixZtcIixcbiAgICAgIHNicXVvOiBcIuKAmlwiLFxuICAgICAgU2M6IFwi4qq8XCIsXG4gICAgICBzYzogXCLiibtcIixcbiAgICAgIHNjYXA6IFwi4qq4XCIsXG4gICAgICBTY2Fyb246IFwixaBcIixcbiAgICAgIHNjYXJvbjogXCLFoVwiLFxuICAgICAgc2NjdWU6IFwi4om9XCIsXG4gICAgICBzY0U6IFwi4qq0XCIsXG4gICAgICBzY2U6IFwi4qqwXCIsXG4gICAgICBTY2VkaWw6IFwixZ5cIixcbiAgICAgIHNjZWRpbDogXCLFn1wiLFxuICAgICAgU2NpcmM6IFwixZxcIixcbiAgICAgIHNjaXJjOiBcIsWdXCIsXG4gICAgICBzY25hcDogXCLiqrpcIixcbiAgICAgIHNjbkU6IFwi4qq2XCIsXG4gICAgICBzY25zaW06IFwi4oupXCIsXG4gICAgICBzY3BvbGludDogXCLiqJNcIixcbiAgICAgIHNjc2ltOiBcIuKJv1wiLFxuICAgICAgU2N5OiBcItChXCIsXG4gICAgICBzY3k6IFwi0YFcIixcbiAgICAgIHNkb3Q6IFwi4ouFXCIsXG4gICAgICBzZG90YjogXCLiiqFcIixcbiAgICAgIHNkb3RlOiBcIuKpplwiLFxuICAgICAgc2VhcmhrOiBcIuKkpVwiLFxuICAgICAgc2VBcnI6IFwi4oeYXCIsXG4gICAgICBzZWFycjogXCLihphcIixcbiAgICAgIHNlYXJyb3c6IFwi4oaYXCIsXG4gICAgICBzZWN0OiBcIsKnXCIsXG4gICAgICBzZW1pOiBcIjtcIixcbiAgICAgIHNlc3dhcjogXCLipKlcIixcbiAgICAgIHNldG1pbnVzOiBcIuKIllwiLFxuICAgICAgc2V0bW46IFwi4oiWXCIsXG4gICAgICBzZXh0OiBcIuKctlwiLFxuICAgICAgU2ZyOiBcIvCdlJZcIixcbiAgICAgIHNmcjogXCLwnZSwXCIsXG4gICAgICBzZnJvd246IFwi4oyiXCIsXG4gICAgICBzaGFycDogXCLima9cIixcbiAgICAgIFNIQ0hjeTogXCLQqVwiLFxuICAgICAgc2hjaGN5OiBcItGJXCIsXG4gICAgICBTSGN5OiBcItCoXCIsXG4gICAgICBzaGN5OiBcItGIXCIsXG4gICAgICBTaG9ydERvd25BcnJvdzogXCLihpNcIixcbiAgICAgIFNob3J0TGVmdEFycm93OiBcIuKGkFwiLFxuICAgICAgc2hvcnRtaWQ6IFwi4oijXCIsXG4gICAgICBzaG9ydHBhcmFsbGVsOiBcIuKIpVwiLFxuICAgICAgU2hvcnRSaWdodEFycm93OiBcIuKGklwiLFxuICAgICAgU2hvcnRVcEFycm93OiBcIuKGkVwiLFxuICAgICAgc2h5OiBcIsKtXCIsXG4gICAgICBTaWdtYTogXCLOo1wiLFxuICAgICAgc2lnbWE6IFwiz4NcIixcbiAgICAgIHNpZ21hZjogXCLPglwiLFxuICAgICAgc2lnbWF2OiBcIs+CXCIsXG4gICAgICBzaW06IFwi4oi8XCIsXG4gICAgICBzaW1kb3Q6IFwi4qmqXCIsXG4gICAgICBzaW1lOiBcIuKJg1wiLFxuICAgICAgc2ltZXE6IFwi4omDXCIsXG4gICAgICBzaW1nOiBcIuKqnlwiLFxuICAgICAgc2ltZ0U6IFwi4qqgXCIsXG4gICAgICBzaW1sOiBcIuKqnVwiLFxuICAgICAgc2ltbEU6IFwi4qqfXCIsXG4gICAgICBzaW1uZTogXCLiiYZcIixcbiAgICAgIHNpbXBsdXM6IFwi4qikXCIsXG4gICAgICBzaW1yYXJyOiBcIuKlslwiLFxuICAgICAgc2xhcnI6IFwi4oaQXCIsXG4gICAgICBTbWFsbENpcmNsZTogXCLiiJhcIixcbiAgICAgIHNtYWxsc2V0bWludXM6IFwi4oiWXCIsXG4gICAgICBzbWFzaHA6IFwi4qizXCIsXG4gICAgICBzbWVwYXJzbDogXCLip6RcIixcbiAgICAgIHNtaWQ6IFwi4oijXCIsXG4gICAgICBzbWlsZTogXCLijKNcIixcbiAgICAgIHNtdDogXCLiqqpcIixcbiAgICAgIHNtdGU6IFwi4qqsXCIsXG4gICAgICBzbXRlczogXCLiqqzvuIBcIixcbiAgICAgIFNPRlRjeTogXCLQrFwiLFxuICAgICAgc29mdGN5OiBcItGMXCIsXG4gICAgICBzb2w6IFwiL1wiLFxuICAgICAgc29sYjogXCLip4RcIixcbiAgICAgIHNvbGJhcjogXCLijL9cIixcbiAgICAgIFNvcGY6IFwi8J2VilwiLFxuICAgICAgc29wZjogXCLwnZWkXCIsXG4gICAgICBzcGFkZXM6IFwi4pmgXCIsXG4gICAgICBzcGFkZXN1aXQ6IFwi4pmgXCIsXG4gICAgICBzcGFyOiBcIuKIpVwiLFxuICAgICAgc3FjYXA6IFwi4oqTXCIsXG4gICAgICBzcWNhcHM6IFwi4oqT77iAXCIsXG4gICAgICBzcWN1cDogXCLiipRcIixcbiAgICAgIHNxY3VwczogXCLiipTvuIBcIixcbiAgICAgIFNxcnQ6IFwi4oiaXCIsXG4gICAgICBzcXN1YjogXCLiio9cIixcbiAgICAgIHNxc3ViZTogXCLiipFcIixcbiAgICAgIHNxc3Vic2V0OiBcIuKKj1wiLFxuICAgICAgc3FzdWJzZXRlcTogXCLiipFcIixcbiAgICAgIHNxc3VwOiBcIuKKkFwiLFxuICAgICAgc3FzdXBlOiBcIuKKklwiLFxuICAgICAgc3FzdXBzZXQ6IFwi4oqQXCIsXG4gICAgICBzcXN1cHNldGVxOiBcIuKKklwiLFxuICAgICAgc3F1OiBcIuKWoVwiLFxuICAgICAgU3F1YXJlOiBcIuKWoVwiLFxuICAgICAgc3F1YXJlOiBcIuKWoVwiLFxuICAgICAgU3F1YXJlSW50ZXJzZWN0aW9uOiBcIuKKk1wiLFxuICAgICAgU3F1YXJlU3Vic2V0OiBcIuKKj1wiLFxuICAgICAgU3F1YXJlU3Vic2V0RXF1YWw6IFwi4oqRXCIsXG4gICAgICBTcXVhcmVTdXBlcnNldDogXCLiipBcIixcbiAgICAgIFNxdWFyZVN1cGVyc2V0RXF1YWw6IFwi4oqSXCIsXG4gICAgICBTcXVhcmVVbmlvbjogXCLiipRcIixcbiAgICAgIHNxdWFyZjogXCLilqpcIixcbiAgICAgIHNxdWY6IFwi4paqXCIsXG4gICAgICBzcmFycjogXCLihpJcIixcbiAgICAgIFNzY3I6IFwi8J2SrlwiLFxuICAgICAgc3NjcjogXCLwnZOIXCIsXG4gICAgICBzc2V0bW46IFwi4oiWXCIsXG4gICAgICBzc21pbGU6IFwi4oyjXCIsXG4gICAgICBzc3RhcmY6IFwi4ouGXCIsXG4gICAgICBTdGFyOiBcIuKLhlwiLFxuICAgICAgc3RhcjogXCLimIZcIixcbiAgICAgIHN0YXJmOiBcIuKYhVwiLFxuICAgICAgc3RyYWlnaHRlcHNpbG9uOiBcIs+1XCIsXG4gICAgICBzdHJhaWdodHBoaTogXCLPlVwiLFxuICAgICAgc3RybnM6IFwiwq9cIixcbiAgICAgIFN1YjogXCLii5BcIixcbiAgICAgIHN1YjogXCLiioJcIixcbiAgICAgIHN1YmRvdDogXCLiqr1cIixcbiAgICAgIHN1YkU6IFwi4quFXCIsXG4gICAgICBzdWJlOiBcIuKKhlwiLFxuICAgICAgc3ViZWRvdDogXCLiq4NcIixcbiAgICAgIHN1Ym11bHQ6IFwi4quBXCIsXG4gICAgICBzdWJuRTogXCLiq4tcIixcbiAgICAgIHN1Ym5lOiBcIuKKilwiLFxuICAgICAgc3VicGx1czogXCLiqr9cIixcbiAgICAgIHN1YnJhcnI6IFwi4qW5XCIsXG4gICAgICBTdWJzZXQ6IFwi4ouQXCIsXG4gICAgICBzdWJzZXQ6IFwi4oqCXCIsXG4gICAgICBzdWJzZXRlcTogXCLiioZcIixcbiAgICAgIHN1YnNldGVxcTogXCLiq4VcIixcbiAgICAgIFN1YnNldEVxdWFsOiBcIuKKhlwiLFxuICAgICAgc3Vic2V0bmVxOiBcIuKKilwiLFxuICAgICAgc3Vic2V0bmVxcTogXCLiq4tcIixcbiAgICAgIHN1YnNpbTogXCLiq4dcIixcbiAgICAgIHN1YnN1YjogXCLiq5VcIixcbiAgICAgIHN1YnN1cDogXCLiq5NcIixcbiAgICAgIHN1Y2M6IFwi4om7XCIsXG4gICAgICBzdWNjYXBwcm94OiBcIuKquFwiLFxuICAgICAgc3VjY2N1cmx5ZXE6IFwi4om9XCIsXG4gICAgICBTdWNjZWVkczogXCLiibtcIixcbiAgICAgIFN1Y2NlZWRzRXF1YWw6IFwi4qqwXCIsXG4gICAgICBTdWNjZWVkc1NsYW50RXF1YWw6IFwi4om9XCIsXG4gICAgICBTdWNjZWVkc1RpbGRlOiBcIuKJv1wiLFxuICAgICAgc3VjY2VxOiBcIuKqsFwiLFxuICAgICAgc3VjY25hcHByb3g6IFwi4qq6XCIsXG4gICAgICBzdWNjbmVxcTogXCLiqrZcIixcbiAgICAgIHN1Y2Nuc2ltOiBcIuKLqVwiLFxuICAgICAgc3VjY3NpbTogXCLiib9cIixcbiAgICAgIFN1Y2hUaGF0OiBcIuKIi1wiLFxuICAgICAgU3VtOiBcIuKIkVwiLFxuICAgICAgc3VtOiBcIuKIkVwiLFxuICAgICAgc3VuZzogXCLimapcIixcbiAgICAgIFN1cDogXCLii5FcIixcbiAgICAgIHN1cDogXCLiioNcIixcbiAgICAgIHN1cDE6IFwiwrlcIixcbiAgICAgIHN1cDI6IFwiwrJcIixcbiAgICAgIHN1cDM6IFwiwrNcIixcbiAgICAgIHN1cGRvdDogXCLiqr5cIixcbiAgICAgIHN1cGRzdWI6IFwi4quYXCIsXG4gICAgICBzdXBFOiBcIuKrhlwiLFxuICAgICAgc3VwZTogXCLiiodcIixcbiAgICAgIHN1cGVkb3Q6IFwi4quEXCIsXG4gICAgICBTdXBlcnNldDogXCLiioNcIixcbiAgICAgIFN1cGVyc2V0RXF1YWw6IFwi4oqHXCIsXG4gICAgICBzdXBoc29sOiBcIuKfiVwiLFxuICAgICAgc3VwaHN1YjogXCLiq5dcIixcbiAgICAgIHN1cGxhcnI6IFwi4qW7XCIsXG4gICAgICBzdXBtdWx0OiBcIuKrglwiLFxuICAgICAgc3VwbkU6IFwi4quMXCIsXG4gICAgICBzdXBuZTogXCLiiotcIixcbiAgICAgIHN1cHBsdXM6IFwi4quAXCIsXG4gICAgICBTdXBzZXQ6IFwi4ouRXCIsXG4gICAgICBzdXBzZXQ6IFwi4oqDXCIsXG4gICAgICBzdXBzZXRlcTogXCLiiodcIixcbiAgICAgIHN1cHNldGVxcTogXCLiq4ZcIixcbiAgICAgIHN1cHNldG5lcTogXCLiiotcIixcbiAgICAgIHN1cHNldG5lcXE6IFwi4quMXCIsXG4gICAgICBzdXBzaW06IFwi4quIXCIsXG4gICAgICBzdXBzdWI6IFwi4quUXCIsXG4gICAgICBzdXBzdXA6IFwi4quWXCIsXG4gICAgICBzd2FyaGs6IFwi4qSmXCIsXG4gICAgICBzd0FycjogXCLih5lcIixcbiAgICAgIHN3YXJyOiBcIuKGmVwiLFxuICAgICAgc3dhcnJvdzogXCLihplcIixcbiAgICAgIHN3bndhcjogXCLipKpcIixcbiAgICAgIHN6bGlnOiBcIsOfXCIsXG4gICAgICBUYWI6IFwiXHRcIixcbiAgICAgIHRhcmdldDogXCLijJZcIixcbiAgICAgIFRhdTogXCLOpFwiLFxuICAgICAgdGF1OiBcIs+EXCIsXG4gICAgICB0YnJrOiBcIuKOtFwiLFxuICAgICAgVGNhcm9uOiBcIsWkXCIsXG4gICAgICB0Y2Fyb246IFwixaVcIixcbiAgICAgIFRjZWRpbDogXCLFolwiLFxuICAgICAgdGNlZGlsOiBcIsWjXCIsXG4gICAgICBUY3k6IFwi0KJcIixcbiAgICAgIHRjeTogXCLRglwiLFxuICAgICAgdGRvdDogXCLig5tcIixcbiAgICAgIHRlbHJlYzogXCLijJVcIixcbiAgICAgIFRmcjogXCLwnZSXXCIsXG4gICAgICB0ZnI6IFwi8J2UsVwiLFxuICAgICAgdGhlcmU0OiBcIuKItFwiLFxuICAgICAgVGhlcmVmb3JlOiBcIuKItFwiLFxuICAgICAgdGhlcmVmb3JlOiBcIuKItFwiLFxuICAgICAgVGhldGE6IFwizphcIixcbiAgICAgIHRoZXRhOiBcIs64XCIsXG4gICAgICB0aGV0YXN5bTogXCLPkVwiLFxuICAgICAgdGhldGF2OiBcIs+RXCIsXG4gICAgICB0aGlja2FwcHJveDogXCLiiYhcIixcbiAgICAgIHRoaWNrc2ltOiBcIuKIvFwiLFxuICAgICAgVGhpY2tTcGFjZTogXCLigZ/igIpcIixcbiAgICAgIHRoaW5zcDogXCLigIlcIixcbiAgICAgIFRoaW5TcGFjZTogXCLigIlcIixcbiAgICAgIHRoa2FwOiBcIuKJiFwiLFxuICAgICAgdGhrc2ltOiBcIuKIvFwiLFxuICAgICAgVEhPUk46IFwiw55cIixcbiAgICAgIHRob3JuOiBcIsO+XCIsXG4gICAgICBUaWxkZTogXCLiiLxcIixcbiAgICAgIHRpbGRlOiBcIsucXCIsXG4gICAgICBUaWxkZUVxdWFsOiBcIuKJg1wiLFxuICAgICAgVGlsZGVGdWxsRXF1YWw6IFwi4omFXCIsXG4gICAgICBUaWxkZVRpbGRlOiBcIuKJiFwiLFxuICAgICAgdGltZXM6IFwiw5dcIixcbiAgICAgIHRpbWVzYjogXCLiiqBcIixcbiAgICAgIHRpbWVzYmFyOiBcIuKosVwiLFxuICAgICAgdGltZXNkOiBcIuKosFwiLFxuICAgICAgdGludDogXCLiiK1cIixcbiAgICAgIHRvZWE6IFwi4qSoXCIsXG4gICAgICB0b3A6IFwi4oqkXCIsXG4gICAgICB0b3Bib3Q6IFwi4oy2XCIsXG4gICAgICB0b3BjaXI6IFwi4quxXCIsXG4gICAgICBUb3BmOiBcIvCdlYtcIixcbiAgICAgIHRvcGY6IFwi8J2VpVwiLFxuICAgICAgdG9wZm9yazogXCLiq5pcIixcbiAgICAgIHRvc2E6IFwi4qSpXCIsXG4gICAgICB0cHJpbWU6IFwi4oC0XCIsXG4gICAgICBUUkFERTogXCLihKJcIixcbiAgICAgIHRyYWRlOiBcIuKEolwiLFxuICAgICAgdHJpYW5nbGU6IFwi4pa1XCIsXG4gICAgICB0cmlhbmdsZWRvd246IFwi4pa/XCIsXG4gICAgICB0cmlhbmdsZWxlZnQ6IFwi4peDXCIsXG4gICAgICB0cmlhbmdsZWxlZnRlcTogXCLiirRcIixcbiAgICAgIHRyaWFuZ2xlcTogXCLiiZxcIixcbiAgICAgIHRyaWFuZ2xlcmlnaHQ6IFwi4pa5XCIsXG4gICAgICB0cmlhbmdsZXJpZ2h0ZXE6IFwi4oq1XCIsXG4gICAgICB0cmlkb3Q6IFwi4pesXCIsXG4gICAgICB0cmllOiBcIuKJnFwiLFxuICAgICAgdHJpbWludXM6IFwi4qi6XCIsXG4gICAgICBUcmlwbGVEb3Q6IFwi4oObXCIsXG4gICAgICB0cmlwbHVzOiBcIuKouVwiLFxuICAgICAgdHJpc2I6IFwi4qeNXCIsXG4gICAgICB0cml0aW1lOiBcIuKou1wiLFxuICAgICAgdHJwZXppdW06IFwi4o+iXCIsXG4gICAgICBUc2NyOiBcIvCdkq9cIixcbiAgICAgIHRzY3I6IFwi8J2TiVwiLFxuICAgICAgVFNjeTogXCLQplwiLFxuICAgICAgdHNjeTogXCLRhlwiLFxuICAgICAgVFNIY3k6IFwi0ItcIixcbiAgICAgIHRzaGN5OiBcItGbXCIsXG4gICAgICBUc3Ryb2s6IFwixaZcIixcbiAgICAgIHRzdHJvazogXCLFp1wiLFxuICAgICAgdHdpeHQ6IFwi4omsXCIsXG4gICAgICB0d29oZWFkbGVmdGFycm93OiBcIuKGnlwiLFxuICAgICAgdHdvaGVhZHJpZ2h0YXJyb3c6IFwi4oagXCIsXG4gICAgICBVYWN1dGU6IFwiw5pcIixcbiAgICAgIHVhY3V0ZTogXCLDulwiLFxuICAgICAgVWFycjogXCLihp9cIixcbiAgICAgIHVBcnI6IFwi4oeRXCIsXG4gICAgICB1YXJyOiBcIuKGkVwiLFxuICAgICAgVWFycm9jaXI6IFwi4qWJXCIsXG4gICAgICBVYnJjeTogXCLQjlwiLFxuICAgICAgdWJyY3k6IFwi0Z5cIixcbiAgICAgIFVicmV2ZTogXCLFrFwiLFxuICAgICAgdWJyZXZlOiBcIsWtXCIsXG4gICAgICBVY2lyYzogXCLDm1wiLFxuICAgICAgdWNpcmM6IFwiw7tcIixcbiAgICAgIFVjeTogXCLQo1wiLFxuICAgICAgdWN5OiBcItGDXCIsXG4gICAgICB1ZGFycjogXCLih4VcIixcbiAgICAgIFVkYmxhYzogXCLFsFwiLFxuICAgICAgdWRibGFjOiBcIsWxXCIsXG4gICAgICB1ZGhhcjogXCLipa5cIixcbiAgICAgIHVmaXNodDogXCLipb5cIixcbiAgICAgIFVmcjogXCLwnZSYXCIsXG4gICAgICB1ZnI6IFwi8J2UslwiLFxuICAgICAgVWdyYXZlOiBcIsOZXCIsXG4gICAgICB1Z3JhdmU6IFwiw7lcIixcbiAgICAgIHVIYXI6IFwi4qWjXCIsXG4gICAgICB1aGFybDogXCLihr9cIixcbiAgICAgIHVoYXJyOiBcIuKGvlwiLFxuICAgICAgdWhibGs6IFwi4paAXCIsXG4gICAgICB1bGNvcm46IFwi4oycXCIsXG4gICAgICB1bGNvcm5lcjogXCLijJxcIixcbiAgICAgIHVsY3JvcDogXCLijI9cIixcbiAgICAgIHVsdHJpOiBcIuKXuFwiLFxuICAgICAgVW1hY3I6IFwixapcIixcbiAgICAgIHVtYWNyOiBcIsWrXCIsXG4gICAgICB1bWw6IFwiwqhcIixcbiAgICAgIFVuZGVyQmFyOiBcIl9cIixcbiAgICAgIFVuZGVyQnJhY2U6IFwi4o+fXCIsXG4gICAgICBVbmRlckJyYWNrZXQ6IFwi4o61XCIsXG4gICAgICBVbmRlclBhcmVudGhlc2lzOiBcIuKPnVwiLFxuICAgICAgVW5pb246IFwi4ouDXCIsXG4gICAgICBVbmlvblBsdXM6IFwi4oqOXCIsXG4gICAgICBVb2dvbjogXCLFslwiLFxuICAgICAgdW9nb246IFwixbNcIixcbiAgICAgIFVvcGY6IFwi8J2VjFwiLFxuICAgICAgdW9wZjogXCLwnZWmXCIsXG4gICAgICBVcEFycm93OiBcIuKGkVwiLFxuICAgICAgVXBhcnJvdzogXCLih5FcIixcbiAgICAgIHVwYXJyb3c6IFwi4oaRXCIsXG4gICAgICBVcEFycm93QmFyOiBcIuKkklwiLFxuICAgICAgVXBBcnJvd0Rvd25BcnJvdzogXCLih4VcIixcbiAgICAgIFVwRG93bkFycm93OiBcIuKGlVwiLFxuICAgICAgVXBkb3duYXJyb3c6IFwi4oeVXCIsXG4gICAgICB1cGRvd25hcnJvdzogXCLihpVcIixcbiAgICAgIFVwRXF1aWxpYnJpdW06IFwi4qWuXCIsXG4gICAgICB1cGhhcnBvb25sZWZ0OiBcIuKGv1wiLFxuICAgICAgdXBoYXJwb29ucmlnaHQ6IFwi4oa+XCIsXG4gICAgICB1cGx1czogXCLiio5cIixcbiAgICAgIFVwcGVyTGVmdEFycm93OiBcIuKGllwiLFxuICAgICAgVXBwZXJSaWdodEFycm93OiBcIuKGl1wiLFxuICAgICAgVXBzaTogXCLPklwiLFxuICAgICAgdXBzaTogXCLPhVwiLFxuICAgICAgdXBzaWg6IFwiz5JcIixcbiAgICAgIFVwc2lsb246IFwizqVcIixcbiAgICAgIHVwc2lsb246IFwiz4VcIixcbiAgICAgIFVwVGVlOiBcIuKKpVwiLFxuICAgICAgVXBUZWVBcnJvdzogXCLihqVcIixcbiAgICAgIHVwdXBhcnJvd3M6IFwi4oeIXCIsXG4gICAgICB1cmNvcm46IFwi4oydXCIsXG4gICAgICB1cmNvcm5lcjogXCLijJ1cIixcbiAgICAgIHVyY3JvcDogXCLijI5cIixcbiAgICAgIFVyaW5nOiBcIsWuXCIsXG4gICAgICB1cmluZzogXCLFr1wiLFxuICAgICAgdXJ0cmk6IFwi4pe5XCIsXG4gICAgICBVc2NyOiBcIvCdkrBcIixcbiAgICAgIHVzY3I6IFwi8J2TilwiLFxuICAgICAgdXRkb3Q6IFwi4ouwXCIsXG4gICAgICBVdGlsZGU6IFwixahcIixcbiAgICAgIHV0aWxkZTogXCLFqVwiLFxuICAgICAgdXRyaTogXCLilrVcIixcbiAgICAgIHV0cmlmOiBcIuKWtFwiLFxuICAgICAgdXVhcnI6IFwi4oeIXCIsXG4gICAgICBVdW1sOiBcIsOcXCIsXG4gICAgICB1dW1sOiBcIsO8XCIsXG4gICAgICB1d2FuZ2xlOiBcIuKmp1wiLFxuICAgICAgdmFuZ3J0OiBcIuKmnFwiLFxuICAgICAgdmFyZXBzaWxvbjogXCLPtVwiLFxuICAgICAgdmFya2FwcGE6IFwiz7BcIixcbiAgICAgIHZhcm5vdGhpbmc6IFwi4oiFXCIsXG4gICAgICB2YXJwaGk6IFwiz5VcIixcbiAgICAgIHZhcnBpOiBcIs+WXCIsXG4gICAgICB2YXJwcm9wdG86IFwi4oidXCIsXG4gICAgICB2QXJyOiBcIuKHlVwiLFxuICAgICAgdmFycjogXCLihpVcIixcbiAgICAgIHZhcnJobzogXCLPsVwiLFxuICAgICAgdmFyc2lnbWE6IFwiz4JcIixcbiAgICAgIHZhcnN1YnNldG5lcTogXCLiiorvuIBcIixcbiAgICAgIHZhcnN1YnNldG5lcXE6IFwi4quL77iAXCIsXG4gICAgICB2YXJzdXBzZXRuZXE6IFwi4oqL77iAXCIsXG4gICAgICB2YXJzdXBzZXRuZXFxOiBcIuKrjO+4gFwiLFxuICAgICAgdmFydGhldGE6IFwiz5FcIixcbiAgICAgIHZhcnRyaWFuZ2xlbGVmdDogXCLiirJcIixcbiAgICAgIHZhcnRyaWFuZ2xlcmlnaHQ6IFwi4oqzXCIsXG4gICAgICBWYmFyOiBcIuKrq1wiLFxuICAgICAgdkJhcjogXCLiq6hcIixcbiAgICAgIHZCYXJ2OiBcIuKrqVwiLFxuICAgICAgVmN5OiBcItCSXCIsXG4gICAgICB2Y3k6IFwi0LJcIixcbiAgICAgIFZEYXNoOiBcIuKKq1wiLFxuICAgICAgVmRhc2g6IFwi4oqpXCIsXG4gICAgICB2RGFzaDogXCLiiqhcIixcbiAgICAgIHZkYXNoOiBcIuKKolwiLFxuICAgICAgVmRhc2hsOiBcIuKrplwiLFxuICAgICAgVmVlOiBcIuKLgVwiLFxuICAgICAgdmVlOiBcIuKIqFwiLFxuICAgICAgdmVlYmFyOiBcIuKKu1wiLFxuICAgICAgdmVlZXE6IFwi4omaXCIsXG4gICAgICB2ZWxsaXA6IFwi4ouuXCIsXG4gICAgICBWZXJiYXI6IFwi4oCWXCIsXG4gICAgICB2ZXJiYXI6IFwifFwiLFxuICAgICAgVmVydDogXCLigJZcIixcbiAgICAgIHZlcnQ6IFwifFwiLFxuICAgICAgVmVydGljYWxCYXI6IFwi4oijXCIsXG4gICAgICBWZXJ0aWNhbExpbmU6IFwifFwiLFxuICAgICAgVmVydGljYWxTZXBhcmF0b3I6IFwi4p2YXCIsXG4gICAgICBWZXJ0aWNhbFRpbGRlOiBcIuKJgFwiLFxuICAgICAgVmVyeVRoaW5TcGFjZTogXCLigIpcIixcbiAgICAgIFZmcjogXCLwnZSZXCIsXG4gICAgICB2ZnI6IFwi8J2Us1wiLFxuICAgICAgdmx0cmk6IFwi4oqyXCIsXG4gICAgICB2bnN1YjogXCLiioLig5JcIixcbiAgICAgIHZuc3VwOiBcIuKKg+KDklwiLFxuICAgICAgVm9wZjogXCLwnZWNXCIsXG4gICAgICB2b3BmOiBcIvCdladcIixcbiAgICAgIHZwcm9wOiBcIuKInVwiLFxuICAgICAgdnJ0cmk6IFwi4oqzXCIsXG4gICAgICBWc2NyOiBcIvCdkrFcIixcbiAgICAgIHZzY3I6IFwi8J2Ti1wiLFxuICAgICAgdnN1Ym5FOiBcIuKri++4gFwiLFxuICAgICAgdnN1Ym5lOiBcIuKKiu+4gFwiLFxuICAgICAgdnN1cG5FOiBcIuKrjO+4gFwiLFxuICAgICAgdnN1cG5lOiBcIuKKi++4gFwiLFxuICAgICAgVnZkYXNoOiBcIuKKqlwiLFxuICAgICAgdnppZ3phZzogXCLipppcIixcbiAgICAgIFdjaXJjOiBcIsW0XCIsXG4gICAgICB3Y2lyYzogXCLFtVwiLFxuICAgICAgd2VkYmFyOiBcIuKpn1wiLFxuICAgICAgV2VkZ2U6IFwi4ouAXCIsXG4gICAgICB3ZWRnZTogXCLiiKdcIixcbiAgICAgIHdlZGdlcTogXCLiiZlcIixcbiAgICAgIHdlaWVycDogXCLihJhcIixcbiAgICAgIFdmcjogXCLwnZSaXCIsXG4gICAgICB3ZnI6IFwi8J2UtFwiLFxuICAgICAgV29wZjogXCLwnZWOXCIsXG4gICAgICB3b3BmOiBcIvCdlahcIixcbiAgICAgIHdwOiBcIuKEmFwiLFxuICAgICAgd3I6IFwi4omAXCIsXG4gICAgICB3cmVhdGg6IFwi4omAXCIsXG4gICAgICBXc2NyOiBcIvCdkrJcIixcbiAgICAgIHdzY3I6IFwi8J2TjFwiLFxuICAgICAgeGNhcDogXCLii4JcIixcbiAgICAgIHhjaXJjOiBcIuKXr1wiLFxuICAgICAgeGN1cDogXCLii4NcIixcbiAgICAgIHhkdHJpOiBcIuKWvVwiLFxuICAgICAgWGZyOiBcIvCdlJtcIixcbiAgICAgIHhmcjogXCLwnZS1XCIsXG4gICAgICB4aEFycjogXCLin7pcIixcbiAgICAgIHhoYXJyOiBcIuKft1wiLFxuICAgICAgWGk6IFwizp5cIixcbiAgICAgIHhpOiBcIs6+XCIsXG4gICAgICB4bEFycjogXCLin7hcIixcbiAgICAgIHhsYXJyOiBcIuKftVwiLFxuICAgICAgeG1hcDogXCLin7xcIixcbiAgICAgIHhuaXM6IFwi4ou7XCIsXG4gICAgICB4b2RvdDogXCLiqIBcIixcbiAgICAgIFhvcGY6IFwi8J2Vj1wiLFxuICAgICAgeG9wZjogXCLwnZWpXCIsXG4gICAgICB4b3BsdXM6IFwi4qiBXCIsXG4gICAgICB4b3RpbWU6IFwi4qiCXCIsXG4gICAgICB4ckFycjogXCLin7lcIixcbiAgICAgIHhyYXJyOiBcIuKftlwiLFxuICAgICAgWHNjcjogXCLwnZKzXCIsXG4gICAgICB4c2NyOiBcIvCdk41cIixcbiAgICAgIHhzcWN1cDogXCLiqIZcIixcbiAgICAgIHh1cGx1czogXCLiqIRcIixcbiAgICAgIHh1dHJpOiBcIuKWs1wiLFxuICAgICAgeHZlZTogXCLii4FcIixcbiAgICAgIHh3ZWRnZTogXCLii4BcIixcbiAgICAgIFlhY3V0ZTogXCLDnVwiLFxuICAgICAgeWFjdXRlOiBcIsO9XCIsXG4gICAgICBZQWN5OiBcItCvXCIsXG4gICAgICB5YWN5OiBcItGPXCIsXG4gICAgICBZY2lyYzogXCLFtlwiLFxuICAgICAgeWNpcmM6IFwixbdcIixcbiAgICAgIFljeTogXCLQq1wiLFxuICAgICAgeWN5OiBcItGLXCIsXG4gICAgICB5ZW46IFwiwqVcIixcbiAgICAgIFlmcjogXCLwnZScXCIsXG4gICAgICB5ZnI6IFwi8J2UtlwiLFxuICAgICAgWUljeTogXCLQh1wiLFxuICAgICAgeWljeTogXCLRl1wiLFxuICAgICAgWW9wZjogXCLwnZWQXCIsXG4gICAgICB5b3BmOiBcIvCdlapcIixcbiAgICAgIFlzY3I6IFwi8J2StFwiLFxuICAgICAgeXNjcjogXCLwnZOOXCIsXG4gICAgICBZVWN5OiBcItCuXCIsXG4gICAgICB5dWN5OiBcItGOXCIsXG4gICAgICBZdW1sOiBcIsW4XCIsXG4gICAgICB5dW1sOiBcIsO/XCIsXG4gICAgICBaYWN1dGU6IFwixblcIixcbiAgICAgIHphY3V0ZTogXCLFulwiLFxuICAgICAgWmNhcm9uOiBcIsW9XCIsXG4gICAgICB6Y2Fyb246IFwixb5cIixcbiAgICAgIFpjeTogXCLQl1wiLFxuICAgICAgemN5OiBcItC3XCIsXG4gICAgICBaZG90OiBcIsW7XCIsXG4gICAgICB6ZG90OiBcIsW8XCIsXG4gICAgICB6ZWV0cmY6IFwi4oSoXCIsXG4gICAgICBaZXJvV2lkdGhTcGFjZTogXCLigItcIixcbiAgICAgIFpldGE6IFwizpZcIixcbiAgICAgIHpldGE6IFwizrZcIixcbiAgICAgIFpmcjogXCLihKhcIixcbiAgICAgIHpmcjogXCLwnZS3XCIsXG4gICAgICBaSGN5OiBcItCWXCIsXG4gICAgICB6aGN5OiBcItC2XCIsXG4gICAgICB6aWdyYXJyOiBcIuKHnVwiLFxuICAgICAgWm9wZjogXCLihKRcIixcbiAgICAgIHpvcGY6IFwi8J2Vq1wiLFxuICAgICAgWnNjcjogXCLwnZK1XCIsXG4gICAgICB6c2NyOiBcIvCdk49cIixcbiAgICAgIHp3ajogXCLigI1cIixcbiAgICAgIHp3bmo6IFwi4oCMXCJcbiAgICB9KSwgdC5lbnRpdHlNYXAgPSB0LkhUTUxfRU5USVRJRVM7XG4gIH0oa3QpKSwga3Q7XG59XG52YXIgeXQgPSB7fSwgb3I7XG5mdW5jdGlvbiBBbigpIHtcbiAgaWYgKG9yKSByZXR1cm4geXQ7XG4gIG9yID0gMTtcbiAgdmFyIHQgPSBEdCgpLCBlID0gRnIoKSwgbiA9IF90KCksIGkgPSB0LmlzSFRNTEVzY2FwYWJsZVJhd1RleHRFbGVtZW50LCBvID0gdC5pc0hUTUxNaW1lVHlwZSwgYSA9IHQuaXNIVE1MUmF3VGV4dEVsZW1lbnQsIGggPSB0Lmhhc093biwgcCA9IHQuTkFNRVNQQUNFLCBmID0gbi5QYXJzZUVycm9yLCBtID0gbi5ET01FeGNlcHRpb24sIEUgPSAwLCBsID0gMSwgdiA9IDIsIE8gPSAzLCBiID0gNCwgQyA9IDUsIGogPSA2LCBSID0gNztcbiAgZnVuY3Rpb24gaygpIHtcbiAgfVxuICBrLnByb3RvdHlwZSA9IHtcbiAgICBwYXJzZTogZnVuY3Rpb24oZCwgTiwgdykge1xuICAgICAgdmFyIHkgPSB0aGlzLmRvbUJ1aWxkZXI7XG4gICAgICB5LnN0YXJ0RG9jdW1lbnQoKSwgRyhOLCBOID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpLCBuZShkLCBOLCB3LCB5LCB0aGlzLmVycm9ySGFuZGxlciksIHkuZW5kRG9jdW1lbnQoKTtcbiAgICB9XG4gIH07XG4gIHZhciAkID0gLyYjP1xcdys7Py9nO1xuICBmdW5jdGlvbiBuZShkLCBOLCB3LCB5LCBNKSB7XG4gICAgdmFyIEEgPSBvKHkubWltZVR5cGUpO1xuICAgIGQuaW5kZXhPZihlLlVOSUNPREVfUkVQTEFDRU1FTlRfQ0hBUkFDVEVSKSA+PSAwICYmIE0ud2FybmluZyhcIlVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGRldGVjdGVkLCBzb3VyY2UgZW5jb2RpbmcgaXNzdWVzP1wiKTtcbiAgICBmdW5jdGlvbiBCKHEpIHtcbiAgICAgIGlmIChxID4gNjU1MzUpIHtcbiAgICAgICAgcSAtPSA2NTUzNjtcbiAgICAgICAgdmFyIFogPSA1NTI5NiArIChxID4+IDEwKSwgQWUgPSA1NjMyMCArIChxICYgMTAyMyk7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFosIEFlKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSihxKSB7XG4gICAgICB2YXIgWiA9IHFbcS5sZW5ndGggLSAxXSA9PT0gXCI7XCIgPyBxIDogcSArIFwiO1wiO1xuICAgICAgaWYgKCFBICYmIFogIT09IHEpXG4gICAgICAgIHJldHVybiBNLmVycm9yKFwiRW50aXR5UmVmOiBleHBlY3RpbmcgO1wiKSwgcTtcbiAgICAgIHZhciBBZSA9IGUuUmVmZXJlbmNlLmV4ZWMoWik7XG4gICAgICBpZiAoIUFlIHx8IEFlWzBdLmxlbmd0aCAhPT0gWi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBNLmVycm9yKFwiZW50aXR5IG5vdCBtYXRjaGluZyBSZWZlcmVuY2UgcHJvZHVjdGlvbjogXCIgKyBxKSwgcTtcbiAgICAgIHZhciBOZSA9IFouc2xpY2UoMSwgLTEpO1xuICAgICAgcmV0dXJuIGgodywgTmUpID8gd1tOZV0gOiBOZS5jaGFyQXQoMCkgPT09IFwiI1wiID8gQihwYXJzZUludChOZS5zdWJzdHJpbmcoMSkucmVwbGFjZShcInhcIiwgXCIweFwiKSkpIDogKE0uZXJyb3IoXCJlbnRpdHkgbm90IGZvdW5kOlwiICsgcSksIHEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfKHEpIHtcbiAgICAgIGlmIChxID4gaWUpIHtcbiAgICAgICAgdmFyIFogPSBkLnN1YnN0cmluZyhpZSwgcSkucmVwbGFjZSgkLCBKKTtcbiAgICAgICAgViAmJiBmZShpZSksIHkuY2hhcmFjdGVycyhaLCAwLCBxIC0gaWUpLCBpZSA9IHE7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBUID0gMCwgSSA9IDAsIEwgPSAvXFxyXFxuP3xcXG58JC9nLCBWID0geS5sb2NhdG9yO1xuICAgIGZ1bmN0aW9uIGZlKHEsIFopIHtcbiAgICAgIGZvciAoOyBxID49IEkgJiYgKFogPSBMLmV4ZWMoZCkpOyApXG4gICAgICAgIFQgPSBJLCBJID0gWi5pbmRleCArIFpbMF0ubGVuZ3RoLCBWLmxpbmVOdW1iZXIrKztcbiAgICAgIFYuY29sdW1uTnVtYmVyID0gcSAtIFQgKyAxO1xuICAgIH1cbiAgICBmb3IgKHZhciB3ZSA9IFt7IGN1cnJlbnROU01hcDogTiB9XSwgdmUgPSBbXSwgaWUgPSAwOyA7ICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIFAgPSBkLmluZGV4T2YoXCI8XCIsIGllKTtcbiAgICAgICAgaWYgKFAgPCAwKSB7XG4gICAgICAgICAgaWYgKCFBICYmIHZlLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm4gTS5mYXRhbEVycm9yKFwidW5jbG9zZWQgeG1sIHRhZyhzKTogXCIgKyB2ZS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgIGlmICghZC5zdWJzdHJpbmcoaWUpLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgICAgICAgdmFyICRlID0geS5kb2MsIFJlID0gJGUuY3JlYXRlVGV4dE5vZGUoZC5zdWJzdHJpbmcoaWUpKTtcbiAgICAgICAgICAgIGlmICgkZS5kb2N1bWVudEVsZW1lbnQpXG4gICAgICAgICAgICAgIHJldHVybiBNLmVycm9yKFwiRXh0cmEgY29udGVudCBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFwiKTtcbiAgICAgICAgICAgICRlLmFwcGVuZENoaWxkKFJlKSwgeS5jdXJyZW50RWxlbWVudCA9IFJlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFAgPiBpZSkge1xuICAgICAgICAgIHZhciBwZSA9IGQuc3Vic3RyaW5nKGllLCBQKTtcbiAgICAgICAgICAhQSAmJiB2ZS5sZW5ndGggPT09IDAgJiYgKHBlID0gcGUucmVwbGFjZShuZXcgUmVnRXhwKGUuU19PUFQuc291cmNlLCBcImdcIiksIFwiXCIpLCBwZSAmJiBNLmVycm9yKFwiVW5leHBlY3RlZCBjb250ZW50IG91dHNpZGUgcm9vdCBlbGVtZW50OiAnXCIgKyBwZSArIFwiJ1wiKSksIF8oUCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChkLmNoYXJBdChQICsgMSkpIHtcbiAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgdmFyIG9lID0gZC5pbmRleE9mKFwiPlwiLCBQICsgMiksIFZlID0gZC5zdWJzdHJpbmcoUCArIDIsIG9lID4gMCA/IG9lIDogdm9pZCAwKTtcbiAgICAgICAgICAgIGlmICghVmUpXG4gICAgICAgICAgICAgIHJldHVybiBNLmZhdGFsRXJyb3IoXCJlbmQgdGFnIG5hbWUgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgIHZhciBfZSA9IG9lID4gMCAmJiBlLnJlZyhcIl5cIiwgZS5RTmFtZV9ncm91cCwgZS5TX09QVCwgXCIkXCIpLmV4ZWMoVmUpO1xuICAgICAgICAgICAgaWYgKCFfZSlcbiAgICAgICAgICAgICAgcmV0dXJuIE0uZmF0YWxFcnJvcignZW5kIHRhZyBuYW1lIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyczogXCInICsgVmUgKyAnXCInKTtcbiAgICAgICAgICAgIGlmICgheS5jdXJyZW50RWxlbWVudCAmJiAheS5kb2MuZG9jdW1lbnRFbGVtZW50KVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgU2UgPSB2ZVt2ZS5sZW5ndGggLSAxXSB8fCB5LmN1cnJlbnRFbGVtZW50LnRhZ05hbWUgfHwgeS5kb2MuZG9jdW1lbnRFbGVtZW50LnRhZ05hbWUgfHwgXCJcIjtcbiAgICAgICAgICAgIGlmIChTZSAhPT0gX2VbMV0pIHtcbiAgICAgICAgICAgICAgdmFyIEZlID0gX2VbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKCFBIHx8IFNlLnRvTG93ZXJDYXNlKCkgIT09IEZlKVxuICAgICAgICAgICAgICAgIHJldHVybiBNLmZhdGFsRXJyb3IoJ09wZW5pbmcgYW5kIGVuZGluZyB0YWcgbWlzbWF0Y2g6IFwiJyArIFNlICsgJ1wiICE9IFwiJyArIFZlICsgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgSGUgPSB3ZS5wb3AoKTtcbiAgICAgICAgICAgIHZlLnBvcCgpO1xuICAgICAgICAgICAgdmFyIEplID0gSGUubG9jYWxOU01hcDtcbiAgICAgICAgICAgIGlmICh5LmVuZEVsZW1lbnQoSGUudXJpLCBIZS5sb2NhbE5hbWUsIFNlKSwgSmUpXG4gICAgICAgICAgICAgIGZvciAodmFyIENlIGluIEplKVxuICAgICAgICAgICAgICAgIGgoSmUsIENlKSAmJiB5LmVuZFByZWZpeE1hcHBpbmcoQ2UpO1xuICAgICAgICAgICAgb2UrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIGVuZCBlbGVtZW50XG4gICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgIFYgJiYgZmUoUCksIG9lID0gdGUoZCwgUCwgeSwgTSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiIVwiOlxuICAgICAgICAgICAgViAmJiBmZShQKSwgb2UgPSBJZShkLCBQLCB5LCBNLCBBKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBWICYmIGZlKFApO1xuICAgICAgICAgICAgdmFyIFEgPSBuZXcgQmUoKSwgR2UgPSB3ZVt3ZS5sZW5ndGggLSAxXS5jdXJyZW50TlNNYXAsIG9lID0gZyhkLCBQLCBRLCBHZSwgSiwgTSwgQSksIFhlID0gUS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoUS5jbG9zZWQgfHwgKEEgJiYgdC5pc0hUTUxWb2lkRWxlbWVudChRLnRhZ05hbWUpID8gUS5jbG9zZWQgPSAhMCA6IHZlLnB1c2goUS50YWdOYW1lKSksIFYgJiYgWGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgdnQgPSBsZShWLCB7fSksIFllID0gMDsgWWUgPCBYZTsgWWUrKykge1xuICAgICAgICAgICAgICAgIHZhciBXZSA9IFFbWWVdO1xuICAgICAgICAgICAgICAgIGZlKFdlLm9mZnNldCksIFdlLmxvY2F0b3IgPSBsZShWLCB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeS5sb2NhdG9yID0gdnQsIHgoUSwgeSwgR2UpICYmIHdlLnB1c2goUSksIHkubG9jYXRvciA9IFY7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgeChRLCB5LCBHZSkgJiYgd2UucHVzaChRKTtcbiAgICAgICAgICAgIEEgJiYgIVEuY2xvc2VkID8gb2UgPSBGKGQsIG9lLCBRLnRhZ05hbWUsIEosIHkpIDogb2UrKztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAocSkge1xuICAgICAgICBpZiAocSBpbnN0YW5jZW9mIGYpXG4gICAgICAgICAgdGhyb3cgcTtcbiAgICAgICAgaWYgKHEgaW5zdGFuY2VvZiBtKVxuICAgICAgICAgIHRocm93IG5ldyBmKHEubmFtZSArIFwiOiBcIiArIHEubWVzc2FnZSwgeS5sb2NhdG9yLCBxKTtcbiAgICAgICAgTS5lcnJvcihcImVsZW1lbnQgcGFyc2UgZXJyb3I6IFwiICsgcSksIG9lID0gLTE7XG4gICAgICB9XG4gICAgICBvZSA+IGllID8gaWUgPSBvZSA6IF8oTWF0aC5tYXgoUCwgaWUpICsgMSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxlKGQsIE4pIHtcbiAgICByZXR1cm4gTi5saW5lTnVtYmVyID0gZC5saW5lTnVtYmVyLCBOLmNvbHVtbk51bWJlciA9IGQuY29sdW1uTnVtYmVyLCBOO1xuICB9XG4gIGZ1bmN0aW9uIGcoZCwgTiwgdywgeSwgTSwgQSwgQikge1xuICAgIGZ1bmN0aW9uIEooZmUsIHdlLCB2ZSkge1xuICAgICAgaWYgKGgody5hdHRyaWJ1dGVOYW1lcywgZmUpKVxuICAgICAgICByZXR1cm4gQS5mYXRhbEVycm9yKFwiQXR0cmlidXRlIFwiICsgZmUgKyBcIiByZWRlZmluZWRcIik7XG4gICAgICBpZiAoIUIgJiYgd2UuaW5kZXhPZihcIjxcIikgPj0gMClcbiAgICAgICAgcmV0dXJuIEEuZmF0YWxFcnJvcihcIlVuZXNjYXBlZCAnPCcgbm90IGFsbG93ZWQgaW4gYXR0cmlidXRlcyB2YWx1ZXNcIik7XG4gICAgICB3LmFkZFZhbHVlKFxuICAgICAgICBmZSxcbiAgICAgICAgLy8gQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIveG1sLyNBVk5vcm1hbGl6ZVxuICAgICAgICAvLyBzaW5jZSB0aGUgeG1sZG9tIHNheCBwYXJzZXIgZG9lcyBub3QgXCJpbnRlcnByZXRcIiBEVEQgdGhlIGZvbGxvd2luZyBpcyBub3QgaW1wbGVtZW50ZWQ6XG4gICAgICAgIC8vIC0gcmVjdXJzaXZlIHJlcGxhY2VtZW50IG9mIChEVEQpIGVudGl0eSByZWZlcmVuY2VzXG4gICAgICAgIC8vIC0gdHJpbW1pbmcgYW5kIGNvbGxhcHNpbmcgbXVsdGlwbGUgc3BhY2VzIGludG8gYSBzaW5nbGUgb25lIGZvciBhdHRyaWJ1dGVzIHRoYXQgYXJlIG5vdCBvZiB0eXBlIENEQVRBXG4gICAgICAgIHdlLnJlcGxhY2UoL1tcXHRcXG5cXHJdL2csIFwiIFwiKS5yZXBsYWNlKCQsIE0pLFxuICAgICAgICB2ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yICh2YXIgXywgVCwgSSA9ICsrTiwgTCA9IEU7IDsgKSB7XG4gICAgICB2YXIgViA9IGQuY2hhckF0KEkpO1xuICAgICAgc3dpdGNoIChWKSB7XG4gICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgaWYgKEwgPT09IGwpXG4gICAgICAgICAgICBfID0gZC5zbGljZShOLCBJKSwgTCA9IE87XG4gICAgICAgICAgZWxzZSBpZiAoTCA9PT0gdilcbiAgICAgICAgICAgIEwgPSBPO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dHJpYnV0ZSBlcXVhbCBtdXN0IGFmdGVyIGF0dHJOYW1lXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgaWYgKEwgPT09IE8gfHwgTCA9PT0gbClcbiAgICAgICAgICAgIGlmIChMID09PSBsICYmIChBLndhcm5pbmcoJ2F0dHJpYnV0ZSB2YWx1ZSBtdXN0IGFmdGVyIFwiPVwiJyksIF8gPSBkLnNsaWNlKE4sIEkpKSwgTiA9IEkgKyAxLCBJID0gZC5pbmRleE9mKFYsIE4pLCBJID4gMClcbiAgICAgICAgICAgICAgVCA9IGQuc2xpY2UoTiwgSSksIEooXywgVCwgTiAtIDEpLCBMID0gQztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0cmlidXRlIHZhbHVlIG5vIGVuZCAnXCIgKyBWICsgXCInIG1hdGNoXCIpO1xuICAgICAgICAgIGVsc2UgaWYgKEwgPT0gYilcbiAgICAgICAgICAgIFQgPSBkLnNsaWNlKE4sIEkpLCBKKF8sIFQsIE4pLCBBLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicgKyBfICsgJ1wiIG1pc3NlZCBzdGFydCBxdW90KCcgKyBWICsgXCIpISFcIiksIE4gPSBJICsgMSwgTCA9IEM7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRyaWJ1dGUgdmFsdWUgbXVzdCBhZnRlciBcIj1cIicpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgIHN3aXRjaCAoTCkge1xuICAgICAgICAgICAgY2FzZSBFOlxuICAgICAgICAgICAgICB3LnNldFRhZ05hbWUoZC5zbGljZShOLCBJKSk7XG4gICAgICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgICBjYXNlIGo6XG4gICAgICAgICAgICBjYXNlIFI6XG4gICAgICAgICAgICAgIEwgPSBSLCB3LmNsb3NlZCA9ICEwO1xuICAgICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdjpcbiAgICAgICAgICAgICAgdy5jbG9zZWQgPSAhMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvL2Nhc2UgU19FUTpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dHJpYnV0ZSBpbnZhbGlkIGNsb3NlIGNoYXIoJy8nKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICByZXR1cm4gQS5lcnJvcihcInVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIpLCBMID09IEUgJiYgdy5zZXRUYWdOYW1lKGQuc2xpY2UoTiwgSSkpLCBJO1xuICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgIHN3aXRjaCAoTCkge1xuICAgICAgICAgICAgY2FzZSBFOlxuICAgICAgICAgICAgICB3LnNldFRhZ05hbWUoZC5zbGljZShOLCBJKSk7XG4gICAgICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgICBjYXNlIGo6XG4gICAgICAgICAgICBjYXNlIFI6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy9ub3JtYWxcbiAgICAgICAgICAgIGNhc2UgYjpcbiAgICAgICAgICAgIC8vQ29tcGF0aWJsZSBzdGF0ZVxuICAgICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgICBUID0gZC5zbGljZShOLCBJKSwgVC5zbGljZSgtMSkgPT09IFwiL1wiICYmICh3LmNsb3NlZCA9ICEwLCBUID0gVC5zbGljZSgwLCAtMSkpO1xuICAgICAgICAgICAgY2FzZSB2OlxuICAgICAgICAgICAgICBMID09PSB2ICYmIChUID0gXyksIEwgPT0gYiA/IChBLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicgKyBUICsgJ1wiIG1pc3NlZCBxdW90KFwiKSEnKSwgSihfLCBULCBOKSkgOiAoQiB8fCBBLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicgKyBUICsgJ1wiIG1pc3NlZCB2YWx1ZSEhIFwiJyArIFQgKyAnXCIgaW5zdGVhZCEhJyksIEooVCwgVCwgTikpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTzpcbiAgICAgICAgICAgICAgaWYgKCFCKVxuICAgICAgICAgICAgICAgIHJldHVybiBBLmZhdGFsRXJyb3IoYEF0dFZhbHVlOiAnIG9yIFwiIGV4cGVjdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAvKnhtbCBzcGFjZSAnXFx4MjAnIHwgI3g5IHwgI3hEIHwgI3hBOyAqL1xuICAgICAgICBjYXNlIFwiwoBcIjpcbiAgICAgICAgICBWID0gXCIgXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKFYgPD0gXCIgXCIpXG4gICAgICAgICAgICBzd2l0Y2ggKEwpIHtcbiAgICAgICAgICAgICAgY2FzZSBFOlxuICAgICAgICAgICAgICAgIHcuc2V0VGFnTmFtZShkLnNsaWNlKE4sIEkpKSwgTCA9IGo7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgICAgICBfID0gZC5zbGljZShOLCBJKSwgTCA9IHY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgYjpcbiAgICAgICAgICAgICAgICB2YXIgVCA9IGQuc2xpY2UoTiwgSSk7XG4gICAgICAgICAgICAgICAgQS53YXJuaW5nKCdhdHRyaWJ1dGUgXCInICsgVCArICdcIiBtaXNzZWQgcXVvdChcIikhIScpLCBKKF8sIFQsIE4pO1xuICAgICAgICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgICAgICAgTCA9IGo7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3dpdGNoIChMKSB7XG4gICAgICAgICAgICAgIC8vY2FzZSBTX1RBRzp2b2lkKCk7YnJlYWs7XG4gICAgICAgICAgICAgIC8vY2FzZSBTX0FUVFI6dm9pZCgpO2JyZWFrO1xuICAgICAgICAgICAgICAvL2Nhc2UgU19BVFRSX05PUVVPVF9WQUxVRTp2b2lkKCk7YnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgdjpcbiAgICAgICAgICAgICAgICBCIHx8IEEud2FybmluZygnYXR0cmlidXRlIFwiJyArIF8gKyAnXCIgbWlzc2VkIHZhbHVlISEgXCInICsgXyArICdcIiBpbnN0ZWFkMiEhJyksIEooXywgXywgTiksIE4gPSBJLCBMID0gbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBDOlxuICAgICAgICAgICAgICAgIEEud2FybmluZygnYXR0cmlidXRlIHNwYWNlIGlzIHJlcXVpcmVkXCInICsgXyArICdcIiEhJyk7XG4gICAgICAgICAgICAgIGNhc2UgajpcbiAgICAgICAgICAgICAgICBMID0gbCwgTiA9IEk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgTzpcbiAgICAgICAgICAgICAgICBMID0gYiwgTiA9IEk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUjpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbGVtZW50cyBjbG9zZWQgY2hhcmFjdGVyICcvJyBhbmQgJz4nIG11c3QgYmUgY29ubmVjdGVkIHRvXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgfVxuICAgICAgSSsrO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB4KGQsIE4sIHcpIHtcbiAgICBmb3IgKHZhciB5ID0gZC50YWdOYW1lLCBNID0gbnVsbCwgTCA9IGQubGVuZ3RoOyBMLS07ICkge1xuICAgICAgdmFyIEEgPSBkW0xdLCBCID0gQS5xTmFtZSwgSiA9IEEudmFsdWUsIFYgPSBCLmluZGV4T2YoXCI6XCIpO1xuICAgICAgaWYgKFYgPiAwKVxuICAgICAgICB2YXIgXyA9IEEucHJlZml4ID0gQi5zbGljZSgwLCBWKSwgVCA9IEIuc2xpY2UoViArIDEpLCBJID0gXyA9PT0gXCJ4bWxuc1wiICYmIFQ7XG4gICAgICBlbHNlXG4gICAgICAgIFQgPSBCLCBfID0gbnVsbCwgSSA9IEIgPT09IFwieG1sbnNcIiAmJiBcIlwiO1xuICAgICAgQS5sb2NhbE5hbWUgPSBULCBJICE9PSAhMSAmJiAoTSA9PSBudWxsICYmIChNID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIEcodywgdyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKSksIHdbSV0gPSBNW0ldID0gSiwgQS51cmkgPSBwLlhNTE5TLCBOLnN0YXJ0UHJlZml4TWFwcGluZyhJLCBKKSk7XG4gICAgfVxuICAgIGZvciAodmFyIEwgPSBkLmxlbmd0aDsgTC0tOyApXG4gICAgICBBID0gZFtMXSwgQS5wcmVmaXggJiYgKEEucHJlZml4ID09PSBcInhtbFwiICYmIChBLnVyaSA9IHAuWE1MKSwgQS5wcmVmaXggIT09IFwieG1sbnNcIiAmJiAoQS51cmkgPSB3W0EucHJlZml4XSkpO1xuICAgIHZhciBWID0geS5pbmRleE9mKFwiOlwiKTtcbiAgICBWID4gMCA/IChfID0gZC5wcmVmaXggPSB5LnNsaWNlKDAsIFYpLCBUID0gZC5sb2NhbE5hbWUgPSB5LnNsaWNlKFYgKyAxKSkgOiAoXyA9IG51bGwsIFQgPSBkLmxvY2FsTmFtZSA9IHkpO1xuICAgIHZhciBmZSA9IGQudXJpID0gd1tfIHx8IFwiXCJdO1xuICAgIGlmIChOLnN0YXJ0RWxlbWVudChmZSwgVCwgeSwgZCksIGQuY2xvc2VkKSB7XG4gICAgICBpZiAoTi5lbmRFbGVtZW50KGZlLCBULCB5KSwgTSlcbiAgICAgICAgZm9yIChfIGluIE0pXG4gICAgICAgICAgaChNLCBfKSAmJiBOLmVuZFByZWZpeE1hcHBpbmcoXyk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gZC5jdXJyZW50TlNNYXAgPSB3LCBkLmxvY2FsTlNNYXAgPSBNLCAhMDtcbiAgfVxuICBmdW5jdGlvbiBGKGQsIE4sIHcsIHksIE0pIHtcbiAgICB2YXIgQSA9IGkodyk7XG4gICAgaWYgKEEgfHwgYSh3KSkge1xuICAgICAgdmFyIEIgPSBkLmluZGV4T2YoXCI8L1wiICsgdyArIFwiPlwiLCBOKSwgSiA9IGQuc3Vic3RyaW5nKE4gKyAxLCBCKTtcbiAgICAgIHJldHVybiBBICYmIChKID0gSi5yZXBsYWNlKCQsIHkpKSwgTS5jaGFyYWN0ZXJzKEosIDAsIEoubGVuZ3RoKSwgQjtcbiAgICB9XG4gICAgcmV0dXJuIE4gKyAxO1xuICB9XG4gIGZ1bmN0aW9uIEcoZCwgTikge1xuICAgIGZvciAodmFyIHcgaW4gZClcbiAgICAgIGgoZCwgdykgJiYgKE5bd10gPSBkW3ddKTtcbiAgfVxuICBmdW5jdGlvbiBLKGQsIE4pIHtcbiAgICB2YXIgdyA9IE47XG4gICAgZnVuY3Rpb24geShJKSB7XG4gICAgICByZXR1cm4gSSA9IEkgfHwgMCwgZC5jaGFyQXQodyArIEkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNKEkpIHtcbiAgICAgIEkgPSBJIHx8IDEsIHcgKz0gSTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQSgpIHtcbiAgICAgIGZvciAodmFyIEkgPSAwOyB3IDwgZC5sZW5ndGg7ICkge1xuICAgICAgICB2YXIgTCA9IHkoKTtcbiAgICAgICAgaWYgKEwgIT09IFwiIFwiICYmIEwgIT09IGBcbmAgJiYgTCAhPT0gXCJcdFwiICYmIEwgIT09IFwiXFxyXCIpXG4gICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgIEkrKywgTSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCKCkge1xuICAgICAgcmV0dXJuIGQuc3Vic3RyaW5nKHcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBKKEkpIHtcbiAgICAgIHJldHVybiBkLnN1YnN0cmluZyh3LCB3ICsgSS5sZW5ndGgpID09PSBJO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfKEkpIHtcbiAgICAgIHJldHVybiBkLnN1YnN0cmluZyh3LCB3ICsgSS5sZW5ndGgpLnRvVXBwZXJDYXNlKCkgPT09IEkudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVChJKSB7XG4gICAgICB2YXIgTCA9IGUucmVnKFwiXlwiLCBJKSwgViA9IEwuZXhlYyhCKCkpO1xuICAgICAgcmV0dXJuIFYgPyAoTShWWzBdLmxlbmd0aCksIFZbMF0pIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXI6IHksXG4gICAgICBnZXRJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3O1xuICAgICAgfSxcbiAgICAgIGdldE1hdGNoOiBULFxuICAgICAgZ2V0U291cmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9LFxuICAgICAgc2tpcDogTSxcbiAgICAgIHNraXBCbGFua3M6IEEsXG4gICAgICBzdWJzdHJpbmdGcm9tSW5kZXg6IEIsXG4gICAgICBzdWJzdHJpbmdTdGFydHNXaXRoOiBKLFxuICAgICAgc3Vic3RyaW5nU3RhcnRzV2l0aENhc2VJbnNlbnNpdGl2ZTogX1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZWUoZCwgTikge1xuICAgIGZ1bmN0aW9uIHcoSiwgXykge1xuICAgICAgdmFyIFQgPSBlLlBJLmV4ZWMoSi5zdWJzdHJpbmdGcm9tSW5kZXgoKSk7XG4gICAgICByZXR1cm4gVCA/IFRbMV0udG9Mb3dlckNhc2UoKSA9PT0gXCJ4bWxcIiA/IF8uZmF0YWxFcnJvcihcbiAgICAgICAgXCJ4bWwgZGVjbGFyYXRpb24gaXMgb25seSBhbGxvd2VkIGF0IHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQsIGJ1dCBmb3VuZCBhdCBwb3NpdGlvbiBcIiArIEouZ2V0SW5kZXgoKVxuICAgICAgKSA6IChKLnNraXAoVFswXS5sZW5ndGgpLCBUWzBdKSA6IF8uZmF0YWxFcnJvcihcInByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gaXMgbm90IHdlbGwtZm9ybWVkIGF0IHBvc2l0aW9uIFwiICsgSi5nZXRJbmRleCgpKTtcbiAgICB9XG4gICAgdmFyIHkgPSBkLmdldFNvdXJjZSgpO1xuICAgIGlmIChkLmNoYXIoKSA9PT0gXCJbXCIpIHtcbiAgICAgIGQuc2tpcCgxKTtcbiAgICAgIGZvciAodmFyIE0gPSBkLmdldEluZGV4KCk7IGQuZ2V0SW5kZXgoKSA8IHkubGVuZ3RoOyApIHtcbiAgICAgICAgaWYgKGQuc2tpcEJsYW5rcygpLCBkLmNoYXIoKSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICB2YXIgQSA9IHkuc3Vic3RyaW5nKE0sIGQuZ2V0SW5kZXgoKSk7XG4gICAgICAgICAgcmV0dXJuIGQuc2tpcCgxKSwgQTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQiA9IG51bGw7XG4gICAgICAgIGlmIChkLmNoYXIoKSA9PT0gXCI8XCIgJiYgZC5jaGFyKDEpID09PSBcIiFcIilcbiAgICAgICAgICBzd2l0Y2ggKGQuY2hhcigyKSkge1xuICAgICAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgICAgICAgZC5jaGFyKDMpID09PSBcIkxcIiA/IEIgPSBkLmdldE1hdGNoKGUuZWxlbWVudGRlY2wpIDogZC5jaGFyKDMpID09PSBcIk5cIiAmJiAoQiA9IGQuZ2V0TWF0Y2goZS5FbnRpdHlEZWNsKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgICAgICAgQiA9IGQuZ2V0TWF0Y2goZS5BdHRsaXN0RGVjbCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk5cIjpcbiAgICAgICAgICAgICAgQiA9IGQuZ2V0TWF0Y2goZS5Ob3RhdGlvbkRlY2wpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICAgIEIgPSBkLmdldE1hdGNoKGUuQ29tbWVudCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZC5jaGFyKCkgPT09IFwiPFwiICYmIGQuY2hhcigxKSA9PT0gXCI/XCIpXG4gICAgICAgICAgQiA9IHcoZCwgTik7XG4gICAgICAgIGVsc2UgaWYgKGQuY2hhcigpID09PSBcIiVcIilcbiAgICAgICAgICBCID0gZC5nZXRNYXRjaChlLlBFUmVmZXJlbmNlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBOLmZhdGFsRXJyb3IoXCJFcnJvciBkZXRlY3RlZCBpbiBNYXJrdXAgZGVjbGFyYXRpb25cIik7XG4gICAgICAgIGlmICghQilcbiAgICAgICAgICByZXR1cm4gTi5mYXRhbEVycm9yKFwiRXJyb3IgaW4gaW50ZXJuYWwgc3Vic2V0IGF0IHBvc2l0aW9uIFwiICsgZC5nZXRJbmRleCgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOLmZhdGFsRXJyb3IoXCJkb2N0eXBlIGludGVybmFsIHN1YnNldCBpcyBub3Qgd2VsbC1mb3JtZWQsIG1pc3NpbmcgXVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gSWUoZCwgTiwgdywgeSwgTSkge1xuICAgIHZhciBBID0gSyhkLCBOKTtcbiAgICBzd2l0Y2ggKE0gPyBBLmNoYXIoMikudG9VcHBlckNhc2UoKSA6IEEuY2hhcigyKSkge1xuICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgdmFyIEIgPSBBLmdldE1hdGNoKGUuQ29tbWVudCk7XG4gICAgICAgIHJldHVybiBCID8gKHcuY29tbWVudChCLCBlLkNPTU1FTlRfU1RBUlQubGVuZ3RoLCBCLmxlbmd0aCAtIGUuQ09NTUVOVF9TVEFSVC5sZW5ndGggLSBlLkNPTU1FTlRfRU5ELmxlbmd0aCksIEEuZ2V0SW5kZXgoKSkgOiB5LmZhdGFsRXJyb3IoXCJjb21tZW50IGlzIG5vdCB3ZWxsLWZvcm1lZCBhdCBwb3NpdGlvbiBcIiArIEEuZ2V0SW5kZXgoKSk7XG4gICAgICBjYXNlIFwiW1wiOlxuICAgICAgICB2YXIgSiA9IEEuZ2V0TWF0Y2goZS5DRFNlY3QpO1xuICAgICAgICByZXR1cm4gSiA/ICFNICYmICF3LmN1cnJlbnRFbGVtZW50ID8geS5mYXRhbEVycm9yKFwiQ0RBVEEgb3V0c2lkZSBvZiBlbGVtZW50XCIpIDogKHcuc3RhcnRDREFUQSgpLCB3LmNoYXJhY3RlcnMoSiwgZS5DREFUQV9TVEFSVC5sZW5ndGgsIEoubGVuZ3RoIC0gZS5DREFUQV9TVEFSVC5sZW5ndGggLSBlLkNEQVRBX0VORC5sZW5ndGgpLCB3LmVuZENEQVRBKCksIEEuZ2V0SW5kZXgoKSkgOiB5LmZhdGFsRXJyb3IoXCJJbnZhbGlkIENEQVRBIHN0YXJ0aW5nIGF0IHBvc2l0aW9uIFwiICsgTik7XG4gICAgICBjYXNlIFwiRFwiOiB7XG4gICAgICAgIGlmICh3LmRvYyAmJiB3LmRvYy5kb2N1bWVudEVsZW1lbnQpXG4gICAgICAgICAgcmV0dXJuIHkuZmF0YWxFcnJvcihcIkRvY3R5cGUgbm90IGFsbG93ZWQgaW5zaWRlIG9yIGFmdGVyIGRvY3VtZW50RWxlbWVudCBhdCBwb3NpdGlvbiBcIiArIEEuZ2V0SW5kZXgoKSk7XG4gICAgICAgIGlmIChNID8gIUEuc3Vic3RyaW5nU3RhcnRzV2l0aENhc2VJbnNlbnNpdGl2ZShlLkRPQ1RZUEVfREVDTF9TVEFSVCkgOiAhQS5zdWJzdHJpbmdTdGFydHNXaXRoKGUuRE9DVFlQRV9ERUNMX1NUQVJUKSlcbiAgICAgICAgICByZXR1cm4geS5mYXRhbEVycm9yKFwiRXhwZWN0ZWQgXCIgKyBlLkRPQ1RZUEVfREVDTF9TVEFSVCArIFwiIGF0IHBvc2l0aW9uIFwiICsgQS5nZXRJbmRleCgpKTtcbiAgICAgICAgaWYgKEEuc2tpcChlLkRPQ1RZUEVfREVDTF9TVEFSVC5sZW5ndGgpLCBBLnNraXBCbGFua3MoKSA8IDEpXG4gICAgICAgICAgcmV0dXJuIHkuZmF0YWxFcnJvcihcIkV4cGVjdGVkIHdoaXRlc3BhY2UgYWZ0ZXIgXCIgKyBlLkRPQ1RZUEVfREVDTF9TVEFSVCArIFwiIGF0IHBvc2l0aW9uIFwiICsgQS5nZXRJbmRleCgpKTtcbiAgICAgICAgdmFyIF8gPSB7XG4gICAgICAgICAgbmFtZTogdm9pZCAwLFxuICAgICAgICAgIHB1YmxpY0lkOiB2b2lkIDAsXG4gICAgICAgICAgc3lzdGVtSWQ6IHZvaWQgMCxcbiAgICAgICAgICBpbnRlcm5hbFN1YnNldDogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChfLm5hbWUgPSBBLmdldE1hdGNoKGUuTmFtZSksICFfLm5hbWUpXG4gICAgICAgICAgcmV0dXJuIHkuZmF0YWxFcnJvcihcImRvY3R5cGUgbmFtZSBtaXNzaW5nIG9yIGNvbnRhaW5zIHVuZXhwZWN0ZWQgY2hhcmFjdGVycyBhdCBwb3NpdGlvbiBcIiArIEEuZ2V0SW5kZXgoKSk7XG4gICAgICAgIGlmIChNICYmIF8ubmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImh0bWxcIiAmJiB5Lndhcm5pbmcoXCJVbmV4cGVjdGVkIERPQ1RZUEUgaW4gSFRNTCBkb2N1bWVudCBhdCBwb3NpdGlvbiBcIiArIEEuZ2V0SW5kZXgoKSksIEEuc2tpcEJsYW5rcygpLCBBLnN1YnN0cmluZ1N0YXJ0c1dpdGgoZS5QVUJMSUMpIHx8IEEuc3Vic3RyaW5nU3RhcnRzV2l0aChlLlNZU1RFTSkpIHtcbiAgICAgICAgICB2YXIgVCA9IGUuRXh0ZXJuYWxJRF9tYXRjaC5leGVjKEEuc3Vic3RyaW5nRnJvbUluZGV4KCkpO1xuICAgICAgICAgIGlmICghVClcbiAgICAgICAgICAgIHJldHVybiB5LmZhdGFsRXJyb3IoXCJkb2N0eXBlIGV4dGVybmFsIGlkIGlzIG5vdCB3ZWxsLWZvcm1lZCBhdCBwb3NpdGlvbiBcIiArIEEuZ2V0SW5kZXgoKSk7XG4gICAgICAgICAgVC5ncm91cHMuU3lzdGVtTGl0ZXJhbE9ubHkgIT09IHZvaWQgMCA/IF8uc3lzdGVtSWQgPSBULmdyb3Vwcy5TeXN0ZW1MaXRlcmFsT25seSA6IChfLnN5c3RlbUlkID0gVC5ncm91cHMuU3lzdGVtTGl0ZXJhbCwgXy5wdWJsaWNJZCA9IFQuZ3JvdXBzLlB1YmlkTGl0ZXJhbCksIEEuc2tpcChUWzBdLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoTSAmJiBBLnN1YnN0cmluZ1N0YXJ0c1dpdGhDYXNlSW5zZW5zaXRpdmUoZS5TWVNURU0pKSB7XG4gICAgICAgICAgaWYgKEEuc2tpcChlLlNZU1RFTS5sZW5ndGgpLCBBLnNraXBCbGFua3MoKSA8IDEpXG4gICAgICAgICAgICByZXR1cm4geS5mYXRhbEVycm9yKFwiRXhwZWN0ZWQgd2hpdGVzcGFjZSBhZnRlciBcIiArIGUuU1lTVEVNICsgXCIgYXQgcG9zaXRpb24gXCIgKyBBLmdldEluZGV4KCkpO1xuICAgICAgICAgIGlmIChfLnN5c3RlbUlkID0gQS5nZXRNYXRjaChlLkFCT1VUX0xFR0FDWV9DT01QQVRfU3lzdGVtTGl0ZXJhbCksICFfLnN5c3RlbUlkKVxuICAgICAgICAgICAgcmV0dXJuIHkuZmF0YWxFcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCBcIiArIGUuQUJPVVRfTEVHQUNZX0NPTVBBVCArIFwiIGluIHNpbmdsZSBvciBkb3VibGUgcXVvdGVzIGFmdGVyIFwiICsgZS5TWVNURU0gKyBcIiBhdCBwb3NpdGlvbiBcIiArIEEuZ2V0SW5kZXgoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTSAmJiBfLnN5c3RlbUlkICYmICFlLkFCT1VUX0xFR0FDWV9DT01QQVRfU3lzdGVtTGl0ZXJhbC50ZXN0KF8uc3lzdGVtSWQpICYmIHkud2FybmluZyhcIlVuZXhwZWN0ZWQgZG9jdHlwZS5zeXN0ZW1JZCBpbiBIVE1MIGRvY3VtZW50IGF0IHBvc2l0aW9uIFwiICsgQS5nZXRJbmRleCgpKSwgTSB8fCAoQS5za2lwQmxhbmtzKCksIF8uaW50ZXJuYWxTdWJzZXQgPSBlZShBLCB5KSksIEEuc2tpcEJsYW5rcygpLCBBLmNoYXIoKSAhPT0gXCI+XCIgPyB5LmZhdGFsRXJyb3IoXCJkb2N0eXBlIG5vdCB0ZXJtaW5hdGVkIHdpdGggPiBhdCBwb3NpdGlvbiBcIiArIEEuZ2V0SW5kZXgoKSkgOiAoQS5za2lwKDEpLCB3LnN0YXJ0RFREKF8ubmFtZSwgXy5wdWJsaWNJZCwgXy5zeXN0ZW1JZCwgXy5pbnRlcm5hbFN1YnNldCksIHcuZW5kRFREKCksIEEuZ2V0SW5kZXgoKSk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geS5mYXRhbEVycm9yKCdOb3Qgd2VsbC1mb3JtZWQgWE1MIHN0YXJ0aW5nIHdpdGggXCI8IVwiIGF0IHBvc2l0aW9uICcgKyBOKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdGUoZCwgTiwgdywgeSkge1xuICAgIHZhciBNID0gZC5zdWJzdHJpbmcoTikubWF0Y2goZS5QSSk7XG4gICAgaWYgKCFNKVxuICAgICAgcmV0dXJuIHkuZmF0YWxFcnJvcihcIkludmFsaWQgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBzdGFydGluZyBhdCBwb3NpdGlvbiBcIiArIE4pO1xuICAgIGlmIChNWzFdLnRvTG93ZXJDYXNlKCkgPT09IFwieG1sXCIpIHtcbiAgICAgIGlmIChOID4gMClcbiAgICAgICAgcmV0dXJuIHkuZmF0YWxFcnJvcihcbiAgICAgICAgICBcInByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gYXQgcG9zaXRpb24gXCIgKyBOICsgXCIgaXMgYW4geG1sIGRlY2xhcmF0aW9uIHdoaWNoIGlzIG9ubHkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudFwiXG4gICAgICAgICk7XG4gICAgICBpZiAoIWUuWE1MRGVjbC50ZXN0KGQuc3Vic3RyaW5nKE4pKSlcbiAgICAgICAgcmV0dXJuIHkuZmF0YWxFcnJvcihcInhtbCBkZWNsYXJhdGlvbiBpcyBub3Qgd2VsbC1mb3JtZWRcIik7XG4gICAgfVxuICAgIHJldHVybiB3LnByb2Nlc3NpbmdJbnN0cnVjdGlvbihNWzFdLCBNWzJdKSwgTiArIE1bMF0ubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIEJlKCkge1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICByZXR1cm4gQmUucHJvdG90eXBlID0ge1xuICAgIHNldFRhZ05hbWU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIGlmICghZS5RTmFtZV9leGFjdC50ZXN0KGQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHRhZ05hbWU6XCIgKyBkKTtcbiAgICAgIHRoaXMudGFnTmFtZSA9IGQ7XG4gICAgfSxcbiAgICBhZGRWYWx1ZTogZnVuY3Rpb24oZCwgTiwgdykge1xuICAgICAgaWYgKCFlLlFOYW1lX2V4YWN0LnRlc3QoZCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXR0cmlidXRlOlwiICsgZCk7XG4gICAgICB0aGlzLmF0dHJpYnV0ZU5hbWVzW2RdID0gdGhpcy5sZW5ndGgsIHRoaXNbdGhpcy5sZW5ndGgrK10gPSB7IHFOYW1lOiBkLCB2YWx1ZTogTiwgb2Zmc2V0OiB3IH07XG4gICAgfSxcbiAgICBsZW5ndGg6IDAsXG4gICAgZ2V0TG9jYWxOYW1lOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gdGhpc1tkXS5sb2NhbE5hbWU7XG4gICAgfSxcbiAgICBnZXRMb2NhdG9yOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gdGhpc1tkXS5sb2NhdG9yO1xuICAgIH0sXG4gICAgZ2V0UU5hbWU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiB0aGlzW2RdLnFOYW1lO1xuICAgIH0sXG4gICAgZ2V0VVJJOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gdGhpc1tkXS51cmk7XG4gICAgfSxcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIHRoaXNbZF0udmFsdWU7XG4gICAgfVxuICAgIC8vXHQsZ2V0SW5kZXg6ZnVuY3Rpb24odXJpLCBsb2NhbE5hbWUpKXtcbiAgICAvL1x0XHRpZihsb2NhbE5hbWUpe1xuICAgIC8vXG4gICAgLy9cdFx0fWVsc2V7XG4gICAgLy9cdFx0XHR2YXIgcU5hbWUgPSB1cmlcbiAgICAvL1x0XHR9XG4gICAgLy9cdH0sXG4gICAgLy9cdGdldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0VmFsdWUodGhpcy5nZXRJbmRleC5hcHBseSh0aGlzLGFyZ3VtZW50cykpfSxcbiAgICAvL1x0Z2V0VHlwZTpmdW5jdGlvbih1cmksbG9jYWxOYW1lKXt9XG4gICAgLy9cdGdldFR5cGU6ZnVuY3Rpb24oaSl7fSxcbiAgfSwgeXQuWE1MUmVhZGVyID0gaywgeXQucGFyc2VVdGlscyA9IEssIHl0LnBhcnNlRG9jdHlwZUNvbW1lbnRPckNEYXRhID0gSWUsIHl0O1xufVxudmFyIGFyO1xuZnVuY3Rpb24gTm4oKSB7XG4gIGlmIChhcikgcmV0dXJuIHJ0O1xuICBhciA9IDE7XG4gIHZhciB0ID0gRHQoKSwgZSA9IGtyKCksIG4gPSBfdCgpLCBpID0gdm4oKSwgbyA9IEFuKCksIGEgPSBlLkRPTUltcGxlbWVudGF0aW9uLCBoID0gdC5oYXNEZWZhdWx0SFRNTE5hbWVzcGFjZSwgcCA9IHQuaXNIVE1MTWltZVR5cGUsIGYgPSB0LmlzVmFsaWRNaW1lVHlwZSwgbSA9IHQuTUlNRV9UWVBFLCBFID0gdC5OQU1FU1BBQ0UsIGwgPSBuLlBhcnNlRXJyb3IsIHYgPSBvLlhNTFJlYWRlcjtcbiAgZnVuY3Rpb24gTyhnKSB7XG4gICAgcmV0dXJuIGcucmVwbGFjZSgvXFxyW1xcblxcdTAwODVdL2csIGBcbmApLnJlcGxhY2UoL1tcXHJcXHUwMDg1XFx1MjAyOFxcdTIwMjldL2csIGBcbmApO1xuICB9XG4gIGZ1bmN0aW9uIGIoZykge1xuICAgIGlmIChnID0gZyB8fCB7fSwgZy5sb2NhdG9yID09PSB2b2lkIDAgJiYgKGcubG9jYXRvciA9ICEwKSwgdGhpcy5hc3NpZ24gPSBnLmFzc2lnbiB8fCB0LmFzc2lnbiwgdGhpcy5kb21IYW5kbGVyID0gZy5kb21IYW5kbGVyIHx8IEMsIHRoaXMub25FcnJvciA9IGcub25FcnJvciB8fCBnLmVycm9ySGFuZGxlciwgZy5lcnJvckhhbmRsZXIgJiYgdHlwZW9mIGcuZXJyb3JIYW5kbGVyICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJlcnJvckhhbmRsZXIgb2JqZWN0IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHN3aXRjaCB0byBvbkVycm9yIVwiKTtcbiAgICBnLmVycm9ySGFuZGxlciAmJiBnLmVycm9ySGFuZGxlcihcIndhcm5pbmdcIiwgXCJUaGUgYGVycm9ySGFuZGxlcmAgb3B0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSBgb25FcnJvcmAgaW5zdGVhZCFcIiwgdGhpcyksIHRoaXMubm9ybWFsaXplTGluZUVuZGluZ3MgPSBnLm5vcm1hbGl6ZUxpbmVFbmRpbmdzIHx8IE8sIHRoaXMubG9jYXRvciA9ICEhZy5sb2NhdG9yLCB0aGlzLnhtbG5zID0gdGhpcy5hc3NpZ24oLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIGcueG1sbnMpO1xuICB9XG4gIGIucHJvdG90eXBlLnBhcnNlRnJvbVN0cmluZyA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICBpZiAoIWYoeCkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdET01QYXJzZXIucGFyc2VGcm9tU3RyaW5nOiB0aGUgcHJvdmlkZWQgbWltZVR5cGUgXCInICsgeCArICdcIiBpcyBub3QgdmFsaWQuJyk7XG4gICAgdmFyIEYgPSB0aGlzLmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdGhpcy54bWxucyksIEcgPSBpLlhNTF9FTlRJVElFUywgSyA9IEZbXCJcIl0gfHwgbnVsbDtcbiAgICBoKHgpID8gKEcgPSBpLkhUTUxfRU5USVRJRVMsIEsgPSBFLkhUTUwpIDogeCA9PT0gbS5YTUxfU1ZHX0lNQUdFICYmIChLID0gRS5TVkcpLCBGW1wiXCJdID0gSywgRi54bWwgPSBGLnhtbCB8fCBFLlhNTDtcbiAgICB2YXIgZWUgPSBuZXcgdGhpcy5kb21IYW5kbGVyKHtcbiAgICAgIG1pbWVUeXBlOiB4LFxuICAgICAgZGVmYXVsdE5hbWVzcGFjZTogSyxcbiAgICAgIG9uRXJyb3I6IHRoaXMub25FcnJvclxuICAgIH0pLCBJZSA9IHRoaXMubG9jYXRvciA/IHt9IDogdm9pZCAwO1xuICAgIHRoaXMubG9jYXRvciAmJiBlZS5zZXREb2N1bWVudExvY2F0b3IoSWUpO1xuICAgIHZhciB0ZSA9IG5ldyB2KCk7XG4gICAgdGUuZXJyb3JIYW5kbGVyID0gZWUsIHRlLmRvbUJ1aWxkZXIgPSBlZTtcbiAgICB2YXIgQmUgPSAhdC5pc0hUTUxNaW1lVHlwZSh4KTtcbiAgICByZXR1cm4gQmUgJiYgdHlwZW9mIGcgIT0gXCJzdHJpbmdcIiAmJiB0ZS5lcnJvckhhbmRsZXIuZmF0YWxFcnJvcihcInNvdXJjZSBpcyBub3QgYSBzdHJpbmdcIiksIHRlLnBhcnNlKHRoaXMubm9ybWFsaXplTGluZUVuZGluZ3MoU3RyaW5nKGcpKSwgRiwgRyksIGVlLmRvYy5kb2N1bWVudEVsZW1lbnQgfHwgdGUuZXJyb3JIYW5kbGVyLmZhdGFsRXJyb3IoXCJtaXNzaW5nIHJvb3QgZWxlbWVudFwiKSwgZWUuZG9jO1xuICB9O1xuICBmdW5jdGlvbiBDKGcpIHtcbiAgICB2YXIgeCA9IGcgfHwge307XG4gICAgdGhpcy5taW1lVHlwZSA9IHgubWltZVR5cGUgfHwgbS5YTUxfQVBQTElDQVRJT04sIHRoaXMuZGVmYXVsdE5hbWVzcGFjZSA9IHguZGVmYXVsdE5hbWVzcGFjZSB8fCBudWxsLCB0aGlzLmNkYXRhID0gITEsIHRoaXMuY3VycmVudEVsZW1lbnQgPSB2b2lkIDAsIHRoaXMuZG9jID0gdm9pZCAwLCB0aGlzLmxvY2F0b3IgPSB2b2lkIDAsIHRoaXMub25FcnJvciA9IHgub25FcnJvcjtcbiAgfVxuICBmdW5jdGlvbiBqKGcsIHgpIHtcbiAgICB4LmxpbmVOdW1iZXIgPSBnLmxpbmVOdW1iZXIsIHguY29sdW1uTnVtYmVyID0gZy5jb2x1bW5OdW1iZXI7XG4gIH1cbiAgQy5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogRWl0aGVyIGNyZWF0ZXMgYW4gWE1MIG9yIGFuIEhUTUwgZG9jdW1lbnQgYW5kIHN0b3JlcyBpdCB1bmRlciBgdGhpcy5kb2NgLlxuICAgICAqIElmIGl0IGlzIGFuIFhNTCBkb2N1bWVudCwgYHRoaXMuZGVmYXVsdE5hbWVzcGFjZWAgaXMgdXNlZCB0byBjcmVhdGUgaXQsXG4gICAgICogYW5kIGl0IHdpbGwgbm90IGNvbnRhaW4gYW55IGBjaGlsZE5vZGVzYC5cbiAgICAgKiBJZiBpdCBpcyBhbiBIVE1MIGRvY3VtZW50LCBpdCB3aWxsIGJlIGNyZWF0ZWQgd2l0aG91dCBhbnkgYGNoaWxkTm9kZXNgLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnNheHByb2plY3Qub3JnL2FwaWRvYy9vcmcveG1sL3NheC9Db250ZW50SGFuZGxlci5odG1sXG4gICAgICovXG4gICAgc3RhcnREb2N1bWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZyA9IG5ldyBhKCk7XG4gICAgICB0aGlzLmRvYyA9IHAodGhpcy5taW1lVHlwZSkgPyBnLmNyZWF0ZUhUTUxEb2N1bWVudCghMSkgOiBnLmNyZWF0ZURvY3VtZW50KHRoaXMuZGVmYXVsdE5hbWVzcGFjZSwgXCJcIik7XG4gICAgfSxcbiAgICBzdGFydEVsZW1lbnQ6IGZ1bmN0aW9uKGcsIHgsIEYsIEcpIHtcbiAgICAgIHZhciBLID0gdGhpcy5kb2MsIGVlID0gSy5jcmVhdGVFbGVtZW50TlMoZywgRiB8fCB4KSwgSWUgPSBHLmxlbmd0aDtcbiAgICAgICQodGhpcywgZWUpLCB0aGlzLmN1cnJlbnRFbGVtZW50ID0gZWUsIHRoaXMubG9jYXRvciAmJiBqKHRoaXMubG9jYXRvciwgZWUpO1xuICAgICAgZm9yICh2YXIgdGUgPSAwOyB0ZSA8IEllOyB0ZSsrKSB7XG4gICAgICAgIHZhciBnID0gRy5nZXRVUkkodGUpLCBCZSA9IEcuZ2V0VmFsdWUodGUpLCBGID0gRy5nZXRRTmFtZSh0ZSksIGQgPSBLLmNyZWF0ZUF0dHJpYnV0ZU5TKGcsIEYpO1xuICAgICAgICB0aGlzLmxvY2F0b3IgJiYgaihHLmdldExvY2F0b3IodGUpLCBkKSwgZC52YWx1ZSA9IGQubm9kZVZhbHVlID0gQmUsIGVlLnNldEF0dHJpYnV0ZU5vZGUoZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbmRFbGVtZW50OiBmdW5jdGlvbihnLCB4LCBGKSB7XG4gICAgICB0aGlzLmN1cnJlbnRFbGVtZW50ID0gdGhpcy5jdXJyZW50RWxlbWVudC5wYXJlbnROb2RlO1xuICAgIH0sXG4gICAgc3RhcnRQcmVmaXhNYXBwaW5nOiBmdW5jdGlvbihnLCB4KSB7XG4gICAgfSxcbiAgICBlbmRQcmVmaXhNYXBwaW5nOiBmdW5jdGlvbihnKSB7XG4gICAgfSxcbiAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgIHZhciBGID0gdGhpcy5kb2MuY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uKGcsIHgpO1xuICAgICAgdGhpcy5sb2NhdG9yICYmIGoodGhpcy5sb2NhdG9yLCBGKSwgJCh0aGlzLCBGKTtcbiAgICB9LFxuICAgIGlnbm9yYWJsZVdoaXRlc3BhY2U6IGZ1bmN0aW9uKGcsIHgsIEYpIHtcbiAgICB9LFxuICAgIGNoYXJhY3RlcnM6IGZ1bmN0aW9uKGcsIHgsIEYpIHtcbiAgICAgIGlmIChnID0gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBnKSB7XG4gICAgICAgIGlmICh0aGlzLmNkYXRhKVxuICAgICAgICAgIHZhciBHID0gdGhpcy5kb2MuY3JlYXRlQ0RBVEFTZWN0aW9uKGcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdmFyIEcgPSB0aGlzLmRvYy5jcmVhdGVUZXh0Tm9kZShnKTtcbiAgICAgICAgdGhpcy5jdXJyZW50RWxlbWVudCA/IHRoaXMuY3VycmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoRykgOiAvXlxccyokLy50ZXN0KGcpICYmIHRoaXMuZG9jLmFwcGVuZENoaWxkKEcpLCB0aGlzLmxvY2F0b3IgJiYgaih0aGlzLmxvY2F0b3IsIEcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2tpcHBlZEVudGl0eTogZnVuY3Rpb24oZykge1xuICAgIH0sXG4gICAgZW5kRG9jdW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb2Mubm9ybWFsaXplKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGxvY2F0b3IgdG8gYmUgYWJsZSB0byBzZXQgdGhlIGBjb2x1bW5OdW1iZXJgIGFuZCBgbGluZU51bWJlcmBcbiAgICAgKiBvbiB0aGUgY3JlYXRlZCBET00gbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2F0b3J9IGxvY2F0b3JcbiAgICAgKi9cbiAgICBzZXREb2N1bWVudExvY2F0b3I6IGZ1bmN0aW9uKGcpIHtcbiAgICAgIGcgJiYgKGcubGluZU51bWJlciA9IDApLCB0aGlzLmxvY2F0b3IgPSBnO1xuICAgIH0sXG4gICAgLy9MZXhpY2FsSGFuZGxlclxuICAgIGNvbW1lbnQ6IGZ1bmN0aW9uKGcsIHgsIEYpIHtcbiAgICAgIGcgPSBrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgRyA9IHRoaXMuZG9jLmNyZWF0ZUNvbW1lbnQoZyk7XG4gICAgICB0aGlzLmxvY2F0b3IgJiYgaih0aGlzLmxvY2F0b3IsIEcpLCAkKHRoaXMsIEcpO1xuICAgIH0sXG4gICAgc3RhcnRDREFUQTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNkYXRhID0gITA7XG4gICAgfSxcbiAgICBlbmRDREFUQTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNkYXRhID0gITE7XG4gICAgfSxcbiAgICBzdGFydERURDogZnVuY3Rpb24oZywgeCwgRiwgRykge1xuICAgICAgdmFyIEsgPSB0aGlzLmRvYy5pbXBsZW1lbnRhdGlvbjtcbiAgICAgIGlmIChLICYmIEsuY3JlYXRlRG9jdW1lbnRUeXBlKSB7XG4gICAgICAgIHZhciBlZSA9IEsuY3JlYXRlRG9jdW1lbnRUeXBlKGcsIHgsIEYsIEcpO1xuICAgICAgICB0aGlzLmxvY2F0b3IgJiYgaih0aGlzLmxvY2F0b3IsIGVlKSwgJCh0aGlzLCBlZSksIHRoaXMuZG9jLmRvY3R5cGUgPSBlZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcG9ydEVycm9yOiBmdW5jdGlvbihnLCB4KSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub25FcnJvciA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5vbkVycm9yKGcsIHgsIHRoaXMpO1xuICAgICAgICB9IGNhdGNoIChGKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGwoXCJSZXBvcnRpbmcgXCIgKyBnICsgJyBcIicgKyB4ICsgJ1wiIGNhdXNlZCAnICsgRiwgdGhpcy5sb2NhdG9yKTtcbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBjb25zb2xlLmVycm9yKFwiW3htbGRvbSBcIiArIGcgKyBcIl1cdFwiICsgeCwgUih0aGlzLmxvY2F0b3IpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cDovL3d3dy5zYXhwcm9qZWN0Lm9yZy9hcGlkb2Mvb3JnL3htbC9zYXgvRXJyb3JIYW5kbGVyLmh0bWxcbiAgICAgKi9cbiAgICB3YXJuaW5nOiBmdW5jdGlvbihnKSB7XG4gICAgICB0aGlzLnJlcG9ydEVycm9yKFwid2FybmluZ1wiLCBnKTtcbiAgICB9LFxuICAgIGVycm9yOiBmdW5jdGlvbihnKSB7XG4gICAgICB0aGlzLnJlcG9ydEVycm9yKFwiZXJyb3JcIiwgZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJlcG9ydHMgYSBmYXRhbCBlcnJvciBhbmQgdGhyb3dzIGEgUGFyc2VFcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICogLSBUaGUgbWVzc2FnZSB0byBiZSB1c2VkIGZvciByZXBvcnRpbmcgYW5kIHRocm93aW5nIHRoZSBlcnJvci5cbiAgICAgKiBAcmV0dXJucyB7bmV2ZXJ9XG4gICAgICogVGhpcyBmdW5jdGlvbiBhbHdheXMgdGhyb3dzIGFuIGVycm9yIGFuZCBuZXZlciByZXR1cm5zIGEgdmFsdWUuXG4gICAgICogQHRocm93cyB7UGFyc2VFcnJvcn1cbiAgICAgKiBBbHdheXMgdGhyb3dzIGEgUGFyc2VFcnJvciB3aXRoIHRoZSBwcm92aWRlZCBtZXNzYWdlLlxuICAgICAqL1xuICAgIGZhdGFsRXJyb3I6IGZ1bmN0aW9uKGcpIHtcbiAgICAgIHRocm93IHRoaXMucmVwb3J0RXJyb3IoXCJmYXRhbEVycm9yXCIsIGcpLCBuZXcgbChnLCB0aGlzLmxvY2F0b3IpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gUihnKSB7XG4gICAgaWYgKGcpXG4gICAgICByZXR1cm4gYFxuQCNbbGluZTpgICsgZy5saW5lTnVtYmVyICsgXCIsY29sOlwiICsgZy5jb2x1bW5OdW1iZXIgKyBcIl1cIjtcbiAgfVxuICBmdW5jdGlvbiBrKGcsIHgsIEYpIHtcbiAgICByZXR1cm4gdHlwZW9mIGcgPT0gXCJzdHJpbmdcIiA/IGcuc3Vic3RyKHgsIEYpIDogZy5sZW5ndGggPj0geCArIEYgfHwgeCA/IG5ldyBqYXZhLmxhbmcuU3RyaW5nKGcsIHgsIEYpICsgXCJcIiA6IGc7XG4gIH1cbiAgXCJlbmREVEQsc3RhcnRFbnRpdHksZW5kRW50aXR5LGF0dHJpYnV0ZURlY2wsZWxlbWVudERlY2wsZXh0ZXJuYWxFbnRpdHlEZWNsLGludGVybmFsRW50aXR5RGVjbCxyZXNvbHZlRW50aXR5LGdldEV4dGVybmFsU3Vic2V0LG5vdGF0aW9uRGVjbCx1bnBhcnNlZEVudGl0eURlY2xcIi5yZXBsYWNlKFxuICAgIC9cXHcrL2csXG4gICAgZnVuY3Rpb24oZykge1xuICAgICAgQy5wcm90b3R5cGVbZ10gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgZnVuY3Rpb24gJChnLCB4KSB7XG4gICAgZy5jdXJyZW50RWxlbWVudCA/IGcuY3VycmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoeCkgOiBnLmRvYy5hcHBlbmRDaGlsZCh4KTtcbiAgfVxuICBmdW5jdGlvbiBuZShnKSB7XG4gICAgaWYgKGcgPT09IFwiZXJyb3JcIikgdGhyb3cgXCJvbkVycm9yU3RvcFBhcnNpbmdcIjtcbiAgfVxuICBmdW5jdGlvbiBsZSgpIHtcbiAgICB0aHJvdyBcIm9uV2FybmluZ1N0b3BQYXJzaW5nXCI7XG4gIH1cbiAgcmV0dXJuIHJ0Ll9fRE9NSGFuZGxlciA9IEMsIHJ0LkRPTVBhcnNlciA9IGIsIHJ0Lm5vcm1hbGl6ZUxpbmVFbmRpbmdzID0gTywgcnQub25FcnJvclN0b3BQYXJzaW5nID0gbmUsIHJ0Lm9uV2FybmluZ1N0b3BQYXJzaW5nID0gbGUsIHJ0O1xufVxudmFyIHNyO1xuZnVuY3Rpb24gYm4oKSB7XG4gIGlmIChzcikgcmV0dXJuIEg7XG4gIHNyID0gMTtcbiAgdmFyIHQgPSBEdCgpO1xuICBILmFzc2lnbiA9IHQuYXNzaWduLCBILmhhc0RlZmF1bHRIVE1MTmFtZXNwYWNlID0gdC5oYXNEZWZhdWx0SFRNTE5hbWVzcGFjZSwgSC5pc0hUTUxNaW1lVHlwZSA9IHQuaXNIVE1MTWltZVR5cGUsIEguaXNWYWxpZE1pbWVUeXBlID0gdC5pc1ZhbGlkTWltZVR5cGUsIEguTUlNRV9UWVBFID0gdC5NSU1FX1RZUEUsIEguTkFNRVNQQUNFID0gdC5OQU1FU1BBQ0U7XG4gIHZhciBlID0gX3QoKTtcbiAgSC5ET01FeGNlcHRpb24gPSBlLkRPTUV4Y2VwdGlvbiwgSC5ET01FeGNlcHRpb25OYW1lID0gZS5ET01FeGNlcHRpb25OYW1lLCBILkV4Y2VwdGlvbkNvZGUgPSBlLkV4Y2VwdGlvbkNvZGUsIEguUGFyc2VFcnJvciA9IGUuUGFyc2VFcnJvcjtcbiAgdmFyIG4gPSBrcigpO1xuICBILkF0dHIgPSBuLkF0dHIsIEguQ0RBVEFTZWN0aW9uID0gbi5DREFUQVNlY3Rpb24sIEguQ2hhcmFjdGVyRGF0YSA9IG4uQ2hhcmFjdGVyRGF0YSwgSC5Db21tZW50ID0gbi5Db21tZW50LCBILkRvY3VtZW50ID0gbi5Eb2N1bWVudCwgSC5Eb2N1bWVudEZyYWdtZW50ID0gbi5Eb2N1bWVudEZyYWdtZW50LCBILkRvY3VtZW50VHlwZSA9IG4uRG9jdW1lbnRUeXBlLCBILkRPTUltcGxlbWVudGF0aW9uID0gbi5ET01JbXBsZW1lbnRhdGlvbiwgSC5FbGVtZW50ID0gbi5FbGVtZW50LCBILkVudGl0eSA9IG4uRW50aXR5LCBILkVudGl0eVJlZmVyZW5jZSA9IG4uRW50aXR5UmVmZXJlbmNlLCBILkxpdmVOb2RlTGlzdCA9IG4uTGl2ZU5vZGVMaXN0LCBILk5hbWVkTm9kZU1hcCA9IG4uTmFtZWROb2RlTWFwLCBILk5vZGUgPSBuLk5vZGUsIEguTm9kZUxpc3QgPSBuLk5vZGVMaXN0LCBILk5vdGF0aW9uID0gbi5Ob3RhdGlvbiwgSC5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSBuLlByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgSC5UZXh0ID0gbi5UZXh0LCBILlhNTFNlcmlhbGl6ZXIgPSBuLlhNTFNlcmlhbGl6ZXI7XG4gIHZhciBpID0gTm4oKTtcbiAgcmV0dXJuIEguRE9NUGFyc2VyID0gaS5ET01QYXJzZXIsIEgubm9ybWFsaXplTGluZUVuZGluZ3MgPSBpLm5vcm1hbGl6ZUxpbmVFbmRpbmdzLCBILm9uRXJyb3JTdG9wUGFyc2luZyA9IGkub25FcnJvclN0b3BQYXJzaW5nLCBILm9uV2FybmluZ1N0b3BQYXJzaW5nID0gaS5vbldhcm5pbmdTdG9wUGFyc2luZywgSDtcbn1cbmJuKCk7XG5jb25zdCBVdCA9IFwiVVNKXCI7XG52YXIgeGUgPSB7fSwgcXQsIGNyO1xuZnVuY3Rpb24gQ24oKSB7XG4gIHJldHVybiBjciB8fCAoY3IgPSAxLCBxdCA9ICgpID0+IHtcbiAgICBjb25zdCB0ID0gXCJcXFxcdWQ4MDAtXFxcXHVkZmZmXCIsIGggPSBcIlxcXFx1MDMwMC1cXFxcdTAzNmZcIiArIFwiXFxcXHVmZTIwLVxcXFx1ZmUyZlwiICsgXCJcXFxcdTIwZDAtXFxcXHUyMGZmXCIgKyBcIlxcXFx1MWFiMC1cXFxcdTFhZmZcIiArIFwiXFxcXHUxZGMwLVxcXFx1MWRmZlwiLCBwID0gXCJcXFxcdWZlMGVcXFxcdWZlMGZcIiwgZiA9IFwiXFxcXHVEODNEXFxcXHVEQzY5XFxcXHVEODNDXFxcXHVERkZCXFxcXHUyMDBEXFxcXHVEODNDXFxcXHVERjkzXCIsIG0gPSBgWyR7dH1dYCwgRSA9IGBbJHtofV1gLCBsID0gXCJcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl1cIiwgdiA9IGAoPzoke0V9fCR7bH0pYCwgTyA9IGBbXiR7dH1dYCwgYiA9IFwiKD86XFxcXHVEODNDW1xcXFx1RERFNi1cXFxcdURERkZdKXsyfVwiLCBDID0gXCJbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl1cIiwgaiA9IFwiXFxcXHUyMDBkXCIsIFIgPSBcIig/OlxcXFx1ZDgzY1xcXFx1ZGZmNFxcXFx1ZGI0MFxcXFx1ZGM2N1xcXFx1ZGI0MFxcXFx1ZGM2MlxcXFx1ZGI0MCg/OlxcXFx1ZGM2NXxcXFxcdWRjNzN8XFxcXHVkYzc3KVxcXFx1ZGI0MCg/OlxcXFx1ZGM2ZXxcXFxcdWRjNjN8XFxcXHVkYzZjKVxcXFx1ZGI0MCg/OlxcXFx1ZGM2N3xcXFxcdWRjNzR8XFxcXHVkYzczKVxcXFx1ZGI0MFxcXFx1ZGM3ZilcIiwgayA9IGBbJHtmfV1gLCAkID0gYCR7dn0/YCwgbmUgPSBgWyR7cH1dP2AsIGxlID0gYCg/OiR7an0oPzoke1tPLCBiLCBDXS5qb2luKFwifFwiKX0pJHtuZSArICR9KSpgLCBnID0gbmUgKyAkICsgbGUsIEYgPSBgKD86JHtbYCR7T30ke0V9P2AsIEUsIGIsIEMsIG0sIGtdLmpvaW4oXCJ8XCIpfSlgO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGAke1J9fCR7bH0oPz0ke2x9KXwke0YgKyBnfWAsIFwiZ1wiKTtcbiAgfSksIHF0O1xufVxudmFyIGxyO1xuZnVuY3Rpb24geW4oKSB7XG4gIGlmIChscikgcmV0dXJuIHhlO1xuICBsciA9IDE7XG4gIHZhciB0ID0geGUgJiYgeGUuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZiAmJiBmLl9fZXNNb2R1bGUgPyBmIDogeyBkZWZhdWx0OiBmIH07XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh4ZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICB2YXIgZSA9IHQoQ24oKSk7XG4gIGZ1bmN0aW9uIG4oZikge1xuICAgIGlmICh0eXBlb2YgZiAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBzdHJpbmcgaXMgZXhwZWN0ZWQgYXMgaW5wdXRcIik7XG4gICAgcmV0dXJuIGYubWF0Y2goZS5kZWZhdWx0KCkpIHx8IFtdO1xuICB9XG4gIHhlLnRvQXJyYXkgPSBuO1xuICBmdW5jdGlvbiBpKGYpIHtcbiAgICBpZiAodHlwZW9mIGYgIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgdmFyIG0gPSBmLm1hdGNoKGUuZGVmYXVsdCgpKTtcbiAgICByZXR1cm4gbSA9PT0gbnVsbCA/IDAgOiBtLmxlbmd0aDtcbiAgfVxuICB4ZS5sZW5ndGggPSBpO1xuICBmdW5jdGlvbiBvKGYsIG0sIEUpIHtcbiAgICBpZiAobSA9PT0gdm9pZCAwICYmIChtID0gMCksIHR5cGVvZiBmICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICh0eXBlb2YgbSAhPSBcIm51bWJlclwiIHx8IG0gPCAwKSAmJiAobSA9IDApLCB0eXBlb2YgRSA9PSBcIm51bWJlclwiICYmIEUgPCAwICYmIChFID0gMCk7XG4gICAgdmFyIGwgPSBmLm1hdGNoKGUuZGVmYXVsdCgpKTtcbiAgICByZXR1cm4gbCA/IGwuc2xpY2UobSwgRSkuam9pbihcIlwiKSA6IFwiXCI7XG4gIH1cbiAgeGUuc3Vic3RyaW5nID0gbztcbiAgZnVuY3Rpb24gYShmLCBtLCBFKSB7XG4gICAgaWYgKG0gPT09IHZvaWQgMCAmJiAobSA9IDApLCB0eXBlb2YgZiAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB2YXIgbCA9IGkoZik7XG4gICAgaWYgKHR5cGVvZiBtICE9IFwibnVtYmVyXCIgJiYgKG0gPSBwYXJzZUludChtLCAxMCkpLCBtID49IGwpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBtIDwgMCAmJiAobSArPSBsKTtcbiAgICB2YXIgdjtcbiAgICB0eXBlb2YgRSA+IFwidVwiID8gdiA9IGwgOiAodHlwZW9mIEUgIT0gXCJudW1iZXJcIiAmJiAoRSA9IHBhcnNlSW50KEUsIDEwKSksIHYgPSBFID49IDAgPyBFICsgbSA6IG0pO1xuICAgIHZhciBPID0gZi5tYXRjaChlLmRlZmF1bHQoKSk7XG4gICAgcmV0dXJuIE8gPyBPLnNsaWNlKG0sIHYpLmpvaW4oXCJcIikgOiBcIlwiO1xuICB9XG4gIHhlLnN1YnN0ciA9IGE7XG4gIGZ1bmN0aW9uIGgoZiwgbSwgRSwgbCkge1xuICAgIGlmIChtID09PSB2b2lkIDAgJiYgKG0gPSAxNiksIEUgPT09IHZvaWQgMCAmJiAoRSA9IFwiI1wiKSwgbCA9PT0gdm9pZCAwICYmIChsID0gXCJyaWdodFwiKSwgdHlwZW9mIGYgIT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbSAhPSBcIm51bWJlclwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgc3BlY2lmaWVkXCIpO1xuICAgIGlmIChbXCJsZWZ0XCIsIFwicmlnaHRcIl0uaW5kZXhPZihsKSA9PT0gLTEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWQgcG9zaXRpb24gc2hvdWxkIGJlIGVpdGhlciBsZWZ0IG9yIHJpZ2h0XCIpO1xuICAgIHR5cGVvZiBFICE9IFwic3RyaW5nXCIgJiYgKEUgPSBTdHJpbmcoRSkpO1xuICAgIHZhciB2ID0gaShmKTtcbiAgICBpZiAodiA+IG0pXG4gICAgICByZXR1cm4gbyhmLCAwLCBtKTtcbiAgICBpZiAodiA8IG0pIHtcbiAgICAgIHZhciBPID0gRS5yZXBlYXQobSAtIHYpO1xuICAgICAgcmV0dXJuIGwgPT09IFwibGVmdFwiID8gTyArIGYgOiBmICsgTztcbiAgICB9XG4gICAgcmV0dXJuIGY7XG4gIH1cbiAgeGUubGltaXQgPSBoO1xuICBmdW5jdGlvbiBwKGYsIG0sIEUpIHtcbiAgICBpZiAoRSA9PT0gdm9pZCAwICYmIChFID0gMCksIHR5cGVvZiBmICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIGlmIChmID09PSBcIlwiKVxuICAgICAgcmV0dXJuIG0gPT09IFwiXCIgPyAwIDogLTE7XG4gICAgRSA9IE51bWJlcihFKSwgRSA9IGlzTmFOKEUpID8gMCA6IEUsIG0gPSBTdHJpbmcobSk7XG4gICAgdmFyIGwgPSBuKGYpO1xuICAgIGlmIChFID49IGwubGVuZ3RoKVxuICAgICAgcmV0dXJuIG0gPT09IFwiXCIgPyBsLmxlbmd0aCA6IC0xO1xuICAgIGlmIChtID09PSBcIlwiKVxuICAgICAgcmV0dXJuIEU7XG4gICAgdmFyIHYgPSBuKG0pLCBPID0gITEsIGI7XG4gICAgZm9yIChiID0gRTsgYiA8IGwubGVuZ3RoOyBiICs9IDEpIHtcbiAgICAgIGZvciAodmFyIEMgPSAwOyBDIDwgdi5sZW5ndGggJiYgdltDXSA9PT0gbFtiICsgQ107IClcbiAgICAgICAgQyArPSAxO1xuICAgICAgaWYgKEMgPT09IHYubGVuZ3RoICYmIHZbQyAtIDFdID09PSBsW2IgKyBDIC0gMV0pIHtcbiAgICAgICAgTyA9ICEwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE8gPyBiIDogLTE7XG4gIH1cbiAgcmV0dXJuIHhlLmluZGV4T2YgPSBwLCB4ZTtcbn1cbnZhciBvdCA9IHluKCk7XG5mdW5jdGlvbiBxcih0KSB7XG4gIHJldHVybiB0ID8gQXJyYXkuaXNBcnJheSh0KSA/IHQgOiBbdF0gOiBbXTtcbn1cbmZ1bmN0aW9uIHh0KHQsIGUpIHtcbiAgaWYgKCEoZSA+IGNlKHQpIHx8IGUgPCAtY2UodCkpKVxuICAgIHJldHVybiBQdCh0LCBlLCAxKTtcbn1cbmZ1bmN0aW9uIEV0KHQsIGUpIHtcbiAgcmV0dXJuIGUgPCAwIHx8IGUgPiBjZSh0KSAtIDEgPyBcIlwiIDogUHQodCwgZSwgMSk7XG59XG5mdW5jdGlvbiBadSh0LCBlKSB7XG4gIGlmICghKGUgPCAwIHx8IGUgPiBjZSh0KSAtIDEpKVxuICAgIHJldHVybiBQdCh0LCBlLCAxKS5jb2RlUG9pbnRBdCgwKTtcbn1cbmZ1bmN0aW9uIFRuKHQsIGUsIG4gPSBjZSh0KSkge1xuICBjb25zdCBpID0gSW4odCwgZSk7XG4gIHJldHVybiAhKGkgPT09IC0xIHx8IGkgKyBjZShlKSAhPT0gbik7XG59XG5mdW5jdGlvbiB3bih0LCBlLCBuKSB7XG4gIGlmIChlIDwgMCkgcmV0dXJuIC0xO1xuICBpZiAobikge1xuICAgIGlmIChFdCh0LCBlKSA9PT0gXCJ9XCIgJiYgRXQodCwgZSAtIDEpID09PSBcIlxcXFxcIikgcmV0dXJuIGU7XG4gICAgY29uc3QgYSA9IFN0KHQsIFwiXFxcXH1cIiwgZSk7XG4gICAgcmV0dXJuIGEgPj0gMCA/IGEgKyAxIDogYTtcbiAgfVxuICBsZXQgaSA9IGU7XG4gIGNvbnN0IG8gPSBjZSh0KTtcbiAgZm9yICg7IGkgPCBvICYmIChpID0gU3QodCwgXCJ9XCIsIGkpLCAhKGkgPT09IC0xIHx8IEV0KHQsIGkgLSAxKSAhPT0gXCJcXFxcXCIpKTsgKVxuICAgIGkgKz0gMTtcbiAgcmV0dXJuIGkgPj0gbyA/IC0xIDogaTtcbn1cbmZ1bmN0aW9uIFNuKHQsIGUpIHtcbiAgY29uc3QgbiA9IFtdO1xuICBsZXQgaSA9IDAsIG8gPSAwO1xuICBmdW5jdGlvbiBhKHAsIGYsIG0pIHtcbiAgICBjb25zdCBFID0gdXQodCwgbywgZiksIGwgPSBuLmxlbmd0aCA+IDAgJiYgTWUobltuLmxlbmd0aCAtIDFdKSA/IGAke24ucG9wKCl9JHtFfWAgOiBFO1xuICAgIE1lKHApID8gbi5wdXNoKGAke2x9JHtwfWApIDogKGwgJiYgbi5wdXNoKGwpLCBuLnB1c2gocCkpLCBvID0gZiArIG07XG4gIH1cbiAgY29uc3QgaCA9IGNlKHQpO1xuICBmb3IgKDsgaSA8IGg7ICkge1xuICAgIHN3aXRjaCAoRXQodCwgaSkpIHtcbiAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgIGlmIChFdCh0LCBpIC0gMSkgIT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgY29uc3QgcCA9IHduKHQsIGksICExKTtcbiAgICAgICAgICBpZiAocCA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdXQodCwgaSArIDEsIHApLCBtID0gZiBpbiBlID8gKFxuICAgICAgICAgICAgICAvLyBKdXN0IGNoZWNrZWQgdGhhdCB0aGUga2V5IGlzIGluIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXR5cGUtYXNzZXJ0aW9uL25vLXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgIGVbZl1cbiAgICAgICAgICAgICkgOiBmO1xuICAgICAgICAgICAgYShtLCBpLCBwICsgMSAtIGkpLCBpID0gcCwgbyA9IHAgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgYShcIntcIiwgaSAtIDEsIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ9XCI6XG4gICAgICAgIEV0KHQsIGkgLSAxKSAhPT0gXCJcXFxcXCIgfHwgYShcIn1cIiwgaSAtIDEsIDIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaSArPSAxO1xuICB9XG4gIGlmIChvIDwgaCkge1xuICAgIGNvbnN0IHAgPSB1dCh0LCBvKTtcbiAgICBuLnB1c2goXG4gICAgICBuLmxlbmd0aCA+IDAgJiYgTWUobltuLmxlbmd0aCAtIDFdKSA/IGAke24ucG9wKCl9JHtwfWAgOiBwXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGVpKHQsIGUpIHtcbiAgcmV0dXJuIFNuKHQsIGUpLm1hcCgobikgPT4gYCR7bn1gKS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gT24odCwgZSwgbiA9IDApIHtcbiAgY29uc3QgaSA9IHV0KHQsIG4pO1xuICByZXR1cm4gU3QoaSwgZSkgIT09IC0xO1xufVxuZnVuY3Rpb24gU3QodCwgZSwgbiA9IDApIHtcbiAgcmV0dXJuIG90LmluZGV4T2YodCwgZSwgbik7XG59XG5mdW5jdGlvbiBJbih0LCBlLCBuKSB7XG4gIGxldCBpID0gbiA9PT0gdm9pZCAwID8gY2UodCkgOiBuO1xuICBpIDwgMCA/IGkgPSAwIDogaSA+PSBjZSh0KSAmJiAoaSA9IGNlKHQpIC0gMSk7XG4gIGZvciAobGV0IG8gPSBpOyBvID49IDA7IG8tLSlcbiAgICBpZiAoUHQodCwgbywgY2UoZSkpID09PSBlKVxuICAgICAgcmV0dXJuIG87XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGNlKHQpIHtcbiAgcmV0dXJuIG90Lmxlbmd0aCh0KTtcbn1cbmZ1bmN0aW9uIHRpKHQsIGUpIHtcbiAgY29uc3QgbiA9IGUudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIG4gPT09IFwiTk9ORVwiID8gdCA6IHQubm9ybWFsaXplKG4pO1xufVxuZnVuY3Rpb24gcmkodCwgZSwgbikge1xuICByZXR1cm4gdC5sb2NhbGVDb21wYXJlKGUsIFwiZW5cIiwgbik7XG59XG5mdW5jdGlvbiBuaSh0LCBlLCBuID0gXCIgXCIpIHtcbiAgcmV0dXJuIGUgPD0gY2UodCkgPyB0IDogb3QubGltaXQodCwgZSwgbiwgXCJyaWdodFwiKTtcbn1cbmZ1bmN0aW9uIHVpKHQsIGUsIG4gPSBcIiBcIikge1xuICByZXR1cm4gZSA8PSBjZSh0KSA/IHQgOiBvdC5saW1pdCh0LCBlLCBuLCBcImxlZnRcIik7XG59XG5mdW5jdGlvbiBmcih0LCBlKSB7XG4gIHJldHVybiBlID4gdCA/IHQgOiBlIDwgLXQgPyAwIDogZSA8IDAgPyBlICsgdCA6IGU7XG59XG5mdW5jdGlvbiBwcih0LCBlLCBuKSB7XG4gIGNvbnN0IGkgPSBjZSh0KTtcbiAgaWYgKGUgPiBpIHx8IG4gJiYgKGUgPiBuICYmICEoZSA+PSAwICYmIGUgPCBpICYmIG4gPCAwICYmIG4gPiAtaSkgfHwgbiA8IC1pKSlcbiAgICByZXR1cm4gXCJcIjtcbiAgY29uc3QgbyA9IGZyKGksIGUpLCBhID0gbiA/IGZyKGksIG4pIDogdm9pZCAwO1xuICByZXR1cm4gdXQodCwgbywgYSk7XG59XG5mdW5jdGlvbiBocih0LCBlLCBuKSB7XG4gIGNvbnN0IGkgPSBbXTtcbiAgaWYgKG4gIT09IHZvaWQgMCAmJiBuIDw9IDApXG4gICAgcmV0dXJuIFt0XTtcbiAgaWYgKGUgPT09IFwiXCIpIHJldHVybiB4bih0KS5zbGljZSgwLCBuKTtcbiAgbGV0IG8gPSBlO1xuICAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIiB8fCBlIGluc3RhbmNlb2YgUmVnRXhwICYmICFPbihlLmZsYWdzLCBcImdcIikpICYmIChvID0gbmV3IFJlZ0V4cChlLCBcImdcIikpO1xuICBjb25zdCBhID0gdC5tYXRjaChvKTtcbiAgbGV0IGggPSAwO1xuICBpZiAoIWEpIHJldHVybiBbdF07XG4gIGZvciAobGV0IHAgPSAwOyBwIDwgKG4gPyBuIC0gMSA6IGEubGVuZ3RoKTsgcCsrKSB7XG4gICAgY29uc3QgZiA9IFN0KHQsIGFbcF0sIGgpLCBtID0gY2UoYVtwXSk7XG4gICAgaWYgKGkucHVzaCh1dCh0LCBoLCBmKSksIGggPSBmICsgbSwgbiAhPT0gdm9pZCAwICYmIGkubGVuZ3RoID09PSBuKVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGkucHVzaCh1dCh0LCBoKSksIGk7XG59XG5mdW5jdGlvbiBVcih0LCBlLCBuID0gMCkge1xuICByZXR1cm4gU3QodCwgZSwgbikgPT09IG47XG59XG5mdW5jdGlvbiBQdCh0LCBlID0gMCwgbiA9IGNlKHQpIC0gZSkge1xuICByZXR1cm4gb3Quc3Vic3RyKHQsIGUsIG4pO1xufVxuZnVuY3Rpb24gdXQodCwgZSwgbiA9IGNlKHQpKSB7XG4gIHJldHVybiBvdC5zdWJzdHJpbmcodCwgZSwgbik7XG59XG5mdW5jdGlvbiB4bih0KSB7XG4gIHJldHVybiBvdC50b0FycmF5KHQpO1xufVxuZnVuY3Rpb24gaWkodCkge1xuICByZXR1cm4gVXIodCwgXCIlXCIpICYmIFRuKHQsIFwiJVwiKTtcbn1cbmZ1bmN0aW9uIG9pKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpO1xuICByZXR1cm4gdC5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZywgXCJcXFxcJCZcIikucmVwbGFjZSgvLS9nLCBcIlxcXFx4MmRcIik7XG59XG5mdW5jdGlvbiBhaSh0KSB7XG4gIHJldHVybiB0ID8gcXIodCkubWFwKFxuICAgIChpKSA9PiBBcnJheS5pc0FycmF5KGkpID8gaS5tYXAoKG8pID0+IG5ldyBSZWdFeHAobykpIDogbmV3IFJlZ0V4cChpKVxuICApIDogW107XG59XG5mdW5jdGlvbiBzaSh0KSB7XG4gIHJldHVybiB0ID8gcXIodCkubWFwKChpKSA9PiBuZXcgUmVnRXhwKGkpKSA6IFtdO1xufVxuY29uc3QgTW4gPSAoXG4gIC8vIFVzaW5nIHVuaWNvZGUgY29udHJvbCBjaGFyYWN0ZXJzIHRvIGJlIHZlcnkgZXhwbGljaXQgYWJvdXQgd2hpY2ggY2hhcmFjdGVycyB3ZSBhcmUgdXNpbmcuXG4gIC8vIFRoZSBmaXJzdCA2IGNoYXJhY3RlcnMgYXJlIHRoZSBjb250cm9sIGNoYXJhY3RlcnMgXFxmXFxuXFxyXFx0XFx2LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAvXltcXHUwMDBDXFx1MDAwQVxcdTAwMERcXHUwMDA5XFx1MDAwQlxcdTAwMjBcXHUwMGEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwYVxcdTIwMjhcXHUyMDI5XFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1MDA4NV0rJC9cbik7XG5mdW5jdGlvbiBtdCh0KSB7XG4gIHJldHVybiBNbi50ZXN0KHQpO1xufVxuZnVuY3Rpb24gY2kodCkge1xuICBsZXQgZSA9IFwiXCI7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IGkgPSB0W25dO1xuICAgIGlmIChpID09PSBpLnRvVXBwZXJDYXNlKCkgJiYgaSAhPT0gaS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgY29uc3QgYSA9IHRbbiAtIDFdO1xuICAgICAgICBpZiAoIShhID09PSBhLnRvVXBwZXJDYXNlKCkgJiYgYSAhPT0gYS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgICBlICs9IFwiLVwiO1xuICAgICAgICBlbHNlIGlmIChuICsgMSA8IHQubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgcCA9IHRbbiArIDFdO1xuICAgICAgICAgIHAgPT09IHAudG9Mb3dlckNhc2UoKSAmJiBwICE9PSBwLnRvVXBwZXJDYXNlKCkgJiYgKGUgKz0gXCItXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlICs9IGkudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2VcbiAgICAgIGUgKz0gaTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmNvbnN0IGp0ID0gW1wiY2hhcHRlclwiLCBcImJvb2tcIiwgXCJwYXJhXCIsIFwicm93XCIsIFwic2lkZWJhclwiLCBVdF0sIEJuID0gXCLigItcIiwganIgPSBbXG4gIHsgc2hvcnROYW1lOiBcIkVSUlwiLCBmdWxsTmFtZXM6IFtcIkVSUk9SXCJdLCBjaGFwdGVyczogLTEgfSxcbiAgeyBzaG9ydE5hbWU6IFwiR0VOXCIsIGZ1bGxOYW1lczogW1wiR2VuZXNpc1wiXSwgY2hhcHRlcnM6IDUwIH0sXG4gIHsgc2hvcnROYW1lOiBcIkVYT1wiLCBmdWxsTmFtZXM6IFtcIkV4b2R1c1wiXSwgY2hhcHRlcnM6IDQwIH0sXG4gIHsgc2hvcnROYW1lOiBcIkxFVlwiLCBmdWxsTmFtZXM6IFtcIkxldml0aWN1c1wiXSwgY2hhcHRlcnM6IDI3IH0sXG4gIHsgc2hvcnROYW1lOiBcIk5VTVwiLCBmdWxsTmFtZXM6IFtcIk51bWJlcnNcIl0sIGNoYXB0ZXJzOiAzNiB9LFxuICB7IHNob3J0TmFtZTogXCJERVVcIiwgZnVsbE5hbWVzOiBbXCJEZXV0ZXJvbm9teVwiXSwgY2hhcHRlcnM6IDM0IH0sXG4gIHsgc2hvcnROYW1lOiBcIkpPU1wiLCBmdWxsTmFtZXM6IFtcIkpvc2h1YVwiXSwgY2hhcHRlcnM6IDI0IH0sXG4gIHsgc2hvcnROYW1lOiBcIkpER1wiLCBmdWxsTmFtZXM6IFtcIkp1ZGdlc1wiXSwgY2hhcHRlcnM6IDIxIH0sXG4gIHsgc2hvcnROYW1lOiBcIlJVVFwiLCBmdWxsTmFtZXM6IFtcIlJ1dGhcIl0sIGNoYXB0ZXJzOiA0IH0sXG4gIHsgc2hvcnROYW1lOiBcIjFTQVwiLCBmdWxsTmFtZXM6IFtcIjEgU2FtdWVsXCJdLCBjaGFwdGVyczogMzEgfSxcbiAgeyBzaG9ydE5hbWU6IFwiMlNBXCIsIGZ1bGxOYW1lczogW1wiMiBTYW11ZWxcIl0sIGNoYXB0ZXJzOiAyNCB9LFxuICB7IHNob3J0TmFtZTogXCIxS0lcIiwgZnVsbE5hbWVzOiBbXCIxIEtpbmdzXCJdLCBjaGFwdGVyczogMjIgfSxcbiAgeyBzaG9ydE5hbWU6IFwiMktJXCIsIGZ1bGxOYW1lczogW1wiMiBLaW5nc1wiXSwgY2hhcHRlcnM6IDI1IH0sXG4gIHsgc2hvcnROYW1lOiBcIjFDSFwiLCBmdWxsTmFtZXM6IFtcIjEgQ2hyb25pY2xlc1wiXSwgY2hhcHRlcnM6IDI5IH0sXG4gIHsgc2hvcnROYW1lOiBcIjJDSFwiLCBmdWxsTmFtZXM6IFtcIjIgQ2hyb25pY2xlc1wiXSwgY2hhcHRlcnM6IDM2IH0sXG4gIHsgc2hvcnROYW1lOiBcIkVaUlwiLCBmdWxsTmFtZXM6IFtcIkV6cmFcIl0sIGNoYXB0ZXJzOiAxMCB9LFxuICB7IHNob3J0TmFtZTogXCJORUhcIiwgZnVsbE5hbWVzOiBbXCJOZWhlbWlhaFwiXSwgY2hhcHRlcnM6IDEzIH0sXG4gIHsgc2hvcnROYW1lOiBcIkVTVFwiLCBmdWxsTmFtZXM6IFtcIkVzdGhlclwiXSwgY2hhcHRlcnM6IDEwIH0sXG4gIHsgc2hvcnROYW1lOiBcIkpPQlwiLCBmdWxsTmFtZXM6IFtcIkpvYlwiXSwgY2hhcHRlcnM6IDQyIH0sXG4gIHsgc2hvcnROYW1lOiBcIlBTQVwiLCBmdWxsTmFtZXM6IFtcIlBzYWxtXCIsIFwiUHNhbG1zXCJdLCBjaGFwdGVyczogMTUwIH0sXG4gIHsgc2hvcnROYW1lOiBcIlBST1wiLCBmdWxsTmFtZXM6IFtcIlByb3ZlcmJzXCJdLCBjaGFwdGVyczogMzEgfSxcbiAgeyBzaG9ydE5hbWU6IFwiRUNDXCIsIGZ1bGxOYW1lczogW1wiRWNjbGVzaWFzdGVzXCJdLCBjaGFwdGVyczogMTIgfSxcbiAgeyBzaG9ydE5hbWU6IFwiU05HXCIsIGZ1bGxOYW1lczogW1wiU29uZyBvZiBTb2xvbW9uXCIsIFwiU29uZyBvZiBTb25nc1wiXSwgY2hhcHRlcnM6IDggfSxcbiAgeyBzaG9ydE5hbWU6IFwiSVNBXCIsIGZ1bGxOYW1lczogW1wiSXNhaWFoXCJdLCBjaGFwdGVyczogNjYgfSxcbiAgeyBzaG9ydE5hbWU6IFwiSkVSXCIsIGZ1bGxOYW1lczogW1wiSmVyZW1pYWhcIl0sIGNoYXB0ZXJzOiA1MiB9LFxuICB7IHNob3J0TmFtZTogXCJMQU1cIiwgZnVsbE5hbWVzOiBbXCJMYW1lbnRhdGlvbnNcIl0sIGNoYXB0ZXJzOiA1IH0sXG4gIHsgc2hvcnROYW1lOiBcIkVaS1wiLCBmdWxsTmFtZXM6IFtcIkV6ZWtpZWxcIl0sIGNoYXB0ZXJzOiA0OCB9LFxuICB7IHNob3J0TmFtZTogXCJEQU5cIiwgZnVsbE5hbWVzOiBbXCJEYW5pZWxcIl0sIGNoYXB0ZXJzOiAxMiB9LFxuICB7IHNob3J0TmFtZTogXCJIT1NcIiwgZnVsbE5hbWVzOiBbXCJIb3NlYVwiXSwgY2hhcHRlcnM6IDE0IH0sXG4gIHsgc2hvcnROYW1lOiBcIkpPTFwiLCBmdWxsTmFtZXM6IFtcIkpvZWxcIl0sIGNoYXB0ZXJzOiAzIH0sXG4gIHsgc2hvcnROYW1lOiBcIkFNT1wiLCBmdWxsTmFtZXM6IFtcIkFtb3NcIl0sIGNoYXB0ZXJzOiA5IH0sXG4gIHsgc2hvcnROYW1lOiBcIk9CQVwiLCBmdWxsTmFtZXM6IFtcIk9iYWRpYWhcIl0sIGNoYXB0ZXJzOiAxIH0sXG4gIHsgc2hvcnROYW1lOiBcIkpPTlwiLCBmdWxsTmFtZXM6IFtcIkpvbmFoXCJdLCBjaGFwdGVyczogNCB9LFxuICB7IHNob3J0TmFtZTogXCJNSUNcIiwgZnVsbE5hbWVzOiBbXCJNaWNhaFwiXSwgY2hhcHRlcnM6IDcgfSxcbiAgeyBzaG9ydE5hbWU6IFwiTkFNXCIsIGZ1bGxOYW1lczogW1wiTmFodW1cIl0sIGNoYXB0ZXJzOiAzIH0sXG4gIHsgc2hvcnROYW1lOiBcIkhBQlwiLCBmdWxsTmFtZXM6IFtcIkhhYmFra3VrXCJdLCBjaGFwdGVyczogMyB9LFxuICB7IHNob3J0TmFtZTogXCJaRVBcIiwgZnVsbE5hbWVzOiBbXCJaZXBoYW5pYWhcIl0sIGNoYXB0ZXJzOiAzIH0sXG4gIHsgc2hvcnROYW1lOiBcIkhBR1wiLCBmdWxsTmFtZXM6IFtcIkhhZ2dhaVwiXSwgY2hhcHRlcnM6IDIgfSxcbiAgeyBzaG9ydE5hbWU6IFwiWkVDXCIsIGZ1bGxOYW1lczogW1wiWmVjaGFyaWFoXCJdLCBjaGFwdGVyczogMTQgfSxcbiAgeyBzaG9ydE5hbWU6IFwiTUFMXCIsIGZ1bGxOYW1lczogW1wiTWFsYWNoaVwiXSwgY2hhcHRlcnM6IDQgfSxcbiAgeyBzaG9ydE5hbWU6IFwiTUFUXCIsIGZ1bGxOYW1lczogW1wiTWF0dGhld1wiXSwgY2hhcHRlcnM6IDI4IH0sXG4gIHsgc2hvcnROYW1lOiBcIk1SS1wiLCBmdWxsTmFtZXM6IFtcIk1hcmtcIl0sIGNoYXB0ZXJzOiAxNiB9LFxuICB7IHNob3J0TmFtZTogXCJMVUtcIiwgZnVsbE5hbWVzOiBbXCJMdWtlXCJdLCBjaGFwdGVyczogMjQgfSxcbiAgeyBzaG9ydE5hbWU6IFwiSkhOXCIsIGZ1bGxOYW1lczogW1wiSm9oblwiXSwgY2hhcHRlcnM6IDIxIH0sXG4gIHsgc2hvcnROYW1lOiBcIkFDVFwiLCBmdWxsTmFtZXM6IFtcIkFjdHNcIl0sIGNoYXB0ZXJzOiAyOCB9LFxuICB7IHNob3J0TmFtZTogXCJST01cIiwgZnVsbE5hbWVzOiBbXCJSb21hbnNcIl0sIGNoYXB0ZXJzOiAxNiB9LFxuICB7IHNob3J0TmFtZTogXCIxQ09cIiwgZnVsbE5hbWVzOiBbXCIxIENvcmludGhpYW5zXCJdLCBjaGFwdGVyczogMTYgfSxcbiAgeyBzaG9ydE5hbWU6IFwiMkNPXCIsIGZ1bGxOYW1lczogW1wiMiBDb3JpbnRoaWFuc1wiXSwgY2hhcHRlcnM6IDEzIH0sXG4gIHsgc2hvcnROYW1lOiBcIkdBTFwiLCBmdWxsTmFtZXM6IFtcIkdhbGF0aWFuc1wiXSwgY2hhcHRlcnM6IDYgfSxcbiAgeyBzaG9ydE5hbWU6IFwiRVBIXCIsIGZ1bGxOYW1lczogW1wiRXBoZXNpYW5zXCJdLCBjaGFwdGVyczogNiB9LFxuICB7IHNob3J0TmFtZTogXCJQSFBcIiwgZnVsbE5hbWVzOiBbXCJQaGlsaXBwaWFuc1wiXSwgY2hhcHRlcnM6IDQgfSxcbiAgeyBzaG9ydE5hbWU6IFwiQ09MXCIsIGZ1bGxOYW1lczogW1wiQ29sb3NzaWFuc1wiXSwgY2hhcHRlcnM6IDQgfSxcbiAgeyBzaG9ydE5hbWU6IFwiMVRIXCIsIGZ1bGxOYW1lczogW1wiMSBUaGVzc2Fsb25pYW5zXCJdLCBjaGFwdGVyczogNSB9LFxuICB7IHNob3J0TmFtZTogXCIyVEhcIiwgZnVsbE5hbWVzOiBbXCIyIFRoZXNzYWxvbmlhbnNcIl0sIGNoYXB0ZXJzOiAzIH0sXG4gIHsgc2hvcnROYW1lOiBcIjFUSVwiLCBmdWxsTmFtZXM6IFtcIjEgVGltb3RoeVwiXSwgY2hhcHRlcnM6IDYgfSxcbiAgeyBzaG9ydE5hbWU6IFwiMlRJXCIsIGZ1bGxOYW1lczogW1wiMiBUaW1vdGh5XCJdLCBjaGFwdGVyczogNCB9LFxuICB7IHNob3J0TmFtZTogXCJUSVRcIiwgZnVsbE5hbWVzOiBbXCJUaXR1c1wiXSwgY2hhcHRlcnM6IDMgfSxcbiAgeyBzaG9ydE5hbWU6IFwiUEhNXCIsIGZ1bGxOYW1lczogW1wiUGhpbGVtb25cIl0sIGNoYXB0ZXJzOiAxIH0sXG4gIHsgc2hvcnROYW1lOiBcIkhFQlwiLCBmdWxsTmFtZXM6IFtcIkhlYnJld3NcIl0sIGNoYXB0ZXJzOiAxMyB9LFxuICB7IHNob3J0TmFtZTogXCJKQVNcIiwgZnVsbE5hbWVzOiBbXCJKYW1lc1wiXSwgY2hhcHRlcnM6IDUgfSxcbiAgeyBzaG9ydE5hbWU6IFwiMVBFXCIsIGZ1bGxOYW1lczogW1wiMSBQZXRlclwiXSwgY2hhcHRlcnM6IDUgfSxcbiAgeyBzaG9ydE5hbWU6IFwiMlBFXCIsIGZ1bGxOYW1lczogW1wiMiBQZXRlclwiXSwgY2hhcHRlcnM6IDMgfSxcbiAgeyBzaG9ydE5hbWU6IFwiMUpOXCIsIGZ1bGxOYW1lczogW1wiMSBKb2huXCJdLCBjaGFwdGVyczogNSB9LFxuICB7IHNob3J0TmFtZTogXCIySk5cIiwgZnVsbE5hbWVzOiBbXCIyIEpvaG5cIl0sIGNoYXB0ZXJzOiAxIH0sXG4gIHsgc2hvcnROYW1lOiBcIjNKTlwiLCBmdWxsTmFtZXM6IFtcIjMgSm9oblwiXSwgY2hhcHRlcnM6IDEgfSxcbiAgeyBzaG9ydE5hbWU6IFwiSlVEXCIsIGZ1bGxOYW1lczogW1wiSnVkZVwiXSwgY2hhcHRlcnM6IDEgfSxcbiAgeyBzaG9ydE5hbWU6IFwiUkVWXCIsIGZ1bGxOYW1lczogW1wiUmV2ZWxhdGlvblwiXSwgY2hhcHRlcnM6IDIyIH1cbl0sIFJuID0gMSwgX24gPSBqci5sZW5ndGggLSAxLCBQbiA9IDEsIExuID0gMSwgbGkgPSB7XG4gIGJvb2s6IFwiR0VOXCIsXG4gIGNoYXB0ZXJOdW06IDEsXG4gIHZlcnNlTnVtOiAxXG59LCBGbiA9ICh0KSA9PiB7XG4gIHZhciBlO1xuICByZXR1cm4gKChlID0ganJbdF0pID09IG51bGwgPyB2b2lkIDAgOiBlLmNoYXB0ZXJzKSA/PyAtMTtcbn0sIGZpID0gKHQsIGUpID0+ICh7XG4gIGJvb2s6IGJlLmJvb2tOdW1iZXJUb0lkKFxuICAgIE1hdGgubWF4KFxuICAgICAgUm4sXG4gICAgICBNYXRoLm1pbihiZS5ib29rSWRUb051bWJlcih0LmJvb2spICsgZSwgX24pXG4gICAgKVxuICApLFxuICBjaGFwdGVyTnVtOiAxLFxuICB2ZXJzZU51bTogMVxufSksIHBpID0gKHQsIGUpID0+ICh7XG4gIC4uLnQsXG4gIGNoYXB0ZXJOdW06IE1hdGgubWluKFxuICAgIE1hdGgubWF4KFBuLCB0LmNoYXB0ZXJOdW0gKyBlKSxcbiAgICBGbihiZS5ib29rSWRUb051bWJlcih0LmJvb2spKVxuICApLFxuICB2ZXJzZU51bTogMVxufSksIGhpID0gKHQsIGUpID0+ICh7XG4gIC4uLnQsXG4gIHZlcnNlTnVtOiBNYXRoLm1heChMbiwgdC52ZXJzZU51bSArIGUpXG59KTtcbmFzeW5jIGZ1bmN0aW9uIGRpKHQsIGUsIG4pIHtcbiAgY29uc3QgaSA9IGJlLmJvb2tOdW1iZXJUb0lkKHQpO1xuICBpZiAoIVVyKEludGwuZ2V0Q2Fub25pY2FsTG9jYWxlcyhlKVswXSwgXCJ6aFwiKSlcbiAgICByZXR1cm4gbih7XG4gICAgICBsb2NhbGl6ZUtleTogYExvY2FsaXplZElkLiR7aX1gLFxuICAgICAgbGFuZ3VhZ2VzVG9TZWFyY2g6IFtlXVxuICAgIH0pO1xuICBjb25zdCBvID0gYXdhaXQgbih7XG4gICAgbG9jYWxpemVLZXk6IGBCb29rLiR7aX1gLFxuICAgIGxhbmd1YWdlc1RvU2VhcmNoOiBbZV1cbiAgfSksIGEgPSBocihvLCBcIi1cIik7XG4gIHJldHVybiBocihhWzBdLCBcIsO/MDhcIilbMF0udHJpbSgpO1xufVxuZnVuY3Rpb24gbWkodCkge1xuICByZXR1cm4gbmV3IExyKGJlLmJvb2tJZFRvTnVtYmVyKHQuYm9vayksIHQuY2hhcHRlck51bSwgdC52ZXJzZU51bSkuQkJCQ0NDO1xufVxuZnVuY3Rpb24gZHIodCkge1xuICByZXR1cm4gbmV3IExyKGJlLmJvb2tJZFRvTnVtYmVyKHQuYm9vayksIHQuY2hhcHRlck51bSwgdC52ZXJzZU51bSkuQkJCQ0NDVlZWO1xufVxuZnVuY3Rpb24gRWkodCwgZSkge1xuICByZXR1cm4gZHIodCkgLSBkcihlKTtcbn1cbmZ1bmN0aW9uIGtuKHQpIHtcbiAgcmV0dXJuIGAlc2Nyb2xsR3JvdXBfJHt0fSVgO1xufVxuZnVuY3Rpb24gZ2kodCkge1xuICByZXR1cm4gdC5tYXAoKGUpID0+IGtuKGUpKTtcbn1cbmZ1bmN0aW9uIERpKHQsIGUsIG4sIGkpIHtcbiAgbGV0IG87XG4gIHN3aXRjaCAoZSA/PyBcImlkXCIpIHtcbiAgICBjYXNlIFwiRW5nbGlzaFwiOlxuICAgICAgbyA9IGJlLmJvb2tJZFRvRW5nbGlzaE5hbWUodC5ib29rKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpZFwiOlxuICAgICAgbyA9IHQuYm9vaztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBvID0gZSA/PyBcIlwiO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGAke299JHtpID8/IFwiIFwifSR7dC5jaGFwdGVyTnVtfSR7biA/PyBcIjpcIn0ke3QudmVyc2VOdW19YDtcbn1cbmNvbnN0IHFuID0gKFxuICAvLyBVc2luZyB1bmljb2RlIGNvbnRyb2wgY2hhcmFjdGVycyB0byBiZSB2ZXJ5IGV4cGxpY2l0IGFib3V0IHdoaWNoIGNoYXJhY3RlcnMgd2UgYXJlIHVzaW5nLlxuICAvLyBUaGUgZmlyc3QgNiBjaGFyYWN0ZXJzIGFyZSB0aGUgY29udHJvbCBjaGFyYWN0ZXJzIFxcZlxcblxcclxcdFxcdi5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgL15bXFx1MDAwQ1xcdTAwMEFcXHUwMDBEXFx1MDAwOVxcdTAwMEJcXHUwMDIwXFx1MDBhMFxcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDI4XFx1MjAyOVxcdTIwMmZcXHUyMDVmXFx1MjAwQlxcdTAwODVdKyQvXG4pO1xuZnVuY3Rpb24gbXIodCkge1xuICByZXR1cm4gcW4udGVzdCh0KTtcbn1cbmNvbnN0IFVuID0gL15bXFx1MjAwZFxcdTIwMDNcXHUyMDAyXFx1MDAyMFxcdTAwYTBcXHUyMDJmXFx1MjAwOVxcdTIwMGFcXHUzMDAwXFx1MjAwYlxcdTIwMGNcXHUyMDYwXFx1MjAwZVxcdTIwMGZdKyQvO1xuZnVuY3Rpb24gam4odCkge1xuICByZXR1cm4gVW4udGVzdCh0KTtcbn1cbmZ1bmN0aW9uIEVyKHQpIHtcbiAgbGV0IGUgPSBcIlwiLCBuID0gITEsIGkgPSBcIlxcMFwiO1xuICBmb3IgKGxldCBvID0gMDsgbyA8IHQubGVuZ3RoOyBvICs9IDEpIHtcbiAgICBjb25zdCBhID0gdFtvXTtcbiAgICBhLmNoYXJDb2RlQXQoMCkgPCAzMiA/IChuIHx8IChlICs9IFwiIFwiKSwgbiA9ICEwKSA6ICFuICYmIGEgPT09IEJuICYmIG8gKyAxIDwgdC5sZW5ndGggJiYgbXIodFtvICsgMV0pIHx8IChtcihhKSA/IChuIHx8IChlICs9IGEpLCBuID0gITApIDogam4oYSkgJiYgaSA9PT0gYSB8fCAoZSArPSBhLCBuID0gITEpKSwgaSA9IGE7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBncih0KSB7XG4gIHJldHVybiAhdCB8fCB0Lmxlbmd0aCA9PT0gMCA/ICEwIDogdC5sZW5ndGggPT09IDEgJiYgKHRbMF0gPT09IHZvaWQgMCB8fCB0WzBdID09PSBcIlwiKTtcbn1cbmZ1bmN0aW9uIERyKHQsIGUpIHtcbiAgaWYgKCFlIHx8ICFqdC5pbmNsdWRlcyhlLnR5cGUpKSByZXR1cm4gITE7XG4gIGlmICghZS5jb250ZW50KVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBQYXJlbnQgJHtKU09OLnN0cmluZ2lmeShlKX0gb2YgJHtKU09OLnN0cmluZ2lmeSh0KX0gZG9lcyBub3QgaGF2ZSBhIGNvbnRlbnQgYXJyYXkhIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4hYFxuICAgICk7XG4gIHJldHVybiB0ID09PSBlLmNvbnRlbnRbZS5jb250ZW50Lmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gJHIodCwgZSwgbiwgaSkge1xuICBpZiAoIXQgJiYgIW4pIHJldHVybiAhMDtcbiAgaWYgKCF0IHx8ICFuKSByZXR1cm4gITE7XG4gIGNvbnN0IG8gPSBNZSh0KSwgYSA9IE1lKG4pO1xuICBpZiAobyAmJiBhKSB7XG4gICAgY29uc3QgaCA9IEVyKHQpLCBwID0gRXIobik7XG4gICAgaWYgKGggIT09IHApIHtcbiAgICAgIGlmICghbXQoeHQoaCwgLTEpID8/IFwiXCIpICYmICFtdCh4dChwLCAtMSkgPz8gXCJcIikgfHwgIURyKHQsIGUpIHx8ICFEcihuLCBpKSkgcmV0dXJuICExO1xuICAgICAgbGV0IGYgPSBoO1xuICAgICAgZm9yICg7IG10KHh0KGYsIC0xKSA/PyBcIlwiKTsgKSBmID0gcHIoZiwgMCwgLTEpO1xuICAgICAgbGV0IG0gPSBwO1xuICAgICAgZm9yICg7IG10KHh0KG0sIC0xKSA/PyBcIlwiKTsgKSBtID0gcHIobSwgMCwgLTEpO1xuICAgICAgaWYgKGYgIT09IG0pIHJldHVybiAhMTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIW8gJiYgIWEpIHtcbiAgICBjb25zdCBoID0gdCwgcCA9IG4sIGYgPSBPYmplY3Qua2V5cyhoKS5maWx0ZXIoXG4gICAgICAobCkgPT4gbCAhPT0gXCJjb250ZW50XCJcbiAgICApO1xuICAgIGlmIChmLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocCkuZmlsdGVyKChsKSA9PiBsICE9PSBcImNvbnRlbnRcIikubGVuZ3RoIHx8IGYuc29tZSgobCkgPT4gIShsIGluIHApIHx8IGhbbF0gIT09IHBbbF0pKSByZXR1cm4gITE7XG4gICAgY29uc3QgbSA9IGdyKGguY29udGVudCksIEUgPSBncihwLmNvbnRlbnQpO1xuICAgIGlmIChtICE9PSBFKSByZXR1cm4gITE7XG4gICAgaWYgKCFtICYmICFFKSB7XG4gICAgICBsZXQgbCA9IGguY29udGVudCwgdiA9IHAuY29udGVudDtcbiAgICAgIGNvbnN0IE8gPSBsW2wubGVuZ3RoIC0gMV07XG4gICAgICBqdC5pbmNsdWRlcyhoLnR5cGUpICYmIE1lKE8pICYmIG10KE8pICYmIChsID0gbC5zbGljZSgwLCAtMSkpO1xuICAgICAgY29uc3QgYiA9IHZbdi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChqdC5pbmNsdWRlcyhwLnR5cGUpICYmIE1lKGIpICYmIG10KGIpICYmICh2ID0gdi5zbGljZSgwLCAtMSkpLCBsLmxlbmd0aCAhPT0gdi5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgIGZvciAobGV0IEMgPSAwOyBDIDwgbC5sZW5ndGg7IEMgKz0gMSlcbiAgICAgICAgaWYgKCEkcihsW0NdLCBoLCB2W0NdLCBwKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgfVxuICB9IGVsc2VcbiAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIHZpKHQsIGUpIHtcbiAgcmV0dXJuICRyKHQsIHZvaWQgMCwgZSwgdm9pZCAwKTtcbn1cbmNvbnN0IEFpID0gKHQpID0+ICguLi5lKSA9PiB0Lm1hcCgoaSkgPT4gaSguLi5lKSkuZXZlcnkoKGkpID0+IGkpLCBOaSA9ICh0KSA9PiBhc3luYyAoLi4uZSkgPT4ge1xuICBjb25zdCBuID0gdC5tYXAoYXN5bmMgKGkpID0+IGkoLi4uZSkpO1xuICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKG4pKS5ldmVyeSgoaSkgPT4gaSk7XG59LCBNdCA9IFwiY2hhcHRlclwiLCBCdCA9IFwidmVyc2VcIjtcbnZhciAkbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLCBWbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIEduID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHZyKHQsIGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGksIG8sIGEpIHtcbiAgICByZXR1cm4gdChpLCBvLCBhKSAmJiBlKGksIG8sIGEpO1xuICB9O1xufVxuZnVuY3Rpb24gUnQodCkge1xuICByZXR1cm4gZnVuY3Rpb24obiwgaSwgbykge1xuICAgIGlmICghbiB8fCAhaSB8fCB0eXBlb2YgbiAhPSBcIm9iamVjdFwiIHx8IHR5cGVvZiBpICE9IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gdChuLCBpLCBvKTtcbiAgICB2YXIgYSA9IG8uY2FjaGUsIGggPSBhLmdldChuKSwgcCA9IGEuZ2V0KGkpO1xuICAgIGlmIChoICYmIHApXG4gICAgICByZXR1cm4gaCA9PT0gaSAmJiBwID09PSBuO1xuICAgIGEuc2V0KG4sIGkpLCBhLnNldChpLCBuKTtcbiAgICB2YXIgZiA9IHQobiwgaSwgbyk7XG4gICAgcmV0dXJuIGEuZGVsZXRlKG4pLCBhLmRlbGV0ZShpKSwgZjtcbiAgfTtcbn1cbmZ1bmN0aW9uIEFyKHQpIHtcbiAgcmV0dXJuICRuKHQpLmNvbmNhdChWbih0KSk7XG59XG52YXIgem4gPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uKHQsIGUpIHtcbiAgcmV0dXJuIEduLmNhbGwodCwgZSk7XG59O1xuZnVuY3Rpb24gYXQodCwgZSkge1xuICByZXR1cm4gdCA9PT0gZSB8fCAhdCAmJiAhZSAmJiB0ICE9PSB0ICYmIGUgIT09IGU7XG59XG52YXIgSG4gPSBcIl9fdlwiLCBKbiA9IFwiX19vXCIsIFhuID0gXCJfb3duZXJcIiwgTnIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBiciA9IE9iamVjdC5rZXlzO1xuZnVuY3Rpb24gWW4odCwgZSwgbikge1xuICB2YXIgaSA9IHQubGVuZ3RoO1xuICBpZiAoZS5sZW5ndGggIT09IGkpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKDsgaS0tID4gMDsgKVxuICAgIGlmICghbi5lcXVhbHModFtpXSwgZVtpXSwgaSwgaSwgdCwgZSwgbikpXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIFduKHQsIGUpIHtcbiAgcmV0dXJuIGF0KHQuZ2V0VGltZSgpLCBlLmdldFRpbWUoKSk7XG59XG5mdW5jdGlvbiBLbih0LCBlKSB7XG4gIHJldHVybiB0Lm5hbWUgPT09IGUubmFtZSAmJiB0Lm1lc3NhZ2UgPT09IGUubWVzc2FnZSAmJiB0LmNhdXNlID09PSBlLmNhdXNlICYmIHQuc3RhY2sgPT09IGUuc3RhY2s7XG59XG5mdW5jdGlvbiBRbih0LCBlKSB7XG4gIHJldHVybiB0ID09PSBlO1xufVxuZnVuY3Rpb24gQ3IodCwgZSwgbikge1xuICB2YXIgaSA9IHQuc2l6ZTtcbiAgaWYgKGkgIT09IGUuc2l6ZSlcbiAgICByZXR1cm4gITE7XG4gIGlmICghaSlcbiAgICByZXR1cm4gITA7XG4gIGZvciAodmFyIG8gPSBuZXcgQXJyYXkoaSksIGEgPSB0LmVudHJpZXMoKSwgaCwgcCwgZiA9IDA7IChoID0gYS5uZXh0KCkpICYmICFoLmRvbmU7ICkge1xuICAgIGZvciAodmFyIG0gPSBlLmVudHJpZXMoKSwgRSA9ICExLCBsID0gMDsgKHAgPSBtLm5leHQoKSkgJiYgIXAuZG9uZTsgKSB7XG4gICAgICBpZiAob1tsXSkge1xuICAgICAgICBsKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHYgPSBoLnZhbHVlLCBPID0gcC52YWx1ZTtcbiAgICAgIGlmIChuLmVxdWFscyh2WzBdLCBPWzBdLCBmLCBsLCB0LCBlLCBuKSAmJiBuLmVxdWFscyh2WzFdLCBPWzFdLCB2WzBdLCBPWzBdLCB0LCBlLCBuKSkge1xuICAgICAgICBFID0gb1tsXSA9ICEwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGwrKztcbiAgICB9XG4gICAgaWYgKCFFKVxuICAgICAgcmV0dXJuICExO1xuICAgIGYrKztcbiAgfVxuICByZXR1cm4gITA7XG59XG52YXIgWm4gPSBhdDtcbmZ1bmN0aW9uIGV1KHQsIGUsIG4pIHtcbiAgdmFyIGkgPSBicih0KSwgbyA9IGkubGVuZ3RoO1xuICBpZiAoYnIoZSkubGVuZ3RoICE9PSBvKVxuICAgIHJldHVybiAhMTtcbiAgZm9yICg7IG8tLSA+IDA7IClcbiAgICBpZiAoIVZyKHQsIGUsIG4sIGlbb10pKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBUdCh0LCBlLCBuKSB7XG4gIHZhciBpID0gQXIodCksIG8gPSBpLmxlbmd0aDtcbiAgaWYgKEFyKGUpLmxlbmd0aCAhPT0gbylcbiAgICByZXR1cm4gITE7XG4gIGZvciAodmFyIGEsIGgsIHA7IG8tLSA+IDA7IClcbiAgICBpZiAoYSA9IGlbb10sICFWcih0LCBlLCBuLCBhKSB8fCAoaCA9IE5yKHQsIGEpLCBwID0gTnIoZSwgYSksIChoIHx8IHApICYmICghaCB8fCAhcCB8fCBoLmNvbmZpZ3VyYWJsZSAhPT0gcC5jb25maWd1cmFibGUgfHwgaC5lbnVtZXJhYmxlICE9PSBwLmVudW1lcmFibGUgfHwgaC53cml0YWJsZSAhPT0gcC53cml0YWJsZSkpKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiB0dSh0LCBlKSB7XG4gIHJldHVybiBhdCh0LnZhbHVlT2YoKSwgZS52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gcnUodCwgZSkge1xuICByZXR1cm4gdC5zb3VyY2UgPT09IGUuc291cmNlICYmIHQuZmxhZ3MgPT09IGUuZmxhZ3M7XG59XG5mdW5jdGlvbiB5cih0LCBlLCBuKSB7XG4gIHZhciBpID0gdC5zaXplO1xuICBpZiAoaSAhPT0gZS5zaXplKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKCFpKVxuICAgIHJldHVybiAhMDtcbiAgZm9yICh2YXIgbyA9IG5ldyBBcnJheShpKSwgYSA9IHQudmFsdWVzKCksIGgsIHA7IChoID0gYS5uZXh0KCkpICYmICFoLmRvbmU7ICkge1xuICAgIGZvciAodmFyIGYgPSBlLnZhbHVlcygpLCBtID0gITEsIEUgPSAwOyAocCA9IGYubmV4dCgpKSAmJiAhcC5kb25lOyApIHtcbiAgICAgIGlmICghb1tFXSAmJiBuLmVxdWFscyhoLnZhbHVlLCBwLnZhbHVlLCBoLnZhbHVlLCBwLnZhbHVlLCB0LCBlLCBuKSkge1xuICAgICAgICBtID0gb1tFXSA9ICEwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIEUrKztcbiAgICB9XG4gICAgaWYgKCFtKVxuICAgICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIG51KHQsIGUpIHtcbiAgdmFyIG4gPSB0Lmxlbmd0aDtcbiAgaWYgKGUubGVuZ3RoICE9PSBuKVxuICAgIHJldHVybiAhMTtcbiAgZm9yICg7IG4tLSA+IDA7IClcbiAgICBpZiAodFtuXSAhPT0gZVtuXSlcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gdXUodCwgZSkge1xuICByZXR1cm4gdC5ob3N0bmFtZSA9PT0gZS5ob3N0bmFtZSAmJiB0LnBhdGhuYW1lID09PSBlLnBhdGhuYW1lICYmIHQucHJvdG9jb2wgPT09IGUucHJvdG9jb2wgJiYgdC5wb3J0ID09PSBlLnBvcnQgJiYgdC5oYXNoID09PSBlLmhhc2ggJiYgdC51c2VybmFtZSA9PT0gZS51c2VybmFtZSAmJiB0LnBhc3N3b3JkID09PSBlLnBhc3N3b3JkO1xufVxuZnVuY3Rpb24gVnIodCwgZSwgbiwgaSkge1xuICByZXR1cm4gKGkgPT09IFhuIHx8IGkgPT09IEpuIHx8IGkgPT09IEhuKSAmJiAodC4kJHR5cGVvZiB8fCBlLiQkdHlwZW9mKSA/ICEwIDogem4oZSwgaSkgJiYgbi5lcXVhbHModFtpXSwgZVtpXSwgaSwgaSwgdCwgZSwgbik7XG59XG52YXIgaXUgPSBcIltvYmplY3QgQXJndW1lbnRzXVwiLCBvdSA9IFwiW29iamVjdCBCb29sZWFuXVwiLCBhdSA9IFwiW29iamVjdCBEYXRlXVwiLCBzdSA9IFwiW29iamVjdCBFcnJvcl1cIiwgY3UgPSBcIltvYmplY3QgTWFwXVwiLCBsdSA9IFwiW29iamVjdCBOdW1iZXJdXCIsIGZ1ID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgcHUgPSBcIltvYmplY3QgUmVnRXhwXVwiLCBodSA9IFwiW29iamVjdCBTZXRdXCIsIGR1ID0gXCJbb2JqZWN0IFN0cmluZ11cIiwgbXUgPSBcIltvYmplY3QgVVJMXVwiLCBFdSA9IEFycmF5LmlzQXJyYXksIFRyID0gdHlwZW9mIEFycmF5QnVmZmVyID09IFwiZnVuY3Rpb25cIiAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcgPyBBcnJheUJ1ZmZlci5pc1ZpZXcgOiBudWxsLCB3ciA9IE9iamVjdC5hc3NpZ24sIGd1ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5mdW5jdGlvbiBEdSh0KSB7XG4gIHZhciBlID0gdC5hcmVBcnJheXNFcXVhbCwgbiA9IHQuYXJlRGF0ZXNFcXVhbCwgaSA9IHQuYXJlRXJyb3JzRXF1YWwsIG8gPSB0LmFyZUZ1bmN0aW9uc0VxdWFsLCBhID0gdC5hcmVNYXBzRXF1YWwsIGggPSB0LmFyZU51bWJlcnNFcXVhbCwgcCA9IHQuYXJlT2JqZWN0c0VxdWFsLCBmID0gdC5hcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsLCBtID0gdC5hcmVSZWdFeHBzRXF1YWwsIEUgPSB0LmFyZVNldHNFcXVhbCwgbCA9IHQuYXJlVHlwZWRBcnJheXNFcXVhbCwgdiA9IHQuYXJlVXJsc0VxdWFsO1xuICByZXR1cm4gZnVuY3Rpb24oYiwgQywgaikge1xuICAgIGlmIChiID09PSBDKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGlmIChiID09IG51bGwgfHwgQyA9PSBudWxsKVxuICAgICAgcmV0dXJuICExO1xuICAgIHZhciBSID0gdHlwZW9mIGI7XG4gICAgaWYgKFIgIT09IHR5cGVvZiBDKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmIChSICE9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIFIgPT09IFwibnVtYmVyXCIgPyBoKGIsIEMsIGopIDogUiA9PT0gXCJmdW5jdGlvblwiID8gbyhiLCBDLCBqKSA6ICExO1xuICAgIHZhciBrID0gYi5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoayAhPT0gQy5jb25zdHJ1Y3RvcilcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoayA9PT0gT2JqZWN0KVxuICAgICAgcmV0dXJuIHAoYiwgQywgaik7XG4gICAgaWYgKEV1KGIpKVxuICAgICAgcmV0dXJuIGUoYiwgQywgaik7XG4gICAgaWYgKFRyICE9IG51bGwgJiYgVHIoYikpXG4gICAgICByZXR1cm4gbChiLCBDLCBqKTtcbiAgICBpZiAoayA9PT0gRGF0ZSlcbiAgICAgIHJldHVybiBuKGIsIEMsIGopO1xuICAgIGlmIChrID09PSBSZWdFeHApXG4gICAgICByZXR1cm4gbShiLCBDLCBqKTtcbiAgICBpZiAoayA9PT0gTWFwKVxuICAgICAgcmV0dXJuIGEoYiwgQywgaik7XG4gICAgaWYgKGsgPT09IFNldClcbiAgICAgIHJldHVybiBFKGIsIEMsIGopO1xuICAgIHZhciAkID0gZ3UoYik7XG4gICAgcmV0dXJuICQgPT09IGF1ID8gbihiLCBDLCBqKSA6ICQgPT09IHB1ID8gbShiLCBDLCBqKSA6ICQgPT09IGN1ID8gYShiLCBDLCBqKSA6ICQgPT09IGh1ID8gRShiLCBDLCBqKSA6ICQgPT09IGZ1ID8gdHlwZW9mIGIudGhlbiAhPSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIEMudGhlbiAhPSBcImZ1bmN0aW9uXCIgJiYgcChiLCBDLCBqKSA6ICQgPT09IG11ID8gdihiLCBDLCBqKSA6ICQgPT09IHN1ID8gaShiLCBDLCBqKSA6ICQgPT09IGl1ID8gcChiLCBDLCBqKSA6ICQgPT09IG91IHx8ICQgPT09IGx1IHx8ICQgPT09IGR1ID8gZihiLCBDLCBqKSA6ICExO1xuICB9O1xufVxuZnVuY3Rpb24gdnUodCkge1xuICB2YXIgZSA9IHQuY2lyY3VsYXIsIG4gPSB0LmNyZWF0ZUN1c3RvbUNvbmZpZywgaSA9IHQuc3RyaWN0LCBvID0ge1xuICAgIGFyZUFycmF5c0VxdWFsOiBpID8gVHQgOiBZbixcbiAgICBhcmVEYXRlc0VxdWFsOiBXbixcbiAgICBhcmVFcnJvcnNFcXVhbDogS24sXG4gICAgYXJlRnVuY3Rpb25zRXF1YWw6IFFuLFxuICAgIGFyZU1hcHNFcXVhbDogaSA/IHZyKENyLCBUdCkgOiBDcixcbiAgICBhcmVOdW1iZXJzRXF1YWw6IFpuLFxuICAgIGFyZU9iamVjdHNFcXVhbDogaSA/IFR0IDogZXUsXG4gICAgYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbDogdHUsXG4gICAgYXJlUmVnRXhwc0VxdWFsOiBydSxcbiAgICBhcmVTZXRzRXF1YWw6IGkgPyB2cih5ciwgVHQpIDogeXIsXG4gICAgYXJlVHlwZWRBcnJheXNFcXVhbDogaSA/IFR0IDogbnUsXG4gICAgYXJlVXJsc0VxdWFsOiB1dVxuICB9O1xuICBpZiAobiAmJiAobyA9IHdyKHt9LCBvLCBuKG8pKSksIGUpIHtcbiAgICB2YXIgYSA9IFJ0KG8uYXJlQXJyYXlzRXF1YWwpLCBoID0gUnQoby5hcmVNYXBzRXF1YWwpLCBwID0gUnQoby5hcmVPYmplY3RzRXF1YWwpLCBmID0gUnQoby5hcmVTZXRzRXF1YWwpO1xuICAgIG8gPSB3cih7fSwgbywge1xuICAgICAgYXJlQXJyYXlzRXF1YWw6IGEsXG4gICAgICBhcmVNYXBzRXF1YWw6IGgsXG4gICAgICBhcmVPYmplY3RzRXF1YWw6IHAsXG4gICAgICBhcmVTZXRzRXF1YWw6IGZcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIEF1KHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUsIG4sIGksIG8sIGEsIGgsIHApIHtcbiAgICByZXR1cm4gdChlLCBuLCBwKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIE51KHQpIHtcbiAgdmFyIGUgPSB0LmNpcmN1bGFyLCBuID0gdC5jb21wYXJhdG9yLCBpID0gdC5jcmVhdGVTdGF0ZSwgbyA9IHQuZXF1YWxzLCBhID0gdC5zdHJpY3Q7XG4gIGlmIChpKVxuICAgIHJldHVybiBmdW5jdGlvbihmLCBtKSB7XG4gICAgICB2YXIgRSA9IGkoKSwgbCA9IEUuY2FjaGUsIHYgPSBsID09PSB2b2lkIDAgPyBlID8gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkgOiB2b2lkIDAgOiBsLCBPID0gRS5tZXRhO1xuICAgICAgcmV0dXJuIG4oZiwgbSwge1xuICAgICAgICBjYWNoZTogdixcbiAgICAgICAgZXF1YWxzOiBvLFxuICAgICAgICBtZXRhOiBPLFxuICAgICAgICBzdHJpY3Q6IGFcbiAgICAgIH0pO1xuICAgIH07XG4gIGlmIChlKVxuICAgIHJldHVybiBmdW5jdGlvbihmLCBtKSB7XG4gICAgICByZXR1cm4gbihmLCBtLCB7XG4gICAgICAgIGNhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgZXF1YWxzOiBvLFxuICAgICAgICBtZXRhOiB2b2lkIDAsXG4gICAgICAgIHN0cmljdDogYVxuICAgICAgfSk7XG4gICAgfTtcbiAgdmFyIGggPSB7XG4gICAgY2FjaGU6IHZvaWQgMCxcbiAgICBlcXVhbHM6IG8sXG4gICAgbWV0YTogdm9pZCAwLFxuICAgIHN0cmljdDogYVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oZiwgbSkge1xuICAgIHJldHVybiBuKGYsIG0sIGgpO1xuICB9O1xufVxudmFyIGJ1ID0gemUoKTtcbnplKHsgc3RyaWN0OiAhMCB9KTtcbnplKHsgY2lyY3VsYXI6ICEwIH0pO1xuemUoe1xuICBjaXJjdWxhcjogITAsXG4gIHN0cmljdDogITBcbn0pO1xuemUoe1xuICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhdDtcbiAgfVxufSk7XG56ZSh7XG4gIHN0cmljdDogITAsXG4gIGNyZWF0ZUludGVybmFsQ29tcGFyYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGF0O1xuICB9XG59KTtcbnplKHtcbiAgY2lyY3VsYXI6ICEwLFxuICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhdDtcbiAgfVxufSk7XG56ZSh7XG4gIGNpcmN1bGFyOiAhMCxcbiAgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXQ7XG4gIH0sXG4gIHN0cmljdDogITBcbn0pO1xuZnVuY3Rpb24gemUodCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XG4gIHZhciBlID0gdC5jaXJjdWxhciwgbiA9IGUgPT09IHZvaWQgMCA/ICExIDogZSwgaSA9IHQuY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yLCBvID0gdC5jcmVhdGVTdGF0ZSwgYSA9IHQuc3RyaWN0LCBoID0gYSA9PT0gdm9pZCAwID8gITEgOiBhLCBwID0gdnUodCksIGYgPSBEdShwKSwgbSA9IGkgPyBpKGYpIDogQXUoZik7XG4gIHJldHVybiBOdSh7IGNpcmN1bGFyOiBuLCBjb21wYXJhdG9yOiBmLCBjcmVhdGVTdGF0ZTogbywgZXF1YWxzOiBtLCBzdHJpY3Q6IGggfSk7XG59XG5mdW5jdGlvbiBDdSh0LCBlKSB7XG4gIHJldHVybiBidSh0LCBlKTtcbn1cbmZ1bmN0aW9uIHl1KHQsIGUpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IHR5cGVvZiBlKSByZXR1cm4gITE7XG4gIGlmICghdCAmJiAhZSkgcmV0dXJuICEwO1xuICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgIGNvbnN0IGEgPSBlLCBoID0gdDtcbiAgICByZXR1cm4gYS5sZW5ndGggPT09IDAgPyAhMCA6IGEuZXZlcnkoKHApID0+IGguaW5jbHVkZXMocCkpO1xuICB9XG4gIGlmICh0eXBlb2YgdCAhPSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBDdSh0LCBlKTtcbiAgY29uc3QgbiA9IGUsIGkgPSB0O1xuICBsZXQgbyA9ICEwO1xuICByZXR1cm4gT2JqZWN0LmtleXMobikuZm9yRWFjaCgoYSkgPT4ge1xuICAgIG8gJiYgKE9iamVjdC5oYXNPd24oaSwgYSkgJiYgeXUoaVthXSwgblthXSkgfHwgKG8gPSAhMSkpO1xuICB9KSwgbztcbn1cbmZ1bmN0aW9uIFNyKHQsIGUsIG4pIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHQsIChvLCBhKSA9PiB7XG4gICAgbGV0IGggPSBhO1xuICAgIHJldHVybiBlICYmIChoID0gZShvLCBoKSksIGggPT09IHZvaWQgMCAmJiAoaCA9IG51bGwpLCBoO1xuICB9LCBuKTtcbn1cbmZ1bmN0aW9uIFR1KHQsIGUpIHtcbiAgZnVuY3Rpb24gbihvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLmZvckVhY2goKGEpID0+IHtcbiAgICAgIG9bYV0gPT09IG51bGwgPyBvW2FdID0gdm9pZCAwIDogdHlwZW9mIG9bYV0gPT0gXCJvYmplY3RcIiAmJiAob1thXSA9IG4ob1thXSkpO1xuICAgIH0pLCBvO1xuICB9XG4gIGNvbnN0IGkgPSBKU09OLnBhcnNlKHQsIGUpO1xuICBpZiAoaSAhPT0gbnVsbClcbiAgICByZXR1cm4gdHlwZW9mIGkgPT0gXCJvYmplY3RcIiA/IG4oaSkgOiBpO1xufVxuZnVuY3Rpb24gYmkodCkge1xuICB0cnkge1xuICAgIGNvbnN0IGUgPSBTcih0KTtcbiAgICByZXR1cm4gZSA9PT0gU3IoVHUoZSkpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNvbnN0IENpID0gKHQpID0+IHQucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpLnJlcGxhY2UoLycvZywgXCImI3gyNztcIikucmVwbGFjZSgvXFwvL2csIFwiJiN4MkY7XCIpO1xuZnVuY3Rpb24geWkoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgbmF2aWdhdG9yLmxhbmd1YWdlcyA/IG5hdmlnYXRvci5sYW5ndWFnZXNbMF0gOiBuZXcgV3IoKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG59XG5mdW5jdGlvbiBUaSh0LCBlID0gMikge1xuICBpZiAodCA9PT0gMCkgcmV0dXJuIFwiMCBCeXRlc1wiO1xuICBjb25zdCBuID0gW1wiQnl0ZXNcIiwgXCJLQlwiLCBcIk1CXCIsIFwiR0JcIiwgXCJUQlwiLCBcIlBCXCIsIFwiRUJcIiwgXCJaQlwiLCBcIllCXCJdLCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZyh0KSAvIE1hdGgubG9nKDEwMjQpKSwgbyA9IG5baV07XG4gIHJldHVybiBgJHtuZXcgdW4oXCJlblwiLCB7XG4gICAgc3R5bGU6IFwiZGVjaW1hbFwiLFxuICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogZSxcbiAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDBcbiAgfSkuZm9ybWF0KHQgLyAxMDI0ICoqIGkpfSAke299YDtcbn1cbmNvbnN0IHd1ID0gMWUzLCBHciA9IDYwLCB6ciA9IEdyICogNjAsIFN1ID0genIgKiAyNDtcbmZ1bmN0aW9uIHdpKHQsIGUsIG4gPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkge1xuICBjb25zdCBpID0gTWF0aC5mbG9vcigoZS5nZXRUaW1lKCkgLSBuLmdldFRpbWUoKSkgLyB3dSksIG8gPSBNYXRoLnJvdW5kKGkgLyBTdSk7XG4gIGlmIChNYXRoLmFicyhvKSA+PSAxKSByZXR1cm4gdC5mb3JtYXQobywgXCJkYXlcIik7XG4gIGNvbnN0IGEgPSBNYXRoLnJvdW5kKGkgLyB6cik7XG4gIGlmIChNYXRoLmFicyhhKSA+PSAxKSByZXR1cm4gdC5mb3JtYXQoYSwgXCJob3VyXCIpO1xuICBjb25zdCBoID0gTWF0aC5yb3VuZChpIC8gR3IpO1xuICByZXR1cm4gTWF0aC5hYnMoaCkgPj0gMSA/IHQuZm9ybWF0KGgsIFwibWludXRlXCIpIDogdC5mb3JtYXQoaSwgXCJzZWNvbmRcIik7XG59XG5jb25zdCB6dCA9IHtcbiAgcHJvamVjdFNldHRpbmdzQ29udHJpYnV0aW9uOiB7XG4gICAgZGVzY3JpcHRpb246IFwiVGhlIGRhdGEgYW4gZXh0ZW5zaW9uIHByb3ZpZGVzIHRvIGluZm9ybSBQbGF0Zm9ybS5CaWJsZSBvZiB0aGUgcHJvamVjdCBzZXR0aW5ncyBpdCBwcm92aWRlc1wiLFxuICAgIGFueU9mOiBbXG4gICAgICB7XG4gICAgICAgICRyZWY6IFwiIy8kZGVmcy9wcm9qZWN0U2V0dGluZ3NHcm91cFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgJHJlZjogXCIjLyRkZWZzL3Byb2plY3RTZXR0aW5nc0dyb3VwXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAgcHJvamVjdFNldHRpbmdzR3JvdXA6IHtcbiAgICBkZXNjcmlwdGlvbjogXCJHcm91cCBvZiByZWxhdGVkIHNldHRpbmdzIGRlZmluaXRpb25zXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICBkZXNjcmlwdGlvbjogXCJsb2NhbGl6ZUtleSB0aGF0IGRpc3BsYXlzIGluIHRoZSBwcm9qZWN0IHNldHRpbmdzIGRpYWxvZyBhcyB0aGUgZ3JvdXAgbmFtZVwiLFxuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvbG9jYWxpemVLZXlcIlxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBcImxvY2FsaXplS2V5IHRoYXQgZGlzcGxheXMgaW4gdGhlIHByb2plY3Qgc2V0dGluZ3MgZGlhbG9nIHRvIGRlc2NyaWJlIHRoZSBncm91cFwiLFxuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvbG9jYWxpemVLZXlcIlxuICAgICAgfSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgJHJlZjogXCIjLyRkZWZzL3Byb2plY3RTZXR0aW5nUHJvcGVydGllc1wiXG4gICAgICB9XG4gICAgfSxcbiAgICByZXF1aXJlZDogW1wibGFiZWxcIiwgXCJwcm9wZXJ0aWVzXCJdXG4gIH0sXG4gIHByb2plY3RTZXR0aW5nUHJvcGVydGllczoge1xuICAgIGRlc2NyaXB0aW9uOiBcIk9iamVjdCB3aG9zZSBrZXlzIGFyZSBzZXR0aW5nIElEcyBhbmQgd2hvc2UgdmFsdWVzIGFyZSBzZXR0aW5ncyBvYmplY3RzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBwYXR0ZXJuUHJvcGVydGllczoge1xuICAgICAgXCJeW1xcXFx3XFxcXC1dK1xcXFwuW1xcXFx3XFxcXC1dKyRcIjoge1xuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvcHJvamVjdFNldHRpbmdcIlxuICAgICAgfVxuICAgIH0sXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXM6ICExXG4gIH0sXG4gIHByb2plY3RTZXR0aW5nOiB7XG4gICAgZGVzY3JpcHRpb246IFwiQSBkZXNjcmlwdGlvbiBvZiBhbiBleHRlbnNpb24ncyBzZXR0aW5nIGVudHJ5XCIsXG4gICAgYW55T2Y6IFtcbiAgICAgIHtcbiAgICAgICAgJHJlZjogXCIjLyRkZWZzL2V4dGVuc2lvbkNvbnRyb2xsZWRQcm9qZWN0U2V0dGluZ1wiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICBleHRlbnNpb25Db250cm9sbGVkUHJvamVjdFNldHRpbmc6IHtcbiAgICBkZXNjcmlwdGlvbjogXCJTZXR0aW5nIGRlZmluaXRpb24gdGhhdCBpcyB2YWxpZGF0ZWQgYnkgdGhlIGV4dGVuc2lvbi5cIixcbiAgICBhbGxPZjogW1xuICAgICAge1xuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvcHJvamVjdFNldHRpbmdCYXNlXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgICRyZWY6IFwiIy8kZGVmcy9tb2RpZmllckV4dGVuc2lvbkNvbnRyb2xsZWRcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAgcHJvamVjdFNldHRpbmdCYXNlOiB7XG4gICAgZGVzY3JpcHRpb246IFwiQmFzZSBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gZGVzY3JpYmUgYSBwcm9qZWN0IHNldHRpbmcgZW50cnlcIixcbiAgICBhbGxPZjogW1xuICAgICAge1xuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvc2V0dGluZ0Jhc2VcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgJHJlZjogXCIjLyRkZWZzL21vZGlmaWVyUHJvamVjdFwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICBtb2RpZmllclByb2plY3Q6IHtcbiAgICBkZXNjcmlwdGlvbjogXCJNb2RpZmllcyBzZXR0aW5nIHR5cGUgdG8gYmUgcHJvamVjdCBzZXR0aW5nXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBpbmNsdWRlUHJvamVjdEludGVyZmFjZXM6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBSZWdFeHBgIHBhdHRlcm4ocykgdG8gbWF0Y2ggYWdhaW5zdCBwcm9qZWN0cycgYHByb2plY3RJbnRlcmZhY2VgcyAodXNpbmcgdGhlIFtgdGVzdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JlZ0V4cC90ZXN0KSBmdW5jdGlvbikgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgc2hvdWxkIGJlIGluY2x1ZGVkLlxcblxcbklmIHRoaXMgaXMgb25lIHN0cmluZywgaXQgd2lsbCBiZSBtYXRjaGVkIGFnYWluc3QgYHByb2plY3RJbnRlcmZhY2Vgcy4gSWYgdGhpcyBpcyBhbiBhcnJheSwgZWFjaCBlbnRyeSBpcyBoYW5kbGVkIGJhc2VkIG9uIGl0cyB0eXBlIChhdCBsZWFzdCBvbmUgZW50cnkgbXVzdCBtYXRjaCBmb3IgdGhpcyBmaWx0ZXIgY29uZGl0aW9uIHRvIHBhc3MpOlxcblxcbi0gSWYgdGhlIGVudHJ5IGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIG1hdGNoZWQgYWdhaW5zdCBlYWNoIGBwcm9qZWN0SW50ZXJmYWNlYC4gSWYgYW55IG1hdGNoLCB0aGUgcHJvamVjdCB3aWxsIHBhc3MgdGhpcyBmaWx0ZXIgY29uZGl0aW9uXFxuLSBJZiB0aGUgZW50cnkgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgZWFjaCB3aWxsIGJlIG1hdGNoZWQgYWdhaW5zdCBlYWNoIGBwcm9qZWN0SW50ZXJmYWNlYC4gSWYgZXZlcnkgc3RyaW5nIG1hdGNoZXMgYWdhaW5zdCBhdCBsZWFzdCBvbmUgYHByb2plY3RJbnRlcmZhY2VgLCB0aGUgcHJvamVjdCB3aWxsIHBhc3MgdGhpcyBmaWx0ZXIgY29uZGl0aW9uXFxuXFxuSW4gb3RoZXIgd29yZHMsIGVhY2ggZW50cnkgaW4gdGhlIGZpcnN0LWxldmVsIGFycmF5IGlzIGBPUmAnZWQgdG9nZXRoZXIuIEVhY2ggZW50cnkgaW4gc2Vjb25kLWxldmVsIGFycmF5cyAoYXJyYXlzIHdpdGhpbiB0aGUgZmlyc3QtbGV2ZWwgYXJyYXkpIGFyZSBgQU5EYCdlZCB0b2dldGhlci5cXG5cXG5EZWZhdWx0cyB0byBhbGwge0BsaW5rIFByb2plY3RJbnRlcmZhY2VzfSwgc28gYWxsIHByb2plY3RzIHRoYXQgZG8gbm90IG1hdGNoIGBleGNsdWRlUHJvamVjdEludGVyZmFjZXNgIHdpbGwgYmUgaW5jbHVkZWRcXG5cXG5AZXhhbXBsZVxcblxcbmBgYHR5cGVzY3JpcHRcXG5pbmNsdWRlUHJvamVjdEludGVyZmFjZXM6IFsnb25lJywgWyd0d28nLCAndGhyZWUnXV07XFxuYGBgXFxuXFxuVGhpcyBmaWx0ZXIgY29uZGl0aW9uIHdpbGwgc3VjY2VlZCBvbiBwcm9qZWN0cyB3aG9zZSBgcHJvamVjdEludGVyZmFjZWBzIGZ1bGZpbGwgYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyAoQXQgbGVhc3Qgb25lIGVudHJ5IGluIHRoZSBhcnJheSBtdXN0IG1hdGNoKTpcXG5cXG4tIEluY2x1ZGUgYG9uZWBcXG4tIEluY2x1ZGUgYm90aCBgdHdvYCBhbmQgYHRocmVlYC5cIixcbiAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bGxcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICBpdGVtczogeyB0eXBlOiBcInN0cmluZ1wiIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBleGNsdWRlUHJvamVjdEludGVyZmFjZXM6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBSZWdFeHBgIHBhdHRlcm4ocykgdG8gbWF0Y2ggYWdhaW5zdCBwcm9qZWN0cycgYHByb2plY3RJbnRlcmZhY2VgcyAodXNpbmcgdGhlIFtgdGVzdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JlZ0V4cC90ZXN0KSBmdW5jdGlvbikgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgc2hvdWxkIGFic29sdXRlbHkgbm90IGJlIGluY2x1ZGVkIGV2ZW4gaWYgdGhleSBtYXRjaCB3aXRoIGBpbmNsdWRlUHJvamVjdEludGVyZmFjZXNgLlxcblxcbklmIHRoaXMgaXMgb25lIHN0cmluZywgaXQgd2lsbCBiZSBtYXRjaGVkIGFnYWluc3QgYHByb2plY3RJbnRlcmZhY2Vgcy4gSWYgdGhpcyBpcyBhbiBhcnJheSwgZWFjaCBlbnRyeSBpcyBoYW5kbGVkIGJhc2VkIG9uIGl0cyB0eXBlIChhdCBsZWFzdCBvbmUgZW50cnkgbXVzdCBtYXRjaCBmb3IgdGhpcyBmaWx0ZXIgY29uZGl0aW9uIHRvIGV4Y2x1ZGUgdGhlIHByb2plY3QpOlxcblxcbi0gSWYgdGhlIGVudHJ5IGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIG1hdGNoZWQgYWdhaW5zdCBlYWNoIGBwcm9qZWN0SW50ZXJmYWNlYC4gSWYgYW55IG1hdGNoLCB0aGUgcHJvamVjdCB3aWxsIHBhc3MgdGhpcyBmaWx0ZXIgY29uZGl0aW9uIGFuZCBleGNsdWRlIHRoZSBwcm9qZWN0XFxuLSBJZiB0aGUgZW50cnkgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgZWFjaCB3aWxsIGJlIG1hdGNoZWQgYWdhaW5zdCBlYWNoIGBwcm9qZWN0SW50ZXJmYWNlYC4gSWYgZXZlcnkgc3RyaW5nIG1hdGNoZXMgYWdhaW5zdCBhdCBsZWFzdCBvbmUgYHByb2plY3RJbnRlcmZhY2VgLCB0aGUgcHJvamVjdCB3aWxsIHBhc3MgdGhpcyBmaWx0ZXIgY29uZGl0aW9uIGFuZCBleGNsdWRlIHRoZSBwcm9qZWN0XFxuXFxuSW4gb3RoZXIgd29yZHMsIGVhY2ggZW50cnkgaW4gdGhlIGZpcnN0LWxldmVsIGFycmF5IGlzIGBPUmAnZWQgdG9nZXRoZXIuIEVhY2ggZW50cnkgaW4gc2Vjb25kLWxldmVsIGFycmF5cyAoYXJyYXlzIHdpdGhpbiB0aGUgZmlyc3QtbGV2ZWwgYXJyYXkpIGFyZSBgQU5EYCdlZCB0b2dldGhlci5cXG5cXG5EZWZhdWx0cyB0byBubyB7QGxpbmsgUHJvamVjdEludGVyZmFjZXN9LCBzbyBhbGwgcHJvamVjdHMgdGhhdCBtYXRjaCBgaW5jbHVkZVByb2plY3RJbnRlcmZhY2VzYCB3aWxsIGJlIGluY2x1ZGVkXFxuXFxuQGV4YW1wbGVcXG5cXG5gYGB0eXBlc2NyaXB0XFxuZXhjbHVkZVByb2plY3RJbnRlcmZhY2VzOiBbJ29uZScsIFsndHdvJywgJ3RocmVlJ11dO1xcbmBgYFxcblxcblRoaXMgZmlsdGVyIGNvbmRpdGlvbiB3aWxsIHN1Y2NlZWQgYW5kIGV4Y2x1ZGUgcHJvamVjdHMgd2hvc2UgYHByb2plY3RJbnRlcmZhY2VgcyBmdWxmaWxsIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgKEF0IGxlYXN0IG9uZSBlbnRyeSBpbiB0aGUgYXJyYXkgbXVzdCBtYXRjaCk6XFxuXFxuLSBJbmNsdWRlIGBvbmVgXFxuLSBJbmNsdWRlIGJvdGggYHR3b2AgYW5kIGB0aHJlZWAuXCIsXG4gICAgICAgIGFueU9mOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJudWxsXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICAgIGFueU9mOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgaXRlbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgaW5jbHVkZVBkcEZhY3RvcnlJZHM6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBSZWdFeHBgIHBhdHRlcm4ocykgdG8gbWF0Y2ggYWdhaW5zdCB0aGUgUHJvamVjdCBEYXRhIFByb3ZpZGVyIEZhY3RvcnkgSWRzIHRoYXQgcHJvdmlkZWQgZWFjaCBwcm9qZWN0J3MgbWV0YWRhdGEgKHVzaW5nIHRoZSBbYHRlc3RgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAvdGVzdCkgZnVuY3Rpb24pIHRvIGRldGVybWluZSBpZiB0aGUgcHJvamVjdHMgc2hvdWxkIGJlIGluY2x1ZGVkLlxcblxcbkRlZmF1bHRzIHRvIGFsbCBQcm9qZWN0IERhdGEgUHJvdmlkZXIgRmFjdG9yeSBJZHMsIHNvIGFsbCBwcm9qZWN0cyB0aGF0IGRvIG5vdCBtYXRjaCBgZXhjbHVkZVBkcEZhY3RvcnlJZHNgIHdpbGwgYmUgaW5jbHVkZWRcIixcbiAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bGxcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgaXRlbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgZXhjbHVkZVBkcEZhY3RvcnlJZHM6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBSZWdFeHBgIHBhdHRlcm4ocykgdG8gbWF0Y2ggYWdhaW5zdCB0aGUgUHJvamVjdCBEYXRhIFByb3ZpZGVyIEZhY3RvcnkgSWRzIHRoYXQgcHJvdmlkZWQgZWFjaCBwcm9qZWN0J3MgbWV0YWRhdGEgKHVzaW5nIHRoZSBbYHRlc3RgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAvdGVzdCkgZnVuY3Rpb24pIHRvIGRldGVybWluZSBpZiB0aGUgcHJvamVjdHMgc2hvdWxkIGFic29sdXRlbHkgbm90IGJlIGluY2x1ZGVkIGV2ZW4gaWYgdGhleSBtYXRjaCB3aXRoIGBpbmNsdWRlUHJvamVjdEludGVyZmFjZXNgLlxcblxcbkRlZmF1bHRzIHRvIG5vbmUsIHNvIGFsbCBwcm9qZWN0cyB0aGF0IG1hdGNoIGBpbmNsdWRlUGRwRmFjdG9yeUlkc2Agd2lsbCBiZSBpbmNsdWRlZFwiLFxuICAgICAgICBhbnlPZjogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVsbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICBpdGVtczogeyB0eXBlOiBcInN0cmluZ1wiIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNldHRpbmdzQ29udHJpYnV0aW9uOiB7XG4gICAgZGVzY3JpcHRpb246IFwiVGhlIGRhdGEgYW4gZXh0ZW5zaW9uIHByb3ZpZGVzIHRvIGluZm9ybSBQbGF0Zm9ybS5CaWJsZSBvZiB0aGUgc2V0dGluZ3MgaXQgcHJvdmlkZXNcIixcbiAgICBhbnlPZjogW1xuICAgICAge1xuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvc2V0dGluZ3NHcm91cFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgJHJlZjogXCIjLyRkZWZzL3NldHRpbmdzR3JvdXBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9LFxuICBzZXR0aW5nc0dyb3VwOiB7XG4gICAgZGVzY3JpcHRpb246IFwiR3JvdXAgb2YgcmVsYXRlZCBzZXR0aW5ncyBkZWZpbml0aW9uc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwibG9jYWxpemVLZXkgdGhhdCBkaXNwbGF5cyBpbiB0aGUgc2V0dGluZ3MgZGlhbG9nIGFzIHRoZSBncm91cCBuYW1lXCIsXG4gICAgICAgICRyZWY6IFwiIy8kZGVmcy9sb2NhbGl6ZUtleVwiXG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwibG9jYWxpemVLZXkgdGhhdCBkaXNwbGF5cyBpbiB0aGUgc2V0dGluZ3MgZGlhbG9nIHRvIGRlc2NyaWJlIHRoZSBncm91cFwiLFxuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvbG9jYWxpemVLZXlcIlxuICAgICAgfSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgJHJlZjogXCIjLyRkZWZzL3NldHRpbmdQcm9wZXJ0aWVzXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcXVpcmVkOiBbXCJsYWJlbFwiLCBcInByb3BlcnRpZXNcIl1cbiAgfSxcbiAgc2V0dGluZ1Byb3BlcnRpZXM6IHtcbiAgICBkZXNjcmlwdGlvbjogXCJPYmplY3Qgd2hvc2Uga2V5cyBhcmUgc2V0dGluZyBJRHMgYW5kIHdob3NlIHZhbHVlcyBhcmUgc2V0dGluZ3Mgb2JqZWN0c1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgcGF0dGVyblByb3BlcnRpZXM6IHtcbiAgICAgIFwiXltcXFxcdy1dK1xcXFwuW1xcXFx3LV0rJFwiOiB7XG4gICAgICAgICRyZWY6IFwiIy8kZGVmcy9zZXR0aW5nXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiAhMVxuICB9LFxuICBzZXR0aW5nOiB7XG4gICAgZGVzY3JpcHRpb246IFwiQSBkZXNjcmlwdGlvbiBvZiBhbiBleHRlbnNpb24ncyBzZXR0aW5nIGVudHJ5XCIsXG4gICAgYW55T2Y6IFtcbiAgICAgIHtcbiAgICAgICAgJHJlZjogXCIjLyRkZWZzL2V4dGVuc2lvbkNvbnRyb2xsZWRTZXR0aW5nXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIGV4dGVuc2lvbkNvbnRyb2xsZWRTZXR0aW5nOiB7XG4gICAgZGVzY3JpcHRpb246IFwiU2V0dGluZyBkZWZpbml0aW9uIHRoYXQgaXMgdmFsaWRhdGVkIGJ5IHRoZSBleHRlbnNpb24uXCIsXG4gICAgYWxsT2Y6IFtcbiAgICAgIHtcbiAgICAgICAgJHJlZjogXCIjLyRkZWZzL3NldHRpbmdCYXNlXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgICRyZWY6IFwiIy8kZGVmcy9tb2RpZmllckV4dGVuc2lvbkNvbnRyb2xsZWRcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAgc2V0dGluZ0Jhc2U6IHtcbiAgICBkZXNjcmlwdGlvbjogXCJCYXNlIGluZm9ybWF0aW9uIG5lZWRlZCB0byBkZXNjcmliZSBhIHNldHRpbmcgZW50cnlcIixcbiAgICBhbGxPZjogW1xuICAgICAge1xuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvc3RhdGVCYXNlXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwibG9jYWxpemVLZXkgdGhhdCBkaXNwbGF5cyBpbiB0aGUgc2V0dGluZ3MgZGlhbG9nIGFzIHRoZSBzZXR0aW5nIG5hbWVcIixcbiAgICAgICAgICAgICRyZWY6IFwiIy8kZGVmcy9sb2NhbGl6ZUtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwibG9jYWxpemVLZXkgdGhhdCBkaXNwbGF5cyBpbiB0aGUgc2V0dGluZ3MgZGlhbG9nIHRvIGRlc2NyaWJlIHRoZSBzZXR0aW5nXCIsXG4gICAgICAgICAgICAkcmVmOiBcIiMvJGRlZnMvbG9jYWxpemVLZXlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZWQ6IFtcImxhYmVsXCJdXG4gICAgICB9XG4gICAgXVxuICB9LFxuICBwcm9qZWN0U3RhdGVDb250cmlidXRpb246IHtcbiAgICBkZXNjcmlwdGlvbjogXCJUaGUgZGF0YSBhbiBleHRlbnNpb24gcHJvdmlkZXMgdG8gaW5mb3JtIFBsYXRmb3JtLkJpYmxlIG9mIHRoZSBwcm9qZWN0IHN0YXRlIGl0IHByb3ZpZGVzXCIsXG4gICAgJHJlZjogXCIjLyRkZWZzL3VzZXJTdGF0ZVByb3BlcnRpZXNcIlxuICB9LFxuICB1c2VyU3RhdGVDb250cmlidXRpb246IHtcbiAgICBkZXNjcmlwdGlvbjogXCJUaGUgZGF0YSBhbiBleHRlbnNpb24gcHJvdmlkZXMgdG8gaW5mb3JtIFBsYXRmb3JtLkJpYmxlIG9mIHRoZSB1c2VyIHN0YXRlIGl0IHByb3ZpZGVzXCIsXG4gICAgJHJlZjogXCIjLyRkZWZzL3VzZXJTdGF0ZVByb3BlcnRpZXNcIlxuICB9LFxuICB1c2VyU3RhdGVQcm9wZXJ0aWVzOiB7XG4gICAgZGVzY3JpcHRpb246IFwiT2JqZWN0IHdob3NlIGtleXMgYXJlIHN0YXRlIElEcyBhbmQgd2hvc2UgdmFsdWVzIGFyZSBzdGF0ZSBvYmplY3RzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBwYXR0ZXJuUHJvcGVydGllczoge1xuICAgICAgXCJeW1xcXFx3XFxcXC1dK1xcXFwuW1xcXFx3XFxcXC1dKyRcIjoge1xuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvdXNlclN0YXRlXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiAhMVxuICB9LFxuICB1c2VyU3RhdGU6IHtcbiAgICBkZXNjcmlwdGlvbjogXCJBIGRlc2NyaXB0aW9uIG9mIGFuIGV4dGVuc2lvbidzIHVzZXIgc3RhdGUgZW50cnlcIixcbiAgICBhbnlPZjogW1xuICAgICAge1xuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvZXh0ZW5zaW9uQ29udHJvbGxlZFN0YXRlXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIGV4dGVuc2lvbkNvbnRyb2xsZWRTdGF0ZToge1xuICAgIGRlc2NyaXB0aW9uOiBcIlN0YXRlIGRlZmluaXRpb24gdGhhdCBpcyB2YWxpZGF0ZWQgYnkgdGhlIGV4dGVuc2lvbi5cIixcbiAgICBhbGxPZjogW1xuICAgICAge1xuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvc3RhdGVCYXNlXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgICRyZWY6IFwiIy8kZGVmcy9tb2RpZmllckV4dGVuc2lvbkNvbnRyb2xsZWRcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAgbW9kaWZpZXJFeHRlbnNpb25Db250cm9sbGVkOiB7XG4gICAgZGVzY3JpcHRpb246ICdNb2RpZmllcyBzdGF0ZS9zZXR0aW5nIHR5cGUgdG8gYmUgZXh0ZW5zaW9uLWNvbnRyb2xsZWQuIFwiRXh0ZW5zaW9uLWNvbnRyb2xsZWRcIiBtZWFucyB0aGUgZXh0ZW5zaW9uIHByb3ZpZGVzIHRoZSBjb21wb25lbnQgYW5kIHRoZSB2YWxpZGF0b3IgZm9yIHRoZSBzdGF0ZS9zZXR0aW5nLCBzbyB0aGUgc3RhdGUvc2V0dGluZyBpcyBjb250cm9sbGVkIGJ5IHRoZSBleHRlbnNpb24uJyxcbiAgICBub3Q6IHtcbiAgICAgIGFueU9mOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgIHJlcXVpcmVkOiBbXCJwbGF0Zm9ybVR5cGVcIl1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgcmVxdWlyZWQ6IFtcInR5cGVcIl1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgc3RhdGVCYXNlOiB7XG4gICAgZGVzY3JpcHRpb246IFwiQmFzZSBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gZGVzY3JpYmUgYSBzdGF0ZSBlbnRyeVwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBkZXNjcmlwdGlvbjogXCJkZWZhdWx0IHZhbHVlIGZvciB0aGUgc3RhdGUvc2V0dGluZ1wiLFxuICAgICAgICB0eXBlOiBcImFueVwiXG4gICAgICB9LFxuICAgICAgZGVyaXZlc0Zyb206IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiYSBzdGF0ZS9zZXR0aW5nIElEIHdob3NlIHZhbHVlIHRvIHNldCB0byB0aGlzIHN0YXRlL3NldHRpbmcncyBzdGFydGluZyB2YWx1ZSB0aGUgZmlyc3QgdGltZSB0aGlzIHN0YXRlL3NldHRpbmcgaXMgbG9hZGVkXCIsXG4gICAgICAgICRyZWY6IFwiIy8kZGVmcy9pZFwiXG4gICAgICB9XG4gICAgfSxcbiAgICByZXF1aXJlZDogW1wiZGVmYXVsdFwiXVxuICB9LFxuICBsb2NhbGl6ZUtleToge1xuICAgIGRlc2NyaXB0aW9uOiBcIklkZW50aWZpZXIgZm9yIGEgc3RyaW5nIHRoYXQgd2lsbCBiZSBsb2NhbGl6ZWQgYmFzZWQgb24gdGhlIHVzZXIncyBVSSBsYW5ndWFnZVwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgcGF0dGVybjogXCJeJVtcXFxcd1xcXFwtXFxcXC5dKyUkXCIsXG4gICAgdHNUeXBlOiBcIkxvY2FsaXplS2V5XCJcbiAgfSxcbiAgaWQ6IHtcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHBhdHRlcm46IFwiXltcXFxcd1xcXFwtXStcXFxcLltcXFxcd1xcXFwtXSskXCIsXG4gICAgdHNUeXBlOiBcIklkXCJcbiAgfVxufTtcbmZ1bmN0aW9uIEh0KHQpIHtcbiAgdCAmJiBPYmplY3QudmFsdWVzKHQpLmZvckVhY2goKGUpID0+IHtcbiAgICBpZiAoZS50eXBlKSB7XG4gICAgICBpZiAoXCJ0c1R5cGVcIiBpbiBlICYmIGRlbGV0ZSBlLnRzVHlwZSwgZS50eXBlID09PSBcImFueVwiKSB7XG4gICAgICAgIGRlbGV0ZSBlLnR5cGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBIdChlLnByb3BlcnRpZXMpO1xuICAgIH1cbiAgfSk7XG59XG5IdCh6dCk7XG5jb25zdCBPdSA9IHtcbiAgJHNjaGVtYTogXCJodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDIwLTEyL3NjaGVtYVwiLFxuICB0aXRsZTogXCJQcm9qZWN0IFNldHRpbmdzIENvbnRyaWJ1dGlvblwiLFxuICBkZXNjcmlwdGlvbjogXCJUaGUgZGF0YSBhbiBleHRlbnNpb24gcHJvdmlkZXMgdG8gaW5mb3JtIFBsYXRmb3JtLkJpYmxlIG9mIHRoZSBwcm9qZWN0IHNldHRpbmdzIGl0IHByb3ZpZGVzXCIsXG4gIGFueU9mOiBbXG4gICAge1xuICAgICAgJHJlZjogXCIjLyRkZWZzL3Byb2plY3RTZXR0aW5nc0dyb3VwXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgICRyZWY6IFwiIy8kZGVmcy9wcm9qZWN0U2V0dGluZ3NHcm91cFwiXG4gICAgICB9XG4gICAgfVxuICBdLFxuICAkZGVmczogenRcbn07XG5PYmplY3QuZnJlZXplKE91KTtcbmNvbnN0IEl1ID0ge1xuICAkc2NoZW1hOiBcImh0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMjAtMTIvc2NoZW1hXCIsXG4gIHRpdGxlOiBcIlNldHRpbmdzIENvbnRyaWJ1dGlvblwiLFxuICBkZXNjcmlwdGlvbjogXCJUaGUgZGF0YSBhbiBleHRlbnNpb24gcHJvdmlkZXMgdG8gaW5mb3JtIFBsYXRmb3JtLkJpYmxlIG9mIHRoZSBzZXR0aW5ncyBpdCBwcm92aWRlc1wiLFxuICBhbnlPZjogW1xuICAgIHtcbiAgICAgICRyZWY6IFwiIy8kZGVmcy9zZXR0aW5nc0dyb3VwXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgICRyZWY6IFwiIy8kZGVmcy9zZXR0aW5nc0dyb3VwXCJcbiAgICAgIH1cbiAgICB9XG4gIF0sXG4gICRkZWZzOiB6dFxufTtcbk9iamVjdC5mcmVlemUoSXUpO1xuY29uc3QgSHIgPSB7XG4gIGxhbmd1YWdlU3RyaW5nczoge1xuICAgIGRlc2NyaXB0aW9uOiBcIk1hcCB3aG9zZSBrZXlzIGFyZSBsb2NhbGl6ZWQgc3RyaW5nIGtleXMgYW5kIHdob3NlIHZhbHVlcyBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IGhvdyB0byBsb2NhbGl6ZSBzdHJpbmdzIGZvciB0aGUgbG9jYWxpemVkIHN0cmluZyBrZXlcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7XG4gICAgICBcIl4lW1xcXFx3XFxcXC1cXFxcLl0rJSRcIjoge1xuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvbG9jYWxpemVkU3RyaW5nVmFsdWVcIlxuICAgICAgfVxuICAgIH0sXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXM6ICExXG4gIH0sXG4gIGxvY2FsaXplZFN0cmluZ1ZhbHVlOiB7XG4gICAgZGVzY3JpcHRpb246IFwiTG9jYWxpemVkIHN0cmluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXlcIixcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH0sXG4gIHN0cmluZ3NNZXRhZGF0YToge1xuICAgIGRlc2NyaXB0aW9uOiBcIk1hcCB3aG9zZSBrZXlzIGFyZSBsb2NhbGl6ZWQgc3RyaW5nIGtleXMgYW5kIHdob3NlIHZhbHVlcyBwcm92aWRlIGFkZGl0aW9uYWwgbm9uLWxvY2FsZS1zcGVjaWZpYyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbG9jYWxpemVkIHN0cmluZyBrZXlcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7XG4gICAgICBcIl4lW1xcXFx3XFxcXC1cXFxcLl0rJSRcIjoge1xuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvc3RyaW5nTWV0YWRhdGFcIlxuICAgICAgfVxuICAgIH0sXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXM6ICExXG4gIH0sXG4gIHN0cmluZ01ldGFkYXRhOiB7XG4gICAgZGVzY3JpcHRpb246IFwiQWRkaXRpb25hbCBub24tbG9jYWxlLXNwZWNpZmljIGluZm9ybWF0aW9uIGFib3V0IGEgbG9jYWxpemVkIHN0cmluZyBrZXlcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGZhbGxiYWNrS2V5OiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkxvY2FsaXplZCBzdHJpbmcga2V5IGZyb20gd2hpY2ggdG8gZ2V0IHRoaXMgdmFsdWUgaWYgb25lIGRvZXMgbm90IGV4aXN0IGluIHRoZSBzcGVjaWZpZWQgbGFuZ3VhZ2UuIElmIGEgbmV3IGtleS92YWx1ZSBwYWlyIG5lZWRzIHRvIGJlIG1hZGUgdG8gcmVwbGFjZSBhbiBleGlzdGluZyBvbmUsIHRoaXMgY291bGQgaGVscCBzbW9vdGggb3ZlciB0aGUgdHJhbnNpdGlvbiBpZiB0aGUgbWVhbmluZ3MgYXJlIGNsb3NlIGVub3VnaC5cXG5Zb3UgY2FuIHVzZSBQYXJhdGV4dCA5IExvY2FsaXplZCBTdHJpbmcgS2V5cyBoZXJlLiBCZSBzdXJlIHRvIGVzY2FwZSBhbnkgJSBzaWducyB3aXRoIGEgYmFja3NsYXNoIGBcXFxcYC5cIixcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgcGF0dGVybjogXCJeJVtcXFxcd1xcXFwtXFxcXC47JiwnICgpe30jOi9cXFxcXFxcXD8l4ouufFtcXFxcXeKAnOKAneKAmOKAmSF+KsKgKz3igKJg4oCm4oCL4oaR4oaTXSslJFwiLFxuICAgICAgICB0c1R5cGU6IFwiTG9jYWxpemVLZXlcIlxuICAgICAgfSxcbiAgICAgIG5vdGVzOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcHJvdmlkZWQgYnkgZGV2ZWxvcGVycyBpbiBFbmdsaXNoIHRvIGhlbHAgdGhlIHRyYW5zbGF0b3IgdG8ga25vdyBob3cgdG8gdHJhbnNsYXRlIHRoaXMgbG9jYWxpemVkIHN0cmluZyBhY2N1cmF0ZWx5XCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGxvY2FsaXplS2V5OiB7XG4gICAgZGVzY3JpcHRpb246IFwiSWRlbnRpZmllciBmb3IgYSBzdHJpbmcgdGhhdCB3aWxsIGJlIGxvY2FsaXplZCBiYXNlZCBvbiB0aGUgdXNlcidzIFVJIGxhbmd1YWdlXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBwYXR0ZXJuOiBcIl4lW1xcXFx3XFxcXC1cXFxcLl0rJSRcIixcbiAgICB0c1R5cGU6IFwiTG9jYWxpemVLZXlcIlxuICB9XG59O1xuSHQoSHIpO1xuY29uc3QgeHUgPSB7XG4gICRzY2hlbWE6IFwiaHR0cHM6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQvMjAyMC0xMi9zY2hlbWFcIixcbiAgdGl0bGU6IFwiTG9jYWxpemVkIFN0cmluZyBEYXRhIENvbnRyaWJ1dGlvblwiLFxuICBkZXNjcmlwdGlvbjogXCJUaGUgZGF0YSBhbiBleHRlbnNpb24gcHJvdmlkZXMgdG8gaW5mb3JtIFBsYXRmb3JtLkJpYmxlIG9mIHRoZSBsb2NhbGl6ZWQgc3RyaW5ncyBpdCBwcm92aWRlcy5cIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgcHJvcGVydGllczoge1xuICAgIG1ldGFkYXRhOiB7XG4gICAgICAkcmVmOiBcIiMvJGRlZnMvc3RyaW5nc01ldGFkYXRhXCJcbiAgICB9LFxuICAgIGxvY2FsaXplZFN0cmluZ3M6IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICAkcmVmOiBcIiMvJGRlZnMvbGFuZ3VhZ2VTdHJpbmdzXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICRkZWZzOiBIclxufTtcbk9iamVjdC5mcmVlemUoeHUpO1xuY29uc3QgTXUgPSB7XG4gIHRpdGxlOiBcIlBsYXRmb3JtLkJpYmxlIG1lbnVzXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBtYWluTWVudToge1xuICAgICAgZGVzY3JpcHRpb246IFwiVG9wIGxldmVsIG1lbnUgZm9yIHRoZSBhcHBsaWNhdGlvblwiLFxuICAgICAgJHJlZjogXCIjLyRkZWZzL211bHRpQ29sdW1uTWVudVwiXG4gICAgfSxcbiAgICBkZWZhdWx0V2ViVmlld1RvcE1lbnU6IHtcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkRlZmF1bHQgdG9wIG1lbnUgZm9yIHdlYiB2aWV3cyB0aGF0IGRvbid0IHNwZWNpZnkgdGhlaXIgb3duXCIsXG4gICAgICAkcmVmOiBcIiMvJGRlZnMvbXVsdGlDb2x1bW5NZW51XCJcbiAgICB9LFxuICAgIGRlZmF1bHRXZWJWaWV3Q29udGV4dE1lbnU6IHtcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkRlZmF1bHQgY29udGV4dCBtZW51IGZvciB3ZWIgdmlld3MgdGhhdCBkb24ndCBzcGVjaWZ5IHRoZWlyIG93blwiLFxuICAgICAgJHJlZjogXCIjLyRkZWZzL3NpbmdsZUNvbHVtbk1lbnVcIlxuICAgIH0sXG4gICAgd2ViVmlld01lbnVzOiB7XG4gICAgICBkZXNjcmlwdGlvbjogXCJNZW51cyB0aGF0IGFwcGx5IHBlciB3ZWIgdmlldyBpbiB0aGUgYXBwbGljYXRpb25cIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwYXR0ZXJuUHJvcGVydGllczoge1xuICAgICAgICBcIl5bXFxcXHdcXFxcLV0rXFxcXC5bXFxcXHdcXFxcLV0rJFwiOiB7XG4gICAgICAgICAgJHJlZjogXCIjLyRkZWZzL21lbnVzRm9yT25lV2ViVmlld1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogITFcbiAgICB9XG4gIH0sXG4gIHJlcXVpcmVkOiBbXCJtYWluTWVudVwiLCBcImRlZmF1bHRXZWJWaWV3VG9wTWVudVwiLCBcImRlZmF1bHRXZWJWaWV3Q29udGV4dE1lbnVcIiwgXCJ3ZWJWaWV3TWVudXNcIl0sXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiAhMSxcbiAgJGRlZnM6IHtcbiAgICBsb2NhbGl6ZUtleToge1xuICAgICAgZGVzY3JpcHRpb246IFwiSWRlbnRpZmllciBmb3IgYSBzdHJpbmcgdGhhdCB3aWxsIGJlIGxvY2FsaXplZCBpbiBhIG1lbnUgYmFzZWQgb24gdGhlIHVzZXIncyBVSSBsYW5ndWFnZVwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHBhdHRlcm46IFwiXiVbXFxcXHdcXFxcLVxcXFwuXSslJFwiXG4gICAgfSxcbiAgICByZWZlcmVuY2VkSXRlbToge1xuICAgICAgZGVzY3JpcHRpb246IFwiTmFtZSBvZiBzb21lIFVJIGVsZW1lbnQgKGkuZS4sIHRhYiwgY29sdW1uLCBncm91cCwgbWVudSBpdGVtKSBvciBzb21lIFBBUEkgb2JqZWN0IChpLmUuLCBjb21tYW5kKVwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHBhdHRlcm46IFwiXltcXFxcd1xcXFwtXStcXFxcLltcXFxcd1xcXFwtXSskXCJcbiAgICB9LFxuICAgIGNvbHVtbnNXaXRoSGVhZGVyczoge1xuICAgICAgZGVzY3JpcHRpb246IFwiR3JvdXAgb2YgY29sdW1ucyB0aGF0IGNhbiBiZSBjb21iaW5lZCB3aXRoIG90aGVyIGNvbHVtbnMgdG8gZm9ybSBhIG11bHRpLWNvbHVtbiBtZW51XCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcGF0dGVyblByb3BlcnRpZXM6IHtcbiAgICAgICAgXCJeW1xcXFx3XFxcXC1dK1xcXFwuW1xcXFx3XFxcXC1dKyRcIjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlNpbmdsZSBjb2x1bW4gd2l0aCBhIGhlYWRlciBzdHJpbmdcIixcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkhlYWRlciB0ZXh0IGZvciB0aGlzIHRoaXMgY29sdW1uIGluIHRoZSBVSVwiLFxuICAgICAgICAgICAgICAkcmVmOiBcIiMvJGRlZnMvbG9jYWxpemVLZXlcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvY2FsaXplTm90ZXM6IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBwcm92aWRlZCBieSBkZXZlbG9wZXJzIHRvIGhlbHAgcGVvcGxlIHdobyBwZXJmb3JtIGxvY2FsaXphdGlvblwiLFxuICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3JkZXI6IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUmVsYXRpdmUgb3JkZXIgb2YgdGhpcyBjb2x1bW4gY29tcGFyZWQgdG8gb3RoZXIgY29sdW1ucyAoc29ydGVkIGFzY2VuZGluZylcIixcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRXh0ZW5zaWJsZToge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJEZWZpbmVzIHdoZXRoZXIgY29udHJpYnV0aW9ucyBhcmUgYWxsb3dlZCB0byBhZGQgbWVudSBncm91cHMgdG8gdGhpcyBjb2x1bW5cIixcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlcXVpcmVkOiBbXCJsYWJlbFwiLCBcIm9yZGVyXCJdLFxuICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiAhMVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBpc0V4dGVuc2libGU6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJEZWZpbmVzIHdoZXRoZXIgY29udHJpYnV0aW9ucyBhcmUgYWxsb3dlZCB0byBhZGQgY29sdW1ucyB0byB0aGlzIG11bHRpLWNvbHVtbiBtZW51XCIsXG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbWVudUdyb3Vwczoge1xuICAgICAgZGVzY3JpcHRpb246IFwiR3JvdXAgb2YgbWVudSBpdGVtcyB0aGF0IGNhbiBiZSBjb21iaW5lZCB3aXRoIG90aGVyIGdyb3VwcyB0byBmb3JtIGEgc2luZ2xlIG1lbnUvc3VibWVudS4gR3JvdXBzIGFyZSBzZXBhcmF0ZWQgdXNpbmcgYSBsaW5lIHdpdGhpbiB0aGUgbWVudS9zdWJtZW51LlwiLFxuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7XG4gICAgICAgIFwiXltcXFxcd1xcXFwtXStcXFxcLltcXFxcd1xcXFwtXSskXCI6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJTaW5nbGUgZ3JvdXAgdGhhdCBjb250YWlucyBtZW51IGl0ZW1zXCIsXG4gICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICBvbmVPZjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiB7XG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJDb2x1bW4gd2hlcmUgdGhpcyBncm91cCBiZWxvbmdzLCBub3QgcmVxdWlyZWQgZm9yIHNpbmdsZSBjb2x1bW4gbWVudXNcIixcbiAgICAgICAgICAgICAgICAgICRyZWY6IFwiIy8kZGVmcy9yZWZlcmVuY2VkSXRlbVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcmRlcjoge1xuICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUmVsYXRpdmUgb3JkZXIgb2YgdGhpcyBncm91cCBjb21wYXJlZCB0byBvdGhlciBncm91cHMgaW4gdGhlIHNhbWUgY29sdW1uIG9yIHN1Ym1lbnUgKHNvcnRlZCBhc2NlbmRpbmcpXCIsXG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0V4dGVuc2libGU6IHtcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkRlZmluZXMgd2hldGhlciBjb250cmlidXRpb25zIGFyZSBhbGxvd2VkIHRvIGFkZCBtZW51IGl0ZW1zIHRvIHRoaXMgbWVudSBncm91cFwiLFxuICAgICAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJvcmRlclwiXSxcbiAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6ICExXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgbWVudUl0ZW06IHtcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIk1lbnUgaXRlbSB0aGF0IGFuY2hvcnMgdGhlIHN1Ym1lbnUgd2hlcmUgdGhpcyBncm91cCBiZWxvbmdzXCIsXG4gICAgICAgICAgICAgICAgICAkcmVmOiBcIiMvJGRlZnMvcmVmZXJlbmNlZEl0ZW1cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3JkZXI6IHtcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlbGF0aXZlIG9yZGVyIG9mIHRoaXMgZ3JvdXAgY29tcGFyZWQgdG8gb3RoZXIgZ3JvdXBzIGluIHRoZSBzYW1lIGNvbHVtbiBvciBzdWJtZW51IChzb3J0ZWQgYXNjZW5kaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNFeHRlbnNpYmxlOiB7XG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJEZWZpbmVzIHdoZXRoZXIgY29udHJpYnV0aW9ucyBhcmUgYWxsb3dlZCB0byBhZGQgbWVudSBpdGVtcyB0byB0aGlzIG1lbnUgZ3JvdXBcIixcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZXF1aXJlZDogW1wibWVudUl0ZW1cIiwgXCJvcmRlclwiXSxcbiAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6ICExXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6ICExXG4gICAgfSxcbiAgICBtZW51SXRlbToge1xuICAgICAgZGVzY3JpcHRpb246IFwiU2luZ2xlIGl0ZW0gaW4gYSBtZW51IHRoYXQgY2FuIGJlIGNsaWNrZWQgb24gdG8gdGFrZSBhbiBhY3Rpb24gb3IgY2FuIGJlIHRoZSBwYXJlbnQgb2YgYSBzdWJtZW51XCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgb25lT2Y6IFtcbiAgICAgICAge1xuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIklEIGZvciB0aGlzIG1lbnUgaXRlbSB0aGF0IGhvbGRzIGEgc3VibWVudVwiLFxuICAgICAgICAgICAgICAkcmVmOiBcIiMvJGRlZnMvcmVmZXJlbmNlZEl0ZW1cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVxdWlyZWQ6IFtcImlkXCJdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBjb21tYW5kOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIk5hbWUgb2YgdGhlIFBBUEkgY29tbWFuZCB0byBydW4gd2hlbiB0aGlzIG1lbnUgaXRlbSBpcyBzZWxlY3RlZC5cIixcbiAgICAgICAgICAgICAgJHJlZjogXCIjLyRkZWZzL3JlZmVyZW5jZWRJdGVtXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpY29uUGF0aEJlZm9yZToge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJVcmkgcGF0aCB0byB0aGUgaWNvbiB0byBkaXNwbGF5IGJlZm9yZSB0aGUgbWVudSB0ZXh0LiBFeDogYHBhcGktZXh0ZW5zaW9uOi8vaGVsbG9Xb3JsZC9hc3NldHMvaWNvbi5wbmdgXCIsXG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpY29uUGF0aEFmdGVyOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlVyaSBwYXRoIHRvIHRoZSBpY29uIHRvIGRpc3BsYXkgYWZ0ZXIgdGhlIG1lbnUgdGV4dC4gRXg6IGBwYXBpLWV4dGVuc2lvbjovL2hlbGxvV29ybGQvYXNzZXRzL2ljb24ucG5nYFwiLFxuICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1aXJlZDogW1wiY29tbWFuZFwiXVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIktleSB0aGF0IHJlcHJlc2VudHMgdGhlIHRleHQgb2YgdGhpcyBtZW51IGl0ZW0gdG8gZGlzcGxheVwiLFxuICAgICAgICAgICRyZWY6IFwiIy8kZGVmcy9sb2NhbGl6ZUtleVwiXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJLZXkgdGhhdCByZXByZXNlbnRzIHRoZSB0ZXh0IHRvIGRpc3BsYXkgaWYgYSBtb3VzZSBwb2ludGVyIGhvdmVycyBvdmVyIHRoZSBtZW51IGl0ZW1cIixcbiAgICAgICAgICAkcmVmOiBcIiMvJGRlZnMvbG9jYWxpemVLZXlcIlxuICAgICAgICB9LFxuICAgICAgICBzZWFyY2hUZXJtczoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIktleSB0aGF0IHJlcHJlc2VudHMgYWRkaXRpb25hbCB3b3JkcyB0aGUgcGxhdGZvcm0gc2hvdWxkIHJlZmVyZW5jZSB3aGVuIHVzZXJzIGFyZSBzZWFyY2hpbmcgZm9yIG1lbnUgaXRlbXNcIixcbiAgICAgICAgICAkcmVmOiBcIiMvJGRlZnMvbG9jYWxpemVLZXlcIlxuICAgICAgICB9LFxuICAgICAgICBsb2NhbGl6ZU5vdGVzOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBwcm92aWRlZCBieSBkZXZlbG9wZXJzIHRvIGhlbHAgcGVvcGxlIHdobyBwZXJmb3JtIGxvY2FsaXphdGlvblwiLFxuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgZ3JvdXA6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJHcm91cCB0byB3aGljaCB0aGlzIG1lbnUgaXRlbSBiZWxvbmdzXCIsXG4gICAgICAgICAgJHJlZjogXCIjLyRkZWZzL3JlZmVyZW5jZWRJdGVtXCJcbiAgICAgICAgfSxcbiAgICAgICAgb3JkZXI6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJSZWxhdGl2ZSBvcmRlciBvZiB0aGlzIG1lbnUgaXRlbSBjb21wYXJlZCB0byBvdGhlciBtZW51IGl0ZW1zIGluIHRoZSBzYW1lIGdyb3VwIChzb3J0ZWQgYXNjZW5kaW5nKVwiLFxuICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBbXCJsYWJlbFwiLCBcImdyb3VwXCIsIFwib3JkZXJcIl0sXG4gICAgICB1bmV2YWx1YXRlZFByb3BlcnRpZXM6ICExXG4gICAgfSxcbiAgICBncm91cHNBbmRJdGVtczoge1xuICAgICAgZGVzY3JpcHRpb246IFwiQ29yZSBzY2hlbWEgZm9yIGEgY29sdW1uXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBncm91cHM6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJHcm91cHMgdGhhdCBiZWxvbmcgaW4gdGhpcyBtZW51XCIsXG4gICAgICAgICAgJHJlZjogXCIjLyRkZWZzL21lbnVHcm91cHNcIlxuICAgICAgICB9LFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkxpc3Qgb2YgbWVudSBpdGVtcyB0aGF0IGJlbG9uZyBpbiB0aGlzIG1lbnVcIixcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaXRlbXM6IHsgJHJlZjogXCIjLyRkZWZzL21lbnVJdGVtXCIgfSxcbiAgICAgICAgICB1bmlxdWVJdGVtczogITBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBbXCJncm91cHNcIiwgXCJpdGVtc1wiXVxuICAgIH0sXG4gICAgc2luZ2xlQ29sdW1uTWVudToge1xuICAgICAgZGVzY3JpcHRpb246IFwiTWVudSB0aGF0IGNvbnRhaW5zIGEgY29sdW1uIHdpdGhvdXQgYSBoZWFkZXJcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBhbGxPZjogW3sgJHJlZjogXCIjLyRkZWZzL2dyb3Vwc0FuZEl0ZW1zXCIgfV0sXG4gICAgICB1bmV2YWx1YXRlZFByb3BlcnRpZXM6ICExXG4gICAgfSxcbiAgICBtdWx0aUNvbHVtbk1lbnU6IHtcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk1lbnUgdGhhdCBjYW4gY29udGFpbiBtdWx0aXBsZSBjb2x1bW5zIHdpdGggaGVhZGVyc1wiLFxuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGFsbE9mOiBbXG4gICAgICAgIHsgJHJlZjogXCIjLyRkZWZzL2dyb3Vwc0FuZEl0ZW1zXCIgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGNvbHVtbnM6IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiQ29sdW1ucyB0aGF0IGJlbG9uZyBpbiB0aGlzIG1lbnVcIixcbiAgICAgICAgICAgICAgJHJlZjogXCIjLyRkZWZzL2NvbHVtbnNXaXRoSGVhZGVyc1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1aXJlZDogW1wiY29sdW1uc1wiXVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzOiAhMVxuICAgIH0sXG4gICAgbWVudXNGb3JPbmVXZWJWaWV3OiB7XG4gICAgICBkZXNjcmlwdGlvbjogXCJTZXQgb2YgbWVudXMgdGhhdCBhcmUgYXNzb2NpYXRlZCB3aXRoIGEgc2luZ2xlIHRhYlwiLFxuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgaW5jbHVkZURlZmF1bHRzOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBsYXRmb3JtIGRlZmF1bHQgbWVudXMgc2hvdWxkIGJlIGluY2x1ZGVkIGZvciB0aGlzIHdlYnZpZXdcIixcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIlxuICAgICAgICB9LFxuICAgICAgICB0b3BNZW51OiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiTWVudSB0aGF0IG9wZW5zIHdoZW4geW91IGNsaWNrIG9uIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgYSB0YWJcIixcbiAgICAgICAgICAkcmVmOiBcIiMvJGRlZnMvbXVsdGlDb2x1bW5NZW51XCJcbiAgICAgICAgfSxcbiAgICAgICAgY29udGV4dE1lbnU6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJNZW51IHRoYXQgb3BlbnMgd2hlbiB5b3UgcmlnaHQgY2xpY2sgb24gdGhlIG1haW4gYm9keS9hcmVhIG9mIGEgdGFiXCIsXG4gICAgICAgICAgJHJlZjogXCIjLyRkZWZzL3NpbmdsZUNvbHVtbk1lbnVcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6ICExXG4gICAgfVxuICB9XG59O1xuT2JqZWN0LmZyZWV6ZShNdSk7XG5jb25zdCBqZSA9IFtcImZpZ3VyZVwiLCBcIm5vdGVcIiwgXCJzaWRlYmFyXCIsIFwidGFibGVcIl07XG5PYmplY3QuZnJlZXplKGplKTtcbmNsYXNzIEVlIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIFcodGhpcywgXCJ1c2pcIik7XG4gICAgVyh0aGlzLCBcInBhcmVudE1hcEludGVybmFsXCIpO1xuICAgIHRoaXMudXNqID0gZTtcbiAgfVxuICAvLyBJZiBuZXcgdmFyaWFibGVzIGFyZSBjcmVhdGVkIHRvIHNwZWVkIHVwIHF1ZXJpZXMsIHRoZXkgc2hvdWxkIGJlIHJlc2V0IGhlcmVcbiAgdXNqQ2hhbmdlZCgpIHtcbiAgICB0aGlzLnBhcmVudE1hcEludGVybmFsID0gdm9pZCAwO1xuICB9XG4gIC8vICNyZWdpb24gRGlyZWN0bHkgdXNpbmcgdGhlIEpTT05QYXRoIHBhY2thZ2UgdG8gcGVyZm9ybSBKU09OUGF0aCBxdWVyeSAtPiBVU0ogbm9kZVxuICBmaW5kU2luZ2xlVmFsdWUoZSkge1xuICAgIGNvbnN0IG4gPSBXdCh7IHBhdGg6IGUsIGpzb246IHRoaXMudXNqLCB3cmFwOiAhMCB9KTtcbiAgICBpZiAobiA9PT0gdm9pZCAwIHx8IG4ubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5bMF0pKSByZXR1cm4gblswXTtcbiAgICBjb25zdCBpID0gV3QoeyBwYXRoOiBlLCBqc29uOiB0aGlzLnVzaiwgd3JhcDogITEgfSk7XG4gICAgcmV0dXJuIGkubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoaVswXSkgPyBpWzBdIDogaTtcbiAgfVxuICBmaW5kUGFyZW50KGUpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kU2luZ2xlVmFsdWUoYCR7ZX1eYCk7XG4gIH1cbiAgZmluZEJvb2tJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kU2luZ2xlVmFsdWUoJyQuY29udGVudFs/KEAudHlwZT09XCJib29rXCIgJiYgQC5tYXJrZXI9PVwiaWRcIildLmNvZGUnKTtcbiAgfVxuICBmaW5kQ2hhcHRlck5vZGUoZSkge1xuICAgIGNvbnN0IG4gPSBgJC4uY29udGVudFs/KEAudHlwZT09XCJjaGFwdGVyXCIgJiYgQC5udW1iZXI9PVwiJHtlfVwiKV1gO1xuICAgIHJldHVybiB0aGlzLmZpbmRTaW5nbGVWYWx1ZShuKTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG4gIC8vICNyZWdpb24gUGFyZW50IE1hcHNcbiAgc3RhdGljIGNyZWF0ZVBhcmVudE1hcEludGVybmFsKGUsIG4sIGkpIHtcbiAgICB2YXIgbztcbiAgICBpLnNldChlLCBuKSwgZS5jb250ZW50ICYmIGkuc2V0KGUuY29udGVudCwgZSksIChvID0gZS5jb250ZW50KSA9PSBudWxsIHx8IG8uZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgdHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiBFZS5jcmVhdGVQYXJlbnRNYXBJbnRlcm5hbChhLCBlLCBpKTtcbiAgICB9KTtcbiAgfVxuICAvKiogVmlld2luZyBhIFVzaiBvYmplY3QgYXMgYSB0cmVlLCBidWlsZCBhIG1hcCB0byB3YWxrIHVwIHRoZSB0cmVlICovXG4gIGNyZWF0ZVVzalBhcmVudE1hcCgpIHtcbiAgICBjb25zdCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICByZXR1cm4gdGhpcy51c2ouY29udGVudCAmJiBlLnNldCh0aGlzLnVzai5jb250ZW50LCB0aGlzLnVzaiksIHRoaXMudXNqLmNvbnRlbnQuZm9yRWFjaCgobikgPT4ge1xuICAgICAgdHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiBFZS5jcmVhdGVQYXJlbnRNYXBJbnRlcm5hbChuLCB0aGlzLnVzaiwgZSk7XG4gICAgfSksIGU7XG4gIH1cbiAgLyoqIENyZWF0ZSB0aGUgcGFyZW50IG1hcCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3QgYW5kIHJldHVybiBpdCAqL1xuICBnZXQgcGFyZW50TWFwKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudE1hcEludGVybmFsID8gdGhpcy5wYXJlbnRNYXBJbnRlcm5hbCA6ICh0aGlzLnBhcmVudE1hcEludGVybmFsID0gdGhpcy5jcmVhdGVVc2pQYXJlbnRNYXAoKSwgdGhpcy5wYXJlbnRNYXBJbnRlcm5hbCk7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuICAvLyAjcmVnaW9uIFdvcmtpbmcgU3RhY2tzXG4gIC8qKiBSZXR1cm4gdGhlIHdvcmtpbmcgc3RhY2sgYXBwbGljYWJsZSB0byB0aGUgZ2l2ZW4gbm9kZSAqL1xuICBjcmVhdGVXb3JraW5nU3RhY2soZSkge1xuICAgIGNvbnN0IG4gPSBbXSwgeyBwYXJlbnRNYXA6IGkgfSA9IHRoaXM7XG4gICAgbGV0IG8gPSBlLCBhID0gaS5nZXQobyk7XG4gICAgZm9yICg7IGEgIT09IHZvaWQgMDsgKSB7XG4gICAgICBpZiAoIWEuY29udGVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJlbnRNYXA6IGFsbCBwYXJlbnRzIHNob3VsZCBoYXZlIGNvbnRlbnRcIik7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIFJlZmVyZW5jaW5nIHRlbXBOb2RlIGFuZCB0ZW1wUGFyZW50IGlzIE9LIGluIHRoZSBsb29wIHNpbmNlICdsZXQnIGlzIHVzZWQgaW5zdGVhZCBvZiAndmFyJ1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICFhLmNvbnRlbnQuZmluZCgoaCwgcCkgPT4ge1xuICAgICAgICAgIGlmIChoICE9PSBvKSByZXR1cm4gITE7XG4gICAgICAgICAgaWYgKCFhKSB0aHJvdyBuZXcgRXJyb3IoJ3VuZGVmaW5lZCBcInRlbXBQYXJlbnRcIiBzaG91bGQgbm90IGJlIHBvc3NpYmxlJyk7XG4gICAgICAgICAgcmV0dXJuIG4udW5zaGlmdCh7IHBhcmVudDogYSwgaW5kZXg6IHAgfSksICEwO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGNvcnJlY3QgcGFyZW50IG5vZGUgb2YgJHtKU09OLnN0cmluZ2lmeShvKX1gKTtcbiAgICAgIGlmIChhLnR5cGUgPT09IFV0KSBicmVhaztcbiAgICAgIG8gPSBhLCBhID0gaS5nZXQoYSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIHN0YXRpYyBjb252ZXJ0V29ya2luZ1N0YWNrVG9Kc29uUGF0aChlKSB7XG4gICAgbGV0IG4gPSBcIiRcIjtcbiAgICByZXR1cm4gZS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBuID0gYCR7bn0uY29udGVudFske2kuaW5kZXh9XWA7XG4gICAgfSksIG47XG4gIH1cbiAgY29udmVydEpzb25QYXRoVG9Xb3JraW5nU3RhY2soZSkge1xuICAgIGNvbnN0IG4gPSBbXSwgaSA9IGUubWF0Y2goL2NvbnRlbnRcXFsoXFxkKylcXF0vZyk7XG4gICAgaWYgKCFpKSB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBvciB1bmV4cGVjdGVkIGpzb25QYXRoOiAke2V9YCk7XG4gICAgbGV0IG8gPSB0aGlzLnVzajtcbiAgICByZXR1cm4gaS5mb3JFYWNoKChhLCBoKSA9PiB7XG4gICAgICBjb25zdCBwID0gLyhcXGQrKS8uZXhlYyhhKTtcbiAgICAgIGlmICghcCkgdGhyb3cgbmV3IEVycm9yKGBNYWxmb3JtZWQgb3IgdW5leHBlY3RlZCBqc29uUGF0aDogJHtlfWApO1xuICAgICAgY29uc3QgZiA9IHBhcnNlSW50KHBbMF0sIDEwKTtcbiAgICAgIGlmIChuLnB1c2goeyBwYXJlbnQ6IG8sIGluZGV4OiBmIH0pLCBoICsgMSA8IGkubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbyA9PSBcInN0cmluZ1wiIHx8ICFvLmNvbnRlbnQpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBqc29uUGF0aCBwb2ludHMgdG8gbm9kZSB3aXRob3V0IGNoaWxkcmVuOiAke0pTT04uc3RyaW5naWZ5KG8pfWApO1xuICAgICAgICBjb25zdCBtID0gby5jb250ZW50W2ZdO1xuICAgICAgICBpZiAodHlwZW9mIG0gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpzb25QYXRoIHBvaW50cyB0byBub2RlIHdpdGhvdXQgY2hpbGRyZW46ICR7SlNPTi5zdHJpbmdpZnkobSl9YCk7XG4gICAgICAgIG8gPSBtO1xuICAgICAgfVxuICAgIH0pLCBuO1xuICB9XG4gIC8vICNlbmRyZWdpb25cbiAgLy8gI3JlZ2lvbiBXYWxrIHRoZSBub2RlIHRyZWVcbiAgLyoqXG4gICAqIEdpdmVuIHRoZSBzdGFydGluZyBwb2ludCBvZiBhIHRyZWUgdG8gY29uc2lkZXIgKGBub2RlYCksIGZpbmQgdGhlIHJpZ2h0bW9zdCBNYXJrZXJPYmplY3QgZnJvbVxuICAgKiB0aGUgYXJyYXkgb2YgYGNvbnRlbnRgLiBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUsIHRoaXMgd291bGQgYmUgXCJKXCIuXG4gICAqXG4gICAqICAgICAgICAgQSAgICAgICAgPC0gQ29uc2lkZXIgXCJBXCIgdG8gYmUgYG5vZGVgXG4gICAqICAgICAvIC8gfCBcXCBcXFxuICAgKiAgICAgQiBDIEQgRSBGICAgIDwtIENvbnNpZGVyIHRoZXNlIHRvIGJlIE1hcmtlck9iamVjdHMgaW5zaWRlIHRoZSBgY29udGVudGAgYXJyYXkgb3duZWQgYnkgXCJBXCJcbiAgICogICAgIHwgIC8gXFwgIHxcbiAgICogICAgIEcgSCAgIEkgSiAgICA8LSBDb25zaWRlciB0aGVzZSB0byBiZSBNYXJrZXJPYmplY3RzIGluc2lkZSB0aGVpciBwYXJlbnRzIGBjb250ZW50YCBhcnJheXNcbiAgICpcbiAgICogSWYgXCJGXCIgZGlkIG5vdCBleGlzdCBpbiB0aGlzIGV4YW1wbGUsIHRoZW4gXCJFXCIgd291bGQgYmUgcmV0dXJuZWQuIElmIFwiRVwiIGFuZCBcIkZcIiBkaWRuJ3QgZXhpc3QsXG4gICAqIHRoZW4gXCJJXCIgd291bGQgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIFRoZSBnZW5lcmFsIGlkZWEgaGVyZSBpcyB0aGF0IHdlIGFyZSBsb29raW5nIGZvciB0aGUgTWFya2VyT2JqZWN0IGluIFVzaiB0aGF0IGlzIGltbWVkaWF0ZWx5XG4gICAqIGFkamFjZW50IHRvIHdoYXRldmVyIGBub2RlYCdzIG5leHQgc2libGluZyBpcyBpbiBgcGFyZW50YCdzIGBjb250ZW50YCBhcnJheS5cbiAgICovXG4gIHN0YXRpYyBmaW5kUmlnaHRNb3N0RGVzY2VuZGFudE1hcmtlck9iamVjdChlLCBuLCBpID0gW10pIHtcbiAgICBpZiAoIWUuY29udGVudCkgcmV0dXJuIHsgbm9kZTogZSwgcGFyZW50OiBuIH07XG4gICAgZm9yIChsZXQgbyA9IGUuY29udGVudC5sZW5ndGggLSAxOyBvID49IDA7IG8tLSkge1xuICAgICAgY29uc3QgYSA9IGUuY29udGVudFtvXTtcbiAgICAgIGlmICh0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmICFpLmluY2x1ZGVzKGEudHlwZSkpXG4gICAgICAgIHJldHVybiBhLmNvbnRlbnQgPyB0aGlzLmZpbmRSaWdodE1vc3REZXNjZW5kYW50TWFya2VyT2JqZWN0KGEsIGUsIGkpIDogeyBub2RlOiBhLCBwYXJlbnQ6IGUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZTogZSwgcGFyZW50OiBuIH07XG4gIH1cbiAgc3RhdGljIGZpbmROZXh0TWF0Y2hpbmdOb2RlVXNpbmdXb3JraW5nU3RhY2soZSwgbiwgaSwgbykge1xuICAgIHZhciBoO1xuICAgIGxldCBhID0gZTtcbiAgICBmb3IgKDsgYSAhPT0gdm9pZCAwOyApIHtcbiAgICAgIGNvbnN0IHAgPSB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIGkuaW5jbHVkZXMoYS50eXBlKTtcbiAgICAgIGlmICghcCAmJiBvKGEsIG4pKSByZXR1cm4gYTtcbiAgICAgIGlmICghcCAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmICgoKGggPSBhLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBoLmxlbmd0aCkgPz8gMCkgPiAwKVxuICAgICAgICBuLnB1c2goeyBwYXJlbnQ6IGEsIGluZGV4OiAwIH0pLCBbYV0gPSBhLmNvbnRlbnQ7XG4gICAgICBlbHNlXG4gICAgICAgIGZvciAoYSA9IHZvaWQgMDsgbi5sZW5ndGggPiAwOyApIHtcbiAgICAgICAgICBjb25zdCBmID0gbi5wb3AoKTtcbiAgICAgICAgICBpZiAoZiAmJiBmLmluZGV4ICsgMSA8IGYucGFyZW50LmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBmLmluZGV4ICs9IDEsIG4ucHVzaChmKSwgYSA9IGYucGFyZW50LmNvbnRlbnRbZi5pbmRleF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdhbGsgdGhyb3VnaCBhIFVTSiBub2RlIHRyZWUgZGVwdGgtZmlyc3QsIGxlZnQtdG8tcmlnaHQgdG8gZmluZCB0aGUgZmlyc3Qgbm9kZSB0aGF0IG1hdGNoZXNcbiAgICogY3JpdGVyaWEgc3BlY2lmaWVkIGJ5IGBzZWFyY2hGdW5jdGlvbmAgKGkuZS4sIHRoZSBmaXJzdCBub2RlIHdoZXJlIGBzZWFyY2hGdW5jdGlvbmAgcmV0dXJuc1xuICAgKiBgdHJ1ZWApXG4gICAqL1xuICBmaW5kTmV4dE1hdGNoaW5nTm9kZShlLCBuLCBpKSB7XG4gICAgY29uc3QgbyA9IHRoaXMuY3JlYXRlV29ya2luZ1N0YWNrKGUpO1xuICAgIHJldHVybiBFZS5maW5kTmV4dE1hdGNoaW5nTm9kZVVzaW5nV29ya2luZ1N0YWNrKFxuICAgICAgZSxcbiAgICAgIG8sXG4gICAgICBuLFxuICAgICAgaVxuICAgICk7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuICAvLyAjcmVnaW9uIE5vZGUgLT4gSlNPTlBhdGhcbiAgbm9kZVRvSnNvblBhdGgoZSkge1xuICAgIHJldHVybiBFZS5jb252ZXJ0V29ya2luZ1N0YWNrVG9Kc29uUGF0aCh0aGlzLmNyZWF0ZVdvcmtpbmdTdGFjayhlKSk7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuICAvLyAjcmVnaW9uIFVTSiArIG5vZGUgLT4gU2VyaWFsaXplZFZlcnNlUmVmICsgb2Zmc2V0XG4gIC8qKiBGaW5kIHRoZSBjaGFwdGVyIGFuZCB2ZXJzZSB0aGF0IGFwcGx5IHRvIGEgZ2l2ZW4gVVNKIG5vZGUgKi9cbiAgZmluZFZlcnNlUmVmRm9yTm9kZShlLCBuLCBpID0ge1xuICAgIGNoYXB0ZXJOdW06IHZvaWQgMCxcbiAgICB2ZXJzZU51bTogdm9pZCAwLFxuICAgIHN0YXJ0aW5nQ29udGVudE5vZGU6IHZvaWQgMFxuICB9KSB7XG4gICAgaWYgKGkudmVyc2VOdW0gIT09IHZvaWQgMCAmJiBpLmNoYXB0ZXJOdW0gIT09IHZvaWQgMCkgcmV0dXJuIGk7XG4gICAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZS5udW1iZXIgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZiA9IE51bWJlci5wYXJzZUludChlLm51bWJlciwgMTApO1xuICAgICAgaWYgKGUudHlwZSA9PT0gTXQpXG4gICAgICAgIHJldHVybiBpLmNoYXB0ZXJOdW0gPSBmLCBpLnZlcnNlTnVtID0gaS52ZXJzZU51bSA/PyAwLCBpLnN0YXJ0aW5nQ29udGVudE5vZGUgPSBpLnN0YXJ0aW5nQ29udGVudE5vZGUgPz8gZSwgaTtcbiAgICAgIGUudHlwZSA9PT0gQnQgJiYgIWkudmVyc2VOdW0gJiYgKGkudmVyc2VOdW0gPSBmLCBpLnN0YXJ0aW5nQ29udGVudE5vZGUgPSBlKTtcbiAgICB9XG4gICAgaWYgKCFuLmNvbnRlbnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiY29udGVudFwiIGFycmF5IG5vdCBmb3VuZDogJHtKU09OLnN0cmluZ2lmeShuKX1gKTtcbiAgICBsZXQgbyA9IDA7XG4gICAgZm9yIChsZXQgZiA9IDA7IGYgPCBuLmNvbnRlbnQubGVuZ3RoOyBmKyspXG4gICAgICBpZiAobi5jb250ZW50W2ZdID09PSBlKSB7XG4gICAgICAgIG8gPSBmO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBsZXQgYSA9IG8gLSAxO1xuICAgIGZvciAoOyBhID49IDAgJiYgdHlwZW9mIG4uY29udGVudFthXSAhPSBcIm9iamVjdFwiOyApXG4gICAgICBhIC09IDE7XG4gICAgaWYgKGEgPCAwKSB7XG4gICAgICBpZiAobi50eXBlID09PSBVdClcbiAgICAgICAgcmV0dXJuIGkuY2hhcHRlck51bSA9PT0gdm9pZCAwICYmIChpLmNoYXB0ZXJOdW0gPSAxLCBpLnZlcnNlTnVtID0gMCwgaS5zdGFydGluZ0NvbnRlbnROb2RlID0gdm9pZCAwKSwgaTtcbiAgICAgIGNvbnN0IGYgPSBuLCBtID0gdGhpcy5wYXJlbnRNYXAuZ2V0KGYpO1xuICAgICAgaWYgKCFtKSB0aHJvdyBuZXcgRXJyb3IoYE5vIHBhcmVudCBmb3VuZCBmb3IgJHtKU09OLnN0cmluZ2lmeShuKX1gKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRWZXJzZVJlZkZvck5vZGUoZiwgbSwgaSk7XG4gICAgfVxuICAgIGNvbnN0IGggPSBuLmNvbnRlbnRbYV0sIHAgPSBFZS5maW5kUmlnaHRNb3N0RGVzY2VuZGFudE1hcmtlck9iamVjdChcbiAgICAgIGgsXG4gICAgICBuLFxuICAgICAgamVcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZpbmRWZXJzZVJlZkZvck5vZGUocC5ub2RlLCBwLnBhcmVudCwgaSk7XG4gIH1cbiAgbm9kZVRvVmVyc2VSZWZBbmRPZmZzZXQoZSwgbiwgaSkge1xuICAgIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIGkgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWYgXCJub2RlXCIgaXMgYSBzdHJpbmcsIHRoZW4gXCJub2RlUGFyZW50XCIgY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuICAgIGxldCBvO1xuICAgIGlmIChpID09PSB2b2lkIDAgPyBvID0gdGhpcy5wYXJlbnRNYXAuZ2V0KG4pIDogbyA9IEFycmF5LmlzQXJyYXkoaSkgPyB0aGlzLnBhcmVudE1hcC5nZXQoaSkgOiBpLCBvID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIHBhcmVudCBmb3IgJHtKU09OLnN0cmluZ2lmeShpKX1gKTtcbiAgICBjb25zdCBhID0gdGhpcy5maW5kVmVyc2VSZWZGb3JOb2RlKG4sIG8pO1xuICAgIGlmICghYSkgcmV0dXJuO1xuICAgIGlmICghYS5jaGFwdGVyTnVtKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZGV0ZXJtaW5lIGNoYXB0ZXIgbnVtYmVyIGZvciAke0pTT04uc3RyaW5naWZ5KG4pfWApO1xuICAgIGNvbnN0IGggPSB7XG4gICAgICBib29rOiBlLFxuICAgICAgY2hhcHRlck51bTogYS5jaGFwdGVyTnVtLFxuICAgICAgdmVyc2VOdW06IGEudmVyc2VOdW0gPz8gMFxuICAgIH07XG4gICAgbGV0IHAgPSAwO1xuICAgIHJldHVybiBhLnN0YXJ0aW5nQ29udGVudE5vZGUgIT09IHZvaWQgMCAmJiB0aGlzLmZpbmROZXh0TWF0Y2hpbmdOb2RlKGEuc3RhcnRpbmdDb250ZW50Tm9kZSwgW10sIChmLCBtKSA9PiB7XG4gICAgICB2YXIgRSwgbDtcbiAgICAgIHJldHVybiBmID09PSBuID8gITAgOiBtLmZpbmQoKHYpID0+IGplLmluY2x1ZGVzKHYucGFyZW50LnR5cGUpKSA/ICExIDogdHlwZW9mIGYgPT0gXCJzdHJpbmdcIiA/IChwICs9IGYubGVuZ3RoLCAhMSkgOiBmLnR5cGUgPT09IE10ICYmIGYubnVtYmVyICE9PSAoKEUgPSBhLmNoYXB0ZXJOdW0pID09IG51bGwgPyB2b2lkIDAgOiBFLnRvU3RyaW5nKCkpIHx8IGYudHlwZSA9PT0gQnQgJiYgZi5udW1iZXIgIT09ICgobCA9IGEudmVyc2VOdW0pID09IG51bGwgPyB2b2lkIDAgOiBsLnRvU3RyaW5nKCkpID8gKHAgPSAwLCAhMCkgOiAhMTtcbiAgICB9KSwgeyB2ZXJzZVJlZjogaCwgb2Zmc2V0OiBwIH07XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuICAvLyAjcmVnaW9uIEpTT05QYXRoIC0+IFNlcmlhbGl6ZWRWZXJzZVJlZiArIG9mZnNldFxuICBqc29uUGF0aFRvVmVyc2VSZWZBbmRPZmZzZXQoZSwgbikge1xuICAgIGNvbnN0IGkgPSBuID8/IHRoaXMuZmluZEJvb2tJZCgpO1xuICAgIGlmICghaSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IGFibGUgdG8gZGV0ZXJtaW5lIHRoZSBib29rIElEXCIpO1xuICAgIGNvbnN0IG8gPSB0aGlzLmZpbmRTaW5nbGVWYWx1ZShlKTtcbiAgICBpZiAoIW8pIHRocm93IG5ldyBFcnJvcihgTm8gcmVzdWx0IGZvdW5kIGZvciBKU09OUGF0aCBxdWVyeTogJHtlfWApO1xuICAgIGNvbnN0IGEgPSB0aGlzLmZpbmRQYXJlbnQoZSk7XG4gICAgaWYgKCFhKSB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBkZXRlcm1pbmUgcGFyZW50IGZvciAke2V9YCk7XG4gICAgY29uc3QgaCA9IHRoaXMubm9kZVRvVmVyc2VSZWZBbmRPZmZzZXQoaSwgbywgYSk7XG4gICAgaWYgKCFoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGRldGVybWluZSBTZXJpYWxpemVkVmVyc2VSZWYgdGhhdCBjb3JyZXNwb25kcyB0byAke2V9YFxuICAgICAgKTtcbiAgICByZXR1cm4gaDtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG4gIC8vICNyZWdpb24gU2VyaWFsaXplZFZlcnNlUmVmICsgb2Zmc2V0IC0+IE5vZGUgKyBKU09OUGF0aCArIG9mZnNldFxuICB2ZXJzZVJlZlRvVXNqQ29udGVudExvY2F0aW9uKGUsIG4gPSAwKSB7XG4gICAgaWYgKG4gPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJvZmZzZXQgbXVzdCBiZSA+PSAwXCIpO1xuICAgIGNvbnN0IGkgPSB0aGlzLmZpbmRCb29rSWQoKSA/PyBlLmJvb2s7XG4gICAgaWYgKCFpKSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYWJsZSB0byBkZXRlcm1pbmUgdGhlIGJvb2sgSURcIik7XG4gICAgaWYgKGkgIT09IGUuYm9vaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQm9vayBJRHMgZG9uJ3QgbWF0Y2g6IFVTSj0ke2l9LCBTZXJpYWxpemVkVmVyc2VSZWY9JHtlLmJvb2t9YCk7XG4gICAgY29uc3QgbyA9IHRoaXMuZmluZENoYXB0ZXJOb2RlKGUuY2hhcHRlck51bSk7XG4gICAgaWYgKG8gPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgJHtpfSBjaGFwdGVyICR7ZS5jaGFwdGVyTnVtfWApO1xuICAgIGxldCBhID0gITEsIGggPSBcIlwiO1xuICAgIGNvbnN0IHAgPSBlLnZlcnNlID8/IGUudmVyc2VOdW0udG9TdHJpbmcoKSwgZiA9IHRoaXMuZmluZE5leHRNYXRjaGluZ05vZGUoXG4gICAgICBvLFxuICAgICAgamUsXG4gICAgICAodiwgTykgPT4gdiA9PT0gbyA/IGUudmVyc2VOdW0gPT09IDAgPyAoaCA9IEVlLmNvbnZlcnRXb3JraW5nU3RhY2tUb0pzb25QYXRoKE8pLCAhMCkgOiAhMSA6IHR5cGVvZiB2ICE9IFwib2JqZWN0XCIgPyAhMSA6IHYudHlwZSA9PT0gTXQgPyAoYSA9ICEwLCAhMCkgOiB2LnR5cGUgPT09IEJ0ICYmIHYubnVtYmVyICE9PSB2b2lkIDAgJiYgdi5udW1iZXIgPT09IHAgPyAoaCA9IEVlLmNvbnZlcnRXb3JraW5nU3RhY2tUb0pzb25QYXRoKE8pLCAhMCkgOiAhMVxuICAgICk7XG4gICAgaWYgKGEgfHwgZiA9PT0gdm9pZCAwIHx8IHR5cGVvZiBmID09IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnNlICR7cH0gbm90IGZvdW5kIGluICR7aX0gJHtlLmNoYXB0ZXJOdW19YCk7XG4gICAgaWYgKG4gPT09IDApIHJldHVybiB7IG5vZGU6IGYsIG9mZnNldDogMCwganNvblBhdGg6IGggfTtcbiAgICBsZXQgbSA9IDAsIEUgPSAwLCBsO1xuICAgIHJldHVybiB0aGlzLmZpbmROZXh0TWF0Y2hpbmdOb2RlKFxuICAgICAgZixcbiAgICAgIGplLFxuICAgICAgKHYsIE8pID0+IHtcbiAgICAgICAgaWYgKHYgPT09IGYpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAobSArPSB2Lmxlbmd0aCwgbSA+IG4pXG4gICAgICAgICAgICByZXR1cm4gaCA9IEVlLmNvbnZlcnRXb3JraW5nU3RhY2tUb0pzb25QYXRoKE8pLCBFID0gbiAtIG0gKyB2Lmxlbmd0aCwgbCA9IHYsICEwO1xuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gTXQgfHwgdi50eXBlID09PSBCdCkgcmV0dXJuICEwO1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgKSwgeyBub2RlOiBsID8/IGYsIG9mZnNldDogRSwganNvblBhdGg6IGggfTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG4gIC8vICNyZWdpb24gU2VhcmNoIGZvciB0ZXh0IGZyb20gYSBub2RlICsgSlNPTlBhdGggKyBvZmZzZXRcbiAgZmluZE5leHRMb2NhdGlvbk9mTWF0Y2hpbmdUZXh0KGUsIG4sIGkgPSAxZTMpIHtcbiAgICBsZXQgbyA9IFwiXCIsIGEgPSAwLCBoID0gMCwgcCA9IDA7XG4gICAgaWYgKEVlLmZpbmROZXh0TWF0Y2hpbmdOb2RlVXNpbmdXb3JraW5nU3RhY2soXG4gICAgICBlLm5vZGUsXG4gICAgICB0aGlzLmNvbnZlcnRKc29uUGF0aFRvV29ya2luZ1N0YWNrKGUuanNvblBhdGgpLFxuICAgICAgamUsXG4gICAgICAobCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGwgIT0gXCJzdHJpbmdcIikgcmV0dXJuICExO1xuICAgICAgICBhICs9IGwubGVuZ3RoLCBvID0gYCR7b30ke2x9YDtcbiAgICAgICAgY29uc3QgdiA9IG8uaW5kZXhPZihuKTtcbiAgICAgICAgcmV0dXJuIHYgPCAwID8gKGggKz0gby5sZW5ndGgsIG8ubGVuZ3RoID4gbi5sZW5ndGggJiYgKG8gPSBvLnN1YnN0cmluZyhvLmxlbmd0aCAtIG4ubGVuZ3RoKSksIGggLT0gby5sZW5ndGgsIGEgPiBpKSA6IChwID0gaCArIHYsICEwKTtcbiAgICAgIH1cbiAgICApLCBwIDw9IDApIHJldHVybjtcbiAgICBhID0gMDtcbiAgICBsZXQgZiA9IDAsIG0gPSBbXTtcbiAgICBjb25zdCBFID0gRWUuZmluZE5leHRNYXRjaGluZ05vZGVVc2luZ1dvcmtpbmdTdGFjayhcbiAgICAgIGUubm9kZSxcbiAgICAgIHRoaXMuY29udmVydEpzb25QYXRoVG9Xb3JraW5nU3RhY2soZS5qc29uUGF0aCksXG4gICAgICBqZSxcbiAgICAgIChsLCB2KSA9PiB0eXBlb2YgbCAhPSBcInN0cmluZ1wiIHx8IChhICs9IGwubGVuZ3RoLCBhIDwgcCArIDEpID8gITEgOiAoZiA9IHAgLSBhICsgbC5sZW5ndGgsIG0gPSB2LCAhMClcbiAgICApO1xuICAgIGlmICghRSkgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IGluY29uc2lzdGVudCBzZWFyY2ggcmVzdWx0c1wiKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogRSxcbiAgICAgIG9mZnNldDogZixcbiAgICAgIGpzb25QYXRoOiBFZS5jb252ZXJ0V29ya2luZ1N0YWNrVG9Kc29uUGF0aChtKVxuICAgIH07XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuICAvLyAjcmVnaW9uIEV4dHJhY3QgdGV4dCBmcm9tIGEgbm9kZSArIEpTT05QYXRoICsgb2Zmc2V0XG4gIGV4dHJhY3RUZXh0KGUsIG4pIHtcbiAgICBsZXQgaSA9IFwiXCIsIG8gPSBlLm9mZnNldCwgYSA9IDA7XG4gICAgcmV0dXJuIEVlLmZpbmROZXh0TWF0Y2hpbmdOb2RlVXNpbmdXb3JraW5nU3RhY2soXG4gICAgICBlLm5vZGUsXG4gICAgICB0aGlzLmNvbnZlcnRKc29uUGF0aFRvV29ya2luZ1N0YWNrKGUuanNvblBhdGgpLFxuICAgICAgamUsXG4gICAgICAoaCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGggIT0gXCJzdHJpbmdcIikgcmV0dXJuICExO1xuICAgICAgICBpZiAobyA+PSBoLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gbyAtPSBoLmxlbmd0aCwgITE7XG4gICAgICAgIGxldCBwID0gaDtcbiAgICAgICAgaWYgKG8gPiAwICYmIChwID0gcC5zdWJzdHJpbmcobyksIG8gPSAwKSwgYSArIHAubGVuZ3RoIDwgbilcbiAgICAgICAgICByZXR1cm4gYSArPSBwLmxlbmd0aCwgaSA9IGAke2l9JHtwfWAsICExO1xuICAgICAgICBjb25zdCBmID0gbiAtIGE7XG4gICAgICAgIHJldHVybiBpID0gYCR7aX0ke3Auc3Vic3RyaW5nKDAsIGYgLSAxKX1gLCAhMDtcbiAgICAgIH1cbiAgICApLCBpO1xuICB9XG4gIGV4dHJhY3RUZXh0QmV0d2VlblBvaW50cyhlLCBuLCBpID0gMTAwKSB7XG4gICAgbGV0IG8gPSBcIlwiO1xuICAgIHJldHVybiBFZS5maW5kTmV4dE1hdGNoaW5nTm9kZVVzaW5nV29ya2luZ1N0YWNrKFxuICAgICAgZS5ub2RlLFxuICAgICAgdGhpcy5jb252ZXJ0SnNvblBhdGhUb1dvcmtpbmdTdGFjayhlLmpzb25QYXRoKSxcbiAgICAgIGplLFxuICAgICAgKGEsIGgpID0+IGEgPT09IG4ubm9kZSAmJiAodHlwZW9mIGEgPT0gXCJvYmplY3RcIiB8fCBuLmpzb25QYXRoID09PSBFZS5jb252ZXJ0V29ya2luZ1N0YWNrVG9Kc29uUGF0aChoKSkgPyAhMCA6IHR5cGVvZiBhICE9IFwic3RyaW5nXCIgPyAhMSA6IChvID0gYCR7b30ke2F9YCwgby5sZW5ndGggPiBpICYmIChvID0gby5zdWJzdHJpbmcoMCwgaSkpLCBvLmxlbmd0aCA+PSBpKVxuICAgICksIG87XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuICAvLyAjcmVnaW9uIEVkaXQgdGhpcyBVU0ogZGF0YVxuICBzdGF0aWMgcmVtb3ZlQ29udGVudE5vZGVzRnJvbUFycmF5KGUsIG4pIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgbyA9IGUubGVuZ3RoIC0gMTsgbyA+PSAwOyBvLS0pIHtcbiAgICAgIGNvbnN0IGEgPSBlW29dO1xuICAgICAgbihhKSA/IChlLnNwbGljZShvLCAxKSwgaSArPSAxKSA6IHR5cGVvZiBhICE9IFwic3RyaW5nXCIgJiYgYS5jb250ZW50ICYmIChpICs9IHRoaXMucmVtb3ZlQ29udGVudE5vZGVzRnJvbUFycmF5KGEuY29udGVudCwgbikpO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuICByZW1vdmVDb250ZW50Tm9kZXMoZSkge1xuICAgIGNvbnN0IG4gPSBFZS5yZW1vdmVDb250ZW50Tm9kZXNGcm9tQXJyYXkodGhpcy51c2ouY29udGVudCwgZSk7XG4gICAgcmV0dXJuIHRoaXMudXNqQ2hhbmdlZCgpLCBuO1xuICB9XG4gIC8vICNlbmRyZWdpb25cbn1cbmV4cG9ydCB7XG4gIFB1IGFzIEFzeW5jVmFyaWFibGUsXG4gIE10IGFzIENIQVBURVJfVFlQRSxcbiAgTHUgYXMgQ29sbGF0b3IsXG4gIFdyIGFzIERhdGVUaW1lRm9ybWF0LFxuICB0biBhcyBEb2N1bWVudENvbWJpbmVyLFxuICB6dSBhcyBFdmVudFJvbGxpbmdUaW1lQ291bnRlcixcbiAgUm4gYXMgRklSU1RfU0NSX0JPT0tfTlVNLFxuICBQbiBhcyBGSVJTVF9TQ1JfQ0hBUFRFUl9OVU0sXG4gIExuIGFzIEZJUlNUX1NDUl9WRVJTRV9OVU0sXG4gIF9uIGFzIExBU1RfU0NSX0JPT0tfTlVNLFxuICBubiBhcyBNdXRleCxcbiAgSHUgYXMgTXV0ZXhNYXAsXG4gIEp1IGFzIE5vblZhbGlkYXRpbmdEb2N1bWVudENvbWJpbmVyLFxuICB1biBhcyBOdW1iZXJGb3JtYXQsXG4gIEl0IGFzIFBMQVRGT1JNX0VSUk9SX1ZFUlNJT04sXG4gIEtyIGFzIFBsYXRmb3JtRXZlbnRFbWl0dGVyLFxuICBYdSBhcyBQcm9taXNlQ2hhaW5pbmdNYXAsXG4gIFl1IGFzIFVuc3Vic2NyaWJlckFzeW5jTGlzdCxcbiAgRWUgYXMgVXNqUmVhZGVyV3JpdGVyLFxuICBCdCBhcyBWRVJTRV9UWVBFLFxuICBOaSBhcyBhZ2dyZWdhdGVVbnN1YnNjcmliZXJBc3luY3MsXG4gIEFpIGFzIGFnZ3JlZ2F0ZVVuc3Vic2NyaWJlcnMsXG4gIHZpIGFzIGFyZVVzakNvbnRlbnRzRXF1YWxFeGNlcHRXaGl0ZXNwYWNlLFxuICB4dCBhcyBhdCxcbiAgRXQgYXMgY2hhckF0LFxuICBadSBhcyBjb2RlUG9pbnRBdCxcbiAgRWkgYXMgY29tcGFyZVNjclJlZnMsXG4gICR1IGFzIGNyZWF0ZVN5bmNQcm94eUZvckFzeW5jT2JqZWN0LFxuICBrdSBhcyBkZWJvdW5jZSxcbiAgd3QgYXMgZGVlcENsb25lLFxuICBDdSBhcyBkZWVwRXF1YWwsXG4gIGxpIGFzIGRlZmF1bHRTY3JSZWYsXG4gIFR1IGFzIGRlc2VyaWFsaXplLFxuICBUbiBhcyBlbmRzV2l0aCxcbiAgcXIgYXMgZW5zdXJlQXJyYXksXG4gIG9pIGFzIGVzY2FwZVN0cmluZ1JlZ2V4cCxcbiAgVGkgYXMgZm9ybWF0Qnl0ZXMsXG4gIGVpIGFzIGZvcm1hdFJlcGxhY2VtZW50U3RyaW5nLFxuICBTbiBhcyBmb3JtYXRSZXBsYWNlbWVudFN0cmluZ1RvQXJyYXksXG4gIERpIGFzIGZvcm1hdFNjclJlZixcbiAgd2kgYXMgZm9ybWF0VGltZVNwYW4sXG4gIGp1IGFzIGdldEFsbE9iamVjdEZ1bmN0aW9uTmFtZXMsXG4gIEZuIGFzIGdldENoYXB0ZXJzRm9yQm9vayxcbiAgeWkgYXMgZ2V0Q3VycmVudExvY2FsZSxcbiAgT3IgYXMgZ2V0RXJyb3JNZXNzYWdlLFxuICBrbiBhcyBnZXRMb2NhbGl6ZUtleUZvclNjcm9sbEdyb3VwSWQsXG4gIGdpIGFzIGdldExvY2FsaXplS2V5c0ZvclNjcm9sbEdyb3VwSWRzLFxuICBkaSBhcyBnZXRMb2NhbGl6ZWRJZEZyb21Cb29rTnVtYmVyLFxuICBxdSBhcyBncm91cEJ5LFxuICBDaSBhcyBodG1sRW5jb2RlLFxuICBPbiBhcyBpbmNsdWRlcyxcbiAgU3QgYXMgaW5kZXhPZixcbiAgVnUgYXMgaXNFcnJvck1lc3NhZ2VBYm91dFBhcmF0ZXh0QmxvY2tpbmdJbnRlcm5ldEFjY2VzcyxcbiAgR3UgYXMgaXNFcnJvck1lc3NhZ2VBYm91dFJlZ2lzdHJ5QXV0aEZhaWx1cmUsXG4gIGlpIGFzIGlzTG9jYWxpemVLZXksXG4gIEt1IGFzIGlzUGxhdGZvcm1FcnJvcixcbiAgYmkgYXMgaXNTZXJpYWxpemFibGUsXG4gIE1lIGFzIGlzU3RyaW5nLFxuICB5dSBhcyBpc1N1YnNldCxcbiAgbXQgYXMgaXNXaGl0ZVNwYWNlLFxuICBJbiBhcyBsYXN0SW5kZXhPZixcbiAgeHUgYXMgbG9jYWxpemVkU3RyaW5nc0RvY3VtZW50U2NoZW1hLFxuICBNdSBhcyBtZW51RG9jdW1lbnRTY2hlbWEsXG4gIEZ1IGFzIG5ld0d1aWQsXG4gIFd1IGFzIG5ld1BsYXRmb3JtRXJyb3IsXG4gIHRpIGFzIG5vcm1hbGl6ZSxcbiAgRXIgYXMgbm9ybWFsaXplU2NyaXB0dXJlU3BhY2VzLFxuICBmaSBhcyBvZmZzZXRCb29rLFxuICBwaSBhcyBvZmZzZXRDaGFwdGVyLFxuICBoaSBhcyBvZmZzZXRWZXJzZSxcbiAgcmkgYXMgb3JkaW5hbENvbXBhcmUsXG4gIG5pIGFzIHBhZEVuZCxcbiAgdWkgYXMgcGFkU3RhcnQsXG4gIE91IGFzIHByb2plY3RTZXR0aW5nc0RvY3VtZW50U2NoZW1hLFxuICBtaSBhcyBzY3JSZWZUb0JCQkNDQyxcbiAgZHIgYXMgc2NyUmVmVG9CQkJDQ0NWVlYsXG4gIFNyIGFzIHNlcmlhbGl6ZSxcbiAgSXUgYXMgc2V0dGluZ3NEb2N1bWVudFNjaGVtYSxcbiAgcHIgYXMgc2xpY2UsXG4gIGhyIGFzIHNwbGl0LFxuICBVciBhcyBzdGFydHNXaXRoLFxuICBjZSBhcyBzdHJpbmdMZW5ndGgsXG4gIHV0IGFzIHN1YnN0cmluZyxcbiAgeG4gYXMgdG9BcnJheSxcbiAgY2kgYXMgdG9LZWJhYkNhc2UsXG4gIHNpIGFzIHRyYW5zZm9ybUFuZEVuc3VyZVJlZ0V4cEFycmF5LFxuICBhaSBhcyB0cmFuc2Zvcm1BbmRFbnN1cmVSZWdFeHBSZWdFeHBBcnJheSxcbiAgZW4gYXMgd2FpdCxcbiAgVXUgYXMgd2FpdEZvckR1cmF0aW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbl9fd2VicGFja19yZXF1aXJlX18uYyA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfXztcblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCJ2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgPyAob2JqKSA9PiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpIDogKG9iaikgPT4gKG9iai5fX3Byb3RvX18pO1xudmFyIGxlYWZQcm90b3R5cGVzO1xuLy8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLy8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vLyBtb2RlICYgMTY6IHJldHVybiB2YWx1ZSB3aGVuIGl0J3MgUHJvbWlzZS1saWtlXG4vLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuXHRpZihtb2RlICYgMSkgdmFsdWUgPSB0aGlzKHZhbHVlKTtcblx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcblx0aWYodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSkge1xuXHRcdGlmKChtb2RlICYgNCkgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuXHRcdGlmKChtb2RlICYgMTYpICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdmFsdWU7XG5cdH1cblx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcblx0dmFyIGRlZiA9IHt9O1xuXHRsZWFmUHJvdG90eXBlcyA9IGxlYWZQcm90b3R5cGVzIHx8IFtudWxsLCBnZXRQcm90byh7fSksIGdldFByb3RvKFtdKSwgZ2V0UHJvdG8oZ2V0UHJvdG8pXTtcblx0Zm9yKHZhciBjdXJyZW50ID0gbW9kZSAmIDIgJiYgdmFsdWU7IHR5cGVvZiBjdXJyZW50ID09ICdvYmplY3QnICYmICF+bGVhZlByb3RvdHlwZXMuaW5kZXhPZihjdXJyZW50KTsgY3VycmVudCA9IGdldFByb3RvKGN1cnJlbnQpKSB7XG5cdFx0T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3VycmVudCkuZm9yRWFjaCgoa2V5KSA9PiAoZGVmW2tleV0gPSAoKSA9PiAodmFsdWVba2V5XSkpKTtcblx0fVxuXHRkZWZbJ2RlZmF1bHQnXSA9ICgpID0+ICh2YWx1ZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChucywgZGVmKTtcblx0cmV0dXJuIG5zO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmYgPSB7fTtcbi8vIFRoaXMgZmlsZSBjb250YWlucyBvbmx5IHRoZSBlbnRyeSBjaHVuay5cbi8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5lID0gKGNodW5rSWQpID0+IHtcblx0cmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uZikucmVkdWNlKChwcm9taXNlcywga2V5KSA9PiB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mW2tleV0oY2h1bmtJZCwgcHJvbWlzZXMpO1xuXHRcdHJldHVybiBwcm9taXNlcztcblx0fSwgW10pKTtcbn07IiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYXN5bmMgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnUgPSAoY2h1bmtJZCkgPT4ge1xuXHQvLyByZXR1cm4gdXJsIGZvciBmaWxlbmFtZXMgYmFzZWQgb24gdGVtcGxhdGVcblx0cmV0dXJuIFwiXCIgKyBjaHVua0lkICsgXCIuYnVuZGxlLmRldi5qc1wiO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIi8vIG5vIGJhc2VVUklcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBjaHVua3Ncbi8vIFwiMVwiIG1lYW5zIFwibG9hZGVkXCIsIG90aGVyd2lzZSBub3QgbG9hZGVkIHlldFxudmFyIGluc3RhbGxlZENodW5rcyA9IHtcblx0XCJtYWluXCI6IDFcbn07XG5cbi8vIG5vIG9uIGNodW5rcyBsb2FkZWRcblxudmFyIGluc3RhbGxDaHVuayA9IChjaHVuaykgPT4ge1xuXHR2YXIgbW9yZU1vZHVsZXMgPSBjaHVuay5tb2R1bGVzLCBjaHVua0lkcyA9IGNodW5rLmlkcywgcnVudGltZSA9IGNodW5rLnJ1bnRpbWU7XG5cdGZvcih2YXIgbW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8obW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcblx0XHR9XG5cdH1cblx0aWYocnVudGltZSkgcnVudGltZShfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKVxuXHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkc1tpXV0gPSAxO1xuXG59O1xuXG4vLyByZXF1aXJlKCkgY2h1bmsgbG9hZGluZyBmb3IgamF2YXNjcmlwdFxuX193ZWJwYWNrX3JlcXVpcmVfXy5mLnJlcXVpcmUgPSAoY2h1bmtJZCwgcHJvbWlzZXMpID0+IHtcblx0Ly8gXCIxXCIgaXMgdGhlIHNpZ25hbCBmb3IgXCJhbHJlYWR5IGxvYWRlZFwiXG5cdGlmKCFpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcblx0XHRpZih0cnVlKSB7IC8vIGFsbCBjaHVua3MgaGF2ZSBKU1xuXHRcdFx0aW5zdGFsbENodW5rKHJlcXVpcmUoXCIuL1wiICsgX193ZWJwYWNrX3JlcXVpcmVfXy51KGNodW5rSWQpKSk7XG5cdFx0fSBlbHNlIGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IDE7XG5cdH1cbn07XG5cbi8vIG5vIGV4dGVybmFsIGluc3RhbGwgY2h1bmtcblxuLy8gbm8gSE1SXG5cbi8vIG5vIEhNUiBtYW5pZmVzdCIsIiIsIi8vIG1vZHVsZSBjYWNoZSBhcmUgdXNlZCBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9tYWluL21haW4udHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=